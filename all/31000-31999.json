[{"original_method":"public void setItem(Object item) {\n    if (item != _item) {\n      Object parent = treeModel().parentTreeNode(item);\n      int level;\n      if (parent == null) {\n        level = 0;\n      }\n      else if (parent == _item) {\n        level = _level + 1;\n      }\n      else if (parent != _lastParent) {\n        level = treeModel().level(item);\n      }\n      else {\n        level = _level;\n      }\n      if (_level > level && parent != null) {\n        _closeCount = (_level - level);\n      }\n      else {\n        _closeCount = 0;\n      }\n      _lastParent = parent;\n      _level = level;\n      _item = item;\n      setValueForBinding(item, \"item\");\n    }\n  }","id":31000,"modified_method":"public void setItem(Object item) {\n    if (item != _item) {\n      Object parent = treeModel().parentTreeNode(item);\n      int level;\n      if (parent == null) {\n        level = 0;\n      }\n      else if (parent == _item) {\n        level = _level + 1;\n      }\n      else if (parent != _lastParent) {\n        level = treeModel().level(item);\n      }\n      else {\n        level = _level;\n      }\n      if (_level > level) {\n        _closeCount = (_level - level);\n      }\n      else {\n        _closeCount = 0;\n      }\n      _lastParent = parent;\n      _level = level;\n      _item = item;\n      setValueForBinding(item, \"item\");\n    }\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public synchronized NSArray childrenTreeNodes() {\n      if (_children == null) {\n        _children = new NSMutableArray();\n        for (int i = 0; i < 10; i++) {\n          _children.addObject(new FakeTreeNode(this, _name + \" Child \" + i));\n        }\n      }\n      return _children;\n    }","id":31001,"modified_method":"public synchronized NSArray childrenTreeNodes() {\n      if (_children == null && _depth < 2) {\n        _children = new NSMutableArray();\n        for (int i = 0; i < 5; i++) {\n          _children.addObject(new FakeTreeNode(this, _name + \" Child \" + i, _depth + 1));\n        }\n      }\n      return _children;\n    }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public FakeTreeNode(Object parentTreeNode, String name) {\n      _parentTreeNode = parentTreeNode;\n      _name = name;\n    }","id":31002,"modified_method":"public FakeTreeNode(Object parentTreeNode, String name, int depth) {\n      _parentTreeNode = parentTreeNode;\n      _name = name;\n      _depth = depth;\n    }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public AjaxTreeExample(WOContext context) {\n    super(context);\n    _rootTreeNode = new FakeTreeNode(null, \"Root\");\n  }","id":31003,"modified_method":"public AjaxTreeExample(WOContext context) {\n    super(context);\n    _rootTreeNode = new FakeTreeNode(null, \"Root\", 0);\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void collapseAll() {\n    _expandedTreeNodes.removeAllObjects();\n  }","id":31004,"modified_method":"public void collapseAll() {\n    if (_allExpanded) {\n      _allExpanded = false;\n    }\n    clearExpandedAndCollapsed();\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isExpanded(Object treeNode) {\n    return _expandedTreeNodes.containsObject(treeNode);\n  }","id":31005,"modified_method":"public boolean isExpanded(Object treeNode) {\n    boolean expanded;\n    if (_allExpanded) {\n      expanded = !_collapsedTreeNodes.containsObject(treeNode);\n    }\n    else {\n      expanded = _expandedTreeNodes.containsObject(treeNode);\n    }\n    return expanded;\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setExpanded(Object treeNode, boolean expanded) {\n    if (expanded) {\n      _expandedTreeNodes.addObject(treeNode);\n    }\n    else {\n      _expandedTreeNodes.removeObject(treeNode);\n    }\n  }","id":31006,"modified_method":"public void setExpanded(Object treeNode, boolean expanded) {\n    if (_rootExpanded && treeNode == _rootTreeNode && !expanded) {\n      return;\n    }\n    \n    if (expanded) {\n      if (_allExpanded) {\n        _collapsedTreeNodes.removeObject(treeNode);\n      }\n      else {\n        _expandedTreeNodes.addObject(treeNode);\n      }\n    }\n    else {\n      if (_allExpanded) {\n        _collapsedTreeNodes.addObject(treeNode);\n      }\n      else {\n        _expandedTreeNodes.removeObject(treeNode);\n      }\n    }\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setRootTreeNode(Object rootTreeNode) {\n    if (rootTreeNode != _rootTreeNode) {\n      _rootTreeNode = rootTreeNode;\n      _expandedTreeNodes.removeAllObjects();\n    }\n  }","id":31007,"modified_method":"public void setRootTreeNode(Object rootTreeNode) {\n    if (rootTreeNode != _rootTreeNode) {\n      _rootTreeNode = rootTreeNode;\n      _expandedTreeNodes.removeAllObjects();\n      _collapsedTreeNodes.removeAllObjects();\n      expandRootIfNecessary();\n    }\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public AjaxTreeModel() {\n    _expandedTreeNodes = new NSMutableSet();\n    _parentTreeNodeKeyPath = \"parent\";\n    _childrenTreeNodesKeyPath = \"children\";\n  }","id":31008,"modified_method":"public AjaxTreeModel() {\n    _expandedTreeNodes = new NSMutableSet();\n    _collapsedTreeNodes = new NSMutableSet();\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns an array of attribute names from the EOEntity of source that are used in the primary key, or in forming\n\t * relationships. These can be presumed to be exposed primary or foreign keys and handled accordingly when copying\n\t * an object.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject to copy attribute values from\n\t * @return an array of attribute names from the EOEntity of source that are used in forming relationships.\n\t */\n\tpublic static NSArray publicAttributeNames(EOEnterpriseObject source) {\n\t\t// These are cached on EOEntity name as an optimization.\n\n\t\tEOEntity entity = EOUtilities.entityForObject(source.editingContext(), source);\n\t\tNSArray publicAttributeNames = (NSArray) EOEnterpriseObjectSerializer.publicAttributes.objectForKey(entity.name());\n\t\t//AK: should use clientProperties from EM\n\t\tif (publicAttributeNames == null) {\n\t\t\tNSMutableSet publicAttributeSet = new NSMutableSet();\n\t\t\tNSArray publicAttributes = ERXProperties.arrayForKey(\"er.ajax.json.\" + entity.name() + \".attributes\");\n\t\t\tif (publicAttributes != null) {\n\t\t\t\tpublicAttributeSet.addObjectsFromArray(publicAttributes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublicAttributes = source.attributeKeys();\n\t\t\t\tpublicAttributeSet.addObjectsFromArray(publicAttributes);\n\t\t\t\tNSArray classProperties = entity.classPropertyNames();\n\t\t\t\tpublicAttributeNames = publicAttributeSet.setByIntersectingSet(new NSSet(classProperties)).allObjects();\n\t\t\t}\n\t\t\tEOEnterpriseObjectSerializer.publicAttributes.setObjectForKey(publicAttributeNames, entity.name());\n\t\t}\n\n\t\treturn publicAttributeNames;\n\t}","id":31009,"modified_method":"/**\n\t * Returns an array of attribute names from the EOEntity of source that should be marshalled to the client.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject to copy attribute values from\n\t * @return an array of attribute names from the EOEntity of source that should be marshalled\n\t */\n\t@SuppressWarnings({ \"unchecked\", \"cast\" })\n\tpublic static NSArray<String> publicAttributeNames(EOEnterpriseObject source) {\n\t\t// These are cached on EOEntity name as an optimization.\n\n\t\tEOEntity entity = EOUtilities.entityForObject(source.editingContext(), source);\n\t\tNSArray<String> attributeNames = EOEnterpriseObjectSerializer.publicAttributeNames.objectForKey(entity.name());\n\t\t//AK: should use clientProperties from EM\n\t\tif (attributeNames == null) {\n\t\t\tattributeNames = (NSArray<String>)ERXProperties.arrayForKey(\"er.ajax.json.\" + entity.name() + \".attributes\");\n\t\t\tif (attributeNames == null) {\n\t\t\t\t//publicAttributes = source.attributeKeys();\n\t\t\t\t//publicAttributeSet.addObjectsFromArray(publicAttributes);\n\t\t\t\t//NSArray classProperties = entity.classPropertyNames();\n\t\t\t\t//publicAttributeNames = publicAttributeSet.setByIntersectingSet(new NSSet(classProperties)).allObjects();\n\t\t\t\tattributeNames = entity.classPropertyNames();\n\t\t\t}\n\t\t\tEOEnterpriseObjectSerializer.publicAttributeNames.setObjectForKey(attributeNames, entity.name());\n\t\t}\n\n\t\treturn attributeNames;\n\t}","commit_id":"d10f9642a8491dcfa1f5ae64734714ecb9c4e962","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * This copies the attributes from the source EOEnterpriseObject to the destination. Only attributes which are class\n\t * properties are copied. However if an attribute is a class property and also used in a relationship it is assumed\n\t * to be an exposed primary or foreign key and not copied. Such attributes are set to null. See\n\t * exposedKeyAttributeNames for details on how this is determined. It can be used when creating custom\n\t * implementations of the duplicate() method in EOCopyable.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject to copy attribute values from\n\t * @param destination\n\t *            the EOEnterpriseObject to copy attribute values to\n\t */\n\tpublic void addAttributes(SerializerState state, EOEnterpriseObject source, JSONObject destination) throws MarshallException {\n\t\tboolean useEO = false;\n\t\ttry {\n\t\t\tJSONObject eoData = destination;\n\t\t\tif(useEO) {\n\t\t\t\tdestination = new JSONObject();\n\t\t\t\tdestination.put(\"eo\", eoData);\n\t\t\t\tstate.push(source, eoData, \"eo\");\n\t\t\t}\n\t\t\tEOClassDescription cd = source.classDescription();\n\t\t\tNSArray publicAttributeNames = attributeNames(source);\n\t\t\tfor (Enumeration e = publicAttributeNames.objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\tString key = (String) e.nextElement();\n\t\t\t\tObject jsonValue;\n\t\t\t\tif(cd.toManyRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tJSONObject rel = new JSONObject();\n\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOArrayFault\");\n\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n\t\t\t\t\trel.put(\"relationshipName\", key);\n\t\t\t\t\tjsonValue = rel;\n\t\t\t\t} else if (cd.toOneRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tJSONObject rel = new JSONObject();\n\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOFault\");\n\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n\t\t\t\t\trel.put(\"relationshipName\", key);\n\t\t\t\t\tjsonValue = rel;\n\t\t\t\t} else {\n\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t}\n\t\t\t\tif (JSONSerializer.CIRC_REF_OR_DUPLICATE == jsonValue)\n\t\t\t\t\tdestination.put(key, JSONObject.NULL);\n\t\t\t\telse\n\t\t\t\t\tdestination.put(key, jsonValue);\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Failed to marshall EO.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif(useEO) {\n\t\t\t\tstate.pop();\n\t\t\t}\n\t\t}\n\t}","id":31010,"modified_method":"/**\n\t * This copies the attributes from the source EOEnterpriseObject to the destination. Only attributes which are class\n\t * properties are copied. However if an attribute is a class property and also used in a relationship it is assumed\n\t * to be an exposed primary or foreign key and not copied. Such attributes are set to null. See\n\t * exposedKeyAttributeNames for details on how this is determined. It can be used when creating custom\n\t * implementations of the duplicate() method in EOCopyable.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject to copy attribute values from\n\t * @param destination\n\t *            the EOEnterpriseObject to copy attribute values to\n\t */\n\tpublic void addAttributes(SerializerState state, EOEnterpriseObject source, JSONObject destination) throws MarshallException {\n\t\tboolean useEO = false;\n\t\ttry {\n\t\t\tJSONObject eoData = destination;\n\t\t\tif(useEO) {\n\t\t\t\tdestination = new JSONObject();\n\t\t\t\tdestination.put(\"eo\", eoData);\n\t\t\t\tstate.push(source, eoData, \"eo\");\n\t\t\t}\n\t\t\tEOClassDescription cd = source.classDescription();\n\t\t\tNSArray<String> attributeNames = _publicAttributeNames(source);\n\t\t\tNSArray<String> relationshipNames = _includedRelationshipNames(source);\n\t\t\t\n\t\t\tfor (Enumeration e = attributeNames.objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\tString key = (String) e.nextElement();\n\t\t\t\tObject jsonValue;\n\t\t\t\tif(cd.toManyRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tif (relationshipNames.containsObject(key)) {\n\t\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tJSONObject rel = new JSONObject();\n\t\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOArrayFault\");\n\t\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n\t\t\t\t\t\trel.put(\"relationshipName\", key);\n\t\t\t\t\t\tjsonValue = rel;\n\t\t\t\t\t}\n\t\t\t\t} else if (cd.toOneRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tif (relationshipNames.containsObject(key)) {\n\t\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tJSONObject rel = new JSONObject();\n\t\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOFault\");\n\t\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n\t\t\t\t\t\trel.put(\"relationshipName\", key);\n\t\t\t\t\t\tjsonValue = rel;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t}\n\t\t\t\tif (JSONSerializer.CIRC_REF_OR_DUPLICATE == jsonValue) {\n\t\t\t\t\tdestination.put(key, JSONObject.NULL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdestination.put(key, jsonValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Failed to marshall EO.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif(useEO) {\n\t\t\t\tstate.pop();\n\t\t\t}\n\t\t}\n\t}","commit_id":"d10f9642a8491dcfa1f5ae64734714ecb9c4e962","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Override to return the appropriate attribute names.\n\t * @param eo\n\t * @return\n\t */\n\tprotected NSArray<String> attributeNames(EOEnterpriseObject eo) {\n\t\treturn EOEnterpriseObjectSerializer.publicAttributeNames(eo);\n\t}","id":31011,"modified_method":"/**\n\t * Override to return the appropriate attribute names.\n\t * @param eo\n\t * @return\n\t */\n\tprotected NSArray<String> _publicAttributeNames(EOEnterpriseObject eo) {\n\t\treturn EOEnterpriseObjectSerializer.publicAttributeNames(eo);\n\t}","commit_id":"d10f9642a8491dcfa1f5ae64734714ecb9c4e962","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean validationExceptionOccurredForPropertyKey() {\n        return d2wContext().propertyKey() != null ? keyPathsWithValidationExceptions().containsObject(d2wContext().propertyKey()) : false;\n    }","id":31012,"modified_method":"public boolean validationExceptionOccurredForPropertyKey() {\n        if (d2wContext().propertyKey() == null) {\n            return false;\n        } else {\n            String propertyKey = d2wContext().propertyKey();\n            boolean contains = keyPathsWithValidationExceptions().containsObject(propertyKey);\n            if (log.isDebugEnabled())\n            \tlog.debug(\"propertyKey=\"+propertyKey+\", keyPathsWithValidationExceptions=\"+keyPathsWithValidationExceptions());\n            return contains;\n        }\n    }","commit_id":"f6359e8a9df39c7a7b38a113c32c8060d7a8dea3","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isStateless() { return true; }","id":31013,"modified_method":"/**\n     * Component is stateless\n     * @return true\n     */\n    public boolean isStateless() { return true; }","commit_id":"3949bdad7ceaa7d52cafff98354a7d0b419c4e64","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean listContainsItem() {\n        NSArray list=(NSArray)valueForBinding(\"list\");\n        Object item=valueForBinding(\"item\");\n        return(list.containsObject(item));\n    }","id":31014,"modified_method":"/**\n     * Tests if the bound item is contained within the\n     * bound list.\n     * @return result of comparision\n     */\n    // ENHANCEME: Should support the List interface\n    public boolean listContainsItem() {\n        NSArray list=(NSArray)valueForBinding(\"list\");\n        Object item=valueForBinding(\"item\");\n        return item != null && list.containsObject(item);\n    }","commit_id":"3949bdad7ceaa7d52cafff98354a7d0b419c4e64","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXListContainsItemConditional(WOContext aContext) {\n        super(aContext);\n    }","id":31015,"modified_method":"/**\n     * Public constructor.\n     * @param aContext a context\n     */\n    public ERXListContainsItemConditional(WOContext aContext) {\n        super(aContext);\n    }","commit_id":"3949bdad7ceaa7d52cafff98354a7d0b419c4e64","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isStateless() { return true; }","id":31016,"modified_method":"/**\n     * Component is stateless\n     * @return true\n     */\n    public boolean isStateless() { return true; }","commit_id":"3949bdad7ceaa7d52cafff98354a7d0b419c4e64","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXNonNullConditional(WOContext aContext) {\n        super(aContext);\n    }","id":31017,"modified_method":"/**\n     * Public constructor\n     * @param aContext a context\n     */\n    public ERXNonNullConditional(WOContext aContext) {\n        super(aContext);\n    }","commit_id":"3949bdad7ceaa7d52cafff98354a7d0b419c4e64","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isNonNull() { return valueForBinding(\"condition\") != null; }","id":31018,"modified_method":"/**\n     * tests if the object returned from the binding \n     * condition is not null.\n     * @return result of comparison.\n     */\n    public boolean isNonNull() { return valueForBinding(\"condition\") != null; }","commit_id":"3949bdad7ceaa7d52cafff98354a7d0b419c4e64","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void performRefactoring(UsageInfo[] usageInfos) {\n    buildClass();\n    if (delegationRequired) {\n      buildDelegate();\n    }\n    super.performRefactoring(usageInfos);\n  }","id":31019,"modified_method":"protected void performRefactoring(UsageInfo[] usageInfos) {\n    if (!buildClass()) return;\n    if (delegationRequired) {\n      buildDelegate();\n    }\n    super.performRefactoring(usageInfos);\n  }","commit_id":"e6aaf4070f6a1a3ef507bb11f298c785eae6e008","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findUsagesForInnerClass(PsiClass innerClass, List<FixableUsageInfo> usages) {\n    final PsiManager psiManager = innerClass.getManager();\n    final Project project = psiManager.getProject();\n    final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    final Iterable<PsiReference> calls = ReferencesSearch.search(innerClass, scope);\n    final String innerName = innerClass.getQualifiedName();\n    final String newInnerClassName = StringUtil.getQualifiedName(newPackageName, newClassName) + innerName.substring(sourceClass.getQualifiedName().length());\n    boolean hasExternalReference = false;\n    for (PsiReference reference : calls) {\n      final PsiElement referenceElement = reference.getElement();\n      if (referenceElement instanceof PsiJavaCodeReferenceElement) {\n        if (!isInMovedElement(referenceElement)) {\n\n          usages.add(new ReplaceClassReference((PsiJavaCodeReferenceElement)referenceElement, newInnerClassName));\n          hasExternalReference = true;\n        }\n      }\n    }\n    if (hasExternalReference) {\n      innerClassesToMakePublic.add(innerClass);\n    }\n  }","id":31020,"modified_method":"private void findUsagesForInnerClass(PsiClass innerClass, List<FixableUsageInfo> usages) {\n    final PsiManager psiManager = innerClass.getManager();\n    final Project project = psiManager.getProject();\n    final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    final Iterable<PsiReference> calls = ReferencesSearch.search(innerClass, scope);\n    final String innerName = innerClass.getQualifiedName();\n    assert innerName != null;\n    final String sourceClassQualifiedName = sourceClass.getQualifiedName();\n    assert sourceClassQualifiedName != null;\n    final String newInnerClassName = StringUtil.getQualifiedName(newPackageName, newClassName) + innerName.substring(sourceClassQualifiedName.length());\n    boolean hasExternalReference = false;\n    for (PsiReference reference : calls) {\n      final PsiElement referenceElement = reference.getElement();\n      if (referenceElement instanceof PsiJavaCodeReferenceElement) {\n        if (!isInMovedElement(referenceElement)) {\n\n          usages.add(new ReplaceClassReference((PsiJavaCodeReferenceElement)referenceElement, newInnerClassName));\n          hasExternalReference = true;\n        }\n      }\n    }\n    if (hasExternalReference) {\n      innerClassesToMakePublic.add(innerClass);\n    }\n  }","commit_id":"e6aaf4070f6a1a3ef507bb11f298c785eae6e008","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildClass() {\n    final PsiManager manager = sourceClass.getManager();\n    final Project project = sourceClass.getProject();\n    final ExtractedClassBuilder extractedClassBuilder = new ExtractedClassBuilder();\n    extractedClassBuilder.setProject(myProject);\n    extractedClassBuilder.setClassName(newClassName);\n    extractedClassBuilder.setPackageName(newPackageName);\n    extractedClassBuilder.setOriginalClassName(sourceClass.getQualifiedName());\n    extractedClassBuilder.setRequiresBackPointer(requiresBackpointer);\n    for (PsiField field : fields) {\n      extractedClassBuilder.addField(field);\n    }\n    for (PsiMethod method : methods) {\n      extractedClassBuilder.addMethod(method);\n    }\n    for (PsiClass innerClass : innerClasses) {\n      extractedClassBuilder.addInnerClass(innerClass, innerClassesToMakePublic.contains(innerClass));\n    }\n    extractedClassBuilder.setTypeArguments(typeParams);\n    final List<PsiClass> interfaces = calculateInterfacesSupported();\n    extractedClassBuilder.setInterfaces(interfaces);\n\n    final String classString;\n    try {\n      classString = extractedClassBuilder.buildBeanClass();\n    }\n    catch (IOException e) {\n      logger.error(e);\n      return;\n    }\n\n    try {\n      final PsiFile containingFile = sourceClass.getContainingFile();\n\n      final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n      final Module module = ModuleUtil.findModuleForPsiElement(containingFile);\n      final PsiDirectory directory = PackageUtil.findOrCreateDirectoryForPackage(module, newPackageName, containingDirectory, false);\n      if (directory != null) {\n        final PsiFile newFile = PsiFileFactory.getInstance(project).createFileFromText(newClassName + \".java\", classString);\n        final PsiElement addedFile = directory.add(newFile);\n        final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n        final PsiElement shortenedFile = JavaCodeStyleManager.getInstance(project).shortenClassReferences(addedFile);\n        codeStyleManager.reformat(shortenedFile);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      logger.error(e);\n    }\n  }","id":31021,"modified_method":"private boolean buildClass() {\n    final PsiManager manager = sourceClass.getManager();\n    final Project project = sourceClass.getProject();\n    final ExtractedClassBuilder extractedClassBuilder = new ExtractedClassBuilder();\n    extractedClassBuilder.setProject(myProject);\n    extractedClassBuilder.setClassName(newClassName);\n    extractedClassBuilder.setPackageName(newPackageName);\n    extractedClassBuilder.setOriginalClassName(sourceClass.getQualifiedName());\n    extractedClassBuilder.setRequiresBackPointer(requiresBackpointer);\n    for (PsiField field : fields) {\n      extractedClassBuilder.addField(field);\n    }\n    for (PsiMethod method : methods) {\n      extractedClassBuilder.addMethod(method);\n    }\n    for (PsiClass innerClass : innerClasses) {\n      extractedClassBuilder.addInnerClass(innerClass, innerClassesToMakePublic.contains(innerClass));\n    }\n    extractedClassBuilder.setTypeArguments(typeParams);\n    final List<PsiClass> interfaces = calculateInterfacesSupported();\n    extractedClassBuilder.setInterfaces(interfaces);\n\n    final String classString = extractedClassBuilder.buildBeanClass();\n\n    try {\n      final PsiFile containingFile = sourceClass.getContainingFile();\n\n      final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n      final Module module = ModuleUtil.findModuleForPsiElement(containingFile);\n      assert module != null;\n      final PsiDirectory directory = PackageUtil.findOrCreateDirectoryForPackage(module, newPackageName, containingDirectory, false);\n      if (directory != null) {\n        final PsiFile newFile = PsiFileFactory.getInstance(project).createFileFromText(newClassName + \".java\", classString);\n        final PsiElement addedFile = directory.add(newFile);\n        final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n        final PsiElement shortenedFile = JavaCodeStyleManager.getInstance(project).shortenClassReferences(addedFile);\n        codeStyleManager.reformat(shortenedFile);\n      } else {\n        return false;\n      }\n    }\n    catch (IncorrectOperationException e) {\n      return false;\n    }\n    return true;\n  }","commit_id":"e6aaf4070f6a1a3ef507bb11f298c785eae6e008","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildDelegate() {\n    final PsiManager manager = sourceClass.getManager();\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n    final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n    @NonNls final StringBuilder fieldBuffer = new StringBuilder();\n    final String delegateVisibility = calculateDelegateVisibility();\n    fieldBuffer.append(delegateVisibility + ' ');\n    fieldBuffer.append(\"final \");\n    final String fullyQualifiedName = StringUtil.getQualifiedName(newPackageName, newClassName);\n    fieldBuffer.append(fullyQualifiedName);\n    if (!typeParams.isEmpty()) {\n      fieldBuffer.append('<');\n      for (PsiTypeParameter typeParameter : typeParams) {\n        fieldBuffer.append(typeParameter.getName());\n      }\n      fieldBuffer.append('>');\n    }\n    fieldBuffer.append(' ');\n    fieldBuffer.append(delegateFieldName);\n    fieldBuffer.append('=');\n    fieldBuffer.append(\"new \" + fullyQualifiedName);\n    if (!typeParams.isEmpty()) {\n      fieldBuffer.append('<');\n      for (PsiTypeParameter typeParameter : typeParams) {\n        fieldBuffer.append(typeParameter.getName());\n      }\n      fieldBuffer.append('>');\n    }\n    fieldBuffer.append('(');\n    boolean isFirst = true;\n    if (requiresBackpointer) {\n      fieldBuffer.append(\"this\");\n      isFirst = false;\n    }\n    for (PsiField field : fields) {\n      if (field.hasModifierProperty(PsiModifier.STATIC)) {\n        continue;\n      }\n      if (!field.hasInitializer()) {\n        continue;\n      }\n      final PsiExpression initializer = field.getInitializer();\n      if (PsiUtil.isConstantExpression(initializer)) {\n        continue;\n      }\n      if (!isFirst) {\n        fieldBuffer.append(\", \");\n      }\n      isFirst = false;\n      assert initializer != null;\n      fieldBuffer.append(initializer.getText());\n    }\n\n    fieldBuffer.append(\");\");\n    try {\n      final String fieldString = fieldBuffer.toString();\n      final PsiField field = factory.createFieldFromText(fieldString, sourceClass);\n      final PsiElement newField = sourceClass.add(field);\n      codeStyleManager.reformat(JavaCodeStyleManager.getInstance(myProject).shortenClassReferences(newField));\n    }\n    catch (IncorrectOperationException e) {\n      logger.error(e);\n    }\n  }","id":31022,"modified_method":"private void buildDelegate() {\n    final PsiManager manager = sourceClass.getManager();\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n    final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n    @NonNls final StringBuilder fieldBuffer = new StringBuilder();\n    final String delegateVisibility = calculateDelegateVisibility();\n    fieldBuffer.append(delegateVisibility).append(' ');\n    fieldBuffer.append(\"final \");\n    final String fullyQualifiedName = StringUtil.getQualifiedName(newPackageName, newClassName);\n    fieldBuffer.append(fullyQualifiedName);\n    if (!typeParams.isEmpty()) {\n      fieldBuffer.append('<');\n      for (PsiTypeParameter typeParameter : typeParams) {\n        fieldBuffer.append(typeParameter.getName());\n      }\n      fieldBuffer.append('>');\n    }\n    fieldBuffer.append(' ');\n    fieldBuffer.append(delegateFieldName);\n    fieldBuffer.append('=');\n    fieldBuffer.append(\"new \").append(fullyQualifiedName);\n    if (!typeParams.isEmpty()) {\n      fieldBuffer.append('<');\n      for (PsiTypeParameter typeParameter : typeParams) {\n        fieldBuffer.append(typeParameter.getName());\n      }\n      fieldBuffer.append('>');\n    }\n    fieldBuffer.append('(');\n    boolean isFirst = true;\n    if (requiresBackpointer) {\n      fieldBuffer.append(\"this\");\n      isFirst = false;\n    }\n    for (PsiField field : fields) {\n      if (field.hasModifierProperty(PsiModifier.STATIC)) {\n        continue;\n      }\n      if (!field.hasInitializer()) {\n        continue;\n      }\n      final PsiExpression initializer = field.getInitializer();\n      if (PsiUtil.isConstantExpression(initializer)) {\n        continue;\n      }\n      if (!isFirst) {\n        fieldBuffer.append(\", \");\n      }\n      isFirst = false;\n      assert initializer != null;\n      fieldBuffer.append(initializer.getText());\n    }\n\n    fieldBuffer.append(\");\");\n    try {\n      final String fieldString = fieldBuffer.toString();\n      final PsiField field = factory.createFieldFromText(fieldString, sourceClass);\n      final PsiElement newField = sourceClass.add(field);\n      codeStyleManager.reformat(JavaCodeStyleManager.getInstance(myProject).shortenClassReferences(newField));\n    }\n    catch (IncorrectOperationException e) {\n      logger.error(e);\n    }\n  }","commit_id":"e6aaf4070f6a1a3ef507bb11f298c785eae6e008","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ExtractClassDialog(PsiClass sourceClass, PsiMember selectedMember) {\n    super(sourceClass.getProject(), true);\n    setModal(true);\n    setTitle(RefactorJBundle.message(\"extract.class.title\"));\n    this.sourceClass = sourceClass;\n    final DocumentListener docListener = new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        validateButtons();\n      }\n    };\n    classNameField = new JTextField();\n    final PsiFile file = sourceClass.getContainingFile();\n    final String text = file instanceof PsiJavaFile ? ((PsiJavaFile)file).getPackageName() : \"\";\n    packageTextField = new PackageNameReferenceEditorCombo(text, myProject, \"ExtractClass.RECENTS_KEY\", RefactorJBundle.message(\"choose.destination.package.label\"));\n    packageTextField.getChildComponent().getDocument().addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n      @Override\n      public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n        validateButtons();\n      }\n    });\n    classNameField.getDocument().addDocumentListener(docListener);\n    sourceClassTextField = new JTextField();\n    final MemberInfo.Filter<PsiMember> filter = new MemberInfo.Filter<PsiMember>() {\n      public boolean includeMember(PsiMember element) {\n        if (element instanceof PsiMethod) {\n          return !((PsiMethod)element).isConstructor() && ((PsiMethod)element).getBody() != null;\n        }\n        else if (element instanceof PsiField) {\n          return true;\n        }\n        else if (element instanceof PsiClass) {\n          return PsiTreeUtil.isAncestor(ExtractClassDialog.this.sourceClass, element, true);\n        }\n        return false;\n      }\n    };\n    memberInfo = MemberInfo.extractClassMembers(this.sourceClass, filter, false);\n    for (MemberInfo info : memberInfo) {\n      if (info.getMember().equals(selectedMember)) {\n        info.setChecked(true);\n      }\n    }\n    super.init();\n    sourceClassTextField.setText(sourceClass.getQualifiedName());\n    validateButtons();\n  }","id":31023,"modified_method":"ExtractClassDialog(PsiClass sourceClass, PsiMember selectedMember) {\n    super(sourceClass.getProject(), true);\n    setModal(true);\n    setTitle(RefactorJBundle.message(\"extract.class.title\"));\n    myVisibilityPanel = new VisibilityPanel(true, true);\n    myVisibilityPanel.setVisibility(null);\n    this.sourceClass = sourceClass;\n    final DocumentListener docListener = new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        validateButtons();\n      }\n    };\n    classNameField = new JTextField();\n    final PsiFile file = sourceClass.getContainingFile();\n    final String text = file instanceof PsiJavaFile ? ((PsiJavaFile)file).getPackageName() : \"\";\n    packageTextField = new PackageNameReferenceEditorCombo(text, myProject, \"ExtractClass.RECENTS_KEY\", RefactorJBundle.message(\"choose.destination.package.label\"));\n    packageTextField.getChildComponent().getDocument().addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n      @Override\n      public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n        validateButtons();\n      }\n    });\n    classNameField.getDocument().addDocumentListener(docListener);\n    sourceClassTextField = new JTextField();\n    final MemberInfo.Filter<PsiMember> filter = new MemberInfo.Filter<PsiMember>() {\n      public boolean includeMember(PsiMember element) {\n        if (element instanceof PsiMethod) {\n          return !((PsiMethod)element).isConstructor() && ((PsiMethod)element).getBody() != null;\n        }\n        else if (element instanceof PsiField) {\n          return true;\n        }\n        else if (element instanceof PsiClass) {\n          return PsiTreeUtil.isAncestor(ExtractClassDialog.this.sourceClass, element, true);\n        }\n        return false;\n      }\n    };\n    memberInfo = MemberInfo.extractClassMembers(this.sourceClass, filter, false);\n    for (MemberInfo info : memberInfo) {\n      if (info.getMember().equals(selectedMember)) {\n        info.setChecked(true);\n      }\n    }\n    super.init();\n    sourceClassTextField.setText(sourceClass.getQualifiedName());\n    validateButtons();\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    final JPanel panel = new JPanel(new BorderLayout());\n    final MemberSelectionPanel memberSelectionPanel =\n      new MemberSelectionPanel(RefactorJBundle.message(\"members.to.extract.label\"), memberInfo, null);\n    final MemberSelectionTable table = memberSelectionPanel.getTable();\n    table.setMemberInfoModel(new DelegatingMemberInfoModel<PsiMember, MemberInfo>(table.getMemberInfoModel()) {\n      public Boolean isFixedAbstract(MemberInfo member) {\n        return Boolean.TRUE;\n      }\n\n      @Override\n      public int checkForProblems(@NotNull final MemberInfo member) {\n        final PsiMember cause = getCause(member);\n        if (member.isChecked() && cause != null) return ERROR;\n        if (!member.isChecked() && cause != null) return WARNING;\n        return OK;\n      }\n\n      @Override\n      public String getTooltipText(final MemberInfo member) {\n        final PsiMember cause = getCause(member);\n        if (cause != null) {\n          final String presentation = SymbolPresentationUtil.getSymbolPresentableText(cause);\n          if (member.isChecked()) {\n            return \"Depends on \" + presentation + \" from \" + sourceClass.getName();\n          } else {\n            final String className = getClassName();\n            return \"Depends on \" + presentation + \" from new class\" + (className.length() > 0 ? \": \" + className : \"\");\n          }\n        }\n        return null;\n      }\n\n      private PsiMember getCause(final MemberInfo member) {\n        PsiMember cause = myMember2CauseMap.get(member);\n\n        if (cause != null) return cause;\n\n        final BackpointerUsageVisitor visitor;\n        if (member.isChecked()) {\n          visitor = new BackpointerUsageVisitor(getFieldsToExtract(), getClassesToExtract(), getMethodsToExtract(), sourceClass);\n        }\n        else {\n          visitor =\n            new BackpointerUsageVisitor(getMembersToExtract(false, PsiField.class), getMembersToExtract(false, PsiClass.class),\n                                        getMembersToExtract(false, PsiMethod.class), sourceClass, false);\n        }\n\n        member.getMember().accept(visitor);\n        cause = visitor.getCause();\n        myMember2CauseMap.put(member, cause);\n        return cause;\n      }\n    });\n    panel.add(memberSelectionPanel, BorderLayout.CENTER);\n    table.addMemberInfoChangeListener(this);\n\n    myGenerateAccessorsCb = new JCheckBox(\"Generate accessors\");\n    myGenerateAccessorsCb.setMnemonic('G');\n    panel.add(myGenerateAccessorsCb, BorderLayout.SOUTH);\n    return panel;\n  }","id":31024,"modified_method":"protected JComponent createCenterPanel() {\n    final JPanel panel = new JPanel(new BorderLayout());\n    final MemberSelectionPanel memberSelectionPanel =\n      new MemberSelectionPanel(RefactorJBundle.message(\"members.to.extract.label\"), memberInfo, null);\n    final MemberSelectionTable table = memberSelectionPanel.getTable();\n    table.setMemberInfoModel(new DelegatingMemberInfoModel<PsiMember, MemberInfo>(table.getMemberInfoModel()) {\n      public Boolean isFixedAbstract(MemberInfo member) {\n        return Boolean.TRUE;\n      }\n\n      @Override\n      public int checkForProblems(@NotNull final MemberInfo member) {\n        final PsiMember cause = getCause(member);\n        if (member.isChecked() && cause != null) return ERROR;\n        if (!member.isChecked() && cause != null) return WARNING;\n        return OK;\n      }\n\n      @Override\n      public String getTooltipText(final MemberInfo member) {\n        final PsiMember cause = getCause(member);\n        if (cause != null) {\n          final String presentation = SymbolPresentationUtil.getSymbolPresentableText(cause);\n          if (member.isChecked()) {\n            return \"Depends on \" + presentation + \" from \" + sourceClass.getName();\n          } else {\n            final String className = getClassName();\n            return \"Depends on \" + presentation + \" from new class\" + (className.length() > 0 ? \": \" + className : \"\");\n          }\n        }\n        return null;\n      }\n\n      private PsiMember getCause(final MemberInfo member) {\n        PsiMember cause = myMember2CauseMap.get(member);\n\n        if (cause != null) return cause;\n\n        final BackpointerUsageVisitor visitor;\n        if (member.isChecked()) {\n          visitor = new BackpointerUsageVisitor(getFieldsToExtract(), getClassesToExtract(), getMethodsToExtract(), sourceClass);\n        }\n        else {\n          visitor =\n            new BackpointerUsageVisitor(getMembersToExtract(false, PsiField.class), getMembersToExtract(false, PsiClass.class),\n                                        getMembersToExtract(false, PsiMethod.class), sourceClass, false);\n        }\n\n        member.getMember().accept(visitor);\n        cause = visitor.getCause();\n        myMember2CauseMap.put(member, cause);\n        return cause;\n      }\n    });\n    panel.add(memberSelectionPanel, BorderLayout.CENTER);\n    table.addMemberInfoChangeListener(this);\n\n    myGenerateAccessorsCb = new JCheckBox(\"Generate accessors\");\n    myGenerateAccessorsCb.setMnemonic('G');\n    panel.add(myGenerateAccessorsCb, BorderLayout.SOUTH);\n\n    panel.add(myVisibilityPanel, BorderLayout.EAST);\n    return panel;\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAction() {\n\n    final List<PsiField> fields = getFieldsToExtract();\n    final List<PsiMethod> methods = getMethodsToExtract();\n    final List<PsiClass> classes = getClassesToExtract();\n    final String newClassName = getClassName();\n    final String packageName = getPackageName();\n\n    final ExtractClassProcessor processor = new ExtractClassProcessor(sourceClass, fields, methods, classes, packageName, newClassName, isGenerateAccessors());\n    invokeRefactoring(processor);\n  }","id":31025,"modified_method":"protected void doAction() {\n\n    final List<PsiField> fields = getFieldsToExtract();\n    final List<PsiMethod> methods = getMethodsToExtract();\n    final List<PsiClass> classes = getClassesToExtract();\n    final String newClassName = getClassName();\n    final String packageName = getPackageName();\n\n    final ExtractClassProcessor processor = new ExtractClassProcessor(sourceClass, fields, methods, classes, packageName, newClassName, myVisibilityPanel.getVisibility(), isGenerateAccessors());\n    invokeRefactoring(processor);\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean buildClass() {\n    final PsiManager manager = sourceClass.getManager();\n    final Project project = sourceClass.getProject();\n    final ExtractedClassBuilder extractedClassBuilder = new ExtractedClassBuilder();\n    extractedClassBuilder.setProject(myProject);\n    extractedClassBuilder.setClassName(newClassName);\n    extractedClassBuilder.setPackageName(newPackageName);\n    extractedClassBuilder.setOriginalClassName(sourceClass.getQualifiedName());\n    extractedClassBuilder.setRequiresBackPointer(requiresBackpointer);\n    for (PsiField field : fields) {\n      extractedClassBuilder.addField(field);\n    }\n    for (PsiMethod method : methods) {\n      extractedClassBuilder.addMethod(method);\n    }\n    for (PsiClass innerClass : innerClasses) {\n      extractedClassBuilder.addInnerClass(innerClass, innerClassesToMakePublic.contains(innerClass));\n    }\n    extractedClassBuilder.setTypeArguments(typeParams);\n    final List<PsiClass> interfaces = calculateInterfacesSupported();\n    extractedClassBuilder.setInterfaces(interfaces);\n\n    if (myGenerateAccessors) {\n      final NecessaryAccessorsVisitor visitor = new NecessaryAccessorsVisitor() {\n        @Override\n        protected boolean isProhibitedReference(PsiField field) {\n          if (fields.contains(field)) {\n            return true;\n          }\n          if (innerClasses.contains(field.getContainingClass())) {\n            return true;\n          }\n          return false;\n        }\n      };\n      sourceClass.accept(visitor);\n      extractedClassBuilder.setFieldsNeedingGetters(visitor.getFieldsNeedingGetter());\n      extractedClassBuilder.setFieldsNeedingSetters(visitor.getFieldsNeedingSetter());\n    }\n\n    final String classString = extractedClassBuilder.buildBeanClass();\n\n    try {\n      final PsiFile containingFile = sourceClass.getContainingFile();\n\n      final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n      final Module module = ModuleUtil.findModuleForPsiElement(containingFile);\n      assert module != null;\n      final PsiDirectory directory = PackageUtil.findOrCreateDirectoryForPackage(module, newPackageName, containingDirectory, false);\n      if (directory != null) {\n        final PsiFile newFile = PsiFileFactory.getInstance(project).createFileFromText(newClassName + \".java\", classString);\n        final PsiElement addedFile = directory.add(newFile);\n        final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n        final PsiElement shortenedFile = JavaCodeStyleManager.getInstance(project).shortenClassReferences(addedFile);\n        codeStyleManager.reformat(shortenedFile);\n      } else {\n        return false;\n      }\n    }\n    catch (IncorrectOperationException e) {\n      return false;\n    }\n    return true;\n  }","id":31026,"modified_method":"private PsiClass buildClass() {\n    final PsiManager manager = sourceClass.getManager();\n    final Project project = sourceClass.getProject();\n    final ExtractedClassBuilder extractedClassBuilder = new ExtractedClassBuilder();\n    extractedClassBuilder.setProject(myProject);\n    extractedClassBuilder.setClassName(newClassName);\n    extractedClassBuilder.setPackageName(newPackageName);\n    extractedClassBuilder.setOriginalClassName(sourceClass.getQualifiedName());\n    extractedClassBuilder.setRequiresBackPointer(requiresBackpointer);\n    for (PsiField field : fields) {\n      extractedClassBuilder.addField(field);\n    }\n    for (PsiMethod method : methods) {\n      extractedClassBuilder.addMethod(method);\n    }\n    for (PsiClass innerClass : innerClasses) {\n      extractedClassBuilder.addInnerClass(innerClass, innerClassesToMakePublic.contains(innerClass));\n    }\n    extractedClassBuilder.setTypeArguments(typeParams);\n    final List<PsiClass> interfaces = calculateInterfacesSupported();\n    extractedClassBuilder.setInterfaces(interfaces);\n\n    if (myGenerateAccessors) {\n      final NecessaryAccessorsVisitor visitor = new NecessaryAccessorsVisitor() {\n        @Override\n        protected boolean isProhibitedReference(PsiField field) {\n          if (fields.contains(field)) {\n            return true;\n          }\n          if (innerClasses.contains(field.getContainingClass())) {\n            return true;\n          }\n          return false;\n        }\n      };\n      sourceClass.accept(visitor);\n      extractedClassBuilder.setFieldsNeedingGetters(visitor.getFieldsNeedingGetter());\n      extractedClassBuilder.setFieldsNeedingSetters(visitor.getFieldsNeedingSetter());\n    }\n\n    final String classString = extractedClassBuilder.buildBeanClass();\n\n    try {\n      final PsiFile containingFile = sourceClass.getContainingFile();\n\n      final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n      final Module module = ModuleUtil.findModuleForPsiElement(containingFile);\n      assert module != null;\n      final PsiDirectory directory = PackageUtil.findOrCreateDirectoryForPackage(module, newPackageName, containingDirectory, false);\n      if (directory != null) {\n        final PsiFile newFile = PsiFileFactory.getInstance(project).createFileFromText(newClassName + \".java\", classString);\n        final PsiElement addedFile = directory.add(newFile);\n        final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n        final PsiElement shortenedFile = JavaCodeStyleManager.getInstance(project).shortenClassReferences(addedFile);\n        return ((PsiJavaFile)codeStyleManager.reformat(shortenedFile)).getClasses()[0];\n      } else {\n        return null;\n      }\n    }\n    catch (IncorrectOperationException e) {\n      return null;\n    }\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExtractClassProcessor(PsiClass sourceClass,\n                               List<PsiField> fields,\n                               List<PsiMethod> methods,\n                               List<PsiClass> classes,\n                               String packageName,\n                               String newClassName,\n                               boolean generateAccessors) {\n    super(sourceClass.getProject());\n    this.sourceClass = sourceClass;\n    this.newPackageName = packageName;\n    myGenerateAccessors = generateAccessors;\n    this.fields = new ArrayList<PsiField>(fields);\n    this.methods = new ArrayList<PsiMethod>(methods);\n    this.innerClasses = new ArrayList<PsiClass>(classes);\n    this.newClassName = newClassName;\n    delegateFieldName = calculateDelegateFieldName();\n    requiresBackpointer = new BackpointerUsageVisitor(fields, innerClasses, methods, sourceClass).backpointerRequired();\n    if (requiresBackpointer) {\n      typeParams.addAll(Arrays.asList(sourceClass.getTypeParameters()));\n    }\n    else {\n      final Set<PsiTypeParameter> typeParamSet = new HashSet<PsiTypeParameter>();\n      final TypeParametersVisitor visitor = new TypeParametersVisitor(typeParamSet);\n      for (PsiField field : fields) {\n        field.accept(visitor);\n      }\n      for (PsiMethod method : methods) {\n        method.accept(visitor);\n      }\n      typeParams.addAll(typeParamSet);\n    }\n  }","id":31027,"modified_method":"public ExtractClassProcessor(PsiClass sourceClass,\n                               List<PsiField> fields,\n                               List<PsiMethod> methods,\n                               List<PsiClass> classes,\n                               String packageName,\n                               String newClassName,\n                               String newVisibility,\n                               boolean generateAccessors) {\n    super(sourceClass.getProject());\n    this.sourceClass = sourceClass;\n    this.newPackageName = packageName;\n    myNewVisibility = newVisibility;\n    myGenerateAccessors = generateAccessors;\n    this.fields = new ArrayList<PsiField>(fields);\n    this.methods = new ArrayList<PsiMethod>(methods);\n    this.innerClasses = new ArrayList<PsiClass>(classes);\n    this.newClassName = newClassName;\n    delegateFieldName = calculateDelegateFieldName();\n    requiresBackpointer = new BackpointerUsageVisitor(fields, innerClasses, methods, sourceClass).backpointerRequired();\n    if (requiresBackpointer) {\n      typeParams.addAll(Arrays.asList(sourceClass.getTypeParameters()));\n    }\n    else {\n      final Set<PsiTypeParameter> typeParamSet = new HashSet<PsiTypeParameter>();\n      final TypeParametersVisitor visitor = new TypeParametersVisitor(typeParamSet);\n      for (PsiField field : fields) {\n        field.accept(visitor);\n      }\n      for (PsiMethod method : methods) {\n        method.accept(visitor);\n      }\n      typeParams.addAll(typeParamSet);\n    }\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExtractClassProcessor(PsiClass sourceClass,\n                               List<PsiField> fields,\n                               List<PsiMethod> methods,\n                               List<PsiClass> innerClasses,\n                               String newPackageName,\n                               String newClassName) {\n    this(sourceClass, fields, methods, innerClasses, newPackageName, newClassName, false);\n  }","id":31028,"modified_method":"public ExtractClassProcessor(PsiClass sourceClass,\n                               List<PsiField> fields,\n                               List<PsiMethod> methods,\n                               List<PsiClass> innerClasses,\n                               String newPackageName,\n                               String newClassName) {\n    this(sourceClass, fields, methods, innerClasses, newPackageName, newClassName, null, false);\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void performRefactoring(UsageInfo[] usageInfos) {\n    if (!buildClass()) return;\n    if (delegationRequired) {\n      buildDelegate();\n    }\n    super.performRefactoring(usageInfos);\n  }","id":31029,"modified_method":"protected void performRefactoring(UsageInfo[] usageInfos) {\n    final PsiClass psiClass = buildClass();\n    if (psiClass == null) return;\n    if (delegationRequired) {\n      buildDelegate();\n    }\n    super.performRefactoring(usageInfos);\n    if (myNewVisibility == null) return;\n    for (PsiMethod method : methods) {\n      final PsiMethod member = psiClass.findMethodBySignature(method, false);\n      if (member != null) {\n        fixVisibility(usageInfos, member);\n      }\n    }\n\n    for (PsiField field : fields) {\n      final PsiField member = psiClass.findFieldByName(field.getName(), false);\n      if (member != null) {\n        fixVisibility(usageInfos, member);\n      }\n    }\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doTest(final PsiClass aClass, final ArrayList<PsiMethod> methods, final ArrayList<PsiField> fields, final String conflicts,\n                             boolean generateGettersSetters) {\n    try {\n      ExtractClassProcessor processor = new ExtractClassProcessor(aClass, fields, methods, new ArrayList<PsiClass>(), \"\", \"Extracted\", generateGettersSetters);\n      processor.run();\n      LocalFileSystem.getInstance().refresh(false);\n      FileDocumentManager.getInstance().saveAllDocuments();\n    }\n    catch (Exception e) {\n      if (conflicts != null) {\n        Assert.assertEquals(e.getMessage(), conflicts);\n        return;\n      } else {\n        fail(e.getMessage());\n      }\n    }\n    if (conflicts != null) {\n      fail(\"Conflicts were not detected: \" + conflicts);\n    }\n  }","id":31030,"modified_method":"private static void doTest(final PsiClass aClass, final ArrayList<PsiMethod> methods, final ArrayList<PsiField> fields, final String conflicts,\n                             boolean generateGettersSetters) {\n    try {\n      ExtractClassProcessor processor = new ExtractClassProcessor(aClass, fields, methods, new ArrayList<PsiClass>(), \"\", \"Extracted\", null, generateGettersSetters);\n      processor.run();\n      LocalFileSystem.getInstance().refresh(false);\n      FileDocumentManager.getInstance().saveAllDocuments();\n    }\n    catch (Exception e) {\n      if (conflicts != null) {\n        Assert.assertEquals(e.getMessage(), conflicts);\n        return;\n      } else {\n        fail(e.getMessage());\n      }\n    }\n    if (conflicts != null) {\n      fail(\"Conflicts were not detected: \" + conflicts);\n    }\n  }","commit_id":"67c770a3a30444b15115702e54db3e0ded35012e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAction() {\n    final boolean useExistingClass = useExistingClassButton.isSelected();\n    final String existingClassName = existingClassField.getText().trim();\n    final String className;\n    final String packageName;\n    if (useExistingClass) {\n      className = StringUtil.getShortName(existingClassName);\n      packageName = StringUtil.getPackageName(existingClassName);\n    }\n    else {\n      className = getClassName();\n      packageName = getPackageName();\n    }\n    invokeRefactoring(\n      new WrapReturnValueProcessor(className, packageName, sourceMethod, useExistingClass, (PsiField)myFieldsCombo.getSelectedItem()));\n  }","id":31031,"modified_method":"protected void doAction() {\n    final boolean useExistingClass = useExistingClassButton.isSelected();\n    final boolean createInnerClass = myCreateInnerClassButton.isSelected();\n    final String existingClassName = existingClassField.getText().trim();\n    final String className;\n    final String packageName;\n    if (useExistingClass) {\n      className = StringUtil.getShortName(existingClassName);\n      packageName = StringUtil.getPackageName(existingClassName);\n    }\n    else if (createInnerClass) {\n      className = getInnerClassName();\n      packageName = \"\";\n    }\n    else {\n      className = getClassName();\n      packageName = getPackageName();\n    }\n    invokeRefactoring(\n      new WrapReturnValueProcessor(className, packageName, sourceMethod, useExistingClass, createInnerClass, (PsiField)myFieldsCombo.getSelectedItem()));\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    sourceMethodTextField.setEditable(false);\n\n    final DocumentListener docListener = new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        validateButtons();\n      }\n    };\n    existingClassField.getTextField().getDocument().addDocumentListener(docListener);\n    packageTextField.getTextField().getDocument().addDocumentListener(docListener);\n    classNameField.getDocument().addDocumentListener(docListener);\n    myFieldsCombo.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        validateButtons();\n      }\n    });\n\n    final PsiFile file = sourceMethod.getContainingFile();\n    if (file instanceof PsiJavaFile) {\n      final String packageName = ((PsiJavaFile)file).getPackageName();\n      packageTextField.setText(packageName);\n    }\n\n    final PsiClass containingClass = sourceMethod.getContainingClass();\n    final String containingClassName = containingClass.getName();\n    final String sourceMethodName = sourceMethod.getName();\n    sourceMethodTextField.setText(containingClassName + '.' + sourceMethodName);\n    final ButtonGroup buttonGroup = new ButtonGroup();\n    buttonGroup.add(useExistingClassButton);\n    buttonGroup.add(createNewClassButton);\n    createNewClassButton.setSelected(true);\n    final ActionListener listener = new ActionListener() {\n      public void actionPerformed(ActionEvent actionEvent) {\n        toggleRadioEnablement();\n      }\n    };\n    useExistingClassButton.addActionListener(listener);\n    createNewClassButton.addActionListener(listener);\n    toggleRadioEnablement();\n    final DefaultComboBoxModel model = new DefaultComboBoxModel();\n    myFieldsCombo.setModel(model);\n    myFieldsCombo.setRenderer(new DefaultPsiElementCellRenderer());\n    existingClassField.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final Project project = sourceMethod.getProject();\n        final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n        final TreeClassChooserDialog chooser =\n          new TreeClassChooserDialog(RefactorJBundle.message(\"select.wrapper.class\"), project, scope, null, null);\n        final String classText = existingClassField.getText();\n        final PsiClass currentClass =\n          JavaPsiFacade.getInstance(PsiManager.getInstance(project).getProject()).findClass(classText, GlobalSearchScope.allScope(project));\n        if (currentClass != null) {\n          chooser.selectClass(currentClass);\n        }\n        chooser.show();\n        final PsiClass selectedClass = chooser.getSelectedClass();\n        if (selectedClass != null) {\n          final String className = selectedClass.getQualifiedName();\n          existingClassField.setText(className);\n          model.removeAllElements();\n          for (PsiField field : selectedClass.getFields()) {\n            if (TypeConversionUtil.isAssignable(sourceMethod.getReturnType(), field.getType())) {\n              model.addElement(field);\n            }\n          }\n        }\n      }\n    });\n\n    packageTextField.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final Project project = sourceMethod.getProject();\n        final PackageChooserDialog chooser = new PackageChooserDialog(RefactorJBundle.message(\"choose.destination.package.label\"), project);\n        final String packageText = packageTextField.getText();\n        chooser.selectPackage(packageText);\n        chooser.show();\n        final PsiPackage aPackage = chooser.getSelectedPackage();\n        if (aPackage != null) {\n          final String packageName = aPackage.getQualifiedName();\n          packageTextField.setText(packageName);\n        }\n      }\n    });\n    return myWholePanel;\n  }","id":31032,"modified_method":"protected JComponent createCenterPanel() {\n    sourceMethodTextField.setEditable(false);\n\n    final DocumentListener docListener = new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        validateButtons();\n      }\n    };\n    existingClassField.getTextField().getDocument().addDocumentListener(docListener);\n    packageTextField.getTextField().getDocument().addDocumentListener(docListener);\n    classNameField.getDocument().addDocumentListener(docListener);\n    myFieldsCombo.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        validateButtons();\n      }\n    });\n\n    final PsiFile file = sourceMethod.getContainingFile();\n    if (file instanceof PsiJavaFile) {\n      final String packageName = ((PsiJavaFile)file).getPackageName();\n      packageTextField.setText(packageName);\n    }\n\n    final PsiClass containingClass = sourceMethod.getContainingClass();\n    final String containingClassName = containingClass.getName();\n    final String sourceMethodName = sourceMethod.getName();\n    sourceMethodTextField.setText(containingClassName + '.' + sourceMethodName);\n    final ButtonGroup buttonGroup = new ButtonGroup();\n    buttonGroup.add(useExistingClassButton);\n    buttonGroup.add(createNewClassButton);\n    buttonGroup.add(myCreateInnerClassButton);\n    createNewClassButton.setSelected(true);\n    final ActionListener enableListener = new ActionListener() {\n      public void actionPerformed(ActionEvent actionEvent) {\n        toggleRadioEnablement();\n      }\n    };\n    useExistingClassButton.addActionListener(enableListener);\n    createNewClassButton.addActionListener(enableListener);\n    myCreateInnerClassButton.addActionListener(enableListener);\n    toggleRadioEnablement();\n    final DefaultComboBoxModel model = new DefaultComboBoxModel();\n    myFieldsCombo.setModel(model);\n    myFieldsCombo.setRenderer(new DefaultPsiElementCellRenderer());\n    existingClassField.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final Project project = sourceMethod.getProject();\n        final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n        final TreeClassChooserDialog chooser =\n          new TreeClassChooserDialog(RefactorJBundle.message(\"select.wrapper.class\"), project, scope, null, null);\n        final String classText = existingClassField.getText();\n        final PsiClass currentClass =\n          JavaPsiFacade.getInstance(PsiManager.getInstance(project).getProject()).findClass(classText, GlobalSearchScope.allScope(project));\n        if (currentClass != null) {\n          chooser.selectClass(currentClass);\n        }\n        chooser.show();\n        final PsiClass selectedClass = chooser.getSelectedClass();\n        if (selectedClass != null) {\n          final String className = selectedClass.getQualifiedName();\n          existingClassField.setText(className);\n          model.removeAllElements();\n          for (PsiField field : selectedClass.getFields()) {\n            if (TypeConversionUtil.isAssignable(sourceMethod.getReturnType(), field.getType())) {\n              model.addElement(field);\n            }\n          }\n        }\n      }\n    });\n\n    packageTextField.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final Project project = sourceMethod.getProject();\n        final PackageChooserDialog chooser = new PackageChooserDialog(RefactorJBundle.message(\"choose.destination.package.label\"), project);\n        final String packageText = packageTextField.getText();\n        chooser.selectPackage(packageText);\n        chooser.show();\n        final PsiPackage aPackage = chooser.getSelectedPackage();\n        if (aPackage != null) {\n          final String packageName = aPackage.getQualifiedName();\n          packageTextField.setText(packageName);\n        }\n      }\n    });\n    return myWholePanel;\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean areButtonsValid() {\n    if (useExistingClassButton.isSelected()) {\n      return myFieldsCombo.getSelectedItem() != null && existingClassField.getText().length() != 0;\n    }\n    final Project project = sourceMethod.getProject();\n    final PsiNameHelper nameHelper = JavaPsiFacade.getInstance(project).getNameHelper();\n    final String packageName = getPackageName();\n    if (packageName.length() == 0 || PackageNameUtil.containsNonIdentifier(nameHelper, packageName)) {\n      return false;\n    }\n    final String className = getClassName();\n    return !(className.length() == 0 || !nameHelper.isIdentifier(className));\n  }","id":31033,"modified_method":"protected boolean areButtonsValid() {\n    if (useExistingClassButton.isSelected()) {\n      return myFieldsCombo.getSelectedItem() != null && existingClassField.getText().length() != 0;\n    }\n    if (myCreateInnerClassButton.isSelected()) {\n      final String innerClassName = getInnerClassName();\n      return innerClassName.length() > 0 && sourceMethod.getContainingClass().findInnerClassByName(innerClassName, false) == null;\n    }\n    final Project project = sourceMethod.getProject();\n    final PsiNameHelper nameHelper = JavaPsiFacade.getInstance(project).getNameHelper();\n    final String packageName = getPackageName();\n    if (packageName.length() == 0 || PackageNameUtil.containsNonIdentifier(nameHelper, packageName)) {\n      return false;\n    }\n    final String className = getClassName();\n    return !(className.length() == 0 || !nameHelper.isIdentifier(className));\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void toggleRadioEnablement() {\n    final boolean useExisting = useExistingClassButton.isSelected();\n    UIUtil.setEnabled(myExistingClassPanel, useExisting, true);\n    UIUtil.setEnabled(myNewClassPanel, !useExisting, true);\n  }","id":31034,"modified_method":"private void toggleRadioEnablement() {\n    UIUtil.setEnabled(myExistingClassPanel, useExistingClassButton.isSelected(), true);\n    UIUtil.setEnabled(myNewClassPanel, createNewClassButton.isSelected(), true);\n    UIUtil.setEnabled(myCreateInnerPanel, myCreateInnerClassButton.isSelected(), true);\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public WrapReturnValueProcessor(String className,\n                                  String packageName,\n                                  PsiMethod method,\n                                  boolean useExistingClass,\n                                  PsiField delegateField) {\n    super(method.getProject());\n    this.method = method;\n    this.className = className;\n    this.packageName = packageName;\n    myDelegateField = delegateField;\n    myQualifiedName = StringUtil.getQualifiedName(packageName, className);\n    this.myUseExistingClass = useExistingClass;\n\n    final Set<PsiTypeParameter> typeParamSet = new HashSet<PsiTypeParameter>();\n    final TypeParametersVisitor visitor = new TypeParametersVisitor(typeParamSet);\n    final PsiTypeElement returnTypeElement = method.getReturnTypeElement();\n    assert returnTypeElement != null;\n    returnTypeElement.accept(visitor);\n    typeParams = new ArrayList<PsiTypeParameter>(typeParamSet);\n    if (useExistingClass) {\n      unwrapMethodName = calculateUnwrapMethodName();\n    }\n    else {\n      unwrapMethodName = \"getValue\";\n    }\n  }","id":31035,"modified_method":"public WrapReturnValueProcessor(String className,\n                                  String packageName,\n                                  PsiMethod method,\n                                  boolean useExistingClass,\n                                  final boolean createInnerClass, PsiField delegateField) {\n    super(method.getProject());\n    this.method = method;\n    this.className = className;\n    this.packageName = packageName;\n    myCreateInnerClass = createInnerClass;\n    myDelegateField = delegateField;\n    myQualifiedName = StringUtil.getQualifiedName(packageName, className);\n    this.myUseExistingClass = useExistingClass;\n\n    final Set<PsiTypeParameter> typeParamSet = new HashSet<PsiTypeParameter>();\n    final TypeParametersVisitor visitor = new TypeParametersVisitor(typeParamSet);\n    final PsiTypeElement returnTypeElement = method.getReturnTypeElement();\n    assert returnTypeElement != null;\n    returnTypeElement.accept(visitor);\n    typeParams = new ArrayList<PsiTypeParameter>(typeParamSet);\n    if (useExistingClass) {\n      unwrapMethodName = calculateUnwrapMethodName();\n    }\n    else {\n      unwrapMethodName = \"getValue\";\n    }\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildClass() {\n    final PsiManager manager = method.getManager();\n    final Project project = method.getProject();\n    final ReturnValueBeanBuilder beanClassBuilder = new ReturnValueBeanBuilder();\n    final CodeStyleSettingsManager settingsManager = CodeStyleSettingsManager.getInstance(project);\n    final CodeStyleSettings settings = settingsManager.getCurrentSettings();\n    beanClassBuilder.setCodeStyleSettings(settings);\n    beanClassBuilder.setTypeArguments(typeParams);\n    beanClassBuilder.setClassName(className);\n    beanClassBuilder.setPackageName(packageName);\n    final PsiType returnType = method.getReturnType();\n    beanClassBuilder.setValueType(returnType);\n\n    final String classString;\n    try {\n      classString = beanClassBuilder.buildBeanClass();\n    }\n    catch (IOException e) {\n      LOG.error(e);\n      return;\n    }\n\n    try {\n      final PsiFile containingFile = method.getContainingFile();\n\n      final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n      final Module module = ModuleUtil.findModuleForPsiElement(containingFile);\n      final PsiDirectory directory = PackageUtil.findOrCreateDirectoryForPackage(module, packageName, containingDirectory, true);\n\n      if (directory != null) {\n        final PsiFile newFile = PsiFileFactory.getInstance(project).createFileFromText(className + \".java\", classString);\n\n        final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n        final PsiElement shortenedFile = JavaCodeStyleManager.getInstance(project).shortenClassReferences(newFile);\n        final PsiElement reformattedFile = codeStyleManager.reformat(shortenedFile);\n        directory.add(reformattedFile);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":31036,"modified_method":"private boolean buildClass() {\n    final PsiManager manager = method.getManager();\n    final Project project = method.getProject();\n    final ReturnValueBeanBuilder beanClassBuilder = new ReturnValueBeanBuilder();\n    final CodeStyleSettingsManager settingsManager = CodeStyleSettingsManager.getInstance(project);\n    final CodeStyleSettings settings = settingsManager.getCurrentSettings();\n    beanClassBuilder.setCodeStyleSettings(settings);\n    beanClassBuilder.setTypeArguments(typeParams);\n    beanClassBuilder.setClassName(className);\n    beanClassBuilder.setPackageName(packageName);\n    final PsiType returnType = method.getReturnType();\n    beanClassBuilder.setValueType(returnType);\n\n    final String classString;\n    try {\n      classString = beanClassBuilder.buildBeanClass();\n    }\n    catch (IOException e) {\n      LOG.error(e);\n      return false;\n    }\n\n    try {\n      final PsiJavaFile psiFile = (PsiJavaFile)PsiFileFactory.getInstance(project).createFileFromText(className + \".java\", classString);\n      final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n      if (myCreateInnerClass) {\n        final PsiClass containingClass = method.getContainingClass();\n        final PsiElement innerClass = containingClass.add(psiFile.getClasses()[0]);\n        JavaCodeStyleManager.getInstance(project).shortenClassReferences(innerClass);\n      } else {\n        final PsiFile containingFile = method.getContainingFile();\n\n        final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n        final Module module = ModuleUtil.findModuleForPsiElement(containingFile);\n        final PsiDirectory directory = PackageUtil.findOrCreateDirectoryForPackage(module, packageName, containingDirectory, true);\n\n        if (directory != null) {\n          final PsiElement shortenedFile = JavaCodeStyleManager.getInstance(project).shortenClassReferences(psiFile);\n          final PsiElement reformattedFile = codeStyleManager.reformat(shortenedFile);\n          directory.add(reformattedFile);\n        } else {\n          return false;\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return false;\n    }\n    return true;\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void performRefactoring(UsageInfo[] usageInfos) {\n    if (!myUseExistingClass) {\n      buildClass();\n    }\n    super.performRefactoring(usageInfos);\n  }","id":31037,"modified_method":"protected void performRefactoring(UsageInfo[] usageInfos) {\n    if (!myUseExistingClass && !buildClass()) return;\n    super.performRefactoring(usageInfos);\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest(final boolean existing, boolean fail) throws Exception {\n    try {\n      doTest(new PerformAction() {\n        public void performAction(final VirtualFile rootDir, final VirtualFile rootAfter) throws Exception {\n          PsiClass aClass = myJavaFacade.findClass(\"Test\");\n\n          assertNotNull(\"Class Test not found\", aClass);\n\n          final PsiMethod method = aClass.findMethodsByName(\"foo\", false)[0];\n\n\n\n          final String wrapperClassName = \"Wrapper\";\n\n          final PsiClass wrapperClass = myJavaFacade.findClass(wrapperClassName);\n\n          assertTrue(!existing || wrapperClass != null);\n          final PsiField delegateField = existing ? wrapperClass.findFieldByName(\"myField\", false) : null;\n          WrapReturnValueProcessor processor = new WrapReturnValueProcessor(wrapperClassName, \"\", method, existing, delegateField);\n          processor.run();\n          LocalFileSystem.getInstance().refresh(false);\n          FileDocumentManager.getInstance().saveAllDocuments();\n        }\n      });\n    }\n    catch (RuntimeException e) {\n      if (fail) {\n        e.printStackTrace();\n        return;\n      }\n      if (!fail) throw e;\n    }\n    if (fail) {\n      fail(\"Conflict was not found\");\n    }\n  }","id":31038,"modified_method":"private void doTest(final boolean existing, final boolean fail) throws Exception {\n    doTest(existing, fail, false);\n  }","commit_id":"abfa7992677cacb0943549d7bd875ed112498c86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    final CoverageDataManager coverageDataManager = CoverageDataManager.getInstance(project);\n    final CoverageSuiteImpl currentSuite = (CoverageSuiteImpl)coverageDataManager.getCurrentSuite();\n\n    final ExportToHTMLDialog dialog = new ExportToHTMLDialog(project, true);\n    dialog.setTitle(\"Generate coverage report for: \\'\" + currentSuite.getPresentableName() + \"\\'\");\n    dialog.reset();\n    dialog.show();\n    if (!dialog.isOK()) return;\n    dialog.apply();\n    try {\n      final File tempFile = File.createTempFile(\"temp\", \"\");\n      tempFile.deleteOnExit();\n      final ProjectData projectData = currentSuite.getCoverageData(coverageDataManager);\n      new SaveHook(tempFile, true, new IdeaClassFinder(project, currentSuite)).save(projectData);\n      final ExportToHTMLSettings settings = ExportToHTMLSettings.getInstance(project);\n      currentSuite.getRunner().generateReport(project, currentSuite.isTrackTestFolders(), tempFile.getCanonicalPath(), settings.OUTPUT_DIRECTORY, settings.OPEN_IN_BROWSER);\n    }\n    catch (IOException e1) {\n      LOG.error(e1);\n    }\n  }","id":31039,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    final CoverageDataManager coverageDataManager = CoverageDataManager.getInstance(project);\n    final CoverageSuite currentSuite = coverageDataManager.getCurrentSuite();\n\n    final ExportToHTMLDialog dialog = new ExportToHTMLDialog(project, true);\n    dialog.setTitle(\"Generate coverage report for: \\'\" + currentSuite.getPresentableName() + \"\\'\");\n    dialog.reset();\n    dialog.show();\n    if (!dialog.isOK()) return;\n    dialog.apply();\n    try {\n      final File tempFile = File.createTempFile(\"temp\", \"\");\n      tempFile.deleteOnExit();\n      final ProjectData projectData = currentSuite.getCoverageData(coverageDataManager);\n      new SaveHook(tempFile, true, new IdeaClassFinder(project, currentSuite)).save(projectData);\n      final ExportToHTMLSettings settings = ExportToHTMLSettings.getInstance(project);\n      currentSuite.getRunner().generateReport(project, currentSuite.isTrackTestFolders(), tempFile.getCanonicalPath(), settings.OUTPUT_DIRECTORY, settings.OPEN_IN_BROWSER);\n    }\n    catch (IOException e1) {\n      LOG.error(e1);\n    }\n  }","commit_id":"ae137a87e29337fe476bb38a6b1f8ae16f71b37e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Presentation presentation = e.getPresentation();\n    presentation.setEnabled(false);\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project != null) {\n      final Sdk projectJdk = ProjectRootManager.getInstance(project).getProjectJdk();\n      if (projectJdk != null) {\n        final CoverageSuiteImpl currentSuite = (CoverageSuiteImpl)CoverageDataManager.getInstance(project).getCurrentSuite();\n        if (currentSuite != null && currentSuite.getRunner().isHTMLReportSupported()) {\n          presentation.setEnabled(true);\n        }\n      }\n    }\n  }","id":31040,"modified_method":"public void update(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Presentation presentation = e.getPresentation();\n    presentation.setEnabled(false);\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project != null) {\n      final Sdk projectJdk = ProjectRootManager.getInstance(project).getProjectJdk();\n      if (projectJdk != null) {\n        final CoverageSuite currentSuite = CoverageDataManager.getInstance(project).getCurrentSuite();\n        if (currentSuite != null && currentSuite.getRunner().isHTMLReportSupported()) {\n          presentation.setEnabled(true);\n        }\n      }\n    }\n  }","commit_id":"ae137a87e29337fe476bb38a6b1f8ae16f71b37e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseCoverageSuite getCurrentSuite() {\n    return myCurrentSuite;\n  }","id":31041,"modified_method":"public CoverageSuite getCurrentSuite() {\n    return myCurrentSuite;\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseCoverageSuite addCoverageSuite(final String name, final CoverageFileProvider fileProvider, final String[] filters, final long lastCoverageTimeStamp,\n                                        @Nullable final String suiteToMergeWith,\n                                        final AbstractCoverageRunner coverageRunner,\n                                        final boolean collectLineInfo,\n                                        final boolean tracingEnabled) {\n    CoverageSuiteImpl suite = new CoverageSuiteImpl(name, fileProvider, filters, lastCoverageTimeStamp, suiteToMergeWith, collectLineInfo, tracingEnabled, false, coverageRunner);\n    if (suiteToMergeWith == null || !name.equals(suiteToMergeWith)) {\n      removeCoverageSuite(suite);\n    }\n    myCoverageSuites.remove(suite); // remove previous instance\n    myCoverageSuites.add(suite); // add new instance\n    return suite;\n  }","id":31042,"modified_method":"public CoverageSuite addCoverageSuite(final String name, final CoverageFileProvider fileProvider, final String[] filters, final long lastCoverageTimeStamp,\n                                        @Nullable final String suiteToMergeWith,\n                                        final AbstractCoverageRunner coverageRunner,\n                                        final boolean collectLineInfo,\n                                        final boolean tracingEnabled) {\n    CoverageSuiteImpl suite = new CoverageSuiteImpl(name, fileProvider, filters, lastCoverageTimeStamp, suiteToMergeWith, collectLineInfo, tracingEnabled, false, coverageRunner);\n    if (suiteToMergeWith == null || !name.equals(suiteToMergeWith)) {\n      removeCoverageSuite(suite);\n    }\n    myCoverageSuites.remove(suite); // remove previous instance\n    myCoverageSuites.add(suite); // add new instance\n    return suite;\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void renewCoverageData(final BaseCoverageSuite suite) {\n    final List<PsiPackage> packages = getCurrentSuitePackages();\n    final List<PsiClass> classes = getCurrentSuiteClasses();\n\n    if (!packages.isEmpty() || !classes.isEmpty()) {\n      myAlarm.addRequest(new Runnable() {\n        public void run() {\n          if (myProject.isDisposed()) return;\n          for (PsiPackage aPackage : packages) {\n            new PackageAnnotator(aPackage).annotate((CoverageSuiteImpl)suite, new PackageAnnotator.Annotator() {\n              public void annotatePackage(String packageQualifiedName, PackageCoverageInfo packageCoverageInfo) {\n                myPackageCoverageInfos.put(packageQualifiedName, packageCoverageInfo);\n              }\n\n              public void annotateSourceDirectory(String packageQualifiedName,\n                                                  PackageCoverageInfo dirCoverageInfo,\n                                                  Module module) {\n                final Pair<String, Module> p = new Pair<String, Module>(packageQualifiedName, module);\n                myDirCoverageInfos.put(p, dirCoverageInfo);\n              }\n\n              public void annotateTestDirectory(String packageQualifiedName, PackageCoverageInfo packageCoverageInfo, Module module) {\n                final Pair<String, Module> p = new Pair<String, Module>(packageQualifiedName, module);\n                myTestDirCoverageInfos.put(p, packageCoverageInfo);\n              }\n\n              public void annotateClass(String classQualifiedName, ClassCoverageInfo classCoverageInfo) {\n                myClassCoverageInfos.put(classQualifiedName, classCoverageInfo);\n              }\n            });\n          }\n\n          triggerPresentationUpdate();\n        }\n      }, 100);\n    }\n  }","id":31043,"modified_method":"public void renewCoverageData(final CoverageSuite suite) {\n    final List<PsiPackage> packages = getCurrentSuitePackages();\n    final List<PsiClass> classes = getCurrentSuiteClasses();\n\n    if (!packages.isEmpty() || !classes.isEmpty()) {\n      myAlarm.addRequest(new Runnable() {\n        public void run() {\n          if (myProject.isDisposed()) return;\n          for (PsiPackage aPackage : packages) {\n            new PackageAnnotator(aPackage).annotate((CoverageSuiteImpl)suite, new PackageAnnotator.Annotator() {\n              public void annotatePackage(String packageQualifiedName, PackageCoverageInfo packageCoverageInfo) {\n                myPackageCoverageInfos.put(packageQualifiedName, packageCoverageInfo);\n              }\n\n              public void annotateSourceDirectory(String packageQualifiedName,\n                                                  PackageCoverageInfo dirCoverageInfo,\n                                                  Module module) {\n                final Pair<String, Module> p = new Pair<String, Module>(packageQualifiedName, module);\n                myDirCoverageInfos.put(p, dirCoverageInfo);\n              }\n\n              public void annotateTestDirectory(String packageQualifiedName, PackageCoverageInfo packageCoverageInfo, Module module) {\n                final Pair<String, Module> p = new Pair<String, Module>(packageQualifiedName, module);\n                myTestDirCoverageInfos.put(p, packageCoverageInfo);\n              }\n\n              public void annotateClass(String classQualifiedName, ClassCoverageInfo classCoverageInfo) {\n                myClassCoverageInfos.put(classQualifiedName, classCoverageInfo);\n              }\n            });\n          }\n\n          triggerPresentationUpdate();\n        }\n      }, 100);\n    }\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void restoreMergedCoverage(@NotNull final BaseCoverageSuite suite) {\n    mySubCoverageIsActive = false;\n    ((CoverageSuiteImpl)suite).restoreCoverageData();\n    renewCoverageData(suite);\n  }","id":31044,"modified_method":"public void restoreMergedCoverage(@NotNull final CoverageSuite suite) {\n    mySubCoverageIsActive = false;\n    ((BaseCoverageSuite)suite).restoreCoverageData();\n    renewCoverageData(suite);\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void removeCoverageSuite(BaseCoverageSuite suite) {\n    final String fileName = suite.getCoverageDataFileName();\n    FileUtil.delete(new File(fileName));\n    FileUtil.delete(getTracesDirectory(fileName));\n    myCoverageSuites.remove(suite);\n    if (myCurrentSuite == suite) {\n      chooseSuite(null);\n    }\n  }","id":31045,"modified_method":"public void removeCoverageSuite(CoverageSuite suite) {\n    final String fileName = suite.getCoverageDataFileName();\n    FileUtil.delete(new File(fileName));\n    FileUtil.delete(getTracesDirectory(fileName));\n    myCoverageSuites.remove(suite);\n    if (myCurrentSuite == suite) {\n      chooseSuite(null);\n    }\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void selectSubCoverage(@NotNull final BaseCoverageSuite suite, final List<String> testNames) {\n    ((CoverageSuiteImpl)suite).restoreCoverageData();\n    final ProjectData data = ((CoverageSuiteImpl)suite).getCoverageData(this);\n    if (data == null) return;\n    mySubCoverageIsActive = true;\n    final Map<String, Set<Integer>> executionTrace = new HashMap<String, Set<Integer>>();\n    final String fileName = suite.getCoverageDataFileName();\n    final File tracesDir = getTracesDirectory(fileName);\n    for (String testName : testNames) {\n      final File file = new File(tracesDir, testName + \".tr\");\n      if (file.exists()) {\n        DataInputStream in = null;\n        try {\n          in = new DataInputStream(new FileInputStream(file));\n          int traceSize = in.readInt();\n          for (int i = 0; i < traceSize; i++) {\n            final String className = in.readUTF();\n            final int linesSize = in.readInt();\n            Set<Integer> lines = executionTrace.get(className);\n            if (lines == null) {\n              lines = new HashSet<Integer>();\n              executionTrace.put(className, lines);\n            }\n            for(int l = 0; l < linesSize; l++) {\n              lines.add(in.readInt());\n            }\n          }\n        }\n        catch (Exception e) {\n          LOG.error(e);\n        }\n        finally {\n          try {\n            in.close();\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n      }\n    }\n    final ProjectData projectData = new ProjectData();\n    for (String className : executionTrace.keySet()) {\n      ClassData loadedClassData = projectData.getClassData(className);\n      if (loadedClassData == null) {\n        loadedClassData = projectData.getOrCreateClassData(className);\n      }\n      final Set<Integer> lineNumbers = executionTrace.get(className);\n      final LineData[] lines = new LineData[lineNumbers.size()];\n      int idx = 0;\n      for (Integer line : lineNumbers) {\n        final LineData lineData = new LineData(line.intValue(), null);\n        lineData.setStatus(LineCoverage.FULL);\n        lines[idx++] = lineData;\n      }\n      loadedClassData.setLines(lines);\n    }\n    ((CoverageSuiteImpl)suite).setCoverageData(projectData);\n    renewCoverageData(suite);\n  }","id":31046,"modified_method":"public void selectSubCoverage(@NotNull final CoverageSuite suite, final List<String> testNames) {\n    ((CoverageSuiteImpl)suite).restoreCoverageData();\n    final ProjectData data = ((CoverageSuiteImpl)suite).getCoverageData(this);\n    if (data == null) return;\n    mySubCoverageIsActive = true;\n    final Map<String, Set<Integer>> executionTrace = new HashMap<String, Set<Integer>>();\n    final String fileName = suite.getCoverageDataFileName();\n    final File tracesDir = getTracesDirectory(fileName);\n    for (String testName : testNames) {\n      final File file = new File(tracesDir, testName + \".tr\");\n      if (file.exists()) {\n        DataInputStream in = null;\n        try {\n          in = new DataInputStream(new FileInputStream(file));\n          int traceSize = in.readInt();\n          for (int i = 0; i < traceSize; i++) {\n            final String className = in.readUTF();\n            final int linesSize = in.readInt();\n            Set<Integer> lines = executionTrace.get(className);\n            if (lines == null) {\n              lines = new HashSet<Integer>();\n              executionTrace.put(className, lines);\n            }\n            for(int l = 0; l < linesSize; l++) {\n              lines.add(in.readInt());\n            }\n          }\n        }\n        catch (Exception e) {\n          LOG.error(e);\n        }\n        finally {\n          try {\n            in.close();\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n      }\n    }\n    final ProjectData projectData = new ProjectData();\n    for (String className : executionTrace.keySet()) {\n      ClassData loadedClassData = projectData.getClassData(className);\n      if (loadedClassData == null) {\n        loadedClassData = projectData.getOrCreateClassData(className);\n      }\n      final Set<Integer> lineNumbers = executionTrace.get(className);\n      final LineData[] lines = new LineData[lineNumbers.size()];\n      int idx = 0;\n      for (Integer line : lineNumbers) {\n        final LineData lineData = new LineData(line.intValue(), null);\n        lineData.setStatus(LineCoverage.FULL);\n        lines[idx++] = lineData;\n      }\n      loadedClassData.setLines(lines);\n    }\n    ((CoverageSuiteImpl)suite).setCoverageData(projectData);\n    renewCoverageData(suite);\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    for (CoverageSuiteImpl coverageSuite : myCoverageSuites) {\n      final Element suiteElement = new Element(SUITE);\n      element.addContent(suiteElement);\n      coverageSuite.writeExternal(suiteElement);\n    }\n  }","id":31047,"modified_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    for (BaseCoverageSuite coverageSuite : myCoverageSuites) {\n      final Element suiteElement = new Element(SUITE);\n      element.addContent(suiteElement);\n      coverageSuite.writeExternal(suiteElement);\n    }\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void chooseSuite(final BaseCoverageSuite suite) {\n    myCurrentSuite = (CoverageSuiteImpl)suite;\n    myAlarm.cancelAllRequests();\n    myPackageCoverageInfos.clear();\n    myDirCoverageInfos.clear();\n    myTestDirCoverageInfos.clear();\n    myClassCoverageInfos.clear();\n    disposeAnnotators();\n\n    if (suite == null) {\n      triggerPresentationUpdate();\n      return;\n    }\n\n    final boolean suiteFileExists = myCurrentSuite.getCoverageDataFileProvider().ensureFileExists();\n    if (!suiteFileExists) {\n      chooseSuite(null);\n      return;\n    }\n\n    renewCoverageData(suite);\n\n    fireAfterSuiteChosen();\n  }","id":31048,"modified_method":"public void chooseSuite(final CoverageSuite suite) {\n    myCurrentSuite = (CoverageSuiteImpl)suite;\n    myAlarm.cancelAllRequests();\n    myPackageCoverageInfos.clear();\n    myDirCoverageInfos.clear();\n    myTestDirCoverageInfos.clear();\n    myClassCoverageInfos.clear();\n    disposeAnnotators();\n\n    if (suite == null) {\n      triggerPresentationUpdate();\n      return;\n    }\n\n    final boolean suiteFileExists = myCurrentSuite.getCoverageDataFileProvider().ensureFileExists();\n    if (!suiteFileExists) {\n      chooseSuite(null);\n      return;\n    }\n\n    renewCoverageData(suite);\n\n    fireAfterSuiteChosen();\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void coverageGathered(@NotNull final BaseCoverageSuite suite) {\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        if (myCurrentSuite != null && !myCurrentSuite.equals(suite)) {\n          final String message = CodeInsightBundle.message(\"display.coverage.prompt\", suite.getPresentableName());\n          if (Messages.showYesNoDialog(message, CodeInsightBundle.message(\"code.coverage\"), Messages.getQuestionIcon()) == DialogWrapper.OK_EXIT_CODE) {\n            chooseSuite(suite);\n          }\n        }\n        else {\n          chooseSuite(suite);\n        }\n      }\n    });\n  }","id":31049,"modified_method":"public void coverageGathered(@NotNull final CoverageSuite suite) {\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        if (myCurrentSuite != null && !myCurrentSuite.equals(suite)) {\n          final String message = CodeInsightBundle.message(\"display.coverage.prompt\", suite.getPresentableName());\n          if (Messages.showYesNoDialog(message, CodeInsightBundle.message(\"code.coverage\"), Messages.getQuestionIcon()) == DialogWrapper.OK_EXIT_CODE) {\n            chooseSuite(suite);\n          }\n        }\n        else {\n          chooseSuite(suite);\n        }\n      }\n    });\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public BaseCoverageSuite addCoverageSuite(final CoverageEnabledConfiguration config) {\n    final String name = config.getName() + \" Coverage Results\";\n    CoverageSuiteImpl suite =\n      new CoverageSuiteImpl(name, new DefaultCoverageFileProvider(new File(config.getCoverageFilePath())),\n                            config.getPatterns(), new Date().getTime(), config.getSuiteToMergeWith(), config.isTrackPerTestCoverage() && !config.isSampling(),\n                            !config.isSampling(), config.isTrackTestFolders(), config.getCoverageRunner());\n    if (config.getSuiteToMergeWith() == null || !name.equals(config.getSuiteToMergeWith())) {\n      removeCoverageSuite(suite);\n    }\n    myCoverageSuites.remove(suite); // remove previous instance\n    myCoverageSuites.add(suite); // add new instance\n    return suite;\n  }","id":31050,"modified_method":"@Override\n  public CoverageSuite addCoverageSuite(final CoverageEnabledConfiguration config) {\n    final JavaCoverageEnabledConfiguration javaConfig = (JavaCoverageEnabledConfiguration)config;\n    final String name = javaConfig.getName() + \" Coverage Results\";\n    final String covFilePath = javaConfig.getCoverageFilePath();\n    assert covFilePath != null; // Shouldn't be null here!\n    final CoverageSuiteImpl suite =\n      new CoverageSuiteImpl(name, new DefaultCoverageFileProvider(new File(covFilePath)),\n                            javaConfig.getPatterns(), new Date().getTime(), javaConfig.getSuiteToMergeWith(), javaConfig.isTrackPerTestCoverage() && !javaConfig.isSampling(),\n                            !javaConfig.isSampling(), javaConfig.isTrackTestFolders(), javaConfig.getCoverageRunner());\n    if (javaConfig.getSuiteToMergeWith() == null || !name.equals(javaConfig.getSuiteToMergeWith())) {\n      removeCoverageSuite(suite);\n    }\n    myCoverageSuites.remove(suite); // remove previous instance\n    myCoverageSuites.add(suite); // add new instance\n    return suite;\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    final String fileName =\n      FileUtil.getRelativePath(new File(PathManager.getSystemPath()), new File(myCoverageDataFileProvider.getCoverageDataFilePath()));\n    element.setAttribute(FILE_PATH, fileName != null ? FileUtil.toSystemIndependentName(fileName) : myCoverageDataFileProvider.getCoverageDataFilePath());\n    element.setAttribute(NAME_ATTRIBUTE, myName);\n    element.setAttribute(MODIFIED_STAMP, String.valueOf(myLastCoverageTimeStamp));\n    element.setAttribute(SOURCE_PROVIDER, myCoverageDataFileProvider instanceof DefaultCoverageFileProvider\n                                          ? ((DefaultCoverageFileProvider)myCoverageDataFileProvider).getSourceProvider()\n                                          : myCoverageDataFileProvider.getClass().getName());\n    if (mySuiteToMerge != null) {\n      element.setAttribute(MERGE_SUITE, mySuiteToMerge);\n    }\n    if (myFilters != null) {\n      for (String filter : myFilters) {\n        final Element filterElement = new Element(FILTER);\n        filterElement.setText(filter);\n        element.addContent(filterElement);\n      }\n    }\n    element.setAttribute(COVERAGE_RUNNER, myRunner != null ? myRunner.getId() : \"emma\");\n    element.setAttribute(COVERAGE_BY_TEST_ENABLED_ATTRIBUTE_NAME, String.valueOf(myCoverageByTestEnabled));\n    element.setAttribute(TRACING_ENABLED_ATTRIBUTE_NAME, String.valueOf(myTracingEnabled));\n  }","id":31051,"modified_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    super.writeExternal(element);\n    if (mySuiteToMerge != null) {\n      element.setAttribute(MERGE_SUITE, mySuiteToMerge);\n    }\n    if (myFilters != null) {\n      for (String filter : myFilters) {\n        final Element filterElement = new Element(FILTER);\n        filterElement.setText(filter);\n        element.addContent(filterElement);\n      }\n    }\n    final AbstractCoverageRunner coverageRunner = getRunner();\n    element.setAttribute(COVERAGE_RUNNER, coverageRunner != null ? coverageRunner.getId() : \"emma\");\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CoverageSuiteImpl(final String name,\n                           final CoverageFileProvider coverageDataFileProvider,\n                           final String[] filters,\n                           final long lastCoverageTimeStamp,\n                           final String suiteToMerge,\n                           final boolean coverageByTestEnabled,\n                           final boolean tracingEnabled,\n                           final boolean trackTestFolders,\n                           final AbstractCoverageRunner coverageRunner) {\n    myName = name;\n    myCoverageDataFileProvider = coverageDataFileProvider;\n    myFilters = filters;\n    myLastCoverageTimeStamp = lastCoverageTimeStamp;\n    mySuiteToMerge = suiteToMerge;\n    myCoverageByTestEnabled = coverageByTestEnabled;\n    myTracingEnabled = tracingEnabled;\n    myTrackTestFolders = trackTestFolders;\n    myRunner = coverageRunner != null ? coverageRunner : AbstractCoverageRunner.getInstance(IDEACoverageRunner.class);\n  }","id":31052,"modified_method":"public CoverageSuiteImpl(final String name,\n                           final CoverageFileProvider coverageDataFileProvider,\n                           final String[] filters,\n                           final long lastCoverageTimeStamp,\n                           final String suiteToMerge,\n                           final boolean coverageByTestEnabled,\n                           final boolean tracingEnabled,\n                           final boolean trackTestFolders,\n                           final AbstractCoverageRunner coverageRunner) {\n    super(name, coverageDataFileProvider, lastCoverageTimeStamp, coverageByTestEnabled,\n          tracingEnabled, trackTestFolders,\n          coverageRunner != null ? coverageRunner : AbstractCoverageRunner.getInstance(IDEACoverageRunner.class));\n\n    myFilters = filters;\n    mySuiteToMerge = suiteToMerge;\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public ProjectData getCoverageData(final CoverageDataManager coverageDataManager) {\n    final ProjectData data = myCoverageData.get();\n    if (data != null) return data;\n    ProjectData map = loadProjectInfo();\n    if (mySuiteToMerge != null) {\n      CoverageSuiteImpl toMerge = null;\n      final BaseCoverageSuite[] suites = coverageDataManager.getSuites();\n      for (BaseCoverageSuite suite : suites) {\n        if (Comparing.strEqual(suite.getPresentableName(), mySuiteToMerge)) {\n          if (!Comparing.strEqual(((CoverageSuiteImpl)suite).getSuiteToMerge(), getPresentableName())) {\n            toMerge = (CoverageSuiteImpl)suite;\n          }\n          break;\n        }\n      }\n      if (toMerge != null) {\n        final ProjectData projectInfo = toMerge.getCoverageData(coverageDataManager);\n        if (map != null) {\n          map.merge(projectInfo);\n        } else {\n          map = projectInfo;\n        }\n      }\n    }\n    myCoverageData = new SoftReference<ProjectData>(map);\n    return map;\n  }","id":31053,"modified_method":"@Nullable\n  public ProjectData getCoverageData(final CoverageDataManager coverageDataManager) {\n    final ProjectData data = getCoverageData();\n    if (data != null) return data;\n    ProjectData map = loadProjectInfo();\n    if (mySuiteToMerge != null) {\n      CoverageSuiteImpl toMerge = null;\n      final CoverageSuite[] suites = coverageDataManager.getSuites();\n      for (CoverageSuite suite : suites) {\n        if (Comparing.strEqual(suite.getPresentableName(), mySuiteToMerge)) {\n          if (!Comparing.strEqual(((CoverageSuiteImpl)suite).getSuiteToMerge(), getPresentableName())) {\n            toMerge = (CoverageSuiteImpl)suite;\n          }\n          break;\n        }\n      }\n      if (toMerge != null) {\n        final ProjectData projectInfo = toMerge.getCoverageData(coverageDataManager);\n        if (map != null) {\n          map.merge(projectInfo);\n        } else {\n          map = projectInfo;\n        }\n      }\n    }\n    setCoverageData(map);\n    return map;\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    final String sourceProvider = element.getAttributeValue(SOURCE_PROVIDER);\n    final String relativePath = FileUtil.toSystemDependentName(element.getAttributeValue(FILE_PATH));\n    final File file = new File(relativePath);\n    myCoverageDataFileProvider = new DefaultCoverageFileProvider(file.exists() ? file : new File(PathManager.getSystemPath(), relativePath),\n                                                                 sourceProvider != null ? sourceProvider : DefaultCoverageFileProvider.class.getName());\n    myName = element.getAttributeValue(NAME_ATTRIBUTE);\n    if (myName == null) myName = generateName();\n    myLastCoverageTimeStamp = Long.parseLong(element.getAttributeValue(MODIFIED_STAMP));\n    final List children = element.getChildren(FILTER);\n    List<String> filters = new ArrayList<String>();\n    //noinspection unchecked\n    for (Element child : ((Iterable<Element>)children)) {\n      filters.add(child.getValue());\n    }\n    myFilters = filters.isEmpty() ? null : ArrayUtil.toStringArray(filters);\n    mySuiteToMerge = element.getAttributeValue(MERGE_SUITE);\n    final String runner = element.getAttributeValue(COVERAGE_RUNNER);\n    if (runner != null) {\n      for (AbstractCoverageRunner coverageRunner : Extensions.getExtensions(AbstractCoverageRunner.EP_NAME)) {\n        if (Comparing.strEqual(coverageRunner.getId(), runner)) {\n          myRunner = coverageRunner;\n          break;\n        }\n      }\n    } else {\n      myRunner = AbstractCoverageRunner.getInstance(IDEACoverageRunner.class); //default\n    }\n    final String collectedLineInfo = element.getAttributeValue(COVERAGE_BY_TEST_ENABLED_ATTRIBUTE_NAME);\n    myCoverageByTestEnabled = collectedLineInfo != null && Boolean.valueOf(collectedLineInfo).booleanValue();\n\n    final String tracingEnabled = element.getAttributeValue(TRACING_ENABLED_ATTRIBUTE_NAME);\n    myTracingEnabled = tracingEnabled != null && Boolean.valueOf(tracingEnabled).booleanValue();\n  }","id":31054,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    super.readExternal(element);\n\n    // filters\n    final List children = element.getChildren(FILTER);\n    List<String> filters = new ArrayList<String>();\n    //noinspection unchecked\n    for (Element child : ((Iterable<Element>)children)) {\n      filters.add(child.getValue());\n    }\n    myFilters = filters.isEmpty() ? null : ArrayUtil.toStringArray(filters);\n\n    // suite to merge\n    mySuiteToMerge = element.getAttributeValue(MERGE_SUITE);\n\n    if (getRunner() == null) {\n      setRunner(AbstractCoverageRunner.getInstance(IDEACoverageRunner.class)); //default\n    }\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    LOG.assertTrue(project != null);\n\n    final BaseCoverageSuite currentSuite = CoverageDataManager.getInstance(project).getCurrentSuite();\n    LOG.assertTrue(currentSuite != null);\n\n    final File[] traceFiles = getTraceFiles(project);\n\n    final Set<String> tests = new HashSet<String>();\n    Runnable runnable = new Runnable() {\n      public void run() {\n        for (File traceFile : traceFiles) {\n          DataInputStream in = null;\n          try {\n            in = new DataInputStream(new FileInputStream(traceFile));\n            extractTests(traceFile, in, tests);\n          }\n          catch (Exception ex) {\n            LOG.error(traceFile.getName(), ex);\n          }\n          finally {\n            try {\n              in.close();\n            }\n            catch (IOException ex) {\n              LOG.error(ex);\n            }\n          }\n        }\n      }\n    };\n\n    if (ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable, \"Exctract information about tests\", false,\n                                                                          project)) { //todo cache them? show nothing found message\n      final String[] testNames = ArrayUtil.toStringArray(tests);\n      Arrays.sort(testNames);\n      final List<PsiElement> elements = new ArrayList<PsiElement>();\n      final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n      for (String testName : testNames) {\n        final PsiClass psiClass =\n            facade.findClass(testName.substring(0, testName.lastIndexOf(\".\")), GlobalSearchScope.projectScope(project));\n        if (psiClass != null) {\n          final PsiMethod[] testsByName = psiClass.findMethodsByName(testName.substring(testName.lastIndexOf(\".\") + 1), true);\n          if (testsByName.length == 1) {\n            elements.add(testsByName[0]);\n          }\n        }\n      }\n      final ImplementationViewComponent component = new ImplementationViewComponent(elements.toArray(new PsiElement[elements.size()]), 0);\n      if (component.hasElementsToShow()) {\n        final String title = \"Tests covering line \" + myClassFQName + \":\" + myLineData.getLineNumber();\n        final JBPopup popup =\n            JBPopupFactory.getInstance().createComponentPopupBuilder(component, component.getPrefferedFocusableComponent())\n                .setRequestFocusCondition(project, NotLookupOrSearchCondition.INSTANCE)\n                .setProject(project)\n                .setDimensionServiceKey(project, \"ShowTestsPopup\", false)\n                .setResizable(true)\n                .setMovable(true)\n                .setTitle(title)\n                .createPopup();\n        popup.showInBestPositionFor(DataManager.getInstance().getDataContext());\n        component.setHint(popup, title);\n      }\n    }\n  }","id":31055,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    LOG.assertTrue(project != null);\n\n    final CoverageSuite currentSuite = CoverageDataManager.getInstance(project).getCurrentSuite();\n    LOG.assertTrue(currentSuite != null);\n\n    final File[] traceFiles = getTraceFiles(project);\n\n    final Set<String> tests = new HashSet<String>();\n    Runnable runnable = new Runnable() {\n      public void run() {\n        for (File traceFile : traceFiles) {\n          DataInputStream in = null;\n          try {\n            in = new DataInputStream(new FileInputStream(traceFile));\n            extractTests(traceFile, in, tests);\n          }\n          catch (Exception ex) {\n            LOG.error(traceFile.getName(), ex);\n          }\n          finally {\n            try {\n              in.close();\n            }\n            catch (IOException ex) {\n              LOG.error(ex);\n            }\n          }\n        }\n      }\n    };\n\n    if (ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable, \"Exctract information about tests\", false,\n                                                                          project)) { //todo cache them? show nothing found message\n      final String[] testNames = ArrayUtil.toStringArray(tests);\n      Arrays.sort(testNames);\n      final List<PsiElement> elements = new ArrayList<PsiElement>();\n      final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n      for (String testName : testNames) {\n        final PsiClass psiClass =\n            facade.findClass(testName.substring(0, testName.lastIndexOf(\".\")), GlobalSearchScope.projectScope(project));\n        if (psiClass != null) {\n          final PsiMethod[] testsByName = psiClass.findMethodsByName(testName.substring(testName.lastIndexOf(\".\") + 1), true);\n          if (testsByName.length == 1) {\n            elements.add(testsByName[0]);\n          }\n        }\n      }\n      final ImplementationViewComponent component = new ImplementationViewComponent(elements.toArray(new PsiElement[elements.size()]), 0);\n      if (component.hasElementsToShow()) {\n        final String title = \"Tests covering line \" + myClassFQName + \":\" + myLineData.getLineNumber();\n        final JBPopup popup =\n            JBPopupFactory.getInstance().createComponentPopupBuilder(component, component.getPrefferedFocusableComponent())\n                .setRequestFocusCondition(project, NotLookupOrSearchCondition.INSTANCE)\n                .setProject(project)\n                .setDimensionServiceKey(project, \"ShowTestsPopup\", false)\n                .setResizable(true)\n                .setMovable(true)\n                .setTitle(title)\n                .createPopup();\n        popup.showInBestPositionFor(DataManager.getInstance().getDataContext());\n        component.setHint(popup, title);\n      }\n    }\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(final AnActionEvent e) {\n    final Presentation presentation = e.getPresentation();\n    presentation.setEnabled(false);\n    if (myLineData != null && myLineData.getStatus() != LineCoverage.NONE) {\n      final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n      if (project != null) {\n        final File[] files = getTraceFiles(project);\n        if (files != null && files.length > 0) {\n          presentation.setEnabled(((CoverageSuiteImpl)CoverageDataManager.getInstance(project).getCurrentSuite()).isCoverageByTestEnabled());\n        }\n      }\n    }\n  }","id":31056,"modified_method":"@Override\n  public void update(final AnActionEvent e) {\n    final Presentation presentation = e.getPresentation();\n    presentation.setEnabled(false);\n    if (myLineData != null && myLineData.getStatus() != LineCoverage.NONE) {\n      final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n      if (project != null) {\n        final File[] files = getTraceFiles(project);\n        if (files != null && files.length > 0) {\n          presentation.setEnabled(CoverageDataManager.getInstance(project).getCurrentSuite().isCoverageByTestEnabled());\n        }\n      }\n    }\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static File[] getTraceFiles(Project project) {\n    final BaseCoverageSuite currentSuite = CoverageDataManager.getInstance(project).getCurrentSuite();\n    LOG.assertTrue(currentSuite != null); //highlight won't be available otherwise\n\n    final String filePath = currentSuite.getCoverageDataFileName();\n    final String dirName = FileUtil.getNameWithoutExtension(new File(filePath).getName());\n\n    final File parentDir = new File(filePath).getParentFile();\n    final File tracesDir = new File(parentDir, dirName);\n\n    return tracesDir.listFiles();\n  }","id":31057,"modified_method":"private static File[] getTraceFiles(Project project) {\n    final CoverageSuite currentSuite = CoverageDataManager.getInstance(project).getCurrentSuite();\n    LOG.assertTrue(currentSuite != null); //highlight won't be available otherwise\n\n    final String filePath = currentSuite.getCoverageDataFileName();\n    final String dirName = FileUtil.getNameWithoutExtension(new File(filePath).getName());\n\n    final File parentDir = new File(filePath).getParentFile();\n    final File tracesDir = new File(parentDir, dirName);\n\n    return tracesDir.listFiles();\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showCoverageInformation(final CoverageSuiteImpl suite) {\n    final MarkupModel markupModel = myDocument.getMarkupModel(myProject);\n    final List<RangeHighlighter> highlighters = new ArrayList<RangeHighlighter>();\n    final ProjectData data = suite.getCoverageData(CoverageDataManager.getInstance(myProject));\n    if (data == null) {\n      coverageDataNotFound(suite);\n      return;\n    }\n\n    final TIntIntHashMap oldToNewLineMapping = getOldToNewLineMapping(suite.getLastCoverageTimeStamp());\n    if (oldToNewLineMapping == null) {\n      showEditorWarningMessage(CodeInsightBundle.message(\"coverage.data.outdated\"));\n      return;\n    }\n\n\n    final Module module = ModuleUtil.findModuleForPsiElement(myFile);\n    if (module == null) return;\n\n    final VirtualFile outputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPath();\n    final VirtualFile testOutputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPathForTests();\n\n    if (outputpath == null || (suite.isTrackTestFolders() && testOutputpath == null)) {\n      if (Messages.showOkCancelDialog(\n        \"Project class files are out of date. Would you like to recompile? The refusal to do it will result in incomplete coverage information\",\n        \"Project is out of date\", Messages.getWarningIcon()) == DialogWrapper.OK_EXIT_CODE) {\n        final CompilerManager compilerManager = CompilerManager.getInstance(myProject);\n        compilerManager.make(compilerManager.createProjectCompileScope(myProject), new CompileStatusNotification() {\n          public void finished(final boolean aborted, final int errors, final int warnings, final CompileContext compileContext) {\n            if (aborted || errors != 0) return;\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                CoverageDataManager.getInstance(myProject).chooseSuite(suite);\n              }\n            });\n          }\n        });\n      }\n      return;\n    }\n\n    final String packageFQName = ((PsiClassOwner)myFile).getPackageName();\n    final String packageVmName = packageFQName.replace('.', '/');\n\n    final List<VirtualFile> children = new ArrayList<VirtualFile>();\n    final VirtualFile vDir = packageVmName.length() > 0 ? outputpath.findFileByRelativePath(packageVmName) : outputpath;\n    if (vDir != null) {\n      Collections.addAll(children, vDir.getChildren());\n    }\n\n    if (suite.isTrackTestFolders()) {\n      final VirtualFile testDir = packageVmName.length() > 0 ? testOutputpath.findFileByRelativePath(packageVmName) : testOutputpath;\n      if (testDir != null) {\n        Collections.addAll(children, testDir.getChildren());\n      }\n    }\n\n    final Set<VirtualFile> classFiles = new HashSet<VirtualFile>();\n    for (PsiClass psiClass : ((PsiClassOwner)myFile).getClasses()) {\n      final String className = psiClass.getName();\n      for (VirtualFile child : children) {\n        if (child.getFileType().equals(StdFileTypes.CLASS)) {\n          final String childName = child.getNameWithoutExtension();\n          if (childName.equals(className) ||  //class or inner\n              childName.startsWith(className) && childName.charAt(className.length()) == '$') {\n            classFiles.add(child);\n          }\n        }\n      }\n    }\n\n    final boolean subCoverageActive = ((CoverageDataManagerImpl)CoverageDataManager.getInstance(myProject)).isSubCoverageActive();\n    final boolean coverageByTestApplicable = suite.isCoverageByTestApplicable() && !(subCoverageActive && suite.isCoverageByTestEnabled());\n    final TreeMap<Integer, LineData> executableLines = new TreeMap<Integer, LineData>();\n    final TreeMap<Integer, ClassData> classLines = new TreeMap<Integer, ClassData>();\n    for (VirtualFile classFile : classFiles) {\n      final String qualifiedName = StringUtil.getQualifiedName(packageFQName, classFile.getNameWithoutExtension());\n      final ClassData classData = data.getClassData(qualifiedName);\n      if (classData != null) {\n        final Object[] lines = classData.getLines();\n        for (Object lineData : lines) {\n          if (lineData instanceof LineData) {\n            final int line = ((LineData)lineData).getLineNumber() - 1;\n            if (oldToNewLineMapping.contains(line)) {\n              final int lineNumberInCurrent = oldToNewLineMapping.get(line);\n              LOG.assertTrue(lineNumberInCurrent < myDocument.getLineCount());\n              executableLines.put(line, (LineData)lineData);\n              classLines.put(line, classData);\n              final RangeHighlighter highlighter =\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classData, line, lineNumberInCurrent);\n              highlighters.add(highlighter);\n            }\n          }\n        }\n      }\n      else if (!subCoverageActive && (suite.isClassFiltered(qualifiedName) || suite.isPackageFiltered(packageFQName))) {\n        collectNonCoveredClassInfo(classFile, highlighters, markupModel, executableLines, coverageByTestApplicable);\n      }\n    }\n\n    final DocumentListener documentListener = new DocumentAdapter() {\n      @Override\n      public void documentChanged(final DocumentEvent e) {\n        myNewToOldLines = null;\n        myOldToNewLines = null;\n        final TIntIntHashMap newToOldLineMapping = getNewToOldLineMapping(suite.getLastCoverageTimeStamp());\n        if (newToOldLineMapping != null) {\n          List<RangeHighlighter> rangeHighlighters = myFile.getUserData(COVERAGE_HIGHLIGHTERS);\n          if (rangeHighlighters == null) rangeHighlighters = new ArrayList<RangeHighlighter>();\n          int offset = e.getOffset();\n          final int lineNumber = myDocument.getLineNumber(offset);\n          final int lastLineNumber = myDocument.getLineNumber(offset + e.getNewLength());\n          final TextRange changeRange =\n              new TextRange(myDocument.getLineStartOffset(lineNumber), myDocument.getLineEndOffset(lastLineNumber));\n          for (Iterator<RangeHighlighter> it = rangeHighlighters.iterator(); it.hasNext();) {\n            final RangeHighlighter highlighter = it.next();\n            if (!highlighter.isValid() || new TextRange(highlighter.getStartOffset(), highlighter.getEndOffset()).intersects(changeRange)) {\n              myDocument.getMarkupModel(myProject).removeHighlighter(highlighter);\n              it.remove();\n            }\n          }\n\n          for (int line = lineNumber; line <= lastLineNumber; line++) {\n            final int oldLineNumber = newToOldLineMapping.get(line);\n            final LineData lineData = executableLines.get(oldLineNumber);\n            if (lineData != null) {\n              rangeHighlighters.add(\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classLines.get(oldLineNumber), oldLineNumber, line));\n            }\n          }\n          myFile.putUserData(COVERAGE_HIGHLIGHTERS, rangeHighlighters.size() > 0 ? rangeHighlighters : null);\n        }\n      }\n    };\n    myDocument.addDocumentListener(documentListener);\n    myFile.putUserData(COVERAGE_DOCUMENT_LISTENER, documentListener);\n\n    if (highlighters.size() > 0) {\n      myFile.putUserData(COVERAGE_HIGHLIGHTERS, highlighters);\n    }\n  }","id":31058,"modified_method":"public void showCoverageInformation(final CoverageSuite suite) {\n    final MarkupModel markupModel = myDocument.getMarkupModel(myProject);\n    final List<RangeHighlighter> highlighters = new ArrayList<RangeHighlighter>();\n    final ProjectData data = suite.getCoverageData(CoverageDataManager.getInstance(myProject));\n    if (data == null) {\n      coverageDataNotFound(suite);\n      return;\n    }\n\n    final TIntIntHashMap oldToNewLineMapping = getOldToNewLineMapping(suite.getLastCoverageTimeStamp());\n    if (oldToNewLineMapping == null) {\n      showEditorWarningMessage(CodeInsightBundle.message(\"coverage.data.outdated\"));\n      return;\n    }\n\n\n    final Module module = ModuleUtil.findModuleForPsiElement(myFile);\n    if (module == null) return;\n\n    final VirtualFile outputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPath();\n    final VirtualFile testOutputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPathForTests();\n\n    if (outputpath == null || (suite.isTrackTestFolders() && testOutputpath == null)) {\n      if (Messages.showOkCancelDialog(\n        \"Project class files are out of date. Would you like to recompile? The refusal to do it will result in incomplete coverage information\",\n        \"Project is out of date\", Messages.getWarningIcon()) == DialogWrapper.OK_EXIT_CODE) {\n        final CompilerManager compilerManager = CompilerManager.getInstance(myProject);\n        compilerManager.make(compilerManager.createProjectCompileScope(myProject), new CompileStatusNotification() {\n          public void finished(final boolean aborted, final int errors, final int warnings, final CompileContext compileContext) {\n            if (aborted || errors != 0) return;\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                CoverageDataManager.getInstance(myProject).chooseSuite(suite);\n              }\n            });\n          }\n        });\n      }\n      return;\n    }\n\n    final String packageFQName = ((PsiClassOwner)myFile).getPackageName();\n    final String packageVmName = packageFQName.replace('.', '/');\n\n    final List<VirtualFile> children = new ArrayList<VirtualFile>();\n    final VirtualFile vDir = packageVmName.length() > 0 ? outputpath.findFileByRelativePath(packageVmName) : outputpath;\n    if (vDir != null) {\n      Collections.addAll(children, vDir.getChildren());\n    }\n\n    if (suite.isTrackTestFolders()) {\n      final VirtualFile testDir = packageVmName.length() > 0 ? testOutputpath.findFileByRelativePath(packageVmName) : testOutputpath;\n      if (testDir != null) {\n        Collections.addAll(children, testDir.getChildren());\n      }\n    }\n\n    final Set<VirtualFile> classFiles = new HashSet<VirtualFile>();\n    for (PsiClass psiClass : ((PsiClassOwner)myFile).getClasses()) {\n      final String className = psiClass.getName();\n      for (VirtualFile child : children) {\n        if (child.getFileType().equals(StdFileTypes.CLASS)) {\n          final String childName = child.getNameWithoutExtension();\n          if (childName.equals(className) ||  //class or inner\n              childName.startsWith(className) && childName.charAt(className.length()) == '$') {\n            classFiles.add(child);\n          }\n        }\n      }\n    }\n\n    final boolean subCoverageActive = ((CoverageDataManagerImpl)CoverageDataManager.getInstance(myProject)).isSubCoverageActive();\n    final boolean coverageByTestApplicable = suite.isCoverageByTestApplicable() && !(subCoverageActive && suite.isCoverageByTestEnabled());\n    final TreeMap<Integer, LineData> executableLines = new TreeMap<Integer, LineData>();\n    final TreeMap<Integer, ClassData> classLines = new TreeMap<Integer, ClassData>();\n    for (VirtualFile classFile : classFiles) {\n      final String qualifiedName = StringUtil.getQualifiedName(packageFQName, classFile.getNameWithoutExtension());\n      final ClassData classData = data.getClassData(qualifiedName);\n      if (classData != null) {\n        final Object[] lines = classData.getLines();\n        for (Object lineData : lines) {\n          if (lineData instanceof LineData) {\n            final int line = ((LineData)lineData).getLineNumber() - 1;\n            if (oldToNewLineMapping.contains(line)) {\n              final int lineNumberInCurrent = oldToNewLineMapping.get(line);\n              LOG.assertTrue(lineNumberInCurrent < myDocument.getLineCount());\n              executableLines.put(line, (LineData)lineData);\n              classLines.put(line, classData);\n              final RangeHighlighter highlighter =\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classData, line, lineNumberInCurrent);\n              highlighters.add(highlighter);\n            }\n          }\n        }\n      }\n      else if (!subCoverageActive && (((CoverageSuiteImpl)suite).isClassFiltered(qualifiedName) || ((CoverageSuiteImpl)suite).isPackageFiltered(packageFQName))) {\n        collectNonCoveredClassInfo(classFile, highlighters, markupModel, executableLines, coverageByTestApplicable);\n      }\n    }\n\n    final DocumentListener documentListener = new DocumentAdapter() {\n      @Override\n      public void documentChanged(final DocumentEvent e) {\n        myNewToOldLines = null;\n        myOldToNewLines = null;\n        final TIntIntHashMap newToOldLineMapping = getNewToOldLineMapping(suite.getLastCoverageTimeStamp());\n        if (newToOldLineMapping != null) {\n          List<RangeHighlighter> rangeHighlighters = myFile.getUserData(COVERAGE_HIGHLIGHTERS);\n          if (rangeHighlighters == null) rangeHighlighters = new ArrayList<RangeHighlighter>();\n          int offset = e.getOffset();\n          final int lineNumber = myDocument.getLineNumber(offset);\n          final int lastLineNumber = myDocument.getLineNumber(offset + e.getNewLength());\n          final TextRange changeRange =\n              new TextRange(myDocument.getLineStartOffset(lineNumber), myDocument.getLineEndOffset(lastLineNumber));\n          for (Iterator<RangeHighlighter> it = rangeHighlighters.iterator(); it.hasNext();) {\n            final RangeHighlighter highlighter = it.next();\n            if (!highlighter.isValid() || new TextRange(highlighter.getStartOffset(), highlighter.getEndOffset()).intersects(changeRange)) {\n              myDocument.getMarkupModel(myProject).removeHighlighter(highlighter);\n              it.remove();\n            }\n          }\n\n          for (int line = lineNumber; line <= lastLineNumber; line++) {\n            final int oldLineNumber = newToOldLineMapping.get(line);\n            final LineData lineData = executableLines.get(oldLineNumber);\n            if (lineData != null) {\n              rangeHighlighters.add(\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classLines.get(oldLineNumber), oldLineNumber, line));\n            }\n          }\n          myFile.putUserData(COVERAGE_HIGHLIGHTERS, rangeHighlighters.size() > 0 ? rangeHighlighters : null);\n        }\n      }\n    };\n    myDocument.addDocumentListener(documentListener);\n    myFile.putUserData(COVERAGE_DOCUMENT_LISTENER, documentListener);\n\n    if (highlighters.size() > 0) {\n      myFile.putUserData(COVERAGE_HIGHLIGHTERS, highlighters);\n    }\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void coverageDataNotFound(final CoverageSuiteImpl suite) {\n    showEditorWarningMessage(CodeInsightBundle.message(\"coverage.data.not.found\"));\n    CoverageDataManager.getInstance(myProject).removeCoverageSuite(suite);\n  }","id":31059,"modified_method":"private void coverageDataNotFound(final CoverageSuite suite) {\n    showEditorWarningMessage(CodeInsightBundle.message(\"coverage.data.not.found\"));\n    CoverageDataManager.getInstance(myProject).removeCoverageSuite(suite);\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract boolean hasSeparatorAbove(BaseCoverageSuite suite);","id":31060,"modified_method":"protected abstract boolean hasSeparatorAbove(CoverageSuite suite);","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void customizeCellRenderer(final JList list,\n                                         final Object value, final int index, final boolean selected, final boolean hasFocus) {\n      BaseCoverageSuite suite = (BaseCoverageSuite)value;\n      final SimpleTextAttributes attributes = suite == myCoverageManager.getCurrentSuite() ?\n                                              SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES :\n                                              SimpleTextAttributes.REGULAR_ATTRIBUTES;\n      append(suite != null ? suite.getPresentableName() : CodeInsightBundle.message(\"no.coverage\"), attributes);\n      if (suite != null) {\n        final String date = \" (\" + DateFormatUtil.formatDate(new Date(), new Date(suite.getLastCoverageTimeStamp())) + \")\";\n        append(date, SimpleTextAttributes.GRAY_ATTRIBUTES);\n      }\n    }","id":31061,"modified_method":"protected void customizeCellRenderer(final JList list,\n                                         final Object value, final int index, final boolean selected, final boolean hasFocus) {\n      CoverageSuite suite = (CoverageSuite)value;\n      final SimpleTextAttributes attributes = suite == myCoverageManager.getCurrentSuite() ?\n                                              SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES :\n                                              SimpleTextAttributes.REGULAR_ATTRIBUTES;\n      append(suite != null ? suite.getPresentableName() : CodeInsightBundle.message(\"no.coverage\"), attributes);\n      if (suite != null) {\n        final String date = \" (\" + DateFormatUtil.formatDate(new Date(), new Date(suite.getLastCoverageTimeStamp())) + \")\";\n        append(date, SimpleTextAttributes.GRAY_ATTRIBUTES);\n      }\n    }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void fillCoverageSuites(final ArrayList<CoverageSuite> model,\n                                         final List<CoverageSuite> firstInGroup,\n                                         final CoverageDataManager coverageManager) {\n    final CoverageSuite[] suites = coverageManager.getSuites();\n    final Map<String, List<BaseCoverageSuite>> grouped = new TreeMap<String, List<BaseCoverageSuite>>();\n    for (CoverageSuite suite : suites) {\n      final CoverageFileProvider coverageFileProvider = ((CoverageSuiteImpl)suite).getCoverageDataFileProvider();\n      if (suite.isValid()) {\n        final String sourceProvider =\n          coverageFileProvider instanceof DefaultCoverageFileProvider ? ((DefaultCoverageFileProvider)coverageFileProvider)\n            .getSourceProvider() : coverageFileProvider.getClass().getName();\n        List<BaseCoverageSuite> coverageSuiteList = grouped.get(sourceProvider);\n        if (coverageSuiteList == null) {\n          coverageSuiteList = new ArrayList<BaseCoverageSuite>();\n          grouped.put(sourceProvider, coverageSuiteList);\n        }\n        coverageSuiteList.add(suite);\n      }\n    }\n\n    final List<CoverageSuite> firstInGroup = new ArrayList<CoverageSuite>();\n    for (String provider : grouped.keySet()) {\n      final List<BaseCoverageSuite> toSort = grouped.get(provider);\n      if (toSort.isEmpty()) continue;\n      Collections.sort(toSort, new Comparator<BaseCoverageSuite>() {\n        public int compare(final BaseCoverageSuite s1, final BaseCoverageSuite s2) {\n          return s1.getPresentableName().compareToIgnoreCase(s2.getPresentableName());\n        }\n      });\n      for (BaseCoverageSuite suite : toSort) {\n        model.add(suite);\n      }\n      firstInGroup.add(toSort.get(0));\n    }\n    model.add(null);\n\n    final JList list = new JList(model);\n    list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    list.setCellRenderer(new MyCellRenderer(coverageManager) {\n      protected boolean hasSeparatorAbove(final BaseCoverageSuite suite) {\n        return suite == null || (suite != model.getElementAt(0) && firstInGroup.contains(suite));\n      }\n    });\n\n    final Runnable chosen = new Runnable(){\n      public void run() {\n        final BaseCoverageSuite suite = (BaseCoverageSuite)list.getSelectedValue();\n        coverageManager.chooseSuite(suite);\n      }\n    };\n\n    final JBPopup popup = new PopupChooserBuilder(list).\n      setTitle(CodeInsightBundle.message(\"title.popup.show.coverage\")).\n      setMovable(true).\n      setItemChoosenCallback(chosen).\n      createPopup();\n\n    list.registerKeyboardAction(\n      new RemoveSuiteAction(list, coverageManager, model, popup, chosen),\n      KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),\n      JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT\n    );\n\n    popup.showCenteredInCurrentWindow(project);\n  }","id":31062,"modified_method":"private static void fillCoverageSuites(final ArrayList<CoverageSuite> model,\n                                         final List<CoverageSuite> firstInGroup,\n                                         final CoverageDataManager coverageManager) {\n    final CoverageSuite[] suites = coverageManager.getSuites();\n    final Map<String, List<CoverageSuite>> grouped = new TreeMap<String, List<CoverageSuite>>();\n    for (CoverageSuite suite : suites) {\n      final CoverageFileProvider coverageFileProvider = suite.getCoverageDataFileProvider();\n      if (suite.isValid()) {\n        final String sourceProvider =\n          coverageFileProvider instanceof DefaultCoverageFileProvider ? ((DefaultCoverageFileProvider)coverageFileProvider)\n            .getSourceProvider() : coverageFileProvider.getClass().getName();\n        List<CoverageSuite> coverageSuiteList = grouped.get(sourceProvider);\n        if (coverageSuiteList == null) {\n          coverageSuiteList = new ArrayList<CoverageSuite>();\n          grouped.put(sourceProvider, coverageSuiteList);\n        }\n        coverageSuiteList.add(suite);\n      }\n    }\n\n    final List<CoverageSuite> firstInGroup = new ArrayList<CoverageSuite>();\n    for (String provider : grouped.keySet()) {\n      final List<CoverageSuite> toSort = grouped.get(provider);\n      if (toSort.isEmpty()) continue;\n      Collections.sort(toSort, new Comparator<CoverageSuite>() {\n        public int compare(final CoverageSuite s1, final CoverageSuite s2) {\n          return s1.getPresentableName().compareToIgnoreCase(s2.getPresentableName());\n        }\n      });\n      for (CoverageSuite suite : toSort) {\n        model.addElement(suite);\n      }\n      firstInGroup.add(toSort.get(0));\n    }\n    model.add(null);\n\n    final JList list = new JList(model);\n    list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    list.setCellRenderer(new MyCellRenderer(coverageManager) {\n      protected boolean hasSeparatorAbove(final CoverageSuite suite) {\n        return suite == null || (suite != model.getElementAt(0) && firstInGroup.contains(suite));\n      }\n    });\n\n    final Runnable chosen = new Runnable(){\n      public void run() {\n        final CoverageSuite suite = (CoverageSuite)list.getSelectedValue();\n        coverageManager.chooseSuite(suite);\n      }\n    };\n\n    final JBPopup popup = new PopupChooserBuilder(list).\n      setTitle(CodeInsightBundle.message(\"title.popup.show.coverage\")).\n      setMovable(true).\n      setItemChoosenCallback(chosen).\n      createPopup();\n\n    list.registerKeyboardAction(\n      new RemoveSuiteAction(list, coverageManager, model, popup, chosen),\n      KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),\n      JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT\n    );\n\n    popup.showCenteredInCurrentWindow(project);\n  }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getListCellRendererComponent(final JList list,\n                                                  final Object value, final int index, final boolean isSelected, final boolean cellHasFocus) {\n      final Component coloredComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n      setPaintFocusBorder(false);\n      BaseCoverageSuite suite = (BaseCoverageSuite)value;\n      JPanel panel = new JPanel(new BorderLayout());\n      panel.add(coloredComponent, BorderLayout.CENTER);\n      if (hasSeparatorAbove(suite)) {\n        final TitledSeparator titledSeparator = new TitledSeparator();\n        titledSeparator.setOpaque(false);\n        panel.add(titledSeparator, BorderLayout.NORTH);\n      }\n      if (isSelected && suite != null) {\n        final JLabel label = new JLabel(CLEAN_ICON);\n        label.setOpaque(true);\n        label.setBackground(UIUtil.getListSelectionBackground());\n        panel.add(label, BorderLayout.EAST);\n      }\n      panel.setBackground(UIUtil.getListBackground());\n      return panel;\n    }","id":31063,"modified_method":"public Component getListCellRendererComponent(final JList list,\n                                                  final Object value, final int index, final boolean isSelected, final boolean cellHasFocus) {\n      final Component coloredComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n      BaseCoverageSuite suite = (BaseCoverageSuite)value;\n      JPanel panel = new JPanel(new BorderLayout());\n      panel.add(coloredComponent, BorderLayout.CENTER);\n      if (hasSeparatorAbove(suite)) {\n        final TitledSeparator titledSeparator = new TitledSeparator();\n        titledSeparator.setOpaque(false);\n        panel.add(titledSeparator, BorderLayout.NORTH);\n      }\n      if (isSelected && suite != null) {\n        final JLabel label = new JLabel(CLEAN_ICON);\n        label.setOpaque(true);\n        label.setBackground(UIUtil.getListSelectionBackground());\n        panel.add(label, BorderLayout.EAST);\n      }\n      panel.setBackground(UIUtil.getListBackground());\n      return panel;\n    }","commit_id":"28cdd4ecd896bfd35fe0b430069dd9329a857598","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void collectNonCoveredClassInfo(final VirtualFile classFile,\n                                          final List<RangeHighlighter> highlighters,\n                                          final MarkupModel markupModel,\n                                          final TreeMap<Integer, LineData> executableLines, final boolean coverageByTestApplicable) {\n    final TIntIntHashMap mapping;\n    if (classFile.getTimeStamp() < getVirtualFile().getTimeStamp()) {\n      mapping = getOldToNewLineMapping(classFile.getTimeStamp());\n      if (mapping == null) return;\n    }\n    else {\n      mapping = null;\n    }\n\n    final byte[] content;\n    try {\n      content = classFile.contentsToByteArray();\n    }\n    catch (IOException e) {\n      return;\n    }\n\n    ClassReader reader = new ClassReader(content, 0, content.length);\n    final CoverageSuiteImpl coverageSuite = (CoverageSuiteImpl)CoverageDataManager.getInstance(myProject).getCurrentSuite();\n    SourceLineCounter collector = new SourceLineCounter(new EmptyVisitor(), null, coverageSuite.getRunner() instanceof IDEACoverageRunner && coverageSuite.isTracingEnabled());\n    reader.accept(collector, 0);\n    final TIntObjectHashMap lines = collector.getSourceLines();\n    lines.forEachKey(new TIntProcedure() {\n      public boolean execute(int line) {\n        line--;\n        int lineNumber = line;\n        if (mapping != null) line = mapping.get(line);\n        if (line >= myDocument.getLineCount()) return true;\n        executableLines.put(line, null);\n        final RangeHighlighter highlighter =\n            createRangeHighlighter(classFile.getTimeStamp(), markupModel, coverageByTestApplicable, executableLines, null, lineNumber,\n                                   line);\n        highlighters.add(highlighter);\n        return true;\n      }\n    });\n  }","id":31064,"modified_method":"private void collectNonCoveredClassInfo(final VirtualFile classFile,\n                                          final List<RangeHighlighter> highlighters,\n                                          final MarkupModel markupModel,\n                                          final TreeMap<Integer, LineData> executableLines,\n                                          final boolean coverageByTestApplicable) {\n    final TIntIntHashMap mapping;\n    if (classFile.getTimeStamp() < getVirtualFile().getTimeStamp()) {\n      mapping = getOldToNewLineMapping(classFile.getTimeStamp());\n      if (mapping == null) return;\n    }\n    else {\n      mapping = null;\n    }\n\n\n    final CoverageSuite coverageSuite = CoverageDataManager.getInstance(myProject).getCurrentSuite();\n\n    final List<Integer> uncoveredLines = coverageSuite.collectNotCoveredFileLines(classFile, coverageSuite);\n    if (uncoveredLines == null) {\n      return;\n    }\n    final int lineCount = myDocument.getLineCount();\n    for (int lineNumber : uncoveredLines) {\n      if (lineNumber >= lineCount) {\n        continue;\n      }\n\n      final int updatedlineNumber = mapping != null ? mapping.get(lineNumber) : lineNumber;\n\n      executableLines.put(updatedlineNumber, null);\n      final RangeHighlighter highlighter =\n        createRangeHighlighter(classFile.getTimeStamp(), markupModel, coverageByTestApplicable, executableLines, null, lineNumber,\n                               updatedlineNumber, coverageSuite);\n      highlighters.add(highlighter);\n    }\n  }","commit_id":"3af068d56745125451d017f6be01598c01e13f5c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showCoverageInformation(final CoverageSuite suite) {\n    final MarkupModel markupModel = myDocument.getMarkupModel(myProject);\n    final List<RangeHighlighter> highlighters = new ArrayList<RangeHighlighter>();\n    final ProjectData data = suite.getCoverageData(CoverageDataManager.getInstance(myProject));\n    if (data == null) {\n      coverageDataNotFound(suite);\n      return;\n    }\n\n    final TIntIntHashMap oldToNewLineMapping = getOldToNewLineMapping(suite.getLastCoverageTimeStamp());\n    if (oldToNewLineMapping == null) {\n      showEditorWarningMessage(CodeInsightBundle.message(\"coverage.data.outdated\"));\n      return;\n    }\n\n\n    final Module module = ModuleUtil.findModuleForPsiElement(myFile);\n    if (module == null) return;\n\n    final VirtualFile outputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPath();\n    final VirtualFile testOutputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPathForTests();\n\n    if (outputpath == null || (suite.isTrackTestFolders() && testOutputpath == null)) {\n      if (Messages.showOkCancelDialog(\n        \"Project class files are out of date. Would you like to recompile? The refusal to do it will result in incomplete coverage information\",\n        \"Project is out of date\", Messages.getWarningIcon()) == DialogWrapper.OK_EXIT_CODE) {\n        final CompilerManager compilerManager = CompilerManager.getInstance(myProject);\n        compilerManager.make(compilerManager.createProjectCompileScope(myProject), new CompileStatusNotification() {\n          public void finished(final boolean aborted, final int errors, final int warnings, final CompileContext compileContext) {\n            if (aborted || errors != 0) return;\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                CoverageDataManager.getInstance(myProject).chooseSuite(suite);\n              }\n            });\n          }\n        });\n      }\n      return;\n    }\n\n    final String packageFQName = ((PsiClassOwner)myFile).getPackageName();\n    final String packageVmName = packageFQName.replace('.', '/');\n\n    final List<VirtualFile> children = new ArrayList<VirtualFile>();\n    final VirtualFile vDir = packageVmName.length() > 0 ? outputpath.findFileByRelativePath(packageVmName) : outputpath;\n    if (vDir != null) {\n      Collections.addAll(children, vDir.getChildren());\n    }\n\n    if (suite.isTrackTestFolders()) {\n      final VirtualFile testDir = packageVmName.length() > 0 ? testOutputpath.findFileByRelativePath(packageVmName) : testOutputpath;\n      if (testDir != null) {\n        Collections.addAll(children, testDir.getChildren());\n      }\n    }\n\n    final Set<VirtualFile> classFiles = new HashSet<VirtualFile>();\n    for (PsiClass psiClass : ((PsiClassOwner)myFile).getClasses()) {\n      final String className = psiClass.getName();\n      for (VirtualFile child : children) {\n        if (child.getFileType().equals(StdFileTypes.CLASS)) {\n          final String childName = child.getNameWithoutExtension();\n          if (childName.equals(className) ||  //class or inner\n              childName.startsWith(className) && childName.charAt(className.length()) == '$') {\n            classFiles.add(child);\n          }\n        }\n      }\n    }\n\n    final boolean subCoverageActive = ((CoverageDataManagerImpl)CoverageDataManager.getInstance(myProject)).isSubCoverageActive();\n    final boolean coverageByTestApplicable = suite.isCoverageByTestApplicable() && !(subCoverageActive && suite.isCoverageByTestEnabled());\n    final TreeMap<Integer, LineData> executableLines = new TreeMap<Integer, LineData>();\n    final TreeMap<Integer, ClassData> classLines = new TreeMap<Integer, ClassData>();\n    for (VirtualFile classFile : classFiles) {\n      final String qualifiedName = StringUtil.getQualifiedName(packageFQName, classFile.getNameWithoutExtension());\n      final ClassData classData = data.getClassData(qualifiedName);\n      if (classData != null) {\n        final Object[] lines = classData.getLines();\n        for (Object lineData : lines) {\n          if (lineData instanceof LineData) {\n            final int line = ((LineData)lineData).getLineNumber() - 1;\n            if (oldToNewLineMapping.contains(line)) {\n              final int lineNumberInCurrent = oldToNewLineMapping.get(line);\n              LOG.assertTrue(lineNumberInCurrent < myDocument.getLineCount());\n              executableLines.put(line, (LineData)lineData);\n              classLines.put(line, classData);\n              final RangeHighlighter highlighter =\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classData, line, lineNumberInCurrent);\n              highlighters.add(highlighter);\n            }\n          }\n        }\n      }\n      else if (!subCoverageActive && (((CoverageSuiteImpl)suite).isClassFiltered(qualifiedName) || ((CoverageSuiteImpl)suite).isPackageFiltered(packageFQName))) {\n        collectNonCoveredClassInfo(classFile, highlighters, markupModel, executableLines, coverageByTestApplicable);\n      }\n    }\n\n    final DocumentListener documentListener = new DocumentAdapter() {\n      @Override\n      public void documentChanged(final DocumentEvent e) {\n        myNewToOldLines = null;\n        myOldToNewLines = null;\n        final TIntIntHashMap newToOldLineMapping = getNewToOldLineMapping(suite.getLastCoverageTimeStamp());\n        if (newToOldLineMapping != null) {\n          List<RangeHighlighter> rangeHighlighters = myFile.getUserData(COVERAGE_HIGHLIGHTERS);\n          if (rangeHighlighters == null) rangeHighlighters = new ArrayList<RangeHighlighter>();\n          int offset = e.getOffset();\n          final int lineNumber = myDocument.getLineNumber(offset);\n          final int lastLineNumber = myDocument.getLineNumber(offset + e.getNewLength());\n          final TextRange changeRange =\n              new TextRange(myDocument.getLineStartOffset(lineNumber), myDocument.getLineEndOffset(lastLineNumber));\n          for (Iterator<RangeHighlighter> it = rangeHighlighters.iterator(); it.hasNext();) {\n            final RangeHighlighter highlighter = it.next();\n            if (!highlighter.isValid() || new TextRange(highlighter.getStartOffset(), highlighter.getEndOffset()).intersects(changeRange)) {\n              myDocument.getMarkupModel(myProject).removeHighlighter(highlighter);\n              it.remove();\n            }\n          }\n\n          for (int line = lineNumber; line <= lastLineNumber; line++) {\n            final int oldLineNumber = newToOldLineMapping.get(line);\n            final LineData lineData = executableLines.get(oldLineNumber);\n            if (lineData != null) {\n              rangeHighlighters.add(\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classLines.get(oldLineNumber), oldLineNumber, line));\n            }\n          }\n          myFile.putUserData(COVERAGE_HIGHLIGHTERS, rangeHighlighters.size() > 0 ? rangeHighlighters : null);\n        }\n      }\n    };\n    myDocument.addDocumentListener(documentListener);\n    myFile.putUserData(COVERAGE_DOCUMENT_LISTENER, documentListener);\n\n    if (highlighters.size() > 0) {\n      myFile.putUserData(COVERAGE_HIGHLIGHTERS, highlighters);\n    }\n  }","id":31065,"modified_method":"public void showCoverageInformation(final CoverageSuite suite) {\n    final MarkupModel markupModel = myDocument.getMarkupModel(myProject);\n    final List<RangeHighlighter> highlighters = new ArrayList<RangeHighlighter>();\n    final ProjectData data = suite.getCoverageData(CoverageDataManager.getInstance(myProject));\n    if (data == null) {\n      coverageDataNotFound(suite);\n      return;\n    }\n\n    final TIntIntHashMap oldToNewLineMapping = getOldToNewLineMapping(suite.getLastCoverageTimeStamp());\n    if (oldToNewLineMapping == null) {\n      showEditorWarningMessage(CodeInsightBundle.message(\"coverage.data.outdated\"));\n      return;\n    }\n\n\n    final Module module = ModuleUtil.findModuleForPsiElement(myFile);\n    if (module == null) return;\n\n    final VirtualFile outputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPath();\n    final VirtualFile testOutputpath = CompilerModuleExtension.getInstance(module).getCompilerOutputPathForTests();\n\n    if (outputpath == null || (suite.isTrackTestFolders() && testOutputpath == null)) {\n      if (Messages.showOkCancelDialog(\n        \"Project class files are out of date. Would you like to recompile? The refusal to do it will result in incomplete coverage information\",\n        \"Project is out of date\", Messages.getWarningIcon()) == DialogWrapper.OK_EXIT_CODE) {\n        final CompilerManager compilerManager = CompilerManager.getInstance(myProject);\n        compilerManager.make(compilerManager.createProjectCompileScope(myProject), new CompileStatusNotification() {\n          public void finished(final boolean aborted, final int errors, final int warnings, final CompileContext compileContext) {\n            if (aborted || errors != 0) return;\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                CoverageDataManager.getInstance(myProject).chooseSuite(suite);\n              }\n            });\n          }\n        });\n      }\n      return;\n    }\n\n    final String packageFQName = ((PsiClassOwner)myFile).getPackageName();\n    final String packageVmName = packageFQName.replace('.', '/');\n\n    final List<VirtualFile> children = new ArrayList<VirtualFile>();\n    final VirtualFile vDir = packageVmName.length() > 0 ? outputpath.findFileByRelativePath(packageVmName) : outputpath;\n    if (vDir != null) {\n      Collections.addAll(children, vDir.getChildren());\n    }\n\n    if (suite.isTrackTestFolders()) {\n      final VirtualFile testDir = packageVmName.length() > 0 ? testOutputpath.findFileByRelativePath(packageVmName) : testOutputpath;\n      if (testDir != null) {\n        Collections.addAll(children, testDir.getChildren());\n      }\n    }\n\n    final Set<VirtualFile> classFiles = new HashSet<VirtualFile>();\n    for (PsiClass psiClass : ((PsiClassOwner)myFile).getClasses()) {\n      final String className = psiClass.getName();\n      for (VirtualFile child : children) {\n        if (child.getFileType().equals(StdFileTypes.CLASS)) {\n          final String childName = child.getNameWithoutExtension();\n          if (childName.equals(className) ||  //class or inner\n              childName.startsWith(className) && childName.charAt(className.length()) == '$') {\n            classFiles.add(child);\n          }\n        }\n      }\n    }\n\n    final boolean subCoverageActive = CoverageDataManager.getInstance(myProject).isSubCoverageActive();\n    final boolean coverageByTestApplicable = suite.isCoverageByTestApplicable() && !(subCoverageActive && suite.isCoverageByTestEnabled());\n    final TreeMap<Integer, LineData> executableLines = new TreeMap<Integer, LineData>();\n    final TreeMap<Integer, ClassData> classLines = new TreeMap<Integer, ClassData>();\n    for (VirtualFile classFile : classFiles) {\n      final String qualifiedName = StringUtil.getQualifiedName(packageFQName, classFile.getNameWithoutExtension());\n      final ClassData classData = data.getClassData(qualifiedName);\n      if (classData != null) {\n        final Object[] lines = classData.getLines();\n        for (Object lineData : lines) {\n          if (lineData instanceof LineData) {\n            final int line = ((LineData)lineData).getLineNumber() - 1;\n            if (oldToNewLineMapping.contains(line)) {\n              final int lineNumberInCurrent = oldToNewLineMapping.get(line);\n              LOG.assertTrue(lineNumberInCurrent < myDocument.getLineCount());\n              executableLines.put(line, (LineData)lineData);\n              classLines.put(line, classData);\n              final RangeHighlighter highlighter =\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classData, line, lineNumberInCurrent, suite);\n              highlighters.add(highlighter);\n            }\n          }\n        }\n      }\n      else if (!subCoverageActive && (((CoverageSuiteImpl)suite).isClassFiltered(qualifiedName) || ((CoverageSuiteImpl)suite).isPackageFiltered(packageFQName))) {\n        collectNonCoveredClassInfo(classFile, highlighters, markupModel, executableLines, coverageByTestApplicable);\n      }\n    }\n\n    final DocumentListener documentListener = new DocumentAdapter() {\n      @Override\n      public void documentChanged(final DocumentEvent e) {\n        myNewToOldLines = null;\n        myOldToNewLines = null;\n        final TIntIntHashMap newToOldLineMapping = getNewToOldLineMapping(suite.getLastCoverageTimeStamp());\n        if (newToOldLineMapping != null) {\n          List<RangeHighlighter> rangeHighlighters = myFile.getUserData(COVERAGE_HIGHLIGHTERS);\n          if (rangeHighlighters == null) rangeHighlighters = new ArrayList<RangeHighlighter>();\n          int offset = e.getOffset();\n          final int lineNumber = myDocument.getLineNumber(offset);\n          final int lastLineNumber = myDocument.getLineNumber(offset + e.getNewLength());\n          final TextRange changeRange =\n              new TextRange(myDocument.getLineStartOffset(lineNumber), myDocument.getLineEndOffset(lastLineNumber));\n          for (Iterator<RangeHighlighter> it = rangeHighlighters.iterator(); it.hasNext();) {\n            final RangeHighlighter highlighter = it.next();\n            if (!highlighter.isValid() || new TextRange(highlighter.getStartOffset(), highlighter.getEndOffset()).intersects(changeRange)) {\n              myDocument.getMarkupModel(myProject).removeHighlighter(highlighter);\n              it.remove();\n            }\n          }\n\n          for (int line = lineNumber; line <= lastLineNumber; line++) {\n            final int oldLineNumber = newToOldLineMapping.get(line);\n            final LineData lineData = executableLines.get(oldLineNumber);\n            if (lineData != null) {\n              rangeHighlighters.add(\n                  createRangeHighlighter(suite.getLastCoverageTimeStamp(), markupModel, coverageByTestApplicable, executableLines,\n                                         classLines.get(oldLineNumber), oldLineNumber, line, suite));\n            }\n          }\n          myFile.putUserData(COVERAGE_HIGHLIGHTERS, rangeHighlighters.size() > 0 ? rangeHighlighters : null);\n        }\n      }\n    };\n    myDocument.addDocumentListener(documentListener);\n    myFile.putUserData(COVERAGE_DOCUMENT_LISTENER, documentListener);\n\n    if (highlighters.size() > 0) {\n      myFile.putUserData(COVERAGE_HIGHLIGHTERS, highlighters);\n    }\n  }","commit_id":"3af068d56745125451d017f6be01598c01e13f5c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private RangeHighlighter createRangeHighlighter(final long date, final MarkupModel markupModel,\n                                                  final boolean coverageByTestApplicable,\n                                                  final TreeMap<Integer, LineData> executableLines, final ClassData classData,\n                                                  final int line,\n                                                  final int lineNumberInCurrent) {\n    final RangeHighlighter highlighter = markupModel.addLineHighlighter(lineNumberInCurrent, HighlighterLayer.SELECTION - 1, null);\n    final CoverageLineMarkerRenderer markerRenderer = CoverageLineMarkerRenderer\n        .getRenderer(line, classData, executableLines, coverageByTestApplicable, new Function<Integer, Integer>() {\n          public Integer fun(final Integer newLine) {\n            final TIntIntHashMap oldLineMapping = getNewToOldLineMapping(date);\n            return oldLineMapping != null ? oldLineMapping.get(newLine.intValue()) : 0;\n          }\n        }, new Function<Integer, Integer>() {\n          public Integer fun(final Integer newLine) {\n            final TIntIntHashMap newLineMapping = getOldToNewLineMapping(date);\n            return newLineMapping != null ? newLineMapping.get(newLine.intValue()) : 0;\n          }\n        });\n    highlighter.setLineMarkerRenderer(markerRenderer);\n\n    final LineData lineData = classData != null ? classData.getLineData(line + 1) : null;\n    if (lineData != null && lineData.getStatus() == LineCoverage.NONE) {\n      highlighter.setErrorStripeMarkColor(markerRenderer.getErrorStripeColor(myEditor));\n      highlighter.setThinErrorStripeMark(true);\n      highlighter.setGreedyToLeft(true);\n      highlighter.setGreedyToRight(true);\n    }\n    return highlighter;\n  }","id":31066,"modified_method":"private RangeHighlighter createRangeHighlighter(final long date, final MarkupModel markupModel,\n                                                  final boolean coverageByTestApplicable,\n                                                  final TreeMap<Integer, LineData> executableLines, final ClassData classData,\n                                                  final int line,\n                                                  final int lineNumberInCurrent,\n                                                  @NotNull final CoverageSuite coverageSuite) {\n    final RangeHighlighter highlighter = markupModel.addLineHighlighter(lineNumberInCurrent, HighlighterLayer.SELECTION - 1, null);\n    final CoverageLineMarkerRenderer markerRenderer = CoverageLineMarkerRenderer\n        .getRenderer(line, classData, executableLines, coverageByTestApplicable, coverageSuite,\n                     new Function<Integer, Integer>() {\n          public Integer fun(final Integer newLine) {\n            final TIntIntHashMap oldLineMapping = getNewToOldLineMapping(date);\n            return oldLineMapping != null ? oldLineMapping.get(newLine.intValue()) : 0;\n          }\n        },\n                     new Function<Integer, Integer>() {\n          public Integer fun(final Integer newLine) {\n            final TIntIntHashMap newLineMapping = getOldToNewLineMapping(date);\n            return newLineMapping != null ? newLineMapping.get(newLine.intValue()) : 0;\n          }\n        });\n    highlighter.setLineMarkerRenderer(markerRenderer);\n\n    final LineData lineData = classData != null ? classData.getLineData(line + 1) : null;\n    if (lineData != null && lineData.getStatus() == LineCoverage.NONE) {\n      highlighter.setErrorStripeMarkColor(markerRenderer.getErrorStripeColor(myEditor));\n      highlighter.setThinErrorStripeMark(true);\n      highlighter.setGreedyToLeft(true);\n      highlighter.setGreedyToRight(true);\n    }\n    return highlighter;\n  }","commit_id":"3af068d56745125451d017f6be01598c01e13f5c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean doChooseLanguageToInject(final Processor<String> onChosen) {\n    final String[] langIds = InjectedLanguage.getAvailableLanguageIDs();\n    Arrays.sort(langIds);\n\n    final Map<String, List<String>> map = new LinkedHashMap<String, List<String>>();\n    buildLanguageTree(langIds, map);\n\n    final BaseListPopupStep<String> step = new MyPopupStep(map, new ArrayList<String>(map.keySet()), onChosen);\n\n    final ListPopup listPopup = JBPopupFactory.getInstance().createListPopup(step);\n    listPopup.showInBestPositionFor(DataManager.getInstance().getDataContext());\n    return true;\n  }","id":31067,"modified_method":"private static boolean doChooseLanguageToInject(final Processor<String> onChosen) {\n    final String[] langIds = InjectedLanguage.getAvailableLanguageIDs();\n    Arrays.sort(langIds);\n\n    final JList list = new JList(langIds);\n    list.setCellRenderer(new DefaultListCellRenderer() {\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        final String aValue = (String)value;\n        final Language language = InjectedLanguage.findLanguageById(aValue);\n        assert language != null;\n        final FileType ft = language.getAssociatedFileType();\n        setIcon(ft != null ? ft.getIcon() : new EmptyIcon(16));\n        setText(value + (ft != null ? \" (\" + ft.getDescription() + \")\" : \"\"));\n        return this;\n      }\n    });\n    new PopupChooserBuilder(list).setItemChoosenCallback(new Runnable() {\n      public void run() {\n        final String string = (String)list.getSelectedValue();\n        onChosen.process(string);\n      }\n    }).setFilteringEnabled(new Function<Object, String>() {\n      public String fun(Object o) {\n        return (String)o;\n      }\n    }).createPopup().showInBestPositionFor(DataManager.getInstance().getDataContext());\n    return true;\n  }","commit_id":"58bb0b0706ff4b9f54e7e1dc74c87cf0aa13a363","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent event) {\n    // get basic information\n    final Project project = event.getData(PlatformDataKeys.PROJECT);\n    if (project == null || project.isDisposed()) {\n      notifyError(project, \"Project is null. \" + event.getPlace() + \", \" + event.getDataContext(), null);\n      return;\n    }\n    final VirtualFile[] vFiles = event.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    if (vFiles == null || vFiles.length != 1 || vFiles[0] == null) {\n      notifyError(project, \"Selected incorrect virtual files array: \" + Arrays.toString(vFiles), null);\n      return;\n    }\n    final VirtualFile file = vFiles[0];\n    final VirtualFile vcsRoot = VcsUtil.getVcsRootFor(project, file);\n    if (vcsRoot == null) {\n      notifyError(project, \"The file \" + file + \" is not under Git version control.\", null);\n      return;\n    }\n\n    // get all branches and current branch\n    final List<String> branches = new ArrayList<String>();\n    GitBranch curBranch = null;\n    try {\n      GitBranch.listAsStrings(project, vcsRoot, true, true, branches, null); // make it return current branch not to call the command twice.\n      curBranch = GitBranch.current(project, vcsRoot);\n    } catch (VcsException e) {\n      notifyError(project, \"Couldn't get information about current branch\", e);\n    }\n    if (curBranch == null) {\n      notifyError(project, \"Current branch is null.\", null);\n      return;\n    }\n\n    // invoke popup\n    final AtomicReference<ListPopup> popup = new AtomicReference<ListPopup>();\n    final String currentBranch = curBranch.getName();\n    final ListPopupStep<String> branchesStep = new BaseListPopupStep<String>(\"Select branch to compare\", branches) {\n      @Override\n      public PopupStep onChosen(final String selectedValue, boolean finalChoice) {\n        return doFinalStep(new Runnable() {\n          public void run() {\n            if (project.isDisposed()) { return; }\n            try {\n              showDiffWithBranch(project, file, currentBranch, selectedValue);\n              popup.get().cancel();\n            } catch (Exception e) {\n              notifyError(project, \"Couldn't compare file [\" + file + \"] with selected branch [\" + selectedValue + \"]\", e);\n            }\n          }\n        });\n      }\n    };\n    popup.set(new ListPopupImpl(branchesStep));\n    popup.get().showInBestPositionFor(event.getDataContext());\n  }","id":31068,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent event) {\n    // get basic information\n    final Project project = event.getData(PlatformDataKeys.PROJECT);\n    if (project == null || project.isDisposed()) {\n      notifyError(project, \"Project is null. \" + event.getPlace() + \", \" + event.getDataContext(), null);\n      return;\n    }\n    final VirtualFile[] vFiles = event.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    if (vFiles == null || vFiles.length != 1 || vFiles[0] == null) {\n      notifyError(project, \"Selected incorrect virtual files array: \" + Arrays.toString(vFiles), null);\n      return;\n    }\n    final VirtualFile file = vFiles[0];\n    final VirtualFile vcsRoot = VcsUtil.getVcsRootFor(project, file);\n    if (vcsRoot == null) {\n      notifyError(project, \"The file \" + file + \" is not under Git version control.\", null);\n      return;\n    }\n\n    // get branches information\n    final List<GitBranch> branches = new ArrayList<GitBranch>();\n    GitBranch curBranch = null;\n    try {\n      curBranch = GitBranch.list(project, vcsRoot, true, true, branches, null);\n    } catch (VcsException e) {\n      notifyError(project, \"Couldn't get information about current branch\", e);\n    }\n    if (curBranch == null) {\n      notifyError(project, \"Current branch is null.\", null);\n      return;\n    }\n    final String currentBranch = curBranch.getName();\n\n    // prepare and invoke popup\n    final JBList list = new JBList(branches);\n    list.installCellRenderer(new NotNullFunction<GitBranch, JComponent>() { // display current branch in bold with asterisk\n      @NotNull public JComponent fun(GitBranch branch) {\n        if (branch.isActive()) {\n          JLabel label = new JLabel(branch.getName() + \" *\");\n          final Map<TextAttribute, Float> attributes = new HashMap<TextAttribute, Float>(1);\n          attributes.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);\n          label.setFont(label.getFont().deriveFont(attributes));\n          return label;\n        }\n        return new JLabel(branch.getName());\n      }\n    });\n\n    JBPopupFactory.getInstance()\n      .createListPopupBuilder(list)\n      .setTitle(\"Select branch to compare\")\n      .setItemChoosenCallback(\n        new Runnable() {\n          public void run() {\n            Application app = ApplicationManager.getApplication();\n            if (project.isDisposed() || app == null || !app.isActive() || app.isDisposed() || app.isDisposeInProgress()) { // safe check\n              return;\n            }\n            ApplicationManager.getApplication()\n              .invokeLater(new Runnable() { // don't block awt thread - getting revision content may take long\n\n                @Override\n                public void run() {\n                  try {\n                    showDiffWithBranch(project, file, currentBranch, list.getSelectedValue().toString());\n                  }\n                  catch (Exception e) {\n                    notifyError(project, \"Couldn't compare file [\" + file + \"] with selected branch [\" + list.getSelectedValue() + \"]\", e);\n                  }\n                }\n              });\n          }\n        })\n      .setAutoselectOnMouseMove(true)\n      .createPopup()\n      .showInBestPositionFor(event.getDataContext());\n  }","commit_id":"182f009b432b72d83e92c4725c7b9ac89263153d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Pair<PsiElement, PsiElement[]> getSourceAndTargetElements(Editor editor, PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement source = TargetElementUtilBase.getInstance().findTargetElement(editor, ImplementationSearcher.getFlags(), offset);\n    PsiElement[] target = new ImplementationSearcher().searchImplementations(editor, source, offset);\n    if (target.length == 0) {\n      return new Pair<PsiElement, PsiElement[]>(source, new PsiElement[] { source });\n    }\n    return new Pair<PsiElement, PsiElement[]>(source, target);\n  }","id":31069,"modified_method":"public GotoData getSourceAndTargetElements(Editor editor, PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement source = TargetElementUtilBase.getInstance().findTargetElement(editor, ImplementationSearcher.getFlags(), offset);\n    if (source == null) return null;\n    return new GotoData(source, new ImplementationSearcher().searchImplementations(editor, source, offset), Collections.EMPTY_LIST);\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getChooserTitleKey(PsiElement sourceElement) {\n    return \"goto.implementation.chooser.title\";\n  }","id":31070,"modified_method":"protected String getChooserTitle(PsiElement sourceElement, String name, int length) {\n    return CodeInsightBundle.message(\"goto.implementation.chooserTitle\", name, length);\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void show(Project project, final Editor editor, final PsiFile file, final PsiElement sourceElement, final PsiElement[] elements) {\n    if (elements == null || elements.length == 0) {\n      handleNoVariansCase(project, editor, file);\n      return;\n    }\n\n    if (elements.length == 1 && elements[0] != null) {\n      Navigatable descriptor = elements[0] instanceof Navigatable ? (Navigatable) elements[0] : EditSourceUtil.getDescriptor(elements[0]);\n      if (descriptor != null && descriptor.canNavigate()) {\n        navigateToElement(descriptor);\n      }\n    }\n    else {\n      PsiElementListCellRenderer renderer = null;\n      for (GotoTargetRendererProvider provider : Extensions.getExtensions(GotoTargetRendererProvider.EP_NAME)) {\n        renderer = provider.getRenderer(elements);\n        if (renderer != null) break;\n      }\n\n      String titleKey;\n      if (renderer == null) {\n        renderer = new DefaultPsiElementListCellRenderer();\n        titleKey = getChooserInFileTitleKey(sourceElement);\n      } else {\n        titleKey = getChooserTitleKey(sourceElement);\n      }\n      String name = ((PsiNamedElement)sourceElement).getName();\n      String title = CodeInsightBundle.message(titleKey, name, hasNullUsage() ? elements.length - 1 : elements.length);\n\n      if (shouldSortResult()) Arrays.sort(elements, renderer.getComparator());\n\n      final JList list = new JList(elements);\n      list.setCellRenderer(renderer);\n\n\n      final Runnable runnable = new Runnable() {\n        public void run() {\n          int[] ids = list.getSelectedIndices();\n          if (ids == null || ids.length == 0) return;\n          Object[] selectedElements = list.getSelectedValues();\n          for (Object element : selectedElements) {\n            final Navigatable descriptor = element instanceof Navigatable ? (Navigatable) element : EditSourceUtil.getDescriptor((PsiElement)element);\n            if (descriptor != null) {\n              if (descriptor.canNavigate()) {\n                navigateToElement(descriptor);\n              }\n            }\n            else {\n              navigateToElement(element, editor, file);\n            }\n          }\n        }\n      };\n\n      final PopupChooserBuilder builder = new PopupChooserBuilder(list);\n      renderer.installSpeedSearch(builder);\n      builder.\n          setTitle(title).\n          setItemChoosenCallback(runnable).\n          setMovable(true).\n          createPopup().showInBestPositionFor(editor);\n    }\n  }","id":31071,"modified_method":"private void show(Project project,\n                    Editor editor,\n                    PsiFile file,\n                    final PsiElement sourceElement,\n                    final PsiElement[] targets,\n                    final List<AdditionalAction> additionalActions) {\n    if (targets.length == 0 && additionalActions.isEmpty()) {\n      HintManager.getInstance().showErrorHint(editor, getNotFoundMessage(project, editor, file));\n      return;\n    }\n\n    if (targets.length == 1 && additionalActions.isEmpty()) {\n      Navigatable descriptor = targets[0] instanceof Navigatable ? (Navigatable)targets[0] : EditSourceUtil.getDescriptor(targets[0]);\n      if (descriptor != null && descriptor.canNavigate()) {\n        navigateToElement(descriptor);\n      }\n      return;\n    }\n\n    final Map<Object, PsiElementListCellRenderer> targetsWithRenderers = new THashMap<Object, PsiElementListCellRenderer>(targets.length);\n\n    GotoTargetRendererProvider[] providers = Extensions.getExtensions(GotoTargetRendererProvider.EP_NAME);\n\n    for (PsiElement eachTarget : targets) {\n      PsiElementListCellRenderer renderer = null;\n      for (GotoTargetRendererProvider eachProvider : providers) {\n        renderer = eachProvider.getRenderer(eachTarget);\n        if (renderer != null) break;\n      }\n      if (renderer == null) {\n        renderer = myDefaultTargetElementRenderer;\n      }\n      targetsWithRenderers.put(eachTarget, renderer);\n    }\n\n\n    String name = ((PsiNamedElement)sourceElement).getName();\n    String title = getChooserTitle(sourceElement, name, targets.length);\n\n    if (shouldSortTargets()) {\n      Arrays.sort(targets, new Comparator<PsiElement>() {\n        @Override\n        public int compare(PsiElement o1, PsiElement o2) {\n          return getComparingObject(o1).compareTo(getComparingObject(o2));\n        }\n\n        private Comparable getComparingObject(PsiElement o1) {\n          return targetsWithRenderers.get(o1).getComparingObject(o1);\n        }\n      });\n    }\n\n    List<Object> allElements = new ArrayList<Object>(targets.length + additionalActions.size());\n    Collections.addAll(allElements, targets);\n    allElements.addAll(additionalActions);\n\n    final JList list = new JBList(allElements);\n    list.setCellRenderer(new DefaultListCellRenderer() {\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        if (value == null) return super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        if (value instanceof AdditionalAction) {\n          return myActionElementRenderer.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        }\n        return targetsWithRenderers.get(value).getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n      }\n    });\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        int[] ids = list.getSelectedIndices();\n        if (ids == null || ids.length == 0) return;\n        Object[] selectedElements = list.getSelectedValues();\n        for (Object element : selectedElements) {\n          if (element instanceof AdditionalAction) {\n            ((AdditionalAction)element).execute();\n          }\n          else {\n            Navigatable nav = element instanceof Navigatable ? (Navigatable)element : EditSourceUtil.getDescriptor((PsiElement)element);\n            if (nav != null && nav.canNavigate()) {\n              navigateToElement(nav);\n            }\n          }\n        }\n      }\n    };\n\n    final PopupChooserBuilder builder = new PopupChooserBuilder(list);\n    builder.setFilteringEnabled(new Function<Object, String>() {\n      @Override\n      public String fun(Object o) {\n        if (o instanceof AdditionalAction) {\n          return ((AdditionalAction)o).getText();\n        }\n        return targetsWithRenderers.get(o).getElementText((PsiElement)o);\n      }\n    });\n\n    builder.\n      setTitle(title).\n      setItemChoosenCallback(runnable).\n      setMovable(true).\n      createPopup().showInBestPositionFor(editor);\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract String getChooserTitleKey(PsiElement sourceElement);","id":31072,"modified_method":"protected abstract String getChooserTitle(PsiElement sourceElement, String name, int length);","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(getFeatureUsedKey());\n\n    try {\n      Pair<PsiElement, PsiElement[]> sourceAndTarget = getSourceAndTargetElements(editor, file);\n      if (sourceAndTarget.first != null) {\n        show(project, editor, file, sourceAndTarget.first, sourceAndTarget.second);\n      }\n    }\n    catch (IndexNotReadyException e) {\n      DumbService.getInstance(project).showDumbModeNotification(\"Navigation is not available here during index update\");\n    }\n  }","id":31073,"modified_method":"public void invoke(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(getFeatureUsedKey());\n\n    try {\n      GotoData gotoData = getSourceAndTargetElements(editor, file);\n      if (gotoData.source != null) {\n        show(project, editor, file, gotoData.source, gotoData.targets, gotoData.additionalActions);\n      }\n    }\n    catch (IndexNotReadyException e) {\n      DumbService.getInstance(project).showDumbModeNotification(\"Navigation is not available here during index update\");\n    }\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void handleNoVariansCase(Project project, Editor editor, PsiFile file) {\n  }","id":31074,"modified_method":"protected abstract String getNotFoundMessage(Project project, Editor editor, PsiFile file);","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void handleNoVariansCase(Project project, Editor editor, PsiFile file) {\n    PsiElement selectedElement = getSelectedElement(editor, file);\n    if (TestFinderHelper.isTest(selectedElement)) {\n      HintManager.getInstance().showErrorHint(editor, ActionsBundle.message(\"action.GotoTestSubject.nothing.found\"));\n    }\n  }","id":31075,"modified_method":"@Override\n  protected String getNotFoundMessage(Project project, Editor editor, PsiFile file) {\n    return CodeInsightBundle.message(\"goto.test.notFound\");\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getChooserTitleKey(PsiElement sourceElement) {\n    if (TestFinderHelper.isTest(sourceElement)) {\n      return \"goto.test.subject.chooser.title\";\n    }\n    else {\n      return \"goto.test.chooser.title\";\n    }\n  }","id":31076,"modified_method":"protected String getChooserTitle(PsiElement sourceElement, String name, int length) {\n    if (TestFinderHelper.isTest(sourceElement)) {\n      return CodeInsightBundle.message(\"goto.test.chooserTitle.subject\", name, length);\n    }\n    else {\n      return CodeInsightBundle.message(\"goto.test.chooserTitle.test\", name, length);\n    }\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Pair<PsiElement, PsiElement[]> getSourceAndTargetElements(Editor editor, PsiFile file) {\n    PsiElement selectedElement = getSelectedElement(editor, file);\n\n    Collection<PsiElement> candidates;\n    if (TestFinderHelper.isTest(selectedElement)) {\n      candidates = TestFinderHelper.findClassesForTest(selectedElement);\n    }\n    else {\n      candidates = TestFinderHelper.findTestsForClass(selectedElement);\n    }\n\n    PsiElement sourceElement = TestFinderHelper.findSourceElement(selectedElement);\n    return new Pair<PsiElement, PsiElement[]>(sourceElement, candidates.toArray(new PsiElement[candidates.size()]));\n  }","id":31077,"modified_method":"@Nullable\n  protected GotoData getSourceAndTargetElements(final Editor editor, final PsiFile file) {\n    PsiElement selectedElement = getSelectedElement(editor, file);\n    PsiElement sourceElement = TestFinderHelper.findSourceElement(selectedElement);\n    if (sourceElement == null) return null;\n\n    List<AdditionalAction> actions = new SmartList<AdditionalAction>();\n\n    Collection<PsiElement> candidates;\n    if (TestFinderHelper.isTest(selectedElement)) {\n      candidates = TestFinderHelper.findClassesForTest(selectedElement);\n    }\n    else {\n      candidates = TestFinderHelper.findTestsForClass(selectedElement);\n      actions.add(new AdditionalAction() {\n        @Override\n        public String getText() {\n          return \"Create New Test...\";\n        }\n\n        @Override\n        public Icon getIcon() {\n          return IconLoader.getIcon(\"/actions/intentionBulb.png\");\n        }\n\n        @Override\n        public void execute() {\n          final TestCreator creator = LanguageTestCreators.INSTANCE.forLanguage(file.getLanguage());\n          if (creator != null) creator.createTest(file.getProject(), editor, file);\n        }\n      });\n    }\n\n    return new GotoData(sourceElement, candidates.toArray(new PsiElement[candidates.size()]), actions);\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testNoGotoImplementationOutsideSourceRoot() throws Throwable {\n    final TempDirTestFixture dirFixture = new TempDirTestFixtureImpl();\n    dirFixture.setUp();\n\n    new WriteCommandAction(getProject()) {\n      protected void run(Result result) throws Throwable {\n        final VirtualFile outside = dirFixture.getFile(\"\").createChildDirectory(this, \"outside\");\n        PsiTestUtil.addContentRoot(myModule, outside);\n        VirtualFile out = outside.createChildData(this, \"Outside.groovy\");\n        VfsUtil.saveText(out, \"class Bar {}\\n class Goo extends Bar {}\");\n      }\n    }.execute();\n\n    try {\n      PsiFile inProject = myFixture.addFileToProject(\"Foo.groovy\", \"class <caret>Foo {}\\n class Bar extends Foo {}\");\n      myFixture.configureFromExistingVirtualFile(inProject.getVirtualFile());\n\n      final PsiElement[] impls = new GotoImplementationHandler().getSourceAndTargetElements(myFixture.getEditor(), inProject).second;\n      assertEquals(1, impls.length);\n    }\n    finally {\n      dirFixture.tearDown();\n    }\n  }","id":31078,"modified_method":"public void testNoGotoImplementationOutsideSourceRoot() throws Throwable {\n    final TempDirTestFixture dirFixture = new TempDirTestFixtureImpl();\n    dirFixture.setUp();\n\n    new WriteCommandAction(getProject()) {\n      protected void run(Result result) throws Throwable {\n        final VirtualFile outside = dirFixture.getFile(\"\").createChildDirectory(this, \"outside\");\n        PsiTestUtil.addContentRoot(myModule, outside);\n        VirtualFile out = outside.createChildData(this, \"Outside.groovy\");\n        VfsUtil.saveText(out, \"class Bar {}\\n class Goo extends Bar {}\");\n      }\n    }.execute();\n\n    try {\n      PsiFile inProject = myFixture.addFileToProject(\"Foo.groovy\", \"class <caret>Foo {}\\n class Bar extends Foo {}\");\n      myFixture.configureFromExistingVirtualFile(inProject.getVirtualFile());\n\n      final PsiElement[] impls = new GotoImplementationHandler().getSourceAndTargetElements(myFixture.getEditor(), inProject).targets;\n      assertEquals(1, impls.length);\n    }\n    finally {\n      dirFixture.tearDown();\n    }\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElementListCellRenderer getRenderer(final PsiElement[] elements) {\n    boolean onlyMethods = true;\n    boolean onlyClasses = true;\n    for (PsiElement element : elements) {\n      if (!(element instanceof PsiMethod)) onlyMethods = false;\n      if (!(element instanceof PsiClass)) onlyClasses = false;\n    }\n    if (onlyMethods) {\n      return new MethodCellRenderer(!PsiUtil.allMethodsHaveSameSignature(Arrays.asList(elements).toArray(PsiMethod.EMPTY_ARRAY)));\n    }\n    else if (onlyClasses) {\n      return new PsiClassListCellRenderer();\n    }\n    return null;\n  }","id":31079,"modified_method":"public PsiElementListCellRenderer getRenderer(final PsiElement element) {\n    if (element instanceof PsiMethod) {\n      return new MethodCellRenderer(false);\n    }\n    else if (element instanceof PsiClass) {\n      return new PsiClassListCellRenderer();\n    }\n    return null;\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Comparator<T> getComparator() {\n    return new Comparator<T>() {\n      public int compare(T o1, T o2) {\n        return getText(o1).compareTo(getText(o2));\n      }\n\n      private String getText(T element) {\n        String elementText = getElementText(element);\n        String containerText = getContainerText(element, elementText);\n        return containerText != null ? elementText + \" \" + containerText : elementText;\n      }\n    };\n  }","id":31080,"modified_method":"public Comparator<T> getComparator() {\n    return new Comparator<T>() {\n      public int compare(T o1, T o2) {\n        return getComparingObject(o1).compareTo(getComparingObject(o2));\n      }\n    };\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void customizeCellRenderer(\n      JList list,\n      Object value,\n      int index,\n      boolean selected,\n      boolean hasFocus\n      ) {\n      Color bgColor = UIUtil.getListBackground();\n      if (value instanceof PsiElement) {\n        T element = (T)value;\n        String name = getElementText((T)element);\n        Color color = list.getForeground();\n        PsiFile psiFile = element.getContainingFile();\n        boolean isProblemFile = false;\n\n        if (psiFile != null) {\n          VirtualFile vFile = psiFile.getVirtualFile();\n          if (vFile != null) {\n            if (WolfTheProblemSolver.getInstance(psiFile.getProject()).isProblemFile(vFile)) {\n              isProblemFile = true;\n            }\n            FileStatus status = FileStatusManager.getInstance(psiFile.getProject()).getStatus(vFile);\n            color = status.getColor();\n\n            final FileColorManager colorManager = FileColorManager.getInstance(psiFile.getProject());\n            if (colorManager.isEnabled()) {\n              final Color fileBgColor = colorManager.getRendererBackground(psiFile);\n              bgColor = fileBgColor == null ? bgColor : fileBgColor;\n            }\n          }\n        }\n\n        TextAttributes attributes = null;\n\n        if (value instanceof NavigationItem) {\n          TextAttributesKey attributesKey = null;\n          final ItemPresentation presentation = ((NavigationItem)value).getPresentation();\n          if (presentation != null) attributesKey = presentation.getTextAttributesKey();\n\n          if (attributesKey != null) {\n            attributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(attributesKey);\n          }\n        }\n\n        if (isProblemFile) {\n          attributes = TextAttributes.merge(new TextAttributes(color, null, Color.red, EffectType.WAVE_UNDERSCORE, Font.PLAIN),attributes);\n        }\n\n        SimpleTextAttributes nameAttributes = attributes != null ? SimpleTextAttributes.fromTextAttributes(attributes) : null;\n\n        if (nameAttributes == null)  nameAttributes = new SimpleTextAttributes(Font.PLAIN, color);\n\n        assert name != null: \"Null name for PSI element \" + element;\n        append(name, nameAttributes);\n        setIcon(PsiElementListCellRenderer.this.getIcon(element));\n\n        String containerText = getContainerText(element, name + (myModuleName != null ? myModuleName + \"        \" : \"\"));\n        if (containerText != null) {\n          append(\" \" + containerText, new SimpleTextAttributes(Font.PLAIN, Color.GRAY));\n        }\n      }\n      else {\n        setIcon(getNullIcon());\n        append(value == null ? getNullPresentation() : value.toString(), new SimpleTextAttributes(Font.PLAIN, list.getForeground()));\n      }\n      setPaintFocusBorder(false);\n      setBackground(selected ? UIUtil.getListSelectionBackground() : bgColor);\n    }","id":31081,"modified_method":"protected void customizeCellRenderer(\n      JList list,\n      Object value,\n      int index,\n      boolean selected,\n      boolean hasFocus\n      ) {\n      Color bgColor = UIUtil.getListBackground();\n      if (value instanceof PsiElement) {\n        T element = (T)value;\n        String name = getElementText((T)element);\n        Color color = list.getForeground();\n        PsiFile psiFile = element.getContainingFile();\n        boolean isProblemFile = false;\n\n        if (psiFile != null) {\n          VirtualFile vFile = psiFile.getVirtualFile();\n          if (vFile != null) {\n            if (WolfTheProblemSolver.getInstance(psiFile.getProject()).isProblemFile(vFile)) {\n              isProblemFile = true;\n            }\n            FileStatus status = FileStatusManager.getInstance(psiFile.getProject()).getStatus(vFile);\n            color = status.getColor();\n\n            final FileColorManager colorManager = FileColorManager.getInstance(psiFile.getProject());\n            if (colorManager.isEnabled()) {\n              final Color fileBgColor = colorManager.getRendererBackground(psiFile);\n              bgColor = fileBgColor == null ? bgColor : fileBgColor;\n            }\n          }\n        }\n\n        TextAttributes attributes = null;\n\n        if (value instanceof NavigationItem) {\n          TextAttributesKey attributesKey = null;\n          final ItemPresentation presentation = ((NavigationItem)value).getPresentation();\n          if (presentation != null) attributesKey = presentation.getTextAttributesKey();\n\n          if (attributesKey != null) {\n            attributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(attributesKey);\n          }\n        }\n\n        if (isProblemFile) {\n          attributes = TextAttributes.merge(new TextAttributes(color, null, Color.red, EffectType.WAVE_UNDERSCORE, Font.PLAIN),attributes);\n        }\n\n        SimpleTextAttributes nameAttributes = attributes != null ? SimpleTextAttributes.fromTextAttributes(attributes) : null;\n\n        if (nameAttributes == null)  nameAttributes = new SimpleTextAttributes(Font.PLAIN, color);\n\n        assert name != null: \"Null name for PSI element \" + element;\n        append(name, nameAttributes);\n        setIcon(PsiElementListCellRenderer.this.getIcon(element));\n\n        String containerText = getContainerText(element, name + (myModuleName != null ? myModuleName + \"        \" : \"\"));\n        if (containerText != null) {\n          append(\" \" + containerText, new SimpleTextAttributes(Font.PLAIN, Color.GRAY));\n        }\n      }\n      else {\n        setIcon(IconUtil.getEmptyIcon(false));\n        append(value == null ? \"\" : value.toString(), new SimpleTextAttributes(Font.PLAIN, list.getForeground()));\n      }\n      setPaintFocusBorder(false);\n      setBackground(selected ? UIUtil.getListSelectionBackground() : bgColor);\n    }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<PsiElement> findTestsForClass(PsiElement element) {\n    List<PsiElement> result = new ArrayList<PsiElement>();\n    for (TestFinder each : getFinders()) {\n      result.addAll(each.findTestsForClass(element));\n    }\n    /*if (!result.isEmpty())*/ result.add(null);\n    return result;\n  }","id":31082,"modified_method":"public static List<PsiElement> findTestsForClass(PsiElement element) {\n    List<PsiElement> result = new ArrayList<PsiElement>();\n    for (TestFinder each : getFinders()) {\n      result.addAll(each.findTestsForClass(element));\n    }\n    return result;\n  }","commit_id":"ca6bcdb07c4bcd31e32e2737850877aed218e3bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void _testCompletionInManifestTag() throws Throwable {\n    doTestCompletion();\n  }","id":31083,"modified_method":"public void testCompletionInManifestTag() throws Throwable {\n    doTestCompletion();\n  }","commit_id":"56ea7a4598c743dd35e013b9784df0f136e2b4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull \n  public static XmlFileHeader getXmlFileHeader(final PsiFile file) {\n    final VirtualFile virtualFile = file.getVirtualFile();\n    if (virtualFile instanceof LightVirtualFile && file instanceof XmlFile && FileDocumentManager.getInstance().getCachedDocument(virtualFile) == null) {\n      final XmlDocument document = ((XmlFile)file).getDocument();\n      if (document != null) {\n        String publicId = null;\n        String systemId = null;\n        final XmlProlog prolog = document.getProlog();\n        if (prolog != null) {\n          final XmlDoctype doctype = prolog.getDoctype();\n          if (doctype != null) {\n            publicId = doctype.getPublicId();\n            systemId = doctype.getSystemId();\n          }\n        }\n\n        final XmlTag tag = document.getRootTag();\n        if (tag != null) {\n          return new XmlFileHeader(tag.getLocalName(), tag.getNamespace(), publicId, systemId);\n        }\n      }\n      return XmlFileHeader.EMPTY;\n    }\n\n    if (!file.isValid()) return XmlFileHeader.EMPTY;\n    return NanoXmlUtil.parseHeader(file);\n  }","id":31084,"modified_method":"@NotNull\n  public static XmlFileHeader getXmlFileHeader(final PsiFile file) {\n    if (file instanceof XmlFile && file.getNode().isParsed()) {\n      final XmlDocument document = ((XmlFile)file).getDocument();\n      if (document != null) {\n        String publicId = null;\n        String systemId = null;\n        final XmlProlog prolog = document.getProlog();\n        if (prolog != null) {\n          final XmlDoctype doctype = prolog.getDoctype();\n          if (doctype != null) {\n            publicId = doctype.getPublicId();\n            systemId = doctype.getSystemId();\n            if (systemId == null) {\n              systemId = doctype.getDtdUri();\n            }\n          }\n        }\n\n        final XmlTag tag = document.getRootTag();\n        if (tag != null) {\n          String localName = tag.getLocalName();\n          if (StringUtil.isNotEmpty(localName)) {\n            if (tag.getPrevSibling() instanceof PsiErrorElement) {\n              return XmlFileHeader.EMPTY;\n            }\n\n            String psiNs = tag.getNamespace();\n            return new XmlFileHeader(localName, psiNs == XmlUtil.EMPTY_URI || Comparing.equal(psiNs, systemId) ? null : psiNs, publicId,\n                                     systemId);\n          }\n        }\n      }\n      return XmlFileHeader.EMPTY;\n    }\n\n    if (!file.isValid()) return XmlFileHeader.EMPTY;\n    return NanoXmlUtil.parseHeader(file);\n  }","commit_id":"56ea7a4598c743dd35e013b9784df0f136e2b4ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isNameSuitable(final EvaluatedXmlName evaluatedXmlName, final XmlTag tag, final DomInvocationHandler handler) {\n    final String localName = evaluatedXmlName.getLocalName();\n    return localName.equals(tag.getLocalName()) && evaluatedXmlName.isNamespaceAllowed(handler, tag.getNamespace());\n  }","id":31085,"modified_method":"public static boolean isNameSuitable(final EvaluatedXmlName evaluatedXmlName, final XmlTag tag, final DomInvocationHandler handler) {\n    return isNameSuitable(evaluatedXmlName, tag.getLocalName(), tag.getName(), tag.getNamespace(), handler);\n  }","commit_id":"6168d2bb7163754d66724d61a11f90a1d9abf5e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final XmlTag createChildTag(final EvaluatedXmlName tagName) {\n    final XmlElement element = getXmlElement();\n    assert element != null;\n    final String namespace = tagName.getNamespace(element);\n    final String localName = tagName.getLocalName();\n    return myXmlTag.createChildTag(localName, namespace, \"\", false);\n  }","id":31086,"modified_method":"protected final XmlTag createChildTag(final EvaluatedXmlName tagName) {\n    final String localName = tagName.getLocalName();\n    if (localName.contains(\":\")) {\n      try {\n        return myXmlTag.getManager().getElementFactory().createTagFromText(\"<\" + localName + \"/>\");\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n\n    final XmlElement element = getXmlElement();\n    assert element != null;\n    return myXmlTag.createChildTag(localName, tagName.getNamespace(element), \"\", false);\n  }","commit_id":"6168d2bb7163754d66724d61a11f90a1d9abf5e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void removeAppendAttributes(Txn transaction, NodeList removeList, NodeList appendList) {\n\t\ttry {\n\t\t\tif (removeList != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (int i=0; i<removeList.getLength(); i++) {\n\t\t\t\t\t\tNode oldChild = removeList.item(i);\n\t\t\t\t\t\tif (!(oldChild instanceof StoredNode))\n\t\t\t\t\t\t\tthrow new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n\t\t\t\t\t\tStoredNode old = (StoredNode) oldChild;\n\t\t\t\t\t\tif (!old.nodeId.isChildOf(nodeId))\n\t\t\t\t\t\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, \"node \" + old.nodeId.getParentId() + \n\t\t\t\t\t\t\t\t\t\" is not a child of element \" + nodeId);\n\t\t\t\t\t\tgetBroker().removeNode(transaction, old, old.getPath(), null);\n\t\t\t\t\t\tchildren--;\n\t\t\t\t\t\tattributes--;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tgetBroker().endRemove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (children == 0) {\n\t\t\t   appendChildren(transaction, nodeId.newChild(), \n\t\t\t\t\t   new NodeImplRef(this), getPath(), appendList, true);\n\t\t\t} else {\n\t\t        if (attributes == 0) {\n\t\t        \tStoredNode firstChild = (StoredNode) getFirstChild();\n\t\t        \tNodeId newNodeId = firstChild.nodeId.insertBefore();\n                    appendChildren(transaction, newNodeId, new NodeImplRef(this), getPath(), appendList, true);                    \n\t\t        } else {\n\t\t        \tAttribVisitor visitor = new AttribVisitor();\n\t\t\t        accept(visitor);\n\t\t\t        NodeId firstChildId = visitor.firstChild == null ? null : visitor.firstChild.nodeId;\n\t\t\t        NodeId newNodeId = visitor.lastAttrib.nodeId.insertNode(firstChildId);\n                    appendChildren(transaction, newNodeId, new NodeImplRef(visitor.lastAttrib), \n                    \t\tgetPath(), appendList, true);\n\t\t        }\n                setDirty(true);\n            }\n\t\t\tattributes += appendList.getLength();\n\t\t} finally {\n            getBroker().updateNode(transaction, this, true);\n            getBroker().flush();\n\t\t}\n\t}","id":31087,"modified_method":"public void removeAppendAttributes(Txn transaction, NodeList removeList, NodeList appendList) {\n\t\ttry {\n\t\t\tif (removeList != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (int i=0; i<removeList.getLength(); i++) {\n\t\t\t\t\t\tNode oldChild = removeList.item(i);\n\t\t\t\t\t\tif (!(oldChild instanceof StoredNode))\n\t\t\t\t\t\t\tthrow new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n\t\t\t\t\t\tStoredNode old = (StoredNode) oldChild;\n\t\t\t\t\t\tif (!old.nodeId.isChildOf(nodeId))\n\t\t\t\t\t\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, \"node \" + old.nodeId.getParentId() + \n\t\t\t\t\t\t\t\t\t\" is not a child of element \" + nodeId);\n                        getBroker().getIndexDispatcher().removeNode(transaction, old);\n                        getBroker().removeNode(transaction, old, old.getPath(), null);\n\t\t\t\t\t\tchildren--;\n\t\t\t\t\t\tattributes--;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tgetBroker().endRemove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (children == 0) {\n\t\t\t   appendChildren(transaction, nodeId.newChild(), \n\t\t\t\t\t   new NodeImplRef(this), getPath(), appendList, true);\n\t\t\t} else {\n\t\t        if (attributes == 0) {\n\t\t        \tStoredNode firstChild = (StoredNode) getFirstChild();\n\t\t        \tNodeId newNodeId = firstChild.nodeId.insertBefore();\n                    appendChildren(transaction, newNodeId, new NodeImplRef(this), getPath(), appendList, true);                    \n\t\t        } else {\n\t\t        \tAttribVisitor visitor = new AttribVisitor();\n\t\t\t        accept(visitor);\n\t\t\t        NodeId firstChildId = visitor.firstChild == null ? null : visitor.firstChild.nodeId;\n\t\t\t        NodeId newNodeId = visitor.lastAttrib.nodeId.insertNode(firstChildId);\n                    appendChildren(transaction, newNodeId, new NodeImplRef(visitor.lastAttrib), \n                    \t\tgetPath(), appendList, true);\n\t\t        }\n                setDirty(true);\n            }\n\t\t\tattributes += appendList.getLength();\n\t\t} finally {\n            getBroker().updateNode(transaction, this, true);\n            getBroker().flush();\n\t\t}\n\t}","commit_id":"62a8ed15401154c7cb2e3e59b97bd05fd5c271d8","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Returns a list of all attribute nodes in attrs that are already present\n     * in the current element.\n     *\n     * @param attrs\n     * @return The attributes list\n     * @throws DOMException\n     */\n    private NodeList findDupAttributes(NodeList attrs) throws DOMException {\n    \tNodeListImpl dupList = null;\n    \tNamedNodeMap map = getAttributes();\n    \tfor (int i = 0; i < attrs.getLength(); i++) {\n    \t\tNode attr = attrs.item(i);\n    \t\tNode duplicate = map.getNamedItemNS(attr.getNamespaceURI(), attr.getLocalName());\n    \t\tif (duplicate != null) {\n    \t\t\tif (dupList == null)\n            \t\tdupList = new NodeListImpl();\n            \tdupList.add(duplicate);\n    \t\t}\n    \t}\n        return dupList;\n    }","id":31088,"modified_method":"/**\n     * Returns a list of all attribute nodes in attrs that are already present\n     * in the current element.\n     *\n     * @param attrs\n     * @return The attributes list\n     * @throws DOMException\n     */\n    private NodeList findDupAttributes(NodeList attrs) throws DOMException {\n    \tNodeListImpl dupList = null;\n    \tNamedNodeMap map = getAttributes();\n    \tfor (int i = 0; i < attrs.getLength(); i++) {\n    \t\tNode attr = attrs.item(i);\n            // Workaround: xerces sometimes returns null for getLocalName() !!!!\n            String localName = attr.getLocalName();\n            if (localName == null)\n                localName = attr.getNodeName();\n            Node duplicate = map.getNamedItemNS(attr.getNamespaceURI(), localName);\n    \t\tif (duplicate != null) {\n    \t\t\tif (dupList == null)\n            \t\tdupList = new NodeListImpl();\n            \tdupList.add(duplicate);\n    \t\t}\n    \t}\n        return dupList;\n    }","commit_id":"62a8ed15401154c7cb2e3e59b97bd05fd5c271d8","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void readElements(Iterator elements) {\n        Element element;\n        while (elements.hasNext()) {\n                element = (Element)elements.next();\n                if (MuleProperties.MULE_CORRELATION_ID_PROPERTY.equals(element.getLocalName())) {\n                    correlationId = getStringValue(element);\n                } else if (MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY.equals(element.getLocalName())) {\n                    correlationGroup = getStringValue(element);\n                } else if (MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY.equals(element.getLocalName())) {\n                    correlationSequence = getStringValue(element);\n                } else if (MuleProperties.MULE_REPLY_TO_PROPERTY.equals(element.getLocalName())) {\n                    replyTo = getStringValue(element);\n                }\n            }\n    }","id":31089,"modified_method":"protected void readElements(Iterator elements) {\n\n        SOAPElement element;\n        \n        while (elements.hasNext()) {\n        \t\n    \t\tObject elementObject = elements.next();\n\n            //Fixed MULE-770 (http://jira.symphonysoft.com/browse/MULE-770)\n    \t\tif (elementObject instanceof SOAPElement) \n    \t\t// if not, means that it is a value not an element, therefore we cannot look for correlation_id ...\n    \t\t{\n                element = (SOAPElement)elementObject;\n                String localName = element.getLocalName();\n                String elementValue = getStringValue(element);\n                \n                if (MuleProperties.MULE_CORRELATION_ID_PROPERTY.equals(localName)) {\n                    correlationId = elementValue;\n                } else if (MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY.equals(localName)) {\n                    correlationGroup = elementValue;\n                } else if (MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY.equals(localName)) {\n                    correlationSequence = elementValue;\n                } else if (MuleProperties.MULE_REPLY_TO_PROPERTY.equals(localName)) {\n                    replyTo = elementValue;\n                }\n                \n    \t\t}\n        }\n    }","commit_id":"4c7b7543a4d9649078d1dc95bc99164aad757ea0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Extracts Mule header properties from a Soap message\n     *\n     * @param soapHeader\n     */\n    public MuleSoapHeaders(SOAPHeader soapHeader)\n    {\n        Iterator iter = soapHeader.examineHeaderElements(MULE_10_ACTOR);\n        SOAPHeaderElement header;\n        while (iter.hasNext()) {\n            header = (SOAPHeaderElement) iter.next();\n            Iterator iter2 = header.getChildElements();\n            readElements(iter2);\n        }\n    }","id":31090,"modified_method":"/**\n     * Extracts Mule header properties from a Soap message\n     *\n     * @param soapHeader\n     */\n    public MuleSoapHeaders(SOAPHeader soapHeader)\n    {\n        Iterator iter = soapHeader.examineHeaderElements(MULE_10_ACTOR);\n        SOAPHeaderElement headerElement;\n        while (iter.hasNext()) {\n            headerElement = (SOAPHeaderElement) iter.next();\n            \n            //checking that the elements are part of the mule namespace\n            if (org.mule.util.StringUtils.equals(MULE_10_ACTOR, headerElement.getNamespaceURI()))\n            {\n                Iterator iter2 = headerElement.getChildElements();\n                readElements(iter2);\n            }\n        }\n    }","commit_id":"4c7b7543a4d9649078d1dc95bc99164aad757ea0","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void startNode(Node node) throws SAXException {\n        String cdata;\n        switch (node.getNodeType()) {\n        case Node.DOCUMENT_NODE :\n        case Node.DOCUMENT_FRAGMENT_NODE :\n            break;\n        case Node.ELEMENT_NODE :\n            namespaceDecls.clear();\n            nsSupport.pushContext();\n            String uri = node.getNamespaceURI();\n            String prefix = node.getPrefix();\n            if (uri == null)\n                {uri = XMLConstants.XML_NS_URI;}\n            if (prefix == null)\n                {prefix = XMLConstants.DEFAULT_NS_PREFIX;}\n            if (nsSupport.getURI(prefix) == null) {\n                namespaceDecls.put(prefix, uri);\n                nsSupport.declarePrefix(prefix, uri);\n            }\n            // check attributes for required namespace declarations\n            final NamedNodeMap attrs = node.getAttributes();\n            Attr nextAttr;\n            String attrName;\n            for (int i = 0; i < attrs.getLength(); i++) {\n                nextAttr = (Attr) attrs.item(i);\n                attrName = nextAttr.getName();\n                if (XMLConstants.XMLNS_ATTRIBUTE.equals(attrName)) {\n                    if (nsSupport.getURI(XMLConstants.NULL_NS_URI) == null) {\n                        uri = nextAttr.getValue();\n                        namespaceDecls.put(XMLConstants.DEFAULT_NS_PREFIX, uri);\n                        nsSupport.declarePrefix(XMLConstants.DEFAULT_NS_PREFIX, uri);\n                    }\n                } else if (attrName.startsWith(XMLConstants.XMLNS_ATTRIBUTE + \":\")) {\n                    prefix = attrName.substring(6);\n                    if (nsSupport.getURI(prefix) == null) {\n                        uri = nextAttr.getValue();\n                        namespaceDecls.put(prefix, uri);\n                        nsSupport.declarePrefix(prefix, uri);\n                    }\n                } else if (attrName.indexOf(':') > 0) {\n                    prefix = nextAttr.getPrefix();\n                    uri = nextAttr.getNamespaceURI();\n                    if (nsSupport.getURI(prefix) == null) {\n                        namespaceDecls.put(prefix, uri);\n                        nsSupport.declarePrefix(prefix, uri);\n                    }\n                }\n            }\n            final ElementInfo info = new ElementInfo(node);\n            String[] declaredPrefixes = null;\n            if(namespaceDecls.size() > 0)\n                {declaredPrefixes = new String[namespaceDecls.size()];}\n            // output all namespace declarations\n            Map.Entry<String, String> nsEntry;\n            int j = 0;\n            for (final Iterator<Map.Entry<String, String>> i = namespaceDecls.entrySet().iterator(); i.hasNext(); j++) {\n                nsEntry = i.next();\n                declaredPrefixes[j] = nsEntry.getKey();\n                contentHandler.startPrefixMapping(declaredPrefixes[j], nsEntry.getValue());\n            }\n            info.prefixes = declaredPrefixes;\n            stack.push(info);\n            // output attributes\n            final AttributesImpl saxAttrs = new AttributesImpl();\n            String attrNS, attrLocalName;\n            for (int i = 0; i < attrs.getLength(); i++) {\n                nextAttr = (Attr) attrs.item(i);\n                attrNS = nextAttr.getNamespaceURI();\n                if(attrNS == null)\n                    {attrNS = XMLConstants.NULL_NS_URI;}\n                attrLocalName = nextAttr.getLocalName();\n                if(attrLocalName == null)\n                    {attrLocalName = QName.extractLocalName(nextAttr.getNodeName());}\n                saxAttrs.addAttribute(\n                    attrNS,\n                    attrLocalName,\n                    nextAttr.getNodeName(),\n                    \"CDATA\",\n                    nextAttr.getValue()\n                );\n            }\n            String localName = node.getLocalName();\n            if(localName == null) {\n                localName = QName.extractLocalName(node.getNodeName());\n            }\n            contentHandler.startElement(node.getNamespaceURI(), localName,\n                node.getNodeName(), saxAttrs);\n            break;\n        case Node.TEXT_NODE :\n            cdata = ((CharacterData) node).getData();\n            contentHandler.characters(cdata.toCharArray(), 0, cdata.length());\n            break;\n        case Node.CDATA_SECTION_NODE :\n            cdata = ((CharacterData) node).getData();\n            if(lexicalHandler != null)\n                {lexicalHandler.startCDATA();}\n            contentHandler.characters(cdata.toCharArray(), 0, cdata.length());\n            if(lexicalHandler != null)\n                {lexicalHandler.endCDATA();}\n            break;\n        case Node.ATTRIBUTE_NODE :\n            break;\n        case Node.PROCESSING_INSTRUCTION_NODE :\n            contentHandler.processingInstruction(\n                ((ProcessingInstruction) node).getTarget(),\n                ((ProcessingInstruction) node).getData());\n            break;\n        case Node.COMMENT_NODE :\n            if(lexicalHandler != null) {\n                cdata = ((Comment) node).getData();\n                lexicalHandler.comment(cdata.toCharArray(), 0, cdata.length());\n            }\n            break;\n        default :\n            //TODO : what kind of default here ? -pb\n            System.out.println(\"Found node: \" + node.getNodeType());\n            break;\n        }\n    }","id":31091,"modified_method":"protected void startNode(Node node) throws SAXException {\n        String cdata;\n        switch (node.getNodeType()) {\n        case Node.DOCUMENT_NODE :\n        case Node.DOCUMENT_FRAGMENT_NODE :\n            break;\n        case Node.ELEMENT_NODE :\n            namespaceDecls.clear();\n            nsSupport.pushContext();\n            String uri = node.getNamespaceURI();\n            String prefix = node.getPrefix();\n            if (uri == null)\n                {uri = XMLConstants.XML_NS_URI;}\n            if (prefix == null)\n                {prefix = XMLConstants.DEFAULT_NS_PREFIX;}\n            if (nsSupport.getURI(prefix) == null) {\n                namespaceDecls.put(prefix, uri);\n                nsSupport.declarePrefix(prefix, uri);\n            }\n            // check attributes for required namespace declarations\n            final NamedNodeMap attrs = node.getAttributes();\n            Attr nextAttr;\n            String attrName;\n            for (int i = 0; i < attrs.getLength(); i++) {\n                nextAttr = (Attr) attrs.item(i);\n                attrName = nextAttr.getName();\n                if (XMLConstants.XMLNS_ATTRIBUTE.equals(attrName)) {\n                    if (nsSupport.getURI(XMLConstants.NULL_NS_URI) == null) {\n                        uri = nextAttr.getValue();\n                        namespaceDecls.put(XMLConstants.DEFAULT_NS_PREFIX, uri);\n                        nsSupport.declarePrefix(XMLConstants.DEFAULT_NS_PREFIX, uri);\n                    }\n                } else if (attrName.startsWith(XMLConstants.XMLNS_ATTRIBUTE + \":\")) {\n                    prefix = attrName.substring(6);\n                    if (nsSupport.getURI(prefix) == null) {\n                        uri = nextAttr.getValue();\n                        namespaceDecls.put(prefix, uri);\n                        nsSupport.declarePrefix(prefix, uri);\n                    }\n                } else if (attrName.indexOf(':') > 0) {\n                    prefix = nextAttr.getPrefix();\n                    uri = nextAttr.getNamespaceURI();\n                    if (nsSupport.getURI(prefix) == null) {\n                        namespaceDecls.put(prefix, uri);\n                        nsSupport.declarePrefix(prefix, uri);\n                    }\n                }\n            }\n            final ElementInfo info = new ElementInfo(node);\n            String[] declaredPrefixes = null;\n            if(namespaceDecls.size() > 0)\n                {declaredPrefixes = new String[namespaceDecls.size()];}\n            // output all namespace declarations\n            Map.Entry<String, String> nsEntry;\n            int j = 0;\n            for (final Iterator<Map.Entry<String, String>> i = namespaceDecls.entrySet().iterator(); i.hasNext(); j++) {\n                nsEntry = i.next();\n                declaredPrefixes[j] = nsEntry.getKey();\n                contentHandler.startPrefixMapping(declaredPrefixes[j], nsEntry.getValue());\n            }\n            info.prefixes = declaredPrefixes;\n            stack.push(info);\n            // output attributes\n            final AttributesImpl saxAttrs = new AttributesImpl();\n            String attrNS, attrLocalName;\n            for (int i = 0; i < attrs.getLength(); i++) {\n                nextAttr = (Attr) attrs.item(i);\n                attrNS = nextAttr.getNamespaceURI();\n                if(attrNS == null)\n                    {attrNS = XMLConstants.NULL_NS_URI;}\n                attrLocalName = nextAttr.getLocalName();\n                if(attrLocalName == null)\n                    {attrLocalName = QName.extractLocalName(nextAttr.getNodeName());}\n                saxAttrs.addAttribute(\n                    attrNS,\n                    attrLocalName,\n                    nextAttr.getNodeName(),\n                    \"CDATA\",\n                    nextAttr.getValue()\n                );\n            }\n            String localName = node.getLocalName();\n            if(localName == null) {\n                localName = QName.extractLocalName(node.getNodeName());\n            }\n            String namespaceURI = node.getNamespaceURI();\n            if(namespaceURI == null) {\n                namespaceURI = XMLConstants.NULL_NS_URI;\n            }\n            contentHandler.startElement(namespaceURI, localName,\n                node.getNodeName(), saxAttrs);\n            break;\n        case Node.TEXT_NODE :\n            cdata = ((CharacterData) node).getData();\n            contentHandler.characters(cdata.toCharArray(), 0, cdata.length());\n            break;\n        case Node.CDATA_SECTION_NODE :\n            cdata = ((CharacterData) node).getData();\n            if(lexicalHandler != null)\n                {lexicalHandler.startCDATA();}\n            contentHandler.characters(cdata.toCharArray(), 0, cdata.length());\n            if(lexicalHandler != null)\n                {lexicalHandler.endCDATA();}\n            break;\n        case Node.ATTRIBUTE_NODE :\n            break;\n        case Node.PROCESSING_INSTRUCTION_NODE :\n            contentHandler.processingInstruction(\n                ((ProcessingInstruction) node).getTarget(),\n                ((ProcessingInstruction) node).getData());\n            break;\n        case Node.COMMENT_NODE :\n            if(lexicalHandler != null) {\n                cdata = ((Comment) node).getData();\n                lexicalHandler.comment(cdata.toCharArray(), 0, cdata.length());\n            }\n            break;\n        default :\n            //TODO : what kind of default here ? -pb\n            System.out.println(\"Found node: \" + node.getNodeType());\n            break;\n        }\n    }","commit_id":"8b8fa47743ababdd1c5e0efdc21b60024eab27d3","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void endNode(Node node) throws SAXException {\n        if (node == null)\n            {return;}\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            final ElementInfo info = stack.pop();\n            nsSupport.popContext();\n            contentHandler.endElement(node.getNamespaceURI(), node.getLocalName(), node.getNodeName());\n            if(info.prefixes != null) {\n                for(int i = 0; i < info.prefixes.length; i++) {\n                    contentHandler.endPrefixMapping(info.prefixes[i]);\n                }\n            }\n        }\n    }","id":31092,"modified_method":"protected void endNode(Node node) throws SAXException {\n        if (node == null)\n            {return;}\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            final ElementInfo info = stack.pop();\n            nsSupport.popContext();\n            String localName = node.getLocalName();\n            if(localName == null) {\n                localName = QName.extractLocalName(node.getNodeName());\n            }\n            String namespaceURI = node.getNamespaceURI();\n            if(namespaceURI == null) {\n                namespaceURI = XMLConstants.NULL_NS_URI;\n            }\n            contentHandler.endElement(namespaceURI, localName, node.getNodeName());\n            if(info.prefixes != null) {\n                for(int i = 0; i < info.prefixes.length; i++) {\n                    contentHandler.endPrefixMapping(info.prefixes[i]);\n                }\n            }\n        }\n    }","commit_id":"8b8fa47743ababdd1c5e0efdc21b60024eab27d3","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t */\n\tpublic void startElement(\n\t\tString namespaceURI,\n\t\tString localName,\n\t\tString qName,\n\t\tAttributes atts)\n\t\tthrows SAXException {\n\t\t// save accumulated character content\n\t\tif (inModification && charBuf.length() > 0) {\n//            String normalized = charBuf.toString();\n\t\t\tfinal String normalized = preserveWhitespace ? charBuf.toString() :\n\t\t\t\tcharBuf.getNormalizedString(FastStringBuffer.SUPPRESS_BOTH);\n\n\t\t\tif (normalized.length() > 0) {\n\t\t\t\tText text = doc.createTextNode(charBuf.toString());\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\t//LOG.debug(\"appending text to fragment: \" + text.getData());\n\t\t\t\t\tcontents.add(text);\n\t\t\t\t} else {\n\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\tlast.appendChild(text);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharBuf.setLength(0);\n\t\t}\n\t\tif (namespaceURI.equals(XUPDATE_NS)) {\n\t\t\tString select = null;\n\t\t\tif (localName.equals(MODIFICATIONS)) {\n\t\t\t\tstartModifications(atts);\n\t\t\t\treturn;\n\t\t\t} else if (localName.equals(VARIABLE)) {\n\t\t\t\t// variable declaration\n\t\t\t\tstartVariableDecl(atts);\n\t\t\t\treturn;\n\t\t\t} else if (IF.equals(localName)) {\n\t\t\t\tif (inModification)\n\t\t\t\t\tthrow new SAXException(\"xupdate:if is not allowed inside a modification\");\n\t\t\t\tselect = atts.getValue(\"test\");\n\t\t\t\tConditional cond = new Conditional(broker, documentSet, select, namespaces, variables);\n\t\t\t\tconditionals.push(cond);\n\t\t\t\treturn;\n\t\t\t} else if (VALUE_OF.equals(localName)) {\n\t\t\t\tif(!inModification)\n\t\t\t\t\tthrow new SAXException(\"xupdate:value-of is not allowed outside a modification\");\n\t\t\t\t\n\t\t\t} else if (APPEND.equals(localName)\n\t\t\t\t|| INSERT_BEFORE.equals(localName)\n\t\t\t\t|| INSERT_AFTER.equals(localName)\n\t\t\t\t|| REMOVE.equals(localName)\n\t\t\t\t|| RENAME.equals(localName)\n\t\t\t\t|| UPDATE.equals(localName)\n\t\t\t\t|| REPLACE.equals(localName)) {\n\t\t\t\tif (inModification)\n\t\t\t\t\tthrow new SAXException(\"nested modifications are not allowed\");\n\t\t\t\tselect = atts.getValue(\"select\");\n\t\t\t\tif (select == null)\n\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\tlocalName + \" requires a select attribute\");\n\t\t\t\tdoc = builder.newDocument();\n\t\t\t\tcontents = new NodeListImpl();\n\t\t\t\tinModification = true;\n\t\t\t} else if (\n\t\t\t\t(ELEMENT.equals(localName)\n\t\t\t\t\t|| ATTRIBUTE.equals(localName)\n\t\t\t\t\t|| TEXT.equals(localName)\n\t\t\t\t\t|| PROCESSING_INSTRUCTION.equals(localName)\n\t\t\t\t\t|| COMMENT.equals(localName))) {\n\t\t\t\tif(!inModification)\n\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"creation elements are only allowed inside \"\n\t\t\t\t\t\t\t+ \"a modification\");\n\t\t\t\tcharBuf.setLength(0);\n\t\t\t} else\n\t\t\t\tthrow new SAXException(\"Unknown XUpdate element: \" + qName);\n\n\t\t\t// start a new modification section\n\t\t\tif (APPEND.equals(localName)) {\n\t\t\t    String child = atts.getValue(\"child\");\n\t\t\t\tmodification = new Append(broker, documentSet, select, child, namespaces, variables);\n\t\t\t} else if (UPDATE.equals(localName))\n\t\t\t\tmodification = new Update(broker, documentSet, select, namespaces, variables);\n\t\t\telse if (INSERT_BEFORE.equals(localName))\n\t\t\t\tmodification =\n\t\t\t\t\tnew Insert(broker, documentSet, select, Insert.INSERT_BEFORE, namespaces, variables);\n\t\t\telse if (INSERT_AFTER.equals(localName))\n\t\t\t\tmodification =\n\t\t\t\t\tnew Insert(broker, documentSet, select, Insert.INSERT_AFTER, namespaces, variables);\n\t\t\telse if (REMOVE.equals(localName))\n\t\t\t\tmodification = new Remove(broker, documentSet, select, namespaces, variables);\n\t\t\telse if (RENAME.equals(localName))\n\t\t\t\tmodification = new Rename(broker, documentSet, select, namespaces, variables);\n\t\t\telse if (REPLACE.equals(localName))\n\t\t\t\tmodification = new Replace(broker, documentSet, select, namespaces, variables);\n\n\t\t\t// process commands for node creation\n\t\t\telse if (ELEMENT.equals(localName)) {\n\t\t\t\tString name = atts.getValue(\"name\");\n\t\t\t\tif (name == null)\n\t\t\t\t\tthrow new SAXException(\"element requires a name attribute\");\n\t\t\t\tint p = name.indexOf(':');\n\t\t\t\tString namespace = null;\n\t\t\t\tString prefix = \"\";\n\t\t\t\tif (p > -1) {\n\t\t\t\t\tprefix = name.substring(0, p);\n\t\t\t\t\tif (name.length() == p + 1)\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"illegal prefix in qname: \" + name);\n\t\t\t\t\tname = name.substring(p + 1);\n\t\t\t\t\tnamespace = atts.getValue(\"namespace\");\n\t\t\t\t\tif(namespace == null)\n\t\t\t\t\t\tnamespace = (String) namespaces.get(prefix);\n\t\t\t\t\tif (namespace == null) {\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"no namespace defined for prefix \" + prefix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tElement elem;\n\t\t\t\tif (namespace != null && namespace.length() > 0)\n\t\t\t\t{\n\t\t\t\t\telem = doc.createElementNS(namespace, name);\n\t\t\t\telem.setPrefix(prefix);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\telem = doc.createElement(name);\n\t\t\t\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tcontents.add(elem);\n\t\t\t\t} else {\n\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\tlast.appendChild(elem);\n\t\t\t\t}\n\t\t\t\tthis.setWhitespaceHandling((Element) stack.push(elem));\n\t\t\t} else if (ATTRIBUTE.equals(localName)) {\n\t\t\t\tString name = atts.getValue(\"name\");\n\t\t\t\tif (name == null)\n\t\t\t\t\tthrow new SAXException(\"attribute requires a name attribute\");\n\t\t\t\tint p = name.indexOf(':');\n\t\t\t\tString namespace = null;\n\t\t\t\tif (p > -1) {\n\t\t\t\t\tString prefix = name.substring(0, p);\n\t\t\t\t\tif (name.length() == p + 1)\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"illegal prefix in qname: \" + name);\n\t\t\t\t\tnamespace = atts.getValue(\"namespace\");\n\t\t\t\t\tif(namespace == null)\n\t\t\t\t\t\tnamespace = (String) namespaces.get(prefix);\n\t\t\t\t\tif (namespace == null)\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"no namespace defined for prefix \" + prefix);\n\t\t\t\t}\n\t\t\t\tAttr attrib = namespace != null && namespace.length() > 0 ?\n\t\t\t\t\t\t\t\tdoc.createAttributeNS(namespace, name) :\n\t\t\t\t\t\t\t\tdoc.createAttribute(name);\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tfor(int i = 0; i < contents.getLength(); i++) {\n\t\t\t\t\t\tNode n = contents.item(i);\n\t\t\t\t\t\tString ns = n.getNamespaceURI();\n\t\t\t\t\t\tif(ns == null) ns = \"\";\n\t\t\t\t\t\tif(n.getNodeType() == Node.ATTRIBUTE_NODE &&\n\t\t\t\t\t\t\t\tn.getLocalName().equals(name) &&\n\t\t\t\t\t\t\t\tns.equals(namespace))\n\t\t\t\t\t\t\tthrow new SAXException(\"The attribute \" + attrib.getNodeName() + \" cannot be specified twice\");\n\t\t\t\t\t}\n\t\t\t\t\tcontents.add(attrib);\n\t\t\t\t} else {\n\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\tif(namespace != null && last.hasAttributeNS(namespace, name) ||\n\t\t\t\t\t   namespace == null && last.hasAttribute(name))\n\t\t\t\t\t\tthrow new SAXException(\"The attribute \" + attrib.getNodeName() + \" cannot be specified \" +\n\t\t\t\t\t\t\t\t\"twice on the same element\");\n\t\t\t\t\tif (namespace != null)\n\t\t\t\t\tlast.setAttributeNodeNS(attrib);\n\t\t\t\t\telse\n\t\t\t\t\t  last.setAttributeNode(attrib);\n\t\t\t\t}\n\t\t\t\tinAttribute = true;\n\t\t\t\tcurrentNode = attrib;\n\n\t\t\t\t// process value-of\n\t\t\t} else if (VALUE_OF.equals(localName)) {\n\t\t\t\tselect = atts.getValue(\"select\");\n\t\t\t\tif (select == null)\n\t\t\t\t\tthrow new SAXException(\"value-of requires a select attribute\");\n\t\t\t\tSequence seq = processQuery(select);\n\t\t\t\tLOG.debug(\"Found \" + seq.getLength() + \" items for value-of\");\n\t\t\t\tItem item;\n\t\t\t\tfor (SequenceIterator i = seq.iterate(); i.hasNext();) {\n\t\t\t\t\titem = i.nextItem();\n\t\t\t\t\tif(Type.subTypeOf(item.getType(), Type.NODE)) { \n\t\t\t\t\t\tNode node = XMLUtil.copyNode(doc, ((NodeValue)item).getNode());\n\t\t\t\t\t\tif (stack.isEmpty())\n\t\t\t\t\t\t\tcontents.add(node);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\t\t\tlast.appendChild(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString value = item.getStringValue();\n\t\t\t\t\t\t\tcharacters(value.toCharArray(), 0, value.length());\n\t\t\t\t\t\t} catch(XPathException e) {\n\t\t\t\t\t\t\tthrow new SAXException(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (inModification) {\n\t\t\tElement elem = namespaceURI != null && namespaceURI.length() > 0 ?\n\t\t\t\t\t\t\t\t\tdoc.createElementNS(namespaceURI, qName) :\n\t\t\t\t\t\t\t\t\tdoc.createElement(qName);\n\t\t\tAttr a;\n\t\t\tfor (int i = 0; i < atts.getLength(); i++) {\n                String name = atts.getQName(i);\n                String nsURI = atts.getURI(i);\n                if (name.startsWith(\"xmlns\")) {\n                    // Why are these showing up? They are supposed to be stripped out?\n                } else {\n                    a = nsURI != null ?\n                          doc.createAttributeNS(nsURI, name) :\n                            doc.createAttribute(name);\n                    a.setValue(atts.getValue(i));\n                    if (nsURI != null)\n                    elem.setAttributeNodeNS(a);\n                    else\n                      elem.setAttributeNode(a);\n                }\n\t\t\t}\n\t\t\tif (stack.isEmpty()) {\n\t\t\t\tcontents.add(elem);\n\t\t\t} else {\n\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\tlast.appendChild(elem);\n\t\t\t}\n            this.setWhitespaceHandling((Element) stack.push(elem));\n\t\t}\n\t}","id":31093,"modified_method":"/**\n\t * @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t */\n\tpublic void startElement(\n\t\tString namespaceURI,\n\t\tString localName,\n\t\tString qName,\n\t\tAttributes atts)\n\t\tthrows SAXException {\n\t\t// save accumulated character content\n\t\tif (inModification && charBuf.length() > 0) {\n//            String normalized = charBuf.toString();\n\t\t\tfinal String normalized = preserveWhitespace ? charBuf.toString() :\n\t\t\t\tcharBuf.getNormalizedString(FastStringBuffer.SUPPRESS_BOTH);\n\n\t\t\tif (normalized.length() > 0) {\n\t\t\t\tText text = doc.createTextNode(charBuf.toString());\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\t//LOG.debug(\"appending text to fragment: \" + text.getData());\n\t\t\t\t\tcontents.add(text);\n\t\t\t\t} else {\n\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\tlast.appendChild(text);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharBuf.setLength(0);\n\t\t}\n\t\tif (namespaceURI.equals(XUPDATE_NS)) {\n\t\t\tString select = null;\n\t\t\tif (localName.equals(MODIFICATIONS)) {\n\t\t\t\tstartModifications(atts);\n\t\t\t\treturn;\n\t\t\t} else if (localName.equals(VARIABLE)) {\n\t\t\t\t// variable declaration\n\t\t\t\tstartVariableDecl(atts);\n\t\t\t\treturn;\n\t\t\t} else if (IF.equals(localName)) {\n\t\t\t\tif (inModification)\n\t\t\t\t\tthrow new SAXException(\"xupdate:if is not allowed inside a modification\");\n\t\t\t\tselect = atts.getValue(\"test\");\n\t\t\t\tConditional cond = new Conditional(broker, documentSet, select, namespaces, variables);\n\t\t\t\tconditionals.push(cond);\n\t\t\t\treturn;\n\t\t\t} else if (VALUE_OF.equals(localName)) {\n\t\t\t\tif(!inModification)\n\t\t\t\t\tthrow new SAXException(\"xupdate:value-of is not allowed outside a modification\");\n\t\t\t\t\n\t\t\t} else if (APPEND.equals(localName)\n\t\t\t\t|| INSERT_BEFORE.equals(localName)\n\t\t\t\t|| INSERT_AFTER.equals(localName)\n\t\t\t\t|| REMOVE.equals(localName)\n\t\t\t\t|| RENAME.equals(localName)\n\t\t\t\t|| UPDATE.equals(localName)\n\t\t\t\t|| REPLACE.equals(localName)) {\n\t\t\t\tif (inModification)\n\t\t\t\t\tthrow new SAXException(\"nested modifications are not allowed\");\n\t\t\t\tselect = atts.getValue(\"select\");\n\t\t\t\tif (select == null)\n\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\tlocalName + \" requires a select attribute\");\n\t\t\t\tdoc = builder.newDocument();\n\t\t\t\tcontents = new NodeListImpl();\n\t\t\t\tinModification = true;\n\t\t\t} else if (\n\t\t\t\t(ELEMENT.equals(localName)\n\t\t\t\t\t|| ATTRIBUTE.equals(localName)\n\t\t\t\t\t|| TEXT.equals(localName)\n\t\t\t\t\t|| PROCESSING_INSTRUCTION.equals(localName)\n\t\t\t\t\t|| COMMENT.equals(localName))) {\n\t\t\t\tif(!inModification)\n\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"creation elements are only allowed inside \"\n\t\t\t\t\t\t\t+ \"a modification\");\n\t\t\t\tcharBuf.setLength(0);\n\t\t\t} else\n\t\t\t\tthrow new SAXException(\"Unknown XUpdate element: \" + qName);\n\n\t\t\t// start a new modification section\n\t\t\tif (APPEND.equals(localName)) {\n\t\t\t    String child = atts.getValue(\"child\");\n\t\t\t\tmodification = new Append(broker, documentSet, select, child, namespaces, variables);\n\t\t\t} else if (UPDATE.equals(localName))\n\t\t\t\tmodification = new Update(broker, documentSet, select, namespaces, variables);\n\t\t\telse if (INSERT_BEFORE.equals(localName))\n\t\t\t\tmodification =\n\t\t\t\t\tnew Insert(broker, documentSet, select, Insert.INSERT_BEFORE, namespaces, variables);\n\t\t\telse if (INSERT_AFTER.equals(localName))\n\t\t\t\tmodification =\n\t\t\t\t\tnew Insert(broker, documentSet, select, Insert.INSERT_AFTER, namespaces, variables);\n\t\t\telse if (REMOVE.equals(localName))\n\t\t\t\tmodification = new Remove(broker, documentSet, select, namespaces, variables);\n\t\t\telse if (RENAME.equals(localName))\n\t\t\t\tmodification = new Rename(broker, documentSet, select, namespaces, variables);\n\t\t\telse if (REPLACE.equals(localName))\n\t\t\t\tmodification = new Replace(broker, documentSet, select, namespaces, variables);\n\n\t\t\t// process commands for node creation\n\t\t\telse if (ELEMENT.equals(localName)) {\n\t\t\t\tString name = atts.getValue(\"name\");\n\t\t\t\tif (name == null)\n\t\t\t\t\tthrow new SAXException(\"element requires a name attribute\");\n\t\t\t\tint p = name.indexOf(':');\n\t\t\t\tString namespace = null;\n\t\t\t\tString prefix = \"\";\n\t\t\t\tif (p > -1) {\n\t\t\t\t\tprefix = name.substring(0, p);\n\t\t\t\t\tif (name.length() == p + 1)\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"illegal prefix in qname: \" + name);\n\t\t\t\t\tname = name.substring(p + 1);\n\t\t\t\t\tnamespace = atts.getValue(\"namespace\");\n\t\t\t\t\tif(namespace == null)\n\t\t\t\t\t\tnamespace = (String) namespaces.get(prefix);\n\t\t\t\t\tif (namespace == null) {\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"no namespace defined for prefix \" + prefix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tElement elem;\n\t\t\t\tif (namespace != null && namespace.length() > 0)\n\t\t\t\t{\n\t\t\t\t\telem = doc.createElementNS(namespace, name);\n\t\t\t\telem.setPrefix(prefix);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\telem = doc.createElement(name);\n\t\t\t\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tcontents.add(elem);\n\t\t\t\t} else {\n\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\tlast.appendChild(elem);\n\t\t\t\t}\n\t\t\t\tthis.setWhitespaceHandling((Element) stack.push(elem));\n\t\t\t} else if (ATTRIBUTE.equals(localName)) {\n\t\t\t\tString name = atts.getValue(\"name\");\n\t\t\t\tif (name == null)\n\t\t\t\t\tthrow new SAXException(\"attribute requires a name attribute\");\n\t\t\t\tint p = name.indexOf(':');\n\t\t\t\tString namespace = null;\n\t\t\t\tif (p > -1) {\n\t\t\t\t\tString prefix = name.substring(0, p);\n\t\t\t\t\tif (name.length() == p + 1)\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"illegal prefix in qname: \" + name);\n\t\t\t\t\tnamespace = atts.getValue(\"namespace\");\n\t\t\t\t\tif(namespace == null)\n\t\t\t\t\t\tnamespace = (String) namespaces.get(prefix);\n\t\t\t\t\tif (namespace == null)\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\"no namespace defined for prefix \" + prefix);\n\t\t\t\t}\n\t\t\t\tAttr attrib = namespace != null && namespace.length() > 0 ?\n\t\t\t\t\t\t\t\tdoc.createAttributeNS(namespace, name) :\n\t\t\t\t\t\t\t\tdoc.createAttribute(name);\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tfor(int i = 0; i < contents.getLength(); i++) {\n\t\t\t\t\t\tNode n = contents.item(i);\n\t\t\t\t\t\tString ns = n.getNamespaceURI();\n\t\t\t\t\t\tString nname = ns == null ? n.getNodeName() : n.getLocalName();\n\t\t\t\t\t\tif(ns == null) ns = \"\";\n\t\t\t\t\t\t// check for duplicate attributes\n\t\t\t\t\t\tif(n.getNodeType() == Node.ATTRIBUTE_NODE &&\n\t\t\t\t\t\t\t\tnname.equals(name) &&\n\t\t\t\t\t\t\t\tns.equals(namespace))\n\t\t\t\t\t\t\tthrow new SAXException(\"The attribute \" + attrib.getNodeName() + \" cannot be specified twice\");\n\t\t\t\t\t}\n\t\t\t\t\tcontents.add(attrib);\n\t\t\t\t} else {\n\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\tif(namespace != null && last.hasAttributeNS(namespace, name) ||\n\t\t\t\t\t   namespace == null && last.hasAttribute(name))\n\t\t\t\t\t\tthrow new SAXException(\"The attribute \" + attrib.getNodeName() + \" cannot be specified \" +\n\t\t\t\t\t\t\t\t\"twice on the same element\");\n\t\t\t\t\tif (namespace != null)\n\t\t\t\t\tlast.setAttributeNodeNS(attrib);\n\t\t\t\t\telse\n\t\t\t\t\t  last.setAttributeNode(attrib);\n\t\t\t\t}\n\t\t\t\tinAttribute = true;\n\t\t\t\tcurrentNode = attrib;\n\n\t\t\t\t// process value-of\n\t\t\t} else if (VALUE_OF.equals(localName)) {\n\t\t\t\tselect = atts.getValue(\"select\");\n\t\t\t\tif (select == null)\n\t\t\t\t\tthrow new SAXException(\"value-of requires a select attribute\");\n\t\t\t\tSequence seq = processQuery(select);\n\t\t\t\tLOG.debug(\"Found \" + seq.getLength() + \" items for value-of\");\n\t\t\t\tItem item;\n\t\t\t\tfor (SequenceIterator i = seq.iterate(); i.hasNext();) {\n\t\t\t\t\titem = i.nextItem();\n\t\t\t\t\tif(Type.subTypeOf(item.getType(), Type.NODE)) { \n\t\t\t\t\t\tNode node = XMLUtil.copyNode(doc, ((NodeValue)item).getNode());\n\t\t\t\t\t\tif (stack.isEmpty())\n\t\t\t\t\t\t\tcontents.add(node);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\t\t\t\tlast.appendChild(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString value = item.getStringValue();\n\t\t\t\t\t\t\tcharacters(value.toCharArray(), 0, value.length());\n\t\t\t\t\t\t} catch(XPathException e) {\n\t\t\t\t\t\t\tthrow new SAXException(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (inModification) {\n\t\t\tElement elem = namespaceURI != null && namespaceURI.length() > 0 ?\n\t\t\t\t\t\t\t\t\tdoc.createElementNS(namespaceURI, qName) :\n\t\t\t\t\t\t\t\t\tdoc.createElement(qName);\n\t\t\tAttr a;\n\t\t\tfor (int i = 0; i < atts.getLength(); i++) {\n                String name = atts.getQName(i);\n                String nsURI = atts.getURI(i);\n                if (name.startsWith(\"xmlns\")) {\n                    // Why are these showing up? They are supposed to be stripped out?\n                } else {\n                    a = nsURI != null ?\n                          doc.createAttributeNS(nsURI, name) :\n                            doc.createAttribute(name);\n                    a.setValue(atts.getValue(i));\n                    if (nsURI != null)\n                    elem.setAttributeNodeNS(a);\n                    else\n                      elem.setAttributeNode(a);\n                }\n\t\t\t}\n\t\t\tif (stack.isEmpty()) {\n\t\t\t\tcontents.add(elem);\n\t\t\t} else {\n\t\t\t\tElement last = (Element) stack.peek();\n\t\t\t\tlast.appendChild(elem);\n\t\t\t}\n            this.setWhitespaceHandling((Element) stack.push(elem));\n\t\t}\n\t}","commit_id":"1513466f76f0b1e28c8081604cbe8941cd6cb0ea","url":"https://github.com/eXist-db/exist"},{"original_method":"private XmlElementDescriptor[] doCollectElements(@Nullable XmlElement context) {\n    final Map<String,XmlElementDescriptor> map = new LinkedHashMap<String,XmlElementDescriptor>(5);\n    new XmlSchemaTagsProcessor(myDocumentDescriptor) {\n      @Override\n      protected void tagStarted(XmlTag tag, XmlTag context, String tagName) {\n        if (\"element\".equals(tagName) && tag.getAttribute(\"name\") != null) {\n          addElementDescriptor(map, myDocumentDescriptor.createElementDescriptor(tag));\n        }\n      }\n    }.startProcessing(myTag);\n    addSubstitutionGroups(map);\n    filterAbstractElements(map);\n    return map.values().toArray(\n      new XmlElementDescriptor[map.values().size()]\n    );\n  }","id":31094,"modified_method":"private XmlElementDescriptor[] doCollectElements(@Nullable XmlElement context) {\n    final Map<String,XmlElementDescriptor> map = new LinkedHashMap<String,XmlElementDescriptor>(5);\n    new XmlSchemaTagsProcessor(myDocumentDescriptor) {\n      @Override\n      protected void tagStarted(XmlTag tag, String tagName, XmlTag context, XmlTag ref) {\n        if (\"element\".equals(tagName) && tag.getAttribute(\"name\") != null) {\n          addElementDescriptor(map, myDocumentDescriptor.createElementDescriptor(tag));\n        }\n      }\n    }.startProcessing(myTag);\n    addSubstitutionGroups(map);\n    filterAbstractElements(map);\n    return map.values().toArray(\n      new XmlElementDescriptor[map.values().size()]\n    );\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private XmlAttributeDescriptor[] doCollectAttributes(@Nullable final XmlElement context) {\n    final List<XmlAttributeDescriptor> result = new ArrayList<XmlAttributeDescriptor>();\n\n    XmlSchemaTagsProcessor processor = new XmlSchemaTagsProcessor(myDocumentDescriptor, \"element\") {\n      @Override\n      protected void tagStarted(XmlTag tag, XmlTag context, String tagName) {\n        if (ATTRIBUTE_TAG_NAME.equals(tagName)) {\n\n          String name = tag.getAttributeValue(NAME_ATTR_NAME);\n          if (name == null) return;\n\n          String use = null;\n          if (ATTRIBUTE_TAG_NAME.equals(context.getLocalName())) { // from ref\n            use = context.getAttributeValue(\"use\");\n          }\n          if (use == null) use = tag.getAttributeValue(\"use\");\n\n          if (PROHIBITED_ATTR_VALUE.equals(use)) {\n            removeAttributeDescriptor(result, name);\n          }\n          else {\n            XmlAttributeDescriptorImpl descriptor = myDocumentDescriptor.createAttributeDescriptor(tag);\n            descriptor.myUse = use;\n            addAttributeDescriptor(result, descriptor);\n          }\n        }\n      }\n    };\n    processor.startProcessing(myTag);\n    return result.toArray(new XmlAttributeDescriptor[result.size()]);\n  }","id":31095,"modified_method":"private XmlAttributeDescriptor[] doCollectAttributes(@Nullable final XmlElement context) {\n    final List<XmlAttributeDescriptor> result = new ArrayList<XmlAttributeDescriptor>();\n\n    XmlSchemaTagsProcessor processor = new XmlSchemaTagsProcessor(myDocumentDescriptor, \"element\") {\n      @Override\n      protected void tagStarted(XmlTag tag, String tagName, XmlTag context, XmlTag ref) {\n        if (ATTRIBUTE_TAG_NAME.equals(tagName)) {\n\n          String name = tag.getAttributeValue(NAME_ATTR_NAME);\n          if (name == null) return;\n\n          String use = null;\n          if (ATTRIBUTE_TAG_NAME.equals(context.getLocalName())) { // from ref\n            use = context.getAttributeValue(\"use\");\n          }\n          if (use == null) use = tag.getAttributeValue(\"use\");\n\n          if (PROHIBITED_ATTR_VALUE.equals(use)) {\n            removeAttributeDescriptor(result, name);\n          }\n          else {\n            XmlAttributeDescriptorImpl descriptor = myDocumentDescriptor.createAttributeDescriptor(tag);\n            descriptor.myUse = use;\n            addAttributeDescriptor(result, descriptor);\n          }\n        }\n      }\n    };\n    processor.startProcessing(myTag);\n    return result.toArray(new XmlAttributeDescriptor[result.size()]);\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static XmlTag createTag(XmlTag contextTag, XmlElementDescriptor descriptor) {\n    String bodyText = descriptor.getContentType() == XmlElementDescriptor.CONTENT_TYPE_EMPTY ? null : \"\";\n    String namespace = getNamespace(descriptor);\n    return contextTag.createChildTag(descriptor.getName(), namespace, bodyText, false);\n  }","id":31096,"modified_method":"private static XmlTag createTag(XmlTag contextTag, XmlElementDescriptor descriptor) {\n    String namespace = getNamespace(descriptor);\n    XmlTag tag = contextTag.createChildTag(descriptor.getName(), namespace, null, false);\n    PsiElement lastChild = tag.getLastChild();\n    assert lastChild != null;\n    lastChild.delete(); // remove XML_EMPTY_ELEMENT_END\n    return tag;\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getMaxOccurs() {\n    String value = myTag.getAttributeValue(\"maxOccurs\");\n    if (value == null) return 1;\n    if (\"unbounded\".equals(value)) return Integer.MAX_VALUE;\n    try {\n      return Integer.parseInt(value);\n    }\n    catch (NumberFormatException e) {\n      return 1;\n    }\n  }","id":31097,"modified_method":"@Override\n  public int getMaxOccurs() {\n    return getMaxOccursImpl(myRef) * getMaxOccursImpl(myTag);\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getMinOccurs() {\n    String value = myTag.getAttributeValue(\"minOccurs\");\n    try {\n      return value == null ? 1 : Integer.parseInt(value);\n    }\n    catch (NumberFormatException e) {\n      return 1;\n    }\n  }","id":31098,"modified_method":"@Override\n  public int getMinOccurs() {\n    return getMinOccursImpl(myRef) * getMinOccursImpl(myTag);\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlElementsGroupBase(XmlTag tag, XmlElementsGroup parent) {\n    myTag = tag;\n    myParent = parent;\n  }","id":31099,"modified_method":"public XmlElementsGroupBase(XmlTag tag, XmlElementsGroup parent, XmlTag ref) {\n    myTag = tag;\n    myParent = parent;\n    myRef = ref;\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlElementsGroupImpl(XmlTag tag, XmlElementsGroup parent) {\n    super(tag, parent);\n  }","id":31100,"modified_method":"public XmlElementsGroupImpl(XmlTag tag, XmlElementsGroup parent, XmlTag ref) {\n    super(tag, parent, ref);\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlElementsGroupLeaf(XmlTag tag, XmlElementDescriptor descriptor, XmlElementsGroup parent) {\n    super(tag, parent);\n    myDescriptor = descriptor;\n  }","id":31101,"modified_method":"public XmlElementsGroupLeaf(XmlTag tag, XmlElementDescriptor descriptor, XmlElementsGroup parent, XmlTag ref) {\n    super(tag, parent, ref);\n    myDescriptor = descriptor;\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private XmlElementsGroupProcessor(XmlNSDescriptorImpl nsDescriptor) {\n    super(nsDescriptor, \"attribute\");\n    myGroups.push(new XmlElementsGroupImpl(null, null) {\n      @Override\n      public Type getGroupType() {\n        return Type.GROUP;\n      }\n\n      @Override\n      public int getMinOccurs() {\n        return 1;\n      }\n\n      @Override\n      public int getMaxOccurs() {\n        return 1;\n      }\n    });\n  }","id":31102,"modified_method":"private XmlElementsGroupProcessor(XmlNSDescriptorImpl nsDescriptor) {\n    super(nsDescriptor, \"attribute\");\n    myGroups.push(new XmlElementsGroupImpl(null, null, null) {\n      @Override\n      public Type getGroupType() {\n        return Type.GROUP;\n      }\n    });\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void tagStarted(XmlTag tag, XmlTag context, String tagName) {\n    XmlElementsGroup.Type type = XmlElementsGroupImpl.getTagType(tag);\n    if (type != null) {\n      XmlElementsGroupImpl group = new XmlElementsGroupImpl(tag, myGroups.peek());\n      addSubGroup(group);\n      myGroups.push(group);\n    }\n    else if (\"element\".equals(tagName)) {\n      XmlElementsGroup group = new XmlElementsGroupLeaf(tag, myNsDescriptor.createElementDescriptor(tag), myGroups.peek());\n      if (!myGroups.empty()) {\n        addSubGroup(group);\n      }\n      else {\n        myGroups.push(group);\n      }\n    }\n  }","id":31103,"modified_method":"@Override\n  protected void tagStarted(XmlTag tag, String tagName, XmlTag context, XmlTag ref) {\n    XmlElementsGroup.Type type = XmlElementsGroupImpl.getTagType(tag);\n    if (type != null) {\n      XmlElementsGroupImpl group = new XmlElementsGroupImpl(tag, myGroups.peek(), ref);\n      addSubGroup(group);\n      myGroups.push(group);\n    }\n    else if (\"element\".equals(tagName)) {\n      XmlElementsGroup group = new XmlElementsGroupLeaf(tag, myNsDescriptor.createElementDescriptor(tag), myGroups.peek(), ref);\n      if (!myGroups.empty()) {\n        addSubGroup(group);\n      }\n      else {\n        myGroups.push(group);\n      }\n    }\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processTagWithSubTags(@Nullable XmlTag tag, XmlTag ctx) {\n    if (tag == null) return;\n    tagStarted(tag, ctx, tag.getLocalName());\n    XmlTag[] subTags = tag.getSubTags();\n    for (XmlTag subTag : subTags) {\n      processTag(subTag, tag);\n    }\n    tagFinished(tag);\n  }","id":31104,"modified_method":"private void processTagWithSubTags(@Nullable XmlTag tag, XmlTag ctx) {\n    if (tag == null) return;\n    tagStarted(tag, tag.getLocalName(), ctx, null);\n    XmlTag[] subTags = tag.getSubTags();\n    for (XmlTag subTag : subTags) {\n      processTag(subTag, tag);\n    }\n    tagFinished(tag);\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processTag(XmlTag tag, XmlTag context) {\n\n    if (myVisited.contains(tag)) return;\n    myVisited.add(tag);\n\n    if (!XmlNSDescriptorImpl.checkSchemaNamespace(tag)) {\n      processTagWithSubTags(tag, context);\n      return;\n    }\n\n    String tagName = tag.getLocalName();\n    if (checkTagName(tagName, \"element\", \"attribute\")) {\n      XmlAttribute ref = tag.getAttribute(\"ref\");\n      if (ref != null) {\n        XmlTag resolved = resolveReference(ref);\n        if (resolved != null) {\n          tagStarted(resolved, tag, resolved.getLocalName());\n        }\n      }\n      else {\n        tagStarted(tag, context, tag.getLocalName());\n      }\n    }\n    else if (checkTagName(tagName, \"group\")) {\n      String value = tag.getAttributeValue(\"ref\");\n      if (value != null) {\n        XmlTag group = myNsDescriptor.findGroup(value);\n        if (group == null) group = resolveReference(tag.getAttribute(\"ref\"));\n        processTagWithSubTags(group, tag);\n      }\n    }\n    else if (checkTagName(tagName, \"attributeGroup\")) {\n      String ref = tag.getAttributeValue(\"ref\");\n      if (ref == null) return;\n      XmlTag group;\n      XmlTag parentTag = tag.getParentTag();\n      if (XmlNSDescriptorImpl.equalsToSchemaName(parentTag, \"attributeGroup\") &&\n        ref.equals(parentTag.getAttributeValue(\"name\"))) {\n        group = resolveReference(tag.getAttribute(\"ref\"));\n        if (group == null) group = myNsDescriptor.findAttributeGroup(ref);\n      }\n      else {\n        group =  myNsDescriptor.findAttributeGroup(ref);\n        if (group == null) group = resolveReference(tag.getAttribute(\"ref\"));\n      }\n      processTagWithSubTags(group, tag);\n    }\n    else if (checkTagName(tagName, \"restriction\", \"extension\")) {\n      processTagWithSubTags(resolveReference(tag.getAttribute(\"base\")), tag);\n      processTagWithSubTags(tag, context);\n    }\n    else if (!checkTagName(tagName, myTagsToIgnore)) {\n      processTagWithSubTags(tag, context);\n    }\n  }","id":31105,"modified_method":"public void processTag(XmlTag tag, XmlTag context) {\n\n    if (myVisited.contains(tag)) return;\n    myVisited.add(tag);\n\n    if (!XmlNSDescriptorImpl.checkSchemaNamespace(tag)) {\n      processTagWithSubTags(tag, context);\n      return;\n    }\n\n    String tagName = tag.getLocalName();\n    if (checkTagName(tagName, \"element\", \"attribute\")) {\n      XmlAttribute ref = tag.getAttribute(\"ref\");\n      if (ref != null) {\n        XmlTag resolved = resolveReference(ref);\n        if (resolved != null) {\n          tagStarted(resolved, resolved.getLocalName(), tag, tag);\n        }\n      }\n      else {\n        tagStarted(tag, tag.getLocalName(), context, null);\n      }\n    }\n    else if (checkTagName(tagName, \"group\")) {\n      String value = tag.getAttributeValue(\"ref\");\n      if (value != null) {\n        XmlTag group = myNsDescriptor.findGroup(value);\n        if (group == null) group = resolveReference(tag.getAttribute(\"ref\"));\n        processTagWithSubTags(group, tag);\n      }\n    }\n    else if (checkTagName(tagName, \"attributeGroup\")) {\n      String ref = tag.getAttributeValue(\"ref\");\n      if (ref == null) return;\n      XmlTag group;\n      XmlTag parentTag = tag.getParentTag();\n      if (XmlNSDescriptorImpl.equalsToSchemaName(parentTag, \"attributeGroup\") &&\n        ref.equals(parentTag.getAttributeValue(\"name\"))) {\n        group = resolveReference(tag.getAttribute(\"ref\"));\n        if (group == null) group = myNsDescriptor.findAttributeGroup(ref);\n      }\n      else {\n        group =  myNsDescriptor.findAttributeGroup(ref);\n        if (group == null) group = resolveReference(tag.getAttribute(\"ref\"));\n      }\n      processTagWithSubTags(group, tag);\n    }\n    else if (checkTagName(tagName, \"restriction\", \"extension\")) {\n      processTagWithSubTags(resolveReference(tag.getAttribute(\"base\")), tag);\n      processTagWithSubTags(tag, context);\n    }\n    else if (!checkTagName(tagName, myTagsToIgnore)) {\n      processTagWithSubTags(tag, context);\n    }\n  }","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract void tagStarted(XmlTag tag, XmlTag context, String tagName);","id":31106,"modified_method":"protected abstract void tagStarted(XmlTag tag, String tagName, XmlTag context, XmlTag ref);","commit_id":"01dc01dbf07263b3c719f6d8a4fb3172179ce696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void copy(Source source, XMLStreamWriter writer) throws XMLStreamException {\n        if (source instanceof SAXSource) {\n            InputSource src = ((SAXSource)source).getInputSource();\n            if (src.getByteStream() == null && src.getCharacterStream() == null\n                && src.getSystemId() == null && src.getPublicId() == null\n                && ((SAXSource)source).getXMLReader() != null) {\n                //OK - reader is OK.  We'll dump that out\n                StreamWriterContentHandler ch = new StreamWriterContentHandler(writer);\n                XMLReader reader = ((SAXSource)source).getXMLReader();\n                reader.setContentHandler(ch);\n                try {\n                    reader.parse(((SAXSource)source).getInputSource());\n                    return;\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    throw new XMLStreamException(e);\n                }\n            }\n        }\n        \n        XMLStreamReader reader = createXMLStreamReader(source);\n        copy(reader, writer);\n        reader.close();\n    }","id":31107,"modified_method":"public static void copy(Source source, XMLStreamWriter writer) throws XMLStreamException {\n        if (source instanceof SAXSource) {\n            InputSource src = ((SAXSource)source).getInputSource();\n            if (src.getSystemId() == null && src.getPublicId() == null\n                && ((SAXSource)source).getXMLReader() != null) {\n                \n                //OK - reader is OK.  We'll use that out\n                StreamWriterContentHandler ch = new StreamWriterContentHandler(writer);\n                XMLReader reader = ((SAXSource)source).getXMLReader();\n                reader.setContentHandler(ch);\n                try {\n                    try {\n                        reader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    } catch (Throwable t) {\n                        //ignore\n                    }\n                    reader.parse(((SAXSource)source).getInputSource());\n                    return;\n                } catch (Exception e) {\n                    throw new XMLStreamException(e);\n                }\n            }\n        }\n        \n        XMLStreamReader reader = createXMLStreamReader(source);\n        copy(reader, writer);\n        reader.close();\n    }","commit_id":"189bb411281b0e0c1a471bbb3d2ffdcc319c6073","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Method startElement.\n     *\n     * @param namespaceURI\n     * @param localName\n     * @param qName\n     * @param atts\n     * @throws SAXException\n     */\n    public void startElement(String namespaceURI,\n                             String localName,\n                             String qName,\n                             Attributes atts) throws SAXException {\n        try {\n            String prefix = getPrefix(qName);\n            \n            // it is only the prefix we want to learn from the QName! so we can get rid of the\n            // spliting QName\n            if (prefix == null) {\n                writer.writeStartElement(namespaceURI, localName);\n            } else {\n                writer.writeStartElement(prefix, localName, namespaceURI);\n            }\n            for (Map.Entry<String, String> e : mapping.entrySet()) {\n                if (\"\".equals(e.getKey())) {\n                    writer.writeDefaultNamespace(e.getValue());\n                } else {\n                    writer.writeNamespace(e.getKey(), e.getValue());\n                }\n            }\n            mapping.clear();\n            if (atts != null) {\n                int attCount = atts.getLength();\n                for (int i = 0; i < attCount; i++) {\n                    if (StringUtils.isEmpty(atts.getURI(i))) {\n                        writer.writeAttribute(atts.getLocalName(i),\n                                              atts.getValue(i));\n                    } else {\n                        writer.writeAttribute(atts.getURI(i),\n                                          atts.getQName(i),\n                                          atts.getValue(i));\n                    }\n                }\n            }\n        } catch (XMLStreamException e) {\n            throw new SAXException(e);\n        }\n    }","id":31108,"modified_method":"/**\n     * Method startElement.\n     *\n     * @param namespaceURI\n     * @param localName\n     * @param qName\n     * @param atts\n     * @throws SAXException\n     */\n    public void startElement(String namespaceURI,\n                             String localName,\n                             String qName,\n                             Attributes atts) throws SAXException {\n        try {\n            String prefix = getPrefix(qName);\n            \n            // it is only the prefix we want to learn from the QName! so we can get rid of the\n            // spliting QName\n            if (prefix == null) {\n                writer.writeStartElement(namespaceURI, localName);\n            } else {\n                writer.writeStartElement(prefix, localName, namespaceURI);\n            }\n            for (Map.Entry<String, String> e : mapping.entrySet()) {\n                if (\"\".equals(e.getKey())) {\n                    writer.writeDefaultNamespace(e.getValue());\n                } else {\n                    writer.writeNamespace(e.getKey(), e.getValue());\n                }\n            }\n            mapping.clear();\n            if (atts != null) {\n                int attCount = atts.getLength();\n                for (int i = 0; i < attCount; i++) {\n                    if (StringUtils.isEmpty(atts.getURI(i))) {\n                        String s = atts.getLocalName(i);\n                        if (StringUtils.isEmpty(s)) {\n                            s = atts.getQName(i);\n                        }\n                        writer.writeAttribute(s,\n                                              atts.getValue(i));\n                    } else {\n                        writer.writeAttribute(atts.getURI(i),\n                                          atts.getQName(i),\n                                          atts.getValue(i));\n                    }\n                }\n            }\n        } catch (XMLStreamException e) {\n            throw new SAXException(e);\n        }\n    }","commit_id":"189bb411281b0e0c1a471bbb3d2ffdcc319c6073","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public String getPropertyName(Element e)\n    {\n        String parent = e.getParentNode().getLocalName().toLowerCase();\n        if (\"inbound-endpoint\".equals(e.getLocalName()))\n        {\n            return \"messageSource\";\n        }\n        else if (\"wire-tap\".equals(parent) || \"wire-tap-router\".equals(parent))\n        {\n            return \"tap\";\n        }\n        else if (\"binding\".equals(parent) || \"java-interface-binding\".equals(parent)\n                 || \"publish-notifications\".equals(parent) || \"remote-dispatcher-agent\".equals(parent))\n        {\n            return \"endpoint\";\n        }\n        else\n        {\n            return super.getPropertyName(e);\n        }\n    }","id":31109,"modified_method":"@Override\n    public String getPropertyName(Element e)\n    {\n        String parent = e.getParentNode().getLocalName().toLowerCase();\n        if (e.getLocalName() != null && e.getLocalName().toLowerCase().endsWith(\"inbound-endpoint\"))\n        {\n            return \"messageSource\";\n        }\n        else if (\"wire-tap\".equals(parent) || \"wire-tap-router\".equals(parent))\n        {\n            return \"tap\";\n        }\n        else if (\"binding\".equals(parent) || \"java-interface-binding\".equals(parent)\n                 || \"publish-notifications\".equals(parent) || \"remote-dispatcher-agent\".equals(parent))\n        {\n            return \"endpoint\";\n        }\n        else\n        {\n            return super.getPropertyName(e);\n        }\n    }","commit_id":"7d18bc7738dd5e876c2578700ba7c1cdeb1984e2","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates an expression for the when node\n     *\n     * @return expression to be used as builder to configure the when node\n     */\n    public ExpressionClause<ChoiceDefinition> when() {\n        WhenDefinition when = new WhenDefinition();\n        getWhenClauses().add(when);\n        ExpressionClause<ChoiceDefinition> clause = new ExpressionClause<ChoiceDefinition>(this);\n        when.setExpression(clause);\n        return clause;\n    }","id":31110,"modified_method":"/**\n     * Creates an expression for the when node\n     *\n     * @return expression to be used as builder to configure the when node\n     */\n    public ExpressionClause<ChoiceDefinition> when() {\n        WhenDefinition when = new WhenDefinition();\n        when.setParent(this);\n        getWhenClauses().add(when);\n        ExpressionClause<ChoiceDefinition> clause = new ExpressionClause<ChoiceDefinition>(this);\n        when.setExpression(clause);\n        return clause;\n    }","commit_id":"8c26e3a4e4ef5f921e9b8b2af76a8f3527512940","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sets the otherwise node\n     * \n     * @return the builder\n     */\n    public ChoiceDefinition otherwise() {\n        OtherwiseDefinition answer = new OtherwiseDefinition();\n        setOtherwise(answer);\n        return this;\n    }","id":31111,"modified_method":"/**\n     * Sets the otherwise node\n     * \n     * @return the builder\n     */\n    public ChoiceDefinition otherwise() {\n        OtherwiseDefinition answer = new OtherwiseDefinition();\n        answer.setParent(this);\n        setOtherwise(answer);\n        return this;\n    }","commit_id":"8c26e3a4e4ef5f921e9b8b2af76a8f3527512940","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sets the predicate for the when node\n     *\n     * @param predicate  the predicate\n     * @return the builder\n     */\n    public ChoiceDefinition when(Predicate predicate) {\n        getWhenClauses().add(new WhenDefinition(predicate));\n        return this;\n    }","id":31112,"modified_method":"/**\n     * Sets the predicate for the when node\n     *\n     * @param predicate  the predicate\n     * @return the builder\n     */\n    public ChoiceDefinition when(Predicate predicate) {\n        WhenDefinition when = new WhenDefinition(predicate);\n        when.setParent(this);\n        getWhenClauses().add(when);\n        return this;\n    }","commit_id":"8c26e3a4e4ef5f921e9b8b2af76a8f3527512940","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates the breadcrumb based on whether this was a trace of\n     * an exchange coming out of or into a processing step. For example, \n     * <br/><tt>transform(body) -> ID-mojo/39713-1225468755256/2-0<\/tt>\n     * <br/>or\n     * <br/><tt>ID-mojo/39713-1225468755256/2-0 -> transform(body)<\/tt>\n     */\n    protected String extractBreadCrumb(TraceInterceptor interceptor, ProcessorDefinition<?> currentNode, Exchange exchange) {\n        String id = \"\";\n        String result;\n        \n        if (!showBreadCrumb && !showExchangeId && !showShortExchangeId && !showNode) {\n            return \"\";\n        }\n\n        // compute breadcrumb id\n        if (showBreadCrumb) {\n            id = getBreadCrumbID(exchange).toString();\n        } else if (showExchangeId || showShortExchangeId) {\n            id = getBreadCrumbID(exchange).toString();\n            if (showShortExchangeId) {\n                // only output last part of id\n                id = id.substring(id.lastIndexOf('-') + 1);\n            }\n        }\n\n        // compute from, to and route\n        String from = \"\";\n        String to = \"\";\n        String route = \"\";\n        if (showNode || showRouteId) {\n            TracedRouteNodes traced = exchange.getUnitOfWork().getTracedRouteNodes();\n\n            RouteNode traceFrom = traced.getSecondLastNode();\n            if (traceFrom != null) {\n                from = getNodeMessage(traceFrom, exchange);\n            } else if (exchange.getFromEndpoint() != null) {\n                from = \"from(\" + exchange.getFromEndpoint().getEndpointUri() + \")\";\n            }\n\n            RouteNode traceTo = traced.getLastNode();\n            if (traceTo != null) {\n                to = getNodeMessage(traceTo, exchange);\n                // if its an abstract dummy holder then get the 2nd last so we can get the real node that has\n                // information which route it belongs to\n                if (traceTo.isAbstract()) {\n                    traceTo = traced.getSecondLastNode();\n                }\n                route = extractRoute(traceTo.getProcessorDefinition());\n            }\n        }\n\n        // assemble result with and without the to/from\n        if (showNode) {\n            if (showRouteId && route != null) {\n                result = id.trim() + \" >>> (\" + route + \") \" + from + \" --> \" + to.trim() + \" <<< \";\n            } else {\n                result = id.trim() + \" >>> \" + from + \" --> \" + to.trim() + \" <<< \";\n            }\n\n            if (interceptor.shouldTraceOutExchanges() && exchange.hasOut()) {\n                result += \" (OUT) \";\n            }\n        } else {\n            result = id;\n        }\n\n        if (breadCrumbLength > 0) {\n            // we want to ensure text coming after this is aligned for readability\n            return String.format(\"%1$-\" + breadCrumbLength + \".\" + breadCrumbLength + \"s\", result.trim());\n        } else {\n            return result.trim();\n        }\n    }","id":31113,"modified_method":"/**\n     * Creates the breadcrumb based on whether this was a trace of\n     * an exchange coming out of or into a processing step. For example, \n     * <br/><tt>transform(body) -> ID-mojo/39713-1225468755256/2-0<\/tt>\n     * <br/>or\n     * <br/><tt>ID-mojo/39713-1225468755256/2-0 -> transform(body)<\/tt>\n     */\n    protected String extractBreadCrumb(TraceInterceptor interceptor, ProcessorDefinition<?> currentNode, Exchange exchange) {\n        String id = \"\";\n        String result;\n        \n        if (!showBreadCrumb && !showExchangeId && !showShortExchangeId && !showNode) {\n            return \"\";\n        }\n\n        // compute breadcrumb id\n        if (showBreadCrumb) {\n            id = getBreadCrumbID(exchange).toString();\n        } else if (showExchangeId || showShortExchangeId) {\n            id = getBreadCrumbID(exchange).toString();\n            if (showShortExchangeId) {\n                // only output last part of id\n                id = id.substring(id.lastIndexOf('-') + 1);\n            }\n        }\n\n        // compute from, to and route\n        String from = \"\";\n        String to = \"\";\n        String route = \"\";\n        if (showNode || showRouteId) {\n            TracedRouteNodes traced = exchange.getUnitOfWork().getTracedRouteNodes();\n\n            RouteNode traceFrom = traced.getSecondLastNode();\n            if (traceFrom != null) {\n                from = getNodeMessage(traceFrom, exchange);\n            } else if (exchange.getFromEndpoint() != null) {\n                from = \"from(\" + exchange.getFromEndpoint().getEndpointUri() + \")\";\n            }\n\n            RouteNode traceTo = traced.getLastNode();\n            if (traceTo != null) {\n                to = getNodeMessage(traceTo, exchange);\n                // if its an abstract dummy holder then we have to get the 2nd last so we can get the real node that has\n                // information which route it belongs to\n                if (traceTo.isAbstract() && traceTo.getProcessorDefinition() == null) {\n                    traceTo = traced.getSecondLastNode();\n                }\n                if (traceTo != null) {\n                    route = extractRoute(traceTo.getProcessorDefinition());\n                }\n            }\n        }\n\n        // assemble result with and without the to/from\n        if (showNode) {\n            if (showRouteId && route != null) {\n                result = id.trim() + \" >>> (\" + route + \") \" + from + \" --> \" + to.trim() + \" <<< \";\n            } else {\n                result = id.trim() + \" >>> \" + from + \" --> \" + to.trim() + \" <<< \";\n            }\n\n            if (interceptor.shouldTraceOutExchanges() && exchange.hasOut()) {\n                result += \" (OUT) \";\n            }\n        } else {\n            result = id;\n        }\n\n        if (breadCrumbLength > 0) {\n            // we want to ensure text coming after this is aligned for readability\n            return String.format(\"%1$-\" + breadCrumbLength + \".\" + breadCrumbLength + \"s\", result.trim());\n        } else {\n            return result.trim();\n        }\n    }","commit_id":"8c26e3a4e4ef5f921e9b8b2af76a8f3527512940","url":"https://github.com/apache/camel"},{"original_method":"public String getTraceLabel() {\n        return destination.getEndpointUri();\n    }","id":31114,"modified_method":"public String getTraceLabel() {\n        return \"to(\" + destination.getEndpointUri() + \")\";\n    }","commit_id":"8c26e3a4e4ef5f921e9b8b2af76a8f3527512940","url":"https://github.com/apache/camel"},{"original_method":"private void removeAllAbstractMethods(List<MethodInfo> methods) {\n        Iterator<MethodInfo> it = methods.iterator();\n        while (it.hasNext()) {\n            MethodInfo info = it.next();\n            if (Modifier.isAbstract(info.getMethod().getModifiers())) {\n                // we cannot invoke an abstract method\n                it.remove();\n            }\n        }\n    }","id":31115,"modified_method":"private void removeAllAbstractMethods(List<MethodInfo> methods) {\n        Iterator<MethodInfo> it = methods.iterator();\n        while (it.hasNext()) {\n            MethodInfo info = it.next();\n            // if the class is an interface then keep the method\n            boolean isFromInterface = Modifier.isInterface(info.getMethod().getDeclaringClass().getModifiers());\n            if (!isFromInterface && Modifier.isAbstract(info.getMethod().getModifiers())) {\n                // we cannot invoke an abstract method\n                it.remove();\n            }\n        }\n    }","commit_id":"1957a8282e6681edd8f547e225bda66feb640173","url":"https://github.com/apache/camel"},{"original_method":"private EditorAspect getEditor(jetbrains.mps.openapi.editor.EditorContext context, SNode node) {\n    SConcept concept = node.getConcept();\n    boolean isInterface = false;\n    ConceptDescriptor conceptDescriptor = null;\n    if (concept != null) {\n      conceptDescriptor = ConceptRegistry.getInstance().getConceptDescriptor(concept.getQualifiedName());\n      EditorAspect editorAspect = getActiveEditorAspect(conceptDescriptor);\n      if (editorAspect != null) {\n        return editorAspect;\n      }\n      isInterface = conceptDescriptor.isInterfaceConcept();\n    }\n\n\n    boolean isAbstract = isInterface || conceptDescriptor != null && conceptDescriptor.isAbstract();\n    return isAbstract ? new DefaultInterfaceEditor() : new DefaultEditor();\n  }","id":31116,"modified_method":"private EditorAspect getEditor(jetbrains.mps.openapi.editor.EditorContext context, SNode node) {\n    SConcept concept = node.getConcept();\n    boolean isInterface = false;\n    boolean isAbstract = false;\n    if (concept != null) {\n      ConceptDescriptor conceptDescriptor = ConceptRegistry.getInstance().getConceptDescriptor(concept.getQualifiedName());\n      EditorAspect editorAspect = EditorAspectManager.getInstance().getEditorAspect(conceptDescriptor);\n      if (editorAspect != null) {\n        return editorAspect;\n      }\n      isInterface = conceptDescriptor.isInterfaceConcept();\n      isAbstract = conceptDescriptor.isAbstract();\n    }\n\n    return isInterface || isAbstract ? new DefaultInterfaceEditor() : new DefaultEditor();\n  }","commit_id":"a3b903b9061aa1ef1a6eb40aa486f23f8c8f2f6b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void setMethodOrValueFlags(ClassOrInterface klass, MethodMirror methodMirror, MethodOrValue decl) {\n        decl.setShared(methodMirror.isPublic() || methodMirror.isProtected());\n        decl.setProtectedVisibility(methodMirror.isProtected());\n        if(methodMirror.isAbstract()\n                // Java interfaces are formal\n                || (klass instanceof Interface\n                        && !((LazyInterface)klass).isCeylon())\n                || isAnnotated(methodMirror, \"formal\")) {\n            decl.setFormal(true);\n        } else {\n            if (!methodMirror.isFinal() && !methodMirror.isStatic()) {\n                decl.setDefault(true);\n            }\n        }\n        decl.setStaticallyImportable(methodMirror.isStatic());\n        if(isOverridingMethod(methodMirror)){\n            decl.setActual(true);\n        }\n    }","id":31117,"modified_method":"private void setMethodOrValueFlags(ClassOrInterface klass, MethodMirror methodMirror, MethodOrValue decl) {\n        decl.setShared(methodMirror.isPublic() || methodMirror.isProtected());\n        decl.setProtectedVisibility(methodMirror.isProtected());\n        if(// for class members we rely on abstract bit\n           (klass instanceof Class \n                   && methodMirror.isAbstract())\n           // Java interfaces are formal\n           || (klass instanceof Interface\n                   && !((LazyInterface)klass).isCeylon())\n           // For Ceylon interfaces we rely on annotation\n           || isAnnotated(methodMirror, \"formal\")) {\n            decl.setFormal(true);\n        } else {\n            if (// for class members we rely on final/static bits\n                (klass instanceof Class\n                        && !methodMirror.isFinal() \n                        && !methodMirror.isStatic())\n                // Java interfaces are never final\n                || (klass instanceof Interface\n                        && !((LazyInterface)klass).isCeylon())\n                // For Ceylon interfaces we rely on annotation\n                || isAnnotated(methodMirror, \"default\")){\n                decl.setDefault(true);\n            }\n        }\n        decl.setStaticallyImportable(methodMirror.isStatic());\n        if(isOverridingMethod(methodMirror)){\n            decl.setActual(true);\n        }\n    }","commit_id":"00db3f67d85942d87d3dc3661d7cfad83b4e1eff","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void setMethodOrValueFlags(ClassOrInterface klass, MethodMirror methodMirror, MethodOrValue decl) {\n        decl.setShared(methodMirror.isPublic() || methodMirror.isProtected());\n        decl.setProtectedVisibility(methodMirror.isProtected());\n        if(methodMirror.isAbstract() || klass instanceof Interface) {\n            decl.setFormal(true);\n        } else {\n            if (!methodMirror.isFinal() && !methodMirror.isStatic()) {\n                decl.setDefault(true);\n            }\n        }\n        decl.setStaticallyImportable(methodMirror.isStatic());\n        if(isOverridingMethod(methodMirror)){\n            decl.setActual(true);\n        }\n    }","id":31118,"modified_method":"private void setMethodOrValueFlags(ClassOrInterface klass, MethodMirror methodMirror, MethodOrValue decl) {\n        decl.setShared(methodMirror.isPublic() || methodMirror.isProtected());\n        decl.setProtectedVisibility(methodMirror.isProtected());\n        if(methodMirror.isAbstract()\n                // Java interfaces are formal\n                || (klass instanceof Interface\n                        && !((LazyInterface)klass).isCeylon())\n                || isAnnotated(methodMirror, \"formal\")) {\n            decl.setFormal(true);\n        } else {\n            if (!methodMirror.isFinal() && !methodMirror.isStatic()) {\n                decl.setDefault(true);\n            }\n        }\n        decl.setStaticallyImportable(methodMirror.isStatic());\n        if(isOverridingMethod(methodMirror)){\n            decl.setActual(true);\n        }\n    }","commit_id":"f7ad3f0e7511e62539d542e5fe900691d037e6ed","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Method obj) {\n        if (obj.isAbstract())\n            return;\n        if (!obj.isPublic())\n            return;\n        if (!getMethodName().equals(\"clone\"))\n            return;\n        if (!getMethodSig().startsWith(\"()\"))\n            return;\n        hasCloneMethod = true;\n        cloneIsDeprecated = getXMethod().isDeprecated();\n        cloneMethodAnnotation = MethodAnnotation.fromVisitedMethod(this);\n        cloneOnlyThrowsException = PruneUnconditionalExceptionThrowerEdges.doesMethodUnconditionallyThrowException(XFactory\n                .createXMethod(this));\n        // ExceptionTable tbl = obj.getExceptionTable();\n        // throwsExceptions = tbl != null && tbl.getNumberOfExceptions() > 0;\n    }","id":31119,"modified_method":"@Override\n    public void visit(Method obj) {\n        if (obj.isAbstract() || obj.isSynthetic())\n            return;\n        if (!obj.isPublic())\n            return;\n        if (!getMethodName().equals(\"clone\"))\n            return;\n        if (!getMethodSig().startsWith(\"()\"))\n            return;\n        hasCloneMethod = true;\n        cloneIsDeprecated = getXMethod().isDeprecated();\n        cloneMethodAnnotation = MethodAnnotation.fromVisitedMethod(this);\n        cloneOnlyThrowsException = PruneUnconditionalExceptionThrowerEdges.doesMethodUnconditionallyThrowException(XFactory\n                .createXMethod(this));\n        // ExceptionTable tbl = obj.getExceptionTable();\n        // throwsExceptions = tbl != null && tbl.getNumberOfExceptions() > 0;\n    }","commit_id":"8421614c2a4d01423216f188271cc977aa7254cd","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Write all DOAP repositories.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#Repository\">http://usefulinc.com/ns/doap#Repository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#CVSRepository\">http://usefulinc.com/ns/doap#CVSRepository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#SVNRepository\">http://usefulinc.com/ns/doap#SVNRepository<\/a>\n     */\n    private void writeSourceRepositories( XMLWriter writer )\n    {\n        Scm scm = project.getScm();\n        if ( scm == null )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Anonymous Source Repository\", 2 );\n        String anonymousConnection = scm.getConnection();\n        writeSourceRepository( writer, anonymousConnection );\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Developer Source Repository\", 2 );\n        String developerConnection = scm.getDeveloperConnection();\n        writeSourceRepository( writer, developerConnection );\n    }","id":31120,"modified_method":"/**\n     * Write all DOAP repositories.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#Repository\">http://usefulinc.com/ns/doap#Repository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#CVSRepository\">http://usefulinc.com/ns/doap#CVSRepository<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#SVNRepository\">http://usefulinc.com/ns/doap#SVNRepository<\/a>\n     */\n    private void writeSourceRepositories( XMLWriter writer )\n    {\n        Scm scm = project.getScm();\n        if ( scm == null )\n        {\n            return;\n        }\n\n        String anonymousConnection = scm.getConnection();\n        if ( StringUtils.isNotEmpty( anonymousConnection ) )\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil.writeCommentText( writer, \"Anonymous Source Repository\", 2 );\n            writeSourceRepository( writer, anonymousConnection );\n        }\n\n        String developerConnection = scm.getDeveloperConnection();\n        if ( StringUtils.isNotEmpty( developerConnection ) )\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil.writeCommentText( writer, \"Developer Source Repository\", 2 );\n            writeSourceRepository( writer, developerConnection );\n        }\n    }","commit_id":"22f4d92e501f36df318397d06f07be60fe50c6d2","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void exitPath( FeatureResultsParser.PathContext ctx )\n    {\n        // On the workload there is a NodeMatcher, and then zero or more (pathLength) PathLinkMatchers\n\n        NodeMatcher singleNodePath = (NodeMatcher) workload.pop();\n        if ( pathElements.isEmpty() )\n        {\n            workload.push( new PathMatcher( singleNodePath ) );\n        }\n        else\n        {\n            workload.push( new PathMatcher( new ArrayList<>( pathElements ) ) );\n            pathElements.clear();\n        }\n    }","id":31121,"modified_method":"@Override\n    public void exitPath( FeatureResultsParser.PathContext ctx )\n    {\n        // On the workload there is a NodeMatcher, and then zero or more (pathLength) PathLinkMatchers\n\n        NodeMatcher singleNodePath = (NodeMatcher) workload.pop();\n        if ( pathElements.isEmpty() )\n        {\n            workload.push( new PathMatcher( singleNodePath ) );\n        }\n        else\n        {\n            ArrayList<PathLinkMatcher> pathLinkMatchers = new ArrayList<>();\n            pathElements.descendingIterator().forEachRemaining( pathLinkMatchers::add );\n            pathElements.clear();\n            workload.push( new PathMatcher( pathLinkMatchers ) );\n        }\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"ListMatcher for \" + list.toString();\n    }","id":31122,"modified_method":"@Override\n    public String toString()\n    {\n        return \"ListMatcher\" + list.toString();\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof List )\n        {\n            List realList = (List) value;\n            boolean match = realList.size() == list.size();\n            if ( match )\n            {\n                for ( int i = 0; i < list.size(); ++i )\n                {\n                    match &= list.get( i ).matches( realList.get( i ) );\n                }\n            }\n            return match;\n        }\n        return false;\n    }","id":31123,"modified_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof List )\n        {\n            List realList = (List) value;\n            if ( realList.size() == list.size() )\n            {\n                for ( int i = 0; i < list.size(); ++i )\n                {\n                    if ( !list.get( i ).matches( realList.get( i ) ) )\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Map )\n        {\n            Map<String,Object> realMap = (Map<String,Object>) value;\n            Set<String> expectedKeys = map.keySet();\n            Set<String> actualKeys = realMap.keySet();\n            boolean match = expectedKeys.equals( actualKeys );\n\n            if ( match )\n            {\n                for ( String key : expectedKeys )\n                {\n                    match &= map.get( key ).matches( realMap.get( key ) );\n                }\n                return match;\n            }\n        }\n        return false;\n    }","id":31124,"modified_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Map )\n        {\n            Map realMap = (Map) value;\n            Set<String> expectedKeys = map.keySet();\n            Set actualKeys = realMap.keySet();\n\n            if ( expectedKeys.equals( actualKeys ) )\n            {\n                for ( Map.Entry<String,ValueMatcher> entry : map.entrySet() )\n                {\n                    if ( !entry.getValue().matches( realMap.get( entry.getKey() ) ) )\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"MapMatcher {\" + map.toString();\n    }","id":31125,"modified_method":"@Override\n    public String toString()\n    {\n        return \"MapMatcher\" + map.toString();\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Node )\n        {\n            Node node = (Node) value;\n            Iterable<Label> labels = node.getLabels();\n            boolean match = true;\n            int nbrOfLabels = 0;\n            for ( Label l : labels )\n            {\n                match &= labelNames.contains( l.name() );\n                ++nbrOfLabels;\n            }\n            match &= nbrOfLabels == labelNames.size();\n\n            match &= propertyMatcher.matches( node.getAllProperties() );\n\n            return match;\n        }\n        return false;\n    }","id":31126,"modified_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Node )\n        {\n            Node node = (Node) value;\n            int nbrOfLabels = 0;\n            for ( Label l : node.getLabels() )\n            {\n                if ( !labelNames.contains( l.name() ) )\n                {\n                    return false;\n                }\n                ++nbrOfLabels;\n            }\n\n            return labelNames.size() == nbrOfLabels && propertyMatcher.matches( node.getAllProperties() );\n        }\n        return false;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"NodeMatcher (\" + labelNames + \") \" + propertyMatcher;\n    }","id":31127,"modified_method":"@Override\n    public String toString()\n    {\n        return \"NodeMatcher\" + labelNames + propertyMatcher;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"PathLinkMatcher \"\n               + leftNode + (outgoing ? \"-\" : \"<-\")\n               + relMatcher + (outgoing ? \"->\" : \"-\")\n               + rightNode;\n    }","id":31128,"modified_method":"@Override\n    public String toString()\n    {\n        return \"PathLinkMatcher <<\"\n               + leftNode + (outgoing ? \"-\" : \"<-\")\n               + relMatcher + (outgoing ? \"->\" : \"-\")\n               + rightNode + \">>\";\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Relationship )\n        {\n            Relationship real = (Relationship) value;\n            boolean matches = relMatcher.matches( real );\n            if ( outgoing )\n            {\n                matches &= leftNode.matches( real.getStartNode() );\n                matches &= rightNode.matches( real.getEndNode() );\n            }\n            else\n            {\n                matches &= leftNode.matches( real.getEndNode() );\n                matches &= rightNode.matches( real.getStartNode() );\n            }\n            return matches;\n        }\n        return false;\n    }","id":31129,"modified_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Relationship )\n        {\n            Relationship real = (Relationship) value;\n            if ( !relMatcher.matches( real ) )\n            {\n                return false;\n            }\n            if ( outgoing )\n            {\n                if ( !leftNode.matches( real.getStartNode() ) || !rightNode.matches( real.getEndNode() ) )\n                {\n                    return false;\n                }\n            }\n            // incoming\n            else if ( !leftNode.matches( real.getEndNode() ) || !rightNode.matches( real.getStartNode() ) )\n            {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Path )\n        {\n            Path path = (Path) value;\n            if ( pathLinks.isEmpty() )\n            {\n                boolean matches = path.length() == 0;\n                matches &= singleNodePath.matches( path.startNode() );\n                matches &= singleNodePath.matches( path.endNode() );\n                return matches;\n            }\n            else\n            {\n                boolean matches = path.length() == pathLinks.size();\n                if ( matches )\n                {\n                    Iterator<Relationship> relationships = path.relationships().iterator();\n                    for ( PathLinkMatcher pathLink : pathLinks )\n                    {\n                        pathLink.matches( relationships.next() );\n                    }\n                }\n                return matches;\n            }\n        }\n        return false;\n    }","id":31130,"modified_method":"@Override\n    public boolean matches( Object value )\n    {\n        if ( value instanceof Path )\n        {\n            Path path = (Path) value;\n            if ( path.length() != pathLinks.size() )\n            {\n                return false;\n            }\n            if ( pathLinks.isEmpty() )\n            {\n                return path.length() == 0\n                       && singleNodePath.matches( path.startNode() )\n                       && singleNodePath.matches( path.endNode() );\n            }\n            else\n            {\n                Iterator<Relationship> relationships = path.relationships().iterator();\n                for ( PathLinkMatcher pathLink : pathLinks )\n                {\n                    Relationship next = relationships.next();\n                    if ( !pathLink.matches( next ) )\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        if ( pathLinks.isEmpty() )\n        {\n            return \"PathMatcher for \" + singleNodePath;\n        }\n        else\n        {\n            return \"PathMatcher for \" + pathLinks;\n        }\n    }","id":31131,"modified_method":"@Override\n    public String toString()\n    {\n        if ( pathLinks.isEmpty() )\n        {\n            return \"PathMatcher\" + singleNodePath;\n        }\n        else\n        {\n            return \"PathMatcher\" + pathLinks;\n        }\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"RelationshipMatcher [\" + relationshipTypeName + \"] \" + propertyMatcher;\n    }","id":31132,"modified_method":"@Override\n    public String toString()\n    {\n        return \"RelationshipMatcher[\" + relationshipTypeName + \"]\" + propertyMatcher;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"RowMatcher(\" + values + \")\";\n    }","id":31133,"modified_method":"@Override\n    public String toString()\n    {\n        return \"RowMatcher\" + values;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean matches( Map<String,Object> value )\n    {\n        Set<String> keys = values.keySet();\n        boolean matches = keys.equals( value.keySet() );\n        if ( matches )\n        {\n            for ( String key : keys )\n            {\n                matches &= values.get( key ).matches( value.get( key ) );\n            }\n        }\n        return matches;\n    }","id":31134,"modified_method":"@Override\n    public boolean matches( Map<String,Object> value )\n    {\n        Set<String> keys = values.keySet();\n        if ( keys.equals( value.keySet() ) )\n        {\n            for ( String key : keys )\n            {\n                if ( !values.get( key ).matches( value.get( key ) ) )\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"587044a07ad8ca987ac9525a4a51660699e986af","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static String[] getKeys(String formNavigatorId) {\n\t\tList<String> keys = new ArrayList<>();\n\n\t\tList<FormNavigatorCategory> formNavigatorCategories =\n\t\t\tgetFormNavigatorCategories(formNavigatorId);\n\n\t\tfor (FormNavigatorCategory formNavigatorCategory :\n\t\t\t\tformNavigatorCategories) {\n\n\t\t\tString key = formNavigatorCategory.getKey();\n\n\t\t\tif (Validator.isNotNull(key)) {\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys.toArray(new String[keys.size()]);\n\t}","id":31135,"modified_method":"public static String[] getKeys(String formNavigatorId) {\n\t\tList<String> keys = new ArrayList<>();\n\n\t\tList<FormNavigatorCategory> formNavigatorCategories =\n\t\t\tgetFormNavigatorCategories(formNavigatorId);\n\n\t\tif (ListUtil.isEmpty(formNavigatorCategories)) {\n\t\t\treturn new String[] {\"\"};\n\t\t}\n\n\t\tfor (FormNavigatorCategory formNavigatorCategory :\n\t\t\t\tformNavigatorCategories) {\n\n\t\t\tString key = formNavigatorCategory.getKey();\n\n\t\t\tif (Validator.isNotNull(key)) {\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys.toArray(new String[keys.size()]);\n\t}","commit_id":"df4371bf4cc0d693ba1e5fe1f00e02265b303751","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String[] getLabels(String formNavigatorId, Locale locale) {\n\t\tList<String> labels = new ArrayList<>();\n\n\t\tList<FormNavigatorCategory> formNavigatorCategories =\n\t\t\tgetFormNavigatorCategories(formNavigatorId);\n\n\t\tfor (FormNavigatorCategory formNavigatorCategory :\n\t\t\t\tformNavigatorCategories) {\n\n\t\t\tString label = formNavigatorCategory.getLabel(locale);\n\n\t\t\tif (Validator.isNotNull(label)) {\n\t\t\t\tlabels.add(label);\n\t\t\t}\n\t\t}\n\n\t\treturn labels.toArray(new String[labels.size()]);\n\t}","id":31136,"modified_method":"public static String[] getLabels(String formNavigatorId, Locale locale) {\n\t\tList<String> labels = new ArrayList<>();\n\n\t\tList<FormNavigatorCategory> formNavigatorCategories =\n\t\t\tgetFormNavigatorCategories(formNavigatorId);\n\n\t\tif (ListUtil.isEmpty(formNavigatorCategories)) {\n\t\t\treturn new String[] {\"\"};\n\t\t}\n\n\t\tfor (FormNavigatorCategory formNavigatorCategory :\n\t\t\t\tformNavigatorCategories) {\n\n\t\t\tString label = formNavigatorCategory.getLabel(locale);\n\n\t\t\tif (Validator.isNotNull(label)) {\n\t\t\t\tlabels.add(label);\n\t\t\t}\n\t\t}\n\n\t\treturn labels.toArray(new String[labels.size()]);\n\t}","commit_id":"df4371bf4cc0d693ba1e5fe1f00e02265b303751","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <T> List<FormNavigatorEntry<T>> getFormNavigatorEntries(\n\t\tString formNavigatorId, User user, T formModelBean) {\n\n\t\tList<FormNavigatorEntry<T>> formNavigatorEntries = new ArrayList<>();\n\n\t\tList<FormNavigatorCategory> formNavigatorCategories =\n\t\t\tFormNavigatorCategoryUtil.getFormNavigatorCategories(\n\t\t\t\tformNavigatorId);\n\n\t\tfor (FormNavigatorCategory formNavigatorCategory :\n\t\t\t\tformNavigatorCategories) {\n\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList<FormNavigatorEntry<T>> curFormNavigatorEntries =\n\t\t\t\t(List)_instance._formNavigatorEntries.getService(\n\t\t\t\t\t_getKey(formNavigatorId, formNavigatorCategory.getKey()));\n\n\t\t\tif (curFormNavigatorEntries != null) {\n\t\t\t\tformNavigatorEntries.addAll(curFormNavigatorEntries);\n\t\t\t}\n\t\t}\n\n\t\treturn filterVisibleFormNavigatorEntries(\n\t\t\tformNavigatorEntries, user, formModelBean);\n\t}","id":31137,"modified_method":"public static <T> List<FormNavigatorEntry<T>> getFormNavigatorEntries(\n\t\tString formNavigatorId, User user, T formModelBean) {\n\n\t\tList<FormNavigatorEntry<T>> formNavigatorEntries = new ArrayList<>();\n\n\t\tString[] categoryKeys = FormNavigatorCategoryUtil.getKeys(\n\t\t\tformNavigatorId);\n\n\t\tfor (String categoryKey : categoryKeys) {\n\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList<FormNavigatorEntry<T>> curFormNavigatorEntries =\n\t\t\t\t(List)_instance._formNavigatorEntries.getService(\n\t\t\t\t\t_getKey(formNavigatorId, categoryKey));\n\n\t\t\tif (curFormNavigatorEntries != null) {\n\t\t\t\tformNavigatorEntries.addAll(curFormNavigatorEntries);\n\t\t\t}\n\t\t}\n\n\t\treturn filterVisibleFormNavigatorEntries(\n\t\t\tformNavigatorEntries, user, formModelBean);\n\t}","commit_id":"df4371bf4cc0d693ba1e5fe1f00e02265b303751","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String[] getCategoryKeys() {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\tString[] categoryKeys = FormNavigatorCategoryUtil.getKeys(_id);\n\n\t\tif (ArrayUtil.isEmpty(categoryKeys)) {\n\t\t\treturn new String[] {\"\"};\n\t\t}\n\n\t\treturn categoryKeys;\n\t}","id":31138,"modified_method":"protected String[] getCategoryKeys() {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\treturn FormNavigatorCategoryUtil.getKeys(_id);\n\t}","commit_id":"df4371bf4cc0d693ba1e5fe1f00e02265b303751","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String[] getCategoryLabels() {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString[] categoryLabels = FormNavigatorCategoryUtil.getLabels(\n\t\t\t_id, themeDisplay.getLocale());\n\n\t\tif (ArrayUtil.isEmpty(categoryLabels)) {\n\t\t\tcategoryLabels = new String[] {\"\"};\n\t\t}\n\n\t\treturn categoryLabels;\n\t}","id":31139,"modified_method":"protected String[] getCategoryLabels() {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\treturn FormNavigatorCategoryUtil.getLabels(\n\t\t\t_id, themeDisplay.getLocale());\n\t}","commit_id":"df4371bf4cc0d693ba1e5fe1f00e02265b303751","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String[][] getCategorySectionLabels() {\n\t\tif (_categorySections != null) {\n\t\t\treturn _categorySections;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString[] categoryKeys = getCategoryKeys();\n\n\t\tString[][] categorySectionLabels = new String[categoryKeys.length][];\n\n\t\tfor (int i = 0; i < categoryKeys.length; i++) {\n\t\t\tString categoryKey = categoryKeys[i];\n\n\t\t\tcategorySectionLabels = ArrayUtil.append(\n\t\t\t\tcategorySectionLabels,\n\t\t\t\tFormNavigatorEntryUtil.getLabels(\n\t\t\t\t\t_id, categoryKey, themeDisplay.getUser(), _formModelBean,\n\t\t\t\t\tthemeDisplay.getLocale()));\n\t\t}\n\n\t\treturn categorySectionLabels;\n\t}","id":31140,"modified_method":"protected String[][] getCategorySectionLabels() {\n\t\tif (_categorySections != null) {\n\t\t\treturn _categorySections;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString[] categoryKeys = getCategoryKeys();\n\n\t\tString[][] categorySectionLabels = new String[0][];\n\n\t\tfor (int i = 0; i < categoryKeys.length; i++) {\n\t\t\tString categoryKey = categoryKeys[i];\n\n\t\t\tcategorySectionLabels = ArrayUtil.append(\n\t\t\t\tcategorySectionLabels,\n\t\t\t\tFormNavigatorEntryUtil.getLabels(\n\t\t\t\t\t_id, categoryKey, themeDisplay.getUser(), _formModelBean,\n\t\t\t\t\tthemeDisplay.getLocale()));\n\t\t}\n\n\t\treturn categorySectionLabels;\n\t}","commit_id":"54db64e2f7376888d974845ba742cc80cc60d29c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String[] getCategoryLabels(Locale locale) {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\treturn FormNavigatorCategoryUtil.getLabels(_id, locale);\n\t}","id":31141,"modified_method":"protected String[] getCategoryLabels(Locale locale) {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\tString[] categoryLabels = FormNavigatorCategoryUtil.getLabels(\n\t\t\t_id, locale);\n\n\t\tif (ArrayUtil.isEmpty(categoryLabels)) {\n\t\t\tcategoryLabels = new String[] {\"\"};\n\t\t}\n\n\t\treturn categoryLabels;\n\t}","commit_id":"54db64e2f7376888d974845ba742cc80cc60d29c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String[][] getCategorySectionKeys() {\n\t\tif (_categorySections != null) {\n\t\t\treturn _categorySections;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString[] categoryKeys = getCategoryKeys();\n\n\t\tString[][] categorySectionKeys = new String[categoryKeys.length][];\n\n\t\tfor (int i = 0; i < categoryKeys.length; i++) {\n\t\t\tString categoryKey = categoryKeys[i];\n\n\t\t\tcategorySectionKeys = ArrayUtil.append(\n\t\t\t\tcategorySectionKeys,\n\t\t\t\tFormNavigatorEntryUtil.getKeys(\n\t\t\t\t\t_id, categoryKey, themeDisplay.getUser(), _formModelBean));\n\t\t}\n\n\t\treturn categorySectionKeys;\n\t}","id":31142,"modified_method":"protected String[][] getCategorySectionKeys() {\n\t\tif (_categorySections != null) {\n\t\t\treturn _categorySections;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString[] categoryKeys = getCategoryKeys();\n\n\t\tString[][] categorySectionKeys = new String[0][];\n\n\t\tfor (int i = 0; i < categoryKeys.length; i++) {\n\t\t\tString categoryKey = categoryKeys[i];\n\n\t\t\tcategorySectionKeys = ArrayUtil.append(\n\t\t\t\tcategorySectionKeys,\n\t\t\t\tFormNavigatorEntryUtil.getKeys(\n\t\t\t\t\t_id, categoryKey, themeDisplay.getUser(), _formModelBean));\n\t\t}\n\n\t\treturn categorySectionKeys;\n\t}","commit_id":"54db64e2f7376888d974845ba742cc80cc60d29c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String[] getCategoryKeys() {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\treturn FormNavigatorCategoryUtil.getKeys(_id);\n\t}","id":31143,"modified_method":"protected String[] getCategoryKeys() {\n\t\tif (_categoryNames != null) {\n\t\t\treturn _categoryNames;\n\t\t}\n\n\t\tString[] categoryKeys = FormNavigatorCategoryUtil.getKeys(_id);\n\n\t\tif (ArrayUtil.isEmpty(categoryKeys)) {\n\t\t\treturn new String[] {\"\"};\n\t\t}\n\n\t\treturn categoryKeys;\n\t}","commit_id":"54db64e2f7376888d974845ba742cc80cc60d29c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Flux<Object> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType,\n\t\t\tMimeType mimeType, Object... hints) {\n\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\t\tTypeFactory typeFactory = this.mapper.getTypeFactory();\n\t\tJavaType javaType = typeFactory.constructType(elementType.getType());\n\t\tObjectReader reader = this.mapper.readerFor(javaType);\n\n\t\treturn this.preProcessor.decode(inputStream, elementType, mimeType, hints)\n\t\t\t\t.map(dataBuffer -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject value = reader.readValue(dataBuffer.asInputStream());\n\t\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\treturn Flux.error(new CodecException(\"Error while reading the data\", e));\n\t\t\t\t\t}\n\t\t});\n\t}","id":31144,"modified_method":"@Override\n\tpublic Flux<Object> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType,\n\t\t\tMimeType mimeType, Object... hints) {\n\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\t\tTypeFactory typeFactory = this.mapper.getTypeFactory();\n\t\tJavaType javaType = typeFactory.constructType(elementType.getType());\n\t\tObjectReader reader = this.mapper.readerFor(javaType);\n\n\t\treturn this.fluxPreProcessor.decode(inputStream, elementType, mimeType, hints)\n\t\t\t\t.map(dataBuffer -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject value = reader.readValue(dataBuffer.asInputStream());\n\t\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\treturn Flux.error(new CodecException(\"Error while reading the data\", e));\n\t\t\t\t\t}\n\t\t});\n\t}","commit_id":"917a2fb9d00d08e95ac4ae5c3c9c6184569d4031","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\t@Ignore // Issue 109\n\tpublic void decodeToList() throws Exception {\n\t\tFlux<DataBuffer> source = Flux.just(stringBuffer(\n\t\t\t\t\"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\"));\n\n\t\tMethod method = getClass().getDeclaredMethod(\"handle\", List.class);\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(method, 0);\n\t\tFlux<Object> flux = new JacksonJsonDecoder().decode(source, elementType, null);\n\n\t\tTestSubscriber.subscribe(flux).assertNoError().assertComplete().\n\t\t\t\tassertValues(Arrays.asList(new Pojo(\"f1\", \"b1\"), new Pojo(\"f2\", \"b2\")));\n\t}","id":31145,"modified_method":"@Test\n\tpublic void decodeToList() throws Exception {\n\t\tFlux<DataBuffer> source = Flux.just(stringBuffer(\n\t\t\t\t\"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\"));\n\n\t\tMethod method = getClass().getDeclaredMethod(\"handle\", List.class);\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(method, 0);\n\t\tMono<Object> mono = new JacksonJsonDecoder().decodeOne(source, elementType, null);\n\n\t\tTestSubscriber.subscribe(mono).assertNoError().assertComplete().\n\t\t\t\tassertValues(Arrays.asList(new Pojo(\"f1\", \"b1\"), new Pojo(\"f2\", \"b2\")));\n\t}","commit_id":"917a2fb9d00d08e95ac4ae5c3c9c6184569d4031","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean isAsyncType(ResolvableType type) {\n\t\treturn (Mono.class.equals(type.getRawClass()) || Flux.class.equals(type.getRawClass()) ||\n\t\t\t\tgetConversionService().canConvert(Publisher.class, type.getRawClass()));\n\t}","id":31146,"modified_method":"private boolean isAsyncType(ResolvableType type) {\n\t\treturn (Mono.class.equals(type.getRawClass()) || Flux.class.equals(type.getRawClass()) ||\n\t\t\t\tgetConversionService().canConvert(Mono.class, type.getRawClass()) ||\n\t\t\t\tgetConversionService().canConvert(Flux.class, type.getRawClass()));\n\t}","commit_id":"917a2fb9d00d08e95ac4ae5c3c9c6184569d4031","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Mono<Object> resolveArgument(MethodParameter parameter, ModelMap model,\n\t\t\tServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tboolean isAsyncType = isAsyncType(type);\n\t\tResolvableType elementType = (isAsyncType ? type.getGeneric(0) : type);\n\n\t\tMediaType mediaType = exchange.getRequest().getHeaders().getContentType();\n\t\tif (mediaType == null) {\n\t\t\tmediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tfor (HttpMessageConverter<?> converter : getMessageConverters()) {\n\t\t\tif (converter.canRead(elementType, mediaType)) {\n\t\t\t\tFlux<?> elementFlux = converter.read(elementType, exchange.getRequest());\n\n\t\t\t\tif (this.validator != null) {\n\t\t\t\t\telementFlux= applyValidationIfApplicable(elementFlux, parameter);\n\t\t\t\t}\n\n\t\t\t\tif (Mono.class.equals(type.getRawClass())) {\n\t\t\t\t\treturn Mono.just(Mono.from(elementFlux));\n\t\t\t\t}\n\t\t\t\telse if (Flux.class.equals(type.getRawClass())) {\n\t\t\t\t\treturn Mono.just(elementFlux);\n\t\t\t\t}\n\t\t\t\telse if (isAsyncType) {\n\t\t\t\t\treturn Mono.just(getConversionService().convert(elementFlux, type.getRawClass()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn elementFlux.next().map(o -> o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes));\n\t}","id":31147,"modified_method":"@Override\n\tpublic Mono<Object> resolveArgument(MethodParameter parameter, ModelMap model,\n\t\t\tServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tboolean isAsyncType = isAsyncType(type);\n\t\tboolean isStreamableType = isStreamableType(type);\n\t\tResolvableType elementType = (isStreamableType || isAsyncType ? type.getGeneric(0) : type);\n\n\t\tMediaType mediaType = exchange.getRequest().getHeaders().getContentType();\n\t\tif (mediaType == null) {\n\t\t\tmediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tfor (HttpMessageConverter<?> converter : getMessageConverters()) {\n\t\t\tif (converter.canRead(elementType, mediaType)) {\n\n\t\t\t\tif (isStreamableType) {\n\t\t\t\t\tPublisher<?> elements = converter.read(elementType, exchange.getRequest());\n\t\t\t\t\tif (this.validator != null) {\n\t\t\t\t\t\telements= applyValidationIfApplicable(elements, parameter);\n\t\t\t\t\t}\n\t\t\t\t\tif (Flux.class.equals(type.getRawClass())) {\n\t\t\t\t\t\treturn Mono.just(elements);\n\t\t\t\t\t}\n\t\t\t\t\telse if (isAsyncType && this.conversionService.canConvert(Flux.class, type.getRawClass())) {\n\t\t\t\t\t\treturn Mono.just(this.conversionService.convert(elements, type.getRawClass()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMono<?> element = converter.readOne(elementType, exchange.getRequest());\n\t\t\t\t\tif (this.validator != null) {\n\t\t\t\t\t\telement = Mono.from(applyValidationIfApplicable(element, parameter));\n\t\t\t\t\t}\n\t\t\t\t\tif (Mono.class.equals(type.getRawClass())) {\n\t\t\t\t\t\treturn Mono.just(element);\n\t\t\t\t\t}\n\t\t\t\t\telse if (isAsyncType && this.conversionService.canConvert(Mono.class, type.getRawClass())) {\n\t\t\t\t\t\treturn Mono.just(this.conversionService.convert(element, type.getRawClass()));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn (Mono<Object>)element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes));\n\t}","commit_id":"917a2fb9d00d08e95ac4ae5c3c9c6184569d4031","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected Flux<?> applyValidationIfApplicable(Flux<?> elementFlux, MethodParameter methodParam) {\n\t\tAnnotation[] annotations = methodParam.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tValidated validAnnot = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\t\tif (validAnnot != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n\t\t\t\tObject hints = (validAnnot != null ? validAnnot.value() : AnnotationUtils.getValue(ann));\n\t\t\t\tObject[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n\t\t\t\treturn elementFlux.map(element -> {\n\t\t\t\t\tvalidate(element, validationHints, methodParam);\n\t\t\t\t\treturn element;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn elementFlux;\n\t}","id":31148,"modified_method":"protected Publisher<?> applyValidationIfApplicable(Publisher<?> elements, MethodParameter methodParam) {\n\t\tAnnotation[] annotations = methodParam.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tValidated validAnnot = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\t\tif (validAnnot != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n\t\t\t\tObject hints = (validAnnot != null ? validAnnot.value() : AnnotationUtils.getValue(ann));\n\t\t\t\tObject[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n\t\t\t\treturn Flux.from(elements).map(element -> {\n\t\t\t\t\tvalidate(element, validationHints, methodParam);\n\t\t\t\t\treturn element;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn elements;\n\t}","commit_id":"917a2fb9d00d08e95ac4ae5c3c9c6184569d4031","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected DataBuffer createDataBuffer(int capacity) {\n\t\treturn this.dataBufferFactory.allocateBuffer(capacity);\n\t}","id":31149,"modified_method":"protected DataBuffer createDataBuffer(int capacity) {\n\t\treturn this.bufferFactory.allocateBuffer(capacity);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected DataBuffer stringBuffer(String value) {\n\t\tbyte[] bytes = value.getBytes(StandardCharsets.UTF_8);\n\t\tDataBuffer buffer = this.dataBufferFactory.allocateBuffer(bytes.length);\n\t\tbuffer.write(bytes);\n\t\treturn buffer;\n\t}","id":31150,"modified_method":"protected DataBuffer stringBuffer(String value) {\n\t\tbyte[] bytes = value.getBytes(StandardCharsets.UTF_8);\n\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(bytes.length);\n\t\tbuffer.write(bytes);\n\t\treturn buffer;\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encode() {\n\t\tbyte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\n\t\tFlux<ByteBuffer> source =\n\t\t\t\tFlux.just(ByteBuffer.wrap(fooBytes), ByteBuffer.wrap(barBytes));\n\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.dataBufferFactory,\n\t\t\t\tResolvableType.forClassWithGenerics(Publisher.class, ByteBuffer.class),\n\t\t\t\tnull);\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertValuesWith(b -> {\n\t\t\t\t\tbyte[] buf = new byte[3];\n\t\t\t\t\tb.read(buf);\n\t\t\t\t\tassertArrayEquals(fooBytes, buf);\n\t\t\t\t}, b -> {\n\t\t\t\t\tbyte[] buf = new byte[3];\n\t\t\t\t\tb.read(buf);\n\t\t\t\t\tassertArrayEquals(barBytes, buf);\n\t\t\t\t});\n\t}","id":31151,"modified_method":"@Test\n\tpublic void encode() {\n\t\tbyte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\n\t\tFlux<ByteBuffer> source =\n\t\t\t\tFlux.just(ByteBuffer.wrap(fooBytes), ByteBuffer.wrap(barBytes));\n\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.bufferFactory,\n\t\t\t\tResolvableType.forClassWithGenerics(Publisher.class, ByteBuffer.class),\n\t\t\t\tnull);\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertValuesWith(b -> {\n\t\t\t\t\tbyte[] buf = new byte[3];\n\t\t\t\t\tb.read(buf);\n\t\t\t\t\tassertArrayEquals(fooBytes, buf);\n\t\t\t\t}, b -> {\n\t\t\t\t\tbyte[] buf = new byte[3];\n\t\t\t\t\tb.read(buf);\n\t\t\t\t\tassertArrayEquals(barBytes, buf);\n\t\t\t\t});\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void dumpBytes() {\n\t\tDataBuffer buffer = this.dataBufferFactory.allocateBuffer(4);\n\t\tbyte[] source = {'a', 'b', 'c', 'd'};\n\t\tbuffer.write(source);\n\n\t\tbyte[] result = DataBufferTestUtils.dumpBytes(buffer);\n\n\t\tassertArrayEquals(source, result);\n\n\t\trelease(buffer);\n\t}","id":31152,"modified_method":"@Test\n\tpublic void dumpBytes() {\n\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(4);\n\t\tbyte[] source = {'a', 'b', 'c', 'd'};\n\t\tbuffer.write(source);\n\n\t\tbyte[] result = DataBufferTestUtils.dumpBytes(buffer);\n\n\t\tassertArrayEquals(source, result);\n\n\t\trelease(buffer);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void dumpString() {\n\t\tDataBuffer buffer = this.dataBufferFactory.allocateBuffer(4);\n\t\tString source = \"abcd\";\n\t\tbuffer.write(source.getBytes(StandardCharsets.UTF_8));\n\n\t\tString result = DataBufferTestUtils.dumpString(buffer, StandardCharsets.UTF_8);\n\n\t\tassertEquals(source, result);\n\n\t\trelease(buffer);\n\t}","id":31153,"modified_method":"@Test\n\tpublic void dumpString() {\n\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(4);\n\t\tString source = \"abcd\";\n\t\tbuffer.write(source.getBytes(StandardCharsets.UTF_8));\n\n\t\tString result = DataBufferTestUtils.dumpString(buffer, StandardCharsets.UTF_8);\n\n\t\tassertEquals(source, result);\n\n\t\trelease(buffer);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void readUnalignedChannel() throws Exception {\n\t\tURI uri = DataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\")\n\t\t\t\t.toURI();\n\t\tFileChannel channel = FileChannel.open(Paths.get(uri), StandardOpenOption.READ);\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(channel, this.dataBufferFactory, 3);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(flux)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"foo\"), stringConsumer(\"\\nba\"),\n\t\t\t\t\t\tstringConsumer(\"r\\nb\"), stringConsumer(\"az\\n\"),\n\t\t\t\t\t\tstringConsumer(\"qux\"), stringConsumer(\"\\n\"));\n\n\t\tassertFalse(channel.isOpen());\n\t}","id":31154,"modified_method":"@Test\n\tpublic void readUnalignedChannel() throws Exception {\n\t\tURI uri = DataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\")\n\t\t\t\t.toURI();\n\t\tFileChannel channel = FileChannel.open(Paths.get(uri), StandardOpenOption.READ);\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(channel, this.bufferFactory, 3);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(flux)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"foo\"), stringConsumer(\"\\nba\"),\n\t\t\t\t\t\tstringConsumer(\"r\\nb\"), stringConsumer(\"az\\n\"),\n\t\t\t\t\t\tstringConsumer(\"qux\"), stringConsumer(\"\\n\"));\n\n\t\tassertFalse(channel.isOpen());\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void readChannel() throws Exception {\n\t\tURI uri = DataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\")\n\t\t\t\t.toURI();\n\t\tFileChannel channel = FileChannel.open(Paths.get(uri), StandardOpenOption.READ);\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(channel, this.dataBufferFactory, 4);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(flux)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"foo\\n\"), stringConsumer(\"bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"baz\\n\"), stringConsumer(\"qux\\n\"));\n\n\t\tassertFalse(channel.isOpen());\n\t}","id":31155,"modified_method":"@Test\n\tpublic void readChannel() throws Exception {\n\t\tURI uri = DataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\")\n\t\t\t\t.toURI();\n\t\tFileChannel channel = FileChannel.open(Paths.get(uri), StandardOpenOption.READ);\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(channel, this.bufferFactory, 4);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(flux)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"foo\\n\"), stringConsumer(\"bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"baz\\n\"), stringConsumer(\"qux\\n\"));\n\n\t\tassertFalse(channel.isOpen());\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void readInputStream() {\n\t\tInputStream is = DataBufferUtilsTests.class\n\t\t\t\t.getResourceAsStream(\"DataBufferUtilsTests.txt\");\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(is, this.dataBufferFactory, 4);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(flux)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"foo\\n\"), stringConsumer(\"bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"baz\\n\"), stringConsumer(\"qux\\n\"));\n\t}","id":31156,"modified_method":"@Test\n\tpublic void readInputStream() {\n\t\tInputStream is = DataBufferUtilsTests.class\n\t\t\t\t.getResourceAsStream(\"DataBufferUtilsTests.txt\");\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(is, this.bufferFactory, 4);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(flux)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"foo\\n\"), stringConsumer(\"bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"baz\\n\"), stringConsumer(\"qux\\n\"));\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream,\n\t\t\tDataBufferFactory bufferFactory, ResolvableType elementType, MimeType mimeType,\n\t\t\tObject... hints) {\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\t\tif (inputStream instanceof Mono) {\n\t\t\t// single object\n\t\t\treturn Flux.from(inputStream)\n\t\t\t\t\t.map(value -> serialize(value, bufferFactory, elementType));\n\t\t}\n\t\telse {\n\t\t\t// array\n\t\t\tMono<DataBuffer> startArray =\n\t\t\t\t\tMono.just(bufferFactory.wrap(START_ARRAY_BUFFER));\n\t\t\tFlux<DataBuffer> arraySeparators =\n\t\t\t\t\tMono.fromSupplier(() -> bufferFactory.wrap(SEPARATOR_BUFFER)).repeat();\n\t\t\tMono<DataBuffer> endArray =\n\t\t\t\t\tMono.just(bufferFactory.wrap(END_ARRAY_BUFFER));\n\n\t\t\tFlux<DataBuffer> serializedObjects = Flux.from(inputStream)\n\t\t\t\t\t.map(value -> serialize(value, bufferFactory, elementType));\n\n\t\t\tFlux<DataBuffer> array = Flux.zip(serializedObjects, arraySeparators)\n\t\t\t\t\t.flatMap(tuple -> Flux.just(tuple.getT1(), tuple.getT2()));\n\n\t\t\tFlux<DataBuffer> arrayWithoutLastSeparator = array.skipLast(1);\n\n\t\t\treturn Flux.concat(startArray, arrayWithoutLastSeparator, endArray);\n\t\t}\n\t}","id":31157,"modified_method":"@Override\n\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, MimeType mimeType, Object... hints) {\n\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\n\t\tif (inputStream instanceof Mono) {\n\t\t\treturn Flux.from(inputStream).map(value -> encodeValue(value, bufferFactory, elementType));\n\t\t}\n\n\t\tFlux<DataBuffer> array = Flux.from(inputStream)\n\t\t\t\t.flatMap(value ->\n\t\t\t\t\t\tFlux.just(encodeValue(value, bufferFactory, elementType),\n\t\t\t\t\t\t\t\tbufferFactory.wrap(SEPARATOR_BUFFER)));\n\n\t\treturn Flux.concat(Mono.just(bufferFactory.wrap(START_ARRAY_BUFFER)), array.skipLast(1),\n\t\t\t\tMono.just(bufferFactory.wrap(END_ARRAY_BUFFER)));\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private DataBuffer serialize(Object value, DataBufferFactory dataBufferFactory,\n\t\t\tResolvableType type) {\n\t\tTypeFactory typeFactory = this.mapper.getTypeFactory();\n\t\tJavaType javaType = typeFactory.constructType(type.getType());\n\t\tObjectWriter writer = this.mapper.writerFor(javaType);\n\t\tDataBuffer buffer = dataBufferFactory.allocateBuffer();\n\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\ttry {\n\t\t\twriter.writeValue(outputStream, value);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new CodecException(\"Error while writing the data\", e);\n\t\t}\n\t\treturn buffer;\n\t}","id":31158,"modified_method":"private DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory, ResolvableType type) {\n\t\tTypeFactory typeFactory = this.mapper.getTypeFactory();\n\t\tJavaType javaType = typeFactory.constructType(type.getType());\n\t\tObjectWriter writer = this.mapper.writerFor(javaType);\n\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer();\n\t\tOutputStream outputStream = buffer.asOutputStream();\n\n\t\ttry {\n\t\t\twriter.writeValue(outputStream, value);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new CodecException(\"Error while writing the data\", e);\n\t\t}\n\n\t\treturn buffer;\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encode() {\n\t\tFlux<Pojo> source = Flux.just(\n\t\t\t\tnew Pojo(\"foo\", \"bar\"),\n\t\t\t\tnew Pojo(\"foofoo\", \"barbar\"),\n\t\t\t\tnew Pojo(\"foofoofoo\", \"barbarbar\")\n\t\t);\n\n\t\tResolvableType type = ResolvableType.forClass(Pojo.class);\n\t\tFlux<DataBuffer> output =\n\t\t\t\tthis.encoder.encode(source, this.dataBufferFactory, type, null);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"[\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\",\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoo\\\",\\\"bar\\\":\\\"barbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\",\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoofoo\\\",\\\"bar\\\":\\\"barbarbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"]\")\n\t\t\t\t);\n\t}","id":31159,"modified_method":"@Test\n\tpublic void encode() {\n\t\tFlux<Pojo> source = Flux.just(\n\t\t\t\tnew Pojo(\"foo\", \"bar\"),\n\t\t\t\tnew Pojo(\"foofoo\", \"barbar\"),\n\t\t\t\tnew Pojo(\"foofoofoo\", \"barbarbar\")\n\t\t);\n\t\tResolvableType type = ResolvableType.forClass(Pojo.class);\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.bufferFactory, type, null);\n\n\t\tTestSubscriber.subscribe(output)\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"[\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\",\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoo\\\",\\\"bar\\\":\\\"barbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\",\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoofoo\\\",\\\"bar\\\":\\\"barbarbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"]\")\n\t\t\t\t);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encodeWithType() {\n\t\tFlux<ParentClass> source = Flux.just(new Foo(), new Bar());\n\n\t\tResolvableType type = ResolvableType.forClass(ParentClass.class);\n\t\tFlux<DataBuffer> output =\n\t\t\t\tthis.encoder.encode(source, this.dataBufferFactory, type, null);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(stringConsumer(\"[\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"type\\\":\\\"foo\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\",\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"type\\\":\\\"bar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"]\"));\n\t}","id":31160,"modified_method":"@Test\n\tpublic void encodeWithType() {\n\t\tFlux<ParentClass> source = Flux.just(new Foo(), new Bar());\n\t\tResolvableType type = ResolvableType.forClass(ParentClass.class);\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.bufferFactory, type, null);\n\n\t\tTestSubscriber.subscribe(output)\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(stringConsumer(\"[\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"type\\\":\\\"foo\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\",\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"type\\\":\\\"bar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"]\"));\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encode() {\n\t\tFlux<Pojo> source = Flux.just(new Pojo(\"foofoo\", \"barbar\"), new Pojo(\"foofoofoo\", \"barbarbar\"));\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.dataBufferFactory,\n\t\t\t\tResolvableType.forClass(Pojo.class),\n\t\t\t\t\t\tMediaType.APPLICATION_XML);\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertValuesWith(dataBuffer -> {\n\t\t\ttry {\n\t\t\t\tString s = DataBufferTestUtils\n\t\t\t\t\t\t.dumpString(dataBuffer, StandardCharsets.UTF_8);\n\t\t\t\tassertXMLEqual(\"<pojo><bar>barbar<\/bar><foo>foofoo<\/foo><\/pojo>\", s);\n\t\t\t}\n\t\t\tcatch (SAXException | IOException e) {\n\t\t\t\tfail(e.getMessage());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t}\n\t\t});\n\t}","id":31161,"modified_method":"@Test\n\tpublic void encode() {\n\t\tFlux<Pojo> source = Flux.just(new Pojo(\"foofoo\", \"barbar\"), new Pojo(\"foofoofoo\", \"barbarbar\"));\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.bufferFactory,\n\t\t\t\tResolvableType.forClass(Pojo.class),\n\t\t\t\t\t\tMediaType.APPLICATION_XML);\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertValuesWith(dataBuffer -> {\n\t\t\ttry {\n\t\t\t\tString s = DataBufferTestUtils\n\t\t\t\t\t\t.dumpString(dataBuffer, StandardCharsets.UTF_8);\n\t\t\t\tassertXMLEqual(\"<pojo><bar>barbar<\/bar><foo>foofoo<\/foo><\/pojo>\", s);\n\t\t\t}\n\t\t\tcatch (SAXException | IOException e) {\n\t\t\t\tfail(e.getMessage());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t}\n\t\t});\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encode() throws Exception {\n\t\tString s = \"foo\";\n\t\tResource resource = new ByteArrayResource(s.getBytes(StandardCharsets.UTF_8));\n\n\t\tMono<Resource> source = Mono.just(resource);\n\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.dataBufferFactory,\n\t\t\t\tResolvableType.forClass(Resource.class),\n\t\t\t\t\t\tnull);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(stringConsumer(s));\n\n\t}","id":31162,"modified_method":"@Test\n\tpublic void encode() throws Exception {\n\t\tString s = \"foo\";\n\t\tResource resource = new ByteArrayResource(s.getBytes(StandardCharsets.UTF_8));\n\n\t\tMono<Resource> source = Mono.just(resource);\n\n\t\tFlux<DataBuffer> output = this.encoder.encode(source, this.bufferFactory,\n\t\t\t\tResolvableType.forClass(Resource.class),\n\t\t\t\t\t\tnull);\n\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertComplete()\n\t\t\t\t.assertValuesWith(stringConsumer(s));\n\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encodeMultilineString() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tFlux<String> source = Flux.just(\"foo\\nbar\", \"foo\\nbaz\");\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.dataBufferFactory,\n\t\t\t\tResolvableType.forClass(String.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"data:foo\\ndata:bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass()),\n\t\t\t\t\t\tstringConsumer(\"data:foo\\ndata:baz\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","id":31163,"modified_method":"@Test\n\tpublic void encodeMultilineString() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tFlux<String> source = Flux.just(\"foo\\nbar\", \"foo\\nbaz\");\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.bufferFactory,\n\t\t\t\tResolvableType.forClass(String.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"data:foo\\ndata:bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass()),\n\t\t\t\t\t\tstringConsumer(\"data:foo\\ndata:baz\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encodeServerSentEvent() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tSseEvent event = new SseEvent();\n\t\tevent.setId(\"c42\");\n\t\tevent.setName(\"foo\");\n\t\tevent.setComment(\"bla\\nbla bla\\nbla bla bla\");\n\t\tevent.setReconnectTime(123L);\n\t\tMono<SseEvent> source = Mono.just(event);\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.dataBufferFactory,\n\t\t\t\t\t\tResolvableType.forClass(SseEvent.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\n\t\t\t\t\t\t\t\t\"id:c42\\n\" +\n\t\t\t\t\t\t\t\t\"event:foo\\n\" +\n\t\t\t\t\t\t\t\t\"retry:123\\n\" +\n\t\t\t\t\t\t\t\t\":bla\\n:bla bla\\n:bla bla bla\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","id":31164,"modified_method":"@Test\n\tpublic void encodeServerSentEvent() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tSseEvent event = new SseEvent();\n\t\tevent.setId(\"c42\");\n\t\tevent.setName(\"foo\");\n\t\tevent.setComment(\"bla\\nbla bla\\nbla bla bla\");\n\t\tevent.setReconnectTime(123L);\n\t\tMono<SseEvent> source = Mono.just(event);\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.bufferFactory,\n\t\t\t\t\t\tResolvableType.forClass(SseEvent.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\n\t\t\t\t\t\t\t\t\"id:c42\\n\" +\n\t\t\t\t\t\t\t\t\"event:foo\\n\" +\n\t\t\t\t\t\t\t\t\"retry:123\\n\" +\n\t\t\t\t\t\t\t\t\":bla\\n:bla bla\\n:bla bla bla\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encodeString() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tFlux<String> source = Flux.just(\"foo\", \"bar\");\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.dataBufferFactory,\n\t\t\t\tResolvableType.forClass(String.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"data:foo\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass()),\n\t\t\t\t\t\tstringConsumer(\"data:bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","id":31165,"modified_method":"@Test\n\tpublic void encodeString() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tFlux<String> source = Flux.just(\"foo\", \"bar\");\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.bufferFactory,\n\t\t\t\tResolvableType.forClass(String.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"data:foo\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass()),\n\t\t\t\t\t\tstringConsumer(\"data:bar\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void encodePojo() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tFlux<Pojo> source = Flux.just(new Pojo(\"foofoo\", \"barbar\"), new Pojo(\"foofoofoo\", \"barbarbar\"));\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.dataBufferFactory,\n\t\t\t\t\t\tResolvableType.forClass(Pojo.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"data:\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoo\\\",\\\"bar\\\":\\\"barbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass()),\n\t\t\t\t\t\tstringConsumer(\"data:\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoofoo\\\",\\\"bar\\\":\\\"barbarbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","id":31166,"modified_method":"@Test\n\tpublic void encodePojo() {\n\t\tSseEventEncoder encoder = new SseEventEncoder(Arrays.asList(new JacksonJsonEncoder()));\n\t\tFlux<Pojo> source = Flux.just(new Pojo(\"foofoo\", \"barbar\"), new Pojo(\"foofoofoo\", \"barbarbar\"));\n\t\tFlux<DataBuffer> output = encoder.encode(source, this.bufferFactory,\n\t\t\t\t\t\tResolvableType.forClass(Pojo.class), new MimeType(\"text\", \"event-stream\"));\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertNoError()\n\t\t\t\t.assertValuesWith(\n\t\t\t\t\t\tstringConsumer(\"data:\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoo\\\",\\\"bar\\\":\\\"barbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass()),\n\t\t\t\t\t\tstringConsumer(\"data:\"),\n\t\t\t\t\t\tstringConsumer(\"{\\\"foo\\\":\\\"foofoofoo\\\",\\\"bar\\\":\\\"barbarbar\\\"}\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tstringConsumer(\"\\n\"),\n\t\t\t\t\t\tb -> assertEquals(FlushingDataBuffer.class, b.getClass())\n\t\t\t\t);\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void write() throws InterruptedException {\n\t\tFlux<String> output = Flux.from(\n\t\t\t\tthis.encoder.encode(Flux.just(\"foo\"), this.dataBufferFactory, null, null))\n\t\t\t\t\t\t.map(chunk -> {\n\t\t\t\t\t\t\tbyte[] b = new byte[chunk.readableByteCount()];\n\t\t\t\t\t\t\tchunk.read(b);\n\t\t\t\t\t\t\tDataBufferUtils.release(chunk);\n\t\t\t\t\t\t\treturn new String(b, StandardCharsets.UTF_8);\n\t\t});\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertValues(\"foo\");\n\t}","id":31167,"modified_method":"@Test\n\tpublic void write() throws InterruptedException {\n\t\tFlux<String> output = Flux.from(\n\t\t\t\tthis.encoder.encode(Flux.just(\"foo\"), this.bufferFactory, null, null))\n\t\t\t\t\t\t.map(chunk -> {\n\t\t\t\t\t\t\tbyte[] b = new byte[chunk.readableByteCount()];\n\t\t\t\t\t\t\tchunk.read(b);\n\t\t\t\t\t\t\tDataBufferUtils.release(chunk);\n\t\t\t\t\t\t\treturn new String(b, StandardCharsets.UTF_8);\n\t\t});\n\t\tTestSubscriber\n\t\t\t\t.subscribe(output)\n\t\t\t\t.assertValues(\"foo\");\n\t}","commit_id":"7af7a55ede0cba513836032ff7f12be46b316633","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Subclasses must implement this method to actually render the view.\n\t * @param renderAttributes combined output Map (never {@code null}),\n\t * with dynamic values taking precedence over static attributes\n\t * @param exchange current exchange\n\t */\n\tprotected abstract Flux<DataBuffer> renderInternal(Map<String, Object> renderAttributes,\n\t\t\tServerWebExchange exchange);","id":31168,"modified_method":"/**\n\t * Subclasses must implement this method to actually render the view.\n\t * @param renderAttributes combined output Map (never {@code null}),\n\t * with dynamic values taking precedence over static attributes\n\t * @param exchange current exchange\n\t * @return {@code Mono} to represent when and if rendering succeeds\n\t */\n\tprotected abstract Mono<Void> renderInternal(Map<String, Object> renderAttributes,\n\t\t\tServerWebExchange exchange);","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Prepare the model to render.\n\t * @param result the result from handler execution\n\t * @param contentType the content type selected to render with which should\n\t * match one of the {@link #getSupportedMediaTypes() supported media types}.\n\t * @param exchange the current exchange\n\t * @return\n\t */\n\t@Override\n\tpublic Flux<DataBuffer> render(HandlerResult result, MediaType contentType,\n\t\t\tServerWebExchange exchange) {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Rendering view with model \" + result.getModel());\n\t\t}\n\n\t\tif (contentType != null) {\n\t\t\texchange.getResponse().getHeaders().setContentType(contentType);\n\t\t}\n\n\t\tMap<String, Object> mergedModel = getModelAttributes(result, exchange);\n\t\treturn renderInternal(mergedModel, exchange);\n\t}","id":31169,"modified_method":"/**\n\t * Prepare the model to render.\n\t * @param result the result from handler execution\n\t * @param contentType the content type selected to render with which should\n\t * match one of the {@link #getSupportedMediaTypes() supported media types}.\n\t * @param exchange the current exchange\n\t * @return {@code Mono} to represent when and if rendering succeeds\n\t */\n\t@Override\n\tpublic Mono<Void> render(HandlerResult result, MediaType contentType,\n\t\t\tServerWebExchange exchange) {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Rendering view with model \" + result.getModel());\n\t\t}\n\n\t\tif (contentType != null) {\n\t\t\texchange.getResponse().getHeaders().setContentType(contentType);\n\t\t}\n\n\t\tMap<String, Object> mergedModel = getModelAttributes(result, exchange);\n\t\treturn renderInternal(mergedModel, exchange);\n\t}","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected Flux<DataBuffer> renderInternal(Map<String, Object> renderAttributes, ServerWebExchange exchange) {\n\t\t// Expose all standard FreeMarker hash models.\n\t\tSimpleHash freeMarkerModel = getTemplateModel(renderAttributes, exchange);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rendering FreeMarker template [\" + getUrl() + \"].\");\n\t\t}\n\t\tLocale locale = Locale.getDefault(); // TODO\n\t\tDataBuffer dataBuffer = getBufferAllocator().allocateBuffer();\n\t\ttry {\n\t\t\tWriter writer = new OutputStreamWriter(dataBuffer.asOutputStream());\n\t\t\tgetTemplate(locale).process(freeMarkerModel, writer);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tString message = \"Could not load FreeMarker template for URL [\" + getUrl() + \"]\";\n\t\t\treturn Flux.error(new IllegalStateException(message, ex));\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn Flux.error(ex);\n\t\t}\n\t\treturn Flux.just(dataBuffer);\n\t}","id":31170,"modified_method":"@Override\n\tprotected Mono<Void> renderInternal(Map<String, Object> renderAttributes, ServerWebExchange exchange) {\n\t\t// Expose all standard FreeMarker hash models.\n\t\tSimpleHash freeMarkerModel = getTemplateModel(renderAttributes, exchange);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rendering FreeMarker template [\" + getUrl() + \"].\");\n\t\t}\n\t\tLocale locale = Locale.getDefault(); // TODO\n\t\tDataBuffer dataBuffer = getBufferAllocator().allocateBuffer();\n\t\ttry {\n\t\t\tWriter writer = new OutputStreamWriter(dataBuffer.asOutputStream());\n\t\t\tgetTemplate(locale).process(freeMarkerModel, writer);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tString message = \"Could not load FreeMarker template for URL [\" + getUrl() + \"]\";\n\t\t\treturn Mono.error(new IllegalStateException(message, ex));\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t\treturn exchange.getResponse().writeWith(Flux.just(dataBuffer));\n\t}","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.context = new GenericApplicationContext();\n\t\tthis.context.refresh();\n\n\t\tFreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n\t\tconfigurer.setPreferFileSystemAccess(false);\n\t\tconfigurer.setTemplateLoaderPath(TEMPLATE_PATH);\n\t\tconfigurer.setResourceLoader(this.context);\n\t\tthis.freeMarkerConfig = configurer.createConfiguration();\n\n\t\tFreeMarkerView fv = new FreeMarkerView();\n\t\tfv.setApplicationContext(this.context);\n\n\t\tMockServerHttpRequest request = new MockServerHttpRequest(HttpMethod.GET, new URI(\"/path\"));\n\t\tMockServerHttpResponse response = new MockServerHttpResponse();\n\t\tWebSessionManager manager = new DefaultWebSessionManager();\n\t\tthis.exchange = new DefaultServerWebExchange(request, response, manager);\n\t}","id":31171,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.context = new GenericApplicationContext();\n\t\tthis.context.refresh();\n\n\t\tFreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n\t\tconfigurer.setPreferFileSystemAccess(false);\n\t\tconfigurer.setTemplateLoaderPath(TEMPLATE_PATH);\n\t\tconfigurer.setResourceLoader(this.context);\n\t\tthis.freeMarkerConfig = configurer.createConfiguration();\n\n\t\tFreeMarkerView fv = new FreeMarkerView();\n\t\tfv.setApplicationContext(this.context);\n\n\t\tMockServerHttpRequest request = new MockServerHttpRequest(HttpMethod.GET, new URI(\"/path\"));\n\t\tthis.response = new MockServerHttpResponse();\n\t\tWebSessionManager manager = new DefaultWebSessionManager();\n\t\tthis.exchange = new DefaultServerWebExchange(request, response, manager);\n\t}","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void render() throws Exception {\n\t\tFreeMarkerView view = new FreeMarkerView();\n\t\tview.setConfiguration(this.freeMarkerConfig);\n\t\tview.setUrl(\"test.ftl\");\n\n\t\tModelMap model = new ExtendedModelMap();\n\t\tmodel.addAttribute(\"hello\", \"hi FreeMarker\");\n\t\tHandlerResult result = new HandlerResult(new Object(), \"\", ResolvableType.NONE, model);\n\t\tFlux<DataBuffer> flux = view.render(result, null, this.exchange);\n\n\t\tTestSubscriber<DataBuffer> subscriber = new TestSubscriber<>();\n\t\tsubscriber.bindTo(flux).assertValuesWith(dataBuffer ->\n\t\t\t\t\tassertEquals(\"<html><body>hi FreeMarker<\/body><\/html>\", asString(dataBuffer)));\n\t}","id":31172,"modified_method":"@Test\n\tpublic void render() throws Exception {\n\t\tFreeMarkerView view = new FreeMarkerView();\n\t\tview.setConfiguration(this.freeMarkerConfig);\n\t\tview.setUrl(\"test.ftl\");\n\n\t\tModelMap model = new ExtendedModelMap();\n\t\tmodel.addAttribute(\"hello\", \"hi FreeMarker\");\n\t\tHandlerResult result = new HandlerResult(new Object(), \"\", ResolvableType.NONE, model);\n\t\tview.render(result, null, this.exchange);\n\n\t\tTestSubscriber<DataBuffer> subscriber = new TestSubscriber<>();\n\t\tsubscriber.bindTo(this.response.getBody()).assertValuesWith(dataBuffer ->\n\t\t\t\t\tassertEquals(\"<html><body>hi FreeMarker<\/body><\/html>\", asString(dataBuffer)));\n\t}","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tprotected Flux<DataBuffer> renderInternal(Map<String, Object> attributes, ServerWebExchange exchange) {\n\t\t\treturn Flux.empty();\n\t\t}","id":31173,"modified_method":"@Override\n\t\tprotected Mono<Void> renderInternal(Map<String, Object> attributes, ServerWebExchange exchange) {\n\t\t\treturn Mono.empty();\n\t\t}","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tMono<Object> valueMono;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType = result.getReturnValueType();\n\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Mono.class)) {\n\t\t\tOptional<Object> optionalValue = result.getReturnValue();\n\t\t\tif (optionalValue.isPresent()) {\n\t\t\t\tMono<?> converted = this.conversionService.convert(optionalValue.get(), Mono.class);\n\t\t\t\tvalueMono = converted.map(o -> o);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueMono = Mono.empty();\n\t\t\t}\n\t\t\telementType = returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tvalueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\telementType = returnType;\n\t\t}\n\n\t\tMono<Object> viewMono;\n\t\tif (isViewReturnType(result, elementType)) {\n\t\t\tviewMono = valueMono.otherwiseIfEmpty(selectDefaultViewName(exchange, result));\n\t\t}\n\t\telse {\n\t\t\tviewMono = valueMono.map(value -> updateModel(result, value))\n\t\t\t\t\t.defaultIfEmpty(result.getModel())\n\t\t\t\t\t.then(model -> selectDefaultViewName(exchange, result));\n\t\t}\n\n\t\treturn viewMono.then(returnValue -> {\n\t\t\tif (returnValue instanceof View) {\n\t\t\t\tFlux<DataBuffer> body = ((View) returnValue).render(result, null, exchange);\n\t\t\t\treturn exchange.getResponse().writeWith(body);\n\t\t\t}\n\t\t\telse if (returnValue instanceof CharSequence) {\n\t\t\t\tString viewName = returnValue.toString();\n\t\t\t\tLocale locale = Locale.getDefault(); // TODO\n\t\t\t\treturn Flux.fromIterable(getViewResolvers())\n\t\t\t\t\t\t.concatMap(resolver -> resolver.resolveViewName(viewName, locale))\n\t\t\t\t\t\t.next()\n\t\t\t\t\t\t.otherwiseIfEmpty(handleUnresolvedViewName(viewName))\n\t\t\t\t\t\t.then(view -> {\n\t\t\t\t\t\t\tFlux<DataBuffer> body = view.render(result, null, exchange);\n\t\t\t\t\t\t\treturn exchange.getResponse().writeWith(body);\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Should not happen\n\t\t\t\treturn Mono.error(new IllegalStateException(\"Unexpected return value\"));\n\t\t\t}\n\t\t});\n\t}","id":31174,"modified_method":"@Override\n\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tMono<Object> valueMono;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType = result.getReturnValueType();\n\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Mono.class)) {\n\t\t\tOptional<Object> optionalValue = result.getReturnValue();\n\t\t\tif (optionalValue.isPresent()) {\n\t\t\t\tMono<?> converted = this.conversionService.convert(optionalValue.get(), Mono.class);\n\t\t\t\tvalueMono = converted.map(o -> o);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueMono = Mono.empty();\n\t\t\t}\n\t\t\telementType = returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tvalueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\telementType = returnType;\n\t\t}\n\n\t\tMono<Object> viewMono;\n\t\tif (isViewReturnType(result, elementType)) {\n\t\t\tviewMono = valueMono.otherwiseIfEmpty(selectDefaultViewName(exchange, result));\n\t\t}\n\t\telse {\n\t\t\tviewMono = valueMono.map(value -> updateModel(result, value))\n\t\t\t\t\t.defaultIfEmpty(result.getModel())\n\t\t\t\t\t.then(model -> selectDefaultViewName(exchange, result));\n\t\t}\n\n\t\treturn viewMono.then(returnValue -> {\n\t\t\tif (returnValue instanceof View) {\n\t\t\t\treturn ((View) returnValue).render(result, null, exchange);\n\t\t\t}\n\t\t\telse if (returnValue instanceof CharSequence) {\n\t\t\t\tString viewName = returnValue.toString();\n\t\t\t\tLocale locale = Locale.getDefault(); // TODO\n\t\t\t\treturn Flux.fromIterable(getViewResolvers())\n\t\t\t\t\t\t.concatMap(resolver -> resolver.resolveViewName(viewName, locale))\n\t\t\t\t\t\t.next()\n\t\t\t\t\t\t.otherwiseIfEmpty(handleUnresolvedViewName(viewName))\n\t\t\t\t\t\t.then(view -> view.render(result, null, exchange));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Should not happen\n\t\t\t\treturn Mono.error(new IllegalStateException(\"Unexpected return value\"));\n\t\t\t}\n\t\t});\n\t}","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic Flux<DataBuffer> render(HandlerResult result, MediaType mediaType, ServerWebExchange exchange) {\n\t\t\tString value = this.name + \": \" + result.getModel().toString();\n\t\t\tassertNotNull(value);\n\t\t\treturn Flux.just(asDataBuffer(value));\n\t\t}","id":31175,"modified_method":"@Override\n\t\tpublic Mono<Void> render(HandlerResult result, MediaType mediaType, ServerWebExchange exchange) {\n\t\t\tString value = this.name + \": \" + result.getModel().toString();\n\t\t\tassertNotNull(value);\n\t\t\tServerHttpResponse response = exchange.getResponse();\n\t\t\treturn response.writeWith(Flux.just(asDataBuffer(value)));\n\t\t}","commit_id":"a37b2e3a847daac1bebd3bdf0f556fcb3d5b9d08","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected boolean isJSPCompiler(String subject, String action) {\n\t\tfor (int i = 1;; i++) {\n\t\t\tClass<?> callerClass = Reflection.getCallerClass(i);\n\n\t\t\tif (callerClass == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString callerClassName = callerClass.getName();\n\n\t\t\tif (!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_JASPER_COMPILER) &&\n\t\t\t\t!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_JASPER_XMLPARSER) &&\n\t\t\t\t!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_NAMING_RESOURCES) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_DEFAULT_INSTANCE_MANAGER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_JASPER_LOADER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_TAG_HANDLER_POOL)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClassLoader callerClassLoader = PACLClassLoaderUtil.getClassLoader(\n\t\t\t\tcallerClass);\n\n\t\t\tif (callerClassLoader != _commonClassLoader) {\n\t\t\t\tif (Validator.isNotNull(action)) {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\tcallerClassName + \" to \" + action + \" \" + subject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\tcallerClassName + \" to \" + subject);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tif (Validator.isNotNull(action)) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\" to \" + action + \" \" + subject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\" to \" + subject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":31176,"modified_method":"protected boolean isJSPCompiler(String subject, String actions) {\n\t\tfor (int i = 1;; i++) {\n\t\t\tClass<?> callerClass = Reflection.getCallerClass(i);\n\n\t\t\tif (callerClass == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString callerClassName = callerClass.getName();\n\n\t\t\tif (!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_JASPER_COMPILER) &&\n\t\t\t\t!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_JASPER_XMLPARSER) &&\n\t\t\t\t!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_NAMING_RESOURCES) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_DEFAULT_INSTANCE_MANAGER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_JASPER_LOADER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_TAG_HANDLER_POOL)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClassLoader callerClassLoader = PACLClassLoaderUtil.getClassLoader(\n\t\t\t\tcallerClass);\n\n\t\t\tif (callerClassLoader != _commonClassLoader) {\n\t\t\t\tif (Validator.isNotNull(actions)) {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\tcallerClassName + \" to \" + actions + \" \" + subject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\tcallerClassName + \" to \" + subject);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tif (Validator.isNotNull(actions)) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\" to \" + actions + \" \" + subject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\" to \" + subject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void logReflect(Class<?> callerClass, int frame) {\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Allow frame \" + frame + \" with caller \" + callerClass +\n\t\t\t\t\t\" to reflect\");\n\t\t}\n\t}","id":31177,"modified_method":"protected void logReflect(Class<?> callerClass, int frame) {\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Allowing frame \" + frame + \" with caller \" + callerClass +\n\t\t\t\t\t\" to reflect\");\n\t\t}\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasReflect(String name, String action) {\n\n\t\t// JSP compiler\n\n\t\tif (isJSPCompiler(name, action)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Prefecth the necessary caller classes\n\n\t\tClass<?> callerClass7 = Reflection.getCallerClass(7);\n\t\tClass<?> callerClass8 = Reflection.getCallerClass(8);\n\t\tClass<?> callerClass9 = Reflection.getCallerClass(9);\n\t\tClass<?> callerClass10 = Reflection.getCallerClass(10);\n\n\t\t// java.lang.Class\n\n\t\tif ((callerClass7.getEnclosingClass() == Class.class) &&\n\t\t\t(callerClass8 == AccessController.class)) {\n\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tStackTraceElement[] stackTraceElements =\n\t\t\t\tcurrentThread.getStackTrace();\n\n\t\t\tStackTraceElement stackTraceElement = stackTraceElements[8];\n\n\t\t\tString methodName = stackTraceElement.getMethodName();\n\n\t\t\tif (methodName.equals(_METHOD_NAME_DO_PRIVILEGED)) {\n\t\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// java.lang.Thread\n\n\t\tif ((callerClass9.getEnclosingClass() == Thread.class) &&\n\t\t\t(callerClass10 == AccessController.class)) {\n\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tStackTraceElement[] stackTraceElements =\n\t\t\t\tcurrentThread.getStackTrace();\n\n\t\t\tStackTraceElement stackTraceElement = stackTraceElements[10];\n\n\t\t\tString methodName = stackTraceElement.getMethodName();\n\n\t\t\tif (methodName.equals(_METHOD_NAME_DO_PRIVILEGED)) {\n\t\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// org.springframework.util.ReflectionUtils\n\n\t\tif (callerClass7 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (callerClass9 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reject\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Rejecting call stack:\");\n\n\t\t\tfor (int i = 5; i < 11; i++) {\n\t\t\t\t_log.debug(\"Frame \" + i + \" \" + Reflection.getCallerClass(i));\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":31178,"modified_method":"protected boolean hasReflect(String name, String actions) {\n\n\t\t// JSP compiler\n\n\t\tif (isJSPCompiler(name, actions)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Prefecth the necessary caller classes\n\n\t\tClass<?> callerClass7 = Reflection.getCallerClass(7);\n\t\tClass<?> callerClass8 = Reflection.getCallerClass(8);\n\t\tClass<?> callerClass9 = Reflection.getCallerClass(9);\n\t\tClass<?> callerClass10 = Reflection.getCallerClass(10);\n\n\t\t// java.lang.Class\n\n\t\tif ((callerClass7.getEnclosingClass() == Class.class) &&\n\t\t\t(callerClass8 == AccessController.class)) {\n\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tStackTraceElement[] stackTraceElements =\n\t\t\t\tcurrentThread.getStackTrace();\n\n\t\t\tStackTraceElement stackTraceElement = stackTraceElements[8];\n\n\t\t\tString methodName = stackTraceElement.getMethodName();\n\n\t\t\tif (methodName.equals(_METHOD_NAME_DO_PRIVILEGED)) {\n\t\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// java.lang.Thread\n\n\t\tif ((callerClass9.getEnclosingClass() == Thread.class) &&\n\t\t\t(callerClass10 == AccessController.class)) {\n\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tStackTraceElement[] stackTraceElements =\n\t\t\t\tcurrentThread.getStackTrace();\n\n\t\t\tStackTraceElement stackTraceElement = stackTraceElements[10];\n\n\t\t\tString methodName = stackTraceElement.getMethodName();\n\n\t\t\tif (methodName.equals(_METHOD_NAME_DO_PRIVILEGED)) {\n\t\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// org.springframework.util.ReflectionUtils\n\n\t\tif (callerClass7 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (callerClass9 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reject\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Rejecting call stack:\");\n\n\t\t\tfor (int i = 5; i < 11; i++) {\n\t\t\t\t_log.debug(\"Frame \" + i + \" \" + Reflection.getCallerClass(i));\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addPermission(\n\t\tList<Permission> permissions, String path, String action) {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Allowing \" + action + \" on \" + path);\n\t\t}\n\n\t\tPermission permission = new FilePermission(path, action);\n\n\t\tpermissions.add(permission);\n\t}","id":31179,"modified_method":"protected void addPermission(\n\t\tList<Permission> permissions, String path, String actions) {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Allowing \" + actions + \" on \" + path);\n\t\t}\n\n\t\tPermission permission = new FilePermission(path, actions);\n\n\t\tpermissions.add(permission);\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<Permission> getPermissions(String key, String action) {\n\t\tList<Permission> permissions = new CopyOnWriteArrayList<Permission>();\n\n\t\tString value = getProperty(key);\n\n\t\tif (value != null) {\n\t\t\tString[] paths = StringUtil.split(value);\n\n\t\t\tif (value.contains(\"${comma}\")) {\n\t\t\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\t\t\tpaths[i] = StringUtil.replace(\n\t\t\t\t\t\tpaths[i], \"${comma}\", StringPool.COMMA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String path : paths) {\n\t\t\t\taddPermission(permissions, path, action);\n\t\t\t}\n\t\t}\n\n\t\t// Plugin can do anything, except execute, in its own work folder\n\n\t\tString pathContext = ContextPathUtil.getContextPath(\n\t\t\tPropsValues.PORTAL_CTX);\n\n\t\tServletContext servletContext = ServletContextPool.get(pathContext);\n\n\t\tif (!action.equals(FILE_PERMISSION_ACTION_EXECUTE) &&\n\t\t\t(_workDir != null)) {\n\n\t\t\taddPermission(permissions, _workDir, action);\n\t\t\taddPermission(permissions, _workDir + \"/-\", action);\n\n\t\t\tif (servletContext != null) {\n\t\t\t\tFile tempDir = (File)servletContext.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_SERVLET_CONTEXT_TEMPDIR);\n\n\t\t\t\tString tempDirAbsolutePath = tempDir.getAbsolutePath();\n\n\t\t\t\tif (action.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\t\t\taddPermission(permissions, tempDirAbsolutePath, action);\n\t\t\t\t}\n\n\t\t\t\taddPermission(permissions, tempDirAbsolutePath + \"/-\", action);\n\t\t\t}\n\t\t}\n\n\t\tif (!action.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\treturn permissions;\n\t\t}\n\n\t\tList<String> paths = new UniqueList<String>();\n\n\t\t// JDK\n\n\t\t// There may be JARs in the system library that are symlinked. We must\n\t\t// include their canonical paths or they will fail permission checks.\n\n\t\ttry {\n\t\t\tFile file = new File(System.getProperty(\"java.home\") + \"/lib\");\n\n\t\t\taddCanonicalPaths(paths, file);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(ioe, ioe);\n\t\t}\n\n\t\t// Shared libs\n\n\t\tpaths.add(_globalSharedLibDir + \"-\");\n\n\t\t// Plugin\n\n\t\tpaths.add(_rootDir + \"-\");\n\n\t\t// Portal\n\n\t\tif (!_portalDir.equals(_rootDir)) {\n\t\t\tpaths.add(_portalDir + \"html/common/-\");\n\t\t\tpaths.add(_portalDir + \"html/taglib/-\");\n\t\t\tpaths.add(_portalDir + \"localhost/html/common/-\");\n\t\t\tpaths.add(_portalDir + \"localhost/html/taglib/-\");\n\t\t\tpaths.add(_portalDir + \"localhost/WEB-INF/tld/-\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/classes/java/-\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/classes/javax/-\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/classes/org/apache/-\");\n\t\t\tpaths.add(\n\t\t\t\t_portalDir + \"WEB-INF/classes/META-INF/services/\" +\n\t\t\t\t\t\"javax.el.ExpressionFactory\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/tld/-\");\n\t\t}\n\n\t\tfor (String path : paths) {\n\t\t\taddPermission(permissions, path, action);\n\t\t}\n\n\t\treturn permissions;\n\t}","id":31180,"modified_method":"protected List<Permission> getPermissions(String key, String actions) {\n\t\tList<Permission> permissions = new CopyOnWriteArrayList<Permission>();\n\n\t\tString value = getProperty(key);\n\n\t\tif (value != null) {\n\t\t\tString[] paths = StringUtil.split(value);\n\n\t\t\tif (value.contains(\"${comma}\")) {\n\t\t\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\t\t\tpaths[i] = StringUtil.replace(\n\t\t\t\t\t\tpaths[i], \"${comma}\", StringPool.COMMA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String path : paths) {\n\t\t\t\taddPermission(permissions, path, actions);\n\t\t\t}\n\t\t}\n\n\t\t// Plugin can do anything, except execute, in its own work folder\n\n\t\tString pathContext = ContextPathUtil.getContextPath(\n\t\t\tPropsValues.PORTAL_CTX);\n\n\t\tServletContext servletContext = ServletContextPool.get(pathContext);\n\n\t\tif (!actions.equals(FILE_PERMISSION_ACTION_EXECUTE) &&\n\t\t\t(_workDir != null)) {\n\n\t\t\taddPermission(permissions, _workDir, actions);\n\t\t\taddPermission(permissions, _workDir + \"/-\", actions);\n\n\t\t\tif (servletContext != null) {\n\t\t\t\tFile tempDir = (File)servletContext.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_SERVLET_CONTEXT_TEMPDIR);\n\n\t\t\t\tString tempDirAbsolutePath = tempDir.getAbsolutePath();\n\n\t\t\t\tif (actions.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\t\t\taddPermission(permissions, tempDirAbsolutePath, actions);\n\t\t\t\t}\n\n\t\t\t\taddPermission(permissions, tempDirAbsolutePath + \"/-\", actions);\n\t\t\t}\n\t\t}\n\n\t\tif (!actions.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\treturn permissions;\n\t\t}\n\n\t\tList<String> paths = new UniqueList<String>();\n\n\t\t// JDK\n\n\t\t// There may be JARs in the system library that are symlinked. We must\n\t\t// include their canonical paths or they will fail permission checks.\n\n\t\ttry {\n\t\t\tFile file = new File(System.getProperty(\"java.home\") + \"/lib\");\n\n\t\t\taddCanonicalPaths(paths, file);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(ioe, ioe);\n\t\t}\n\n\t\t// Shared libs\n\n\t\tpaths.add(_globalSharedLibDir + \"-\");\n\n\t\t// Plugin\n\n\t\tpaths.add(_rootDir + \"-\");\n\n\t\t// Portal\n\n\t\tif (!_portalDir.equals(_rootDir)) {\n\t\t\tpaths.add(_portalDir + \"html/common/-\");\n\t\t\tpaths.add(_portalDir + \"html/taglib/-\");\n\t\t\tpaths.add(_portalDir + \"localhost/html/common/-\");\n\t\t\tpaths.add(_portalDir + \"localhost/html/taglib/-\");\n\t\t\tpaths.add(_portalDir + \"localhost/WEB-INF/tld/-\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/classes/java/-\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/classes/javax/-\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/classes/org/apache/-\");\n\t\t\tpaths.add(\n\t\t\t\t_portalDir + \"WEB-INF/classes/META-INF/services/\" +\n\t\t\t\t\t\"javax.el.ExpressionFactory\");\n\t\t\tpaths.add(_portalDir + \"WEB-INF/tld/-\");\n\t\t}\n\n\t\tfor (String path : paths) {\n\t\t\taddPermission(permissions, path, actions);\n\t\t}\n\n\t\treturn permissions;\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void logCreateClassLoader(Class<?> callerClass, int frame) {\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Allow frame \" + frame + \" with caller \" + callerClass +\n\t\t\t\t\t\" to create a class loader\");\n\t\t}\n\t}","id":31181,"modified_method":"protected void logCreateClassLoader(Class<?> callerClass, int frame) {\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Allowing frame \" + frame + \" with caller \" + callerClass +\n\t\t\t\t\t\" to create a class loader\");\n\t\t}\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initClassLoaderReferenceIds() {\n\t\t_classLoaderReferenceIds = getPropertySet(\n\t\t\t\"security-manager-class-loader-reference-ids\");\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tSet<String> referenceIds = new TreeSet<String>(\n\t\t\t\t_classLoaderReferenceIds);\n\n\t\t\tfor (String referenceId : referenceIds) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Allow access to class loader for reference \" +\n\t\t\t\t\t\treferenceId);\n\t\t\t}\n\t\t}\n\t}","id":31182,"modified_method":"protected void initClassLoaderReferenceIds() {\n\t\t_classLoaderReferenceIds = getPropertySet(\n\t\t\t\"security-manager-class-loader-reference-ids\");\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tSet<String> referenceIds = new TreeSet<String>(\n\t\t\t\t_classLoaderReferenceIds);\n\n\t\t\tfor (String referenceId : referenceIds) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Allowing access to class loader for reference \" +\n\t\t\t\t\t\treferenceId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasGetClassLoader(String name) {\n\t\tint pos = name.indexOf(StringPool.PERIOD);\n\n\t\tif (pos != -1) {\n\t\t\tString referenceId = name.substring(pos + 1);\n\n\t\t\tif (_classLoaderReferenceIds.contains(referenceId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tClass<?> callerClass6 = Reflection.getCallerClass(6);\n\t\tClass<?> callerClass7 = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tcallerClass7 = Reflection.getCallerClass(7);\n\n\t\t\t_log.debug(\n\t\t\t\tcallerClass7.getName() +\n\t\t\t\t\t\" is attempting to get the class loader via \" +\n\t\t\t\t\t\tcallerClass6.getName());\n\t\t}\n\n\t\tif (callerClass6 == Class.class) {\n\t\t}\n\t\telse if (callerClass6 == ClassLoader.class) {\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tStackTraceElement[] stackTraceElements =\n\t\t\t\tcurrentThread.getStackTrace();\n\n\t\t\tStackTraceElement stackTraceElement = stackTraceElements[6];\n\n\t\t\tString methodName = stackTraceElement.getMethodName();\n\n\t\t\tif (methodName.equals(_METHOD_NAME_GET_SYSTEM_CLASS_LOADER)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allow \" + callerClass7.getName() +\n\t\t\t\t\t\t\t\" to access the system class loader\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (callerClass6 == Thread.class) {\n\t\t\tClassLoader contextClassLoader =\n\t\t\t\tPACLClassLoaderUtil.getContextClassLoader();\n\n\t\t\tif (isSharedClassLoader(contextClassLoader) ||\n\t\t\t\tisLocalClassLoader(contextClassLoader)) {\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tcallerClass7 = Reflection.getCallerClass(7);\n\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allow \" + callerClass7.getName() +\n\t\t\t\t\t\t\t\" to access the context class loader\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":31183,"modified_method":"protected boolean hasGetClassLoader(String name) {\n\t\tint pos = name.indexOf(StringPool.PERIOD);\n\n\t\tif (pos != -1) {\n\t\t\tString referenceId = name.substring(pos + 1);\n\n\t\t\tif (_classLoaderReferenceIds.contains(referenceId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tClass<?> callerClass6 = Reflection.getCallerClass(6);\n\t\tClass<?> callerClass7 = Reflection.getCallerClass(7);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\tcallerClass7.getName() +\n\t\t\t\t\t\" is attempting to get the class loader via \" +\n\t\t\t\t\t\tcallerClass6.getName());\n\t\t}\n\n\t\tif (callerClass6 == Class.class) {\n\t\t}\n\t\telse if (callerClass6 == ClassLoader.class) {\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tStackTraceElement[] stackTraceElements =\n\t\t\t\tcurrentThread.getStackTrace();\n\n\t\t\tStackTraceElement stackTraceElement = stackTraceElements[6];\n\n\t\t\tString methodName = stackTraceElement.getMethodName();\n\n\t\t\tif (methodName.equals(_METHOD_NAME_GET_SYSTEM_CLASS_LOADER)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Allowing \" + callerClass7.getName() +\n\t\t\t\t\t\t\t\" to access the system class loader\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (callerClass6 == Thread.class) {\n\t\t\tClassLoader contextClassLoader =\n\t\t\t\tPACLClassLoaderUtil.getContextClassLoader();\n\n\t\t\tif (isSharedClassLoader(contextClassLoader) ||\n\t\t\t\tisLocalClassLoader(contextClassLoader)) {\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Allowing \" + callerClass7.getName() +\n\t\t\t\t\t\t\t\" to access the context class loader\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"a5b8f58c50a9160593e3a963db2158b781684a03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasReflect(Permission permission) {\n\n\t\tString name = permission.getName();\n\t\tString actions = permission.getActions();\n\n\t\t/*for (int i = 6; i <= 15; i++) {\n\t\t\tSystem.out.println(\n\t\t\t\t\"Caller class \" + i + \" \" + Reflection.getCallerClass(i));\n\t\t}*/\n\n\t\t// JSP compiler\n\n\t\tif (isJSPCompiler(name, actions)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tClass<?> callerClass9 = null;\n\n\t\tif (permission instanceof CheckMemberAccessPermission) {\n\t\t\tCheckMemberAccessPermission memberAccessPermission =\n\t\t\t\t(CheckMemberAccessPermission)permission;\n\n\t\t\tif (memberAccessPermission.getCaller() == ReferenceRegistry.class) {\n\t\t\t\tClass<?> realCallerClass = memberAccessPermission.getCaller();\n\n\t\t\t\tint depth = 9;\n\n\t\t\t\twhile (realCallerClass == ReferenceRegistry.class) {\n\t\t\t\t\tdepth++;\n\n\t\t\t\t\trealCallerClass = Reflection.getCallerClass(depth);\n\t\t\t\t}\n\n\t\t\t\tClassLoader callerClassLoader =\n\t\t\t\t\tPACLClassLoaderUtil.getClassLoader(realCallerClass);\n\n\t\t\t\tif (callerClassLoader ==\n\t\t\t\t\t\tmemberAccessPermission.getSubjectClassLoader()) {\n\n\t\t\t\t\tlogReflect(realCallerClass, depth);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcallerClass9 = memberAccessPermission.getCaller();\n\t\t}\n\t\telse {\n\t\t\tcallerClass9 = Reflection.getCallerClass(9);\n\t\t}\n\n\t\t// com.caucho.config.reflect.ReflectionAnnotatedType\n\n\t\tif (isResinReflectionAnnotatedType(callerClass9)) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// com.caucho.server.session.JavaSessionSerializer\n\n\t\tif (isResinJavaSessionSerializer()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// com.liferay.portal.kernel.messaging.config.\n\t\t// AbstractMessagingConfigurator\n\n\t\tif (callerClass9 == AbstractMessagingConfigurator.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// java.beans.Introspector\n\n\t\t//if (JavaDetector.isOpenJDK()) {\n\t\t\tif ((callerClass9.getEnclosingClass() == Introspector.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(10)) {\n\n\t\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t//}\n\n\t\t// jodd.util.ReflectUtil\n\n\t\tif (callerClass9 == ReflectUtil.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// java.lang.Class\n\n\t\tClass<?> callerClass7 = Reflection.getCallerClass(7);\n\t\tClass<?> callerClass8 = null;\n\n\t\tif (name.equals(\"suppressAccessChecks\") &&\n\t\t\t(callerClass7 == ReferenceEntry.class)) {\n\n\t\t\tcallerClass8 = Reflection.getCallerClass(8);\n\n\t\t\tif (callerClass8 == ReferenceRegistry.class) {\n\t\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (JavaDetector.isIBM() || JavaDetector.isJDK7()) {\n\t\t\tif (callerClass8 == null) {\n\t\t\t\tcallerClass8 = Reflection.getCallerClass(8);\n\t\t\t}\n\n\t\t\tif ((callerClass8.getEnclosingClass() == Class.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(9)) {\n\n\t\t\t\tlogReflect(callerClass8, 8);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((callerClass7.getEnclosingClass() == Class.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(8)) {\n\n\t\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// java.lang.Thread\n\n\t\tif (JavaDetector.isJDK7() || JavaDetector.isOpenJDK()) {\n\t\t\tClass<?> callerClass10 = Reflection.getCallerClass(10);\n\n\t\t\tif ((callerClass10.getEnclosingClass() == Thread.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(11)) {\n\n\t\t\t\tlogReflect(callerClass10, 10);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((callerClass9.getEnclosingClass() == Thread.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(10)) {\n\n\t\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// org.apache.felix.framework.util.SecureAction\n\n\t\tif (isGlassfishSecureAction(\n\t\t\t\tcallerClass7.getEnclosingClass()) &&\n\t\t\tCheckerUtil.isAccessControllerDoPrivileged(8)) {\n\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.hibernate.property.BasicPropertyAccessor\n\n\t\tif (callerClass9 == BasicPropertyAccessor.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.hibernate.tuple.entity.EntityTuplizerFactory\n\n\t\tif (callerClass7 == EntityTuplizerFactory.class) {\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.hibernate.util.ReflectHelper\n\n\t\tif (callerClass9 == ReflectHelper.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.beans.BeanUtils\n\n\t\tif (callerClass9 == BeanUtils.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.beans.factory.support.SimpleInstantiationStrategy\n\n\t\tif (callerClass9.getEnclosingClass() ==\n\t\t\t\tSimpleInstantiationStrategy.class) {\n\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.core.LocalVariableTableParameterNameDiscoverer\n\n\t\tif (callerClass9.getEnclosingClass() ==\n\t\t\t\tLocalVariableTableParameterNameDiscoverer.class) {\n\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.util.ReflectionUtils\n\n\t\tif (callerClass7 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (callerClass9 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// weblogic.spring.monitoring.utils.AbstractApplicationContextDelegator\n\n\t\tif (isWebLogicAbstractApplicationContextDelegator(callerClass9)) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// weblogic.spring.monitoring.utils.AbstractBeanDefinitionDelegator\n\n\t\tif (isWebLogicAbstractBeanDefinitionDelegator(callerClass9)) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reject\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Rejecting call stack:\");\n\n\t\t\tfor (int i = 6; i < 11; i++) {\n\t\t\t\t_log.debug(\"Frame \" + i + \" \" + Reflection.getCallerClass(i));\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":31184,"modified_method":"protected boolean hasReflect(Permission permission) {\n\n\t\t/*for (int i = 6; i <= 15; i++) {\n\t\t\tSystem.out.println(\n\t\t\t\t\"Caller class \" + i + \" \" + Reflection.getCallerClass(i));\n\t\t}*/\n\n\t\t// JSP compiler\n\n\t\tString name = permission.getName();\n\t\tString actions = permission.getActions();\n\n\t\tif (isJSPCompiler(name, actions)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tClass<?> callerClass9 = null;\n\n\t\tif (permission instanceof CheckMemberAccessPermission) {\n\t\t\tCheckMemberAccessPermission checkMemberAccessPermission =\n\t\t\t\t(CheckMemberAccessPermission)permission;\n\n\t\t\tif (checkMemberAccessPermission.getCallerClass() ==\n\t\t\t\t\tReferenceRegistry.class) {\n\n\t\t\t\tClass<?> checkMemberAccessPermissionCallerClass =\n\t\t\t\t\tcheckMemberAccessPermission.getCallerClass();\n\n\t\t\t\tint depth = 9;\n\n\t\t\t\twhile (checkMemberAccessPermissionCallerClass ==\n\t\t\t\t\t\t\tReferenceRegistry.class) {\n\n\t\t\t\t\tdepth++;\n\n\t\t\t\t\tcheckMemberAccessPermissionCallerClass =\n\t\t\t\t\t\tReflection.getCallerClass(depth);\n\t\t\t\t}\n\n\t\t\t\tClassLoader callerClassLoader =\n\t\t\t\t\tPACLClassLoaderUtil.getClassLoader(\n\t\t\t\t\t\tcheckMemberAccessPermissionCallerClass);\n\n\t\t\t\tif (callerClassLoader ==\n\t\t\t\t\t\tcheckMemberAccessPermission.getSubjectClassLoader()) {\n\n\t\t\t\t\tlogReflect(checkMemberAccessPermissionCallerClass, depth);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcallerClass9 = checkMemberAccessPermission.getCallerClass();\n\t\t}\n\t\telse {\n\t\t\tcallerClass9 = Reflection.getCallerClass(9);\n\t\t}\n\n\t\t// com.caucho.config.reflect.ReflectionAnnotatedType\n\n\t\tif (isResinReflectionAnnotatedType(callerClass9)) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// com.caucho.server.session.JavaSessionSerializer\n\n\t\tif (isResinJavaSessionSerializer()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// com.liferay.portal.kernel.messaging.config.\n\t\t// AbstractMessagingConfigurator\n\n\t\tif (callerClass9 == AbstractMessagingConfigurator.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// java.beans.Introspector\n\n\t\t//if (JavaDetector.isOpenJDK()) {\n\t\t\tif ((callerClass9.getEnclosingClass() == Introspector.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(10)) {\n\n\t\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t//}\n\n\t\t// jodd.util.ReflectUtil\n\n\t\tif (callerClass9 == ReflectUtil.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// java.lang.Class\n\n\t\tClass<?> callerClass7 = Reflection.getCallerClass(7);\n\t\tClass<?> callerClass8 = Reflection.getCallerClass(8);\n\n\t\tif (name.equals(\"suppressAccessChecks\") &&\n\t\t\t(callerClass7 == ReferenceEntry.class)) {\n\n\t\t\tif (callerClass8 == ReferenceRegistry.class) {\n\t\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (JavaDetector.isIBM() || JavaDetector.isJDK7()) {\n\t\t\tif ((callerClass8.getEnclosingClass() == Class.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(9)) {\n\n\t\t\t\tlogReflect(callerClass8, 8);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((callerClass7.getEnclosingClass() == Class.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(8)) {\n\n\t\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// java.lang.Thread\n\n\t\tif (JavaDetector.isJDK7() || JavaDetector.isOpenJDK()) {\n\t\t\tClass<?> callerClass10 = Reflection.getCallerClass(10);\n\n\t\t\tif ((callerClass10.getEnclosingClass() == Thread.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(11)) {\n\n\t\t\t\tlogReflect(callerClass10, 10);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((callerClass9.getEnclosingClass() == Thread.class) &&\n\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(10)) {\n\n\t\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// org.apache.felix.framework.util.SecureAction\n\n\t\tif (isGlassfishSecureAction(\n\t\t\t\tcallerClass7.getEnclosingClass()) &&\n\t\t\tCheckerUtil.isAccessControllerDoPrivileged(8)) {\n\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.hibernate.property.BasicPropertyAccessor\n\n\t\tif (callerClass9 == BasicPropertyAccessor.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.hibernate.tuple.entity.EntityTuplizerFactory\n\n\t\tif (callerClass7 == EntityTuplizerFactory.class) {\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.hibernate.util.ReflectHelper\n\n\t\tif (callerClass9 == ReflectHelper.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.beans.BeanUtils\n\n\t\tif (callerClass9 == BeanUtils.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.beans.factory.support.SimpleInstantiationStrategy\n\n\t\tif (callerClass9.getEnclosingClass() ==\n\t\t\t\tSimpleInstantiationStrategy.class) {\n\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.core.LocalVariableTableParameterNameDiscoverer\n\n\t\tif (callerClass9.getEnclosingClass() ==\n\t\t\t\tLocalVariableTableParameterNameDiscoverer.class) {\n\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// org.springframework.util.ReflectionUtils\n\n\t\tif (callerClass7 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass7, 7);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (callerClass9 == ReflectionUtils.class) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// weblogic.spring.monitoring.utils.AbstractApplicationContextDelegator\n\n\t\tif (isWebLogicAbstractApplicationContextDelegator(callerClass9)) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// weblogic.spring.monitoring.utils.AbstractBeanDefinitionDelegator\n\n\t\tif (isWebLogicAbstractBeanDefinitionDelegator(callerClass9)) {\n\t\t\tlogReflect(callerClass9, 9);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reject\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Rejecting call stack:\");\n\n\t\t\tfor (int i = 6; i < 11; i++) {\n\t\t\t\t_log.debug(\"Frame \" + i + \" \" + Reflection.getCallerClass(i));\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"0d5f7c752fa7b579611e14768c095e5e0d766abb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CheckMemberAccessPermission(\n\t\tString name, Class<?> caller, ClassLoader callerClassLoader,\n\t\tClass<?> subject, ClassLoader subjectClassLoader) {\n\n\t\tsuper(name);\n\n\t\t_caller = caller;\n\t\t_callerClassLoader = callerClassLoader;\n\t\t_subject = subject;\n\t\t_subjectClassLoader = subjectClassLoader;\n\t}","id":31185,"modified_method":"public CheckMemberAccessPermission(\n\t\tString name, Class<?> callerClass, ClassLoader callerClassLoader,\n\t\tClass<?> subjectClass, ClassLoader subjectClassLoader) {\n\n\t\tsuper(name);\n\n\t\t_callerClass = callerClass;\n\t\t_callerClassLoader = callerClassLoader;\n\t\t_subjectClass = subjectClass;\n\t\t_subjectClassLoader = subjectClassLoader;\n\t}","commit_id":"0d5f7c752fa7b579611e14768c095e5e0d766abb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Class<?> getSubject() {\n\t\treturn _subject;\n\t}","id":31186,"modified_method":"public Class<?> getSubjectClass() {\n\t\treturn _subjectClass;\n\t}","commit_id":"0d5f7c752fa7b579611e14768c095e5e0d766abb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Class<?> getCaller() {\n\t\treturn _caller;\n\t}","id":31187,"modified_method":"public Class<?> getCallerClass() {\n\t\treturn _callerClass;\n\t}","commit_id":"0d5f7c752fa7b579611e14768c095e5e0d766abb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isJSPCompiler(String subject, String actions) {\n\t\tfor (int i = 1;; i++) {\n\t\t\tClass<?> callerClass = Reflection.getCallerClass(i);\n\n\t\t\tif (callerClass == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString callerClassName = callerClass.getName();\n\n\t\t\tif (!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_JASPER_COMPILER) &&\n\t\t\t\t!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_JASPER_XMLPARSER) &&\n\t\t\t\t!callerClassName.startsWith(\n\t\t\t\t\t_PACKAGE_NAME_ORG_APACHE_NAMING_RESOURCES) &&\n\t\t\t\t!callerClassName.equals(\n\t\t\t\t\t_ClASS_NAME_DEFAULT_ANNOTATION_PROCESSOR) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_DEFAULT_INSTANCE_MANAGER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_JASPER_LOADER) &&\n\t\t\t\t!callerClassName.startsWith(\n\t\t\t\t\t_CLASS_NAME_JASPER_SERVLET_CONTEXT_CUSTOMIZER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_JSP_MANAGER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_PAGE_MANAGER) &&\n\t\t\t\t!callerClassName.equals(_ClASS_NAME_TAG_HANDLER_POOL)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClassLoader callerClassLoader = PACLClassLoaderUtil.getClassLoader(\n\t\t\t\tcallerClass);\n\n\t\t\tif (callerClassLoader != _commonClassLoader) {\n\t\t\t\tboolean allow = false;\n\n\t\t\t\tif (ServerDetector.isGeronimo()) {\n\t\t\t\t\tClass<?> callerClassLoaderClass =\n\t\t\t\t\t\tcallerClassLoader.getClass();\n\n\t\t\t\t\tString callerClassLoaderClassName =\n\t\t\t\t\t\tcallerClassLoaderClass.getName();\n\n\t\t\t\t\tif (callerClassLoaderClassName.equals(\n\t\t\t\t\t\t\t_CLASS_NAME_JAR_FILE_CLASS_LOADER)) {\n\n\t\t\t\t\t\tallow = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ServerDetector.isGlassfish()) {\n\t\t\t\t\tClass<?> callerClassLoaderClass =\n\t\t\t\t\t\tcallerClassLoader.getClass();\n\n\t\t\t\t\tcallerClassLoaderClass =\n\t\t\t\t\t\tcallerClassLoaderClass.getEnclosingClass();\n\n\t\t\t\t\tif (callerClassLoaderClass != null) {\n\t\t\t\t\t\tString callerClassLoaderClassName =\n\t\t\t\t\t\t\tcallerClassLoaderClass.getName();\n\n\t\t\t\t\t\tif (callerClassLoaderClassName.equals(\n\t\t\t\t\t\t\t\t_ClASS_NAME_BUNDLE_WIRING_IMPL)) {\n\n\t\t\t\t\t\t\tallow = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ServerDetector.isJBoss()) {\n\t\t\t\t\tString callerClassLoaderString =\n\t\t\t\t\t\tcallerClassLoader.toString();\n\n\t\t\t\t\tif (callerClassLoaderString.contains(\n\t\t\t\t\t\t\t_MODULE_NAME_ORG_JBOSS_AS_WEB_MAIN)) {\n\n\t\t\t\t\t\tallow = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ServerDetector.isJOnAS()) {\n\t\t\t\t\tClass<?> callerClassLoaderClass =\n\t\t\t\t\t\tcallerClassLoader.getClass();\n\n\t\t\t\t\tString callerClassLoaderClassName =\n\t\t\t\t\t\tcallerClassLoaderClass.getName();\n\n\t\t\t\t\tif (callerClassLoaderClassName.startsWith(\n\t\t\t\t\t\t\t_CLASS_NAME_MODULE_IMPL)) {\n\n\t\t\t\t\t\tallow = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ServerDetector.isResin()) {\n\t\t\t\t\tClass<?> callerClassLoaderClass =\n\t\t\t\t\t\tcallerClassLoader.getClass();\n\n\t\t\t\t\tString classLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClassLoaderClass);\n\n\t\t\t\t\tif (Validator.isNull(classLocation)) {\n\t\t\t\t\t\tallow = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!allow) {\n\t\t\t\t\tif (Validator.isNotNull(actions)) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\t\tcallerClassName + \" to \" + actions + \" \" +\n\t\t\t\t\t\t\t\t\tsubject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\t\tcallerClassName + \" to \" + subject);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tif (Validator.isNotNull(actions)) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\" to \" + actions + \" \" + subject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\" to \" + subject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":31188,"modified_method":"protected boolean isJSPCompiler(String subject, String actions) {\n\t\tfor (int i = 7;; i++) {\n\t\t\tClass<?> callerClass = Reflection.getCallerClass(i);\n\n\t\t\tif (callerClass == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tBoolean allowed = null;\n\n\t\t\tString callerClassName = callerClass.getName();\n\n\t\t\tif (ServerDetector.isGeronimo()) {\n\t\t\t\tif (callerClassName.equals(_ClASS_NAME_COMPILER) ||\n\t\t\t\t\tcallerClassName.startsWith(\n\t\t\t\t\t\t_CLASS_NAME_JASPER_SERVLET_CONTEXT_CUSTOMIZER) ||\n\t\t\t\t\tcallerClassName.equals(_ClASS_NAME_TAG_HANDLER_POOL)) {\n\n\t\t\t\t\tString actualClassLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClass);\n\t\t\t\t\tString expectedClassLocation = PathUtil.toUnixPath(\n\t\t\t\t\t\tSystem.getProperty(\"org.apache.geronimo.home.dir\") +\n\t\t\t\t\t\t\t\"/repository/org/apache/geronimo/\");\n\n\t\t\t\t\tallowed = actualClassLocation.contains(\n\t\t\t\t\t\texpectedClassLocation);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ServerDetector.isGlassfish()) {\n\t\t\t\tif (callerClassName.equals(_ClASS_NAME_COMPILER) ||\n\t\t\t\t\tcallerClassName.equals(\n\t\t\t\t\t\t_ClASS_NAME_JSP_COMPILATION_CONTEXT)) {\n\n\t\t\t\t\tString classLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClass);\n\n\t\t\t\t\tallowed = classLocation.startsWith(\"bundle://\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ServerDetector.isJBoss()) {\n\t\t\t\tif (callerClassName.equals(_ClASS_NAME_COMPILER)) {\n\t\t\t\t\tClassLoader callerClassLoader =\n\t\t\t\t\t\tPACLClassLoaderUtil.getClassLoader(callerClass);\n\n\t\t\t\t\tString callerClassLoaderString =\n\t\t\t\t\t\tcallerClassLoader.toString();\n\n\t\t\t\t\tallowed = callerClassLoaderString.contains(\n\t\t\t\t\t\t_MODULE_NAME_ORG_JBOSS_AS_WEB_MAIN);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ServerDetector.isJetty()) {\n\t\t\t\tif (callerClassName.equals(_ClASS_NAME_COMPILER) ||\n\t\t\t\t\tcallerClassName.equals(_ClASS_NAME_JASPER_LOADER)) {\n\n\t\t\t\t\tClassLoader callerClassLoader =\n\t\t\t\t\t\tPACLClassLoaderUtil.getClassLoader(callerClass);\n\n\t\t\t\t\tallowed = (callerClassLoader == _commonClassLoader);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ServerDetector.isJOnAS()) {\n\t\t\t\tif (callerClassName.equals(\n\t\t\t\t\t\t_ClASS_NAME_DEFAULT_ANNOTATION_PROCESSOR) ||\n\t\t\t\t\tcallerClassName.equals(_ClASS_NAME_JASPER_LOADER) ||\n\t\t\t\t\tcallerClassName.equals(\n\t\t\t\t\t\t_ClASS_NAME_JSP_COMPILATION_CONTEXT)) {\n\n\t\t\t\t\tString classLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClass);\n\n\t\t\t\t\tallowed = classLocation.startsWith(\"bundle://\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ServerDetector.isResin()) {\n\t\t\t\tif (callerClassName.equals(_ClASS_NAME_JSP_MANAGER) ||\n\t\t\t\t\tcallerClassName.equals(_ClASS_NAME_PAGE_MANAGER)) {\n\n\t\t\t\t\tString actualClassLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClass);\n\t\t\t\t\tString expectedClassLocation = PathUtil.toUnixPath(\n\t\t\t\t\t\tSystem.getProperty(\"resin.home\") + \"/lib/resin.jar!/\");\n\n\t\t\t\t\tallowed = actualClassLocation.contains(\n\t\t\t\t\t\texpectedClassLocation);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ServerDetector.isTomcat()) {\n\t\t\t\tif (callerClassName.equals(\n\t\t\t\t\t\t_ClASS_NAME_DEFAULT_INSTANCE_MANAGER) ||\n\t\t\t\t\tcallerClassName.equals(_ClASS_NAME_COMPILER) ||\n\t\t\t\t\tcallerClassName.equals(_ClASS_NAME_TAG_HANDLER_POOL)) {\n\n\t\t\t\t\tClassLoader callerClassLoader =\n\t\t\t\t\t\tPACLClassLoaderUtil.getClassLoader(callerClass);\n\n\t\t\t\t\tallowed = (callerClassLoader == _commonClassLoader);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (allowed == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (allowed) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tif (Validator.isNotNull(actions)) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\t\" to \" + actions + \" \" + subject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Allowing the JSP compiler via \" + callerClassName +\n\t\t\t\t\t\t\t\t\" to \" + subject);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNotNull(actions)) {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\tcallerClassName + \" to \" + actions + \" \" +\n\t\t\t\t\t\t\t\tsubject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"A plugin is hijacking the JSP compiler via \" +\n\t\t\t\t\t\t\tcallerClassName + \" to \" + subject);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}","commit_id":"1040892968945a54d32dc1f10954b00d64bb790c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasDelete(Permission permission) {\n\t\tfor (Permission deleteFilePermission : _deletePermissions) {\n\t\t\tif (deleteFilePermission.implies(permission)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (isJSPCompiler(\n\t\t\t\tpermission.getName(), FILE_PERMISSION_ACTION_DELETE)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isResinVFS()) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":31189,"modified_method":"protected boolean hasDelete(Permission permission) {\n\t\tfor (Permission deleteFilePermission : _deletePermissions) {\n\t\t\tif (deleteFilePermission.implies(permission)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (ServerDetector.isResin()) {\n\t\t\tfor (int i = 7;; i++) {\n\t\t\t\tClass<?> callerClass = Reflection.getCallerClass(i);\n\n\t\t\t\tif (callerClass == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tString callerClassName = callerClass.getName();\n\n\t\t\t\tif (callerClassName.equals(_CLASS_NAME_FILE_PATH)) {\n\t\t\t\t\tString actualClassLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClass);\n\t\t\t\t\tString expectedClassLocation = PathUtil.toUnixPath(\n\t\t\t\t\t\tSystem.getProperty(\"resin.home\") + \"/lib/resin.jar!/\");\n\n\t\t\t\t\treturn actualClassLocation.contains(expectedClassLocation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"1040892968945a54d32dc1f10954b00d64bb790c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<Permission> getPermissions(String key, String actions) {\n\t\tList<Permission> permissions = new CopyOnWriteArrayList<Permission>();\n\n\t\tString value = getProperty(key);\n\n\t\tif (value != null) {\n\t\t\tvalue = StringUtil.replace(\n\t\t\t\tvalue, _defaultReadPathsFromArray, _defaultReadPathsToArray);\n\n\t\t\tString[] paths = StringUtil.split(value);\n\n\t\t\tif (value.contains(\"${comma}\")) {\n\t\t\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\t\t\tpaths[i] = StringUtil.replace(\n\t\t\t\t\t\tpaths[i], \"${comma}\", StringPool.COMMA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String path : paths) {\n\t\t\t\taddPermission(permissions, path, actions);\n\t\t\t}\n\t\t}\n\n\t\t// Plugin can do anything, except execute, in its own work folder\n\n\t\tString pathContext = ContextPathUtil.getContextPath(\n\t\t\tPropsValues.PORTAL_CTX);\n\n\t\tServletContext servletContext = ServletContextPool.get(pathContext);\n\n\t\tif (!actions.equals(FILE_PERMISSION_ACTION_EXECUTE) &&\n\t\t\t(_workDir != null)) {\n\n\t\t\taddPermission(permissions, _workDir, actions);\n\t\t\taddPermission(permissions, _workDir + \"/-\", actions);\n\n\t\t\tif (servletContext != null) {\n\t\t\t\tFile tempDir = (File)servletContext.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_SERVLET_CONTEXT_TEMPDIR);\n\n\t\t\t\tString tempDirAbsolutePath = tempDir.getAbsolutePath();\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Temp directory \" + tempDirAbsolutePath);\n\t\t\t\t}\n\n\t\t\t\tif (actions.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\t\t\taddPermission(permissions, tempDirAbsolutePath, actions);\n\t\t\t\t}\n\n\t\t\t\taddPermission(permissions, tempDirAbsolutePath + \"/-\", actions);\n\t\t\t}\n\t\t}\n\n\t\tif (!actions.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\treturn permissions;\n\t\t}\n\n\t\tList<String> paths = new UniqueList<String>();\n\n\t\t// JDK\n\n\t\t// There may be JARs in the system library that are symlinked. We must\n\t\t// include their canonical paths or they will fail permission checks.\n\n\t\ttry {\n\t\t\tFile file = new File(System.getProperty(\"java.home\") + \"/lib\");\n\n\t\t\taddCanonicalPaths(paths, file);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(ioe, ioe);\n\t\t}\n\n\t\t// Shared libs\n\n\t\tpaths.add(_globalSharedLibDir + \"-\");\n\n\t\t// Plugin\n\n\t\tpaths.add(_rootDir + \"-\");\n\n\t\t// Portal\n\n\t\taddDefaultReadPaths(paths, \"common\");\n\t\taddDefaultReadPaths(paths, ServerDetector.getServerId());\n\n\t\tfor (String path : paths) {\n\t\t\taddPermission(permissions, path, actions);\n\t\t}\n\n\t\treturn permissions;\n\t}","id":31190,"modified_method":"protected List<Permission> getPermissions(String key, String actions) {\n\t\tList<Permission> permissions = new CopyOnWriteArrayList<Permission>();\n\n\t\tString value = getProperty(key);\n\n\t\tif (value != null) {\n\t\t\tvalue = StringUtil.replace(\n\t\t\t\tvalue, _defaultReadPathsFromArray, _defaultReadPathsToArray);\n\n\t\t\tString[] paths = StringUtil.split(value);\n\n\t\t\tif (value.contains(\"${comma}\")) {\n\t\t\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\t\t\tpaths[i] = StringUtil.replace(\n\t\t\t\t\t\tpaths[i], \"${comma}\", StringPool.COMMA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String path : paths) {\n\t\t\t\taddPermission(permissions, path, actions);\n\t\t\t}\n\t\t}\n\n\t\t// Plugin can do anything, except execute, in its own work folder\n\n\t\tString pathContext = ContextPathUtil.getContextPath(\n\t\t\tPropsValues.PORTAL_CTX);\n\n\t\tServletContext servletContext = ServletContextPool.get(pathContext);\n\n\t\tif (!actions.equals(FILE_PERMISSION_ACTION_EXECUTE) &&\n\t\t\t(_workDir != null)) {\n\n\t\t\taddPermission(permissions, _workDir, actions);\n\t\t\taddPermission(permissions, _workDir + \"/-\", actions);\n\n\t\t\tif (servletContext != null) {\n\t\t\t\tFile tempDir = (File)servletContext.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_SERVLET_CONTEXT_TEMPDIR);\n\n\t\t\t\tString tempDirAbsolutePath = tempDir.getAbsolutePath();\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Temp directory \" + tempDirAbsolutePath);\n\t\t\t\t}\n\n\t\t\t\tif (actions.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\t\t\taddPermission(permissions, tempDirAbsolutePath, actions);\n\t\t\t\t}\n\n\t\t\t\taddPermission(permissions, tempDirAbsolutePath + \"/-\", actions);\n\t\t\t}\n\t\t}\n\n\t\tif (!actions.equals(FILE_PERMISSION_ACTION_READ)) {\n\t\t\treturn permissions;\n\t\t}\n\n\t\tList<String> paths = new UniqueList<String>();\n\n\t\t// JDK\n\n\t\t// There may be JARs in the system library that are symlinked. We must\n\t\t// include their canonical paths or they will fail permission checks.\n\n\t\ttry {\n\t\t\tFile file = new File(System.getProperty(\"java.home\") + \"/lib\");\n\n\t\t\taddCanonicalPaths(paths, file);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(ioe, ioe);\n\t\t}\n\n\t\t// Shared libs\n\n\t\tpaths.add(_globalSharedLibDir + \"-\");\n\n\t\t// Plugin\n\n\t\tpaths.add(_rootDir + \"-\");\n\n\t\t// Portal\n\n\t\taddDefaultReadPaths(paths, ServerDetector.getServerId());\n\n\t\tfor (String path : paths) {\n\t\t\taddPermission(permissions, path, actions);\n\t\t}\n\n\t\treturn permissions;\n\t}","commit_id":"1040892968945a54d32dc1f10954b00d64bb790c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasWrite(Permission permission) {\n\t\tfor (Permission writeFilePermission : _writePermissions) {\n\t\t\tif (writeFilePermission.implies(permission)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (isJSPCompiler(permission.getName(), FILE_PERMISSION_ACTION_WRITE)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":31191,"modified_method":"protected boolean hasWrite(Permission permission) {\n\t\tfor (Permission writeFilePermission : _writePermissions) {\n\t\t\tif (writeFilePermission.implies(permission)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (ServerDetector.isResin()) {\n\t\t\tfor (int i = 7;; i++) {\n\t\t\t\tClass<?> callerClass = Reflection.getCallerClass(i);\n\n\t\t\t\tif (callerClass == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tString callerClassName = callerClass.getName();\n\n\t\t\t\tif (callerClassName.equals(_CLASS_NAME_FILE_PATH)) {\n\t\t\t\t\tString actualClassLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClass);\n\t\t\t\t\tString expectedClassLocation = PathUtil.toUnixPath(\n\t\t\t\t\t\tSystem.getProperty(\"resin.home\") + \"/lib/resin.jar!/\");\n\n\t\t\t\t\treturn actualClassLocation.contains(expectedClassLocation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"1040892968945a54d32dc1f10954b00d64bb790c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasRead(Permission permission) {\n\t\tfor (Permission readFilePermission : _readPermissions) {\n\t\t\tif (readFilePermission.implies(permission)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (isJSPCompiler(permission.getName(), FILE_PERMISSION_ACTION_READ)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isResinVFS()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tClass<?> callerClass10 = Reflection.getCallerClass(10);\n\n\t\tif (isGeronimoJarFileClassLoader(\n\t\t\t\tcallerClass10.getEnclosingClass()) &&\n\t\t\tCheckerUtil.isAccessControllerDoPrivileged(11)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\tClass<?> callerClass20 = Reflection.getCallerClass(20);\n\n\t\tif (isGeronimoJarFileClassLoader(\n\t\t\t\tcallerClass20.getEnclosingClass()) &&\n\t\t\tCheckerUtil.isAccessControllerDoPrivileged(21)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":31192,"modified_method":"protected boolean hasRead(Permission permission) {\n\t\tfor (Permission readFilePermission : _readPermissions) {\n\t\t\tif (readFilePermission.implies(permission)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (isJSPCompiler(permission.getName(), FILE_PERMISSION_ACTION_READ)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfor (int i = 7;; i++) {\n\t\t\tClass<?> callerClass = Reflection.getCallerClass(i);\n\n\t\t\tif (callerClass == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ((callerClass == DirectServletRegistryImpl.class) ||\n\t\t\t\t(callerClass == FileAvailabilityUtil.class) ||\n\t\t\t\tClassLoader.class.isAssignableFrom(callerClass)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (ServerDetector.isGlassfish()) {\n\t\t\t\tClass<?> enclosingClass = callerClass.getEnclosingClass();\n\n\t\t\t\tif (enclosingClass != null) {\n\t\t\t\t\tif ((enclosingClass.getEnclosingClass() ==\n\t\t\t\t\t\t\tURLClassLoader.class) &&\n\t\t\t\t\t\tCheckerUtil.isAccessControllerDoPrivileged(i + 1)) {\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ServerDetector.isResin()) {\n\t\t\t\tString callerClassName = callerClass.getName();\n\n\t\t\t\tif (callerClassName.equals(_CLASS_NAME_FILE_PATH)) {\n\t\t\t\t\tString actualClassLocation = PACLClassUtil.getClassLocation(\n\t\t\t\t\t\tcallerClass);\n\t\t\t\t\tString expectedClassLocation = PathUtil.toUnixPath(\n\t\t\t\t\t\tSystem.getProperty(\"resin.home\") + \"/lib/resin.jar!/\");\n\n\t\t\t\t\treturn actualClassLocation.contains(expectedClassLocation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"1040892968945a54d32dc1f10954b00d64bb790c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Inject\n  public CachedStreamEventCollector(CConfiguration cConfig, OperationExecutor opex,\n                                    QueueClientFactory queueClientFactory) {\n    this.flushTimer = new Timer(\"stream-rest-flush-thread\", true);\n\n    int maxCachedEventsPerStream = cConfig.getInt(GatewayConstants.ConfigKeys.MAX_CACHED_EVENTS_PER_STREAM_NUM,\n                                                  GatewayConstants.DEFAULT_MAX_CACHED_EVENTS_PER_STREAM_NUM);\n    int maxCachedEvents = cConfig.getInt(GatewayConstants.ConfigKeys.MAX_CACHED_STREAM_EVENTS_NUM,\n                                         GatewayConstants.DEFAULT_MAX_CACHED_STREAM_EVENTS_NUM);\n    long maxCachedSizeBytes = cConfig.getLong(GatewayConstants.ConfigKeys.MAX_CACHED_STREAM_EVENTS_BYTES,\n                                              GatewayConstants.DEFAULT_MAX_CACHED_STREAM_EVENTS_BYTES);\n    this.flushIntervalMs = cConfig.getLong(GatewayConstants.ConfigKeys.STREAM_EVENTS_FLUSH_INTERVAL_MS,\n                                           GatewayConstants.DEFAULT_STREAM_EVENTS_FLUSH_INTERVAL_MS);\n\n    int numThreads = cConfig.getInt(GatewayConstants.ConfigKeys.STREAM_EVENTS_CALLBACK_NUM_THREADS,\n                                    GatewayConstants.DEFAULT_STREAM_EVENTS_CALLBACK_NUM_THREADS);\n    this.callbackExecutorService = Executors.newFixedThreadPool(numThreads,\n                                                                new ThreadFactoryBuilder()\n                                                                  .setDaemon(true)\n                                                                  .setNameFormat(\"stream-rest-callback-thread\")\n                                                                  .build()\n    );\n\n    this.cachedStreamEvents = new CachedStreamEvents(opex, queueClientFactory, callbackExecutorService,\n                                                     maxCachedSizeBytes, maxCachedEvents,\n                                                     maxCachedEventsPerStream);\n  }","id":31193,"modified_method":"@Inject\n  public CachedStreamEventCollector(CConfiguration cConfig, TransactionSystemClient txClient,\n                                    QueueClientFactory queueClientFactory) {\n    this.flushTimer = new Timer(\"stream-rest-flush-thread\", true);\n\n    int maxCachedEventsPerStream = cConfig.getInt(GatewayConstants.ConfigKeys.MAX_CACHED_EVENTS_PER_STREAM_NUM,\n                                                  GatewayConstants.DEFAULT_MAX_CACHED_EVENTS_PER_STREAM_NUM);\n    int maxCachedEvents = cConfig.getInt(GatewayConstants.ConfigKeys.MAX_CACHED_STREAM_EVENTS_NUM,\n                                         GatewayConstants.DEFAULT_MAX_CACHED_STREAM_EVENTS_NUM);\n    long maxCachedSizeBytes = cConfig.getLong(GatewayConstants.ConfigKeys.MAX_CACHED_STREAM_EVENTS_BYTES,\n                                              GatewayConstants.DEFAULT_MAX_CACHED_STREAM_EVENTS_BYTES);\n    this.flushIntervalMs = cConfig.getLong(GatewayConstants.ConfigKeys.STREAM_EVENTS_FLUSH_INTERVAL_MS,\n                                           GatewayConstants.DEFAULT_STREAM_EVENTS_FLUSH_INTERVAL_MS);\n\n    int numThreads = cConfig.getInt(GatewayConstants.ConfigKeys.STREAM_EVENTS_CALLBACK_NUM_THREADS,\n                                    GatewayConstants.DEFAULT_STREAM_EVENTS_CALLBACK_NUM_THREADS);\n    this.callbackExecutorService = Executors.newFixedThreadPool(numThreads,\n                                                                new ThreadFactoryBuilder()\n                                                                  .setDaemon(true)\n                                                                  .setNameFormat(\"stream-rest-callback-thread\")\n                                                                  .build()\n    );\n\n    this.cachedStreamEvents = new CachedStreamEvents(txClient, queueClientFactory, callbackExecutorService,\n                                                     maxCachedSizeBytes, maxCachedEvents,\n                                                     maxCachedEventsPerStream);\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Used to enqueue a StreamEvent.\n   * @param event StreamEvent to enqueue.\n   * @param accountId accountId of the entity making the call.\n   * @param callback Callback to be called after enqueuing the event\n   */\n  public void collect(StreamEvent event, String accountId, FutureCallback<Void> callback) {\n    try {\n      byte[] bytes = serializer.encodePayload(event);\n      Preconditions.checkArgument(bytes != null, String.format(\"Could not serialize event: %s\", event));\n\n      String destination = event.getHeaders().get(Constants.HEADER_DESTINATION_STREAM);\n      if (destination == null) {\n        LOG.trace(\"Enqueuing an event that has no destination. Using 'default' instead.\");\n        destination = \"default\";\n      }\n\n      QueueName queueName = QueueName.fromStream(accountId, destination);\n      cachedStreamEvents.put(queueName, new QueueEntry(bytes), callback);\n    } catch (Exception e) {\n      callback.onFailure(e);\n    }\n  }","id":31194,"modified_method":"/**\n   * Used to enqueue a StreamEvent.\n   * @param event StreamEvent to enqueue.\n   * @param accountId accountId of the entity making the call.\n   * @param callback Callback to be called after enqueuing the event\n   */\n  public void collect(StreamEvent event, String accountId, FutureCallback<Void> callback) {\n    try {\n      byte[] bytes = serializer.encodePayload(event);\n      Preconditions.checkArgument(bytes != null, String.format(\"Could not serialize event: %s\", event));\n\n      String destination = event.getHeaders().get(Constants.HEADER_DESTINATION_STREAM);\n      if (destination == null) {\n        LOG.trace(\"Enqueuing an event that has no destination. Using 'default' instead.\");\n        destination = \"default\";\n      }\n\n      QueueName queueName = QueueName.fromStream(accountId, destination);\n      cachedStreamEvents.put(queueName, new QueueEntry(bytes), callback);\n    } catch (Throwable e) {\n      callback.onFailure(e);\n    }\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"CachedStreamEvents(final OperationExecutor opex, final QueueClientFactory queueClientFactory,\n                     final ExecutorService callbackExecutorService,\n                     long maxCachedSizeBytes, int maxCachedEvents,\n                     final int maxCachedEventsPerStream) {\n    this.maxCachedSizeBytes = maxCachedSizeBytes;\n    this.maxCachedEvents = maxCachedEvents;\n\n    this.eventCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .removalListener(\n        new RemovalListener<QueueName, ProducerStreamEntries>() {\n          @Override\n          public void onRemoval(RemovalNotification<QueueName, ProducerStreamEntries> notification) {\n            ProducerStreamEntries producerStreamEntries = notification.getValue();\n            if (producerStreamEntries != null) {\n              producerStreamEntries.flush();\n              try {\n                producerStreamEntries.close();\n              } catch (IOException e) {\n                LOG.error(\"Exception while closing producer {}\", producerStreamEntries);\n              }\n            }\n          }\n        }\n      )\n      .build(\n        new CacheLoader<QueueName, ProducerStreamEntries>() {\n          @Override\n          public ProducerStreamEntries load(QueueName key) throws Exception {\n            Queue2Producer producer = queueClientFactory.createProducer(key);\n            return new ProducerStreamEntries(producer,\n                                             new ArrayBlockingQueue<StreamEntry>(maxCachedEventsPerStream),\n                                             opex, callbackExecutorService, cachedBytes, cachedNumEntries);\n          }\n        });\n  }","id":31195,"modified_method":"CachedStreamEvents(final TransactionSystemClient txClient, final QueueClientFactory queueClientFactory,\n                     final ExecutorService callbackExecutorService,\n                     long maxCachedSizeBytes, int maxCachedEvents,\n                     final int maxCachedEventsPerStream) {\n    this.maxCachedSizeBytes = maxCachedSizeBytes;\n    this.maxCachedEvents = maxCachedEvents;\n\n    this.eventCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .removalListener(\n        new RemovalListener<QueueName, ProducerStreamEntries>() {\n          @Override\n          public void onRemoval(RemovalNotification<QueueName, ProducerStreamEntries> notification) {\n            ProducerStreamEntries producerStreamEntries = notification.getValue();\n            if (producerStreamEntries != null) {\n              producerStreamEntries.flush();\n              try {\n                producerStreamEntries.close();\n              } catch (IOException e) {\n                LOG.error(\"Exception while closing producer {}\", producerStreamEntries);\n              }\n            }\n          }\n        }\n      )\n      .build(\n        new CacheLoader<QueueName, ProducerStreamEntries>() {\n          @Override\n          public ProducerStreamEntries load(QueueName key) throws Exception {\n            Queue2Producer producer = queueClientFactory.createProducer(key);\n            return new ProducerStreamEntries(producer,\n                                             new ArrayBlockingQueue<StreamEntry>(maxCachedEventsPerStream),\n                                             txClient, callbackExecutorService, cachedBytes, cachedNumEntries);\n          }\n        });\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public ProducerStreamEntries(Queue2Producer producer, BlockingQueue<StreamEntry> streamEntries,\n                                 OperationExecutor opex, ExecutorService callbackExecutorService,\n                                 AtomicLong cachedBytes, AtomicInteger cachedNumEntries) {\n      this.producer = producer;\n      this.txManager = new TxManager(opex, (TransactionAware) producer);\n      this.streamEntries = streamEntries;\n\n      this.callbackExecutorService = callbackExecutorService;\n\n      this.cachedBytes = cachedBytes;\n      this.cachedNumEntries = cachedNumEntries;\n    }","id":31196,"modified_method":"public ProducerStreamEntries(Queue2Producer producer, BlockingQueue<StreamEntry> streamEntries,\n                                 TransactionSystemClient txClient, ExecutorService callbackExecutorService,\n                                 AtomicLong cachedBytes, AtomicInteger cachedNumEntries) {\n      this.producer = producer;\n      this.txManager = new TxManager(txClient, (TransactionAware) producer);\n      this.streamEntries = streamEntries;\n\n      this.callbackExecutorService = callbackExecutorService;\n\n      this.cachedBytes = cachedBytes;\n      this.cachedNumEntries = cachedNumEntries;\n    }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized void flush() {\n      List<StreamEntry> entries = Lists.newArrayListWithExpectedSize(streamEntries.size());\n      SettableFuture<Void> future = SettableFuture.create();\n      StreamEntryToQueueEntryFunction transformer =\n        new StreamEntryToQueueEntryFunction(future, callbackExecutorService);\n\n      try {\n        streamEntries.drainTo(entries);\n        if (entries.isEmpty()) {\n          return;\n        }\n\n        txManager.start();\n        producer.enqueue(Iterables.transform(entries, transformer));\n\n        // Commit\n        txManager.commit();\n        future.set(null);\n\n      } catch (Throwable e) {\n        LOG.error(\"Exception when trying to enqueue with producer {}. Aborting txn...\", producer, e);\n\n        try {\n          txManager.abort();\n        } catch (OperationException e1) {\n          LOG.error(\"Exception while aborting txn\", e1);\n        } finally {\n          future.setException(e);\n        }\n      } finally {\n        int numEntries = entries.size();\n        cachedNumEntries.addAndGet(-1 * numEntries);\n\n        long numBytes = transformer.getNumBytes();\n        if (numEntries != transformer.getNumEntries()) {\n          numBytes = numBytesInList(entries);\n        }\n        cachedBytes.addAndGet(-1 * numBytes);\n\n        LOG.debug(\"Flushed {} events with producer {}\", numEntries, producer);\n      }\n    }","id":31197,"modified_method":"public synchronized void flush() {\n      List<StreamEntry> entries = Lists.newArrayListWithExpectedSize(streamEntries.size());\n      streamEntries.drainTo(entries);\n      if (entries.isEmpty()) {\n        return;\n      }\n\n      CallbackNotifier callbackNotifier =\n        new CallbackNotifier(callbackExecutorService,\n                             Iterables.transform(entries, STREAM_ENTRY_FUTURE_CALLBACK_FUNCTION));\n      StreamEntryToQueueEntryFunction transformer = new StreamEntryToQueueEntryFunction();\n\n      try {\n        txManager.start();\n\n        try {\n          producer.enqueue(Iterables.transform(entries, transformer));\n\n          // Commit\n          txManager.commit();\n\n          // Notify callbacks\n          callbackNotifier.notifySuccess();\n          LOG.debug(\"Flushed {} events with producer {}\", entries.size(), producer);\n        } catch (Throwable e) {\n          LOG.error(\"Exception when trying to enqueue with producer {}. Aborting txn...\", producer, e);\n\n          try {\n            txManager.abort();\n          } catch (OperationException e1) {\n            LOG.error(\"Exception while aborting txn\", e1);\n          } finally {\n            // Notify callbacks\n            callbackNotifier.notifyFailure(e);\n          }\n        }\n      } catch (OperationException e) {\n        LOG.error(\"Caught exception\", e);\n        callbackNotifier.notifyFailure(e);\n      } finally {\n        int numEntries = entries.size();\n        cachedNumEntries.addAndGet(-1 * numEntries);\n\n        long numBytes = transformer.getNumBytes();\n        if (numEntries != transformer.getNumEntries()) {\n          numBytes = numBytesInList(entries);\n        }\n        cachedBytes.addAndGet(-1 * numBytes);\n      }\n    }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized DequeueResult dequeue() throws Throwable {\n    try {\n      txManager.start();\n      DequeueResult result = consumer.dequeue();\n      txManager.commit();\n      return result;\n    } catch (Throwable e) {\n      LOG.error(\"Exception while dequeuing stream using consumer {}\", consumer, e);\n      txManager.abort();\n      throw e;\n    }\n  }","id":31198,"modified_method":"public synchronized DequeueResult dequeue() throws Throwable {\n    try {\n      txManager.start();\n\n      try {\n        DequeueResult result = consumer.dequeue();\n        txManager.commit();\n        return result;\n      } catch (Throwable e) {\n        LOG.error(\"Exception while dequeuing stream using consumer {}\", consumer, e);\n        txManager.abort();\n        throw e;\n      }\n    } catch (OperationException e) {\n      LOG.error(\"Got exception\", e);\n      throw e;\n    }\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public ConsumerHolder(ConsumerKey key, OperationExecutor opex,\n                        QueueClientFactory queueClientFactory) throws Exception {\n    // 0th instance of group 'groupId' of size 1\n    this.consumer =\n      queueClientFactory.createConsumer(key.getQueueName(),\n                                        new ConsumerConfig(key.getGroupId(), 0, 1, DequeueStrategy.FIFO, null), 1);\n    this.txManager = new TxManager(opex, (TransactionAware) consumer);\n  }","id":31199,"modified_method":"public ConsumerHolder(ConsumerKey key, TransactionSystemClient txClient,\n                        QueueClientFactory queueClientFactory) throws Exception {\n    // 0th instance of group 'groupId' of size 1\n    this.consumer =\n      queueClientFactory.createConsumer(key.getQueueName(),\n                                        new ConsumerConfig(key.getGroupId(), 0, 1, DequeueStrategy.FIFO, null), 1);\n    this.txManager = new TxManager(txClient, (TransactionAware) consumer);\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public StreamHandler(final OperationExecutor opex, CConfiguration cConfig, StreamCache streamCache,\n                       MetadataService metadataService, CMetrics cMetrics, GatewayMetrics gatewayMetrics,\n                       final QueueClientFactory queueClientFactory, GatewayAuthenticator authenticator) {\n    this.streamCache = streamCache;\n    this.metadataService = metadataService;\n    this.cMetrics = cMetrics;\n    this.gatewayMetrics = gatewayMetrics;\n    this.authenticator = authenticator;\n\n    this.streamEventCollector = new CachedStreamEventCollector(cConfig, opex, queueClientFactory);\n\n    this.queueConsumerCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .removalListener(\n        new RemovalListener<ConsumerKey, ConsumerHolder>() {\n          @Override\n          public void onRemoval(RemovalNotification<ConsumerKey, ConsumerHolder> notification) {\n            ConsumerHolder holder = notification.getValue();\n            if (holder == null) {\n              return;\n            }\n\n            try {\n              holder.close();\n            } catch (IOException e) {\n              LOG.error(\"Exception while closing consumer {}\", holder, e);\n            }\n          }\n        }\n      )\n      .build(\n        new CacheLoader<ConsumerKey, ConsumerHolder>() {\n          @Override\n          public ConsumerHolder load(ConsumerKey key) throws Exception {\n            return new ConsumerHolder(key, opex, queueClientFactory);\n          }\n        });\n  }","id":31200,"modified_method":"@Inject\n  public StreamHandler(final TransactionSystemClient txClient, CConfiguration cConfig, StreamCache streamCache,\n                       MetadataService metadataService, CMetrics cMetrics, GatewayMetrics gatewayMetrics,\n                       final QueueClientFactory queueClientFactory, GatewayAuthenticator authenticator) {\n    this.streamCache = streamCache;\n    this.metadataService = metadataService;\n    this.cMetrics = cMetrics;\n    this.gatewayMetrics = gatewayMetrics;\n    this.authenticator = authenticator;\n\n    this.streamEventCollector = new CachedStreamEventCollector(cConfig, txClient, queueClientFactory);\n\n    this.queueConsumerCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .removalListener(\n        new RemovalListener<ConsumerKey, ConsumerHolder>() {\n          @Override\n          public void onRemoval(RemovalNotification<ConsumerKey, ConsumerHolder> notification) {\n            ConsumerHolder holder = notification.getValue();\n            if (holder == null) {\n              return;\n            }\n\n            try {\n              holder.close();\n            } catch (IOException e) {\n              LOG.error(\"Exception while closing consumer {}\", holder, e);\n            }\n          }\n        }\n      )\n      .build(\n        new CacheLoader<ConsumerKey, ConsumerHolder>() {\n          @Override\n          public ConsumerHolder load(ConsumerKey key) throws Exception {\n            return new ConsumerHolder(key, txClient, queueClientFactory);\n          }\n        });\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public TxManager(OperationExecutor opex, TransactionAware...txAware) {\n    this.opex = opex;\n    txAwares = ImmutableList.copyOf(txAware);\n  }","id":31201,"modified_method":"public TxManager(TransactionSystemClient txClient, TransactionAware...txAware) {\n    this.txClient = txClient;\n    txAwares = ImmutableList.copyOf(txAware);\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public void start() throws OperationException {\n    transaction = opex.start();\n    for (TransactionAware txAware : txAwares) {\n      txAware.startTx(transaction);\n    }\n  }","id":31202,"modified_method":"public void start() throws OperationException {\n    transaction = txClient.start();\n    for (TransactionAware txAware : txAwares) {\n      txAware.startTx(transaction);\n    }\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public void abort() throws OperationException {\n    for (TransactionAware txAware : txAwares) {\n      try {\n        if (!txAware.rollbackTx()) {\n          LOG.error(\"Fail to rollback: {}\", txAware);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Exception in rollback: {}\", txAware, e);\n      }\n    }\n    opex.abort(transaction);\n  }","id":31203,"modified_method":"public void abort() throws OperationException {\n    boolean rollbacksSuccess = true;\n    for (TransactionAware txAware : txAwares) {\n      try {\n        if (!txAware.rollbackTx()) {\n          rollbacksSuccess = false;\n          LOG.error(\"Fail to rollback: {}\", txAware);\n        }\n      } catch (Throwable e) {\n        rollbacksSuccess = false;\n        LOG.error(\"Exception in rollback: {}\", txAware, e);\n      }\n    }\n\n    // Only abort txn if all rollbacks are successful\n    if (rollbacksSuccess) {\n      txClient.abort(transaction);\n    } else {\n      throw new OperationException(StatusCode.INTERNAL_ERROR,\n                                   \"Not all TransactionAwares could be rolled back successfully\");\n    }\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"public void commit() throws OperationException {\n    // Collects change sets\n    Set<byte[]> changeSet = Sets.newTreeSet(Bytes.BYTES_COMPARATOR);\n    for (TransactionAware txAware : txAwares) {\n      changeSet.addAll(txAware.getTxChanges());\n    }\n\n    // Check for conflicts\n    if (!opex.canCommit(transaction, changeSet)) {\n      throw new OperationException(StatusCode.TRANSACTION_CONFLICT, \"Cannot commit tx: conflict detected\");\n    }\n\n    // Persist changes\n    for (TransactionAware txAware : txAwares) {\n      try {\n        if (!txAware.commitTx()) {\n          throw new OperationException(StatusCode.INVALID_TRANSACTION, \"Fails to commit tx.\");\n        }\n      } catch (Exception e) {\n        throw new OperationException(StatusCode.INVALID_TRANSACTION, \"Fails to commit tx.\", e);\n      }\n    }\n\n    // Make visible\n    if (!opex.commit(transaction)) {\n      throw new OperationException(StatusCode.INVALID_TRANSACTION, \"Fails to make tx visible.\");\n    }\n\n    // Post commit call\n    for (TransactionAware txAware : txAwares) {\n      try {\n        txAware.postTxCommit();\n      } catch (Throwable t) {\n        LOG.error(\"Post commit call failure.\", t);\n      }\n    }\n  }","id":31204,"modified_method":"public void commit() throws OperationException {\n    // Collects change sets\n    Set<byte[]> changeSet = Sets.newTreeSet(Bytes.BYTES_COMPARATOR);\n    for (TransactionAware txAware : txAwares) {\n      changeSet.addAll(txAware.getTxChanges());\n    }\n\n    // Check for conflicts\n    if (!txClient.canCommit(transaction, changeSet)) {\n      throw new OperationException(StatusCode.TRANSACTION_CONFLICT, \"Cannot commit tx: conflict detected\");\n    }\n\n    // Persist changes\n    for (TransactionAware txAware : txAwares) {\n      try {\n        if (!txAware.commitTx()) {\n          throw new OperationException(StatusCode.INVALID_TRANSACTION, \"Fails to commit tx.\");\n        }\n      } catch (Exception e) {\n        throw new OperationException(StatusCode.INVALID_TRANSACTION, \"Fails to commit tx.\", e);\n      }\n    }\n\n    // Make visible\n    if (!txClient.commit(transaction)) {\n      throw new OperationException(StatusCode.INVALID_TRANSACTION, \"Fails to make tx visible.\");\n    }\n\n    // Post commit call\n    for (TransactionAware txAware : txAwares) {\n      try {\n        txAware.postTxCommit();\n      } catch (Throwable t) {\n        LOG.error(\"Post commit call failure.\", t);\n      }\n    }\n  }","commit_id":"9b76bd8b46da92072c1f8a38b1234988a8e6c0d5","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Batch method to apply all the queued refresh or update operations. The idea is to try and batch as much\n     * as possible so we won't create the same index all the time for example for the updates on the same mapping\n     * and generate a single cluster change event out of all of those.\n     */\n    ClusterState executeRefreshOrUpdate(final ClusterState currentState) throws Exception {\n        List<Object> tasks = new ArrayList<Object>();\n        refreshOrUpdateQueue.drainTo(tasks);\n\n        if (tasks.isEmpty()) {\n            return currentState;\n        }\n\n        Set<String> indicesToRemove = Sets.newHashSet();\n        // keep track of what we already refreshed, no need to refresh it again...\n        Set<Tuple<String, String>> processedRefreshes = Sets.newHashSet();\n        try {\n            boolean dirty = false;\n            MetaData.Builder mdBuilder = newMetaDataBuilder().metaData(currentState.metaData());\n            for (Object task : tasks) {\n                if (task instanceof RefreshTask) {\n                    RefreshTask refreshTask = (RefreshTask) task;\n                    String index = refreshTask.index;\n                    final IndexMetaData indexMetaData = mdBuilder.get(index);\n                    if (indexMetaData == null) {\n                        // index got delete on us, ignore...\n                        continue;\n                    }\n                    IndexService indexService = indicesService.indexService(index);\n                    if (indexService == null) {\n                        // we need to create the index here, and add the current mapping to it, so we can merge\n                        indexService = indicesService.createIndex(indexMetaData.index(), indexMetaData.settings(), currentState.nodes().localNode().id());\n                        indicesToRemove.add(index);\n                        for (String type : refreshTask.types) {\n                            // only add the current relevant mapping (if exists)\n                            if (indexMetaData.mappings().containsKey(type)) {\n                                // don't apply the default mapping, it has been applied when the mapping was created\n                                indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);\n                            }\n                        }\n                    }\n                    IndexMetaData.Builder indexMetaDataBuilder = newIndexMetaDataBuilder(indexMetaData);\n                    List<String> updatedTypes = Lists.newArrayList();\n                    for (String type : refreshTask.types) {\n                        Tuple<String, String> processedRefresh = Tuple.tuple(index, type);\n                        if (processedRefreshes.contains(processedRefresh)) {\n                            continue;\n                        }\n                        DocumentMapper mapper = indexService.mapperService().documentMapper(type);\n                        if (!mapper.mappingSource().equals(indexMetaData.mappings().get(type).source())) {\n                            updatedTypes.add(type);\n                            indexMetaDataBuilder.putMapping(new MappingMetaData(mapper));\n                        }\n                        processedRefreshes.add(processedRefresh);\n                    }\n\n                    if (updatedTypes.isEmpty()) {\n                        continue;\n                    }\n\n                    logger.warn(\"[{}] re-syncing mappings with cluster state for types [{}]\", index, updatedTypes);\n                    mdBuilder.put(indexMetaDataBuilder);\n                    dirty = true;\n\n                } else if (task instanceof UpdateTask) {\n                    UpdateTask updateTask = (UpdateTask) task;\n                    String index = updateTask.index;\n                    String type = updateTask.type;\n                    CompressedString mappingSource = updateTask.mappingSource;\n\n                    // first, check if it really needs to be updated\n                    final IndexMetaData indexMetaData = mdBuilder.get(index);\n                    if (indexMetaData == null) {\n                        // index got delete on us, ignore...\n                        continue;\n                    }\n                    if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(mappingSource)) {\n                        continue;\n                    }\n\n                    IndexService indexService = indicesService.indexService(index);\n                    if (indexService == null) {\n                        // we need to create the index here, and add the current mapping to it, so we can merge\n                        indexService = indicesService.createIndex(indexMetaData.index(), indexMetaData.settings(), currentState.nodes().localNode().id());\n                        indicesToRemove.add(index);\n                        // only add the current relevant mapping (if exists)\n                        if (indexMetaData.mappings().containsKey(type)) {\n                            indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);\n                        }\n                    }\n\n                    DocumentMapper updatedMapper = indexService.mapperService().merge(type, mappingSource.string(), false);\n                    processedRefreshes.add(Tuple.tuple(index, type));\n\n                    // if we end up with the same mapping as the original once, ignore\n                    if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {\n                        continue;\n                    }\n\n                    // build the updated mapping source\n                    if (logger.isDebugEnabled()) {\n                        try {\n                            logger.debug(\"[{}] update_mapping [{}] (dynamic) with source [{}]\", index, type, updatedMapper.mappingSource().string());\n                        } catch (Exception e) {\n                            // ignore\n                        }\n                    } else if (logger.isInfoEnabled()) {\n                        logger.info(\"[{}] update_mapping [{}] (dynamic)\", index, type);\n                    }\n\n                    mdBuilder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));\n                    dirty = true;\n                } else {\n                    logger.warn(\"illegal state, got wrong mapping task type [{}]\", task);\n                }\n            }\n            if (!dirty) {\n                return currentState;\n            }\n            return newClusterStateBuilder().state(currentState).metaData(mdBuilder).build();\n        } finally {\n            for (String index : indicesToRemove) {\n                indicesService.removeIndex(index, \"created for mapping processing\");\n            }\n            for (Object task : tasks) {\n                if (task instanceof UpdateTask) {\n                    ((UpdateTask) task).listener.onResponse(new Response(true));\n                }\n            }\n        }\n    }","id":31205,"modified_method":"/**\n     * Batch method to apply all the queued refresh or update operations. The idea is to try and batch as much\n     * as possible so we won't create the same index all the time for example for the updates on the same mapping\n     * and generate a single cluster change event out of all of those.\n     */\n    ClusterState executeRefreshOrUpdate(final ClusterState currentState) throws Exception {\n        List<Object> allTasks = new ArrayList<Object>();\n        refreshOrUpdateQueue.drainTo(allTasks);\n\n        if (allTasks.isEmpty()) {\n            return currentState;\n        }\n\n        // break down to tasks per index, so we can optimize the on demand index service creation\n        // to only happen for the duration of a single index processing of its respective events\n        Map<String, List<Object>> tasksPerIndex = Maps.newHashMap();\n        for (Object task : allTasks) {\n            String index = null;\n            if (task instanceof UpdateTask) {\n                index = ((UpdateTask) task).index;\n            } else if (task instanceof RefreshTask) {\n                index = ((RefreshTask) task).index;\n            } else {\n                logger.warn(\"illegal state, got wrong mapping task type [{}]\", task);\n            }\n            if (index != null) {\n                List<Object> indexTasks = tasksPerIndex.get(index);\n                if (indexTasks == null) {\n                    indexTasks = new ArrayList<Object>();\n                    tasksPerIndex.put(index, indexTasks);\n                }\n                indexTasks.add(task);\n            }\n        }\n\n        boolean dirty = false;\n        MetaData.Builder mdBuilder = newMetaDataBuilder().metaData(currentState.metaData());\n        for (Map.Entry<String, List<Object>> entry : tasksPerIndex.entrySet()) {\n            String index = entry.getKey();\n            List<Object> tasks = entry.getValue();\n            boolean removeIndex = false;\n            // keep track of what we already refreshed, no need to refresh it again...\n            Set<String> processedRefreshes = Sets.newHashSet();\n            try {\n                for (Object task : tasks) {\n                    if (task instanceof RefreshTask) {\n                        RefreshTask refreshTask = (RefreshTask) task;\n                        final IndexMetaData indexMetaData = mdBuilder.get(index);\n                        if (indexMetaData == null) {\n                            // index got delete on us, ignore...\n                            continue;\n                        }\n                        IndexService indexService = indicesService.indexService(index);\n                        if (indexService == null) {\n                            // we need to create the index here, and add the current mapping to it, so we can merge\n                            indexService = indicesService.createIndex(indexMetaData.index(), indexMetaData.settings(), currentState.nodes().localNode().id());\n                            removeIndex = true;\n                            for (String type : refreshTask.types) {\n                                // only add the current relevant mapping (if exists)\n                                if (indexMetaData.mappings().containsKey(type)) {\n                                    // don't apply the default mapping, it has been applied when the mapping was created\n                                    indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);\n                                }\n                            }\n                        }\n                        IndexMetaData.Builder indexMetaDataBuilder = newIndexMetaDataBuilder(indexMetaData);\n                        List<String> updatedTypes = Lists.newArrayList();\n                        for (String type : refreshTask.types) {\n                            if (processedRefreshes.contains(type)) {\n                                continue;\n                            }\n                            DocumentMapper mapper = indexService.mapperService().documentMapper(type);\n                            if (!mapper.mappingSource().equals(indexMetaData.mappings().get(type).source())) {\n                                updatedTypes.add(type);\n                                indexMetaDataBuilder.putMapping(new MappingMetaData(mapper));\n                            }\n                            processedRefreshes.add(type);\n                        }\n\n                        if (updatedTypes.isEmpty()) {\n                            continue;\n                        }\n\n                        logger.warn(\"[{}] re-syncing mappings with cluster state for types [{}]\", index, updatedTypes);\n                        mdBuilder.put(indexMetaDataBuilder);\n                        dirty = true;\n\n                    } else if (task instanceof UpdateTask) {\n                        UpdateTask updateTask = (UpdateTask) task;\n                        String type = updateTask.type;\n                        CompressedString mappingSource = updateTask.mappingSource;\n\n                        // first, check if it really needs to be updated\n                        final IndexMetaData indexMetaData = mdBuilder.get(index);\n                        if (indexMetaData == null) {\n                            // index got delete on us, ignore...\n                            continue;\n                        }\n                        if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(mappingSource)) {\n                            continue;\n                        }\n\n                        IndexService indexService = indicesService.indexService(index);\n                        if (indexService == null) {\n                            // we need to create the index here, and add the current mapping to it, so we can merge\n                            indexService = indicesService.createIndex(indexMetaData.index(), indexMetaData.settings(), currentState.nodes().localNode().id());\n                            removeIndex = true;\n                            // only add the current relevant mapping (if exists)\n                            if (indexMetaData.mappings().containsKey(type)) {\n                                indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);\n                            }\n                        }\n\n                        DocumentMapper updatedMapper = indexService.mapperService().merge(type, mappingSource.string(), false);\n                        processedRefreshes.add(type);\n\n                        // if we end up with the same mapping as the original once, ignore\n                        if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {\n                            continue;\n                        }\n\n                        // build the updated mapping source\n                        if (logger.isDebugEnabled()) {\n                            try {\n                                logger.debug(\"[{}] update_mapping [{}] (dynamic) with source [{}]\", index, type, updatedMapper.mappingSource().string());\n                            } catch (Exception e) {\n                                // ignore\n                            }\n                        } else if (logger.isInfoEnabled()) {\n                            logger.info(\"[{}] update_mapping [{}] (dynamic)\", index, type);\n                        }\n\n                        mdBuilder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));\n                        dirty = true;\n                    } else {\n                        logger.warn(\"illegal state, got wrong mapping task type [{}]\", task);\n                    }\n                }\n            } finally {\n                if (removeIndex) {\n                    indicesService.removeIndex(index, \"created for mapping processing\");\n                }\n                for (Object task : tasks) {\n                    if (task instanceof UpdateTask) {\n                        ((UpdateTask) task).listener.onResponse(new Response(true));\n                    }\n                }\n            }\n        }\n\n        if (!dirty) {\n            return currentState;\n        }\n        return newClusterStateBuilder().state(currentState).metaData(mdBuilder).build();\n    }","commit_id":"993fad4c339bd741eee4da7cf6817ca69f614676","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public int read(byte[] b, int off, int len) throws IOException\n        {\n            if (len == 0)\n                return 0;\n            if (index == buffers.size())\n                return -1;\n\n            if (slice == null)\n                slice = buffers.get(index).slice();\n\n            int size = Math.min(len, slice.remaining());\n            slice.get(b, off, size);\n\n            if (!slice.hasRemaining())\n            {\n                ++index;\n                slice = null;\n            }\n\n            return size;\n        }","id":31206,"modified_method":"@Override\n        public int read(byte[] b, int off, int len) throws IOException\n        {\n            if (len == 0)\n                return 0;\n            if (index == sourceBuffers.size())\n                return -1;\n\n            if (slice == null)\n                slice = sourceBuffers.get(index).slice();\n\n            int size = Math.min(len, slice.remaining());\n            slice.get(b, off, size);\n\n            if (!slice.hasRemaining())\n            {\n                ++index;\n                slice = null;\n            }\n\n            return size;\n        }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void overflow(ByteBuffer input) throws IOException\n    {\n        if (inputFile == null)\n        {\n            Path path = Files.createTempFile(getOverflowDirectory(), getInputFilePrefix(), null);\n            inputFile = FileChannel.open(path,\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.READ,\n                    StandardOpenOption.WRITE,\n                    StandardOpenOption.DELETE_ON_CLOSE);\n            int size = buffers.size();\n            if (size > 0)\n            {\n                inputFile.write(buffers.toArray(new ByteBuffer[size]));\n                buffers.clear();\n            }\n        }\n        inputFile.write(input);\n    }","id":31207,"modified_method":"private void overflow(ByteBuffer input) throws IOException\n    {\n        if (inputFile == null)\n        {\n            Path path = Files.createTempFile(getOverflowDirectory(), getInputFilePrefix(), null);\n            inputFile = FileChannel.open(path,\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.READ,\n                    StandardOpenOption.WRITE,\n                    StandardOpenOption.DELETE_ON_CLOSE);\n            int size = sourceBuffers.size();\n            if (size > 0)\n            {\n                inputFile.write(sourceBuffers.toArray(new ByteBuffer[size]));\n                sourceBuffers.clear();\n            }\n        }\n        inputFile.write(input);\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void drainTo(List<ByteBuffer> output) throws IOException\n        {\n            if (outputFile == null)\n            {\n                output.addAll(buffers);\n                buffers.clear();\n            }\n            else\n            {\n                outputFile.force(true);\n                long position = 0;\n                long length = outputFile.size();\n                outputFile.position(position);\n                while (length > 0)\n                {\n                    // At most 1 GiB file maps.\n                    long size = Math.min(1024 * 1024 * 1024, length);\n                    ByteBuffer buffer = outputFile.map(FileChannel.MapMode.READ_ONLY, position, size);\n                    output.add(buffer);\n                    position += size;\n                    length -= size;\n                }\n            }\n        }","id":31208,"modified_method":"private void drainTo(List<ByteBuffer> output) throws IOException\n        {\n            if (outputFile == null)\n            {\n                output.addAll(sinkBuffers);\n                sinkBuffers.clear();\n            }\n            else\n            {\n                outputFile.force(true);\n                drain(outputFile, output);\n            }\n        }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * <p>Transforms the original content read from the {@code source} into\n     * transformed content written to the {@code sink}.<\/p>\n     * <p>The transformation must happen synchronously in the context of a call\n     * to this method (it is not supported to perform the transformation in another\n     * thread spawned during the call to this method).<\/p>\n     * <p>Differently from {@link #transform(ByteBuffer, boolean, List)}, this\n     * method is invoked only when the whole content is available, and offers\n     * a blocking API via the InputStream and OutputStream that can be obtained\n     * from {@link Source} and {@link Sink} respectively.<\/p>\n     * <p>Typical implementations:<\/p>\n     * <pre>\n     * // Identity transformation (no transformation, the input is copied to the output)\n     * public void transform(Source source, Sink sink)\n     * {\n     *     org.eclipse.jetty.util.IO.copy(source.getInputStream(), sink.getOutputStream());\n     * }\n     * <\/pre>\n     *\n     * @param source where the original content is read\n     * @param sink where the transformed content is written\n     * @throws IOException if the transformation fails\n     */\n    public abstract void transform(Source source, Sink sink) throws IOException;","id":31209,"modified_method":"/**\n     * <p>Transforms the original content read from the {@code source} into\n     * transformed content written to the {@code sink}.<\/p>\n     * <p>The transformation must happen synchronously in the context of a call\n     * to this method (it is not supported to perform the transformation in another\n     * thread spawned during the call to this method).<\/p>\n     * <p>Differently from {@link #transform(ByteBuffer, boolean, List)}, this\n     * method is invoked only when the whole content is available, and offers\n     * a blocking API via the InputStream and OutputStream that can be obtained\n     * from {@link Source} and {@link Sink} respectively.<\/p>\n     * <p>Implementations may read the source, inspect the input bytes and decide\n     * that no transformation is necessary, and therefore the source must be copied\n     * unchanged to the sink. In such case, the implementation must return false to\n     * indicate that it wishes to just pipe the bytes from the source to the sink.<\/p>\n     * <p>Typical implementations:<\/p>\n     * <pre>\n     * // Identity transformation (no transformation, the input is copied to the output)\n     * public boolean transform(Source source, Sink sink)\n     * {\n     *     org.eclipse.jetty.util.IO.copy(source.getInputStream(), sink.getOutputStream());\n     *     return true;\n     * }\n     * <\/pre>\n     *\n     * @param source where the original content is read\n     * @param sink where the transformed content is written\n     * @return true if the transformation happened and the transformed bytes have\n     * been written to the sink, false if no transformation happened and the source\n     * must be copied to the sink.\n     * @throws IOException if the transformation fails\n     */\n    public abstract boolean transform(Source source, Sink sink) throws IOException;","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public final void transform(ByteBuffer input, boolean finished, List<ByteBuffer> output) throws IOException\n    {\n        int remaining = input.remaining();\n        if (remaining > 0)\n        {\n            inputBufferSize += remaining;\n            long max = getMaxInputBufferSize();\n            if (max >= 0 && inputBufferSize > max)\n            {\n                overflow(input);\n            }\n            else\n            {\n                ByteBuffer copy = ByteBuffer.allocate(input.remaining());\n                copy.put(input).flip();\n                buffers.add(copy);\n            }\n        }\n\n        if (finished)\n        {\n            Source source = new Source();\n            Sink sink = new Sink();\n            transform(source, sink);\n            sink.drainTo(output);\n        }\n    }","id":31210,"modified_method":"@Override\n    public final void transform(ByteBuffer input, boolean finished, List<ByteBuffer> output) throws IOException\n    {\n        int remaining = input.remaining();\n        if (remaining > 0)\n        {\n            inputBufferSize += remaining;\n            long max = getMaxInputBufferSize();\n            if (max >= 0 && inputBufferSize > max)\n            {\n                overflow(input);\n            }\n            else\n            {\n                ByteBuffer copy = ByteBuffer.allocate(input.remaining());\n                copy.put(input).flip();\n                sourceBuffers.add(copy);\n            }\n        }\n\n        if (finished)\n        {\n            Source source = new Source();\n            Sink sink = new Sink();\n            if (transform(source, sink))\n                sink.drainTo(output);\n            else\n                source.drainTo(output);\n        }\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void overflow(ByteBuffer output) throws IOException\n        {\n            if (outputFile == null)\n            {\n                Path path = Files.createTempFile(getOverflowDirectory(), getOutputFilePrefix(), null);\n                outputFile = FileChannel.open(path,\n                        StandardOpenOption.CREATE,\n                        StandardOpenOption.READ,\n                        StandardOpenOption.WRITE,\n                        StandardOpenOption.DELETE_ON_CLOSE);\n                int size = buffers.size();\n                if (size > 0)\n                {\n                    outputFile.write(buffers.toArray(new ByteBuffer[size]));\n                    buffers.clear();\n                }\n            }\n            outputFile.write(output);\n        }","id":31211,"modified_method":"private void overflow(ByteBuffer output) throws IOException\n        {\n            if (outputFile == null)\n            {\n                Path path = Files.createTempFile(getOverflowDirectory(), getOutputFilePrefix(), null);\n                outputFile = FileChannel.open(path,\n                        StandardOpenOption.CREATE,\n                        StandardOpenOption.READ,\n                        StandardOpenOption.WRITE,\n                        StandardOpenOption.DELETE_ON_CLOSE);\n                int size = sinkBuffers.size();\n                if (size > 0)\n                {\n                    outputFile.write(sinkBuffers.toArray(new ByteBuffer[size]));\n                    sinkBuffers.clear();\n                }\n            }\n            outputFile.write(output);\n        }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n            public void write(byte[] b, int off, int len) throws IOException\n            {\n                if (len <= 0)\n                    return;\n\n                outputBufferSize += len;\n                long max = getMaxOutputBufferSize();\n                if (max >= 0 && outputBufferSize > max)\n                {\n                    overflow(ByteBuffer.wrap(b, off, len));\n                }\n                else\n                {\n                    // The array may be reused by the\n                    // application so we need to copy it.\n                    byte[] copy = new byte[len];\n                    System.arraycopy(b, off, copy, 0, len);\n                    buffers.add(ByteBuffer.wrap(copy));\n                }\n            }","id":31212,"modified_method":"@Override\n            public void write(byte[] b, int off, int len) throws IOException\n            {\n                if (len <= 0)\n                    return;\n\n                outputBufferSize += len;\n                long max = getMaxOutputBufferSize();\n                if (max >= 0 && outputBufferSize > max)\n                {\n                    overflow(ByteBuffer.wrap(b, off, len));\n                }\n                else\n                {\n                    // The array may be reused by the\n                    // application so we need to copy it.\n                    byte[] copy = new byte[len];\n                    System.arraycopy(b, off, copy, 0, len);\n                    sinkBuffers.add(ByteBuffer.wrap(copy));\n                }\n            }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void startProxy(HttpServlet proxyServlet) throws Exception\n    {\n        startProxy(proxyServlet, new HashMap<String, String>());\n    }","id":31213,"modified_method":"private void startProxy(AsyncMiddleManServlet proxyServlet) throws Exception\n    {\n        startProxy(proxyServlet, new HashMap<String, String>());\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void testAfterContentTransformerInputStreamReset(final boolean overflow) throws Exception\n    {\n        final byte[] data = new byte[]{'c', 'o', 'f', 'f', 'e', 'e'};\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                // Write the content in two chunks.\n                int chunk = data.length / 2;\n                ServletOutputStream output = response.getOutputStream();\n                output.write(data, 0, chunk);\n                sleep(1000);\n                output.write(data, chunk, data.length - chunk);\n            }\n        });\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                return new AfterContentTransformer()\n                {\n                    {\n                        setMaxInputBufferSize(overflow ? data.length / 2 : data.length * 2);\n                    }\n\n                    @Override\n                    public void transform(Source source, Sink sink) throws IOException\n                    {\n                        // Consume the stream once.\n                        InputStream input = source.getInputStream();\n                        IO.copy(input, IO.getNullStream());\n\n                        // Reset the stream and re-read it.\n                        input.reset();\n                        IO.copy(input, sink.getOutputStream());\n                    }\n                };\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertEquals(HttpStatus.OK_200, response.getStatus());\n        Assert.assertArrayEquals(data, response.getContent());\n    }","id":31214,"modified_method":"private void testAfterContentTransformerInputStreamReset(final boolean overflow) throws Exception\n    {\n        final byte[] data = new byte[]{'c', 'o', 'f', 'f', 'e', 'e'};\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                // Write the content in two chunks.\n                int chunk = data.length / 2;\n                ServletOutputStream output = response.getOutputStream();\n                output.write(data, 0, chunk);\n                sleep(1000);\n                output.write(data, chunk, data.length - chunk);\n            }\n        });\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                return new AfterContentTransformer()\n                {\n                    {\n                        setMaxInputBufferSize(overflow ? data.length / 2 : data.length * 2);\n                    }\n\n                    @Override\n                    public boolean transform(Source source, Sink sink) throws IOException\n                    {\n                        // Consume the stream once.\n                        InputStream input = source.getInputStream();\n                        IO.copy(input, IO.getNullStream());\n\n                        // Reset the stream and re-read it.\n                        input.reset();\n                        IO.copy(input, sink.getOutputStream());\n                        return true;\n                    }\n                };\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertEquals(HttpStatus.OK_200, response.getStatus());\n        Assert.assertArrayEquals(data, response.getContent());\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAfterContentTransformerClosingFilesOnClientRequestException() throws Exception\n    {\n        final Path targetTestsDir = prepareTargetTestsDir();\n\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                IO.copy(request.getInputStream(), IO.getNullStream());\n            }\n        });\n        final CountDownLatch destroyLatch = new CountDownLatch(1);\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newClientRequestContentTransformer(HttpServletRequest clientRequest, Request proxyRequest)\n            {\n                return new AfterContentTransformer()\n                {\n                    {\n                        setOverflowDirectory(targetTestsDir);\n                        setMaxInputBufferSize(0);\n                        setMaxOutputBufferSize(0);\n                    }\n\n                    @Override\n                    public void transform(Source source, Sink sink) throws IOException\n                    {\n                        IO.copy(source.getInputStream(), sink.getOutputStream());\n                    }\n\n                    @Override\n                    public void destroy()\n                    {\n                        super.destroy();\n                        destroyLatch.countDown();\n                    }\n                };\n            }\n        });\n        long idleTimeout = 1000;\n        proxyConnector.setIdleTimeout(idleTimeout);\n        startClient();\n\n        // Send only part of the content; the proxy will idle timeout.\n        final byte[] data = new byte[]{'c', 'a', 'f', 'e'};\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .header(HttpHeader.CONNECTION, HttpHeaderValue.CLOSE.asString())\n                .content(new BytesContentProvider(data)\n                {\n                    @Override\n                    public long getLength()\n                    {\n                        return data.length + 1;\n                    }\n                })\n                .timeout(5 * idleTimeout, TimeUnit.MILLISECONDS)\n                .send();\n\n        Assert.assertTrue(destroyLatch.await(5 * idleTimeout, TimeUnit.MILLISECONDS));\n        Assert.assertEquals(HttpStatus.GATEWAY_TIMEOUT_504, response.getStatus());\n    }","id":31215,"modified_method":"@Test\n    public void testAfterContentTransformerClosingFilesOnClientRequestException() throws Exception\n    {\n        final Path targetTestsDir = prepareTargetTestsDir();\n\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                IO.copy(request.getInputStream(), IO.getNullStream());\n            }\n        });\n        final CountDownLatch destroyLatch = new CountDownLatch(1);\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newClientRequestContentTransformer(HttpServletRequest clientRequest, Request proxyRequest)\n            {\n                return new AfterContentTransformer()\n                {\n                    {\n                        setOverflowDirectory(targetTestsDir);\n                        setMaxInputBufferSize(0);\n                        setMaxOutputBufferSize(0);\n                    }\n\n                    @Override\n                    public boolean transform(Source source, Sink sink) throws IOException\n                    {\n                        IO.copy(source.getInputStream(), sink.getOutputStream());\n                        return true;\n                    }\n\n                    @Override\n                    public void destroy()\n                    {\n                        super.destroy();\n                        destroyLatch.countDown();\n                    }\n                };\n            }\n        });\n        long idleTimeout = 1000;\n        proxyConnector.setIdleTimeout(idleTimeout);\n        startClient();\n\n        // Send only part of the content; the proxy will idle timeout.\n        final byte[] data = new byte[]{'c', 'a', 'f', 'e'};\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .header(HttpHeader.CONNECTION, HttpHeaderValue.CLOSE.asString())\n                .content(new BytesContentProvider(data)\n                {\n                    @Override\n                    public long getLength()\n                    {\n                        return data.length + 1;\n                    }\n                })\n                .timeout(5 * idleTimeout, TimeUnit.MILLISECONDS)\n                .send();\n\n        Assert.assertTrue(destroyLatch.await(5 * idleTimeout, TimeUnit.MILLISECONDS));\n        Assert.assertEquals(HttpStatus.GATEWAY_TIMEOUT_504, response.getStatus());\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void startProxy(HttpServlet proxyServlet, Map<String, String> initParams) throws Exception\n    {\n        QueuedThreadPool proxyPool = new QueuedThreadPool();\n        proxyPool.setName(\"proxy\");\n        proxy = new Server(proxyPool);\n\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSendDateHeader(false);\n        configuration.setSendServerVersion(false);\n        String value = initParams.get(\"outputBufferSize\");\n        if (value != null)\n            configuration.setOutputBufferSize(Integer.valueOf(value));\n        proxyConnector = new ServerConnector(proxy, new HttpConnectionFactory(configuration));\n        proxy.addConnector(proxyConnector);\n\n        ServletContextHandler proxyContext = new ServletContextHandler(proxy, \"/\", true, false);\n        ServletHolder proxyServletHolder = new ServletHolder(proxyServlet);\n        proxyServletHolder.setInitParameters(initParams);\n        proxyContext.addServlet(proxyServletHolder, \"/*\");\n\n        proxy.start();\n    }","id":31216,"modified_method":"private void startProxy(AsyncMiddleManServlet proxyServlet, Map<String, String> initParams) throws Exception\n    {\n        QueuedThreadPool proxyPool = new QueuedThreadPool();\n        proxyPool.setName(\"proxy\");\n        proxy = new Server(proxyPool);\n\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSendDateHeader(false);\n        configuration.setSendServerVersion(false);\n        String value = initParams.get(\"outputBufferSize\");\n        if (value != null)\n            configuration.setOutputBufferSize(Integer.valueOf(value));\n        proxyConnector = new ServerConnector(proxy, new HttpConnectionFactory(configuration));\n        proxy.addConnector(proxyConnector);\n\n        ServletContextHandler proxyContext = new ServletContextHandler(proxy, \"/\", true, false);\n        ServletHolder proxyServletHolder = new ServletHolder(proxyServlet);\n        proxyServletHolder.setInitParameters(initParams);\n        proxyContext.addServlet(proxyServletHolder, \"/*\");\n\n        proxy.start();\n\n        ((StdErrLog)proxyServlet._log).setHideStacks(true);\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAfterContentTransformerOverflowingToDisk() throws Exception\n    {\n        // Make sure the temporary directory we use exists and it's empty.\n        final Path targetTestsDir = prepareTargetTestsDir();\n\n        final String key0 = \"id\";\n        long value0 = 1;\n        final String key1 = \"channel\";\n        String value1 = \"foo\";\n        final String json = \"{ \\\"\" + key0 + \"\\\":\" + value0 + \", \\\"\" + key1 + \"\\\":\\\"\" + value1 + \"\\\" }\";\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                response.getOutputStream().write(json.getBytes(StandardCharsets.UTF_8));\n            }\n        });\n        final String inputPrefix = \"in_\";\n        final String outputPrefix = \"out_\";\n        final String key2 = \"c\";\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                AfterContentTransformer transformer = new AfterContentTransformer()\n                {\n                    @Override\n                    public void transform(Source source, Sink sink) throws IOException\n                    {\n                        InputStream input = source.getInputStream();\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, Object> obj = (Map<String, Object>)JSON.parse(new InputStreamReader(input, \"UTF-8\"));\n                        // Transform the object.\n                        obj.put(key2, obj.remove(key1));\n                        try (OutputStream output = sink.getOutputStream())\n                        {\n                            output.write(JSON.toString(obj).getBytes(StandardCharsets.UTF_8));\n                        }\n                    }\n                };\n                transformer.setOverflowDirectory(targetTestsDir);\n                int maxBufferSize = json.length() / 4;\n                transformer.setMaxInputBufferSize(maxBufferSize);\n                transformer.setInputFilePrefix(inputPrefix);\n                transformer.setMaxOutputBufferSize(maxBufferSize);\n                transformer.setOutputFilePrefix(outputPrefix);\n                return transformer;\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertEquals(200, response.getStatus());\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> obj = (Map<String, Object>)JSON.parse(response.getContentAsString());\n        Assert.assertNotNull(obj);\n        Assert.assertEquals(2, obj.size());\n        Assert.assertEquals(value0, obj.get(key0));\n        Assert.assertEquals(value1, obj.get(key2));\n        // Make sure the files do not exist.\n        try (DirectoryStream<Path> paths = Files.newDirectoryStream(targetTestsDir, inputPrefix + \"*.*\"))\n        {\n            Assert.assertFalse(paths.iterator().hasNext());\n        }\n        try (DirectoryStream<Path> paths = Files.newDirectoryStream(targetTestsDir, outputPrefix + \"*.*\"))\n        {\n            Assert.assertFalse(paths.iterator().hasNext());\n        }\n    }","id":31217,"modified_method":"@Test\n    public void testAfterContentTransformerOverflowingToDisk() throws Exception\n    {\n        // Make sure the temporary directory we use exists and it's empty.\n        final Path targetTestsDir = prepareTargetTestsDir();\n\n        final String key0 = \"id\";\n        long value0 = 1;\n        final String key1 = \"channel\";\n        String value1 = \"foo\";\n        final String json = \"{ \\\"\" + key0 + \"\\\":\" + value0 + \", \\\"\" + key1 + \"\\\":\\\"\" + value1 + \"\\\" }\";\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                response.getOutputStream().write(json.getBytes(StandardCharsets.UTF_8));\n            }\n        });\n        final String inputPrefix = \"in_\";\n        final String outputPrefix = \"out_\";\n        final String key2 = \"c\";\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                AfterContentTransformer transformer = new AfterContentTransformer()\n                {\n                    @Override\n                    public boolean transform(Source source, Sink sink) throws IOException\n                    {\n                        InputStream input = source.getInputStream();\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, Object> obj = (Map<String, Object>)JSON.parse(new InputStreamReader(input, \"UTF-8\"));\n                        // Transform the object.\n                        obj.put(key2, obj.remove(key1));\n                        try (OutputStream output = sink.getOutputStream())\n                        {\n                            output.write(JSON.toString(obj).getBytes(StandardCharsets.UTF_8));\n                            return true;\n                        }\n                    }\n                };\n                transformer.setOverflowDirectory(targetTestsDir);\n                int maxBufferSize = json.length() / 4;\n                transformer.setMaxInputBufferSize(maxBufferSize);\n                transformer.setInputFilePrefix(inputPrefix);\n                transformer.setMaxOutputBufferSize(maxBufferSize);\n                transformer.setOutputFilePrefix(outputPrefix);\n                return transformer;\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertEquals(200, response.getStatus());\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> obj = (Map<String, Object>)JSON.parse(response.getContentAsString());\n        Assert.assertNotNull(obj);\n        Assert.assertEquals(2, obj.size());\n        Assert.assertEquals(value0, obj.get(key0));\n        Assert.assertEquals(value1, obj.get(key2));\n        // Make sure the files do not exist.\n        try (DirectoryStream<Path> paths = Files.newDirectoryStream(targetTestsDir, inputPrefix + \"*.*\"))\n        {\n            Assert.assertFalse(paths.iterator().hasNext());\n        }\n        try (DirectoryStream<Path> paths = Files.newDirectoryStream(targetTestsDir, outputPrefix + \"*.*\"))\n        {\n            Assert.assertFalse(paths.iterator().hasNext());\n        }\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAfterContentTransformerClosingFilesOnServerResponseException() throws Exception\n    {\n        final Path targetTestsDir = prepareTargetTestsDir();\n\n        final CountDownLatch serviceLatch = new CountDownLatch(1);\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                response.setHeader(HttpHeader.CONNECTION.asString(), HttpHeaderValue.CLOSE.asString());\n                response.setContentLength(2);\n                // Send only part of the content.\n                OutputStream output = response.getOutputStream();\n                output.write('x');\n                output.flush();\n                serviceLatch.countDown();\n            }\n        });\n        final CountDownLatch destroyLatch = new CountDownLatch(1);\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                return new AfterContentTransformer()\n                {\n                    {\n                        setOverflowDirectory(targetTestsDir);\n                        setMaxInputBufferSize(0);\n                        setMaxOutputBufferSize(0);\n                    }\n\n                    @Override\n                    public void transform(Source source, Sink sink) throws IOException\n                    {\n                        IO.copy(source.getInputStream(), sink.getOutputStream());\n                    }\n\n                    @Override\n                    public void destroy()\n                    {\n                        super.destroy();\n                        destroyLatch.countDown();\n                    }\n                };\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertTrue(serviceLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(destroyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertEquals(HttpStatus.BAD_GATEWAY_502, response.getStatus());\n    }","id":31218,"modified_method":"@Test\n    public void testAfterContentTransformerClosingFilesOnServerResponseException() throws Exception\n    {\n        final Path targetTestsDir = prepareTargetTestsDir();\n\n        final CountDownLatch serviceLatch = new CountDownLatch(1);\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                response.setHeader(HttpHeader.CONNECTION.asString(), HttpHeaderValue.CLOSE.asString());\n                response.setContentLength(2);\n                // Send only part of the content.\n                OutputStream output = response.getOutputStream();\n                output.write('x');\n                output.flush();\n                serviceLatch.countDown();\n            }\n        });\n        final CountDownLatch destroyLatch = new CountDownLatch(1);\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                return new AfterContentTransformer()\n                {\n                    {\n                        setOverflowDirectory(targetTestsDir);\n                        setMaxInputBufferSize(0);\n                        setMaxOutputBufferSize(0);\n                    }\n\n                    @Override\n                    public boolean transform(Source source, Sink sink) throws IOException\n                    {\n                        IO.copy(source.getInputStream(), sink.getOutputStream());\n                        return true;\n                    }\n\n                    @Override\n                    public void destroy()\n                    {\n                        super.destroy();\n                        destroyLatch.countDown();\n                    }\n                };\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertTrue(serviceLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(destroyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertEquals(HttpStatus.BAD_GATEWAY_502, response.getStatus());\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAfterContentTransformer() throws Exception\n    {\n        final String key0 = \"id\";\n        long value0 = 1;\n        final String key1 = \"channel\";\n        String value1 = \"foo\";\n        final String json = \"{ \\\"\" + key0 + \"\\\":\" + value0 + \", \\\"\" + key1 + \"\\\":\\\"\" + value1 + \"\\\" }\";\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                response.getOutputStream().write(json.getBytes(StandardCharsets.UTF_8));\n            }\n        });\n        final String key2 = \"c\";\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                return new AfterContentTransformer()\n                {\n                    @Override\n                    public void transform(Source source, Sink sink) throws IOException\n                    {\n                        InputStream input = source.getInputStream();\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, Object> obj = (Map<String, Object>)JSON.parse(new InputStreamReader(input, \"UTF-8\"));\n                        // Transform the object.\n                        obj.put(key2, obj.remove(key1));\n                        try (OutputStream output = sink.getOutputStream())\n                        {\n                            output.write(JSON.toString(obj).getBytes(StandardCharsets.UTF_8));\n                        }\n                    }\n                };\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertEquals(200, response.getStatus());\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> obj = (Map<String, Object>)JSON.parse(response.getContentAsString());\n        Assert.assertNotNull(obj);\n        Assert.assertEquals(2, obj.size());\n        Assert.assertEquals(value0, obj.get(key0));\n        Assert.assertEquals(value1, obj.get(key2));\n    }","id":31219,"modified_method":"@Test\n    public void testAfterContentTransformer() throws Exception\n    {\n        final String key0 = \"id\";\n        long value0 = 1;\n        final String key1 = \"channel\";\n        String value1 = \"foo\";\n        final String json = \"{ \\\"\" + key0 + \"\\\":\" + value0 + \", \\\"\" + key1 + \"\\\":\\\"\" + value1 + \"\\\" }\";\n        startServer(new HttpServlet()\n        {\n            @Override\n            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n            {\n                response.getOutputStream().write(json.getBytes(StandardCharsets.UTF_8));\n            }\n        });\n        final String key2 = \"c\";\n        startProxy(new AsyncMiddleManServlet()\n        {\n            @Override\n            protected ContentTransformer newServerResponseContentTransformer(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)\n            {\n                return new AfterContentTransformer()\n                {\n                    @Override\n                    public boolean transform(Source source, Sink sink) throws IOException\n                    {\n                        InputStream input = source.getInputStream();\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, Object> obj = (Map<String, Object>)JSON.parse(new InputStreamReader(input, \"UTF-8\"));\n                        // Transform the object.\n                        obj.put(key2, obj.remove(key1));\n                        try (OutputStream output = sink.getOutputStream())\n                        {\n                            output.write(JSON.toString(obj).getBytes(StandardCharsets.UTF_8));\n                            return true;\n                        }\n                    }\n                };\n            }\n        });\n        startClient();\n\n        ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort())\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertEquals(200, response.getStatus());\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> obj = (Map<String, Object>)JSON.parse(response.getContentAsString());\n        Assert.assertNotNull(obj);\n        Assert.assertEquals(2, obj.size());\n        Assert.assertEquals(value0, obj.get(key0));\n        Assert.assertEquals(value1, obj.get(key2));\n    }","commit_id":"4573e20033208579121e40a0e59c80ef227f63ef","url":"https://github.com/eclipse/jetty.project"},{"original_method":"BeforeRunStepsPanel(StepsBeforeRunListener listener) {\n    myListener = listener;\n    myModel = new CollectionListModel<BeforeRunTask>();\n    myList = new JBList(myModel);\n    myList.getEmptyText().setText(ExecutionBundle.message(\"before.launch.panel.empty\"));\n    myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myList.setCellRenderer(new MyListCellRenderer());\n\n    myModel.addListDataListener(new ListDataListener() {\n      @Override\n      public void intervalAdded(ListDataEvent e) {\n        adjustVisibleRowCount();\n        updateText();\n      }\n\n      @Override\n      public void intervalRemoved(ListDataEvent e) {\n        adjustVisibleRowCount();\n        updateText();\n      }\n\n      @Override\n      public void contentsChanged(ListDataEvent e) {\n      }\n\n      private void adjustVisibleRowCount() {\n        myList.setVisibleRowCount(Math.max(4, Math.min(8, myModel.getSize())));\n      }\n    });\n\n    ToolbarDecorator myDecorator = ToolbarDecorator.createDecorator(myList);\n    if (!SystemInfo.isMac) {\n      myDecorator.setAsUsualTopToolbar();\n    }\n    myDecorator.setEditAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        int index = myList.getSelectedIndex();\n        if (index == -1)\n          return;\n        Pair<BeforeRunTask, BeforeRunTaskProvider<BeforeRunTask>> selection = getSelection();\n        if (selection == null)\n          return;\n        BeforeRunTask task = selection.getFirst();\n        BeforeRunTaskProvider<BeforeRunTask> provider = selection.getSecond();\n        if (provider.configureTask(myRunConfiguration, task)) {\n          myModel.setElementAt(task, index);\n        }\n      }\n    });\n    myDecorator.setEditActionUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        Pair<BeforeRunTask, BeforeRunTaskProvider<BeforeRunTask>> selection = getSelection();\n        return selection != null && selection.getSecond().isConfigurable();\n      }\n    });\n    myDecorator.setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        doAddAction(button);\n      }\n    });\n    myDecorator.setAddActionUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        return checkBeforeRunTasksAbility(true);\n      }\n    });\n\n    myShowSettingsBeforeRunCheckBox = new JCheckBox(ExecutionBundle.message(\"configuration.edit.before.run\"));\n    myShowSettingsBeforeRunCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        updateText();\n      }\n    });\n\n    myPanel = myDecorator.createPanel();\n\n    JPanel wrapper = new JPanel(new BorderLayout());\n    wrapper.add(myShowSettingsBeforeRunCheckBox, BorderLayout.NORTH);\n    wrapper.add(myPanel, BorderLayout.CENTER);\n    setContent(wrapper);\n  }","id":31220,"modified_method":"BeforeRunStepsPanel(StepsBeforeRunListener listener) {\n    myListener = listener;\n    myModel = new CollectionListModel<BeforeRunTask>();\n    myList = new JBList(myModel);\n    myList.getEmptyText().setText(ExecutionBundle.message(\"before.launch.panel.empty\"));\n    myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myList.setCellRenderer(new MyListCellRenderer());\n\n    myModel.addListDataListener(new ListDataListener() {\n      @Override\n      public void intervalAdded(ListDataEvent e) {\n        adjustVisibleRowCount();\n        updateText();\n      }\n\n      @Override\n      public void intervalRemoved(ListDataEvent e) {\n        adjustVisibleRowCount();\n        updateText();\n      }\n\n      @Override\n      public void contentsChanged(ListDataEvent e) {\n      }\n\n      private void adjustVisibleRowCount() {\n        myList.setVisibleRowCount(Math.max(4, Math.min(8, myModel.getSize())));\n      }\n    });\n\n    ToolbarDecorator myDecorator = ToolbarDecorator.createDecorator(myList);\n    if (!SystemInfo.isMac) {\n      myDecorator.setAsUsualTopToolbar();\n    }\n    myDecorator.setEditAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        int index = myList.getSelectedIndex();\n        if (index == -1)\n          return;\n        Pair<BeforeRunTask, BeforeRunTaskProvider<BeforeRunTask>> selection = getSelection();\n        if (selection == null)\n          return;\n        BeforeRunTask task = selection.getFirst();\n        BeforeRunTaskProvider<BeforeRunTask> provider = selection.getSecond();\n        if (provider.configureTask(myRunConfiguration, task)) {\n          myModel.setElementAt(task, index);\n        }\n      }\n    });\n    myDecorator.setEditActionUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        Pair<BeforeRunTask, BeforeRunTaskProvider<BeforeRunTask>> selection = getSelection();\n        return selection != null && selection.getSecond().isConfigurable();\n      }\n    });\n    myDecorator.setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        doAddAction(button);\n      }\n    });\n    myDecorator.setAddActionUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        return checkBeforeRunTasksAbility(true);\n      }\n    });\n\n    myShowSettingsBeforeRunCheckBox = new JCheckBox(ExecutionBundle.message(\"configuration.edit.before.run\"));\n    myShowSettingsBeforeRunCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        updateText();\n      }\n    });\n\n    myPanel = myDecorator.createPanel();\n\n    JPanel wrapper = new JPanel(new BorderLayout());\n    wrapper.add(myShowSettingsBeforeRunCheckBox, BorderLayout.NORTH);\n    wrapper.add(myPanel, BorderLayout.CENTER);\n    setContent(wrapper);\n    setExpanded(PropertiesComponent.getInstance().getBoolean(EXPAND_PROPERTY_KEY, false));\n    addChangeListener(new ChangeListener() {\n      @Override\n      public void stateChanged(ChangeEvent e) {\n        PropertiesComponent.getInstance().setValue(EXPAND_PROPERTY_KEY, String.valueOf(isExpanded()));\n      }\n    });\n  }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void doReset(RunnerAndConfigurationSettings settings) {\n    myRunConfiguration = settings.getConfiguration();\n\n    originalTasks.clear();\n    originalTasks.addAll(RunManagerImpl.getInstanceImpl(myRunConfiguration.getProject()).getBeforeRunTasks(myRunConfiguration));\n    myModel.replaceAll(originalTasks);\n    myShowSettingsBeforeRunCheckBox.setSelected(settings.isEditBeforeRun());\n    myShowSettingsBeforeRunCheckBox.setEnabled(!(isUnknown()));\n    myPanel.setVisible(checkBeforeRunTasksAbility(false));\n  }","id":31221,"modified_method":"void doReset(RunnerAndConfigurationSettings settings) {\n    myRunConfiguration = settings.getConfiguration();\n\n    originalTasks.clear();\n    RunManagerImpl runManager = RunManagerImpl.getInstanceImpl(myRunConfiguration.getProject());\n    originalTasks.addAll(runManager.getBeforeRunTasks(myRunConfiguration));\n    myModel.replaceAll(originalTasks);\n    myShowSettingsBeforeRunCheckBox.setSelected(settings.isEditBeforeRun());\n    myShowSettingsBeforeRunCheckBox.setEnabled(!(isUnknown()));\n    myPanel.setVisible(checkBeforeRunTasksAbility(false));\n    updateText();\n  }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setExpanded(boolean expanded) {\n    if (myExpanded == expanded) {\n      return;\n    }\n    myLabel.setIcon(expanded ? UP : DOWN);\n    if (myContent != null) {\n      if (expanded) {\n        add(myContent, BorderLayout.CENTER);\n      }\n      else {\n        remove(myContent);\n      }\n    }\n    myExpanded = expanded;\n    revalidate();\n    repaint();\n  }","id":31222,"modified_method":"public void setExpanded(boolean expanded) {\n    if (myExpanded == expanded) {\n      return;\n    }\n    myLabel.getLabel().setIcon(expanded ? UP : DOWN);\n    if (myContent != null) {\n      if (expanded) {\n        add(myContent, BorderLayout.CENTER);\n      }\n      else {\n        remove(myContent);\n      }\n    }\n    myExpanded = expanded;\n    revalidate();\n    repaint();\n    ChangeEvent changeEvent = new ChangeEvent(this);\n    for (ChangeListener listener : myListeners) {\n      listener.stateChanged(changeEvent);\n    }\n  }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void paintComponent(Graphics g) {\n      ActionButtonLook.IDEA_LOOK.paintBackground(g, this);\n      ActionButtonLook.IDEA_LOOK.paintBorder(g, this);\n      super.paintComponent(g);\n      if (myLine) {\n        g.setColor(GroupedElementsRenderer.POPUP_SEPARATOR_FOREGROUND);\n        Icon icon = getIcon();\n        final FontMetrics fm = getFontMetrics(getFont());\n        String text = getText();\n        Border border = getBorder();\n        Insets insets = border != null ? border.getBorderInsets(this) : new Insets(0, 0, 0, 0);\n        int width = (icon != null ? icon.getIconWidth() : 0)\n                    + (text != null ? getIconTextGap() + fm.stringWidth(text) : 0)\n                    + insets.left;\n        final int lineY = (UIUtil.isUnderNativeMacLookAndFeel() ? 1 : 3) + fm.getHeight() / 2;\n        g.drawLine(width + 3, lineY, getWidth() - 3 - insets.right, lineY);\n      }\n    }","id":31223,"modified_method":"@Override\n    public void paintComponent(Graphics g) {\n      super.paintComponent(g);\n      ActionButtonLook.IDEA_LOOK.paintBackground(g, this);\n      ActionButtonLook.IDEA_LOOK.paintBorder(g, this);\n    }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ButtonLabel(boolean withSeparatorLine) {\n      myLine = withSeparatorLine;\n      setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n      setIconTextGap(2);\n      enableEvents(AWTEvent.MOUSE_EVENT_MASK);\n    }","id":31224,"modified_method":"private ButtonLabel() {\n      setBorder(BorderFactory.createEmptyBorder(4, 0, 4, 0));\n      myLabel.setIconTextGap(2);\n      enableEvents(AWTEvent.MOUSE_EVENT_MASK);\n    }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DropDownPanel(@Nullable String title, @Nullable JComponent content, boolean withSeparatorLine) {\n    super(new BorderLayout());\n    myLabel = new ButtonLabel(withSeparatorLine);\n    add(myLabel, BorderLayout.NORTH);\n    setTitle(title);\n    setContent(content);\n    setExpanded(false);\n  }","id":31225,"modified_method":"public DropDownPanel(@Nullable String title, @Nullable JComponent content) {\n    super(new BorderLayout());\n    myLabel = new ButtonLabel();\n    add(myLabel, BorderLayout.NORTH);\n    setTitle(title);\n    setContent(content);\n    setExpanded(false);\n  }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DropDownPanel() {\n    this(null, null, true);\n  }","id":31226,"modified_method":"public DropDownPanel() {\n    this(null, null);\n  }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n  public String toString() {\r\n    return getType() + \": \" + getName();\r\n  }","id":31227,"modified_method":"@Override\r\n  public String toString() {\r\n    return getType().getDisplayName() + \": \" + getName();\r\n  }","commit_id":"37fdf462777e60cd5e1ab5ab71ebfa4b70eead52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    customizeComponent((T) value, isSelected);\n    return this;\n  }","id":31228,"modified_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    @SuppressWarnings(\"unchecked\") final T t = (T)value;\n    customizeComponent(t, table, isSelected);\n    return this;\n  }","commit_id":"8a9ee965192ac0060c23aea614e7b3782bc7bea9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellEditorComponent(JTable table, final Object value, boolean isSelected, final int row, final int column) {\n    myValue = (T) value;\n    customizeComponent((T) value, isSelected);\n\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        showPopup((T) value, row);\n      }\n    });\n\n    return this;\n  }","id":31229,"modified_method":"public Component getTableCellEditorComponent(JTable table, final Object value, boolean isSelected, final int row, final int column) {\n    @SuppressWarnings(\"unchecked\") final T t = (T)value;\n    myValue = t;\n    customizeComponent(t, table, isSelected);\n\n    //noinspection SSBasedInspection\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        showPopup(t, row);\n      }\n    });\n\n    return this;\n  }","commit_id":"8a9ee965192ac0060c23aea614e7b3782bc7bea9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    final Rectangle r = getBounds();\n    final Insets i = getInsets();\n\n    if (getText() != null && getText().length() != 0) ARROW_ICON.paintIcon(this, g, r.width - i.right - ARROW_ICON.getIconWidth(), i.top);\n  }","id":31230,"modified_method":"@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    if (!StringUtil.isEmpty(getText())) {\n      final Rectangle r = getBounds();\n      final Insets i = getInsets();\n      final int x = r.width - i.right - ARROW_ICON.getIconWidth();\n      final int y = i.top + (r.height - i.top - i.bottom - ARROW_ICON.getIconHeight()) / 2;\n      ARROW_ICON.paintIcon(this, g, x, y);\n    }\n  }","commit_id":"8a9ee965192ac0060c23aea614e7b3782bc7bea9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void customizeComponent(T value, boolean isSelected) {\n    setOpaque(true);\n    setText(value == null ? \"\" : getTextFor(value));\n    setBackground(isSelected ? UIUtil.getTableSelectionBackground() : UIUtil.getTableBackground());\n    setForeground(isSelected ? UIUtil.getTableSelectionForeground() : UIUtil.getTableForeground());\n  }","id":31231,"modified_method":"/** @deprecated use {@linkplain #customizeComponent(Object, javax.swing.JTable, boolean)} (to remove in IDEA 12) */\n  protected void customizeComponent(T value, boolean isSelected) {\n    setOpaque(true);\n    setText(value == null ? \"\" : getTextFor(value));\n    setBackground(isSelected ? UIUtil.getTableSelectionBackground() : UIUtil.getTableBackground());\n    setForeground(isSelected ? UIUtil.getTableSelectionForeground() : UIUtil.getTableForeground());\n  }","commit_id":"8a9ee965192ac0060c23aea614e7b3782bc7bea9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void paintComponent(Graphics g)\n        {\n            super.paintComponent(g);\n\n            g = g.create();\n            try\n            {\n                AntialiasingManager.activateAntialiasing(g);\n\n                Graphics2D g2 = (Graphics2D) g;\n\n                if (bgImage != null)\n                    g2.drawImage(bgImage, 30, 30, null);\n\n                g2.drawImage(ImageLoader\n                    .getImage(ImageLoader.AUTH_WINDOW_BACKGROUND), 0, 0, this\n                    .getWidth(), this.getHeight(), null);\n            }\n            finally\n            {\n                g.dispose();\n            }\n        }","id":31232,"modified_method":"protected void paintComponent(Graphics g)\n        {\n            super.paintComponent(g);\n\n            g = g.create();\n\n            AntialiasingManager.activateAntialiasing(g);\n\n            Graphics2D g2 = (Graphics2D) g;\n\n            if (bgImage != null)\n                g2.drawImage(bgImage, 30, 30, null);\n        }","commit_id":"7471f75d9ba7c94b13350f64ca05b1923c8af22c","url":"https://github.com/jitsi/jitsi"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private <T extends Entity> void populateSpec(EntitySpec<T> spec, Set<String> encounteredRegisteredTypeIds) {\n        String name, source=null, templateId=null, planId=null;\n        if (template.isPresent()) {\n            name = template.get().getName();\n            templateId = template.get().getId();\n            source = template.get().getSourceCode();\n        } else {\n            name = (String)attrs.getStringKey(\"name\");\n        }\n        planId = (String)attrs.getStringKey(\"id\");\n        if (planId==null)\n            planId = (String) attrs.getStringKey(BrooklynCampConstants.PLAN_ID_FLAG);\n\n        Object childrenObj = attrs.getStringKey(BrooklynCampReservedKeys.BROOKLYN_CHILDREN);\n        if (childrenObj != null) {\n            Iterable<Map<String,?>> children = (Iterable<Map<String,?>>)childrenObj;\n            for (Map<String,?> childAttrs : children) {\n                BrooklynComponentTemplateResolver entityResolver = BrooklynComponentTemplateResolver.Factory.newInstance(loader, childAttrs);\n                // encounteredRegisteredTypeIds must contain the items currently being loaded (the dependency chain),\n                // but not parent items in this type already resolved.\n                EntitySpec<? extends Entity> childSpec = entityResolver.resolveSpec(encounteredRegisteredTypeIds);\n                spec.child(EntityManagementUtils.unwrapEntity(childSpec));\n            }\n        }\n\n        if (source!=null) {\n            spec.tag(BrooklynTags.newYamlSpecTag(source));\n        }\n\n        if (!Strings.isBlank(name))\n            spec.displayName(name);\n        if (templateId != null)\n            spec.configure(BrooklynCampConstants.TEMPLATE_ID, templateId);\n        if (planId != null)\n            spec.configure(BrooklynCampConstants.PLAN_ID, planId);\n\n        List<Location> childLocations = new BrooklynYamlLocationResolver(mgmt).resolveLocations(attrs.getAllConfig(), true);\n        if (childLocations != null)\n            spec.locations(childLocations);\n\n        decorateSpec(spec, encounteredRegisteredTypeIds);\n    }","id":31233,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private <T extends Entity> void populateSpec(EntitySpec<T> spec, Set<String> encounteredRegisteredTypeIds) {\n        String name, source=null, templateId=null, planId=null;\n        if (template.isPresent()) {\n            name = template.get().getName();\n            templateId = template.get().getId();\n            source = template.get().getSourceCode();\n        } else {\n            name = (String)attrs.getStringKey(\"name\");\n        }\n        planId = (String)attrs.getStringKey(\"id\");\n        if (planId==null)\n            planId = (String) attrs.getStringKey(BrooklynCampConstants.PLAN_ID_FLAG);\n\n        Object childrenObj = attrs.getStringKey(BrooklynCampReservedKeys.BROOKLYN_CHILDREN);\n        if (childrenObj != null) {\n            Iterable<Map<String,?>> children = (Iterable<Map<String,?>>)childrenObj;\n            for (Map<String,?> childAttrs : children) {\n                BrooklynComponentTemplateResolver entityResolver = BrooklynComponentTemplateResolver.Factory.newInstance(loader, childAttrs);\n                // encounteredRegisteredTypeIds must contain the items currently being loaded (the dependency chain),\n                // but not parent items in this type already resolved.\n                EntitySpec<? extends Entity> childSpec = entityResolver.resolveSpec(encounteredRegisteredTypeIds);\n                spec.child(EntityManagementUtils.unwrapEntity(childSpec));\n            }\n        }\n\n        if (source!=null) {\n            spec.tag(BrooklynTags.newYamlSpecTag(source));\n        }\n\n        if (!Strings.isBlank(name))\n            spec.displayName(name);\n        if (templateId != null)\n            spec.configure(BrooklynCampConstants.TEMPLATE_ID, templateId);\n        if (planId != null)\n            spec.configure(BrooklynCampConstants.PLAN_ID, planId);\n\n        List<Location> locations = new BrooklynYamlLocationResolver(mgmt).resolveLocations(attrs.getAllConfig(), true);\n        if (locations != null) {\n            // override locations defined in the type if locations are specified here\n            // empty list can be used by caller to clear, so they are inherited\n            spec.clearLocations();\n            spec.locations(locations);\n        }\n\n        decorateSpec(spec, encounteredRegisteredTypeIds);\n    }","commit_id":"70ed345e4b4cb992d92f363f250000b4c00558ae","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** Modifies the child so it includes the inessential setup of its parent,\n     * for use when unwrapping specific children, but a name or other item may have been set on the parent.\n     * See {@link #WRAPPER_APP_MARKER}. */\n    private static void mergeWrapperParentSpecToChildEntity(EntitySpec<? extends Application> wrapperParent, EntitySpec<?> wrappedChild) {\n        if (Strings.isNonEmpty(wrapperParent.getDisplayName()))\n            wrappedChild.displayName(wrapperParent.getDisplayName());\n        if (!wrapperParent.getLocations().isEmpty())\n            wrappedChild.locations(wrapperParent.getLocations());\n        if (!wrapperParent.getParameters().isEmpty()) {\n            wrappedChild.parameters(wrapperParent.getParameters());\n        }\n\n        // NB: this clobbers child config; might prefer to deeply merge maps etc\n        // (but this should not be surprising, as unwrapping is often parameterising the nested blueprint, so outer config should dominate) \n        Map<ConfigKey<?>, Object> configWithoutWrapperMarker = Maps.filterKeys(wrapperParent.getConfig(), Predicates.not(Predicates.<ConfigKey<?>>equalTo(EntityManagementUtils.WRAPPER_APP_MARKER)));\n        wrappedChild.configure(configWithoutWrapperMarker);\n        wrappedChild.configure(wrapperParent.getFlags());\n        \n        // TODO copying tags to all entities is not ideal;\n        // in particular the BrooklynTags.YAML_SPEC tag will show all entities if the root has multiple\n        wrappedChild.tags(wrapperParent.getTags());\n    }","id":31234,"modified_method":"/** Modifies the child so it includes the inessential setup of its parent,\n     * for use when unwrapping specific children, but a name or other item may have been set on the parent.\n     * See {@link #WRAPPER_APP_MARKER}. */\n    private static void mergeWrapperParentSpecToChildEntity(EntitySpec<? extends Application> wrapperParent, EntitySpec<?> wrappedChild) {\n        if (Strings.isNonEmpty(wrapperParent.getDisplayName())) {\n            wrappedChild.displayName(wrapperParent.getDisplayName());\n        }\n        if (!wrapperParent.getLocations().isEmpty()) {\n            wrappedChild.locations(wrapperParent.getLocations());\n        }\n        if (!wrapperParent.getParameters().isEmpty()) {\n            wrappedChild.parameters(wrapperParent.getParameters());\n        }\n        if (wrappedChild.getCatalogItemId()==null) {\n            wrappedChild.catalogItemId(wrapperParent.getCatalogItemId());\n        }\n\n        // NB: this clobbers child config; might prefer to deeply merge maps etc\n        // (but this should not be surprising, as unwrapping is often parameterising the nested blueprint, so outer config should dominate) \n        Map<ConfigKey<?>, Object> configWithoutWrapperMarker = Maps.filterKeys(wrapperParent.getConfig(), Predicates.not(Predicates.<ConfigKey<?>>equalTo(EntityManagementUtils.WRAPPER_APP_MARKER)));\n        wrappedChild.configure(configWithoutWrapperMarker);\n        wrappedChild.configure(wrapperParent.getFlags());\n        \n        // copying tags to all entities may be something the caller wants to control,\n        // e.g. if we're creating a list of entities which will be added,\n        // ignoring the parent Application holder; \n        // in that case each child's BrooklynTags.YAML_SPEC tag will show all entities;\n        // but in the normal case where we're unwrapping one, it's probably right.\n        wrappedChild.tags(wrapperParent.getTags());\n    }","commit_id":"649a08d614d8afb9404e45c17f4adaeacd6db4d1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n\t * Retrieve {@link ApplicationContext} resource locations for the supplied\n\t * {@link Class class}, using the supplied {@link ContextLoader} to\n\t * {@link ContextLoader#processLocations(Class, String...) process} the\n\t * locations.\n\t * <p>\n\t * Note that the {@link ContextConfiguration#inheritLocations()\n\t * inheritLocations} flag of {@link ContextConfiguration\n\t * &#064;ContextConfiguration} will be taken into consideration.\n\t * Specifically, if the <code>inheritLocations<\/code> flag is set to\n\t * <code>true<\/code>, locations defined in the annotated class will be\n\t * appended to the locations defined in superclasses. &#064;param\n\t * contextLoader the ContextLoader to use for processing the locations (must\n\t * not be <code>null<\/code>)\n\t * \n\t * @param clazz the class for which to retrieve the resource locations (must\n\t * not be <code>null<\/code>)\n\t * @return the list of ApplicationContext resource locations for the\n\t * specified class, including locations from superclasses if appropriate\n\t * @throws IllegalArgumentException if {@link ContextConfiguration\n\t * &#064;ContextConfiguration} is not <em>present<\/em> on the supplied class\n\t */\n\tprivate String[] retrieveContextLocations(ContextLoader contextLoader, Class<?> clazz) {\n\t\tAssert.notNull(contextLoader, \"ContextLoader must not be null\");\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\n\t\tList<String> locationsList = new ArrayList<String>();\n\t\tClass<ContextConfiguration> annotationType = ContextConfiguration.class;\n\t\tClass<?> declaringClass = AnnotationUtils.findAnnotationDeclaringClass(annotationType, clazz);\n\t\tAssert.notNull(declaringClass, \"Could not find an 'annotation declaring class' for annotation type [\"\n\t\t\t\t+ annotationType + \"] and class [\" + clazz + \"]\");\n\n\t\twhile (declaringClass != null) {\n\t\t\tContextConfiguration contextConfiguration = declaringClass.getAnnotation(annotationType);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Retrieved @ContextConfiguration [\" + contextConfiguration + \"] for declaring class [\"\n\t\t\t\t\t\t+ declaringClass + \"]\");\n\t\t\t}\n\t\t\tString[] locations = contextLoader.processLocations(declaringClass, contextConfiguration.locations());\n\t\t\tlocationsList.addAll(0, Arrays.<String> asList(locations));\n\t\t\tdeclaringClass = contextConfiguration.inheritLocations() ? AnnotationUtils.findAnnotationDeclaringClass(\n\t\t\t\tannotationType, declaringClass.getSuperclass()) : null;\n\t\t}\n\n\t\treturn locationsList.toArray(new String[locationsList.size()]);\n\t}","id":31235,"modified_method":"/**\n\t * Retrieve {@link ApplicationContext} resource locations for the supplied\n\t * {@link Class class}, using the supplied {@link ContextLoader} to\n\t * {@link ContextLoader#processLocations(Class, String...) process} the\n\t * locations.\n\t * <p>\n\t * Note that the {@link ContextConfiguration#inheritLocations()\n\t * inheritLocations} flag of {@link ContextConfiguration\n\t * &#064;ContextConfiguration} will be taken into consideration.\n\t * Specifically, if the <code>inheritLocations<\/code> flag is set to\n\t * <code>true<\/code>, locations defined in the annotated class will be\n\t * appended to the locations defined in superclasses. &#064;param\n\t * contextLoader the ContextLoader to use for processing the locations (must\n\t * not be <code>null<\/code>)\n\t * \n\t * @param clazz the class for which to retrieve the resource locations (must\n\t * not be <code>null<\/code>)\n\t * @return the list of ApplicationContext resource locations for the\n\t * specified class, including locations from superclasses if appropriate\n\t * @throws IllegalArgumentException if {@link ContextConfiguration\n\t * &#064;ContextConfiguration} is not <em>present<\/em> on the supplied class\n\t */\n\tprivate String[] retrieveContextLocations(ContextLoader contextLoader, Class<?> clazz) {\n\t\tAssert.notNull(contextLoader, \"ContextLoader must not be null\");\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\n\t\tList<String> locationsList = new ArrayList<String>();\n\t\tClass<ContextConfiguration> annotationType = ContextConfiguration.class;\n\t\tClass<?> declaringClass = AnnotationUtils.findAnnotationDeclaringClass(annotationType, clazz);\n\t\tAssert.notNull(declaringClass, \"Could not find an 'annotation declaring class' for annotation type [\"\n\t\t\t\t+ annotationType + \"] and class [\" + clazz + \"]\");\n\n\t\twhile (declaringClass != null) {\n\t\t\tContextConfiguration contextConfiguration = declaringClass.getAnnotation(annotationType);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Retrieved @ContextConfiguration [\" + contextConfiguration + \"] for declaring class [\"\n\t\t\t\t\t\t+ declaringClass + \"]\");\n\t\t\t}\n\n\t\t\tString[] valueLocations = contextConfiguration.value();\n\t\t\tString[] locations = contextConfiguration.locations();\n\t\t\tif (!ObjectUtils.isEmpty(valueLocations) && !ObjectUtils.isEmpty(locations)) {\n\t\t\t\tString msg = \"Test class [\"\n\t\t\t\t\t\t+ declaringClass\n\t\t\t\t\t\t+ \"] has been configured with @ContextConfiguration's 'value' [\"\n\t\t\t\t\t\t+ ObjectUtils.nullSafeToString(valueLocations)\n\t\t\t\t\t\t+ \"] and 'locations' [\"\n\t\t\t\t\t\t+ ObjectUtils.nullSafeToString(locations)\n\t\t\t\t\t\t+ \"] attributes. Only one declaration of resource locations is permitted per @ContextConfiguration annotation.\";\n\t\t\t\tlogger.error(msg);\n\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t}\n\t\t\telse if (!ObjectUtils.isEmpty(valueLocations)) {\n\t\t\t\tlocations = valueLocations;\n\t\t\t}\n\n\t\t\tlocations = contextLoader.processLocations(declaringClass, locations);\n\t\t\tlocationsList.addAll(0, Arrays.<String> asList(locations));\n\t\t\tdeclaringClass = contextConfiguration.inheritLocations() ? AnnotationUtils.findAnnotationDeclaringClass(\n\t\t\t\tannotationType, declaringClass.getSuperclass()) : null;\n\t\t}\n\n\t\treturn locationsList.toArray(new String[locationsList.size()]);\n\t}","commit_id":"781da89d921b42d03cf8c7d39df4d5b9f19e1b9d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private Association(Field f1, Field f2, boolean isOn) {\n        if (f1 == f2)\n            throw new IllegalArgumentException(\"field can't associate to itself: \" + f1);\n        if (f1 == null || f2 == null)\n            throw new IllegalArgumentException(\"null field: \" + f1 + \"; \" + f2);\n        Log.debug(\"Adding association:\\n\\tfield 1: \" + quoteKey(f1) + \"\\n\\tfield 2: \" + quoteKey(f2));\n        field1 = f1;\n        field2 = f2;\n        schema1 = field1.getSchema();\n        schema2 = field2.getSchema();\n        enabled = isOn;\n        if (schema1 == schema2)\n            throw new IllegalArgumentException(\"can't associate fields from the same schema: \" + f1 + \"; \" + f2 + \"; \" + schema1);\n        AllByField.put(f1, this);\n        AllByField.put(f2, this);\n        AllPairsList.add(this);\n    }","id":31236,"modified_method":"private Association(Field f1, Field f2, boolean isOn) {\n        if (f1 == f2)\n            throw new IllegalArgumentException(\"field can't associate to itself: \" + f1);\n        if (f1 == null || f2 == null)\n            throw new IllegalArgumentException(\"null field: \" + f1 + \"; \" + f2);\n        if (DEBUG.SCHEMA)\n            Log.debug(\"Adding association:\"\n                      + \"\\n\\tfield 1: \" + quoteKey(f1) + \" \" + Util.tags(f1)\n                      + \"\\n\\tfield 2: \" + quoteKey(f2) + \" \" + Util.tags(f2));\n        field1 = f1;\n        field2 = f2;\n        schema1 = field1.getSchema();\n        schema2 = field2.getSchema();\n        enabled = isOn;\n        if (schema1 == schema2)\n            throw new IllegalArgumentException(\"can't associate fields from the same schema: \" + f1 + \"; \" + f2 + \"; \" + schema1);\n        AllByField.put(f1, this);\n        AllByField.put(f2, this);\n        AllPairsList.add(this);\n    }","commit_id":"89c7a5ccb9434a6a3af714a6c65e8768d786b4a7","url":"https://github.com/VUE/VUE"},{"original_method":"/** add a global association between the given two fields */\n    public static void add(Field f1, Field f2) {\n        Association a = null;\n        synchronized (AllPairsList) {\n\n            boolean alreadyExists = false;\n            for (Association scan : AllPairsList) {\n                if (scan.field1 == f1 && scan.field2 == f2) {\n                    alreadyExists = true;\n                    if (DEBUG.SCHEMA) Log.debug(\"an association already exists between \" + f1 + \" and \" + f2);\n                    break;\n                }\n            }\n\n            if (!alreadyExists)\n                a = new Association(f1, f2, true);\n        }\n        if (a != null)\n            EventSource.raise(Association.class, new Event(a, Event.ADDED));\n    }","id":31237,"modified_method":"/** add a global association between the given two fields */\n    public static void add(Field f1, Field f2) {\n        Association a = null;\n        synchronized (AllPairsList) {\n\n            boolean alreadyExists = false;\n            for (Association scan : AllPairsList) {\n                if ((scan.field1 == f1 && scan.field2 == f2) ||\n                    (scan.field1 == f2 && scan.field2 == f1)) {\n                    alreadyExists = true;\n                    if (DEBUG.SCHEMA) Log.debug(\"an association already exists between \" + f1 + \" and \" + f2);\n                    break;\n                }\n            }\n\n            if (!alreadyExists)\n                a = new Association(f1, f2, true);\n        }\n        if (a != null)\n            EventSource.raise(Association.class, new Event(a, Event.ADDED));\n    }","commit_id":"89c7a5ccb9434a6a3af714a6c65e8768d786b4a7","url":"https://github.com/VUE/VUE"},{"original_method":"/** for castor de-serialization only */\n    public Schema() {\n        mLocalID = nextLocalID();\n        Log.debug(\"CONSTRUCTED SCHEMA \" + this + \"\\n\");\n    }","id":31238,"modified_method":"/** for castor de-serialization only */\n    public Schema() {\n        mLocalID = nextLocalID();\n        Log.debug(this + \"; CONSTRUCTED FOR CASTOR\");\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"void setDSGUID(String s) {\n        //if (DEBUG.Enabled) Util.printStackTrace(\"setDSGUID [\" + s + \"]\");\n        DSGUID = s;\n        getResource().setProperty(\"@DSGUID\", s);\n        if (DSGUID != null)\n            SchemaByGUID.put(DSGUID, this);        \n    }","id":31239,"modified_method":"void setDSGUID(String s) {\n        //if (DEBUG.Enabled) Util.printStackTrace(\"setDSGUID [\" + s + \"]\");\n        DSGUID = s;\n        getResource().setProperty(\"@DSGUID\", s);\n        if (DSGUID != null)\n            SchemaByDSGUID.put(DSGUID, this);        \n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"/** find all schema handles in all nodes that match the new schema\n     * and replace them with pointers to the live data schema */\n    public static void updateAllSchemaReferences(final Schema newlyLoadedSchema,\n                                                  final Collection<tufts.vue.LWMap> maps)\n    {\n        if (DEBUG.Enabled) Log.debug(\"updateAllSchemaReferences; \" + newlyLoadedSchema + \"; maps: \" + maps);\n        \n        if (!newlyLoadedSchema.isLoaded()) {\n            Log.warn(\"newly loaded schema is empty: \" + newlyLoadedSchema, new Throwable(\"FYI\"));\n            return;\n        }\n        \n        int updateCount = 0;\n        int mapUpdateCount = 0;\n\n        // todo: if this ever gets slow, could improve performance by pre-computing a\n        // lookup map of all schema handles that map to the new schema (which will\n        // usually contain only a single schema mapping) then we only have to check\n        // every schema reference found against the pre-computed lookups instead of\n        // doing a Schema.lookup against all loaded Schema's.\n        \n        for (tufts.vue.LWMap map : maps) {\n            final int countAtMapStart = updateCount;\n            Collection<LWComponent> nodes = map.getAllDescendents();\n            for (LWComponent c : nodes) {\n                final MetaMap data = c.getRawData();\n                if (data == null)\n                    continue;\n                final Schema curSchema = data.getSchema();\n                if (curSchema != null) {\n                    final Schema newSchema = Schema.lookup(curSchema);\n                    if (newSchema != curSchema) {\n                        data.setSchema(newSchema);\n                        updateCount++;\n                        if (newSchema != newlyLoadedSchema) {\n                            Log.warn(\"out of date schema in \" + c + \"; oldSchema=\" + curSchema + \"; replaced with \" + newSchema);\n                        } else {\n                            //if (DEBUG.SCHEMA) Log.debug(\"replaced schema handle in \" + c);\n                        }\n\n                    }\n                }\n            }\n            if (updateCount > countAtMapStart)\n                mapUpdateCount++;\n        }\n        Log.info(String.format(\"updated %d schema handle references in %d maps\", updateCount, mapUpdateCount));\n    }","id":31240,"modified_method":"/** find all schema handles in all nodes that match the new schema\n     * and replace them with pointers to the live data schema */\n    public static void updateAllSchemaReferences(final Schema newlyLoadedSchema,\n                                                  final Collection<tufts.vue.LWMap> maps)\n    {\n        if (DEBUG.Enabled) {\n            Log.debug(\"updateAllSchemaReferences; \" + newlyLoadedSchema + \"; maps: \" + maps);\n            Util.dump(SchemaByResource, \"BY-RESOURCE\");\n            Util.dump(SchemaByDSGUID, \"BY-DSGUID\");\n        }\n        \n        if (!newlyLoadedSchema.isLoaded()) {\n            Log.warn(\"newly loaded schema is empty: \" + newlyLoadedSchema, new Throwable(\"FYI\"));\n            return;\n        }\n        \n        int updateCount = 0;\n        int mapUpdateCount = 0;\n\n        // todo: if this ever gets slow, could improve performance by pre-computing a\n        // lookup map of all schema handles that map to the new schema (which will\n        // usually contain only a single schema mapping) then we only have to check\n        // every schema reference found against the pre-computed lookups instead of\n        // doing a Schema.lookup against all loaded Schema's.\n        \n        for (tufts.vue.LWMap map : maps) {\n            final int countAtMapStart = updateCount;\n            final Collection<LWComponent> nodes = map.getAllDescendents(LWComponent.ChildKind.ANY);\n            for (LWComponent c : nodes) {\n                final MetaMap data = c.getRawData();\n                if (data == null)\n                    continue;\n                final Schema curSchema = data.getSchema();\n                if (curSchema != null) {\n                    final Schema newSchema = Schema.lookupAuthority(curSchema);\n//                     Log.debug(\"curs: \" + newSchema);\n//                     Log.debug(\"auth: \" + newSchema);\n                    if (newSchema != curSchema) {\n                        data.setSchema(newSchema);\n                        updateCount++;\n                        if (newSchema != newlyLoadedSchema) {\n                            Log.warn(\"out of date schema in \" + c + \"; oldSchema=\" + curSchema + \"; replaced with \" + newSchema);\n                        } else {\n                            //if (DEBUG.SCHEMA) Log.debug(\"replaced schema handle in \" + c);\n                        }\n\n                    }\n                }\n            }\n            if (updateCount > countAtMapStart)\n                mapUpdateCount++;\n        }\n        Log.info(String.format(\"updated %d schema handle references in %d maps\", updateCount, mapUpdateCount));\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"public static Schema instance(Resource r, String dataSourceGUID) {\n        final Schema s = new Schema();\n        s.setResource(r);\n        s.setDSGUID(dataSourceGUID);\n        s.setGUID(edu.tufts.vue.util.GUID.generate());\n        if (DEBUG.SCHEMA) Log.debug(\"INSTANCED SCHEMA \" + s + \"\\n\");\n\n        // may want to wait to do this until we actually load the rows...        \n        SchemaByResource.put(r, s);\n        if (dataSourceGUID != null)\n            SchemaByGUID.put(dataSourceGUID, s);\n            \n        return s;\n    }","id":31241,"modified_method":"public static Schema instance(Resource r, String dataSourceGUID) {\n        final Schema s = new Schema();\n        s.setResource(r);\n        s.setDSGUID(dataSourceGUID);\n        s.setGUID(edu.tufts.vue.util.GUID.generate());\n        if (DEBUG.SCHEMA) Log.debug(\"INSTANCED SCHEMA \" + s + \"\\n\");\n\n        // may want to wait to do this until we actually load the rows...\n        Schema prev = SchemaByResource.put(r, s);\n        if (prev != null) {\n            Log.error(\"BLEW AWAY BY RESOURCE \" + prev + \" with \" + s, new Throwable(\"HERE\"));\n        }\n        if (dataSourceGUID != null) {\n            prev = SchemaByDSGUID.put(dataSourceGUID, s);\n            if (prev != null) {\n                Log.error(\"BLEW AWAY BY DSGUID \" + prev + \" with \" + s, new Throwable(\"HERE\"));\n            }\n        }\n            \n        return s;\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    public String toString() {\n        //return getName() + \"; \" + getSource() + \"; \" + UUID;\n        //return getName() + \"; \" + getResource() + \"; \" + UUID;\n        //return getName();\n        try {\n            if (DEBUG.META) {\n                return String.format(\"Schema@%06x[%s;%s #%dx%d %s k=%s %s]\",\n                                     System.identityHashCode(this),\n                                     getMapLocalID(),\n                                     DSGUID == null ? \"\" : (\" \" + DSGUID + \"; \"),\n                                     mFields.size(),\n                                     mRows.size(),\n                                     Util.color(getName(), Util.TERM_PURPLE),\n                                     Relation.quoteKey(getKeyFieldName()),\n                                     getResource()\n                                     );\n            } else {\n                return String.format(\"Schema@%06x[%s; #%dx%d %s k=%s]\",\n                                     System.identityHashCode(this),\n                                     getMapLocalID(),\n                                     mFields.size(),\n                                     mRows.size(),\n                                     Util.color(getName(), Util.TERM_PURPLE),\n                                     Relation.quoteKey(getKeyFieldName())\n                                     );\n                    \n            }\n        } catch (Throwable t) {\n            return String.format(\"Schema@%06x[%s; %s; #%dx%d \\\"%s\\\" %s]\",\n                                 System.identityHashCode(this),\n                                 \"\"+mLocalID,\n                                 DSGUID,\n                                 mFields.size(),\n                                 mRows.size(),\n                                 \"\"+mName, \"\"+mResource);\n        }\n    }","id":31242,"modified_method":"@Override\n    public String toString() {\n        try {\n            String extra = \"\";\n            if (DEBUG.META) extra = \" \" + DSGUID + \"/\" + mResource;\n            return String.format(\"Schema@%07x[%s/%s; #%dx%d %s k=%s%s]\",\n                                 System.identityHashCode(this),\n                                 \"\"+mLocalID,\n                                 \"\"+GUID,\n                                 mFields.size(),\n                                 mRows.size(),\n                                 Util.color(mName, Util.TERM_PURPLE),\n                                 Relation.quoteKey(mKeyField),\n                                 extra);\n        } catch (Throwable t) {\n            t.printStackTrace();\n            return \"Schema[\" + t + \"]\";\n        }\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"/** for looking up a loaded (data-containing) schema from a an empty schema-handle.\n     * If the given schema is already loaded, or if no matching loaded schema can be found,\n     * the passed in schema is returned.\n     */\n    public static Schema lookup(Schema schema) {\n        if (DEBUG.SCHEMA && DEBUG.META) Log.debug(\"LOOKUP SCHEMA \" + schema);\n        if (schema == null)\n            return null;\n        if (schema.isLoaded())\n            return schema;\n        final Resource resource = schema.getResource();\n        Schema loaded = SchemaByResource.get(resource);\n        Object matched = resource;\n        if (loaded == null) {\n            loaded = SchemaByGUID.get(matched = schema.getDSGUID());\n            if (DEBUG.SCHEMA && DEBUG.META && loaded != null) {\n                Log.debug(\"MATCHED SCHEMA BY GUID: \" + matched + \" \" + loaded);\n            }\n        }\n        if (loaded != null) {\n            if (DEBUG.SCHEMA && DEBUG.DATA) Log.debug(\"MATCHED EMPTY SCHEMA \" + matched + \" to \" + loaded);\n            return loaded;\n        } else\n            return schema;\n\n        // now, even if resource doesn't match, look up based on GUID, as a url may have slightly changed.\n    }","id":31243,"modified_method":"/** for looking up a loaded (data-containing) schema from a an empty schema-handle.\n     * If the given schema is already loaded, or if no matching loaded schema can be found,\n     * the passed in schema is returned.\n     */\n    public static Schema lookupAuthority(final Schema schema) {\n        if (DEBUG.SCHEMA && DEBUG.META) Log.debug(\"LOOKUP SCHEMA \" + schema);\n        if (schema == null)\n            return null;\n        if (schema.isLoaded())\n            return schema;\n\n        final Schema authoritativeSchema = lookForReplacement(schema);\n\n        if (authoritativeSchema != null)\n            return authoritativeSchema;\n        else\n            return schema;\n        \n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"private Field addField(final Field newField) {\n        // note: for new Fields, constructor may have trimmed the name,\n        // so we should always fetch via f.getName() just in case.\n        // (instead of ever passing in the name of the new field)\n\n        final String name = newField.getName();\n        \n        mFields.put(name, newField);\n        \n        final String keyName = name.toLowerCase();\n\n        Association.addByAll(newField, AllFieldsByLowerName.get(keyName));\n        \n        AllFieldsByLowerName.put(keyName, newField);\n\n        return newField;\n    }","id":31244,"modified_method":"private Field addField(final Field newField) {\n\n        newField.setSchema(this);\n\n        // note: for new Fields, constructor may have trimmed the name,\n        // so we should always fetch via f.getName() just in case.\n        // (instead of ever passing in the name of the new field)\n        final String name = newField.getName();\n        \n        mFields.put(name, newField);\n        \n        final String keyName = name.toLowerCase();\n        // This will auto-add associations for fields of the same name -- too aggressive tho\n        //Association.addByAll(newField, AllFieldsByLowerName.get(keyName));\n        AllFieldsByLowerName.put(keyName, newField);\n\n        return newField;\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"public final void setMapLocalID(String id) {\n        Log.debug(\"SCHEMA ID WAS PERSISTED AS \" + id + \"; \" + this);\n        //mLocalID.set(i);\n    }","id":31245,"modified_method":"/** only debug during castor deserialization */\n    public final void setMapLocalID(String id) {\n        // we can safely ignore this -- a new current runtime map-local-id has already\n        // been set -- the existing one is purely for castor's use in assigning references\n        // from MetaMap's in the save file to this schema instance.\n        Log.debug(this + \"; ignoring persisted map-id [\" + id + \"]\");\n        //mLocalID.set(i);\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"/** interface {@link XMLUnmarshalListener} -- track us */\n    public void XML_completed(Object context) {\n        SchemaHandles.add(this);\n        // As the resource isn't in the LWComponent hierarchy, it won't be updated in the map.\n        // Too bad actually -- then it could make use of the relative path code -- would be\n        // a good idea to move these to the map.\n        ((tufts.vue.URLResource)getResource()).XML_completed(\"SCHEMA-MANUAL-INIT\");\n        DSGUID = getResource().getProperty(\"@DSGUID\");\n        if (DEBUG.Enabled) Log.debug(\"RESTORED SCHEMA \" + this + \"; DSGUID=\" + DSGUID);\n        if (DSGUID != null) {\n            Schema prev = SchemaByGUID.put(DSGUID, this);\n            if (prev != null)\n                Log.warn(\"BLEW AWAY PRIOR SCHEMA \" + prev, new Throwable(\"HERE\"));\n        }\n        //Log.debug(\"LOAD FIELDS WITH \" + mPersistFields);\n        for (Field f : mPersistFields) {\n            final LWComponent style = f.getStyleNode();\n            if (DEBUG.Enabled) Log.debug(\"loading field \" + f + \"; style:\" + style);\n            initStyleNode(style);\n            addField(f);\n        }\n        mXMLRestoreUnderway = false;\n    }","id":31246,"modified_method":"/** interface {@link XMLUnmarshalListener} -- track us */\n    public void XML_completed(Object context) {\n        // As the resource isn't in the LWComponent hierarchy, it won't be updated in\n        // the map.  TODO: too bad actually -- then it could make use of the\n        // relative-to-map file path code -- would be a good idea to move these to the\n        // map.\n        ((tufts.vue.URLResource)getResource()).XML_completed(\"SCHEMA-MANUAL-INIT\");\n        \n        this.DSGUID = getResource().getProperty(\"@DSGUID\");\n\n        for (Field field : mPersistFields) {\n            field.setSchema(this);\n            if (DEBUG.Enabled) Log.debug(String.format(\"seen field %s%-20s%s\",\n                                                       Util.TERM_YELLOW, field, Util.TERM_CLEAR));\n        }\n        \n        createAttachableAssociations(mPersistFields);\n        mXMLRestoreUnderway = false;\n        if (DEBUG.Enabled) Log.debug(this + \" RESTORED; DSGUID=\" + DSGUID + \"\\n\");\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"/** If an existing schema exists matching the GUID, return that, otherwise, a new schema instance */\n    // TODO: factor in looking up based on the resource if the DSGUID doesn't match for some reason\n    public static Schema fetch(Resource r, String dataSourceGUID) {\n        Schema s = SchemaByGUID.get(dataSourceGUID);\n        if (s == null) {\n            if (DEBUG.SCHEMA) Log.debug(\"fetch: GUID \" + Util.tags(dataSourceGUID) + \" not found; instancing new\");\n            return instance(r, dataSourceGUID);\n        } else {\n            if (DEBUG.SCHEMA) {\n                Log.debug(\"fetch: found by GUID \" + s);\n                Log.debug(\"fetch: existing fields:\");\n                Util.dump(s.mFields);\n            }\n            return s;\n        }\n    }","id":31247,"modified_method":"/** If an existing schema exists matching the GUID, return that, otherwise, a new schema instance */\n    // TODO: factor in looking up based on the resource if the DSGUID doesn't match for some reason\n    public static Schema fetch(Resource r, String dataSourceGUID) {\n        Schema s = SchemaByDSGUID.get(dataSourceGUID);\n        if (s == null) {\n            if (DEBUG.SCHEMA) Log.debug(\"fetch: GUID \" + Util.tags(dataSourceGUID) + \" not found; instancing new\");\n            return instance(r, dataSourceGUID);\n        } else {\n            if (DEBUG.SCHEMA) {\n                Log.debug(\"fetch: found by GUID \" + s);\n                Log.debug(\"fetch: existing fields:\");\n                Util.dump(s.mFields);\n            }\n            return s;\n        }\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"public final String getMapLocalID() {\n        return mLocalID;\n    }","id":31248,"modified_method":"/** for persistance */\n    public final String getMapLocalID() {\n        return mLocalID;\n    }","commit_id":"463631822dcd2f5809ba036da35cc60148794eda","url":"https://github.com/VUE/VUE"},{"original_method":"public Object getValue(ResultSet rs, String name, Integer type)\n\t\tthrows Exception {\n\n\t\tObject value = null;\n\n\t\tint t = type.intValue();\n\n\t\tUserType userType = null;\n\n\t\tif (t == Types.BIGINT) {\n\t\t\tuserType = new LongType();\n\t\t}\n\t\telse if (t == Types.BOOLEAN) {\n\t\t\tuserType = new BooleanType();\n\t\t}\n\t\telse if (t == Types.CLOB) {\n\t\t\tClob clob = rs.getClob(name);\n\n\t\t\tif (clob == null) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBufferedReader br = new BufferedReader(\n\t\t\t\t\tclob.getCharacterStream());\n\n\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\tString line = null;\n\n\t\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\t\tif (sm.length() != 0) {\n\t\t\t\t\t\tsm.append(SAFE_NEWLINE_CHARACTER);\n\t\t\t\t\t}\n\n\t\t\t\t\tsm.append(line);\n\t\t\t\t}\n\n\t\t\t\tvalue = sm.toString();\n\t\t\t}\n\t\t}\n\t\telse if (t == Types.DOUBLE) {\n\t\t\tuserType = new DoubleType();\n\t\t}\n\t\telse if (t == Types.FLOAT) {\n\t\t\tuserType = new FloatType();\n\t\t}\n\t\telse if (t == Types.INTEGER) {\n\t\t\tuserType = new IntegerType();\n\t\t}\n\t\telse if (t == Types.SMALLINT) {\n\t\t\tuserType = new ShortType();\n\t\t}\n\t\telse if (t == Types.TIMESTAMP) {\n\t\t\ttry {\n\t\t\t\tvalue = rs.getObject(name);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tvalue = StringPool.NULL;\n\t\t\t}\n\t\t}\n\t\telse if (t == Types.VARCHAR) {\n\t\t\tvalue = GetterUtil.getString(rs.getString(name));\n\t\t}\n\t\telse {\n\t\t\tthrow new UpgradeException(\n\t\t\t\t\"Upgrade code using unsupported class type \" + type);\n\t\t}\n\n\t\tif (userType != null) {\n\t\t\tvalue = userType.nullSafeGet(rs, new String[] {name}, null);\n\t\t}\n\n\t\treturn value;\n\t}","id":31249,"modified_method":"public Object getValue(ResultSet rs, String name, Integer type)\n\t\tthrows Exception {\n\n\t\tObject value = null;\n\n\t\tint t = type.intValue();\n\n\t\tUserType userType = null;\n\n\t\tif (t == Types.BIGINT) {\n\t\t\tuserType = new LongType();\n\t\t}\n\t\telse if (t == Types.BOOLEAN) {\n\t\t\tuserType = new BooleanType();\n\t\t}\n\t\telse if (t == Types.CLOB) {\n\t\t\tClob clob = rs.getClob(name);\n\n\t\t\tif (clob == null) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBufferedReader br = new BufferedReader(\n\t\t\t\t\tclob.getCharacterStream());\n\n\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\tString line = null;\n\n\t\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\t\tif (sm.length() != 0) {\n\t\t\t\t\t\tsm.append(SAFE_NEWLINE_CHARACTER);\n\t\t\t\t\t}\n\n\t\t\t\t\tsm.append(line);\n\t\t\t\t}\n\n\t\t\t\tvalue = sm.toString();\n\t\t\t}\n\t\t}\n\t\telse if (t == Types.DOUBLE) {\n\t\t\tuserType = new DoubleType();\n\t\t}\n\t\telse if (t == Types.FLOAT) {\n\t\t\tuserType = new FloatType();\n\t\t}\n\t\telse if (t == Types.INTEGER) {\n\t\t\tuserType = new IntegerType();\n\t\t}\n\t\telse if (t == Types.SMALLINT) {\n\t\t\tuserType = new ShortType();\n\t\t}\n\t\telse if (t == Types.TIMESTAMP) {\n\t\t\ttry {\n\t\t\t\tvalue = rs.getObject(name);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tvalue = StringPool.NULL;\n\t\t\t}\n\t\t}\n\t\telse if (t == Types.VARCHAR) {\n\t\t\tvalue = GetterUtil.getString(rs.getString(name));\n\t\t}\n\t\telse {\n\t\t\tthrow new UpgradeException(\n\t\t\t\t\"Upgrade code using unsupported class type \" + type);\n\t\t}\n\n\t\tif (userType != null) {\n\t\t\ttry {\n\t\t\t\tvalue = userType.nullSafeGet(rs, new String[] {name}, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Unable to nullSafeGet \" + name + \" with \" +\n\t\t\t\t\t\tuserType.getClass().getName());\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void runSQLTemplate(String path, boolean failOnError)\n\t\tthrows IOException, SQLException {\n\n\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\tInputStream is = classLoader.getResourceAsStream(\n\t\t\t\"com/liferay/portal/tools/sql/dependencies/\" + path);\n\n\t\tif (is == null) {\n\t\t\tis = classLoader.getResourceAsStream(path);\n\t\t}\n\n\t\tString template = StringUtil.read(is);\n\n\t\tis.close();\n\n\t\tif (path.endsWith(\".vm\")) {\n\t\t\ttry {\n\t\t\t\ttemplate = evaluateVM(template);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tBufferedReader br = new BufferedReader(new StringReader(template));\n\n\t\tString line = null;\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tif (!line.startsWith(\"##\")) {\n\t\t\t\tsm.append(line);\n\n\t\t\t\tif (line.endsWith(\";\")) {\n\t\t\t\t\tString sql = sm.toString();\n\n\t\t\t\t\tsm = new StringMaker();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunSQL(sql);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tif (failOnError) {\n\t\t\t\t\t\t\tthrow ioe;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(ioe.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException sqle) {\n\t\t\t\t\t\tif (failOnError) {\n\t\t\t\t\t\t\tthrow sqle;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(sqle.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbr.close();\n\t}","id":31250,"modified_method":"public void runSQLTemplate(String path, boolean failOnError)\n\t\tthrows IOException, SQLException {\n\n\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\tInputStream is = classLoader.getResourceAsStream(\n\t\t\t\"com/liferay/portal/tools/sql/dependencies/\" + path);\n\n\t\tif (is == null) {\n\t\t\tis = classLoader.getResourceAsStream(path);\n\t\t}\n\n\t\tString template = StringUtil.read(is);\n\n\t\tis.close();\n\n\t\tif (path.endsWith(\".vm\")) {\n\t\t\ttry {\n\t\t\t\ttemplate = evaluateVM(template);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tBufferedReader br = new BufferedReader(new StringReader(template));\n\n\t\tString line = null;\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tif (!line.startsWith(\"##\")) {\n\t\t\t\tsm.append(line);\n\n\t\t\t\tif (line.endsWith(\";\")) {\n\t\t\t\t\tString sql = sm.toString();\n\n\t\t\t\t\tsm = new StringMaker();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!sql.equals(\"COMMIT_TRANSACTION;\")) {\n\t\t\t\t\t\t\trunSQL(sql);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t_log.debug(\"Skip commit sql\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tif (failOnError) {\n\t\t\t\t\t\t\tthrow ioe;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(ioe.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException sqle) {\n\t\t\t\t\t\tif (failOnError) {\n\t\t\t\t\t\t\tthrow sqle;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(sqle.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbr.close();\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void runSQL(String[] templates)\n\t\tthrows IOException, SQLException {\n\n\t\tConnection con = null;\n\t\tStatement stmt = null;\n\n\t\ttry {\n\t\t\tcon = HibernateUtil.getConnection();\n\n\t\t\tstmt = con.createStatement();\n\n\t\t\tfor (int i = 0; i < templates.length; i++) {\n\t\t\t\tString sql = buildSQL(templates[i]);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(sql);\n\t\t\t\t}\n\n\t\t\t\tstmt.executeUpdate(sql);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, stmt);\n\t\t}\n\t}","id":31251,"modified_method":"public void runSQL(String[] templates)\n\t\tthrows IOException, SQLException {\n\n\t\tConnection con = null;\n\t\tStatement stmt = null;\n\n\t\ttry {\n\t\t\tcon = HibernateUtil.getConnection();\n\n\t\t\tstmt = con.createStatement();\n\n\t\t\tfor (int i = 0; i < templates.length; i++) {\n\t\t\t\tString sql = buildSQL(templates[i]);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(sql);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tstmt.executeUpdate(sql);\n\t\t\t\t}\n\t\t\t\tcatch (SQLException sqle) {\n\t\t\t\t\t_log.error(\"Error to running \" + sql);\n\n\t\t\t\t\tthrow sqle;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, stmt);\n\t\t}\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException, SQLException {\n\n\t\tLong value = (Long)Hibernate.LONG.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn new Long(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":31252,"modified_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException, SQLException {\n\n\t\tObject value = null;\n\n\t\ttry {\n\t\t\tvalue = Hibernate.LONG.nullSafeGet(rs, names[0]);\n\t\t}\n\t\tcatch (SQLException sqle1) {\n\n\t\t\t// Some JDBC drivers do not know how to convert a VARCHAR column\n\t\t\t// with a blank entry into a BIGINT\n\n\t\t\ttry {\n\t\t\t\tvalue = new Long(GetterUtil.getLong(\n\t\t\t\t\t(String)Hibernate.STRING.nullSafeGet(rs, names[0])));\n\t\t\t}\n\t\t\tcatch (SQLException sqle2) {\n\t\t\t\tthrow sqle1;\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn new Long(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PKUpgradeColumnImpl(String name, Integer oldColumnType,\n\t\t\t\t\t\t\t   boolean trackValues) {\n\n\t\tsuper(name, oldColumnType);\n\n\t\t_trackValues = trackValues;\n\n\t\tif (_trackValues) {\n\t\t\t_valueMapper = ValueMapperFactory.getValueMapper();\n\t\t}\n\t}","id":31253,"modified_method":"public PKUpgradeColumnImpl(String name, Integer oldColumnType,\n\t\t\t\t\t\t\t   boolean trackValues) {\n\n\t\tsuper(name, oldColumnType);\n\n\t\t_newColumnType = new Integer(Types.BIGINT);\n\t\t_trackValues = trackValues;\n\n\t\tif (_trackValues) {\n\t\t\t_valueMapper = ValueMapperFactory.getValueMapper();\n\t\t}\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Integer getNewColumnType(Integer defaultType) {\n\t\treturn new Integer(Types.BIGINT);\n\t}","id":31254,"modified_method":"public Integer getNewColumnType(Integer defaultType) {\n\t\treturn _newColumnType;\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doUpgrade() throws Exception {\n\n\t\t// Calendar\n\n\t\tUpgradeColumn upgradeGroupIdColumn = new SwapUpgradeColumnImpl(\n\t\t\t\"groupId\", AvailableMappersUtil.getGroupIdMapper());\n\n\t\tUpgradeColumn upgradeUserIdColumn = new SwapUpgradeColumnImpl(\n\t\t\t\"userId\", new Integer(Types.VARCHAR),\n\t\t\tAvailableMappersUtil.getUserIdMapper());\n\n\t\tPKUpgradeColumnImpl upgradePKColumn = new PKUpgradeColumnImpl(\n\t\t\t\"eventId\", true);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tCalEventImpl.TABLE_NAME, CalEventImpl.TABLE_COLUMNS,\n\t\t\tupgradePKColumn, upgradeGroupIdColumn, upgradeUserIdColumn);\n\n\t\tupgradeTable.setCreateSQL(CalEventImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\n\t\tValueMapper eventIdMapper = upgradePKColumn.getValueMapper();\n\n\t\tAvailableMappersUtil.setCalEventIdMapper(eventIdMapper);\n\n\t\t// Schema\n\n\t\trunSQL(_UPGRADE_SCHEMA);\n\t}","id":31255,"modified_method":"protected void doUpgrade() throws Exception {\n\n\t\t// Calendar\n\n\t\tUpgradeColumn upgradeGroupIdColumn = new SwapUpgradeColumnImpl(\n\t\t\t\"groupId\", AvailableMappersUtil.getGroupIdMapper());\n\n\t\tUpgradeColumn upgradeUserIdColumn = new SwapUpgradeColumnImpl(\n\t\t\t\"userId\", new Integer(Types.VARCHAR),\n\t\t\tAvailableMappersUtil.getUserIdMapper());\n\n\t\tPKUpgradeColumnImpl upgradePKColumn = new PKUpgradeColumnImpl(\n\t\t\t\"eventId\", true);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tCalEventImpl.TABLE_NAME, CalEventImpl.TABLE_COLUMNS,\n\t\t\tupgradePKColumn, upgradeGroupIdColumn, upgradeUserIdColumn);\n\n\t\tupgradeTable.setCreateSQL(CalEventImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\n\t\tValueMapper eventIdMapper = upgradePKColumn.getValueMapper();\n\n\t\tAvailableMappersUtil.setCalEventIdMapper(eventIdMapper);\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doUpgrade() throws Exception {\n\n\t\t// Contact_\n\n\t\tPKUpgradeColumnImpl pkUpgradeColumn = new PKUpgradeColumnImpl(\n\t\t\t\"contactId\", new Integer(Types.VARCHAR), true);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tContactImpl.TABLE_NAME, ContactImpl.TABLE_COLUMNS, pkUpgradeColumn);\n\n\t\tupgradeTable.setCreateSQL(ContactImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\n\t\tValueMapper contactIdMapper = new DefaultPKMapper(\n\t\t\tpkUpgradeColumn.getValueMapper());\n\n\t\tAvailableMappersUtil.setContactIdMapper(contactIdMapper);\n\n\t\t// User_\n\n\t\tUpgradeColumn upgradeScreenNameColumn =\n\t\t\tnew TempUpgradeColumnImpl(\"screenName\");\n\n\t\tUpgradeColumn upgradeContactIdColumn = new ContactIdUpgradeColumnImpl(\n\t\t\tupgradeScreenNameColumn, contactIdMapper);\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tUserImpl.TABLE_NAME, UserImpl.TABLE_COLUMNS,\n\t\t\tupgradeScreenNameColumn, upgradeContactIdColumn);\n\n\t\tupgradeTable.setCreateSQL(UserImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Schema\n\n\t\trunSQL(_UPGRADE_SCHEMA);\n\t}","id":31256,"modified_method":"protected void doUpgrade() throws Exception {\n\n\t\t// Contact_\n\n\t\tPKUpgradeColumnImpl pkUpgradeColumn = new PKUpgradeColumnImpl(\n\t\t\t\"contactId\", new Integer(Types.VARCHAR), true);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tContactImpl.TABLE_NAME, ContactImpl.TABLE_COLUMNS, pkUpgradeColumn);\n\n\t\tupgradeTable.setCreateSQL(ContactImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\n\t\tValueMapper contactIdMapper = new DefaultPKMapper(\n\t\t\tpkUpgradeColumn.getValueMapper());\n\n\t\tAvailableMappersUtil.setContactIdMapper(contactIdMapper);\n\n\t\t// User_\n\n\t\tUpgradeColumn upgradeScreenNameColumn =\n\t\t\tnew TempUpgradeColumnImpl(\"screenName\");\n\n\t\tUpgradeColumn upgradeContactIdColumn = new ContactIdUpgradeColumnImpl(\n\t\t\tupgradeScreenNameColumn, contactIdMapper);\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tUserImpl.TABLE_NAME, UserImpl.TABLE_COLUMNS,\n\t\t\tupgradeScreenNameColumn, upgradeContactIdColumn);\n\n\t\tupgradeTable.setCreateSQL(UserImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\t}","commit_id":"616ef853e34b6d5d299c6d97ea56c9594abd7f73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows HibernateException, SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = Boolean.valueOf(DEFAULT_VALUE);\n\t\t}\n\n\t\tHibernate.BOOLEAN.nullSafeSet(ps, obj, index);\n\t}","id":31257,"modified_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = Boolean.valueOf(DEFAULT_VALUE);\n\t\t}\n\n\t\tps.setBoolean(index, (Boolean)obj);\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException, SQLException {\n\n\t\tBoolean value = (Boolean)Hibernate.BOOLEAN.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn Boolean.valueOf(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":31258,"modified_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object owner)\n\t\tthrows SQLException {\n\n\t\tBoolean value = StandardBasicTypes.BOOLEAN.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn Boolean.valueOf(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows HibernateException, SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Double(DEFAULT_VALUE);\n\t\t}\n\n\t\tHibernate.DOUBLE.nullSafeSet(ps, obj, index);\n\t}","id":31259,"modified_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Double(DEFAULT_VALUE);\n\t\t}\n\n\t\tps.setDouble(index, (Double)obj);\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException, SQLException {\n\n\t\tDouble value = (Double)Hibernate.DOUBLE.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn new Double(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":31260,"modified_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object owner)\n\t\tthrows SQLException {\n\n\t\tDouble value = StandardBasicTypes.DOUBLE.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn new Double(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException, SQLException {\n\n\t\tFloat value = (Float)Hibernate.FLOAT.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn new Float(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":31261,"modified_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object owner)\n\t\tthrows SQLException {\n\n\t\tFloat value = StandardBasicTypes.FLOAT.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn new Float(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows HibernateException, SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Float(DEFAULT_VALUE);\n\t\t}\n\n\t\tHibernate.FLOAT.nullSafeSet(ps, obj, index);\n\t}","id":31262,"modified_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Float(DEFAULT_VALUE);\n\t\t}\n\n\t\tps.setFloat(index, (Float)obj);\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException {\n\n\t\tInteger value = null;\n\n\t\ttry {\n\t\t\tvalue = (Integer)Hibernate.INTEGER.nullSafeGet(rs, names[0]);\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn new Integer(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":31263,"modified_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object owner)\n\t\tthrows HibernateException {\n\n\t\tInteger value = null;\n\n\t\ttry {\n\t\t\tvalue = StandardBasicTypes.INTEGER.nullSafeGet(rs, names[0]);\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn new Integer(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows HibernateException, SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Integer(DEFAULT_VALUE);\n\t\t}\n\n\t\tHibernate.INTEGER.nullSafeSet(ps, obj, index);\n\t}","id":31264,"modified_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Integer(DEFAULT_VALUE);\n\t\t}\n\n\t\tps.setInt(index, (Integer)obj);\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows HibernateException, SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Long(DEFAULT_VALUE);\n\t\t}\n\n\t\tHibernate.LONG.nullSafeSet(ps, obj, index);\n\t}","id":31265,"modified_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Long(DEFAULT_VALUE);\n\t\t}\n\n\t\tps.setLong(index, (Long)obj);\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException, SQLException {\n\n\t\tObject value = null;\n\n\t\ttry {\n\t\t\tvalue = Hibernate.LONG.nullSafeGet(rs, names[0]);\n\t\t}\n\t\tcatch (SQLException sqle1) {\n\n\t\t\t// Some JDBC drivers do not know how to convert a VARCHAR column\n\t\t\t// with a blank entry into a BIGINT\n\n\t\t\ttry {\n\t\t\t\tvalue = new Long(GetterUtil.getLong(\n\t\t\t\t\t(String)Hibernate.STRING.nullSafeGet(rs, names[0])));\n\t\t\t}\n\t\t\tcatch (SQLException sqle2) {\n\t\t\t\tthrow sqle1;\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn new Long(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":31266,"modified_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object owner)\n\t\tthrows SQLException {\n\n\t\tObject value = null;\n\n\t\ttry {\n\t\t\tvalue = StandardBasicTypes.LONG.nullSafeGet(rs, names[0]);\n\t\t}\n\t\tcatch (SQLException sqle1) {\n\n\t\t\t// Some JDBC drivers do not know how to convert a VARCHAR column\n\t\t\t// with a blank entry into a BIGINT\n\n\t\t\ttry {\n\t\t\t\tvalue = new Long(\n\t\t\t\t\tGetterUtil.getLong(\n\t\t\t\t\t\tStandardBasicTypes.STRING.nullSafeGet(rs, names[0])));\n\t\t\t}\n\t\t\tcatch (SQLException sqle2) {\n\t\t\t\tthrow sqle1;\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn new Long(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object obj)\n\t\tthrows HibernateException, SQLException {\n\n\t\tShort value = (Short)Hibernate.SHORT.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn new Short(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":31267,"modified_method":"public Object nullSafeGet(ResultSet rs, String[] names, Object owner)\n\t\tthrows SQLException {\n\n\t\tShort value = StandardBasicTypes.SHORT.nullSafeGet(rs, names[0]);\n\n\t\tif (value == null) {\n\t\t\treturn new Short(DEFAULT_VALUE);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows HibernateException, SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Short(DEFAULT_VALUE);\n\t\t}\n\n\t\tHibernate.SHORT.nullSafeSet(ps, obj, index);\n\t}","id":31268,"modified_method":"public void nullSafeSet(PreparedStatement ps, Object obj, int index)\n\t\tthrows SQLException {\n\n\t\tif (obj == null) {\n\t\t\tobj = new Short(DEFAULT_VALUE);\n\t\t}\n\n\t\tps.setShort(index, (Short)obj);\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isEqual(Object x, Object y) {\n\t\tboolean equal = super.isEqual(x, y);\n\n\t\tif (!equal) {\n\t\t\tif (((x == null) || x.equals(StringPool.BLANK)) &&\n\t\t\t\t((y == null) || y.equals(StringPool.BLANK))) {\n\n\t\t\t\tequal = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tequal = false;\n\t\t\t}\n\t\t}\n\n\t\treturn equal;\n\t}","id":31269,"modified_method":"public boolean equals(Object x, Object y) {\n\t\tif (Validator.equals(x, y)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (((x == null) || x.equals(StringPool.BLANK)) &&\n\t\t\t\t ((y == null) || y.equals(StringPool.BLANK))) {\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static org.hibernate.type.Type translate(Type type) {\n\t\tif (type == Type.BIG_DECIMAL) {\n\t\t\treturn org.hibernate.Hibernate.BIG_DECIMAL;\n\t\t}\n\t\telse if (type == Type.BIG_INTEGER) {\n\t\t\treturn org.hibernate.Hibernate.BIG_INTEGER;\n\t\t}\n\t\telse if (type == Type.BINARY) {\n\t\t\treturn org.hibernate.Hibernate.BINARY;\n\t\t}\n\t\telse if (type == Type.BLOB) {\n\t\t\treturn org.hibernate.Hibernate.BLOB;\n\t\t}\n\t\telse if (type == Type.BOOLEAN) {\n\t\t\treturn org.hibernate.Hibernate.BOOLEAN;\n\t\t}\n\t\telse if (type == Type.BYTE) {\n\t\t\treturn org.hibernate.Hibernate.BYTE;\n\t\t}\n\t\telse if (type == Type.CALENDAR) {\n\t\t\treturn org.hibernate.Hibernate.CALENDAR;\n\t\t}\n\t\telse if (type == Type.CALENDAR_DATE) {\n\t\t\treturn org.hibernate.Hibernate.CALENDAR_DATE;\n\t\t}\n\t\telse if (type == Type.CHAR_ARRAY) {\n\t\t\treturn org.hibernate.Hibernate.CHAR_ARRAY;\n\t\t}\n\t\telse if (type == Type.CHARACTER) {\n\t\t\treturn org.hibernate.Hibernate.CHARACTER;\n\t\t}\n\t\telse if (type == Type.CHARACTER_ARRAY) {\n\t\t\treturn org.hibernate.Hibernate.CHARACTER_ARRAY;\n\t\t}\n\t\telse if (type == Type.CLASS) {\n\t\t\treturn org.hibernate.Hibernate.CLASS;\n\t\t}\n\t\telse if (type == Type.CLOB) {\n\t\t\treturn org.hibernate.Hibernate.CLOB;\n\t\t}\n\t\telse if (type == Type.CURRENCY) {\n\t\t\treturn org.hibernate.Hibernate.CURRENCY;\n\t\t}\n\t\telse if (type == Type.DATE) {\n\t\t\treturn org.hibernate.Hibernate.DATE;\n\t\t}\n\t\telse if (type == Type.DOUBLE) {\n\t\t\treturn org.hibernate.Hibernate.DOUBLE;\n\t\t}\n\t\telse if (type == Type.FLOAT) {\n\t\t\treturn org.hibernate.Hibernate.FLOAT;\n\t\t}\n\t\telse if (type == Type.INTEGER) {\n\t\t\treturn org.hibernate.Hibernate.INTEGER;\n\t\t}\n\t\telse if (type == Type.LOCALE) {\n\t\t\treturn org.hibernate.Hibernate.LOCALE;\n\t\t}\n\t\telse if (type == Type.LONG) {\n\t\t\treturn org.hibernate.Hibernate.LONG;\n\t\t}\n\t\telse if (type == Type.OBJECT) {\n\t\t\treturn org.hibernate.Hibernate.OBJECT;\n\t\t}\n\t\telse if (type == Type.SERIALIZABLE) {\n\t\t\treturn org.hibernate.Hibernate.SERIALIZABLE;\n\t\t}\n\t\telse if (type == Type.SHORT) {\n\t\t\treturn org.hibernate.Hibernate.SHORT;\n\t\t}\n\t\telse if (type == Type.STRING) {\n\t\t\treturn org.hibernate.Hibernate.STRING;\n\t\t}\n\t\telse if (type == Type.TEXT) {\n\t\t\treturn org.hibernate.Hibernate.TEXT;\n\t\t}\n\t\telse if (type == Type.TIMESTAMP) {\n\t\t\treturn org.hibernate.Hibernate.TIMESTAMP;\n\t\t}\n\t\telse if (type == Type.TIMEZONE) {\n\t\t\treturn org.hibernate.Hibernate.TIMEZONE;\n\t\t}\n\t\telse if (type == Type.TRUE_FALSE) {\n\t\t\treturn org.hibernate.Hibernate.TRUE_FALSE;\n\t\t}\n\t\telse if (type == Type.WRAPPER_BINARY) {\n\t\t\treturn org.hibernate.Hibernate.WRAPPER_BINARY;\n\t\t}\n\t\telse if (type == Type.YES_NO) {\n\t\t\treturn org.hibernate.Hibernate.YES_NO;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":31270,"modified_method":"public static org.hibernate.type.Type translate(Type type) {\n\t\tif (type == Type.BIG_DECIMAL) {\n\t\t\treturn BIG_DECIMAL;\n\t\t}\n\t\telse if (type == Type.BIG_INTEGER) {\n\t\t\treturn BIG_INTEGER;\n\t\t}\n\t\telse if (type == Type.BINARY) {\n\t\t\treturn BINARY;\n\t\t}\n\t\telse if (type == Type.BLOB) {\n\t\t\treturn BLOB;\n\t\t}\n\t\telse if (type == Type.BOOLEAN) {\n\t\t\treturn BOOLEAN;\n\t\t}\n\t\telse if (type == Type.BYTE) {\n\t\t\treturn BYTE;\n\t\t}\n\t\telse if (type == Type.CALENDAR) {\n\t\t\treturn CALENDAR;\n\t\t}\n\t\telse if (type == Type.CALENDAR_DATE) {\n\t\t\treturn CALENDAR_DATE;\n\t\t}\n\t\telse if (type == Type.CHAR_ARRAY) {\n\t\t\treturn CHAR_ARRAY;\n\t\t}\n\t\telse if (type == Type.CHARACTER) {\n\t\t\treturn CHARACTER;\n\t\t}\n\t\telse if (type == Type.CHARACTER_ARRAY) {\n\t\t\treturn CHARACTER_ARRAY;\n\t\t}\n\t\telse if (type == Type.CLASS) {\n\t\t\treturn CLASS;\n\t\t}\n\t\telse if (type == Type.CLOB) {\n\t\t\treturn CLOB;\n\t\t}\n\t\telse if (type == Type.CURRENCY) {\n\t\t\treturn CURRENCY;\n\t\t}\n\t\telse if (type == Type.DATE) {\n\t\t\treturn DATE;\n\t\t}\n\t\telse if (type == Type.DOUBLE) {\n\t\t\treturn DOUBLE;\n\t\t}\n\t\telse if (type == Type.FLOAT) {\n\t\t\treturn FLOAT;\n\t\t}\n\t\telse if (type == Type.IMAGE) {\n\t\t\treturn IMAGE;\n\t\t}\n\t\telse if (type == Type.INTEGER) {\n\t\t\treturn INTEGER;\n\t\t}\n\t\telse if (type == Type.LOCALE) {\n\t\t\treturn LOCALE;\n\t\t}\n\t\telse if (type == Type.LONG) {\n\t\t\treturn LONG;\n\t\t}\n\t\telse if (type == Type.MATERIALIZED_BLOB) {\n\t\t\treturn MATERIALIZED_BLOB;\n\t\t}\n\t\telse if (type == Type.MATERIALIZED_CLOB) {\n\t\t\treturn MATERIALIZED_CLOB;\n\t\t}\n\t\telse if (type == Type.NUMERIC_BOOLEAN) {\n\t\t\treturn NUMERIC_BOOLEAN;\n\t\t}\n\t\telse if (type == Type.SERIALIZABLE) {\n\t\t\treturn SERIALIZABLE;\n\t\t}\n\t\telse if (type == Type.SHORT) {\n\t\t\treturn SHORT;\n\t\t}\n\t\telse if (type == Type.STRING) {\n\t\t\treturn STRING;\n\t\t}\n\t\telse if (type == Type.TEXT) {\n\t\t\treturn TEXT;\n\t\t}\n\t\telse if (type == Type.TIME) {\n\t\t\treturn TIME;\n\t\t}\n\t\telse if (type == Type.TIMESTAMP) {\n\t\t\treturn TIMESTAMP;\n\t\t}\n\t\telse if (type == Type.TIMEZONE) {\n\t\t\treturn TIMEZONE;\n\t\t}\n\t\telse if (type == Type.TRUE_FALSE) {\n\t\t\treturn TRUE_FALSE;\n\t\t}\n\t\telse if (type == Type.URL) {\n\t\t\treturn URL;\n\t\t}\n\t\telse if (type == Type.UUID_BINARY) {\n\t\t\treturn UUID_BINARY;\n\t\t}\n\t\telse if (type == Type.UUID_CHAR) {\n\t\t\treturn UUID_CHAR;\n\t\t}\n\t\telse if (type == Type.WRAPPER_BINARY) {\n\t\t\treturn WRAPPER_BINARY;\n\t\t}\n\t\telse if (type == Type.YES_NO) {\n\t\t\treturn YES_NO;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"1c9c31b02f960525f1030c2128249105842295d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Factory method for creating a source line annotation describing the\n\t * source line number for a visited instruction.\n\t * @param methodGen the MethodGen object representing the method\n\t * @param handle the InstructionHandle containing the visited instruction\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the instruction\n\t */\n\tpublic static SourceLineAnnotation fromVisitedInstruction(MethodGen methodGen, InstructionHandle handle) {\n\t\tLineNumberTable table = methodGen.getLineNumberTable(methodGen.getConstantPool());\n\t\tif (table == null)\n\t\t\treturn null;\n\n\t\tint lineNumber = table.getSourceLine(handle.getPosition());\n\t\treturn new SourceLineAnnotation(methodGen.getClassName(), lineNumber, lineNumber);\n\t}","id":31271,"modified_method":"/**\n\t * Factory method for creating a source line annotation describing the\n\t * source line number for a visited instruction.\n\t * @param methodGen the MethodGen object representing the method\n\t * @param handle the InstructionHandle containing the visited instruction\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the instruction\n\t */\n\tpublic static SourceLineAnnotation fromVisitedInstruction(MethodGen methodGen, InstructionHandle handle) {\n\t\tLineNumberTable table = methodGen.getLineNumberTable(methodGen.getConstantPool());\n\t\tString className = methodGen.getClassName();\n\n\t\tif (table == null)\n\t\t\treturn createUnknown(className);\n\n\t\tint lineNumber = table.getSourceLine(handle.getPosition());\n\t\treturn new SourceLineAnnotation(className, lineNumber, lineNumber);\n\t}","commit_id":"2fb6c97894c154ca57a81a49d4915901fb95989f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * an entire method.\n\t * @param methodGen the method being visited\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the method\n\t */\n\tpublic static SourceLineAnnotation fromVisitedMethod(MethodGen methodGen) {\n\t\tLineNumberTable lineNumberTable = methodGen.getLineNumberTable(methodGen.getConstantPool());\n\t\tif (lineNumberTable == null)\n\t\t\treturn null;\n\t\treturn forEntireMethod(methodGen.getClassName(), lineNumberTable);\n\t}","id":31272,"modified_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * an entire method.\n\t * @param methodGen the method being visited\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the method\n\t */\n\tpublic static SourceLineAnnotation fromVisitedMethod(MethodGen methodGen) {\n\t\tLineNumberTable lineNumberTable = methodGen.getLineNumberTable(methodGen.getConstantPool());\n\t\tString className = methodGen.getClassName();\n\t\tif (lineNumberTable == null)\n\t\t\treturn createUnknown(className);\n\t\treturn forEntireMethod(className, lineNumberTable);\n\t}","commit_id":"2fb6c97894c154ca57a81a49d4915901fb95989f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static SourceLineAnnotation forEntireMethod(String className, LineNumberTable lineNumberTable) {\n\t\tLineNumber[] table = lineNumberTable.getLineNumberTable();\n\t\treturn (table != null && table.length > 0)\n\t\t\t? new SourceLineAnnotation(className, table[0].getLineNumber(), table[table.length-1].getLineNumber())\n\t\t\t: null;\n\t}","id":31273,"modified_method":"private static SourceLineAnnotation forEntireMethod(String className, LineNumberTable lineNumberTable) {\n\t\tLineNumber[] table = lineNumberTable.getLineNumberTable();\n\t\treturn (table != null && table.length > 0)\n\t\t\t? new SourceLineAnnotation(className, table[0].getLineNumber(), table[table.length-1].getLineNumber())\n\t\t\t: createUnknown(className);\n\t}","commit_id":"2fb6c97894c154ca57a81a49d4915901fb95989f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Factory method for creating a source line annotation describing the\n\t * source line numbers for a range of instructions in the method being\n\t * visited by the given visitor.\n\t * @param visitor a BetterVisitor which is visiting the method\n\t * @param startPC the bytecode offset of the start instruction in the range\n\t * @param endPC the bytecode offset of the end instruction in the range\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the instruction\n\t */\n\tpublic static SourceLineAnnotation fromVisitedInstructionRange(BetterVisitor visitor, int startPC, int endPC) {\n\t\tLineNumberTable lineNumberTable = getLineNumberTable(visitor);\n\t\tif (lineNumberTable == null)\n\t\t\treturn null;\n\n\t\tint startLine = lineNumberTable.getSourceLine(startPC);\n\t\tint endLine = lineNumberTable.getSourceLine(endPC);\n\t\treturn new SourceLineAnnotation(visitor.getBetterClassName(), startLine, endLine);\n\t}","id":31274,"modified_method":"/**\n\t * Factory method for creating a source line annotation describing the\n\t * source line numbers for a range of instructions in the method being\n\t * visited by the given visitor.\n\t * @param visitor a BetterVisitor which is visiting the method\n\t * @param startPC the bytecode offset of the start instruction in the range\n\t * @param endPC the bytecode offset of the end instruction in the range\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the instruction\n\t */\n\tpublic static SourceLineAnnotation fromVisitedInstructionRange(BetterVisitor visitor, int startPC, int endPC) {\n\t\tLineNumberTable lineNumberTable = getLineNumberTable(visitor);\n\t\tString className = visitor.getBetterClassName();\n\n\t\tif (lineNumberTable == null)\n\t\t\treturn createUnknown(className);\n\n\t\tint startLine = lineNumberTable.getSourceLine(startPC);\n\t\tint endLine = lineNumberTable.getSourceLine(endPC);\n\t\treturn new SourceLineAnnotation(className, startLine, endLine);\n\t}","commit_id":"2fb6c97894c154ca57a81a49d4915901fb95989f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * the source line numbers for a range of instruction in a method.\n\t * @param methodGen the method\n\t * @param start the start instruction\n\t * @param end the end instruction (inclusive)\n\t */\n\tpublic static SourceLineAnnotation fromVisitedInstructionRange(MethodGen methodGen, InstructionHandle start, InstructionHandle end) {\n\t\tLineNumberTable lineNumberTable = methodGen.getLineNumberTable(methodGen.getConstantPool());\n\t\tif (lineNumberTable == null)\n\t\t\treturn null;\n\n\t\tint startLine = lineNumberTable.getSourceLine(start.getPosition());\n\t\tint endLine = lineNumberTable.getSourceLine(end.getPosition());\n\t\treturn new SourceLineAnnotation(methodGen.getClassName(), startLine, endLine);\n\t}","id":31275,"modified_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * the source line numbers for a range of instruction in a method.\n\t * @param methodGen the method\n\t * @param start the start instruction\n\t * @param end the end instruction (inclusive)\n\t */\n\tpublic static SourceLineAnnotation fromVisitedInstructionRange(MethodGen methodGen, InstructionHandle start, InstructionHandle end) {\n\t\tLineNumberTable lineNumberTable = methodGen.getLineNumberTable(methodGen.getConstantPool());\n\t\tString className = methodGen.getClassName();\n\n\t\tif (lineNumberTable == null)\n\t\t\treturn createUnknown(className);\n\n\t\tint startLine = lineNumberTable.getSourceLine(start.getPosition());\n\t\tint endLine = lineNumberTable.getSourceLine(end.getPosition());\n\t\treturn new SourceLineAnnotation(className, startLine, endLine);\n\t}","commit_id":"2fb6c97894c154ca57a81a49d4915901fb95989f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * an entire method.\n\t * @param visitor a BetterVisitor which is visiting the method\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the method\n\t */\n\tpublic static SourceLineAnnotation fromVisitedMethod(BetterVisitor visitor) {\n\t\tLineNumberTable lineNumberTable = getLineNumberTable(visitor);\n\t\tif (lineNumberTable == null)\n\t\t\treturn null;\n\t\treturn forEntireMethod(visitor.getBetterClassName(), lineNumberTable);\n\t}","id":31276,"modified_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * an entire method.\n\t * @param visitor a BetterVisitor which is visiting the method\n\t * @return the SourceLineAnnotation\n\t */\n\tpublic static SourceLineAnnotation fromVisitedMethod(BetterVisitor visitor) {\n\t\tLineNumberTable lineNumberTable = getLineNumberTable(visitor);\n\t\tString className = visitor.getBetterClassName();\n\t\tif (lineNumberTable == null)\n\t\t\treturn createUnknown(className);\n\t\treturn forEntireMethod(className, lineNumberTable);\n\t}","commit_id":"2fb6c97894c154ca57a81a49d4915901fb95989f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * an entire method.\n\t * @param visitor a BetterVisitor which is visiting the method\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the method\n\t */\n\tpublic static SourceLineAnnotation fromVisitedMethod(BetterVisitor visitor) {\n\t\tLineNumberTable lineNumberTable = getLineNumberTable(visitor);\n\t\tif (lineNumberTable == null)\n\t\t\treturn null;\n\n\t\tLineNumber[] table = lineNumberTable.getLineNumberTable();\n\t\treturn new SourceLineAnnotation(visitor.getBetterClassName(), table[0].getLineNumber(), table[table.length-1].getLineNumber());\n\t}","id":31277,"modified_method":"/**\n\t * Factory method for creating a source line annotation describing\n\t * an entire method.\n\t * @param visitor a BetterVisitor which is visiting the method\n\t * @return the SourceLineAnnotation, or null if we do not have line number information\n\t *   for the method\n\t */\n\tpublic static SourceLineAnnotation fromVisitedMethod(BetterVisitor visitor) {\n\t\tLineNumberTable lineNumberTable = getLineNumberTable(visitor);\n\t\tif (lineNumberTable == null)\n\t\t\treturn null;\n\t\treturn forEntireMethod(visitor.getBetterClassName(), lineNumberTable);\n\t}","commit_id":"1fabee7cdfc96d9f8cd6d1ace27c3401b4c3ea05","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public String getWrappedElementType(QName wrapperElement, QName item) {        \n        SchemaType st = typeSystem.findElement(wrapperElement).getType();\n        SchemaType partType = st.getElementProperty(item).getType();        \n        return XMLBeansSchemaTypeUtils.getNaturalJavaClassName(partType);        \n    }","id":31278,"modified_method":"public String getWrappedElementType(QName wrapperElement, QName item) {        \n        SchemaGlobalElement elem = typeSystem.findElement(wrapperElement);\n\n        if (elem == null)  {\n            elem = typeLoader.findElement(wrapperElement);\n        }\n\n        SchemaType st = elem.getType();\n        SchemaType partType = st.getElementProperty(item).getType();        \n        return XMLBeansSchemaTypeUtils.getNaturalJavaClassName(partType);        \n    }","commit_id":"1d49f2023c512003199acf409d2d5d8622d058a8","url":"https://github.com/apache/cxf"},{"original_method":"public String getType(QName qn, boolean element) {\n        String ret;\n        if (element) {\n            ret = typeSystem.findDocumentType(qn).getFullJavaName();                  \n            if (ret.contains(\"$\")) {\n                ret = ret.substring(0, ret.indexOf('$'));\n            }\n            return ret;\n        }\n        ret = typeSystem.findType(qn).getFullJavaName();\n        return ret.replace('$', '.');\n    }","id":31279,"modified_method":"public String getType(QName qn, boolean element) {\n        String ret;\n        if (element) {\n            SchemaType type = typeSystem.findDocumentType(qn);\n            if (type == null)  {\n                type = typeLoader.findDocumentType(qn);\n            }\n\n            ret = type.getFullJavaName();\n            if (ret.contains(\"$\")) {\n                ret = ret.substring(0, ret.indexOf('$'));\n            }\n            return ret;\n        }\n\n        SchemaType type = typeSystem.findType(qn);\n        if (type == null) {\n            type = typeLoader.findType(qn);\n        }\n\n        ret = type.getFullJavaName();\n        return ret.replace('$', '.');\n    }","commit_id":"1d49f2023c512003199acf409d2d5d8622d058a8","url":"https://github.com/apache/cxf"},{"original_method":"private SchemaTypeSystem loadTypeSystem(String wsdlFile, \n                                           String[] configFiles,\n                                           Set mdefNamespaces, \n                                           File baseDir, \n                                           File schemasDir,\n                                           EntityResolver entResolver) {\n\n\n        SchemaTypeLoader loader = XmlBeans.typeLoaderForClassLoader(SchemaDocument.class.getClassLoader());\n\n        // parse all the XSD files.\n        List<SchemaDocument.Schema> scontentlist = new ArrayList<SchemaDocument.Schema>();\n        try {\n            URL url = new URL(wsdlFile);\n            XmlOptions options = new XmlOptions();\n            options.setLoadLineNumbers();\n            options.setLoadSubstituteNamespaces(Collections\n                .singletonMap(\"http://schemas.xmlsoap.org/wsdl/\",\n                              \"http://www.apache.org/internal/xmlbeans/wsdlsubst\"));\n            options.setEntityResolver(entResolver);\n            options.setGenerateJavaVersion(XmlOptions.GENERATE_JAVA_15);\n\n            state.addSourceUri(wsdlFile, null);\n            loadWSDLDoc(loader, url, options, scontentlist, errorListener);\n\n\n        } catch (XmlException e) {\n            errorListener.add(e.getError());\n        } catch (Exception e) {\n            StscState.addError(errorListener, XmlErrorCodes.CANNOT_LOAD_FILE, new Object[] {\n                \"url\", wsdlFile, e.getMessage()\n            }, (URL)null);\n        }\n\n        SchemaDocument.Schema[] sdocs = (SchemaDocument.Schema[])scontentlist\n            .toArray(new SchemaDocument.Schema[scontentlist.size()]);\n        \n        // now the config files.\n        List<ConfigDocument.Config> cdoclist = new ArrayList<ConfigDocument.Config>();\n        List<File> javaFiles = new ArrayList<File>();\n        if (configFiles != null) {\n            for (int i = 0; i < configFiles.length; i++) {\n                if (configFiles[i].endsWith(\".java\")) {\n                    javaFiles.add(new File(configFiles[i]));\n                    continue;\n                }\n                if (!configFiles[i].endsWith(\".xsdconfig\")) {\n                    //jaxws/jaxb customization file or something else\n                    continue;\n                }\n                try {\n                    XmlOptions options = new XmlOptions();\n                    options.put(XmlOptions.LOAD_LINE_NUMBERS);\n                    options.setEntityResolver(entResolver);\n                    options.setLoadSubstituteNamespaces(MAP_COMPATIBILITY_CONFIG_URIS);\n\n                    URI uri = new URI(configFiles[i]);\n                    XmlObject configdoc = null;\n                    if (\"file\".equals(uri.getRawSchemeSpecificPart())) {\n                        configdoc = loader.parse(new File(uri), null, options);                        \n                    } else {\n                        InputSource source = new InputSource(configFiles[i]);\n                        Document doc = XMLUtils.parse(source);\n                        configdoc = loader.parse(doc, null, options);                        \n                    }\n                    \n                    if (!(configdoc instanceof ConfigDocument)) {\n                        StscState.addError(errorListener, XmlErrorCodes.INVALID_DOCUMENT_TYPE, new Object[] {\n                            configFiles[i], \"xsd config\"\n                        }, configdoc);\n                    } else {\n                        StscState.addInfo(errorListener, \"Loading config file \" + configFiles[i]);\n                        if (configdoc.validate(new XmlOptions().setErrorListener(errorListener))) {\n                            ConfigDocument.Config config = ((ConfigDocument)configdoc).getConfig();\n                            cdoclist.add(config);\n                            config.setExtensionArray(new Extensionconfig[] {});\n                        }\n                    }\n                } catch (XmlException e) {\n                    errorListener.add(e.getError());\n                } catch (Exception e) {\n                    StscState.addError(errorListener, XmlErrorCodes.CANNOT_LOAD_FILE, new Object[] {\n                        \"xsd config\", configFiles[i], e.getMessage()\n                    }, new File(configFiles[i]));\n                }\n            }\n        }\n        ConfigDocument.Config[] cdocs = (ConfigDocument.Config[])cdoclist\n            .toArray(new ConfigDocument.Config[cdoclist.size()]);\n\n\n        SchemaTypeLoader linkTo = SchemaTypeLoaderImpl.build(null, cpResourceLoader, null);\n\n        URI baseURI = null;\n        if (baseDir != null) {\n            baseURI = baseDir.toURI();\n        }\n\n        XmlOptions opts = new XmlOptions();\n        opts.setCompileDownloadUrls();\n        \n        \n        if (mdefNamespaces != null) {\n            opts.setCompileMdefNamespaces(mdefNamespaces);\n        }\n        opts.setCompileNoValidation(); // already validated here\n        opts.setEntityResolver(entResolver);\n        opts.setGenerateJavaVersion(\"1.5\");\n\n        // now pass it to the main compile function\n        SchemaTypeSystemCompiler.Parameters params = new SchemaTypeSystemCompiler.Parameters();\n        params.setSchemas(sdocs);\n        params.setConfig(BindingConfigImpl.forConfigDocuments(cdocs, \n                                                              javaFiles.toArray(new File[javaFiles.size()]), \n                                                              CodeGenUtil.systemClasspath()));\n        params.setLinkTo(linkTo);\n        params.setOptions(opts);\n        params.setErrorListener(errorListener);\n        params.setJavaize(true);\n        params.setBaseURI(baseURI);\n        params.setSourcesToCopyMap(sourcesToCopyMap);\n        //params.setSchemasDir(schemasDir);\n        return SchemaTypeSystemCompiler.compile(params);\n    }","id":31280,"modified_method":"private SchemaTypeSystem loadTypeSystem(String wsdlFile, \n                                           String[] configFiles,\n                                           Set mdefNamespaces, \n                                           File baseDir, \n                                           File schemasDir,\n                                           EntityResolver entResolver) {\n\n\n        SchemaTypeLoader loader = XmlBeans.typeLoaderForClassLoader(SchemaDocument.class.getClassLoader());\n\n        // parse all the XSD files.\n        List<SchemaDocument.Schema> scontentlist = new ArrayList<SchemaDocument.Schema>();\n        try {\n            URL url = new URL(wsdlFile);\n            XmlOptions options = new XmlOptions();\n            options.setLoadLineNumbers();\n            options.setLoadSubstituteNamespaces(Collections\n                .singletonMap(\"http://schemas.xmlsoap.org/wsdl/\",\n                              \"http://www.apache.org/internal/xmlbeans/wsdlsubst\"));\n            options.setEntityResolver(entResolver);\n            options.setGenerateJavaVersion(XmlOptions.GENERATE_JAVA_15);\n\n            state.addSourceUri(wsdlFile, null);\n            loadWSDLDoc(loader, url, options, scontentlist, errorListener);\n\n\n        } catch (XmlException e) {\n            errorListener.add(e.getError());\n        } catch (Exception e) {\n            StscState.addError(errorListener, XmlErrorCodes.CANNOT_LOAD_FILE, new Object[] {\n                \"url\", wsdlFile, e.getMessage()\n            }, (URL)null);\n        }\n\n        SchemaDocument.Schema[] sdocs = (SchemaDocument.Schema[])scontentlist\n            .toArray(new SchemaDocument.Schema[scontentlist.size()]);\n        \n        // now the config files.\n        List<ConfigDocument.Config> cdoclist = new ArrayList<ConfigDocument.Config>();\n        List<File> javaFiles = new ArrayList<File>();\n        if (configFiles != null) {\n            for (int i = 0; i < configFiles.length; i++) {\n                if (configFiles[i].endsWith(\".java\")) {\n                    javaFiles.add(new File(configFiles[i]));\n                    continue;\n                }\n                if (!configFiles[i].endsWith(\".xsdconfig\")) {\n                    //jaxws/jaxb customization file or something else\n                    continue;\n                }\n                try {\n                    XmlOptions options = new XmlOptions();\n                    options.put(XmlOptions.LOAD_LINE_NUMBERS);\n                    options.setEntityResolver(entResolver);\n                    options.setLoadSubstituteNamespaces(MAP_COMPATIBILITY_CONFIG_URIS);\n\n                    URI uri = new URI(configFiles[i]);\n                    XmlObject configdoc = null;\n                    if (\"file\".equals(uri.getRawSchemeSpecificPart())) {\n                        configdoc = loader.parse(new File(uri), null, options);                        \n                    } else {\n                        InputSource source = new InputSource(configFiles[i]);\n                        Document doc = XMLUtils.parse(source);\n                        configdoc = loader.parse(doc, null, options);                        \n                    }\n                    \n                    if (!(configdoc instanceof ConfigDocument)) {\n                        StscState.addError(errorListener, XmlErrorCodes.INVALID_DOCUMENT_TYPE, new Object[] {\n                            configFiles[i], \"xsd config\"\n                        }, configdoc);\n                    } else {\n                        StscState.addInfo(errorListener, \"Loading config file \" + configFiles[i]);\n                        if (configdoc.validate(new XmlOptions().setErrorListener(errorListener))) {\n                            ConfigDocument.Config config = ((ConfigDocument)configdoc).getConfig();\n                            cdoclist.add(config);\n                            config.setExtensionArray(new Extensionconfig[] {});\n                        }\n                    }\n                } catch (XmlException e) {\n                    errorListener.add(e.getError());\n                } catch (Exception e) {\n                    StscState.addError(errorListener, XmlErrorCodes.CANNOT_LOAD_FILE, new Object[] {\n                        \"xsd config\", configFiles[i], e.getMessage()\n                    }, new File(configFiles[i]));\n                }\n            }\n        }\n        ConfigDocument.Config[] cdocs = (ConfigDocument.Config[])cdoclist\n            .toArray(new ConfigDocument.Config[cdoclist.size()]);\n\n\n        SchemaTypeLoader linkTo = SchemaTypeLoaderImpl.build(null, cpResourceLoader, null);\n\n        URI baseURI = null;\n        if (baseDir != null) {\n            baseURI = baseDir.toURI();\n        }\n\n        XmlOptions opts = new XmlOptions();\n        opts.setCompileDownloadUrls();\n        \n        \n        if (mdefNamespaces != null) {\n            opts.setCompileMdefNamespaces(mdefNamespaces);\n        }\n        opts.setCompileNoValidation(); // already validated here\n        opts.setEntityResolver(entResolver);\n        opts.setGenerateJavaVersion(\"1.5\");\n\n        // now pass it to the main compile function\n        SchemaTypeSystemCompiler.Parameters params = new SchemaTypeSystemCompiler.Parameters();\n        params.setSchemas(sdocs);\n        params.setConfig(BindingConfigImpl.forConfigDocuments(cdocs, \n                                                              javaFiles.toArray(new File[javaFiles.size()]), \n                                                              CodeGenUtil.systemClasspath()));\n\n        typeLoader = loader;\n\n        params.setLinkTo(linkTo);\n        params.setOptions(opts);\n        params.setErrorListener(errorListener);\n        params.setJavaize(true);\n        params.setBaseURI(baseURI);\n        params.setSourcesToCopyMap(sourcesToCopyMap);\n        //params.setSchemasDir(schemasDir);\n        return SchemaTypeSystemCompiler.compile(params);\n    }","commit_id":"1d49f2023c512003199acf409d2d5d8622d058a8","url":"https://github.com/apache/cxf"},{"original_method":"public JvmType findType(final URI resourceURI, final String fragment, final boolean traverseNestedTypes) {\n    JvmType _xblockexpression = null;\n    {\n      final IndexedJvmTypeAccess indexedJvmTypeAccess = this.getIndexedJvmTypeAccess();\n      if ((indexedJvmTypeAccess != null)) {\n        final URI proxyURI = resourceURI.appendFragment(fragment);\n        ResourceSet _resourceSet = this.getResourceSet();\n        final EObject candidate = indexedJvmTypeAccess.getIndexedJvmType(proxyURI, _resourceSet);\n        if ((candidate instanceof JvmType)) {\n          return ((JvmType)candidate);\n        }\n      }\n      ProgressIndicatorProvider.checkCanceled();\n      JvmType _xtrycatchfinallyexpression = null;\n      try {\n        JvmType _xblockexpression_1 = null;\n        {\n          ResourceSet _resourceSet_1 = this.getResourceSet();\n          final Resource resource = _resourceSet_1.getResource(resourceURI, true);\n          _xblockexpression_1 = this.findType(resource, fragment, traverseNestedTypes);\n        }\n        _xtrycatchfinallyexpression = _xblockexpression_1;\n      } catch (final Throwable _t) {\n        if (_t instanceof OperationCanceledError) {\n          final OperationCanceledError e = (OperationCanceledError)_t;\n          throw e.getWrapped();\n        } else {\n          throw Exceptions.sneakyThrow(_t);\n        }\n      }\n      _xblockexpression = _xtrycatchfinallyexpression;\n    }\n    return _xblockexpression;\n  }","id":31281,"modified_method":"public JvmType findType(final URI resourceURI, final String fragment, final boolean traverseNestedTypes) {\n    try {\n      final IndexedJvmTypeAccess indexedJvmTypeAccess = this.getIndexedJvmTypeAccess();\n      if ((indexedJvmTypeAccess != null)) {\n        final URI proxyURI = resourceURI.appendFragment(fragment);\n        ResourceSet _resourceSet = this.getResourceSet();\n        final EObject candidate = indexedJvmTypeAccess.getIndexedJvmType(proxyURI, _resourceSet);\n        if ((candidate instanceof JvmType)) {\n          return ((JvmType)candidate);\n        }\n      }\n      ProgressIndicatorProvider.checkCanceled();\n      try {\n        ResourceSet _resourceSet_1 = this.getResourceSet();\n        final Resource existing = _resourceSet_1.getResource(resourceURI, false);\n        boolean _notEquals = (!Objects.equal(existing, null));\n        if (_notEquals) {\n          return this.findType(existing, fragment, traverseNestedTypes);\n        }\n        final IMirror mirror = this.createMirror(resourceURI);\n        boolean _equals = Objects.equal(mirror, null);\n        if (_equals) {\n          return null;\n        }\n        final TypeResource resource = this.doCreateResource(resourceURI);\n        resource.setMirror(mirror);\n        ResourceSet _resourceSet_2 = this.getResourceSet();\n        EList<Resource> _resources = _resourceSet_2.getResources();\n        _resources.add(resource);\n        resource.load(null);\n        return this.findType(resource, fragment, traverseNestedTypes);\n      } catch (final Throwable _t) {\n        if (_t instanceof OperationCanceledError) {\n          final OperationCanceledError e = (OperationCanceledError)_t;\n          throw e.getWrapped();\n        } else {\n          throw Exceptions.sneakyThrow(_t);\n        }\n      }\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"7b9e8b479e5f1037ce09abcdcbadb3a26936dab9","url":"https://github.com/eclipse/xtext"},{"original_method":"public void exportClassSchema(final ODatabaseRecord<?> db, final OJSONWriter json, final OClass cls) throws IOException {\r\n    if (cls == null)\r\n      return;\r\n\r\n    json.write(\" \\\"schema\\\": \");\r\n    json.beginObject(1, false, null);\r\n    json.writeAttribute(2, true, \"id\", cls.getId());\r\n    json.writeAttribute(2, true, \"name\", cls.getName());\r\n\r\n    if (cls.properties() != null && cls.properties().size() > 0) {\r\n      json.beginObject(2, true, \"properties\");\r\n      for (OProperty prop : cls.properties()) {\r\n        json.beginObject(3, true, prop.getName());\r\n        json.writeAttribute(4, true, \"id\", prop.getId());\r\n        json.writeAttribute(4, true, \"name\", prop.getName());\r\n        if (prop.getLinkedClass() != null)\r\n          json.writeAttribute(4, true, \"linkedClass\", prop.getLinkedClass().getName());\r\n        if (prop.getLinkedType() != null)\r\n          json.writeAttribute(4, true, \"linkedType\", prop.getLinkedType());\r\n        json.writeAttribute(4, true, \"type\", prop.getType().toString());\r\n        json.writeAttribute(4, true, \"mandatory\", prop.isMandatory());\r\n        json.writeAttribute(4, true, \"notNull\", prop.isNotNull());\r\n        json.writeAttribute(4, true, \"min\", prop.getMin());\r\n        json.writeAttribute(4, true, \"max\", prop.getMax());\r\n        json.endObject(3, true);\r\n      }\r\n      json.endObject(2, true);\r\n    }\r\n    json.endObject(1, true);\r\n  }","id":31282,"modified_method":"public void exportClassSchema(final ODatabaseRecord<?> db, final OJSONWriter json, final OClass cls) throws IOException {\r\n    if (cls == null)\r\n      return;\r\n\r\n    json.write(\" \\\"schema\\\": \");\r\n    json.beginObject(1, false, null);\r\n    json.writeAttribute(2, true, \"id\", cls.getId());\r\n    json.writeAttribute(2, true, \"name\", cls.getName());\r\n\r\n    if (cls.properties() != null && cls.properties().size() > 0) {\r\n      json.beginObject(2, true, \"properties\");\r\n      for (OProperty prop : cls.properties()) {\r\n        json.beginObject(3, true, prop.getName());\r\n        json.writeAttribute(4, true, \"id\", prop.getId());\r\n        json.writeAttribute(4, true, \"name\", prop.getName());\r\n        if (prop.getLinkedClass() != null)\r\n          json.writeAttribute(4, true, \"linkedClass\", prop.getLinkedClass().getName());\r\n        if (prop.getLinkedType() != null)\r\n          json.writeAttribute(4, true, \"linkedType\", prop.getLinkedType().toString());\r\n        json.writeAttribute(4, true, \"type\", prop.getType().toString());\r\n        json.writeAttribute(4, true, \"mandatory\", prop.isMandatory());\r\n        json.writeAttribute(4, true, \"notNull\", prop.isNotNull());\r\n        json.writeAttribute(4, true, \"min\", prop.getMin());\r\n        json.writeAttribute(4, true, \"max\", prop.getMax());\r\n        json.endObject(3, true);\r\n      }\r\n      json.endObject(2, true);\r\n    }\r\n    json.endObject(1, true);\r\n  }","commit_id":"b1032cea3157adb37106c1f615e9a36615d60abd","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void exportClass(final ODatabaseDocumentTx db, final OJSONWriter json, final OClass cls) throws IOException {\r\n\t\tjson.beginObject(2, true, null);\r\n\t\tjson.writeAttribute(3, true, \"id\", cls.getId());\r\n\t\tjson.writeAttribute(3, true, \"name\", cls.getName());\r\n\t\tjson.writeAttribute(3, true, \"clusters\", cls.getClusterIds());\r\n\t\tjson.writeAttribute(3, true, \"defaultCluster\", cls.getDefaultClusterId());\r\n\t\ttry {\r\n\t\t\tjson.writeAttribute(3, false, \"records\", db.countClass(cls.getName()));\r\n\t\t} catch (OSecurityAccessException e) {\r\n\t\t\tjson.writeAttribute(3, false, \"records\", \"? (Unauthorized)\");\r\n\t\t}\r\n\r\n\t\tif (cls.properties() != null && cls.properties().size() > 0) {\r\n\t\t\tjson.beginCollection(3, true, \"properties\");\r\n\t\t\tfor (OProperty prop : cls.properties()) {\r\n\t\t\t\tjson.beginObject(4, true, null);\r\n\t\t\t\tjson.writeAttribute(4, true, \"id\", prop.getId());\r\n\t\t\t\tjson.writeAttribute(4, true, \"name\", prop.getName());\r\n\t\t\t\tif (prop.getLinkedClass() != null)\r\n\t\t\t\t\tjson.writeAttribute(4, true, \"linkedClass\", prop.getLinkedClass().getName());\r\n\t\t\t\tif (prop.getLinkedType() != null)\r\n\t\t\t\t\tjson.writeAttribute(4, true, \"linkedType\", prop.getLinkedType());\r\n\t\t\t\tjson.writeAttribute(4, true, \"type\", prop.getType().toString());\r\n\t\t\t\tjson.writeAttribute(4, true, \"mandatory\", prop.isMandatory());\r\n\t\t\t\tjson.writeAttribute(4, true, \"notNull\", prop.isNotNull());\r\n\t\t\t\tjson.writeAttribute(4, true, \"min\", prop.getMin());\r\n\t\t\t\tjson.writeAttribute(4, true, \"max\", prop.getMax());\r\n\t\t\t\tjson.endObject(3, true);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, true);\r\n\t\t}\r\n\t\tjson.endObject(1, false);\r\n\t}","id":31283,"modified_method":"public void exportClass(final ODatabaseDocumentTx db, final OJSONWriter json, final OClass cls) throws IOException {\r\n\t\tjson.beginObject(2, true, null);\r\n\t\tjson.writeAttribute(3, true, \"id\", cls.getId());\r\n\t\tjson.writeAttribute(3, true, \"name\", cls.getName());\r\n\t\tjson.writeAttribute(3, true, \"clusters\", cls.getClusterIds());\r\n\t\tjson.writeAttribute(3, true, \"defaultCluster\", cls.getDefaultClusterId());\r\n\t\ttry {\r\n\t\t\tjson.writeAttribute(3, false, \"records\", db.countClass(cls.getName()));\r\n\t\t} catch (OSecurityAccessException e) {\r\n\t\t\tjson.writeAttribute(3, false, \"records\", \"? (Unauthorized)\");\r\n\t\t}\r\n\r\n\t\tif (cls.properties() != null && cls.properties().size() > 0) {\r\n\t\t\tjson.beginCollection(3, true, \"properties\");\r\n\t\t\tfor (OProperty prop : cls.properties()) {\r\n\t\t\t\tjson.beginObject(4, true, null);\r\n\t\t\t\tjson.writeAttribute(4, true, \"id\", prop.getId());\r\n\t\t\t\tjson.writeAttribute(4, true, \"name\", prop.getName());\r\n\t\t\t\tif (prop.getLinkedClass() != null)\r\n\t\t\t\t\tjson.writeAttribute(4, true, \"linkedClass\", prop.getLinkedClass().getName());\r\n\t\t\t\tif (prop.getLinkedType() != null)\r\n\t\t\t\t\tjson.writeAttribute(4, true, \"linkedType\", prop.getLinkedType().toString());\r\n\t\t\t\tjson.writeAttribute(4, true, \"type\", prop.getType().toString());\r\n\t\t\t\tjson.writeAttribute(4, true, \"mandatory\", prop.isMandatory());\r\n\t\t\t\tjson.writeAttribute(4, true, \"notNull\", prop.isNotNull());\r\n\t\t\t\tjson.writeAttribute(4, true, \"min\", prop.getMin());\r\n\t\t\t\tjson.writeAttribute(4, true, \"max\", prop.getMax());\r\n\t\t\t\tjson.endObject(3, true);\r\n\t\t\t}\r\n\t\t\tjson.endCollection(1, true);\r\n\t\t}\r\n\t\tjson.endObject(1, false);\r\n\t}","commit_id":"dbaae0cc3d62fd5628cde06b3129fee3bdffeff8","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ContainerRemoteLaunchEvent(TaskAttemptId taskAttemptID,\n      ContainerId containerID, String containerMgrAddress,\n      ContainerToken containerToken) {\n    super(taskAttemptID, containerID, containerMgrAddress,\n        containerToken,\n        ContainerLauncher.EventType.CONTAINER_REMOTE_LAUNCH);\n  }","id":31284,"modified_method":"public ContainerRemoteLaunchEvent(TaskAttemptId taskAttemptID,\n      ContainerId containerID, String containerMgrAddress,\n      ContainerToken containerToken,\n      ContainerLaunchContext containerLaunchContext, Task remoteTask) {\n    super(taskAttemptID, containerID, containerMgrAddress, containerToken,\n        ContainerLauncher.EventType.CONTAINER_REMOTE_LAUNCH);\n    this.container = containerLaunchContext;\n    this.task = remoteTask;\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"public abstract ContainerLaunchContext getContainer();","id":31285,"modified_method":"public ContainerLaunchContext getContainer() {\n    return this.container;\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"public abstract Task getRemoteTask();","id":31286,"modified_method":"public Task getRemoteTask() {\n    return this.task;\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n    protected void setup(JobImpl job) throws IOException {\n      job.conf.setInt(MRJobConfig.NUM_REDUCES, reduces);\n      job.remoteJobConfFile = new Path(\"test\");\n    }","id":31287,"modified_method":"@Override\n    protected void setup(JobImpl job) throws IOException {\n      super.setup(job);\n      job.conf.setInt(MRJobConfig.NUM_REDUCES, reduces);\n      job.remoteJobConfFile = new Path(\"test\");\n    }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"public Job submit(Configuration conf) throws Exception {\n    String user = conf.get(MRJobConfig.USER_NAME, \"mapred\");\n    conf.set(MRJobConfig.USER_NAME, user);\n    conf.set(MRJobConfig.MR_AM_STAGING_DIR, testAbsPath.toString());\n    conf.setBoolean(MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR, true);\n    //TODO: fix the bug where the speculator gets events with \n    //not-fully-constructed objects. For now, disable speculative exec\n    LOG.info(\"****DISABLING SPECULATIVE EXECUTION*****\");\n    conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n    conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n\n    init(conf);\n    start();\n    DefaultMetricsSystem.shutdown();\n    Job job = getContext().getAllJobs().values().iterator().next();\n    return job;\n  }","id":31288,"modified_method":"public Job submit(Configuration conf) throws Exception {\n    String user = conf.get(MRJobConfig.USER_NAME, UserGroupInformation\n      .getCurrentUser().getShortUserName());\n    conf.set(MRJobConfig.USER_NAME, user);\n    conf.set(MRJobConfig.MR_AM_STAGING_DIR, testAbsPath.toString());\n    conf.setBoolean(MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR, true);\n    //TODO: fix the bug where the speculator gets events with \n    //not-fully-constructed objects. For now, disable speculative exec\n    LOG.info(\"****DISABLING SPECULATIVE EXECUTION*****\");\n    conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n    conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n\n    init(conf);\n    start();\n    DefaultMetricsSystem.shutdown();\n    Job job = getContext().getAllJobs().values().iterator().next();\n\n    // Write job.xml\n    String jobFile = MRApps.getJobFile(conf, user,\n      TypeConverter.fromYarn(job.getID()));\n    LOG.info(\"Writing job conf to \" + jobFile);\n    new File(jobFile).getParentFile().mkdirs();\n    conf.writeXml(new FileOutputStream(jobFile));\n\n    return job;\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected TaskAttemptListener createTaskAttemptListener(AppContext context) {\n    return new TaskAttemptListener(){\n      @Override\n      public InetSocketAddress getAddress() {\n        return null;\n      }\n      @Override\n      public void registerLaunchedTask(TaskAttemptId attemptID, \n          org.apache.hadoop.mapred.Task task, WrappedJvmID jvmID) {}\n      @Override\n      public void unregister(TaskAttemptId attemptID, WrappedJvmID jvmID) {\n      }\n      @Override\n      public void registerPendingTask(WrappedJvmID jvmID) {\n      }\n    };\n  }","id":31289,"modified_method":"@Override\n  protected TaskAttemptListener createTaskAttemptListener(AppContext context) {\n    return new TaskAttemptListener(){\n      @Override\n      public InetSocketAddress getAddress() {\n        return NetUtils.createSocketAddr(\"localhost:54321\");\n      }\n      @Override\n      public void registerLaunchedTask(TaskAttemptId attemptID, \n          org.apache.hadoop.mapred.Task task, WrappedJvmID jvmID) {}\n      @Override\n      public void unregister(TaskAttemptId attemptID, WrappedJvmID jvmID) {\n      }\n      @Override\n      public void registerPendingTask(WrappedJvmID jvmID) {\n      }\n    };\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"public static void setVMEnv(Map<String, String> environment,\n      Task task) {\n\n    JobConf conf = task.conf;\n\n    // Shell\n    environment.put(\n        Environment.SHELL.name(), \n        conf.get(\n            MRJobConfig.MAPRED_ADMIN_USER_SHELL, \n            MRJobConfig.DEFAULT_SHELL)\n            );\n    \n    // Add pwd to LD_LIBRARY_PATH, add this before adding anything else\n    Apps.addToEnvironment(\n        environment, \n        Environment.LD_LIBRARY_PATH.name(), \n        Environment.PWD.$());\n\n    // Add the env variables passed by the user & admin\n    String mapredChildEnv = getChildEnv(conf, task.isMapTask());\n    Apps.setEnvFromInputString(environment, mapredChildEnv);\n    Apps.setEnvFromInputString(\n        environment, \n        conf.get(\n            MRJobConfig.MAPRED_ADMIN_USER_ENV, \n            MRJobConfig.DEFAULT_MAPRED_ADMIN_USER_ENV)\n        );\n\n    // Set logging level in the environment.\n    // This is so that, if the child forks another \"bin/hadoop\" (common in\n    // streaming) it will have the correct loglevel.\n    environment.put(\n        \"HADOOP_ROOT_LOGGER\", \n        getChildLogLevel(conf, task.isMapTask()) + \",CLA\"); \n\n    // TODO: The following is useful for instance in streaming tasks. Should be\n    // set in ApplicationMaster's env by the RM.\n    String hadoopClientOpts = System.getenv(\"HADOOP_CLIENT_OPTS\");\n    if (hadoopClientOpts == null) {\n      hadoopClientOpts = \"\";\n    } else {\n      hadoopClientOpts = hadoopClientOpts + \" \";\n    }\n    // FIXME: don't think this is also needed given we already set java\n    // properties.\n    long logSize = TaskLog.getTaskLogLength(conf);\n    Vector<String> logProps = new Vector<String>(4);\n    setupLog4jProperties(task, logProps, logSize);\n    Iterator<String> it = logProps.iterator();\n    StringBuffer buffer = new StringBuffer();\n    while (it.hasNext()) {\n      buffer.append(\" \" + it.next());\n    }\n    hadoopClientOpts = hadoopClientOpts + buffer.toString();\n    environment.put(\"HADOOP_CLIENT_OPTS\", hadoopClientOpts);\n\n    // Add stdout/stderr env\n    environment.put(\n        MRJobConfig.STDOUT_LOGFILE_ENV,\n        getTaskLogFile(TaskLog.LogName.STDOUT)\n        );\n    environment.put(\n        MRJobConfig.STDERR_LOGFILE_ENV,\n        getTaskLogFile(TaskLog.LogName.STDERR)\n        );\n    environment.put(MRJobConfig.APPLICATION_ATTEMPT_ID_ENV, \n        \tconf.get(MRJobConfig.APPLICATION_ATTEMPT_ID).toString());\n  }","id":31290,"modified_method":"public static void setVMEnv(Map<String, String> environment,\n      Task task) {\n\n    JobConf conf = task.conf;\n\n    // Add the env variables passed by the user\n    String mapredChildEnv = getChildEnv(conf, task.isMapTask());\n    Apps.setEnvFromInputString(environment, mapredChildEnv);\n\n    // Set logging level in the environment.\n    // This is so that, if the child forks another \"bin/hadoop\" (common in\n    // streaming) it will have the correct loglevel.\n    environment.put(\n        \"HADOOP_ROOT_LOGGER\", \n        getChildLogLevel(conf, task.isMapTask()) + \",CLA\"); \n\n    // TODO: The following is useful for instance in streaming tasks. Should be\n    // set in ApplicationMaster's env by the RM.\n    String hadoopClientOpts = System.getenv(\"HADOOP_CLIENT_OPTS\");\n    if (hadoopClientOpts == null) {\n      hadoopClientOpts = \"\";\n    } else {\n      hadoopClientOpts = hadoopClientOpts + \" \";\n    }\n    // FIXME: don't think this is also needed given we already set java\n    // properties.\n    long logSize = TaskLog.getTaskLogLength(conf);\n    Vector<String> logProps = new Vector<String>(4);\n    setupLog4jProperties(task, logProps, logSize);\n    Iterator<String> it = logProps.iterator();\n    StringBuffer buffer = new StringBuffer();\n    while (it.hasNext()) {\n      buffer.append(\" \" + it.next());\n    }\n    hadoopClientOpts = hadoopClientOpts + buffer.toString();\n    environment.put(\"HADOOP_CLIENT_OPTS\", hadoopClientOpts);\n\n    // Add stdout/stderr env\n    environment.put(\n        MRJobConfig.STDOUT_LOGFILE_ENV,\n        getTaskLogFile(TaskLog.LogName.STDOUT)\n        );\n    environment.put(\n        MRJobConfig.STDERR_LOGFILE_ENV,\n        getTaskLogFile(TaskLog.LogName.STDERR)\n        );\n    environment.put(MRJobConfig.APPLICATION_ATTEMPT_ID_ENV, \n        \tconf.get(MRJobConfig.APPLICATION_ATTEMPT_ID).toString());\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"private static String getChildEnv(JobConf jobConf, boolean isMap) {\n    if (isMap) {\n      return jobConf.get(JobConf.MAPRED_MAP_TASK_ENV,\n          jobConf.get(JobConf.MAPRED_TASK_ENV));\n    }\n    return jobConf.get(JobConf.MAPRED_REDUCE_TASK_ENV,\n        jobConf.get(jobConf.MAPRED_TASK_ENV));\n  }","id":31291,"modified_method":"private static String getChildEnv(JobConf jobConf, boolean isMap) {\n    if (isMap) {\n      return jobConf.get(JobConf.MAPRED_MAP_TASK_ENV,\n          jobConf.get(JobConf.MAPRED_TASK_ENV));\n    }\n    return jobConf.get(JobConf.MAPRED_REDUCE_TASK_ENV,\n        jobConf.get(JobConf.MAPRED_TASK_ENV));\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Create a {@link LocalResource} record with all the given parameters.\n   * TODO: This should pave way for Builder pattern.\n   */\n  private static LocalResource createLocalResource(FileSystem fc,\n      RecordFactory recordFactory, Path file, LocalResourceType type,\n      LocalResourceVisibility visibility) throws IOException {\n    FileStatus fstat = fc.getFileStatus(file);\n    LocalResource resource =\n        recordFactory.newRecordInstance(LocalResource.class);\n    resource.setResource(ConverterUtils.getYarnUrlFromPath(fc.resolvePath(fstat\n        .getPath())));\n    resource.setType(type);\n    resource.setVisibility(visibility);\n    resource.setSize(fstat.getLen());\n    resource.setTimestamp(fstat.getModificationTime());\n    return resource;\n  }","id":31292,"modified_method":"/**\n   * Create a {@link LocalResource} record with all the given parameters.\n   */\n  private static LocalResource createLocalResource(FileSystem fc, Path file,\n      LocalResourceType type, LocalResourceVisibility visibility)\n      throws IOException {\n    FileStatus fstat = fc.getFileStatus(file);\n    URL resourceURL = ConverterUtils.getYarnUrlFromPath(fc.resolvePath(fstat\n        .getPath()));\n    long resourceSize = fstat.getLen();\n    long resourceModificationTime = fstat.getModificationTime();\n\n    return BuilderUtils.newLocalResource(resourceURL, type, visibility,\n        resourceSize, resourceModificationTime);\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public void transition(TaskAttemptImpl taskAttempt, \n        TaskAttemptEvent event) {\n      @SuppressWarnings(\"deprecation\")\n      TaskAttemptContext taskContext =\n        new TaskAttemptContextImpl(taskAttempt.conf,\n            TypeConverter.fromYarn(taskAttempt.attemptId));\n      taskAttempt.eventHandler.handle(new TaskCleanupEvent(\n          taskAttempt.attemptId,\n          taskAttempt.committer,\n          taskContext));\n    }","id":31293,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public void transition(TaskAttemptImpl taskAttempt, \n        TaskAttemptEvent event) {\n      TaskAttemptContext taskContext =\n        new TaskAttemptContextImpl(taskAttempt.conf,\n            TypeConverter.fromYarn(taskAttempt.attemptId));\n      taskAttempt.eventHandler.handle(new TaskCleanupEvent(\n          taskAttempt.attemptId,\n          taskAttempt.committer,\n          taskContext));\n    }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Create the {@link ContainerLaunchContext} for this attempt.\n   * @param applicationACLs \n   */\n  private ContainerLaunchContext createContainerLaunchContext(\n      Map<ApplicationAccessType, String> applicationACLs) {\n\n    // Application resources\n    Map<String, LocalResource> localResources = \n        new HashMap<String, LocalResource>();\n    \n    // Application environment\n    Map<String, String> environment = new HashMap<String, String>();\n\n    // Service data\n    Map<String, ByteBuffer> serviceData = new HashMap<String, ByteBuffer>();\n\n    // Tokens\n    ByteBuffer tokens = ByteBuffer.wrap(new byte[]{});\n    try {\n      FileSystem remoteFS = FileSystem.get(conf);\n\n      // //////////// Set up JobJar to be localized properly on the remote NM.\n      if (conf.get(MRJobConfig.JAR) != null) {\n        Path remoteJobJar = (new Path(remoteTask.getConf().get(\n              MRJobConfig.JAR))).makeQualified(remoteFS.getUri(), \n                                               remoteFS.getWorkingDirectory());\n        localResources.put(\n            MRJobConfig.JOB_JAR,\n            createLocalResource(remoteFS, recordFactory, remoteJobJar,\n                LocalResourceType.FILE, LocalResourceVisibility.APPLICATION));\n        LOG.info(\"The job-jar file on the remote FS is \"\n            + remoteJobJar.toUri().toASCIIString());\n      } else {\n        // Job jar may be null. For e.g, for pipes, the job jar is the hadoop\n        // mapreduce jar itself which is already on the classpath.\n        LOG.info(\"Job jar is not present. \"\n            + \"Not adding any jar to the list of resources.\");\n      }\n      // //////////// End of JobJar setup\n\n      // //////////// Set up JobConf to be localized properly on the remote NM.\n      Path path =\n          MRApps.getStagingAreaDir(conf, UserGroupInformation\n              .getCurrentUser().getShortUserName());\n      Path remoteJobSubmitDir =\n          new Path(path, oldJobId.toString());\n      Path remoteJobConfPath = \n          new Path(remoteJobSubmitDir, MRJobConfig.JOB_CONF_FILE);\n      localResources.put(\n          MRJobConfig.JOB_CONF_FILE,\n          createLocalResource(remoteFS, recordFactory, remoteJobConfPath,\n              LocalResourceType.FILE, LocalResourceVisibility.APPLICATION));\n      LOG.info(\"The job-conf file on the remote FS is \"\n          + remoteJobConfPath.toUri().toASCIIString());\n      // //////////// End of JobConf setup\n\n      // Setup DistributedCache\n      MRApps.setupDistributedCache(conf, localResources);\n\n      // Setup up tokens\n      Credentials taskCredentials = new Credentials();\n\n      if (UserGroupInformation.isSecurityEnabled()) {\n        // Add file-system tokens\n        for (Token<? extends TokenIdentifier> token : fsTokens) {\n          LOG.info(\"Putting fs-token for NM use for launching container : \"\n              + token.toString());\n          taskCredentials.addToken(token.getService(), token);\n        }\n      }\n\n      // LocalStorageToken is needed irrespective of whether security is enabled\n      // or not.\n      TokenCache.setJobToken(jobToken, taskCredentials);\n\n      DataOutputBuffer containerTokens_dob = new DataOutputBuffer();\n      LOG.info(\"Size of containertokens_dob is \"\n          + taskCredentials.numberOfTokens());\n      taskCredentials.writeTokenStorageToStream(containerTokens_dob);\n      tokens = \n          ByteBuffer.wrap(containerTokens_dob.getData(), 0,\n              containerTokens_dob.getLength());\n\n      // Add shuffle token\n      LOG.info(\"Putting shuffle token in serviceData\");\n      serviceData.put(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID,\n          ShuffleHandler.serializeServiceData(jobToken));\n\n      Apps.addToEnvironment(\n          environment,  \n          Environment.CLASSPATH.name(), \n          getInitialClasspath());\n    } catch (IOException e) {\n      throw new YarnException(e);\n    }\n\n    // Setup environment\n    MapReduceChildJVM.setVMEnv(environment, remoteTask);\n\n    // Set up the launch command\n    List<String> commands = MapReduceChildJVM.getVMCommand(\n        taskAttemptListener.getAddress(), remoteTask,\n        jvmID);\n    \n    // Construct the actual Container\n    ContainerLaunchContext container = BuilderUtils\n        .newContainerLaunchContext(containerID, conf\n            .get(MRJobConfig.USER_NAME), assignedCapability, localResources,\n            environment, commands, serviceData, tokens, applicationACLs);\n\n    return container;\n  }","id":31294,"modified_method":"/**\n   * Create the common {@link ContainerLaunchContext} for all attempts.\n   * @param applicationACLs \n   */\n  private static ContainerLaunchContext createCommonContainerLaunchContext(\n      Map<ApplicationAccessType, String> applicationACLs, Configuration conf,\n      Token<JobTokenIdentifier> jobToken,\n      final org.apache.hadoop.mapred.JobID oldJobId,\n      Collection<Token<? extends TokenIdentifier>> fsTokens) {\n\n    // Application resources\n    Map<String, LocalResource> localResources = \n        new HashMap<String, LocalResource>();\n    \n    // Application environment\n    Map<String, String> environment = new HashMap<String, String>();\n\n    // Service data\n    Map<String, ByteBuffer> serviceData = new HashMap<String, ByteBuffer>();\n\n    // Tokens\n    ByteBuffer tokens = ByteBuffer.wrap(new byte[]{});\n    try {\n      FileSystem remoteFS = FileSystem.get(conf);\n\n      // //////////// Set up JobJar to be localized properly on the remote NM.\n      String jobJar = conf.get(MRJobConfig.JAR);\n      if (jobJar != null) {\n        Path remoteJobJar = (new Path(jobJar)).makeQualified(remoteFS\n            .getUri(), remoteFS.getWorkingDirectory());\n        localResources.put(\n            MRJobConfig.JOB_JAR,\n            createLocalResource(remoteFS, remoteJobJar,\n                LocalResourceType.FILE, LocalResourceVisibility.APPLICATION));\n        LOG.info(\"The job-jar file on the remote FS is \"\n            + remoteJobJar.toUri().toASCIIString());\n      } else {\n        // Job jar may be null. For e.g, for pipes, the job jar is the hadoop\n        // mapreduce jar itself which is already on the classpath.\n        LOG.info(\"Job jar is not present. \"\n            + \"Not adding any jar to the list of resources.\");\n      }\n      // //////////// End of JobJar setup\n\n      // //////////// Set up JobConf to be localized properly on the remote NM.\n      Path path =\n          MRApps.getStagingAreaDir(conf, UserGroupInformation\n              .getCurrentUser().getShortUserName());\n      Path remoteJobSubmitDir =\n          new Path(path, oldJobId.toString());\n      Path remoteJobConfPath = \n          new Path(remoteJobSubmitDir, MRJobConfig.JOB_CONF_FILE);\n      localResources.put(\n          MRJobConfig.JOB_CONF_FILE,\n          createLocalResource(remoteFS, remoteJobConfPath,\n              LocalResourceType.FILE, LocalResourceVisibility.APPLICATION));\n      LOG.info(\"The job-conf file on the remote FS is \"\n          + remoteJobConfPath.toUri().toASCIIString());\n      // //////////// End of JobConf setup\n\n      // Setup DistributedCache\n      MRApps.setupDistributedCache(conf, localResources);\n\n      // Setup up tokens\n      Credentials taskCredentials = new Credentials();\n\n      if (UserGroupInformation.isSecurityEnabled()) {\n        // Add file-system tokens\n        for (Token<? extends TokenIdentifier> token : fsTokens) {\n          LOG.info(\"Putting fs-token for NM use for launching container : \"\n              + token.toString());\n          taskCredentials.addToken(token.getService(), token);\n        }\n      }\n\n      // LocalStorageToken is needed irrespective of whether security is enabled\n      // or not.\n      TokenCache.setJobToken(jobToken, taskCredentials);\n\n      DataOutputBuffer containerTokens_dob = new DataOutputBuffer();\n      LOG.info(\"Size of containertokens_dob is \"\n          + taskCredentials.numberOfTokens());\n      taskCredentials.writeTokenStorageToStream(containerTokens_dob);\n      tokens = \n          ByteBuffer.wrap(containerTokens_dob.getData(), 0,\n              containerTokens_dob.getLength());\n\n      // Add shuffle token\n      LOG.info(\"Putting shuffle token in serviceData\");\n      serviceData.put(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID,\n          ShuffleHandler.serializeServiceData(jobToken));\n\n      Apps.addToEnvironment(\n          environment,  \n          Environment.CLASSPATH.name(), \n          getInitialClasspath());\n    } catch (IOException e) {\n      throw new YarnException(e);\n    }\n\n    // Shell\n    environment.put(\n        Environment.SHELL.name(), \n        conf.get(\n            MRJobConfig.MAPRED_ADMIN_USER_SHELL, \n            MRJobConfig.DEFAULT_SHELL)\n            );\n\n    // Add pwd to LD_LIBRARY_PATH, add this before adding anything else\n    Apps.addToEnvironment(\n        environment, \n        Environment.LD_LIBRARY_PATH.name(), \n        Environment.PWD.$());\n\n    // Add the env variables passed by the admin\n    Apps.setEnvFromInputString(\n        environment, \n        conf.get(\n            MRJobConfig.MAPRED_ADMIN_USER_ENV, \n            MRJobConfig.DEFAULT_MAPRED_ADMIN_USER_ENV)\n        );\n\n    // Construct the actual Container\n    // The null fields are per-container and will be constructed for each\n    // container separately.\n    ContainerLaunchContext container = BuilderUtils\n        .newContainerLaunchContext(null, conf\n            .get(MRJobConfig.USER_NAME), null, localResources,\n            environment, null, serviceData, tokens, applicationACLs);\n\n    return container;\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Lock this on initialClasspath so that there is only one fork in the AM for\n   * getting the initial class-path. TODO: This should go away once we construct\n   * a parent CLC and use it for all the containers.\n   */\n  private String getInitialClasspath() throws IOException {\n    synchronized (classpathLock) {\n      if (initialClasspathFlag.get()) {\n        return initialClasspath;\n      }\n      Map<String, String> env = new HashMap<String, String>();\n      MRApps.setClasspath(env);\n      initialClasspath = env.get(Environment.CLASSPATH.name());\n      initialClasspathFlag.set(true);\n      return initialClasspath;\n    }\n  }","id":31295,"modified_method":"/**\n   * Lock this on initialClasspath so that there is only one fork in the AM for\n   * getting the initial class-path. TODO: We already construct\n   * a parent CLC and use it for all the containers, so this should go away\n   * once the mr-generated-classpath stuff is gone.\n   */\n  private static String getInitialClasspath() throws IOException {\n    synchronized (classpathLock) {\n      if (initialClasspathFlag.get()) {\n        return initialClasspath;\n      }\n      Map<String, String> env = new HashMap<String, String>();\n      MRApps.setClasspath(env);\n      initialClasspath = env.get(Environment.CLASSPATH.name());\n      initialClasspathFlag.set(true);\n      return initialClasspath;\n    }\n  }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"deprecation\" })\n    @Override\n    public void transition(final TaskAttemptImpl taskAttempt, \n        TaskAttemptEvent event) {\n      final TaskAttemptContainerAssignedEvent cEvent = \n        (TaskAttemptContainerAssignedEvent) event;\n      taskAttempt.containerID = cEvent.getContainer().getId();\n      taskAttempt.containerNodeId = cEvent.getContainer().getNodeId();\n      taskAttempt.containerMgrAddress = taskAttempt.containerNodeId\n          .toString();\n      taskAttempt.nodeHttpAddress = cEvent.getContainer().getNodeHttpAddress();\n      taskAttempt.nodeRackName = RackResolver.resolve(\n          taskAttempt.containerNodeId.getHost()).getNetworkLocation();\n      taskAttempt.containerToken = cEvent.getContainer().getContainerToken();\n      taskAttempt.assignedCapability = cEvent.getContainer().getResource();\n      // this is a _real_ Task (classic Hadoop mapred flavor):\n      taskAttempt.remoteTask = taskAttempt.createRemoteTask();\n      taskAttempt.jvmID = new WrappedJvmID(\n          taskAttempt.remoteTask.getTaskID().getJobID(), \n          taskAttempt.remoteTask.isMapTask(), taskAttempt.containerID.getId());\n      taskAttempt.taskAttemptListener.registerPendingTask(taskAttempt.jvmID);\n      \n      //launch the container\n      //create the container object to be launched for a given Task attempt\n      taskAttempt.eventHandler.handle(\n          new ContainerRemoteLaunchEvent(taskAttempt.attemptId, \n              taskAttempt.containerID, \n              taskAttempt.containerMgrAddress, taskAttempt.containerToken) {\n        @Override\n        public ContainerLaunchContext getContainer() {\n          return taskAttempt.createContainerLaunchContext(cEvent\n              .getApplicationACLs());\n        }\n        @Override\n        public Task getRemoteTask() {  // classic mapred Task, not YARN version\n          return taskAttempt.remoteTask;\n        }\n      });\n\n      // send event to speculator that our container needs are satisfied\n      taskAttempt.eventHandler.handle\n          (new SpeculatorEvent(taskAttempt.getID().getTaskId(), -1));\n    }","id":31296,"modified_method":"@SuppressWarnings({ \"unchecked\" })\n    @Override\n    public void transition(final TaskAttemptImpl taskAttempt, \n        TaskAttemptEvent event) {\n      final TaskAttemptContainerAssignedEvent cEvent = \n        (TaskAttemptContainerAssignedEvent) event;\n      taskAttempt.containerID = cEvent.getContainer().getId();\n      taskAttempt.containerNodeId = cEvent.getContainer().getNodeId();\n      taskAttempt.containerMgrAddress = taskAttempt.containerNodeId\n          .toString();\n      taskAttempt.nodeHttpAddress = cEvent.getContainer().getNodeHttpAddress();\n      taskAttempt.nodeRackName = RackResolver.resolve(\n          taskAttempt.containerNodeId.getHost()).getNetworkLocation();\n      taskAttempt.containerToken = cEvent.getContainer().getContainerToken();\n      taskAttempt.assignedCapability = cEvent.getContainer().getResource();\n      // this is a _real_ Task (classic Hadoop mapred flavor):\n      taskAttempt.remoteTask = taskAttempt.createRemoteTask();\n      taskAttempt.jvmID = new WrappedJvmID(\n          taskAttempt.remoteTask.getTaskID().getJobID(), \n          taskAttempt.remoteTask.isMapTask(), taskAttempt.containerID.getId());\n      taskAttempt.taskAttemptListener.registerPendingTask(taskAttempt.jvmID);\n      \n      //launch the container\n      //create the container object to be launched for a given Task attempt\n      ContainerLaunchContext launchContext = createContainerLaunchContext(\n          cEvent.getApplicationACLs(), taskAttempt.containerID,\n          taskAttempt.conf, taskAttempt.jobToken, taskAttempt.remoteTask,\n          taskAttempt.oldJobId, taskAttempt.assignedCapability,\n          taskAttempt.jvmID, taskAttempt.taskAttemptListener,\n          taskAttempt.fsTokens);\n      taskAttempt.eventHandler.handle(new ContainerRemoteLaunchEvent(\n          taskAttempt.attemptId, taskAttempt.containerID,\n          taskAttempt.containerMgrAddress, taskAttempt.containerToken,\n          launchContext, taskAttempt.remoteTask));\n\n      // send event to speculator that our container needs are satisfied\n      taskAttempt.eventHandler.handle\n          (new SpeculatorEvent(taskAttempt.getID().getTaskId(), -1));\n    }","commit_id":"0870734787d7005d85697549eab5b6479d97d453","url":"https://github.com/apache/hadoop"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithWorker() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppWithWorker.class);\n    LOG.info(\"Deployed.\");\n    WorkerManager manager = applicationManager.startWorker(AppWithWorker.WORKER);\n    TimeUnit.MILLISECONDS.sleep(200);\n    manager.stop();\n    applicationManager.stopAll();\n    DataSetManager<KeyValueTable> dataSetManager = applicationManager.getDataSet(AppWithWorker.DATASET);\n    KeyValueTable table = dataSetManager.get();\n    Assert.assertEquals(AppWithWorker.INITIALIZE, Bytes.toString(table.read(AppWithWorker.INITIALIZE)));\n    Assert.assertEquals(AppWithWorker.RUN, Bytes.toString(table.read(AppWithWorker.RUN)));\n    Assert.assertEquals(AppWithWorker.STOP, Bytes.toString(table.read(AppWithWorker.STOP)));\n  }","id":31297,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithWorker() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithWorker.class);\n    LOG.info(\"Deployed.\");\n    WorkerManager manager = applicationManager.startWorker(AppWithWorker.WORKER);\n    TimeUnit.MILLISECONDS.sleep(200);\n    manager.stop();\n    applicationManager.stopAll();\n    DataSetManager<KeyValueTable> dataSetManager = getDataset(testSpace, AppWithWorker.DATASET);\n    KeyValueTable table = dataSetManager.get();\n    Assert.assertEquals(AppWithWorker.INITIALIZE, Bytes.toString(table.read(AppWithWorker.INITIALIZE)));\n    Assert.assertEquals(AppWithWorker.RUN, Bytes.toString(table.read(AppWithWorker.RUN)));\n    Assert.assertEquals(AppWithWorker.STOP, Bytes.toString(table.read(AppWithWorker.STOP)));\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test\n  public void testDeployWorkflowApp() throws InterruptedException {\n    ApplicationManager applicationManager = deployApplication(AppWithSchedule.class);\n    WorkflowManager wfmanager = applicationManager.startWorkflow(\"SampleWorkflow\", null);\n    List<ScheduleSpecification> schedules = wfmanager.getSchedules();\n    Assert.assertEquals(1, schedules.size());\n    String scheduleName = schedules.get(0).getSchedule().getName();\n    Assert.assertNotNull(scheduleName);\n    Assert.assertFalse(scheduleName.isEmpty());\n\n    List<RunRecord> history;\n    int workflowRuns;\n    workFlowHistoryCheck(5, wfmanager, 0);\n\n    String status = wfmanager.getSchedule(scheduleName).status(200);\n    Assert.assertEquals(\"SCHEDULED\", status);\n\n    wfmanager.getSchedule(scheduleName).suspend();\n    workFlowStatusCheck(5, scheduleName, wfmanager, \"SUSPENDED\");\n\n    TimeUnit.SECONDS.sleep(3);\n    history = wfmanager.getHistory();\n    workflowRuns = history.size();\n\n    //Sleep for some time and verify there are no more scheduled jobs after the suspend.\n    TimeUnit.SECONDS.sleep(10);\n    int workflowRunsAfterSuspend = wfmanager.getHistory().size();\n    Assert.assertEquals(workflowRuns, workflowRunsAfterSuspend);\n\n    wfmanager.getSchedule(scheduleName).resume();\n\n    //Check that after resume it goes to \"SCHEDULED\" state\n    workFlowStatusCheck(5, scheduleName, wfmanager, \"SCHEDULED\");\n\n    workFlowHistoryCheck(5, wfmanager, workflowRunsAfterSuspend);\n\n    //check scheduled state\n    Assert.assertEquals(\"SCHEDULED\", wfmanager.getSchedule(scheduleName).status(200));\n\n    //check status of non-existent schedule\n    Assert.assertEquals(\"NOT_FOUND\", wfmanager.getSchedule(\"doesnt exist\").status(404));\n\n    //suspend the schedule\n    wfmanager.getSchedule(scheduleName).suspend();\n\n    //Check that after suspend it goes to \"SUSPENDED\" state\n    workFlowStatusCheck(5, scheduleName, wfmanager, \"SUSPENDED\");\n  }","id":31298,"modified_method":"@Category(XSlowTests.class)\n  @Test\n  public void testDeployWorkflowApp() throws InterruptedException {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithSchedule.class);\n    WorkflowManager wfmanager = applicationManager.startWorkflow(\"SampleWorkflow\", null);\n    List<ScheduleSpecification> schedules = wfmanager.getSchedules();\n    Assert.assertEquals(1, schedules.size());\n    String scheduleName = schedules.get(0).getSchedule().getName();\n    Assert.assertNotNull(scheduleName);\n    Assert.assertFalse(scheduleName.isEmpty());\n\n    List<RunRecord> history;\n    int workflowRuns;\n    workFlowHistoryCheck(5, wfmanager, 0);\n\n    String status = wfmanager.getSchedule(scheduleName).status(200);\n    Assert.assertEquals(\"SCHEDULED\", status);\n\n    wfmanager.getSchedule(scheduleName).suspend();\n    workFlowStatusCheck(5, scheduleName, wfmanager, \"SUSPENDED\");\n\n    TimeUnit.SECONDS.sleep(3);\n    history = wfmanager.getHistory();\n    workflowRuns = history.size();\n\n    //Sleep for some time and verify there are no more scheduled jobs after the suspend.\n    TimeUnit.SECONDS.sleep(10);\n    int workflowRunsAfterSuspend = wfmanager.getHistory().size();\n    Assert.assertEquals(workflowRuns, workflowRunsAfterSuspend);\n\n    wfmanager.getSchedule(scheduleName).resume();\n\n    //Check that after resume it goes to \"SCHEDULED\" state\n    workFlowStatusCheck(5, scheduleName, wfmanager, \"SCHEDULED\");\n\n    workFlowHistoryCheck(5, wfmanager, workflowRunsAfterSuspend);\n\n    //check scheduled state\n    Assert.assertEquals(\"SCHEDULED\", wfmanager.getSchedule(scheduleName).status(200));\n\n    //check status of non-existent schedule\n    Assert.assertEquals(\"NOT_FOUND\", wfmanager.getSchedule(\"doesnt exist\").status(404));\n\n    //suspend the schedule\n    wfmanager.getSchedule(scheduleName).suspend();\n\n    //Check that after suspend it goes to \"SUSPENDED\" state\n    workFlowStatusCheck(5, scheduleName, wfmanager, \"SUSPENDED\");\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testGetServiceURL() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppUsingGetServiceURL.class);\n    ServiceManager centralServiceManager = applicationManager.startService(AppUsingGetServiceURL.CENTRAL_SERVICE);\n    centralServiceManager.waitForStatus(true);\n\n    // Test procedure's getServiceURL\n    ProcedureManager procedureManager = applicationManager.startProcedure(AppUsingGetServiceURL.PROCEDURE);\n    ProcedureClient procedureClient = procedureManager.getClient();\n    String result = procedureClient.query(\"ping\", Collections.<String, String>emptyMap());\n    String decodedResult = new Gson().fromJson(result, String.class);\n    // Verify that the procedure was able to hit the CentralService and retrieve the answer.\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n\n    // Test serviceWorker's getServiceURL\n    ServiceManager serviceWithWorker = applicationManager.startService(AppUsingGetServiceURL.SERVICE_WITH_WORKER);\n    serviceWithWorker.waitForStatus(true);\n    // Since the worker is passive (we can not ping it), allow the service worker 2 seconds to ping\n    // the CentralService, get the appropriate response, and write to to a dataset.\n    Thread.sleep(2000);\n    serviceWithWorker.stop();\n    serviceWithWorker.waitForStatus(false);\n\n    result = procedureClient.query(\"readDataSet\", ImmutableMap.of(AppUsingGetServiceURL.DATASET_WHICH_KEY,\n                                                                  AppUsingGetServiceURL.DATASET_KEY));\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n    procedureManager.stop();\n\n    centralServiceManager.stop();\n    centralServiceManager.waitForStatus(false);\n  }","id":31299,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testGetServiceURL() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);\n    ServiceManager centralServiceManager = applicationManager.startService(AppUsingGetServiceURL.CENTRAL_SERVICE);\n    centralServiceManager.waitForStatus(true);\n\n    // Test procedure's getServiceURL\n    ProcedureManager procedureManager = applicationManager.startProcedure(AppUsingGetServiceURL.PROCEDURE);\n    ProcedureClient procedureClient = procedureManager.getClient();\n    String result = procedureClient.query(\"ping\", Collections.<String, String>emptyMap());\n    String decodedResult = new Gson().fromJson(result, String.class);\n    // Verify that the procedure was able to hit the CentralService and retrieve the answer.\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n\n    // Test serviceWorker's getServiceURL\n    ServiceManager serviceWithWorker = applicationManager.startService(AppUsingGetServiceURL.SERVICE_WITH_WORKER);\n    serviceWithWorker.waitForStatus(true);\n    // Since the worker is passive (we can not ping it), allow the service worker 2 seconds to ping\n    // the CentralService, get the appropriate response, and write to to a dataset.\n    Thread.sleep(2000);\n    serviceWithWorker.stop();\n    serviceWithWorker.waitForStatus(false);\n\n    result = procedureClient.query(\"readDataSet\", ImmutableMap.of(AppUsingGetServiceURL.DATASET_WHICH_KEY,\n                                                                  AppUsingGetServiceURL.DATASET_KEY));\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n    procedureManager.stop();\n\n    centralServiceManager.stop();\n    centralServiceManager.waitForStatus(false);\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test\n  public void testDatasetUncheckedUpgrade() throws Exception {\n    ApplicationManager applicationManager = deployApplication(DatasetUncheckedUpgradeApp.class);\n    DataSetManager<DatasetUncheckedUpgradeApp.RecordDataset> datasetManager =\n      applicationManager.getDataSet(DatasetUncheckedUpgradeApp.DATASET_NAME);\n    DatasetUncheckedUpgradeApp.Record expectedRecord = new DatasetUncheckedUpgradeApp.Record(\"0AXB\", \"john\", \"doe\");\n    datasetManager.get().writeRecord(\"key\", expectedRecord);\n    datasetManager.flush();\n\n    DatasetUncheckedUpgradeApp.Record actualRecord =\n      (DatasetUncheckedUpgradeApp.Record) datasetManager.get().getRecord(\"key\");\n    Assert.assertEquals(expectedRecord, actualRecord);\n\n    // Test compatible upgrade\n    applicationManager = deployApplication(CompatibleDatasetUncheckedUpgradeApp.class);\n    datasetManager = applicationManager.getDataSet(DatasetUncheckedUpgradeApp.DATASET_NAME);\n    CompatibleDatasetUncheckedUpgradeApp.Record compatibleRecord =\n      (CompatibleDatasetUncheckedUpgradeApp.Record) datasetManager.get().getRecord(\"key\");\n    Assert.assertEquals(new CompatibleDatasetUncheckedUpgradeApp.Record(\"0AXB\", \"john\", false), compatibleRecord);\n\n    // Test in-compatible upgrade\n    applicationManager = deployApplication(IncompatibleDatasetUncheckedUpgradeApp.class);\n    datasetManager = applicationManager.getDataSet(DatasetUncheckedUpgradeApp.DATASET_NAME);\n    try {\n      datasetManager.get().getRecord(\"key\");\n      Assert.fail(\"Expected to throw exception here due to an incompatible Dataset upgrade.\");\n    } catch (Exception e) {\n      // Expected exception due to incompatible Dataset upgrade\n    }\n\n    // Revert the upgrade\n    applicationManager = deployApplication(CompatibleDatasetUncheckedUpgradeApp.class);\n    datasetManager = applicationManager.getDataSet(DatasetUncheckedUpgradeApp.DATASET_NAME);\n    CompatibleDatasetUncheckedUpgradeApp.Record revertRecord =\n      (CompatibleDatasetUncheckedUpgradeApp.Record) datasetManager.get().getRecord(\"key\");\n    Assert.assertEquals(new CompatibleDatasetUncheckedUpgradeApp.Record(\"0AXB\", \"john\", false), revertRecord);\n  }","id":31300,"modified_method":"@Category(XSlowTests.class)\n  @Test\n  public void testDatasetUncheckedUpgrade() throws Exception {\n    deployApplication(testSpace, DatasetUncheckedUpgradeApp.class);\n    DataSetManager<DatasetUncheckedUpgradeApp.RecordDataset> datasetManager =\n      getDataset(testSpace, DatasetUncheckedUpgradeApp.DATASET_NAME);\n    DatasetUncheckedUpgradeApp.Record expectedRecord = new DatasetUncheckedUpgradeApp.Record(\"0AXB\", \"john\", \"doe\");\n    datasetManager.get().writeRecord(\"key\", expectedRecord);\n    datasetManager.flush();\n\n    DatasetUncheckedUpgradeApp.Record actualRecord =\n      (DatasetUncheckedUpgradeApp.Record) datasetManager.get().getRecord(\"key\");\n    Assert.assertEquals(expectedRecord, actualRecord);\n\n    // Test compatible upgrade\n    deployApplication(testSpace, CompatibleDatasetUncheckedUpgradeApp.class);\n    datasetManager = getDataset(testSpace, DatasetUncheckedUpgradeApp.DATASET_NAME);\n    CompatibleDatasetUncheckedUpgradeApp.Record compatibleRecord =\n      (CompatibleDatasetUncheckedUpgradeApp.Record) datasetManager.get().getRecord(\"key\");\n    Assert.assertEquals(new CompatibleDatasetUncheckedUpgradeApp.Record(\"0AXB\", \"john\", false), compatibleRecord);\n\n    // Test in-compatible upgrade\n    deployApplication(testSpace, IncompatibleDatasetUncheckedUpgradeApp.class);\n    datasetManager = getDataset(testSpace, DatasetUncheckedUpgradeApp.DATASET_NAME);\n    try {\n      datasetManager.get().getRecord(\"key\");\n      Assert.fail(\"Expected to throw exception here due to an incompatible Dataset upgrade.\");\n    } catch (Exception e) {\n      // Expected exception due to incompatible Dataset upgrade\n    }\n\n    // Revert the upgrade\n    deployApplication(testSpace, CompatibleDatasetUncheckedUpgradeApp.class);\n    datasetManager = getDataset(testSpace, DatasetUncheckedUpgradeApp.DATASET_NAME);\n    CompatibleDatasetUncheckedUpgradeApp.Record revertRecord =\n      (CompatibleDatasetUncheckedUpgradeApp.Record) datasetManager.get().getRecord(\"key\");\n    Assert.assertEquals(new CompatibleDatasetUncheckedUpgradeApp.Record(\"0AXB\", \"john\", false), revertRecord);\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testApp(Class<? extends Application> app, String streamName) throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(app);\n    applicationManager.startFlow(\"WordCountFlow\");\n\n    // Send some inputs to streams\n    StreamWriter streamWriter = applicationManager.getStreamWriter(streamName);\n    for (int i = 0; i < 100; i++) {\n      streamWriter.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                   \"WordCountFlow\",\n                                                                   \"CountByField\");\n    flowletMetrics.waitForProcessed(500, 10, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n\n    // Query the result\n    ProcedureManager procedureManager = applicationManager.startProcedure(\"WordFrequency\");\n    ProcedureClient procedureClient = procedureManager.getClient();\n\n    // Verify the query result\n    Type resultType = new TypeToken<Map<String, Long>>() { }.getType();\n    Gson gson = new Gson();\n    Map<String, Long> result = gson.fromJson(procedureClient.query(\"wordfreq\",\n                                                                   ImmutableMap.of(\"word\", streamName + \":testing\")),\n                                             resultType);\n\n    Assert.assertEquals(100L, result.get(streamName + \":testing\").longValue());\n\n    // check the metrics\n    RuntimeMetrics procedureMetrics = RuntimeStats.getProcedureMetrics(\"WordCountApp\", \"WordFrequency\");\n    procedureMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, procedureMetrics.getException());\n\n    // Run mapreduce job\n    MapReduceManager mrManager = applicationManager.startMapReduce(\"countTotal\");\n    mrManager.waitForFinish(1800L, TimeUnit.SECONDS);\n\n    long totalCount = Long.valueOf(procedureClient.query(\"total\", Collections.<String, String>emptyMap()));\n    // every event has 5 tokens\n    Assert.assertEquals(5 * 100L, totalCount);\n\n    // Run mapreduce from stream\n    mrManager = applicationManager.startMapReduce(\"countFromStream\");\n    mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n    totalCount = Long.valueOf(procedureClient.query(\"stream_total\", Collections.<String, String>emptyMap()));\n\n    // The stream MR only consume the body, not the header.\n    Assert.assertEquals(3 * 100L, totalCount);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> mydatasetManager =\n      applicationManager.getDataSet(\"mydataset\");\n    Assert.assertEquals(100L, Long.valueOf(mydatasetManager.get().get(\"title:title\")).longValue());\n  }","id":31301,"modified_method":"private void testApp(Class<? extends Application> app, String streamName) throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(testSpace, app);\n    applicationManager.startFlow(\"WordCountFlow\");\n\n    // Send some inputs to streams\n    StreamWriter streamWriter = applicationManager.getStreamWriter(streamName);\n    for (int i = 0; i < 100; i++) {\n      streamWriter.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                   \"WordCountFlow\",\n                                                                   \"CountByField\");\n    flowletMetrics.waitForProcessed(500, 10, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n\n    // Query the result\n    ProcedureManager procedureManager = applicationManager.startProcedure(\"WordFrequency\");\n    ProcedureClient procedureClient = procedureManager.getClient();\n\n    // Verify the query result\n    Type resultType = new TypeToken<Map<String, Long>>() { }.getType();\n    Gson gson = new Gson();\n    Map<String, Long> result = gson.fromJson(procedureClient.query(\"wordfreq\",\n                                                                   ImmutableMap.of(\"word\", streamName + \":testing\")),\n                                             resultType);\n\n    Assert.assertEquals(100L, result.get(streamName + \":testing\").longValue());\n\n    // check the metrics\n    RuntimeMetrics procedureMetrics = RuntimeStats.getProcedureMetrics(\"WordCountApp\", \"WordFrequency\");\n    procedureMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, procedureMetrics.getException());\n\n    // Run mapreduce job\n    MapReduceManager mrManager = applicationManager.startMapReduce(\"countTotal\");\n    mrManager.waitForFinish(1800L, TimeUnit.SECONDS);\n\n    long totalCount = Long.valueOf(procedureClient.query(\"total\", Collections.<String, String>emptyMap()));\n    // every event has 5 tokens\n    Assert.assertEquals(5 * 100L, totalCount);\n\n    // Run mapreduce from stream\n    mrManager = applicationManager.startMapReduce(\"countFromStream\");\n    mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n    totalCount = Long.valueOf(procedureClient.query(\"stream_total\", Collections.<String, String>emptyMap()));\n\n    // The stream MR only consume the body, not the header.\n    Assert.assertEquals(3 * 100L, totalCount);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> mydatasetManager = getDataset(testSpace, \"mydataset\");\n    Assert.assertEquals(100L, Long.valueOf(mydatasetManager.get().get(\"title:title\")).longValue());\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test\n  public void testByteCodeClassLoader() throws Exception {\n    // This test verify bytecode generated classes ClassLoading\n\n    ApplicationManager appManager = deployApplication(ClassLoaderTestApp.class);\n    FlowManager flowManager = appManager.startFlow(\"BasicFlow\");\n\n    // Wait for at least 10 records being generated\n    RuntimeMetrics flowMetrics = RuntimeStats.getFlowletMetrics(\"ClassLoaderTestApp\", \"BasicFlow\", \"Sink\");\n    flowMetrics.waitForProcessed(10, 5000, TimeUnit.MILLISECONDS);\n    flowManager.stop();\n\n    ServiceManager serviceManager = appManager.startService(\"RecordQuery\");\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Query record\n    URL url = new URL(serviceURL, \"query?type=public\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    long count = Long.parseLong(response.getResponseBodyAsString());\n    serviceManager.stop();\n\n    // Verify the record count with dataset\n    KeyValueTable records = appManager.<KeyValueTable>getDataSet(\"records\").get();\n    Assert.assertTrue(count == Bytes.toLong(records.read(\"PUBLIC\")));\n  }","id":31302,"modified_method":"@Category(XSlowTests.class)\n  @Test\n  public void testByteCodeClassLoader() throws Exception {\n    // This test verify bytecode generated classes ClassLoading\n\n    ApplicationManager appManager = deployApplication(testSpace, ClassLoaderTestApp.class);\n    FlowManager flowManager = appManager.startFlow(\"BasicFlow\");\n\n    // Wait for at least 10 records being generated\n    RuntimeMetrics flowMetrics = RuntimeStats.getFlowletMetrics(\"ClassLoaderTestApp\", \"BasicFlow\", \"Sink\");\n    flowMetrics.waitForProcessed(10, 5000, TimeUnit.MILLISECONDS);\n    flowManager.stop();\n\n    ServiceManager serviceManager = appManager.startService(\"RecordQuery\");\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Query record\n    URL url = new URL(serviceURL, \"query?type=public\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    long count = Long.parseLong(response.getResponseBodyAsString());\n    serviceManager.stop();\n\n    // Verify the record count with dataset\n    DataSetManager<KeyValueTable> recordsManager = getDataset(testSpace, \"records\");\n    KeyValueTable records = recordsManager.get();\n    Assert.assertTrue(count == Bytes.toLong(records.read(\"PUBLIC\")));\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testFlowletInitAndSetInstances() throws Exception {\n    ApplicationManager appManager = deployApplication(DataSetInitApp.class);\n    FlowManager flowManager = appManager.startFlow(\"DataSetFlow\");\n\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"DataSetInitApp\", \"DataSetFlow\", \"Consumer\");\n\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n\n    // Now change generator to 3 instances\n    flowManager.setFlowletInstances(\"Generator\", 3);\n\n    // Now should have 3 processed from the consumer flowlet\n    flowletMetrics.waitForProcessed(3, 10, TimeUnit.SECONDS);\n\n    // Now reset to 1 instances\n    flowManager.setFlowletInstances(\"Generator\", 1);\n\n    // Shouldn't have new item\n    TimeUnit.SECONDS.sleep(3);\n    Assert.assertEquals(3, flowletMetrics.getProcessed());\n\n    // Now set to 2 instances again. Since there is a new instance, expect one new item emitted\n    flowManager.setFlowletInstances(\"Generator\", 2);\n    flowletMetrics.waitForProcessed(4, 10, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    DataSetManager<Table> dataSetManager = appManager.getDataSet(\"conf\");\n    Table confTable = dataSetManager.get();\n\n    Assert.assertEquals(\"generator\", confTable.get(new Get(\"key\", \"column\")).getString(\"column\"));\n\n    dataSetManager.flush();\n  }","id":31303,"modified_method":"@Test(timeout = 60000L)\n  public void testFlowletInitAndSetInstances() throws Exception {\n    ApplicationManager appManager = deployApplication(testSpace, DataSetInitApp.class);\n    FlowManager flowManager = appManager.startFlow(\"DataSetFlow\");\n\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"DataSetInitApp\",\n                                                                   \"DataSetFlow\", \"Consumer\");\n\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n\n    // Now change generator to 3 instances\n    flowManager.setFlowletInstances(\"Generator\", 3);\n\n    // Now should have 3 processed from the consumer flowlet\n    flowletMetrics.waitForProcessed(3, 10, TimeUnit.SECONDS);\n\n    // Now reset to 1 instances\n    flowManager.setFlowletInstances(\"Generator\", 1);\n\n    // Shouldn't have new item\n    TimeUnit.SECONDS.sleep(3);\n    Assert.assertEquals(3, flowletMetrics.getProcessed());\n\n    // Now set to 2 instances again. Since there is a new instance, expect one new item emitted\n    flowManager.setFlowletInstances(\"Generator\", 2);\n    flowletMetrics.waitForProcessed(4, 10, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    DataSetManager<Table> dataSetManager = getDataset(testSpace, \"conf\");\n    Table confTable = dataSetManager.get();\n\n    Assert.assertEquals(\"generator\", confTable.get(new Get(\"key\", \"column\")).getString(\"column\"));\n\n    dataSetManager.flush();\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testAppRedeployKeepsData() throws Exception {\n    ApplicationManager appManager = deployApplication(AppWithTable.class);\n    DataSetManager<Table> myTableManager = appManager.getDataSet(\"my_table\");\n    myTableManager.get().put(new Put(\"key1\", \"column1\", \"value1\"));\n    myTableManager.flush();\n\n    // Changes should be visible to other instances of datasets\n    DataSetManager<Table> myTableManager2 = appManager.getDataSet(\"my_table\");\n    Assert.assertEquals(\"value1\", myTableManager2.get().get(new Get(\"key1\", \"column1\")).getString(\"column1\"));\n\n    // Even after redeploy of an app: changes should be visible to other instances of datasets\n    appManager = deployApplication(AppWithTable.class);\n    DataSetManager<Table> myTableManager3 = appManager.getDataSet(\"my_table\");\n    Assert.assertEquals(\"value1\", myTableManager3.get().get(new Get(\"key1\", \"column1\")).getString(\"column1\"));\n\n    // Calling commit again (to test we can call it multiple times)\n    myTableManager.get().put(new Put(\"key1\", \"column1\", \"value2\"));\n    myTableManager.flush();\n\n    Assert.assertEquals(\"value1\", myTableManager3.get().get(new Get(\"key1\", \"column1\")).getString(\"column1\"));\n  }","id":31304,"modified_method":"@Test\n  public void testAppRedeployKeepsData() throws Exception {\n    ApplicationManager appManager = deployApplication(testSpace, AppWithTable.class);\n    DataSetManager<Table> myTableManager = getDataset(testSpace, \"my_table\");\n    myTableManager.get().put(new Put(\"key1\", \"column1\", \"value1\"));\n    myTableManager.flush();\n\n    // Changes should be visible to other instances of datasets\n    DataSetManager<Table> myTableManager2 = getDataset(testSpace, \"my_table\");\n    Assert.assertEquals(\"value1\", myTableManager2.get().get(new Get(\"key1\", \"column1\")).getString(\"column1\"));\n\n    // Even after redeploy of an app: changes should be visible to other instances of datasets\n    appManager = deployApplication(AppWithTable.class);\n    DataSetManager<Table> myTableManager3 = getDataset(testSpace, \"my_table\");\n    Assert.assertEquals(\"value1\", myTableManager3.get().get(new Get(\"key1\", \"column1\")).getString(\"column1\"));\n\n    // Calling commit again (to test we can call it multiple times)\n    myTableManager.get().put(new Put(\"key1\", \"column1\", \"value2\"));\n    myTableManager.flush();\n\n    Assert.assertEquals(\"value1\", myTableManager3.get().get(new Get(\"key1\", \"column1\")).getString(\"column1\"));\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFlowRuntimeArguments() throws Exception {\n    ApplicationManager applicationManager = deployApplication(FilterApp.class);\n    Map<String, String> args = Maps.newHashMap();\n    args.put(\"threshold\", \"10\");\n    applicationManager.startFlow(\"FilterFlow\", args);\n\n    StreamWriter input = applicationManager.getStreamWriter(\"input\");\n    input.send(\"1\");\n    input.send(\"11\");\n\n    ProcedureManager queryManager = applicationManager.startProcedure(\"Count\");\n    ProcedureClient client = queryManager.getClient();\n    Gson gson = new Gson();\n\n    //Adding sleep so that the test does not fail if the procedure takes sometime to start on slow machines.\n    //TODO : Can be removed after fixing JIRA - CDAP-15\n    TimeUnit.SECONDS.sleep(2);\n\n    Assert.assertEquals(\"1\",\n                        gson.fromJson(client.query(\"result\", ImmutableMap.of(\"type\", \"highpass\")), String.class));\n  }","id":31305,"modified_method":"@Test\n  public void testFlowRuntimeArguments() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, FilterApp.class);\n    Map<String, String> args = Maps.newHashMap();\n    args.put(\"threshold\", \"10\");\n    applicationManager.startFlow(\"FilterFlow\", args);\n\n    StreamWriter input = applicationManager.getStreamWriter(\"input\");\n    input.send(\"1\");\n    input.send(\"11\");\n\n    ProcedureManager queryManager = applicationManager.startProcedure(\"Count\");\n    ProcedureClient client = queryManager.getClient();\n    Gson gson = new Gson();\n\n    //Adding sleep so that the test does not fail if the procedure takes sometime to start on slow machines.\n    //TODO : Can be removed after fixing JIRA - CDAP-15\n    TimeUnit.SECONDS.sleep(2);\n\n    Assert.assertEquals(\"1\",\n                        gson.fromJson(client.query(\"result\", ImmutableMap.of(\"type\", \"highpass\")), String.class));\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTransactionHandlerService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.startService(AppWithServices.TRANSACTIONS_SERVICE_NAME);\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n\n    final URL baseUrl = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(baseUrl);\n\n    // Make a request to write in a separate thread and wait for it to return.\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    Future<Integer> requestFuture = executorService.submit(new Callable<Integer>() {\n      @Override\n      public Integer call() throws Exception {\n        try {\n          URL url = new URL(String.format(\"%s/write/%s/%s/%d\",\n                                          baseUrl,\n                                          AppWithServices.DATASET_TEST_KEY,\n                                          AppWithServices.DATASET_TEST_VALUE,\n                                          10000));\n          HttpRequest request = HttpRequest.get(url).build();\n          HttpResponse response = HttpRequests.execute(request);\n          return response.getResponseCode();\n        } catch (Exception e) {\n          LOG.error(\"Request thread got exception.\", e);\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    // The dataset should not be written by the time this request is made, since the transaction to write\n    // has not been committed yet.\n    URL url = new URL(String.format(\"%s/read/%s\", baseUrl, AppWithServices.DATASET_TEST_KEY));\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(204, response.getResponseCode());\n\n    // Wait for the transaction to commit.\n    Integer writeStatusCode = requestFuture.get();\n    Assert.assertEquals(200, writeStatusCode.intValue());\n\n    // Make the same request again. By now the transaction should've completed.\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE,\n                        new Gson().fromJson(response.getResponseBodyAsString(), String.class));\n\n    executorService.shutdown();\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    DataSetManager<KeyValueTable> dsManager\n      = applicationManager.getDataSet(AppWithServices.TRANSACTIONS_DATASET_NAME);\n    String value = Bytes.toString(dsManager.get().read(AppWithServices.DESTROY_KEY));\n    Assert.assertEquals(AppWithServices.VALUE, value);\n  }","id":31306,"modified_method":"@Test\n  public void testTransactionHandlerService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.startService(AppWithServices.TRANSACTIONS_SERVICE_NAME);\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n\n    final URL baseUrl = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(baseUrl);\n\n    // Make a request to write in a separate thread and wait for it to return.\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    Future<Integer> requestFuture = executorService.submit(new Callable<Integer>() {\n      @Override\n      public Integer call() throws Exception {\n        try {\n          URL url = new URL(String.format(\"%s/write/%s/%s/%d\",\n                                          baseUrl,\n                                          AppWithServices.DATASET_TEST_KEY,\n                                          AppWithServices.DATASET_TEST_VALUE,\n                                          10000));\n          HttpRequest request = HttpRequest.get(url).build();\n          HttpResponse response = HttpRequests.execute(request);\n          return response.getResponseCode();\n        } catch (Exception e) {\n          LOG.error(\"Request thread got exception.\", e);\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    // The dataset should not be written by the time this request is made, since the transaction to write\n    // has not been committed yet.\n    URL url = new URL(String.format(\"%s/read/%s\", baseUrl, AppWithServices.DATASET_TEST_KEY));\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(204, response.getResponseCode());\n\n    // Wait for the transaction to commit.\n    Integer writeStatusCode = requestFuture.get();\n    Assert.assertEquals(200, writeStatusCode.intValue());\n\n    // Make the same request again. By now the transaction should've completed.\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE,\n                        new Gson().fromJson(response.getResponseBodyAsString(), String.class));\n\n    executorService.shutdown();\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    DataSetManager<KeyValueTable> dsManager = getDataset(testSpace, AppWithServices.TRANSACTIONS_DATASET_NAME);\n    String value = Bytes.toString(dsManager.get().read(AppWithServices.DESTROY_KEY));\n    Assert.assertEquals(AppWithServices.VALUE, value);\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 90000L)\n  public void testSQLQuery() throws Exception {\n    // Deploying app makes sure that the default namespace is available.\n    deployApplication(DummyApp.class);\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    ApplicationManager appManager = deployApplication(AppsWithDataset.AppWithAutoCreate.class);\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> myTableManager =\n      appManager.getDataSet(\"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = myTableManager.get();\n    kvTable.put(\"a\", \"1\");\n    kvTable.put(\"b\", \"2\");\n    kvTable.put(\"c\", \"1\");\n    myTableManager.flush();\n\n    Connection connection = getQueryClient();\n    try {\n\n      // run a query over the dataset\n      ResultSet results = connection.prepareStatement(\"select first from mytable where second = '1'\")\n        .executeQuery();\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"a\", results.getString(1));\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"c\", results.getString(1));\n      Assert.assertFalse(results.next());\n\n    } finally {\n      connection.close();\n    }\n  }","id":31307,"modified_method":"@Test(timeout = 90000L)\n  public void testSQLQuery() throws Exception {\n    // Deploying app makes sure that the default namespace is available.\n    deployApplication(testSpace, DummyApp.class);\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    deployApplication(testSpace, AppsWithDataset.AppWithAutoCreate.class);\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> myTableManager =\n      getDataset(testSpace, \"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = myTableManager.get();\n    kvTable.put(\"a\", \"1\");\n    kvTable.put(\"b\", \"2\");\n    kvTable.put(\"c\", \"1\");\n    myTableManager.flush();\n\n    Connection connection = getQueryClient(testSpace);\n    try {\n\n      // run a query over the dataset\n      ResultSet results = connection.prepareStatement(\"select first from mytable where second = '1'\")\n        .executeQuery();\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"a\", results.getString(1));\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"c\", results.getString(1));\n      Assert.assertFalse(results.next());\n\n    } finally {\n      connection.close();\n    }\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testAppWithDataset(Class<? extends Application> app, String procedureName) throws Exception {\n    ApplicationManager applicationManager = deployApplication(app);\n    // Query the result\n    ProcedureManager procedureManager = applicationManager.startProcedure(procedureName);\n    ProcedureClient procedureClient = procedureManager.getClient();\n\n    procedureClient.query(\"set\", ImmutableMap.of(\"key\", \"key1\", \"value\", \"value1\"));\n\n    String response = procedureClient.query(\"get\", ImmutableMap.of(\"key\", \"key1\"));\n    Assert.assertEquals(\"value1\", new Gson().fromJson(response, String.class));\n  }","id":31308,"modified_method":"private void testAppWithDataset(Class<? extends Application> app, String procedureName) throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, app);\n    // Query the result\n    ProcedureManager procedureManager = applicationManager.startProcedure(procedureName);\n    ProcedureClient procedureClient = procedureManager.getClient();\n\n    procedureClient.query(\"set\", ImmutableMap.of(\"key\", \"key1\", \"value\", \"value1\"));\n\n    String response = procedureClient.query(\"get\", ImmutableMap.of(\"key\", \"key1\"));\n    Assert.assertEquals(\"value1\", new Gson().fromJson(response, String.class));\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testGenerator() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(GenSinkApp2.class);\n    applicationManager.startFlow(\"GenSinkFlow\");\n\n    // Check the flowlet metrics\n    RuntimeMetrics genMetrics = RuntimeStats.getFlowletMetrics(\"GenSinkApp\",\n                                                               \"GenSinkFlow\",\n                                                               \"GenFlowlet\");\n\n    RuntimeMetrics sinkMetrics = RuntimeStats.getFlowletMetrics(\"GenSinkApp\",\n                                                                \"GenSinkFlow\",\n                                                                \"SinkFlowlet\");\n\n    RuntimeMetrics batchSinkMetrics = RuntimeStats.getFlowletMetrics(\"GenSinkApp\",\n                                                                     \"GenSinkFlow\",\n                                                                     \"BatchSinkFlowlet\");\n\n    // Generator generators 99 events + 99 batched events\n    sinkMetrics.waitFor(\"system.process.events.in\", 198, 5, TimeUnit.SECONDS);\n    sinkMetrics.waitForProcessed(198, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, sinkMetrics.getException());\n\n    // Batch sink only get the 99 batch events\n    batchSinkMetrics.waitFor(\"system.process.events.in\", 99, 5, TimeUnit.SECONDS);\n    batchSinkMetrics.waitForProcessed(99, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, batchSinkMetrics.getException());\n\n    Assert.assertEquals(1L, genMetrics.getException());\n  }","id":31309,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testGenerator() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(testSpace, GenSinkApp2.class);\n    applicationManager.startFlow(\"GenSinkFlow\");\n\n    // Check the flowlet metrics\n    RuntimeMetrics genMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                               \"GenSinkApp\",\n                                                               \"GenSinkFlow\",\n                                                               \"GenFlowlet\");\n\n    RuntimeMetrics sinkMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                                \"GenSinkApp\",\n                                                                \"GenSinkFlow\",\n                                                                \"SinkFlowlet\");\n\n    RuntimeMetrics batchSinkMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                                     \"GenSinkApp\",\n                                                                     \"GenSinkFlow\",\n                                                                     \"BatchSinkFlowlet\");\n\n    // Generator generators 99 events + 99 batched events\n    sinkMetrics.waitFor(\"system.process.events.in\", 198, 5, TimeUnit.SECONDS);\n    sinkMetrics.waitForProcessed(198, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, sinkMetrics.getException());\n\n    // Batch sink only get the 99 batch events\n    batchSinkMetrics.waitFor(\"system.process.events.in\", 99, 5, TimeUnit.SECONDS);\n    batchSinkMetrics.waitForProcessed(99, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, batchSinkMetrics.getException());\n\n    Assert.assertEquals(1L, genMetrics.getException());\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"private void assertWorkerDatasetWrites(ApplicationManager applicationManager, byte[] startRow, byte[] endRow,\n                                         int expectedCount, int expectedTotalCount) throws Exception {\n    DataSetManager<KeyValueTable> datasetManager = applicationManager\n      .getDataSet(AppUsingGetServiceURL.WORKER_INSTANCES_DATASET);\n    KeyValueTable instancesTable = datasetManager.get();\n    CloseableIterator<KeyValue<byte[], byte[]>> instancesIterator = instancesTable.scan(startRow, endRow);\n    try {\n      List<KeyValue<byte[], byte[]>> workerInstances = Lists.newArrayList(instancesIterator);\n      // Assert that the worker starts with expectedCount instances\n      Assert.assertEquals(expectedCount, workerInstances.size());\n      // Assert that each instance of the worker knows the total number of instances\n      for (KeyValue<byte[], byte[]> keyValue : workerInstances) {\n        Assert.assertEquals(expectedTotalCount, Bytes.toInt(keyValue.getValue()));\n      }\n    } finally {\n      instancesIterator.close();\n    }\n  }","id":31310,"modified_method":"private void assertWorkerDatasetWrites(ApplicationManager applicationManager, byte[] startRow, byte[] endRow,\n                                         int expectedCount, int expectedTotalCount) throws Exception {\n    DataSetManager<KeyValueTable> datasetManager = getDataset(testSpace, AppUsingGetServiceURL.WORKER_INSTANCES_DATASET);\n    KeyValueTable instancesTable = datasetManager.get();\n    CloseableIterator<KeyValue<byte[], byte[]>> instancesIterator = instancesTable.scan(startRow, endRow);\n    try {\n      List<KeyValue<byte[], byte[]>> workerInstances = Lists.newArrayList(instancesIterator);\n      // Assert that the worker starts with expectedCount instances\n      Assert.assertEquals(expectedCount, workerInstances.size());\n      // Assert that each instance of the worker knows the total number of instances\n      for (KeyValue<byte[], byte[]> keyValue : workerInstances) {\n        Assert.assertEquals(expectedTotalCount, Bytes.toInt(keyValue.getValue()));\n      }\n    } finally {\n      instancesIterator.close();\n    }\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithServices() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.startService(AppWithServices.SERVICE_NAME);\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Call the ping endpoint\n    URL url = new URL(serviceURL, \"ping2\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    // Call the failure endpoint\n    url = new URL(serviceURL, \"failure\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(500, response.getResponseCode());\n    Assert.assertTrue(response.getResponseBodyAsString().contains(\"Transaction failure\"));\n\n    // Call the verify ClassLoader endpoint\n    url = new URL(serviceURL, \"verifyClassLoader\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(AppWithServices.APP_NAME,\n                                                                   AppWithServices.SERVICE_NAME);\n    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, serviceMetrics.getInput());\n    Assert.assertEquals(2, serviceMetrics.getProcessed());\n    Assert.assertEquals(1, serviceMetrics.getException());\n\n    // we can verify metrics, by adding getServiceMetrics in RuntimeStats and then disabling the system scope test in\n    // TestMetricsCollectionService\n\n    LOG.info(\"DatasetUpdateService Started\");\n    Map<String, String> args\n      = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,\n                        AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);\n    ServiceManager datasetWorkerServiceManager = applicationManager\n      .startService(AppWithServices.DATASET_WORKER_SERVICE_NAME, args);\n    datasetWorkerServiceManager.waitForStatus(true);\n\n    ProcedureManager procedureManager = applicationManager.startProcedure(\"NoOpProcedure\");\n    ProcedureClient procedureClient = procedureManager.getClient();\n\n    String result = procedureClient.query(\"ping\", ImmutableMap.of(AppWithServices.PROCEDURE_DATASET_KEY,\n                                                                  AppWithServices.DATASET_TEST_KEY));\n    String decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);\n\n    // Test that a service can discover another service\n    String path = String.format(\"discover/%s/%s\",\n                                AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    url = new URL(serviceURL, path);\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    datasetWorkerServiceManager.stop();\n    datasetWorkerServiceManager.waitForStatus(false);\n    LOG.info(\"DatasetUpdateService Stopped\");\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n    LOG.info(\"ServerService Stopped\");\n\n    result = procedureClient.query(\"ping\", ImmutableMap.of(AppWithServices.PROCEDURE_DATASET_KEY,\n                                                           AppWithServices.DATASET_TEST_KEY_STOP));\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);\n\n    result = procedureClient.query(\"ping\", ImmutableMap.of(AppWithServices.PROCEDURE_DATASET_KEY,\n                                                           AppWithServices.DATASET_TEST_KEY_STOP_2));\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);\n  }","id":31311,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithServices() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.startService(AppWithServices.SERVICE_NAME);\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Call the ping endpoint\n    URL url = new URL(serviceURL, \"ping2\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    // Call the failure endpoint\n    url = new URL(serviceURL, \"failure\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(500, response.getResponseCode());\n    Assert.assertTrue(response.getResponseBodyAsString().contains(\"Transaction failure\"));\n\n    // Call the verify ClassLoader endpoint\n    url = new URL(serviceURL, \"verifyClassLoader\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(AppWithServices.APP_NAME,\n                                                                   AppWithServices.SERVICE_NAME);\n    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, serviceMetrics.getInput());\n    Assert.assertEquals(2, serviceMetrics.getProcessed());\n    Assert.assertEquals(1, serviceMetrics.getException());\n\n    // we can verify metrics, by adding getServiceMetrics in RuntimeStats and then disabling the system scope test in\n    // TestMetricsCollectionService\n\n    LOG.info(\"DatasetUpdateService Started\");\n    Map<String, String> args\n      = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,\n                        AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);\n    ServiceManager datasetWorkerServiceManager = applicationManager\n      .startService(AppWithServices.DATASET_WORKER_SERVICE_NAME, args);\n    datasetWorkerServiceManager.waitForStatus(true);\n\n    ProcedureManager procedureManager = applicationManager.startProcedure(\"NoOpProcedure\");\n    ProcedureClient procedureClient = procedureManager.getClient();\n\n    String result = procedureClient.query(\"ping\", ImmutableMap.of(AppWithServices.PROCEDURE_DATASET_KEY,\n                                                                  AppWithServices.DATASET_TEST_KEY));\n    String decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);\n\n    // Test that a service can discover another service\n    String path = String.format(\"discover/%s/%s\",\n                                AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    url = new URL(serviceURL, path);\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    datasetWorkerServiceManager.stop();\n    datasetWorkerServiceManager.waitForStatus(false);\n    LOG.info(\"DatasetUpdateService Stopped\");\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n    LOG.info(\"ServerService Stopped\");\n\n    result = procedureClient.query(\"ping\", ImmutableMap.of(AppWithServices.PROCEDURE_DATASET_KEY,\n                                                           AppWithServices.DATASET_TEST_KEY_STOP));\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);\n\n    result = procedureClient.query(\"ping\", ImmutableMap.of(AppWithServices.PROCEDURE_DATASET_KEY,\n                                                           AppWithServices.DATASET_TEST_KEY_STOP_2));\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test(timeout = 240000)\n  public void testMultiInput() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(JoinMultiStreamApp.class);\n    applicationManager.startFlow(\"JoinMultiFlow\");\n\n    StreamWriter s1 = applicationManager.getStreamWriter(\"s1\");\n    StreamWriter s2 = applicationManager.getStreamWriter(\"s2\");\n    StreamWriter s3 = applicationManager.getStreamWriter(\"s3\");\n\n    s1.send(\"testing 1\");\n    s2.send(\"testing 2\");\n    s3.send(\"testing 3\");\n\n    RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(\"JoinMulti\", \"JoinMultiFlow\", \"Terminal\");\n\n    terminalMetrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    TimeUnit.SECONDS.sleep(1);\n\n    ProcedureManager queryManager = applicationManager.startProcedure(\"Query\");\n    Gson gson = new Gson();\n\n    ProcedureClient client = queryManager.getClient();\n    Assert.assertEquals(\"testing 1\",\n                        gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input1\")), String.class));\n    Assert.assertEquals(\"testing 2\",\n                        gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input2\")), String.class));\n    Assert.assertEquals(\"testing 3\",\n                        gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input3\")), String.class));\n  }","id":31312,"modified_method":"@Category(XSlowTests.class)\n  @Test(timeout = 240000)\n  public void testMultiInput() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(testSpace, JoinMultiStreamApp.class);\n    applicationManager.startFlow(\"JoinMultiFlow\");\n\n    StreamWriter s1 = applicationManager.getStreamWriter(\"s1\");\n    StreamWriter s2 = applicationManager.getStreamWriter(\"s2\");\n    StreamWriter s3 = applicationManager.getStreamWriter(\"s3\");\n\n    s1.send(\"testing 1\");\n    s2.send(\"testing 2\");\n    s3.send(\"testing 3\");\n\n    RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"JoinMulti\",\n                                                                    \"JoinMultiFlow\", \"Terminal\");\n\n    terminalMetrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    TimeUnit.SECONDS.sleep(1);\n\n    ProcedureManager queryManager = applicationManager.startProcedure(\"Query\");\n    Gson gson = new Gson();\n\n    ProcedureClient client = queryManager.getClient();\n    Assert.assertEquals(\"testing 1\",\n                        gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input1\")), String.class));\n    Assert.assertEquals(\"testing 2\",\n                        gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input2\")), String.class));\n    Assert.assertEquals(\"testing 3\",\n                        gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input3\")), String.class));\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testServiceRunnableInstances() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppUsingGetServiceURL.class);\n    ServiceManager serviceManager = applicationManager.startService(AppUsingGetServiceURL.SERVICE_WITH_WORKER);\n    serviceManager.waitForStatus(true);\n\n    String runnableName = AppUsingGetServiceURL.SERVICE_WITH_WORKER;\n    int retries = 5;\n\n    // Should be 1 instance when first started.\n    runnableInstancesCheck(serviceManager, runnableName, 1, retries, \"provisioned\");\n\n    // Test increasing instances.\n    serviceManager.setRunnableInstances(runnableName, 5);\n    runnableInstancesCheck(serviceManager, runnableName, 5, retries, \"provisioned\");\n\n    // Test decreasing instances.\n    serviceManager.setRunnableInstances(runnableName, 2);\n    runnableInstancesCheck(serviceManager, runnableName, 2, retries, \"provisioned\");\n\n    // Test requesting same number of instances.\n    serviceManager.setRunnableInstances(runnableName, 2);\n    runnableInstancesCheck(serviceManager, runnableName, 2, retries, \"provisioned\");\n\n    // Set 5 instances for the LifecycleWorker\n    serviceManager.setRunnableInstances(AppUsingGetServiceURL.LIFECYCLE_WORKER, 5);\n    runnableInstancesCheck(serviceManager, AppUsingGetServiceURL.LIFECYCLE_WORKER, 5, retries, \"provisioned\");\n\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    // Should be 0 instances when stopped.\n    runnableInstancesCheck(serviceManager, runnableName, 0, retries, \"provisioned\");\n    runnableInstancesCheck(serviceManager, AppUsingGetServiceURL.LIFECYCLE_WORKER, 0, retries, \"provisioned\");\n\n    // Assert the LifecycleWorker dataset writes\n    // 3 workers should have started with 3 total instances. 2 more should later start with 5 total instances.\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init.2\")), 3, 3);\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init.3\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init\")), 2, 5);\n\n    // Test that the worker had 5 instances when stopped, and each knew that there were 5 instances\n    byte[] startRow = Bytes.toBytes(\"stop\");\n    assertWorkerDatasetWrites(applicationManager, startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);\n  }","id":31313,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testServiceRunnableInstances() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);\n    ServiceManager serviceManager = applicationManager.startService(AppUsingGetServiceURL.SERVICE_WITH_WORKER);\n    serviceManager.waitForStatus(true);\n\n    String runnableName = AppUsingGetServiceURL.SERVICE_WITH_WORKER;\n    int retries = 5;\n\n    // Should be 1 instance when first started.\n    runnableInstancesCheck(serviceManager, runnableName, 1, retries, \"provisioned\");\n\n    // Test increasing instances.\n    serviceManager.setRunnableInstances(runnableName, 5);\n    runnableInstancesCheck(serviceManager, runnableName, 5, retries, \"provisioned\");\n\n    // Test decreasing instances.\n    serviceManager.setRunnableInstances(runnableName, 2);\n    runnableInstancesCheck(serviceManager, runnableName, 2, retries, \"provisioned\");\n\n    // Test requesting same number of instances.\n    serviceManager.setRunnableInstances(runnableName, 2);\n    runnableInstancesCheck(serviceManager, runnableName, 2, retries, \"provisioned\");\n\n    // Set 5 instances for the LifecycleWorker\n    serviceManager.setRunnableInstances(AppUsingGetServiceURL.LIFECYCLE_WORKER, 5);\n    runnableInstancesCheck(serviceManager, AppUsingGetServiceURL.LIFECYCLE_WORKER, 5, retries, \"provisioned\");\n\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    // Should be 0 instances when stopped.\n    runnableInstancesCheck(serviceManager, runnableName, 0, retries, \"provisioned\");\n    runnableInstancesCheck(serviceManager, AppUsingGetServiceURL.LIFECYCLE_WORKER, 0, retries, \"provisioned\");\n\n    // Assert the LifecycleWorker dataset writes\n    // 3 workers should have started with 3 total instances. 2 more should later start with 5 total instances.\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init.2\")), 3, 3);\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init.3\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init\")), 2, 5);\n\n    // Test that the worker had 5 instances when stopped, and each knew that there were 5 instances\n    byte[] startRow = Bytes.toBytes(\"stop\");\n    assertWorkerDatasetWrites(applicationManager, startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testDatasetWithoutApp() throws Exception {\n    // TODO: Although this has nothing to do with this testcase, deploying a dummy app to create the default namespace\n    deployApplication(DummyApp.class);\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(\"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY).create();\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> dataSetManager = getDataset(\"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = dataSetManager.get();\n    kvTable.put(\"test\", \"hello\");\n    dataSetManager.flush();\n    Assert.assertEquals(\"hello\", dataSetManager.get().get(\"test\"));\n  }","id":31314,"modified_method":"@Test(timeout = 60000L)\n  public void testDatasetWithoutApp() throws Exception {\n    // TODO: Although this has nothing to do with this testcase, deploying a dummy app to create the default namespace\n    deployApplication(testSpace, DummyApp.class);\n    deployDatasetModule(testSpace, \"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(testSpace, \"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY).create();\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> dataSetManager = getDataset(\"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = dataSetManager.get();\n    kvTable.put(\"test\", \"hello\");\n    dataSetManager.flush();\n    Assert.assertEquals(\"hello\", dataSetManager.get().get(\"test\"));\n  }","commit_id":"d0af6d6896be13045f83a1ec1a11c73ed51be8ef","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Generates a bnd file from the given contents map and returns it.\n   */\n  @NotNull\n  public static File makeBndFile(@NotNull Module module,\n                                 @NotNull Map<String, String> contents,\n                                 @NotNull File outputDir) throws IOException {\n    File tmpFile = FileUtil.createTempFile(outputDir, \"osmorc.\", \".bnd\", true);\n\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile));\n    try {\n      OrderedProperties props = OrderedProperties.fromMap(contents);\n      String comments = \"Bnd file generated by Osmorc for build of module \" + module.getName() + \" in project \" + module.getProject().getName();\n      props.store(bos, comments);\n    }\n    finally {\n      bos.close();\n    }\n\n    tmpFile.deleteOnExit();\n    return tmpFile;\n  }","id":31315,"modified_method":"/**\n   * Generates a bnd file from the given contents map and returns it.\n   */\n  @NotNull\n  public static File makeBndFile(@NotNull Module module,\n                                 @NotNull Map<String, String> contents,\n                                 @NotNull File outputDir) throws IOException {\n    File tmpFile = FileUtil.createTempFile(outputDir, \"osmorc.\", \".bnd\", true);\n\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile));\n    try {\n      OrderedProperties props = OrderedProperties.fromMap(contents);\n      String comments = \"Generated by Osmorc for build of module \" + module.getName() + \" in project \" + module.getProject().getName();\n      props.store(bos, comments);\n    }\n    finally {\n      bos.close();\n    }\n\n    tmpFile.deleteOnExit();\n    return tmpFile;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Builds the jar file for the given module. This is called inside a compile run.\n   */\n  public static boolean build(@NotNull Module module,\n                              @NotNull CompileContext compileContext,\n                              @NotNull File bndFile,\n                              @NotNull List<String> classPathUrls,\n                              @NotNull String outputPath) throws Exception {\n    String prefix = \"[\" + module.getName() + \"] \";\n\n    ReportingBuilder builder = new ReportingBuilder(compileContext, VfsUtilCore.pathToUrl(bndFile.getPath()), module);\n    builder.setPedantic(false);\n    builder.setProperties(bndFile);\n\n    File[] classPath = new File[classPathUrls.size()];\n    for (int i = 0; i < classPathUrls.size(); i++) {\n      classPath[i] = new File(VfsUtilCore.urlToPath(classPathUrls.get(i)));\n    }\n    builder.setClasspath(classPath);\n\n    // Check if the manifest version is missing (IDEADEV-41174)\n    String manifest = builder.getProperty(aQute.bnd.osgi.Constants.MANIFEST);\n    if (manifest != null) {\n      File manifestFile = builder.getFile(manifest);\n      if (manifestFile != null && manifestFile.canRead()) {\n        Properties props = new Properties();\n        FileInputStream fileInputStream = new FileInputStream(manifestFile);\n        try {\n          props.load(fileInputStream);\n          String value = props.getProperty(Attributes.Name.MANIFEST_VERSION.toString());\n          if (StringUtil.isEmptyOrSpaces(value)) {\n            String message = \"Your manifest does not contain a Manifest-Version entry. This may produce an empty manifest in the resulting bundle.\";\n            compileContext.addMessage(CompilerMessageCategory.WARNING, prefix + message, VfsUtilCore.pathToUrl(manifestFile.getAbsolutePath()), 0, 0);\n          }\n        }\n        catch (Exception ex) {\n          String message = \"There was a problem reading your manifest.\";\n          compileContext.addMessage(CompilerMessageCategory.WARNING, prefix + message, VfsUtilCore.pathToUrl(manifestFile.getAbsolutePath()), 0, 0);\n        }\n        finally {\n          fileInputStream.close();\n        }\n      }\n    }\n\n    File output = new File(outputPath);\n    Jar jar = builder.build();\n    jar.setName(output.getName());\n    jar.write(output);\n    builder.close();\n\n    return true;\n  }","id":31316,"modified_method":"/**\n   * Builds the jar file for the given module. This is called inside a compile run.\n   */\n  public static boolean build(@NotNull Module module,\n                              @NotNull CompileContext compileContext,\n                              @NotNull File bndFile,\n                              @NotNull File moduleOutputDir,\n                              @NotNull String outputPath) throws Exception {\n    String prefix = \"[\" + module.getName() + \"] \";\n\n    ReportingBuilder builder = new ReportingBuilder(compileContext, VfsUtilCore.pathToUrl(bndFile.getPath()), module);\n    builder.setPedantic(false);\n    builder.setProperties(bndFile);\n\n    File[] classPath = {moduleOutputDir};\n    builder.setClasspath(classPath);\n\n    // Check if the manifest version is missing (IDEADEV-41174)\n    String manifest = builder.getProperty(aQute.bnd.osgi.Constants.MANIFEST);\n    if (manifest != null) {\n      File manifestFile = builder.getFile(manifest);\n      if (manifestFile != null && manifestFile.canRead()) {\n        Properties props = new Properties();\n        FileInputStream fileInputStream = new FileInputStream(manifestFile);\n        try {\n          props.load(fileInputStream);\n          String value = props.getProperty(Attributes.Name.MANIFEST_VERSION.toString());\n          if (StringUtil.isEmptyOrSpaces(value)) {\n            String message = \"Your manifest does not contain a Manifest-Version entry. This may produce an empty manifest in the resulting bundle.\";\n            compileContext.addMessage(CompilerMessageCategory.WARNING, prefix + message, VfsUtilCore.pathToUrl(manifestFile.getAbsolutePath()), 0, 0);\n          }\n        }\n        catch (Exception ex) {\n          String message = \"There was a problem reading your manifest.\";\n          compileContext.addMessage(CompilerMessageCategory.WARNING, prefix + message, VfsUtilCore.pathToUrl(manifestFile.getAbsolutePath()), 0, 0);\n        }\n        finally {\n          fileInputStream.close();\n        }\n      }\n    }\n\n    File output = new File(outputPath);\n    Jar jar = builder.build();\n    jar.setName(output.getName());\n    jar.write(output);\n    builder.close();\n\n    return true;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Creates Osmorc output dir relative to a module's one.\n   */\n  @Nullable\n  public static File getOutputDir(@NotNull File moduleOutputDir, @NotNull CompileContext context) {\n    File outputDir = new File(moduleOutputDir.getParent(), \"bundles\");\n    if (!outputDir.exists() && !outputDir.mkdirs()) {\n      String message = \"Could not create output directory: \" + outputDir + \". Please check file permissions.\";\n      context.addMessage(CompilerMessageCategory.ERROR, message, null, 0, 0);\n      return null;\n    }\n    return outputDir;\n  }","id":31317,"modified_method":"/**\n   * Creates Osmorc output dir relative to a module's one.\n   */\n  @Nullable\n  public static File getOutputDir(@Nullable File moduleOutputDir, @NotNull CompileContext context) {\n    if (moduleOutputDir == null) {\n      return null;\n    }\n    File outputDir = new File(moduleOutputDir.getParent(), \"bundles\");\n    if (!outputDir.exists() && !outputDir.mkdirs()) {\n      String message = \"Could not create output directory: \" + outputDir + \". Please check file permissions.\";\n      context.addMessage(CompilerMessageCategory.ERROR, message, null, 0, 0);\n      return null;\n    }\n    return outputDir;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Builds the name of the jar file for a given module.\n   */\n  @Nullable\n  public static String getJarFileName(@NotNull final Module module) {\n    final OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    if (facet != null) {\n      return facet.getConfiguration().getJarFileLocation();\n    }\n    return null;\n  }","id":31318,"modified_method":"/**\n   * Builds the name of the jar file for a given module.\n   */\n  @Nullable\n  public static String getJarFileName(@NotNull final Module module) {\n    OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    return facet != null ? facet.getConfiguration().getJarFileLocation() : null;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Returns a virtual file representing the module's output path.\n   */\n  @Nullable\n  public static VirtualFile getModuleOutputUrl(@NotNull Module module) {\n    CompilerModuleExtension extension = CompilerModuleExtension.getInstance(module);\n    return extension != null ? extension.getCompilerOutputPath() : null;\n  }","id":31319,"modified_method":"/**\n   * Returns a file representing the module's output path.\n   */\n  @Nullable\n  public static File getModuleOutputDir(@NotNull Module module) {\n    CompilerModuleExtension extension = CompilerModuleExtension.getInstance(module);\n    if (extension != null) {\n      String url = extension.getCompilerOutputUrl();\n      if (url != null) {\n        return new File(VfsUtilCore.urlToPath(url));\n      }\n    }\n    return null;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Returns the manifest file for the given module if it exists\n   *\n   * @param module the module\n   * @return the manifest file or null if it doesnt exist\n   */\n  @Nullable\n  public static VirtualFile getManifestFile(@NotNull Module module) {\n    OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    // FIXES Exception (http://ea.jetbrains.com/browser/ea_problems/17161)\n    if (facet == null) {\n      return null;\n    }\n    ModuleRootManager manager = ModuleRootManager.getInstance(module);\n    for (VirtualFile root : manager.getContentRoots()) {\n      VirtualFile result = VfsUtilCore.findRelativeFile(facet.getManifestLocation(), root);\n      if (result != null) {\n        return result;\n      }\n    }\n    return null;\n  }","id":31320,"modified_method":"/**\n   * Returns the manifest file for the given module or null if it does not exist.\n   */\n  @Nullable\n  public static File getManifestFile(@NotNull Module module) {\n    OsmorcFacet facet = OsmorcFacet.getInstance(module);\n    if (facet != null) {\n      String manifestLocation = facet.getManifestLocation();\n      ModuleRootManager manager = ModuleRootManager.getInstance(module);\n      for (String root : manager.getContentRootUrls()) {\n        File file = new File(VfsUtilCore.urlToPath(root), manifestLocation);\n        if (file.exists()) {\n          return file;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Bundlifies all libraries that belong to the given module and that are not bundles and that are not modules.\n   * The bundles are cached, so if * the source library does not change, it will not be bundlified again.\n   * Returns a string array containing the urls of the bundlified libraries.\n   */\n  @NotNull\n  public static String[] bundlifyLibraries(@NotNull Module module,\n                                           @NotNull ProgressIndicator indicator,\n                                           @NotNull CompileContext compileContext) {\n    File outputDir = null;\n    VirtualFile moduleOutputUrl = getModuleOutputUrl(module);\n    if (moduleOutputUrl != null) {\n      outputDir = BndWrapper.getOutputDir(VfsUtilCore.virtualToIoFile(moduleOutputUrl), compileContext);\n    }\n    if (outputDir == null) {\n      // couldn't create output path, abort here..\n      return ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n\n    String[] urls = OrderEnumerator.orderEntries(module)\n      .withoutSdk()\n      .withoutModuleSourceEntries()\n      .withoutDepModules()\n      .productionOnly()\n      .runtimeOnly()\n      .recursively()\n      .exportedOnly()\n      .satisfying(NOT_FRAMEWORK_LIBRARY_CONDITION)\n      .classes().getUrls();\n    List<String> result = new ArrayList<String>();\n    BndWrapper wrapper = new BndWrapper();\n    for (String url : urls) {\n      url = convertJarUrlToFileUrl(url);\n      if (CachingBundleInfoProvider.canBeBundlified(url)) { // Fixes IDEA-56666\n        indicator.setText(\"Bundling non-OSGi libraries for module: \" + module.getName());\n        indicator.setText2(url);\n        // ok it is not a bundle, so we need to bundlify\n        String bundledLocation = wrapper.wrapLibrary(module, compileContext, url, outputDir);\n        // if no bundle could (or should) be created, we exempt this library\n        if (bundledLocation != null) {\n          result.add(fixFileURL(bundledLocation));\n        }\n      }\n      else if (CachingBundleInfoProvider.isBundle(url)) { // Exclude non-bundles (IDEA-56666)\n        result.add(fixFileURL(url));\n      }\n    }\n    return ArrayUtil.toStringArray(result);\n  }","id":31321,"modified_method":"/**\n   * Bundlifies all libraries that belong to the given module and that are not bundles and that are not modules.\n   * The bundles are cached, so if * the source library does not change, it will not be bundlified again.\n   * Returns a string array containing the urls of the bundlified libraries.\n   */\n  @NotNull\n  public static String[] bundlifyLibraries(@NotNull Module module,\n                                           @NotNull ProgressIndicator indicator,\n                                           @NotNull CompileContext compileContext) {\n    File outputDir = BndWrapper.getOutputDir(getModuleOutputDir(module), compileContext);\n    if (outputDir == null) {\n      // couldn't create output path, abort here..\n      return ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n\n    String[] urls = OrderEnumerator.orderEntries(module)\n      .withoutSdk()\n      .withoutModuleSourceEntries()\n      .withoutDepModules()\n      .productionOnly()\n      .runtimeOnly()\n      .recursively()\n      .exportedOnly()\n      .satisfying(NOT_FRAMEWORK_LIBRARY_CONDITION)\n      .classes().getUrls();\n    List<String> result = new ArrayList<String>();\n    BndWrapper wrapper = new BndWrapper();\n    for (String url : urls) {\n      url = convertJarUrlToFileUrl(url);\n      if (CachingBundleInfoProvider.canBeBundlified(url)) { // Fixes IDEA-56666\n        indicator.setText(\"Bundling non-OSGi libraries for module: \" + module.getName());\n        indicator.setText2(url);\n        // ok it is not a bundle, so we need to bundlify\n        String bundledLocation = wrapper.wrapLibrary(module, compileContext, url, outputDir);\n        // if no bundle could (or should) be created, we exempt this library\n        if (bundledLocation != null) {\n          result.add(fixFileURL(bundledLocation));\n        }\n      }\n      else if (CachingBundleInfoProvider.isBundle(url)) { // Exclude non-bundles (IDEA-56666)\n        result.add(fixFileURL(url));\n      }\n    }\n    return ArrayUtil.toStringArray(result);\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Builds the bundle for a given module.\n   */\n  private static void buildBundle(Module module, OsmorcFacet facet, CompileContext context) {\n    ProgressIndicator progressIndicator = context.getProgressIndicator();\n    progressIndicator.setText(\"Building bundle for module \" + module.getName());\n\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n\n    // create the jar file\n    File jarFile = new File(VfsUtilCore.urlToPath(getJarFileName(module)));\n    FileUtil.delete(jarFile);\n    if (!FileUtil.createParentDirs(jarFile)) {\n      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Cannot create path to \" + jarFile.getPath(), null, 0, 0);\n      return;\n    }\n\n    OsmorcFacetConfiguration configuration = facet.getConfiguration();\n\n    VirtualFile moduleOutputUrl = getModuleOutputUrl(module);\n    if (moduleOutputUrl == null) {\n      String message = \"Unable to determine the compiler output path for module \" + module.getName();\n      context.addMessage(CompilerMessageCategory.WARNING, message, null, 0, 0);\n      return;\n    }\n    File moduleOutputDir = VfsUtilCore.virtualToIoFile(moduleOutputUrl);\n\n    List<String> classPathUrls = ContainerUtil.newSmartList(moduleOutputUrl.getUrl());\n\n    // build a bnd file or use a provided one.\n    File bndFile = getBndFile(module, facet, context, moduleOutputDir);\n    if (bndFile == null) {\n      // error already reported\n      return;\n    }\n\n    String outputPath = jarFile.getPath();\n    if (configuration.isUseBundlorFile()) {\n      // we create a temp jar file in this case.\n      outputPath += \".tmp.jar\";\n    }\n\n    progressIndicator.setText2(\"Running bnd to build the bundle\");\n    try {\n      BndWrapper.build(module, context, bndFile, classPathUrls, outputPath);\n    }\n    catch (Exception e) {\n      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Unexpected error: \" + e.getMessage(), null, 0, 0);\n      return;\n    }\n\n    // if we use bundlor, let bundlor work on the generated file.\n    if (configuration.isUseBundlorFile()) {\n      progressIndicator.setText2(\"Running bundlor to calculate the manifest\");\n\n      File bundlorFile = findFileInModuleContentRoots(configuration.getBundlorFileLocation(), module);\n      if (bundlorFile == null || !bundlorFile.exists()) {\n        String message = String.format(\"The Bundlor file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                       configuration.getBundlorFileLocation(), module.getName());\n        context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, configuration.getBundlorFileLocation(), 0, 0);\n        return;\n      }\n\n      BundlorWrapper bw = new BundlorWrapper();\n      try {\n        if (!bw.wrapModule(context, outputPath, jarFile.getPath(), bundlorFile.getPath())) {\n          String message = \"Bundlifying the file \" + jarFile.getPath() + \" with Bundlor failed.\";\n          context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, null, 0, 0);\n          return;\n        }\n      }\n      finally {\n        // delete the tmp jar\n        File tempJar = new File(outputPath);\n        if (tempJar.exists() && !tempJar.delete()) {\n          String message = \"Could not delete temporary file: \" + tempJar.getPath();\n          context.addMessage(CompilerMessageCategory.WARNING, messagePrefix + message, null, 0, 0);\n        }\n      }\n    }\n\n    if (!configuration.isUseBndFile() && !configuration.isUseBundlorFile()) {\n      // finally bundlify all the libs for this one\n      bundlifyLibraries(module, progressIndicator, context);\n    }\n  }","id":31322,"modified_method":"/**\n   * Builds the bundle for a given module.\n   */\n  private static void buildBundle(Module module, OsmorcFacet facet, CompileContext context) {\n    ProgressIndicator progressIndicator = context.getProgressIndicator();\n    progressIndicator.setText(\"Building bundle for module \" + module.getName());\n\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n\n    // create the jar file\n    File jarFile = new File(VfsUtilCore.urlToPath(getJarFileName(module)));\n    FileUtil.delete(jarFile);\n    if (!FileUtil.createParentDirs(jarFile)) {\n      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Cannot create path to \" + jarFile.getPath(), null, 0, 0);\n      return;\n    }\n\n    OsmorcFacetConfiguration configuration = facet.getConfiguration();\n\n    File moduleOutputDir = getModuleOutputDir(module);\n    if (moduleOutputDir == null) {\n      String message = \"Unable to determine the compiler output path for module \" + module.getName();\n      context.addMessage(CompilerMessageCategory.WARNING, message, null, 0, 0);\n      return;\n    }\n\n    // build a bnd file or use a provided one.\n    File bndFile = getBndFile(module, facet, context, moduleOutputDir);\n    if (bndFile == null) {\n      // error already reported\n      return;\n    }\n\n    String outputPath = jarFile.getPath();\n    if (configuration.isUseBundlorFile()) {\n      // we create a temp jar file in this case.\n      outputPath += \".tmp.jar\";\n    }\n\n    progressIndicator.setText2(\"Running bnd to build the bundle\");\n    try {\n      BndWrapper.build(module, context, bndFile, moduleOutputDir, outputPath);\n    }\n    catch (Exception e) {\n      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Unexpected error: \" + e.getMessage(), null, 0, 0);\n      return;\n    }\n\n    // if we use bundlor, let bundlor work on the generated file.\n    if (configuration.isUseBundlorFile()) {\n      progressIndicator.setText2(\"Running bundlor to calculate the manifest\");\n\n      File bundlorFile = findFileInModuleContentRoots(configuration.getBundlorFileLocation(), module);\n      if (bundlorFile == null || !bundlorFile.exists()) {\n        String message = String.format(\"The Bundlor file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                       configuration.getBundlorFileLocation(), module.getName());\n        context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, configuration.getBundlorFileLocation(), 0, 0);\n        return;\n      }\n\n      BundlorWrapper bw = new BundlorWrapper();\n      try {\n        if (!bw.wrapModule(context, outputPath, jarFile.getPath(), bundlorFile.getPath())) {\n          String message = \"Bundlifying the file \" + jarFile.getPath() + \" with Bundlor failed.\";\n          context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, null, 0, 0);\n          return;\n        }\n      }\n      finally {\n        // delete the tmp jar\n        File tempJar = new File(outputPath);\n        if (tempJar.exists() && !tempJar.delete()) {\n          String message = \"Could not delete temporary file: \" + tempJar.getPath();\n          context.addMessage(CompilerMessageCategory.WARNING, messagePrefix + message, null, 0, 0);\n        }\n      }\n    }\n\n    if (!configuration.isUseBndFile() && !configuration.isUseBundlorFile()) {\n      // finally bundlify all the libs for this one\n      bundlifyLibraries(module, progressIndicator, context);\n    }\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void save(DataOutput out) throws IOException {\n    out.writeBoolean(myAlwaysRebuildBundleJAR);\n    IOUtil.writeString(myModuleName, out);\n    int i = myFileUrls.length;\n    out.writeInt(i);\n    for (int j = 0; j < i; j++) {\n      String s = myFileUrls[j];\n      long l = myFileTimestamps[j];\n      IOUtil.writeString(s, out);\n      out.writeLong(l);\n    }\n\n    IOUtil.writeString(myJarUrl, out);\n    out.writeLong(myJarLastModificationTime);\n    out.writeLong(myRulesModifiedTimeStamp);\n  }","id":31323,"modified_method":"@Override\n  public void save(@NotNull DataOutput out) throws IOException {\n    out.writeBoolean(myAlwaysRebuildBundleJAR);\n    IOUtil.writeString(myModuleName, out);\n    int i = myFilePaths.length;\n    out.writeInt(i);\n    for (int j = 0; j < i; j++) {\n      String s = myFilePaths[j];\n      long l = myFileTimestamps[j];\n      IOUtil.writeString(s, out);\n      out.writeLong(l);\n    }\n\n    IOUtil.writeString(myJarPath, out);\n    out.writeLong(myJarLastModificationTime);\n    out.writeLong(myRulesModifiedTimeStamp);\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Finds all included files of the given bnd file and registers them as dependencies as well\n   *\n   * @param bndFile        the bnd file.\n   * @param url2Timestamps the map containing the known timestamps\n   */\n  private static void registerDependencies(VirtualFile bndFile, TObjectLongHashMap<String> url2Timestamps) {\n    try {\n      String contents = VfsUtilCore.loadText(bndFile);\n      Pattern p = Pattern.compile(\"-include[:=\\\\s](.+)\");\n      Matcher m = p.matcher(contents);\n      while (m.find()) {\n        // get the file list\n        String dependentFileLocation = m.group(1);\n\n        String[] listMembers = dependentFileLocation.split(\",\");\n        for (String listMember : listMembers) {\n          // trim it, and remove any leading tilde or minus chars, which do not belong to the path name\n          listMember = listMember.trim().replaceFirst(\"^[~-]\", \"\");\n\n          // according to bnd specs all file locations are relative to the including file\n          // TODO: we currently do not support replacing bnd's properties or macros in the file locations\n          VirtualFile dependentFile = VfsUtilCore.findRelativeFile(listMember, bndFile);\n          if (dependentFile != null && dependentFile.exists()) {\n            if (url2Timestamps.containsKey(dependentFile.getUrl())) {\n              // welcome to the world of circular dependencies\n              return;\n            }\n            else {\n              registerTimestamps(dependentFile, url2Timestamps);\n              // recursively call for includes inside the included file\n              registerDependencies(dependentFile, url2Timestamps);\n            }\n          }\n        }\n      }\n    }\n    catch (IOException e) {\n      // bummer...\n    }\n  }","id":31324,"modified_method":"private static void registerDependencies(File bndFile, TObjectLongHashMap<String> paths2Timestamps) {\n    try {\n      String contents = FileUtil.loadFile(bndFile);\n      Matcher m = Pattern.compile(\"-include[:=\\\\s](.+)\").matcher(contents);\n      while (m.find()) {\n        // get the file list\n        String dependentFileLocation = m.group(1);\n\n        String[] listMembers = dependentFileLocation.split(\",\");\n        for (String listMember : listMembers) {\n          // trim it, and remove any leading tilde or minus chars, which do not belong to the path name\n          listMember = listMember.trim().replaceFirst(\"^[~-]\", \"\");\n\n          // according to bnd specs all file locations are relative to the including file\n          // TODO: we currently do not support replacing bnd's properties or macros in the file locations\n          File dependentFile = new File(bndFile, listMember);\n          if (dependentFile.exists()) {\n            if (paths2Timestamps.containsKey(dependentFile.getAbsolutePath())) {\n              // welcome to the world of circular dependencies\n              return;\n            }\n            else {\n              registerTimestamps(dependentFile, paths2Timestamps);\n              // recursively call for includes inside the included file\n              registerDependencies(dependentFile, paths2Timestamps);\n            }\n          }\n        }\n      }\n    }\n    catch (IOException e) {\n      // bummer...\n    }\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void registerTimestamps(VirtualFile root, final TObjectLongHashMap<String> url2Timestamps) {\n    VfsUtilCore.visitChildrenRecursively(root, new VirtualFileVisitor() {\n      @Override\n      public boolean visitFile(@NotNull VirtualFile file) {\n        if (!file.isDirectory()) {\n          url2Timestamps.put(file.getUrl(), file.getTimeStamp());\n        }\n        return super.visitFile(file);\n      }\n    });\n  }","id":31325,"modified_method":"private static void registerTimestamps(File root, final TObjectLongHashMap<String> paths2Timestamps) {\n    FileUtil.visitFiles(root, new Processor<File>() {\n      @Override\n      public boolean process(File file) {\n        FileAttributes attributes = FileSystemUtil.getAttributes(file);\n        if (attributes != null && !attributes.isDirectory()) {\n          paths2Timestamps.put(file.getAbsolutePath(), attributes.lastModified);\n        }\n        return true;\n      }\n    });\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public boolean equalsTo(ValidityState validityState) {\n    if (myAlwaysRebuildBundleJAR) {\n      return false;\n    }\n    if (!(validityState instanceof BundleValidityState)) {\n      return false;\n    }\n\n    BundleValidityState other = (BundleValidityState)validityState;\n    if (myRulesModifiedTimeStamp != other.myRulesModifiedTimeStamp) {\n      return false;\n    }\n    if (!myModuleName.equals(other.myModuleName)) {\n      return false;\n    }\n    if (myFileUrls.length != other.myFileUrls.length) {\n      return false;\n    }\n    for (int i = 0; i < myFileUrls.length; i++) {\n      String s = myFileUrls[i];\n      long l = myFileTimestamps[i];\n      if (!s.equals(other.myFileUrls[i]) || l != other.myFileTimestamps[i]) {\n        return false;\n      }\n    }\n    return Comparing.strEqual(myJarUrl, other.myJarUrl) &&\n           myJarLastModificationTime == other.myJarLastModificationTime;\n  }","id":31326,"modified_method":"@Override\n  public boolean equalsTo(ValidityState validityState) {\n    if (myAlwaysRebuildBundleJAR) {\n      return false;\n    }\n    if (!(validityState instanceof BundleValidityState)) {\n      return false;\n    }\n\n    BundleValidityState other = (BundleValidityState)validityState;\n    if (myRulesModifiedTimeStamp != other.myRulesModifiedTimeStamp) {\n      return false;\n    }\n    if (!myModuleName.equals(other.myModuleName)) {\n      return false;\n    }\n    if (myFilePaths.length != other.myFilePaths.length) {\n      return false;\n    }\n    for (int i = 0; i < myFilePaths.length; i++) {\n      if (!Comparing.strEqual(myFilePaths[i], other.myFilePaths[i]) ||\n          myFileTimestamps[i] != other.myFileTimestamps[i]) {\n        return false;\n      }\n    }\n    if (!Comparing.strEqual(myJarPath, other.myJarPath)) {\n      return false;\n    }\n    if (myJarLastModificationTime != other.myJarLastModificationTime) {\n      return false;\n    }\n\n    return true;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Ctor. Used by the bundle compiler to create a validity state for a given module.\n   *\n   * @param module the mode to create the validity state for.\n   */\n  public BundleValidityState(final Module module) {\n    myModuleName = module.getName();\n    myJarUrl = BundleCompiler.getJarFileName(module);\n\n    OsmorcFacet osmorcFacet = OsmorcFacet.getInstance(module);\n    OsmorcFacetConfiguration configuration = osmorcFacet != null ? osmorcFacet.getConfiguration() : null;\n    myAlwaysRebuildBundleJAR = configuration != null && configuration.isAlwaysRebuildBundleJAR();\n\n    if (myAlwaysRebuildBundleJAR) {\n      myJarLastModificationTime = 0;\n      myFileTimestamps = new long[0];\n      myFileUrls = ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n    else {\n      myJarLastModificationTime = (new File(VfsUtilCore.urlToPath(myJarUrl))).lastModified();\n      final TObjectLongHashMap<String> url2Timestamps = new TObjectLongHashMap<String>();\n\n      // note down the modification times of all files that will be copied by the Jar builder\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          VirtualFile moduleOutputDir = BundleCompiler.getModuleOutputUrl(module);\n          if (moduleOutputDir != null) {\n            registerTimestamps(moduleOutputDir, url2Timestamps);\n          }\n        }\n      });\n\n      // add the manifest from the facet settings (it might not be in the source roots)\n      // so the build is also triggered when only the manifest has changed\n      VirtualFile manifestFile = BundleCompiler.getManifestFile(module);\n      if (manifestFile != null) {\n        registerTimestamps(manifestFile, url2Timestamps);\n      }\n\n      if (osmorcFacet != null) {\n        List<Pair<String, String>> jarContents = configuration.getAdditionalJARContents();\n        for (Pair<String, String> jarContent : jarContents) {\n          VirtualFile file = LocalFileSystem.getInstance().findFileByPath(jarContent.getFirst());\n          if (file != null) {\n            registerTimestamps(file, url2Timestamps);\n          }\n        }\n\n        // OSMORC-130 - include BND files into change calculation\n        if (configuration.isUseBndFile()) {\n          String bndFileLocation = configuration.getBndFileLocation();\n          File bndFileIo = BundleCompiler.findFileInModuleContentRoots(bndFileLocation, module);\n          if (bndFileIo != null) {\n            VirtualFile bndFile = LocalFileSystem.getInstance().findFileByIoFile(bndFileIo);\n            if (bndFile != null && bndFile.exists()) {\n              registerTimestamps(bndFile, url2Timestamps);\n              registerDependencies(bndFile, url2Timestamps);\n            }\n          }\n        }\n      }\n\n      // we put the urls and timestamps into two arrays for easy serialization\n      myFileUrls = new String[url2Timestamps.size()];\n      myFileTimestamps = new long[url2Timestamps.size()];\n\n      url2Timestamps.forEachEntry(new TObjectLongProcedure<String>() {\n        public boolean execute(String s, long l) {\n          myFileUrls[i] = s;\n          myFileTimestamps[i] = l;\n          i++;\n          return true;\n        }\n\n        int i;\n      });\n    }\n\n    long lastModified = 0;\n    ApplicationSettings settings = ServiceManager.getService(ApplicationSettings.class);\n    for (LibraryBundlificationRule bundlificationRule : settings.getLibraryBundlificationRules()) {\n      lastModified = Math.max(lastModified, bundlificationRule.getLastModified());\n    }\n    myRulesModifiedTimeStamp = lastModified;\n  }","id":31327,"modified_method":"public BundleValidityState(@NotNull Module module) {\n    OsmorcFacet osmorcFacet = OsmorcFacet.getInstance(module);\n    OsmorcFacetConfiguration configuration = osmorcFacet != null ? osmorcFacet.getConfiguration() : null;\n    myAlwaysRebuildBundleJAR = configuration != null && configuration.isAlwaysRebuildBundleJAR();\n\n    myModuleName = module.getName();\n    myJarPath = ObjectUtils.notNull(BundleCompiler.getJarFileName(module), \"\");\n\n    if (myAlwaysRebuildBundleJAR) {\n      myFilePaths = ArrayUtil.EMPTY_STRING_ARRAY;\n      myFileTimestamps = ArrayUtil.EMPTY_LONG_ARRAY;\n      myJarLastModificationTime = 0;\n    }\n    else {\n      TObjectLongHashMap<String> paths2Timestamps = new TObjectLongHashMap<String>();\n\n      // note down the modification times of all files that will be copied by the Jar builder\n      File moduleOutputDir = BundleCompiler.getModuleOutputDir(module);\n      if (moduleOutputDir != null) {\n        registerTimestamps(moduleOutputDir, paths2Timestamps);\n      }\n\n      // add the manifest from the facet settings (it might not be in the source roots)\n      // so the build is also triggered when only the manifest has changed\n      File manifestFile = BundleCompiler.getManifestFile(module);\n      if (manifestFile != null) {\n        registerTimestamps(manifestFile, paths2Timestamps);\n      }\n\n      if (osmorcFacet != null) {\n        List<Pair<String, String>> jarContents = configuration.getAdditionalJARContents();\n        for (Pair<String, String> jarContent : jarContents) {\n          registerTimestamps(new File(jarContent.getFirst()), paths2Timestamps);\n        }\n\n        // OSMORC-130 - include BND files into change calculation\n        if (configuration.isUseBndFile()) {\n          String bndFileLocation = configuration.getBndFileLocation();\n          File bndFile = BundleCompiler.findFileInModuleContentRoots(bndFileLocation, module);\n          if (bndFile != null) {\n            registerTimestamps(bndFile, paths2Timestamps);\n            registerDependencies(bndFile, paths2Timestamps);\n          }\n        }\n      }\n\n      // we put the paths and timestamps into two arrays for easy serialization\n      myFilePaths = new String[paths2Timestamps.size()];\n      myFileTimestamps = new long[paths2Timestamps.size()];\n\n      paths2Timestamps.forEachEntry(new TObjectLongProcedure<String>() {\n        private int i = 0;\n\n        @Override\n        public boolean execute(String s, long l) {\n          myFilePaths[i] = s;\n          myFileTimestamps[i] = l;\n          i++;\n          return true;\n        }\n      });\n\n      FileAttributes attributes = FileSystemUtil.getAttributes(myJarPath);\n      myJarLastModificationTime = attributes != null ? attributes.lastModified : FileSystemInterface.DEFAULT_TIMESTAMP;\n    }\n\n    long lastModified = 0;\n    ApplicationSettings settings = ServiceManager.getService(ApplicationSettings.class);\n    for (LibraryBundlificationRule bundlificationRule : settings.getLibraryBundlificationRules()) {\n      lastModified = Math.max(lastModified, bundlificationRule.getLastModified());\n    }\n    myRulesModifiedTimeStamp = lastModified;\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public BundleValidityState(DataInput in) throws IOException {\n    myAlwaysRebuildBundleJAR = in.readBoolean();\n    myModuleName = IOUtil.readString(in);\n    int i = in.readInt();\n    myFileUrls = new String[i];\n    myFileTimestamps = new long[i];\n    for (int j = 0; j < i; j++) {\n      String s = IOUtil.readString(in);\n      long l = in.readLong();\n      myFileUrls[j] = s;\n      myFileTimestamps[j] = l;\n    }\n\n    myJarUrl = IOUtil.readString(in);\n    myJarLastModificationTime = in.readLong();\n    myRulesModifiedTimeStamp = in.readLong();\n  }","id":31328,"modified_method":"public BundleValidityState(@NotNull DataInput in) throws IOException {\n    myAlwaysRebuildBundleJAR = in.readBoolean();\n    myModuleName = IOUtil.readString(in);\n\n    int i = in.readInt();\n    myFilePaths = new String[i];\n    myFileTimestamps = new long[i];\n    for (int j = 0; j < i; j++) {\n      String s = IOUtil.readString(in);\n      long l = in.readLong();\n      myFilePaths[j] = s;\n      myFileTimestamps[j] = l;\n    }\n\n    myJarPath = IOUtil.readString(in);\n    myJarLastModificationTime = in.readLong();\n    myRulesModifiedTimeStamp = in.readLong();\n  }","commit_id":"9a8dbd78803fa605bd62fd11786af02969bab6e7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public VmTypeInfo populateVirtualBootRecord( final VmType vmType, final Partition partition,\n    \t\tfinal String instanceId) throws MetadataException {\n      final VmTypeInfo vmTypeInfo = VmTypes.asVmTypeInfo( vmType, this.getMachine( ) );\n      if ( this.isLinux( ) ) {\n        if ( this.hasKernel( ) ) {\n          vmTypeInfo.setKernel( this.getKernel( ).getDisplayName( ), this.getKernel( ).getManifestLocation( ) );\n        }\n        if ( this.hasRamdisk( ) ) {\n          vmTypeInfo.setRamdisk( this.getRamdisk( ).getDisplayName( ), this.getRamdisk( ).getManifestLocation( ) );\n        }\n      }\n      if ( this.getMachine( ) instanceof StaticDiskImage ) {\n        // generate download manifest and replace machine URL\n        try {\n          VirtualBootRecord root = vmTypeInfo.lookupRoot();\n          String manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n            new ImageManifestFile( ((StaticDiskImage)this.getMachine()).getManifestLocation(), BundleImageManifest.INSTANCE ),\n            partition.getNodePrivateKey(), instanceId, 3);\n          // TODO: change root as soon as back-end is ready\n          root.setResourceLocation(manifestLocation);\n          // LOG.info(\"Download manifest URL is \" + manifestLocation);\n        } catch (DownloadManifestException ex) {\n          throw new MetadataException(ex);\n        }\n      }\n      return vmTypeInfo;\n    }","id":31329,"modified_method":"public VmTypeInfo populateVirtualBootRecord( final VmType vmType, final Partition partition,\n    \t\tfinal String instanceId) throws MetadataException {\n      final VmTypeInfo vmTypeInfo = VmTypes.asVmTypeInfo( vmType, this.getMachine( ) );\n      try {\n        if ( this.isLinux( ) ) {\n          if ( this.hasKernel( ) ) {\n            String manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n                new ImageManifestFile( this.getKernel( ).getManifestLocation( ), BundleImageManifest.INSTANCE ),\n                partition.getNodePrivateKey(), this.getKernel( ).getDisplayName( ));\n            vmTypeInfo.setKernel( this.getKernel( ).getDisplayName( ), manifestLocation );\n          }\n          if ( this.hasRamdisk( ) ) {\n            String manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n                new ImageManifestFile( this.getRamdisk( ).getManifestLocation( ), BundleImageManifest.INSTANCE ),\n                partition.getNodePrivateKey(), this.getRamdisk( ).getDisplayName( ));\n            vmTypeInfo.setRamdisk( this.getRamdisk( ).getDisplayName( ), manifestLocation );\n          }\n        }\n        if ( this.getMachine( ) instanceof StaticDiskImage ) {\n            VirtualBootRecord root = vmTypeInfo.lookupRoot();\n            String manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n              new ImageManifestFile( ((StaticDiskImage)this.getMachine()).getManifestLocation(), BundleImageManifest.INSTANCE ),\n              partition.getNodePrivateKey(), instanceId);\n            root.setResourceLocation(manifestLocation);\n            vmTypeInfo.setRoot( this.getMachine( ).getDisplayName( ), manifestLocation, this.getMachine( ).getImageSizeBytes() );\n        }\n      } catch (DownloadManifestException ex) {\n        throw new MetadataException(ex);\n      }\n\n      return vmTypeInfo;\n    }","commit_id":"780ebafc2ba9deb74f722a884cd35c613f471fb9","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static VmTypeInfo asVmTypeInfo( VmType vmType, BootableImageInfo img ) throws MetadataException {\n    Long imgSize = img.getImageSizeBytes( );\n    Long diskSize = vmType.getDisk( ) * 1024l * 1024l * 1024l;\n    \n    if ( !( img instanceof BlockStorageImageInfo ) && imgSize > diskSize ) {\n      throw new InvalidMetadataException( \"image too large [size=\" + imgSize / ( 1024l * 1024l ) + \"MB] for instance type \" + vmType.getName( ) + \" [disk=\"\n                                          + vmType.getDisk( ) * 1024l + \"MB]\" );\n    }\n    VmTypeInfo vmTypeInfo = null;\n    if ( img instanceof StaticDiskImage ) {\n      if ( ImageMetadata.Platform.windows.equals( img.getPlatform( ) ) ) {\n        vmTypeInfo = VmTypes.InstanceStoreWindowsVmTypeInfoMapper.INSTANCE.apply( vmType );\n        vmTypeInfo.setEphemeral( 0, \"sdb\", diskSize - imgSize, \"none\" );\n      } else if(ImageMetadata.VirtualizationType.hvm.equals(img.getVirtualizationType())){\n    \tvmTypeInfo = VmTypes.InstanceStoreLinuxHvmVmTypeInfoMapper.INSTANCE.apply(vmType);\n        vmTypeInfo.setEphemeral( 0, \"sdb\", diskSize - imgSize, \"none\" );\n      } else\n      {\n        vmTypeInfo = VmTypes.InstanceStoreVmTypeInfoMapper.INSTANCE.apply( vmType );\n        long ephemeralSize = diskSize - imgSize - SWAP_SIZE_BYTES;\n        if ( ephemeralSize < MIN_EPHEMERAL_SIZE_BYTES ) {\n          throw new InvalidMetadataException( \"image too large to accommodate swap and ephemeral [size=\"\n                                              + imgSize\n                                              / ( 1024l * 1024l )\n                                              + \"MB] for instance type \"\n                                              + vmType.getName( )\n                                              + \" [disk=\"\n                                              + vmType.getDisk( )\n                                              * 1024l\n                                              + \"MB]\" );\n        }\n        vmTypeInfo.setEphemeral( 0, \"sda2\", ephemeralSize, \"ext3\" );\n      }\n      vmTypeInfo.setRoot( img.getDisplayName( ), ( ( StaticDiskImage ) img ).getManifestLocation( ), imgSize );\n    } else if ( img instanceof BlockStorageImageInfo ) {\n      vmTypeInfo = VmTypes.BlockStorageVmTypeInfoMapper.INSTANCE.apply( vmType );\n      vmTypeInfo.setRootDeviceName(img.getRootDeviceName());\n      vmTypeInfo.setEbsRoot( img.getDisplayName( ), null, imgSize );\n      // Getting rid of default ephemeral partition for bfebs instances to match AWS behavior. Fixes EUCA-3461, EUCA-3271  \n      // vmTypeInfo.setEphemeral( 0, \"sdb\", diskSize, \"none\" );\n    } else {\n      throw new InvalidMetadataException( \"Failed to identify the root machine image type: \" + img );\n    }\n    return vmTypeInfo;\n  }","id":31330,"modified_method":"public static VmTypeInfo asVmTypeInfo( VmType vmType, BootableImageInfo img ) throws MetadataException {\n    Long imgSize = img.getImageSizeBytes( );\n    Long diskSize = vmType.getDisk( ) * 1024l * 1024l * 1024l;\n    \n    if ( !( img instanceof BlockStorageImageInfo ) && imgSize > diskSize ) {\n      throw new InvalidMetadataException( \"image too large [size=\" + imgSize / ( 1024l * 1024l ) + \"MB] for instance type \" + vmType.getName( ) + \" [disk=\"\n                                          + vmType.getDisk( ) * 1024l + \"MB]\" );\n    }\n    VmTypeInfo vmTypeInfo = null;\n    if ( img instanceof StaticDiskImage ) {\n      if ( ImageMetadata.Platform.windows.equals( img.getPlatform( ) ) ) {\n        vmTypeInfo = VmTypes.InstanceStoreWindowsVmTypeInfoMapper.INSTANCE.apply( vmType );\n        vmTypeInfo.setEphemeral( 0, \"sdb\", diskSize - imgSize, \"none\" );\n      } else if(ImageMetadata.VirtualizationType.hvm.equals(img.getVirtualizationType())){\n    \tvmTypeInfo = VmTypes.InstanceStoreLinuxHvmVmTypeInfoMapper.INSTANCE.apply(vmType);\n        vmTypeInfo.setEphemeral( 0, \"sdb\", diskSize - imgSize, \"none\" );\n      } else\n      {\n        vmTypeInfo = VmTypes.InstanceStoreVmTypeInfoMapper.INSTANCE.apply( vmType );\n        long ephemeralSize = diskSize - imgSize - SWAP_SIZE_BYTES;\n        if ( ephemeralSize < MIN_EPHEMERAL_SIZE_BYTES ) {\n          throw new InvalidMetadataException( \"image too large to accommodate swap and ephemeral [size=\"\n                                              + imgSize\n                                              / ( 1024l * 1024l )\n                                              + \"MB] for instance type \"\n                                              + vmType.getName( )\n                                              + \" [disk=\"\n                                              + vmType.getDisk( )\n                                              * 1024l\n                                              + \"MB]\" );\n        }\n        vmTypeInfo.setEphemeral( 0, \"sda2\", ephemeralSize, \"ext3\" );\n      }\n    } else if ( img instanceof BlockStorageImageInfo ) {\n      vmTypeInfo = VmTypes.BlockStorageVmTypeInfoMapper.INSTANCE.apply( vmType );\n      vmTypeInfo.setRootDeviceName(img.getRootDeviceName());\n      vmTypeInfo.setEbsRoot( img.getDisplayName( ), null, imgSize );\n      // Getting rid of default ephemeral partition for bfebs instances to match AWS behavior. Fixes EUCA-3461, EUCA-3271  \n      // vmTypeInfo.setEphemeral( 0, \"sdb\", diskSize, \"none\" );\n    } else {\n      throw new InvalidMetadataException( \"Failed to identify the root machine image type: \" + img );\n    }\n    return vmTypeInfo;\n  }","commit_id":"780ebafc2ba9deb74f722a884cd35c613f471fb9","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected MuleClient getClient()\n    {\n        return client;\n    }","id":31331,"modified_method":"public String getClientId()\n    {\n        return clientId;\n    }","commit_id":"a27bb375089f67d922def8c7eb618b45880f2481","url":"https://github.com/mulesoft/mule"},{"original_method":"protected MuleMessage receiveMessage() throws Exception\n    {\n        return receiveMessage(DEFAULT_OUTPUT_MESSAGE);\n    }","id":31332,"modified_method":"public Message receive() throws Exception\n    {\n        return receive((MessagePostProcessor) null);\n    }","commit_id":"a27bb375089f67d922def8c7eb618b45880f2481","url":"https://github.com/mulesoft/mule"},{"original_method":"public AbstractJmsFunctionalTestCase(JmsVendorConfiguration config)\n    {\n        setJmsConfig(config);\n        scenarioNoTx = new NonTransactedScenario();\n        scenarioCommit = new ScenarioCommit();\n        scenarioRollback = new ScenarioRollback();\n        scenarioNotReceive = new ScenarioNotReceive();\n        scenarioReceive = new ScenarioReceive();\n    }","id":31333,"modified_method":"public AbstractJmsFunctionalTestCase(JmsVendorConfiguration config)\n    {\n        super();\n        setJmsConfig(config);\n    }","commit_id":"a27bb375089f67d922def8c7eb618b45880f2481","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Since we are using JUnit 4, but the Mule Test Framework assumes JUnit 3, we\n     * need to explicitly call the setUp and tearDown methods\n     *\n     * @throws Exception if, well, anything goes wrong\n     */\n    @After\n    public void after() throws Exception\n    {\n        super.tearDown();\n    }","id":31334,"modified_method":"/**\n     * Since we are using JUnit 4, but the Mule Test Framework assumes JUnit 3, we\n     * need to explicitly call the setUp and tearDown methods\n     *\n     * @throws Exception if, well, anything goes wrong\n     */\n    @After\n    public void after() throws Exception\n    {\n        super.tearDown();\n        purge(getJmsConfig().getInboundDestinationName());\n        purge(getJmsConfig().getOutboundDestinationName());\n        purge(getJmsConfig().getMiddleDestinationName());\n        purge(getJmsConfig().getDeadLetterDestinationName());\n    }","commit_id":"a27bb375089f67d922def8c7eb618b45880f2481","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Finds the {@link org.mule.transport.jms.integration.JmsVendorConfiguration} instances to test with by looking\n     * in a file called \"jms-vendor-configs.txt\" which contains one or more fuly qualified classnames of\n     * {@link org.mule.transport.jms.integration.JmsVendorConfiguration} instances to load.\n     *\n     * @return a collection of {@link org.mule.transport.jms.integration.JmsVendorConfiguration} instance to test\n     * against.\n     *\n     * @throws Exception if the 'jms-vendor-configs.txt' cannot be loaded or the classes defined within that file\n     * are not on the classpath\n     *\n     * TODO this method can return more than one provider, but our test class can only handle one at a time\n     * IMPORTANT: Only set one class in 'jms-vendor-configs.txt'\n     */\n    public static Collection jmsProviderConfigs()\n    {\n        JmsVendorConfiguration[][] configs;\n        URL url = ClassUtils.getResource(\"jms-vendor-configs.txt\", AbstractJmsFunctionalTestCase.class);\n\n        if (url == null)\n        {\n            fail(\"Please specify the org.mule.transport.jms.integration.JmsVendorConfiguration \" +\n                  \"implementation to use in jms-vendor-configs.txt on classpaath.\");\n            return CollectionUtils.EMPTY_COLLECTION;\n        }\n\n        if (logger.isInfoEnabled())\n        {\n            logger.info(\"Parameterized test using: \" + url);\n        }\n\n        try\n        {\n            List classes = IOUtils.readLines(url.openStream());\n            configs = new JmsVendorConfiguration[1][classes.size()];\n            int i = 0;\n            for (Iterator iterator = classes.iterator(); iterator.hasNext(); i++)\n            {\n                String cls = (String) iterator.next();\n                configs[0][i] = (JmsVendorConfiguration) ClassUtils.instanciateClass(cls, ClassUtils.NO_ARGS);\n            }\n            return Arrays.asList(configs);\n        }\n        catch (Exception e)\n        {\n            fail(\"Please specify the org.mule.transport.jms.integration.JmsVendorConfiguration \" +\n                 \"implementation to use in jms-vendor-configs.txt on classpath: \" + e.getMessage());\n            return CollectionUtils.EMPTY_COLLECTION;\n        }\n    }","id":31335,"modified_method":"/**\n     * Finds the {@link org.mule.transport.jms.integration.JmsVendorConfiguration} instances to test with by looking\n     * in a file called \"jms-vendor-configs.txt\" which contains one or more fuly qualified classnames of\n     * {@link org.mule.transport.jms.integration.JmsVendorConfiguration} instances to load.\n     *\n     * @return a collection of {@link org.mule.transport.jms.integration.JmsVendorConfiguration} instance to test\n     * against.\n     *\n     * @throws Exception if the 'jms-vendor-configs.txt' cannot be loaded or the classes defined within that file\n     * are not on the classpath\n     *\n     * TODO this method can return more than one provider, but our test class can only handle one at a time\n     * IMPORTANT: Only set one class in 'jms-vendor-configs.txt'\n     */\n    @Parameters\n    public static Collection jmsProviderConfigs()\n    {\n        URL url = ClassUtils.getResource(\"jms-vendor-configs.txt\", AbstractJmsFunctionalTestCase.class);\n\n        if (url == null)\n        {\n            fail(\"Please specify the org.mule.transport.jms.integration.JmsVendorConfiguration \" +\n                  \"implementation to use in jms-vendor-configs.txt on classpaath.\");\n            return CollectionUtils.EMPTY_COLLECTION;\n        }\n\n        if (logger.isInfoEnabled())\n        {\n            logger.info(\"Parameterized test using: \" + url);\n        }\n\n        try\n        {\n            List configs = new ArrayList();\n            List classes = IOUtils.readLines(url.openStream());\n            int i = 0;\n            for (Iterator iterator = classes.iterator(); iterator.hasNext(); i++)\n            {\n                String cls = (String) iterator.next();\n                configs.add(new Object[] { ClassUtils.instanciateClass(cls, ClassUtils.NO_ARGS) });\n            }\n            return configs;\n        }\n        catch (Exception e)\n        {\n            if (logger.isDebugEnabled())\n            {\n                e.printStackTrace();\n            }\n            fail(\"Please specify the org.mule.transport.jms.integration.JmsVendorConfiguration \" +\n                 \"implementation to use in jms-vendor-configs.txt on classpath: \" + e.getMessage());\n            return CollectionUtils.EMPTY_COLLECTION;\n        }\n    }","commit_id":"a27bb375089f67d922def8c7eb618b45880f2481","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Set<Class> processFileUrl(URL url, String basepath, Class clazz, int flags) throws IOException\n    {\n        Set<Class> set = new HashSet<Class>();\n        String urlBase = url.getFile();\n        //We can't URLDecoder.decode(path) since some encoded chars are allowed on file uris\n        urlBase = urlBase.replaceAll(\"%20\", \" \");\n        File dir = new File(urlBase);\n        if(!dir.isDirectory())\n        {\n            logger.warn(\"Cannot process File URL: \" + url + \". Path is not a directory\");\n            return set;\n        }\n\n        Collection<File> files = FileUtils.listFiles(new File(urlBase), new String[]{\"class\"}, true);\n        for (File file : files)\n        {\n            try\n            {\n                //Ignore anonymous and inner classes\n                if (file.getName().contains(\"$\") && !hasFlag(flags, INCLUDE_INNER))\n                {\n                    continue;\n                }\n                InputStream classStream = new FileInputStream(file);\n                ClassReader reader = new ClosableClassReader(classStream);\n\n                ClassScanner visitor = getScanner(clazz);\n                reader.accept(visitor, 0);\n                if (visitor.isMatch())\n                {\n                    addClassToSet(loadClass(visitor.getClassName()), set, flags);\n                }\n            }\n            catch (IOException e)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    Throwable t = ExceptionHelper.getRootException(e);\n                    logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                }\n            }\n        }\n        return set;\n    }","id":31336,"modified_method":"protected <T> Set<Class<T>> processFileUrl(URL url, String basepath, Class<T> clazz, int flags) throws IOException\n    {\n        Set<Class<T>> set = new HashSet<Class<T>>();\n        String urlBase = url.getFile();\n        //We can't URLDecoder.decode(path) since some encoded chars are allowed on file uris\n        urlBase = urlBase.replaceAll(\"%20\", \" \");\n        File dir = new File(urlBase);\n        if(!dir.isDirectory())\n        {\n            logger.warn(\"Cannot process File URL: \" + url + \". Path is not a directory\");\n            return set;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Collection<File> files = FileUtils.listFiles(new File(urlBase), new String[]{\"class\"}, true);\n        for (File file : files)\n        {\n            try\n            {\n                //Ignore anonymous and inner classes\n                if (file.getName().contains(\"$\") && !hasFlag(flags, INCLUDE_INNER))\n                {\n                    continue;\n                }\n                InputStream classStream = new FileInputStream(file);\n                ClassReader reader = new ClosableClassReader(classStream);\n\n                ClassScanner visitor = getScanner(clazz);\n                reader.accept(visitor, 0);\n                if (visitor.isMatch())\n                {\n                    @SuppressWarnings(\"unchecked\")\n                    Class<T> loadedClass = (Class<T>) loadClass(visitor.getClassName());\n                    addClassToSet(loadedClass, set, flags);\n                }\n            }\n            catch (IOException e)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    Throwable t = ExceptionHelper.getRootException(e);\n                    logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                }\n            }\n        }\n        return set;\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public Set<Class> scanFor(Class clazz, int flags) throws IOException\n    {\n        Set<Class> classes = new HashSet<Class>();\n\n        for (int i = 0; i < basepaths.length; i++)\n        {\n            String basepath = basepaths[i];\n\n            Enumeration<URL> urls = classLoader.getResources(basepath.trim());\n            while (urls.hasMoreElements())\n            {\n                URL url = urls.nextElement();\n                if (url.getProtocol().equalsIgnoreCase(\"file\"))\n                {\n                    classes.addAll(processFileUrl(url, basepath, clazz, flags));\n                }\n                else if (url.getProtocol().equalsIgnoreCase(\"jar\"))\n                {\n                    classes.addAll(processJarUrl(url, basepath, clazz, flags));\n                }\n                else\n                {\n                    throw new IllegalArgumentException(\"Do not understand how to handle protocol: \" + url.getProtocol());\n                }\n            }\n        }\n        return classes;\n    }","id":31337,"modified_method":"public <T> Set<Class<T>> scanFor(Class<T> clazz, int flags) throws IOException\n    {\n        Set<Class<T>> classes = new HashSet<Class<T>>();\n\n        for (int i = 0; i < basepaths.length; i++)\n        {\n            String basepath = basepaths[i];\n\n            Enumeration<URL> urls = classLoader.getResources(basepath.trim());\n            while (urls.hasMoreElements())\n            {\n                URL url = urls.nextElement();\n                if (url.getProtocol().equalsIgnoreCase(\"file\"))\n                {\n                    classes.addAll(processFileUrl(url, basepath, clazz, flags));\n                }\n                else if (url.getProtocol().equalsIgnoreCase(\"jar\"))\n                {\n                    classes.addAll(processJarUrl(url, basepath, clazz, flags));\n                }\n                else\n                {\n                    throw new IllegalArgumentException(\"Do not understand how to handle protocol: \" + url.getProtocol());\n                }\n            }\n        }\n        return classes;\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addClassToSet(Class c, Set<Class> set, int flags)\n    {\n        if (c != null)\n        {\n            synchronized (set)\n            {\n                if(c.isInterface())\n                {\n                    if(hasFlag(flags, INCLUDE_INTERFACE)) set.add(c);\n                }\n                else if(Modifier.isAbstract(c.getModifiers()))\n                {\n                    if(hasFlag(flags, INCLUDE_ABSTRACT)) set.add(c);\n                }\n                else\n                {\n                    set.add(c);\n                }\n            }\n        }\n    }","id":31338,"modified_method":"protected <T> void addClassToSet(Class<T> c, Set<Class<T>> set, int flags)\n    {\n        if (c != null)\n        {\n            synchronized (set)\n            {\n                if (c.isInterface())\n                {\n                    if (hasFlag(flags, INCLUDE_INTERFACE))\n                    {\n                        set.add(c);\n                    }\n                }\n                else if (Modifier.isAbstract(c.getModifiers()))\n                {\n                    if (hasFlag(flags, INCLUDE_ABSTRACT))\n                    {\n                        set.add(c);\n                    }\n                }\n                else\n                {\n                    set.add(c);\n                }\n            }\n        }\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public Set<Class> scanFor(Class clazz) throws IOException\n    {\n        return scanFor(clazz, DEFAULT_FLAGS);\n    }","id":31339,"modified_method":"public <T> Set<Class<T>> scanFor(Class<T> clazz) throws IOException\n    {\n        return scanFor(clazz, DEFAULT_FLAGS);\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Set<Class> processJarUrl(URL url, String basepath, Class clazz, int flags) throws IOException\n    {\n        Set<Class> set = new HashSet<Class>();\n        String path = url.getFile().substring(5, url.getFile().indexOf(\"!\"));\n        //We can't URLDecoder.decode(path) since some encoded chars are allowed on file uris\n        path = path.replaceAll(\"%20\", \" \");\n        JarFile jar = new JarFile(path);\n\n        for (Enumeration entries = jar.entries(); entries.hasMoreElements();)\n        {\n            JarEntry entry = (JarEntry) entries.nextElement();\n            if (entry.getName().startsWith(basepath) && entry.getName().endsWith(\".class\"))\n            {\n                try\n                {\n                    String name = entry.getName();\n                    //Ignore anonymous and inner classes\n                    if (name.contains(\"$\") && !hasFlag(flags, INCLUDE_INNER))\n                    {\n                        continue;\n                    }\n                    \n                    URL classURL = classLoader.getResource(name);\n                    InputStream classStream = classURL.openStream();\n                    ClassReader reader = new ClosableClassReader(classStream);\n\n                    ClassScanner visitor = getScanner(clazz);\n                    reader.accept(visitor, 0);\n                    if (visitor.isMatch())\n                    {\n                        addClassToSet(loadClass(visitor.getClassName()), set, flags);\n                    }\n                }\n                catch (Exception e)\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        Throwable t = ExceptionHelper.getRootException(e);\n                        logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                    }\n                }\n            }\n        }\n        jar.close();\n        \n        return set;\n    }","id":31340,"modified_method":"protected <T> Set<Class<T>> processJarUrl(URL url, String basepath, Class<T> clazz, int flags) throws IOException\n    {\n        Set<Class<T>> set = new HashSet<Class<T>>();\n        String path = url.getFile().substring(5, url.getFile().indexOf(\"!\"));\n        // We can't URLDecoder.decode(path) since some encoded chars are allowed on file uris\n        path = path.replaceAll(\"%20\", \" \");\n        JarFile jar = new JarFile(path);\n\n        for (Enumeration<JarEntry> entries = jar.entries(); entries.hasMoreElements();)\n        {\n            JarEntry entry = entries.nextElement();\n            if (entry.getName().startsWith(basepath) && entry.getName().endsWith(\".class\"))\n            {\n                try\n                {\n                    String name = entry.getName();\n                    // Ignore anonymous and inner classes\n                    if (name.contains(\"$\") && !hasFlag(flags, INCLUDE_INNER))\n                    {\n                        continue;\n                    }\n                    \n                    URL classURL = classLoader.getResource(name);\n                    InputStream classStream = classURL.openStream();\n                    ClassReader reader = new ClosableClassReader(classStream);\n\n                    ClassScanner visitor = getScanner(clazz);\n                    reader.accept(visitor, 0);\n                    if (visitor.isMatch())\n                    {\n                        @SuppressWarnings(\"unchecked\")\n                        Class<T> loadedClass = (Class<T>) loadClass(visitor.getClassName());\n                        addClassToSet(loadedClass, set, flags);\n                    }\n                }\n                catch (Exception e)\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        Throwable t = ExceptionHelper.getRootException(e);\n                        logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                    }\n                }\n            }\n        }\n        jar.close();\n        \n        return set;\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Works out the correct scanner based on the class passed in\n     * <p/>\n     * Note that these could be better architected by breaking out filters into strategy objects, but for now this\n     * suits my needs\n     *\n     * @param clazz the type to scan for\n     * @return a scanner suitable for handling the type passed in\n     * @see AnnotationsScanner\n     * @see InterfaceClassScanner\n     * @see ImplementationClassScanner\n     */\n    protected ClassScanner getScanner(Class clazz)\n    {\n        if (clazz.isInterface())\n        {\n            if (clazz.isAnnotation())\n            {\n                AnnotationFilter filter = null;\n                Annotation[] annos = clazz.getDeclaredAnnotations();\n                for (int i = 0; i < annos.length; i++)\n                {\n                    Annotation anno = annos[i];\n                    if (anno instanceof Target)\n                    {\n                        if (((Target) anno).value()[0] == ElementType.ANNOTATION_TYPE)\n                        {\n                            filter = new MetaAnnotationTypeFilter(clazz, classLoader);\n                        }\n                    }\n                }\n                if (filter == null)\n                {\n                    filter = new AnnotationTypeFilter(clazz);\n                }\n                return new AnnotationsScanner(filter);\n            }\n            else\n            {\n                return new InterfaceClassScanner(clazz);\n            }\n        }\n        else\n        {\n            return new ImplementationClassScanner(clazz);\n        }\n    }","id":31341,"modified_method":"/**\n     * Works out the correct scanner based on the class passed in\n     * <p/>\n     * Note that these could be better architected by breaking out filters into strategy objects, but for now this\n     * suits my needs\n     *\n     * @param clazz the type to scan for\n     * @return a scanner suitable for handling the type passed in\n     * @see AnnotationsScanner\n     * @see InterfaceClassScanner\n     * @see ImplementationClassScanner\n     */\n    protected ClassScanner getScanner(Class<?> clazz)\n    {\n        if (clazz.isInterface())\n        {\n            if (clazz.isAnnotation())\n            {\n                @SuppressWarnings(\"unchecked\")\n                Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) clazz;\n                \n                AnnotationFilter filter = null;\n                Annotation[] annos = clazz.getDeclaredAnnotations();\n                for (int i = 0; i < annos.length; i++)\n                {\n                    Annotation anno = annos[i];\n                    if (anno instanceof Target)\n                    {\n                        if (((Target) anno).value()[0] == ElementType.ANNOTATION_TYPE)\n                        {\n                            filter = new MetaAnnotationTypeFilter(annotationClass, classLoader);\n                        }\n                    }\n                }\n                if (filter == null)\n                {\n                    filter = new AnnotationTypeFilter(annotationClass);\n                }\n                return new AnnotationsScanner(filter);\n            }\n            else\n            {\n                return new InterfaceClassScanner(clazz);\n            }\n        }\n        else\n        {\n            return new ImplementationClassScanner(clazz);\n        }\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testImplementationScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner s = new ClasspathScanner(\"org/mule\");\n        Set<Class> set = s.scanFor(Orange.class);\n\n        assertFalse(set.contains(Apple.class));\n        assertTrue(set.contains(BloodOrange.class));\n        assertFalse(set.contains(OrangeInterface.class));\n        assertFalse(set.contains(Orange.class));\n        assertFalse(set.contains(Grape.class));\n        assertTrue(set.contains(MadridOrange.class));\n    }","id":31342,"modified_method":"public void testImplementationScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner scanner = new ClasspathScanner(\"org/mule\");\n        Set<Class<Orange>> set = scanner.scanFor(Orange.class);\n\n        assertFalse(set.contains(Apple.class));\n        assertTrue(set.contains(BloodOrange.class));\n        assertFalse(set.contains(OrangeInterface.class));\n        assertFalse(set.contains(Orange.class));\n        assertFalse(set.contains(Grape.class));\n        assertTrue(set.contains(MadridOrange.class));\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testAnnotationMetaScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner s = new ClasspathScanner(\"org/mule/util\");\n        Set<Class> set = s.scanFor(Meta.class);\n\n        assertEquals(3, set.size());\n        assertTrue(set.contains(SampleClassWithAnnotations.class));\n        assertTrue(set.contains(SampleBeanWithAnnotations.class));\n        assertTrue(set.contains(SubscribeBean.class));\n    }","id":31343,"modified_method":"public void testAnnotationMetaScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner scanner = new ClasspathScanner(\"org/mule/util\");\n        Set<Class<Meta>> set = scanner.scanFor(Meta.class);\n\n        assertEquals(3, set.size());\n        assertTrue(set.contains(SampleClassWithAnnotations.class));\n        assertTrue(set.contains(SampleBeanWithAnnotations.class));\n        assertTrue(set.contains(SubscribeBean.class));\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testAnnotationScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner s = new ClasspathScanner(\"org/mule\");\n        Set<Class> set = s.scanFor(Marker.class);\n\n        assertTrue(set.contains(SampleBeanWithAnnotations.class));\n        assertTrue(set.contains(SubscribeBean.class));\n\n        set = s.scanFor(NonMeta.class);\n        //assertEquals(1, set.size());\n        assertTrue(set.contains(SampleBeanWithAnnotations.class));\n\n    }","id":31344,"modified_method":"public void testAnnotationScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner scanner = new ClasspathScanner(\"org/mule\");\n        Set<Class<Marker>> set = scanner.scanFor(Marker.class);\n\n        assertTrue(set.contains(SampleBeanWithAnnotations.class));\n        assertTrue(set.contains(SubscribeBean.class));\n\n        Set<Class<NonMeta>> nonMetaSet = scanner.scanFor(NonMeta.class);\n        //assertEquals(1, set.size());\n        assertTrue(nonMetaSet.contains(SampleBeanWithAnnotations.class));\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testInterfaceScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner s = new ClasspathScanner(\"org/mule\");\n        Set<Class> set = s.scanFor(Fruit.class);\n\n        assertTrue(set.contains(Apple.class));\n        assertTrue(set.contains(RedApple.class));\n        assertTrue(set.contains(BloodOrange.class));\n        assertFalse(set.contains(OrangeInterface.class));\n        assertTrue(set.contains(Orange.class));\n        assertTrue(set.contains(Grape.class));\n        assertTrue(set.contains(SeedlessGrape.class));\n        assertTrue(set.contains(MadridOrange.class));\n    }","id":31345,"modified_method":"public void testInterfaceScanClasspathAndJarsMultipleBasePaths() throws Exception\n    {\n        ClasspathScanner scanner = new ClasspathScanner(\"org/mule\");\n        Set<Class<Fruit>> set = scanner.scanFor(Fruit.class);\n\n        assertTrue(set.contains(Apple.class));\n        assertTrue(set.contains(RedApple.class));\n        assertTrue(set.contains(BloodOrange.class));\n        assertFalse(set.contains(OrangeInterface.class));\n        assertTrue(set.contains(Orange.class));\n        assertTrue(set.contains(Grape.class));\n        assertTrue(set.contains(SeedlessGrape.class));\n        assertTrue(set.contains(MadridOrange.class));\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSearchInterfaceScanClasspathAndJarsWithInterfaceFlag() throws Exception\n        {\n            ClasspathScanner s = new ClasspathScanner(\"org/mule\");\n            Set<Class> set = s.scanFor(Fruit.class, ClasspathScanner.INCLUDE_INTERFACE);\n\n            assertTrue(set.contains(Apple.class));\n            assertTrue(set.contains(RedApple.class));\n            assertTrue(set.contains(BloodOrange.class));\n            assertTrue(set.contains(OrangeInterface.class));\n            assertTrue(set.contains(Orange.class));\n            assertTrue(set.contains(Grape.class));\n            assertTrue(set.contains(SeedlessGrape.class));\n        }","id":31346,"modified_method":"public void testSearchInterfaceScanClasspathAndJarsWithInterfaceFlag() throws Exception\n    {\n        ClasspathScanner scanner = new ClasspathScanner(\"org/mule\");\n        Set<Class<Fruit>> set = scanner.scanFor(Fruit.class, ClasspathScanner.INCLUDE_INTERFACE);\n\n        assertTrue(set.contains(Apple.class));\n        assertTrue(set.contains(RedApple.class));\n        assertTrue(set.contains(BloodOrange.class));\n        assertTrue(set.contains(OrangeInterface.class));\n        assertTrue(set.contains(Orange.class));\n        assertTrue(set.contains(Grape.class));\n        assertTrue(set.contains(SeedlessGrape.class));\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSearchInterfaceScanClasspathAndJars() throws Exception\n    {\n        ClasspathScanner s = new ClasspathScanner(\"org\");\n        Set<Class> set = s.scanFor(Fruit.class);\n\n        assertTrue(set.contains(Apple.class));\n        assertTrue(set.contains(RedApple.class));\n        assertTrue(set.contains(BloodOrange.class));\n        assertFalse(set.contains(OrangeInterface.class));\n        assertTrue(set.contains(Orange.class));\n        assertTrue(set.contains(Grape.class));\n        assertTrue(set.contains(SeedlessGrape.class));\n    }","id":31347,"modified_method":"public void testSearchInterfaceScanClasspathAndJars() throws Exception\n    {\n        ClasspathScanner scanner = new ClasspathScanner(\"org\");\n        Set<Class<Fruit>> set = scanner.scanFor(Fruit.class);\n\n        assertTrue(set.contains(Apple.class));\n        assertTrue(set.contains(RedApple.class));\n        assertTrue(set.contains(BloodOrange.class));\n        assertFalse(set.contains(OrangeInterface.class));\n        assertTrue(set.contains(Orange.class));\n        assertTrue(set.contains(Grape.class));\n        assertTrue(set.contains(SeedlessGrape.class));\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doConfigure(MuleContext muleContext) throws Exception\n    {\n\n        List<Module> allModules = getSystemModules(muleContext);\n\n        Injector injector;\n        if (basepath != null && basepath.startsWith(\"/\"))\n        {\n            basepath = basepath.substring(1);\n        }\n\n        //No modules were set explicitly on this ConfigurationBuilder so we now try and discover\n        //modules and {@link GuiceModuleFactory} instances on the classpath\n        if (modules == null)\n        {\n            ClasspathScanner scanner = new ClasspathScanner(classLoader, basepath);\n            Set<Class> classes = scanner.scanFor(Module.class);\n            Set<Class> factories = scanner.scanFor(GuiceModuleFactory.class);\n\n            if (classes.size() == 0 && factories.size() == 0)\n            {\n                try\n                {\n                    basepath = getClass().getClassLoader().getResources(basepath).toString();\n                }\n                catch (Exception e)\n                {\n                    basepath = (basepath.equals(\"\") ? \"/\" : basepath);\n                }\n                //lets just log a noticeable exception as a warning since the Guice build can compliment other configuration builders\n                logger.warn(new ConfigurationException(CoreMessages.createStaticMessage(\"There are no Guice modules or module factories on the classpath under: \" + basepath)));\n                return;\n            }\n\n            for (Class moduleClass : classes)\n            {\n                allModules.add((Module) ClassUtils.instanciateClass(moduleClass, ClassUtils.NO_ARGS));\n            }\n            for (Class factoryClass : factories)\n            {\n                GuiceModuleFactory factory = (GuiceModuleFactory) ClassUtils.instanciateClass(factoryClass, ClassUtils.NO_ARGS);\n                allModules.add(factory.createModule());\n            }\n        }\n        else\n        {\n            allModules.addAll(Arrays.asList(modules));\n        }\n\n        for (Module module : allModules)\n        {\n            if (module instanceof AbstractMuleGuiceModule)\n            {\n                ((AbstractMuleGuiceModule) module).setMuleContext(muleContext);\n            }\n        }\n\n        if (stage != null)\n        {\n            injector = Guice.createInjector(stage, allModules);\n        }\n        else\n        {\n            injector = Guice.createInjector(allModules);\n        }\n        \n        GuiceRegistry registry = new GuiceRegistry(injector, muleContext);\n        registry.initialise();\n        muleContext.addRegistry(registry);\n    }","id":31348,"modified_method":"@Override\n    protected void doConfigure(MuleContext muleContext) throws Exception\n    {\n\n        List<Module> allModules = getSystemModules(muleContext);\n\n        Injector injector;\n        if (basepath != null && basepath.startsWith(\"/\"))\n        {\n            basepath = basepath.substring(1);\n        }\n\n        //No modules were set explicitly on this ConfigurationBuilder so we now try and discover\n        //modules and {@link GuiceModuleFactory} instances on the classpath\n        if (modules == null)\n        {\n            ClasspathScanner scanner = new ClasspathScanner(classLoader, basepath);\n            Set<Class<Module>> classes = scanner.scanFor(Module.class);\n            Set<Class<GuiceModuleFactory>> factories = scanner.scanFor(GuiceModuleFactory.class);\n\n            if (classes.size() == 0 && factories.size() == 0)\n            {\n                try\n                {\n                    basepath = getClass().getClassLoader().getResources(basepath).toString();\n                }\n                catch (Exception e)\n                {\n                    basepath = (basepath.equals(\"\") ? \"/\" : basepath);\n                }\n                //lets just log a noticeable exception as a warning since the Guice build can compliment other configuration builders\n                logger.warn(new ConfigurationException(CoreMessages.createStaticMessage(\"There are no Guice modules or module factories on the classpath under: \" + basepath)));\n                return;\n            }\n\n            for (Class<Module> moduleClass : classes)\n            {\n                allModules.add(ClassUtils.instanciateClass(moduleClass, ClassUtils.NO_ARGS));\n            }\n            for (Class<GuiceModuleFactory> factoryClass : factories)\n            {\n                GuiceModuleFactory factory = ClassUtils.instanciateClass(factoryClass, ClassUtils.NO_ARGS);\n                allModules.add(factory.createModule());\n            }\n        }\n        else\n        {\n            allModules.addAll(Arrays.asList(modules));\n        }\n\n        for (Module module : allModules)\n        {\n            if (module instanceof AbstractMuleGuiceModule)\n            {\n                ((AbstractMuleGuiceModule) module).setMuleContext(muleContext);\n            }\n        }\n\n        if (stage != null)\n        {\n            injector = Guice.createInjector(stage, allModules);\n        }\n        else\n        {\n            injector = Guice.createInjector(allModules);\n        }\n        \n        GuiceRegistry registry = new GuiceRegistry(injector, muleContext);\n        registry.initialise();\n        muleContext.addRegistry(registry);\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected List<Module> getSystemModules(MuleContext muleContext)\n    {\n        List<Module> modules = new ArrayList<Module>();\n        //JSR-250 lifecycle and @Resource annotation support & Mule lifecycle support\n        modules.add(new MuleModule());\n        modules.add(new MuleSupportModule(muleContext));\n        return modules;\n    }","id":31349,"modified_method":"protected List<Module> getSystemModules(MuleContext muleContext)\n    {\n        List<Module> systemModules = new ArrayList<Module>();\n        //JSR-250 lifecycle and @Resource annotation support & Mule lifecycle support\n        systemModules.add(new MuleModule());\n        systemModules.add(new MuleSupportModule(muleContext));\n        return systemModules;\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doConfigure(MuleContext muleContext) throws Exception\n    {\n        Set<Class> ibeanClasses = new HashSet<Class>();\n        ClasspathScanner scanner = createClasspathScanner();\n\n        try\n        {\n            //There will be some overlap here but only\n            ibeanClasses.addAll(scanner.scanFor(Call.class, ClasspathScanner.INCLUDE_INTERFACE));\n            ibeanClasses.addAll(scanner.scanFor(Template.class, ClasspathScanner.INCLUDE_INTERFACE));\n            //Some ibeans will extend other iBeans but have not methods of there own\n            ibeanClasses.addAll(scanner.scanFor(IBeanGroup.class, ClasspathScanner.INCLUDE_INTERFACE));\n        }\n        catch (IOException e)\n        {\n            throw new ConfigurationException(e);\n        }\n\n        for (Class ibeanClass : ibeanClasses)\n        {\n            muleContext.getRegistry().registerObject(IBeanHolder.getId(ibeanClass), new IBeanHolder(ibeanClass));\n        }\n    }","id":31350,"modified_method":"@Override\n    protected void doConfigure(MuleContext muleContext) throws Exception\n    {\n        Set<Class<?>> ibeanClasses = new HashSet<Class<?>>();\n        ClasspathScanner scanner = createClasspathScanner();\n\n        try\n        {\n            //There will be some overlap here but only\n            ibeanClasses.addAll(scanner.scanFor(Call.class, ClasspathScanner.INCLUDE_INTERFACE));\n            ibeanClasses.addAll(scanner.scanFor(Template.class, ClasspathScanner.INCLUDE_INTERFACE));\n            //Some ibeans will extend other iBeans but have not methods of there own\n            ibeanClasses.addAll(scanner.scanFor(IBeanGroup.class, ClasspathScanner.INCLUDE_INTERFACE));\n        }\n        catch (IOException e)\n        {\n            throw new ConfigurationException(e);\n        }\n\n        for (Class<?> ibeanClass : ibeanClasses)\n        {\n            muleContext.getRegistry().registerObject(IBeanHolder.getId(ibeanClass), new IBeanHolder(ibeanClass));\n        }\n    }","commit_id":"98814e6cd2a79d6caa5356d9a14560640fe10f6f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected CaseInsensitiveHashMap createTestMap()\n    {\n        CaseInsensitiveHashMap map = new CaseInsensitiveHashMap();\n        map.put(\"FOO\", \"BAR\");\n        map.put(\"DOO\", new Integer(3));\n        return map;\n    }","id":31351,"modified_method":"protected CaseInsensitiveHashMap createTestMap()\n    {\n        CaseInsensitiveHashMap map = new CaseInsensitiveHashMap();\n        map.put(\"FOO\", \"BAR\");\n        map.put(\"DOO\", Integer.valueOf(3));\n        return map;\n    }","commit_id":"38ebacea23acad67a631c5b974aed8050b43f4f4","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doTestMap(CaseInsensitiveHashMap  map) throws Exception\n    {\n        assertEquals(\"BAR\", map.get(\"FOO\"));\n        assertEquals(\"BAR\", map.get(\"foo\"));\n        assertEquals(\"BAR\", map.get(\"Foo\"));\n\n        assertEquals(new Integer(3), map.get(\"DOO\"));\n        assertEquals(new Integer(3), map.get(\"doo\"));\n        assertEquals(new Integer(3), map.get(\"Doo\"));\n\n        assertEquals(2, map.size());\n\n        //Test that the key set contains the same case as we put in\n        for (Object o : map.keySet())\n        {\n            assertTrue(o.equals(\"FOO\") || o.equals(\"DOO\"));\n            assertFalse(o.equals(\"foo\") || o.equals(\"doo\"));\n        }\n\n\n    }","id":31352,"modified_method":"public void doTestMap(CaseInsensitiveHashMap  map) throws Exception\n    {\n        assertEquals(\"BAR\", map.get(\"FOO\"));\n        assertEquals(\"BAR\", map.get(\"foo\"));\n        assertEquals(\"BAR\", map.get(\"Foo\"));\n\n        assertEquals(Integer.valueOf(3), map.get(\"DOO\"));\n        assertEquals(Integer.valueOf(3), map.get(\"doo\"));\n        assertEquals(Integer.valueOf(3), map.get(\"Doo\"));\n\n        assertEquals(2, map.size());\n\n        // Test that the key set contains the same case as we put in\n        for (Object o : map.keySet())\n        {\n            assertTrue(o.equals(\"FOO\") || o.equals(\"DOO\"));\n            assertFalse(o.equals(\"foo\") || o.equals(\"doo\"));\n        }\n    }","commit_id":"38ebacea23acad67a631c5b974aed8050b43f4f4","url":"https://github.com/mulesoft/mule"},{"original_method":"protected ServletConnector getOrCreateServletConnector(String name) throws ServletException\n    {\n        ServletConnector connector;\n        if (name == null)\n        {\n            connector = (ServletConnector) new TransportFactory(muleContext).getConnectorByProtocol(\"servlet\");\n            if (connector == null)\n            {\n                connector = new ServletConnector();\n                connector.setName(\"_generatedServletConnector\");\n                try\n                {\n                    muleContext.getRegistry().registerConnector(connector);\n                }\n                catch (MuleException e)\n                {\n                    throw new ServletException(\"Failed to register the ServletConnector\", e);\n                }\n            }\n        }\n        else\n        {\n            connector = (ServletConnector) muleContext.getRegistry().lookupConnector(name);\n            if (connector == null)\n            {\n                throw new ServletException(ServletMessages.noServletConnectorFound(name).toString());\n            }\n        }\n\n        return connector;\n    }","id":31353,"modified_method":"protected ServletConnector getOrCreateServletConnector(String name) throws ServletException\n    {\n        ServletConnector servletConnector;\n        if (name == null)\n        {\n            servletConnector = (ServletConnector) new TransportFactory(muleContext).getConnectorByProtocol(\"servlet\");\n            if (servletConnector == null)\n            {\n                servletConnector = new ServletConnector();\n                servletConnector.setName(\"_generatedServletConnector\");\n                try\n                {\n                    muleContext.getRegistry().registerConnector(servletConnector);\n                }\n                catch (MuleException e)\n                {\n                    throw new ServletException(\"Failed to register the ServletConnector\", e);\n                }\n            }\n        }\n        else\n        {\n            servletConnector = (ServletConnector) muleContext.getRegistry().lookupConnector(name);\n            if (servletConnector == null)\n            {\n                throw new ServletException(ServletMessages.noServletConnectorFound(name).toString());\n            }\n        }\n\n        return servletConnector;\n    }","commit_id":"38ebacea23acad67a631c5b974aed8050b43f4f4","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Will shut down the server displaying the cause and time of the shutdown\n     *\n     * @param e the exception that caused the shutdown\n     */\n    public void shutdown(Throwable e)\n    {\n        Message msg = CoreMessages.fatalErrorWhileRunning();\n        MuleException muleException = ExceptionHelper.getRootMuleException(e);\n        if (muleException != null)\n        {\n            logger.fatal(muleException.getDetailedMessage());\n        }\n        else\n        {\n            logger.fatal(msg.toString() + \" \" + e.getMessage(), e);\n        }\n        List msgs = new ArrayList();\n        msgs.add(msg.getMessage());\n        Throwable root = ExceptionHelper.getRootException(e);\n        msgs.add(root.getMessage() + \" (\" + root.getClass().getName() + \")\");\n        msgs.add(\" \");\n        msgs.add(CoreMessages.fatalErrorInShutdown());\n        String shutdownMessage = StringMessageUtils.getBoilerPlate(msgs, '*', 80);\n        logger.fatal(shutdownMessage);\n\n        unregisterShutdownHook();\n        doShutdown();\n    }","id":31354,"modified_method":"/**\n     * Will shut down the server displaying the cause and time of the shutdown\n     *\n     * @param e the exception that caused the shutdown\n     */\n    public void shutdown(Throwable e)\n    {\n        Message msg = CoreMessages.fatalErrorWhileRunning();\n        MuleException muleException = ExceptionHelper.getRootMuleException(e);\n        if (muleException != null)\n        {\n            logger.fatal(muleException.getDetailedMessage());\n        }\n        else\n        {\n            logger.fatal(msg.toString() + \" \" + e.getMessage(), e);\n        }\n        List<String> msgs = new ArrayList<String>();\n        msgs.add(msg.getMessage());\n        Throwable root = ExceptionHelper.getRootException(e);\n        msgs.add(root.getMessage() + \" (\" + root.getClass().getName() + \")\");\n        msgs.add(\" \");\n        msgs.add(CoreMessages.fatalErrorInShutdown().getMessage());\n        String shutdownMessage = StringMessageUtils.getBoilerPlate(msgs, '*', 80);\n        logger.fatal(shutdownMessage);\n\n        unregisterShutdownHook();\n        doShutdown();\n    }","commit_id":"38ebacea23acad67a631c5b974aed8050b43f4f4","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Initializes this daemon. Derived classes could add some extra behaviour if\n     * they wish.\n     *\n     * @throws Exception if failed to initialize\n     */\n    public void initialize() throws Exception\n    {\n        if (configurationResources == null)\n        {\n            logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n            configurationResources = DEFAULT_CONFIGURATION;\n        }\n\n        ConfigurationBuilder cfgBuilder;\n\n        try\n        {\n            // create a new ConfigurationBuilder that is disposed afterwards\n            cfgBuilder = (ConfigurationBuilder) ClassUtils.instanciateClass(getConfigBuilderClassName(),\n                    new Object[]{configurationResources}, MuleServer.class);\n        }\n        catch (Exception e)\n        {\n            throw new ConfigurationException(CoreMessages.failedToLoad(getConfigBuilderClassName()), e);\n        }\n\n        if (!cfgBuilder.isConfigured())\n        {\n            List<ConfigurationBuilder> builders = new ArrayList<ConfigurationBuilder>(2);\n            builders.add(cfgBuilder);\n            //If the annotations module is on the classpath, add the annotations config builder to the list\n            //This will enable annotations config for this instance\n            if (ClassUtils.isClassOnPath(CLASSNAME_ANNOTATIONS_CONFIG_BUILDER, getClass()))\n            {\n                builders.add((ConfigurationBuilder) ClassUtils.instanciateClass(CLASSNAME_ANNOTATIONS_CONFIG_BUILDER,\n                        ClassUtils.NO_ARGS, getClass()));\n            }\n\n            Properties startupProperties = null;\n            if (getStartupPropertiesFile() != null)\n            {\n                startupProperties = PropertiesUtils.loadProperties(getStartupPropertiesFile(), getClass());\n            }\n            DefaultMuleContextFactory muleContextFactory = new DefaultMuleContextFactory();\n            muleContext = muleContextFactory.createMuleContext(cfgBuilder, startupProperties);\n        }\n    }","id":31355,"modified_method":"/**\n     * Initializes this daemon. Derived classes could add some extra behaviour if\n     * they wish.\n     *\n     * @throws Exception if failed to initialize\n     */\n    public void initialize() throws Exception\n    {\n        if (configurationResources == null)\n        {\n            logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n            configurationResources = DEFAULT_CONFIGURATION;\n        }\n\n        ConfigurationBuilder cfgBuilder;\n\n        try\n        {\n            // create a new ConfigurationBuilder that is disposed afterwards\n            cfgBuilder = (ConfigurationBuilder) ClassUtils.instanciateClass(getConfigBuilderClassName(),\n                    new Object[]{configurationResources}, MuleServer.class);\n        }\n        catch (Exception e)\n        {\n            throw new ConfigurationException(CoreMessages.failedToLoad(getConfigBuilderClassName()), e);\n        }\n\n        if (!cfgBuilder.isConfigured())\n        {\n            List<ConfigurationBuilder> builders = new ArrayList<ConfigurationBuilder>(2);\n            builders.add(cfgBuilder);\n            \n            // If the annotations module is on the classpath, add the annotations config builder to the list\n            // This will enable annotations config for this instance\n            if (ClassUtils.isClassOnPath(CLASSNAME_ANNOTATIONS_CONFIG_BUILDER, getClass()))\n            {\n                Object configBuilder = ClassUtils.instanciateClass(\n                    CLASSNAME_ANNOTATIONS_CONFIG_BUILDER, ClassUtils.NO_ARGS, getClass());\n                builders.add((ConfigurationBuilder) configBuilder);\n            }\n\n            Properties startupProperties = null;\n            if (getStartupPropertiesFile() != null)\n            {\n                startupProperties = PropertiesUtils.loadProperties(getStartupPropertiesFile(), getClass());\n            }\n            DefaultMuleContextFactory muleContextFactory = new DefaultMuleContextFactory();\n            muleContext = muleContextFactory.createMuleContext(cfgBuilder, startupProperties);\n        }\n    }","commit_id":"38ebacea23acad67a631c5b974aed8050b43f4f4","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testMessageSerialization() throws Exception\n    {\n        ObjectToXml t1 = createObject(ObjectToXml.class);\n        t1.setAcceptMuleMessage(true);\n\n        MuleMessage msg = new DefaultMuleMessage(\"test\", muleContext);\n        msg.setEncoding(\"UTF-8\");\n        msg.setCorrelationId(\"1234\");\n        msg.setProperty(\"number\", new Integer(1), PropertyScope.INVOCATION);\n        msg.setProperty(\"object\", new Apple(), PropertyScope.OUTBOUND);\n        msg.setProperty(\"string\", \"hello\", PropertyScope.OUTBOUND);\n\n        String xml = (String) t1.transform(msg);\n        assertNotNull(xml);\n\n        XmlToObject t2 = createObject(XmlToObject.class);\n\n        Object result = t2.transform(xml);\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessage);\n\n        msg = (MuleMessage) result;\n\n        assertEquals(\"test\", msg.getPayload());\n        assertEquals(new Apple(), msg.getProperty(\"object\", PropertyScope.OUTBOUND));\n        //with different case\n        assertEquals(new Apple(), msg.getProperty(\"oBjeCt\", PropertyScope.OUTBOUND));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.INVOCATION));\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.SESSION));\n\n        assertEquals(\"hello\", msg.getProperty(\"string\"));\n        //with different case\n        assertEquals(\"hello\", msg.getProperty(\"String\"));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"string\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"string\", PropertyScope.INVOCATION));\n        assertNull(msg.getProperty(\"string\", PropertyScope.SESSION));\n\n        assertEquals(new Integer(1), msg.getProperty(\"number\", PropertyScope.INVOCATION));\n        //with different case\n        assertEquals(new Integer(1), msg.getProperty(\"NUMBER\", PropertyScope.INVOCATION));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"number\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.OUTBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.SESSION));\n\n        assertEquals(\"1234\", msg.getCorrelationId());\n        assertEquals(\"UTF-8\", msg.getEncoding());\n\n\n        Set<String> keys = msg.getPropertyNames();\n\n        assertEquals(5, keys.size());\n\n        //Remove Mule properties\n        keys.remove(MuleProperties.MULE_CORRELATION_ID_PROPERTY);\n        keys.remove(MuleProperties.MULE_ENCODING_PROPERTY);\n\n        for (String key : keys)\n        {\n            assertTrue(key.equals(\"number\") || key.equals(\"string\") || key.equals(\"object\"));\n            assertFalse(key.equals(\"NUMBER\") || key.equals(\"STRING\") || key.equals(\"OBJECT\"));\n        }\n\n    }","id":31356,"modified_method":"public void testMessageSerialization() throws Exception\n    {\n        ObjectToXml t1 = createObject(ObjectToXml.class);\n        t1.setAcceptMuleMessage(true);\n\n        MuleMessage msg = new DefaultMuleMessage(\"test\", muleContext);\n        msg.setEncoding(\"UTF-8\");\n        msg.setCorrelationId(\"1234\");\n        msg.setProperty(\"number\", Integer.valueOf(1), PropertyScope.INVOCATION);\n        msg.setProperty(\"object\", new Apple(), PropertyScope.OUTBOUND);\n        msg.setProperty(\"string\", \"hello\", PropertyScope.OUTBOUND);\n\n        String xml = (String) t1.transform(msg);\n        assertNotNull(xml);\n\n        XmlToObject t2 = createObject(XmlToObject.class);\n\n        Object result = t2.transform(xml);\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessage);\n\n        msg = (MuleMessage) result;\n\n        assertEquals(\"test\", msg.getPayload());\n        assertEquals(new Apple(), msg.getProperty(\"object\", PropertyScope.OUTBOUND));\n        //with different case\n        assertEquals(new Apple(), msg.getProperty(\"oBjeCt\", PropertyScope.OUTBOUND));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.INVOCATION));\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.SESSION));\n\n        assertEquals(\"hello\", msg.getProperty(\"string\"));\n        //with different case\n        assertEquals(\"hello\", msg.getProperty(\"String\"));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"string\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"string\", PropertyScope.INVOCATION));\n        assertNull(msg.getProperty(\"string\", PropertyScope.SESSION));\n\n        assertEquals(new Integer(1), msg.getProperty(\"number\", PropertyScope.INVOCATION));\n        //with different case\n        assertEquals(new Integer(1), msg.getProperty(\"NUMBER\", PropertyScope.INVOCATION));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"number\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.OUTBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.SESSION));\n\n        assertEquals(\"1234\", msg.getCorrelationId());\n        assertEquals(\"UTF-8\", msg.getEncoding());\n\n        Set<String> keys = msg.getPropertyNames();\n        assertEquals(5, keys.size());\n\n        //Remove Mule properties\n        keys.remove(MuleProperties.MULE_CORRELATION_ID_PROPERTY);\n        keys.remove(MuleProperties.MULE_ENCODING_PROPERTY);\n\n        for (String key : keys)\n        {\n            assertTrue(key.equals(\"number\") || key.equals(\"string\") || key.equals(\"object\"));\n            assertFalse(key.equals(\"NUMBER\") || key.equals(\"STRING\") || key.equals(\"OBJECT\"));\n        }\n    }","commit_id":"38ebacea23acad67a631c5b974aed8050b43f4f4","url":"https://github.com/mulesoft/mule"},{"original_method":"public String toString()\n    {\n        return \"JiniEntryFilter{\" + \"expectedType=\" + expectedType + \", fields=\" + fields + \"}\";\n    }","id":31357,"modified_method":"public String toString()\n    {\n        return \"Filter{\" + \"expectedType=\" + expectedType + \", fields=\" + fields + \"}\";\n    }","commit_id":"f78c9fbba6b0287d21ca0cc5732b2b7df09b7bce","url":"https://github.com/mulesoft/mule"},{"original_method":"public Entry getEntry() throws IllegalAccessException, NoSuchMethodException,\n            InvocationTargetException, InstantiationException, ClassNotFoundException\n    {\n\n        if (entry == null) {\n            if (expectedType == null) {\n                return null; // Match all template\n            }\n            entry = (Entry)ClassHelper.instanciateClass(expectedType, ClassHelper.NO_ARGS);\n            if (entry.getClass().isAssignableFrom(Entry.class)) {\n                throw new IllegalArgumentException(new Message(\"gs\", 1, expectedType).toString());\n            }\n            if (fields.size() > 0) {\n                BeanUtils.populate(entry, fields);\n            }\n        }\n        return entry;\n    }","id":31358,"modified_method":"public Entry getEntry() throws IllegalAccessException, NoSuchMethodException,\n            InvocationTargetException, InstantiationException, ClassNotFoundException\n    {\n\n        if (entry == null) {\n            if (expectedType == null) {\n                return null; // Match all template\n            }\n            Object entryType = ClassHelper.instanciateClass(expectedType, ClassHelper.NO_ARGS);\n            if (!(entryType instanceof Entry)) {\n                entry = new JiniMessage(null, entryType);\n                if (fields.size() > 0) {\n                    //Populate any properties on the message\n                    BeanUtils.populate(entry, fields);\n                    //populate properties on the payload\n                    BeanUtils.populate(((JiniMessage)entry).getPayload(), fields);\n                }\n            } else {\n                entry = (Entry)entryType;\n                if (fields.size() > 0) {\n                    BeanUtils.populate(entry, fields);\n                }\n            }\n\n        }\n        return entry;\n    }","commit_id":"f78c9fbba6b0287d21ca0cc5732b2b7df09b7bce","url":"https://github.com/mulesoft/mule"},{"original_method":"public OBonsaiBucketPointer(long pageIndex) {\n    this.pageIndex = pageIndex;\n  }","id":31359,"modified_method":"public OBonsaiBucketPointer(long pageIndex, int pageOffset) {\n    this.pageIndex = pageIndex;\n    this.pageOffset = pageOffset;\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private BucketSearchResult splitBucket(List<OBonsaiBucketPointer> path, int keyIndex, K keyToInsert) throws IOException {\n    final OBonsaiBucketPointer bucketPointer = path.get(path.size() - 1);\n    OCacheEntry bucketEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n    OCachePointer pointer = bucketEntry.getCachePointer();\n\n    pointer.acquireExclusiveLock();\n    try {\n      OSBTreeBonsaiBucket<K, V> bucketToSplit = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(),\n          bucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n\n      final boolean splitLeaf = bucketToSplit.isLeaf();\n      final int bucketSize = bucketToSplit.size();\n\n      int indexToSplit = bucketSize >>> 1;\n      final K separationKey = bucketToSplit.getKey(indexToSplit);\n      final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> rightEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n          indexToSplit);\n\n      final int startRightIndex = splitLeaf ? indexToSplit : indexToSplit + 1;\n\n      for (int i = startRightIndex; i < bucketSize; i++)\n        rightEntries.add(bucketToSplit.getEntry(i));\n\n      if (!bucketPointer.equals(rootBucketPointer)) {\n        // TODO\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        final OBonsaiBucketPointer rightBucketPointer = new OBonsaiBucketPointer(rightBucketEntry.getPageIndex());\n\n        OCachePointer rightPointer = rightBucketEntry.getCachePointer();\n\n        rightPointer.acquireExclusiveLock();\n\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightPointer.getDataPointer(),\n              rightBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          bucketToSplit.shrink(indexToSplit);\n\n          if (splitLeaf) {\n            OBonsaiBucketPointer rightSiblingBucketPointer = bucketToSplit.getRightSibling();\n\n            newRightBucket.setRightSibling(rightSiblingBucketPointer);\n            newRightBucket.setLeftSibling(bucketPointer);\n\n            bucketToSplit.setRightSibling(rightBucketPointer);\n\n            if (rightSiblingBucketPointer.isValid()) {\n              final OCacheEntry rightSiblingBucketEntry = diskCache.load(fileId, rightSiblingBucketPointer.getPageIndex(), false);\n              final OCachePointer rightSiblingPointer = rightSiblingBucketEntry.getCachePointer();\n\n              rightSiblingPointer.acquireExclusiveLock();\n              OSBTreeBonsaiBucket<K, V> rightSiblingBucket = new OSBTreeBonsaiBucket<K, V>(rightSiblingPointer.getDataPointer(),\n                  rightSiblingBucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n              try {\n                rightSiblingBucket.setLeftSibling(rightBucketPointer);\n                logPageChanges(rightSiblingBucket, fileId, rightSiblingBucketPointer.getPageIndex(), false);\n\n                rightSiblingBucketEntry.markDirty();\n              } finally {\n                rightSiblingPointer.releaseExclusiveLock();\n                diskCache.release(rightSiblingBucketEntry);\n              }\n            }\n          }\n\n          OBonsaiBucketPointer parentBucketPointer = path.get(path.size() - 2);\n          OCacheEntry parentCacheEntry = diskCache.load(fileId, parentBucketPointer.getPageIndex(), false);\n          OCachePointer parentPointer = parentCacheEntry.getCachePointer();\n\n          parentPointer.acquireExclusiveLock();\n          try {\n            OSBTreeBonsaiBucket<K, V> parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(),\n                parentBucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n            OSBTreeBonsaiBucket.SBTreeEntry<K, V> parentEntry = new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(bucketPointer,\n                rightBucketPointer, separationKey, null);\n\n            int insertionIndex = parentBucket.find(separationKey);\n            assert insertionIndex < 0;\n\n            insertionIndex = -insertionIndex - 1;\n            while (!parentBucket.addEntry(insertionIndex, parentEntry, true)) {\n              parentPointer.releaseExclusiveLock();\n              diskCache.release(parentCacheEntry);\n\n              BucketSearchResult bucketSearchResult = splitBucket(path.subList(0, path.size() - 1), insertionIndex, separationKey);\n\n              parentBucketPointer = bucketSearchResult.getLastPathItem();\n              parentCacheEntry = diskCache.load(fileId, parentBucketPointer.getPageIndex(), false);\n              parentPointer = parentCacheEntry.getCachePointer();\n\n              parentPointer.acquireExclusiveLock();\n\n              insertionIndex = bucketSearchResult.itemIndex;\n\n              parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(), parentBucketPointer.getPageOffset(),\n                  keySerializer, valueSerializer, getTrackMode());\n            }\n\n            logPageChanges(parentBucket, fileId, parentBucketPointer.getPageIndex(), false);\n          } finally {\n            parentCacheEntry.markDirty();\n            parentPointer.releaseExclusiveLock();\n\n            diskCache.release(parentCacheEntry);\n          }\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n        } finally {\n          rightBucketEntry.markDirty();\n          rightPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        logPageChanges(bucketToSplit, fileId, bucketPointer.getPageIndex(), false);\n        ArrayList<OBonsaiBucketPointer> resultPath = new ArrayList<OBonsaiBucketPointer>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(bucketPointer);\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketPointer);\n        if (splitLeaf) {\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n        }\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n\n      } else {\n        long treeSize = bucketToSplit.getTreeSize();\n\n        final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> leftEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n            indexToSplit);\n\n        for (int i = 0; i < indexToSplit; i++)\n          leftEntries.add(bucketToSplit.getEntry(i));\n\n        // TODO\n        OCacheEntry leftBucketEntry = diskCache.allocateNewPage(fileId);\n        OBonsaiBucketPointer leftBucketPointer = new OBonsaiBucketPointer(leftBucketEntry.getPageIndex());\n        OCachePointer leftPointer = leftBucketEntry.getCachePointer();\n\n        // TODO\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        OBonsaiBucketPointer rightBucketPointer = new OBonsaiBucketPointer(rightBucketEntry.getPageIndex());\n        leftPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newLeftBucket = new OSBTreeBonsaiBucket<K, V>(leftPointer.getDataPointer(),\n              leftBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newLeftBucket.addAll(leftEntries);\n\n          if (splitLeaf)\n            newLeftBucket.setRightSibling(rightBucketPointer);\n\n          logPageChanges(newLeftBucket, fileId, leftBucketEntry.getPageIndex(), true);\n          leftBucketEntry.markDirty();\n        } finally {\n          leftPointer.releaseExclusiveLock();\n          diskCache.release(leftBucketEntry);\n        }\n\n        OCachePointer rightPointer = rightBucketEntry.getCachePointer();\n        rightPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightPointer.getDataPointer(),\n              rightBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          if (splitLeaf)\n            newRightBucket.setLeftSibling(leftBucketPointer);\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n          rightBucketEntry.markDirty();\n        } finally {\n          rightPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        bucketToSplit = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), bucketPointer.getPageOffset(), false,\n            keySerializer, valueSerializer, getTrackMode());\n        bucketToSplit.setTreeSize(treeSize);\n\n        bucketToSplit.addEntry(0, new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(leftBucketPointer, rightBucketPointer, separationKey,\n            null), true);\n\n        logPageChanges(bucketToSplit, fileId, bucketPointer.getPageIndex(), false);\n        ArrayList<OBonsaiBucketPointer> resultPath = new ArrayList<OBonsaiBucketPointer>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(leftBucketPointer);\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketPointer);\n\n        if (splitLeaf)\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n      }\n\n    } finally {\n      bucketEntry.markDirty();\n      pointer.releaseExclusiveLock();\n      diskCache.release(bucketEntry);\n    }\n  }","id":31360,"modified_method":"private BucketSearchResult splitBucket(List<OBonsaiBucketPointer> path, int keyIndex, K keyToInsert) throws IOException {\n    final OBonsaiBucketPointer bucketPointer = path.get(path.size() - 1);\n    OCacheEntry bucketEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n    OCachePointer pointer = bucketEntry.getCachePointer();\n\n    pointer.acquireExclusiveLock();\n    try {\n      OSBTreeBonsaiBucket<K, V> bucketToSplit = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(),\n          bucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n\n      final boolean splitLeaf = bucketToSplit.isLeaf();\n      final int bucketSize = bucketToSplit.size();\n\n      int indexToSplit = bucketSize >>> 1;\n      final K separationKey = bucketToSplit.getKey(indexToSplit);\n      final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> rightEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n          indexToSplit);\n\n      final int startRightIndex = splitLeaf ? indexToSplit : indexToSplit + 1;\n\n      for (int i = startRightIndex; i < bucketSize; i++)\n        rightEntries.add(bucketToSplit.getEntry(i));\n\n      if (!bucketPointer.equals(rootBucketPointer)) {\n        // TODO\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        final OBonsaiBucketPointer rightBucketPointer = new OBonsaiBucketPointer(rightBucketEntry.getPageIndex(), 8192 * 2);\n\n        OCachePointer rightPointer = rightBucketEntry.getCachePointer();\n\n        rightPointer.acquireExclusiveLock();\n\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightPointer.getDataPointer(),\n              rightBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          bucketToSplit.shrink(indexToSplit);\n\n          if (splitLeaf) {\n            OBonsaiBucketPointer rightSiblingBucketPointer = bucketToSplit.getRightSibling();\n\n            newRightBucket.setRightSibling(rightSiblingBucketPointer);\n            newRightBucket.setLeftSibling(bucketPointer);\n\n            bucketToSplit.setRightSibling(rightBucketPointer);\n\n            if (rightSiblingBucketPointer.isValid()) {\n              final OCacheEntry rightSiblingBucketEntry = diskCache.load(fileId, rightSiblingBucketPointer.getPageIndex(), false);\n              final OCachePointer rightSiblingPointer = rightSiblingBucketEntry.getCachePointer();\n\n              rightSiblingPointer.acquireExclusiveLock();\n              OSBTreeBonsaiBucket<K, V> rightSiblingBucket = new OSBTreeBonsaiBucket<K, V>(rightSiblingPointer.getDataPointer(),\n                  rightSiblingBucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n              try {\n                rightSiblingBucket.setLeftSibling(rightBucketPointer);\n                logPageChanges(rightSiblingBucket, fileId, rightSiblingBucketPointer.getPageIndex(), false);\n\n                rightSiblingBucketEntry.markDirty();\n              } finally {\n                rightSiblingPointer.releaseExclusiveLock();\n                diskCache.release(rightSiblingBucketEntry);\n              }\n            }\n          }\n\n          OBonsaiBucketPointer parentBucketPointer = path.get(path.size() - 2);\n          OCacheEntry parentCacheEntry = diskCache.load(fileId, parentBucketPointer.getPageIndex(), false);\n          OCachePointer parentPointer = parentCacheEntry.getCachePointer();\n\n          parentPointer.acquireExclusiveLock();\n          try {\n            OSBTreeBonsaiBucket<K, V> parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(),\n                parentBucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n            OSBTreeBonsaiBucket.SBTreeEntry<K, V> parentEntry = new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(bucketPointer,\n                rightBucketPointer, separationKey, null);\n\n            int insertionIndex = parentBucket.find(separationKey);\n            assert insertionIndex < 0;\n\n            insertionIndex = -insertionIndex - 1;\n            while (!parentBucket.addEntry(insertionIndex, parentEntry, true)) {\n              parentPointer.releaseExclusiveLock();\n              diskCache.release(parentCacheEntry);\n\n              BucketSearchResult bucketSearchResult = splitBucket(path.subList(0, path.size() - 1), insertionIndex, separationKey);\n\n              parentBucketPointer = bucketSearchResult.getLastPathItem();\n              parentCacheEntry = diskCache.load(fileId, parentBucketPointer.getPageIndex(), false);\n              parentPointer = parentCacheEntry.getCachePointer();\n\n              parentPointer.acquireExclusiveLock();\n\n              insertionIndex = bucketSearchResult.itemIndex;\n\n              parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(), parentBucketPointer.getPageOffset(),\n                  keySerializer, valueSerializer, getTrackMode());\n            }\n\n            logPageChanges(parentBucket, fileId, parentBucketPointer.getPageIndex(), false);\n          } finally {\n            parentCacheEntry.markDirty();\n            parentPointer.releaseExclusiveLock();\n\n            diskCache.release(parentCacheEntry);\n          }\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n        } finally {\n          rightBucketEntry.markDirty();\n          rightPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        logPageChanges(bucketToSplit, fileId, bucketPointer.getPageIndex(), false);\n        ArrayList<OBonsaiBucketPointer> resultPath = new ArrayList<OBonsaiBucketPointer>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(bucketPointer);\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketPointer);\n        if (splitLeaf) {\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n        }\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n\n      } else {\n        long treeSize = bucketToSplit.getTreeSize();\n\n        final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> leftEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n            indexToSplit);\n\n        for (int i = 0; i < indexToSplit; i++)\n          leftEntries.add(bucketToSplit.getEntry(i));\n\n        // TODO\n        OCacheEntry leftBucketEntry = diskCache.allocateNewPage(fileId);\n        OBonsaiBucketPointer leftBucketPointer = new OBonsaiBucketPointer(leftBucketEntry.getPageIndex(), 8192 * 2);\n        OCachePointer leftPointer = leftBucketEntry.getCachePointer();\n\n        // TODO\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        OBonsaiBucketPointer rightBucketPointer = new OBonsaiBucketPointer(rightBucketEntry.getPageIndex(), 8192 * 2);\n        leftPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newLeftBucket = new OSBTreeBonsaiBucket<K, V>(leftPointer.getDataPointer(),\n              leftBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newLeftBucket.addAll(leftEntries);\n\n          if (splitLeaf)\n            newLeftBucket.setRightSibling(rightBucketPointer);\n\n          logPageChanges(newLeftBucket, fileId, leftBucketEntry.getPageIndex(), true);\n          leftBucketEntry.markDirty();\n        } finally {\n          leftPointer.releaseExclusiveLock();\n          diskCache.release(leftBucketEntry);\n        }\n\n        OCachePointer rightPointer = rightBucketEntry.getCachePointer();\n        rightPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightPointer.getDataPointer(),\n              rightBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          if (splitLeaf)\n            newRightBucket.setLeftSibling(leftBucketPointer);\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n          rightBucketEntry.markDirty();\n        } finally {\n          rightPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        bucketToSplit = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), bucketPointer.getPageOffset(), false,\n            keySerializer, valueSerializer, getTrackMode());\n        bucketToSplit.setTreeSize(treeSize);\n\n        bucketToSplit.addEntry(0, new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(leftBucketPointer, rightBucketPointer, separationKey,\n            null), true);\n\n        logPageChanges(bucketToSplit, fileId, bucketPointer.getPageIndex(), false);\n        ArrayList<OBonsaiBucketPointer> resultPath = new ArrayList<OBonsaiBucketPointer>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(leftBucketPointer);\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketPointer);\n\n        if (splitLeaf)\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n      }\n\n    } finally {\n      bucketEntry.markDirty();\n      pointer.releaseExclusiveLock();\n      diskCache.release(bucketEntry);\n    }\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void create(String name, long rootIndex, OBinarySerializer<K> keySerializer, OBinarySerializer<V> valueSerializer,\n      OStorageLocalAbstract storageLocal) {\n    acquireExclusiveLock();\n    try {\n      this.storage = storageLocal;\n\n      this.diskCache = storage.getDiskCache();\n\n      this.name = name;\n      this.keySerializer = keySerializer;\n      this.valueSerializer = valueSerializer;\n\n      fileId = diskCache.openFile(name + dataFileExtension);\n\n      initDurableComponent(storageLocal);\n\n      OCacheEntry rootCacheEntry;\n      if (rootIndex < 0)\n        rootCacheEntry = diskCache.allocateNewPage(fileId);\n      else\n        rootCacheEntry = diskCache.load(fileId, rootIndex, false);\n\n      rootBucketPointer = new OBonsaiBucketPointer(rootCacheEntry.getPageIndex());\n\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n\n      rootPointer.acquireExclusiveLock();\n      try {\n        super.startDurableOperation(null);\n\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(),\n            rootBucketPointer.getPageOffset(), true, keySerializer, valueSerializer, getTrackMode());\n        rootBucket.setKeySerializerId(keySerializer.getId());\n        rootBucket.setValueSerializerId(valueSerializer.getId());\n        rootBucket.setTreeSize(0);\n\n        super.logPageChanges(rootBucket, fileId, rootBucketPointer.getPageIndex(), true);\n        rootCacheEntry.markDirty();\n      } finally {\n        rootPointer.releaseExclusiveLock();\n        diskCache.release(rootCacheEntry);\n      }\n\n      super.endDurableOperation(null, false);\n    } catch (IOException e) {\n      try {\n        super.endDurableOperation(null, true);\n      } catch (IOException e1) {\n        OLogManager.instance().error(this, \"Error during sbtree data rollback\", e1);\n      }\n      throw new OSBTreeException(\"Error creation of sbtree with name\" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","id":31361,"modified_method":"public void create(String name, long rootIndex, OBinarySerializer<K> keySerializer, OBinarySerializer<V> valueSerializer,\n      OStorageLocalAbstract storageLocal) {\n    acquireExclusiveLock();\n    try {\n      this.storage = storageLocal;\n\n      this.diskCache = storage.getDiskCache();\n\n      this.name = name;\n      this.keySerializer = keySerializer;\n      this.valueSerializer = valueSerializer;\n\n      fileId = diskCache.openFile(name + dataFileExtension);\n\n      initDurableComponent(storageLocal);\n\n      OCacheEntry rootCacheEntry;\n      if (rootIndex < 0)\n        rootCacheEntry = diskCache.allocateNewPage(fileId);\n      else\n        rootCacheEntry = diskCache.load(fileId, rootIndex, false);\n\n      // TODO\n      rootBucketPointer = new OBonsaiBucketPointer(rootCacheEntry.getPageIndex(), 8192 * 2);\n\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n\n      rootPointer.acquireExclusiveLock();\n      try {\n        super.startDurableOperation(null);\n\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(),\n            rootBucketPointer.getPageOffset(), true, keySerializer, valueSerializer, getTrackMode());\n        rootBucket.setKeySerializerId(keySerializer.getId());\n        rootBucket.setValueSerializerId(valueSerializer.getId());\n        rootBucket.setTreeSize(0);\n\n        super.logPageChanges(rootBucket, fileId, rootBucketPointer.getPageIndex(), true);\n        rootCacheEntry.markDirty();\n      } finally {\n        rootPointer.releaseExclusiveLock();\n        diskCache.release(rootCacheEntry);\n      }\n\n      super.endDurableOperation(null, false);\n    } catch (IOException e) {\n      try {\n        super.endDurableOperation(null, true);\n      } catch (IOException e1) {\n        OLogManager.instance().error(this, \"Error during sbtree data rollback\", e1);\n      }\n      throw new OSBTreeException(\"Error creation of sbtree with name\" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OBonsaiBucketPointer getLeftSibling() {\n    // TODO\n    return new OBonsaiBucketPointer(getLongValue(offset + LEFT_SIBLING_OFFSET));\n  }","id":31362,"modified_method":"public OBonsaiBucketPointer getLeftSibling() {\n    return getBucketPointer(offset + LEFT_SIBLING_OFFSET);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean addEntry(int index, SBTreeEntry<K, V> treeEntry, boolean updateNeighbors) throws IOException {\n    final int keySize = keySerializer.getObjectSize(treeEntry.key);\n    int valueSize = 0;\n    int entrySize = keySize;\n\n    if (isLeaf) {\n      if (valueSerializer.isFixedLength())\n        valueSize = valueSerializer.getFixedLength();\n      else\n        valueSize = valueSerializer.getObjectSize(treeEntry.value);\n\n      entrySize += valueSize;\n\n      checkEntreeSize(entrySize);\n    } else\n      entrySize += 2 * OLongSerializer.LONG_SIZE;\n\n    int size = size();\n    int freePointer = getIntValue(offset + FREE_POINTER_OFFSET);\n    if (freePointer - entrySize < (size + 1) * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET)\n      return false;\n\n    if (index <= size - 1) {\n      copyData(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, offset + POSITIONS_ARRAY_OFFSET + (index + 1)\n          * OIntegerSerializer.INT_SIZE, (size - index) * OIntegerSerializer.INT_SIZE);\n    }\n\n    freePointer -= entrySize;\n\n    setIntValue(offset + FREE_POINTER_OFFSET, freePointer);\n    setIntValue(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, freePointer);\n    setIntValue(offset + SIZE_OFFSET, size + 1);\n\n    if (isLeaf) {\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n\n      setBinaryValue(offset + freePointer, serializedKey);\n      freePointer += keySize;\n\n      byte[] serializedValue = new byte[valueSize];\n      valueSerializer.serializeNative(treeEntry.value, serializedValue, 0);\n      setBinaryValue(offset + freePointer, serializedValue);\n\n    } else {\n      // TODO\n      setLongValue(offset + freePointer, treeEntry.leftChild.getPageIndex());\n      freePointer += OLongSerializer.LONG_SIZE;\n\n      // TODO\n      setLongValue(offset + freePointer, treeEntry.rightChild.getPageIndex());\n      freePointer += OLongSerializer.LONG_SIZE;\n\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n      setBinaryValue(offset + freePointer, serializedKey);\n\n      size++;\n\n      if (updateNeighbors && size > 1) {\n        if (index < size - 1) {\n          final int nextEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index + 1) * OIntegerSerializer.INT_SIZE);\n          // TODO\n          setLongValue(offset + nextEntryPosition, treeEntry.rightChild.getPageIndex());\n        }\n\n        if (index > 0) {\n          final int prevEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index - 1) * OIntegerSerializer.INT_SIZE);\n          // TODO\n          setLongValue(offset + prevEntryPosition + OLongSerializer.LONG_SIZE, treeEntry.leftChild.getPageIndex());\n        }\n      }\n    }\n\n    return true;\n  }","id":31363,"modified_method":"public boolean addEntry(int index, SBTreeEntry<K, V> treeEntry, boolean updateNeighbors) throws IOException {\n    final int keySize = keySerializer.getObjectSize(treeEntry.key);\n    int valueSize = 0;\n    int entrySize = keySize;\n\n    if (isLeaf) {\n      if (valueSerializer.isFixedLength())\n        valueSize = valueSerializer.getFixedLength();\n      else\n        valueSize = valueSerializer.getObjectSize(treeEntry.value);\n\n      entrySize += valueSize;\n\n      checkEntreeSize(entrySize);\n    } else\n      entrySize += 2 * (OLongSerializer.LONG_SIZE + OIntegerSerializer.INT_SIZE);\n\n    int size = size();\n    int freePointer = getIntValue(offset + FREE_POINTER_OFFSET);\n    if (freePointer - entrySize < (size + 1) * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET)\n      return false;\n\n    if (index <= size - 1) {\n      copyData(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, offset + POSITIONS_ARRAY_OFFSET + (index + 1)\n          * OIntegerSerializer.INT_SIZE, (size - index) * OIntegerSerializer.INT_SIZE);\n    }\n\n    freePointer -= entrySize;\n\n    setIntValue(offset + FREE_POINTER_OFFSET, freePointer);\n    setIntValue(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, freePointer);\n    setIntValue(offset + SIZE_OFFSET, size + 1);\n\n    if (isLeaf) {\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n\n      setBinaryValue(offset + freePointer, serializedKey);\n      freePointer += keySize;\n\n      byte[] serializedValue = new byte[valueSize];\n      valueSerializer.serializeNative(treeEntry.value, serializedValue, 0);\n      setBinaryValue(offset + freePointer, serializedValue);\n\n    } else {\n      setBucketPointer(offset + freePointer, treeEntry.leftChild);\n      freePointer += OLongSerializer.LONG_SIZE + OIntegerSerializer.INT_SIZE;\n\n      setBucketPointer(offset + freePointer, treeEntry.rightChild);\n      freePointer += OLongSerializer.LONG_SIZE + OIntegerSerializer.INT_SIZE;\n\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n      setBinaryValue(offset + freePointer, serializedKey);\n\n      size++;\n\n      if (updateNeighbors && size > 1) {\n        if (index < size - 1) {\n          final int nextEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index + 1) * OIntegerSerializer.INT_SIZE);\n          setBucketPointer(offset + nextEntryPosition, treeEntry.rightChild);\n        }\n\n        if (index > 0) {\n          final int prevEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index - 1) * OIntegerSerializer.INT_SIZE);\n          setBucketPointer(offset + prevEntryPosition + OLongSerializer.LONG_SIZE + OIntegerSerializer.INT_SIZE,\n              treeEntry.leftChild);\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void setLeftSibling(OBonsaiBucketPointer pointer) throws IOException {\n    // TODO\n    setLongValue(offset + LEFT_SIBLING_OFFSET, pointer.getPageIndex());\n  }","id":31364,"modified_method":"public void setLeftSibling(OBonsaiBucketPointer pointer) throws IOException {\n    setBucketPointer(offset + LEFT_SIBLING_OFFSET, pointer);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OBonsaiBucketPointer getRightSibling() {\n    // TODO\n    return new OBonsaiBucketPointer(getLongValue(offset + RIGHT_SIBLING_OFFSET));\n  }","id":31365,"modified_method":"public OBonsaiBucketPointer getRightSibling() {\n    return getBucketPointer(offset + RIGHT_SIBLING_OFFSET);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public SBTreeEntry<K, V> getEntry(int entryIndex) {\n    int entryPosition = getIntValue(offset + entryIndex * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    if (isLeaf) {\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n      entryPosition += keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      V value = valueSerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(OBonsaiBucketPointer.NULL, OBonsaiBucketPointer.NULL, key, value);\n    } else {\n      // TODO\n      OBonsaiBucketPointer leftChild = new OBonsaiBucketPointer(getLongValue(offset + entryPosition));\n      entryPosition += OLongSerializer.LONG_SIZE;\n\n      // TODO\n      OBonsaiBucketPointer rightChild = new OBonsaiBucketPointer(getLongValue(offset + entryPosition));\n      entryPosition += OLongSerializer.LONG_SIZE;\n\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(leftChild, rightChild, key, null);\n    }\n  }","id":31366,"modified_method":"public SBTreeEntry<K, V> getEntry(int entryIndex) {\n    int entryPosition = getIntValue(offset + entryIndex * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    if (isLeaf) {\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n      entryPosition += keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      V value = valueSerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(OBonsaiBucketPointer.NULL, OBonsaiBucketPointer.NULL, key, value);\n    } else {\n      OBonsaiBucketPointer leftChild = getBucketPointer(offset + entryPosition);\n      entryPosition += OLongSerializer.LONG_SIZE + OIntegerSerializer.INT_SIZE;\n\n      OBonsaiBucketPointer rightChild = getBucketPointer(offset + entryPosition);\n      entryPosition += OLongSerializer.LONG_SIZE + OIntegerSerializer.INT_SIZE;\n\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(leftChild, rightChild, key, null);\n    }\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public K getKey(int index) {\n    int entryPosition = getIntValue(offset + index * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    if (!isLeaf)\n      entryPosition += 2 * OLongSerializer.LONG_SIZE;\n\n    return keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n  }","id":31367,"modified_method":"public K getKey(int index) {\n    int entryPosition = getIntValue(offset + index * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    if (!isLeaf)\n      entryPosition += 2 * (OLongSerializer.LONG_SIZE + OIntegerSerializer.INT_SIZE);\n\n    return keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void setRightSibling(OBonsaiBucketPointer pointer) throws IOException {\n    // TODO\n    setLongValue(offset + RIGHT_SIBLING_OFFSET, pointer.getPageIndex());\n  }","id":31368,"modified_method":"public void setRightSibling(OBonsaiBucketPointer pointer) throws IOException {\n    setBucketPointer(offset + RIGHT_SIBLING_OFFSET, pointer);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSetLeftSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    final OBonsaiBucketPointer p = new OBonsaiBucketPointer(123);\n    treeBucket.setLeftSibling(p);\n    Assert.assertEquals(treeBucket.getLeftSibling(), p);\n\n    directMemory.free(pointer);\n  }","id":31369,"modified_method":"public void testSetLeftSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    final OBonsaiBucketPointer p = new OBonsaiBucketPointer(123, 8192 * 2);\n    treeBucket.setLeftSibling(p);\n    Assert.assertEquals(treeBucket.getLeftSibling(), p);\n\n    directMemory.free(pointer);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSetRightSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    final OBonsaiBucketPointer p = new OBonsaiBucketPointer(123);\n    treeBucket.setRightSibling(p);\n    Assert.assertEquals(treeBucket.getRightSibling(), p);\n\n    directMemory.free(pointer);\n  }","id":31370,"modified_method":"public void testSetRightSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    final OBonsaiBucketPointer p = new OBonsaiBucketPointer(123, 8192 * 2);\n    treeBucket.setRightSibling(p);\n    Assert.assertEquals(treeBucket.getRightSibling(), p);\n\n    directMemory.free(pointer);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testShrink() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testShrink seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(index),\n          new OBonsaiBucketPointer(index + 1), key, null), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    treeBucket.shrink(treeBucket.size() / 2);\n    Assert.assertEquals(treeBucket.size(), index / 2);\n\n    index = 0;\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n\n    Iterator<Long> keysIterator = keys.iterator();\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(keyIndexEntry.getValue()),\n              new OBonsaiBucketPointer(keyIndexEntry.getValue() + 1), keyIndexEntry.getKey(), null));\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(index),\n          new OBonsaiBucketPointer(index + 1), key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(keyIndexEntry.getValue()),\n              new OBonsaiBucketPointer(keyIndexEntry.getValue() + 1), keyIndexEntry.getKey(), null));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","id":31371,"modified_method":"public void testShrink() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testShrink seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(index,\n          8192 * 2), new OBonsaiBucketPointer(index + 1, 8192 * 2), key, null), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    treeBucket.shrink(treeBucket.size() / 2);\n    Assert.assertEquals(treeBucket.size(), index / 2);\n\n    index = 0;\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n\n    Iterator<Long> keysIterator = keys.iterator();\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(keyIndexEntry.getValue(), 8192 * 2),\n              new OBonsaiBucketPointer(keyIndexEntry.getValue() + 1, 8192 * 2), keyIndexEntry.getKey(), null));\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(index,\n          8192 * 2), new OBonsaiBucketPointer(index + 1, 8192 * 2), key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(keyIndexEntry.getValue(), 8192 * 2),\n              new OBonsaiBucketPointer(keyIndexEntry.getValue() + 1, 8192 * 2), keyIndexEntry.getKey(), null));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSearch() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testSearch seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(random.nextInt(Integer.MAX_VALUE)),\n              new OBonsaiBucketPointer(random.nextInt(Integer.MAX_VALUE)), key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(treeBucket.size(), keyIndexMap.size());\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    OBonsaiBucketPointer prevRight = OBonsaiBucketPointer.NULL;\n    for (int i = 0; i < treeBucket.size(); i++) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevRight.getPageIndex() > 0)\n        Assert.assertEquals(entry.leftChild, prevRight);\n\n      prevRight = entry.rightChild;\n    }\n\n    OBonsaiBucketPointer prevLeft = OBonsaiBucketPointer.NULL;\n    for (int i = treeBucket.size() - 1; i >= 0; i--) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevLeft.getPageIndex() > 0)\n        Assert.assertEquals(entry.rightChild, prevLeft);\n\n      prevLeft = entry.leftChild;\n    }\n\n    directMemory.free(pointer);\n  }","id":31372,"modified_method":"public void testSearch() throws Exception {\n    long seed = 1381299802658L;// System.currentTimeMillis();\n    System.out.println(\"testSearch seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(random.nextInt(Integer.MAX_VALUE),\n              8192 * 2), new OBonsaiBucketPointer(random.nextInt(Integer.MAX_VALUE), 8192 * 2), key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(treeBucket.size(), keyIndexMap.size());\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    OBonsaiBucketPointer prevRight = OBonsaiBucketPointer.NULL;\n    for (int i = 0; i < treeBucket.size(); i++) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevRight.getPageIndex() > 0)\n        Assert.assertEquals(entry.leftChild, prevRight);\n\n      prevRight = entry.rightChild;\n    }\n\n    OBonsaiBucketPointer prevLeft = OBonsaiBucketPointer.NULL;\n    for (int i = treeBucket.size() - 1; i >= 0; i--) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevLeft.getPageIndex() > 0)\n        Assert.assertEquals(entry.rightChild, prevLeft);\n\n      prevLeft = entry.leftChild;\n    }\n\n    directMemory.free(pointer);\n  }","commit_id":"9bbbbcd81784544c36a1919dca8be396d25bf21a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unused\") // called through reflection by RequestServer\n  public Schema fetch(int version, JobsV3 s) {\n    Key key = s.job_id.key();\n    Value val = DKV.get(key);\n    if( null == val ) throw new IllegalArgumentException(\"Job is missing\");\n    Iced ice = val.get();\n    if( !(ice instanceof Job) ) throw new IllegalArgumentException(\"Must be a Job not a \"+ice.getClass());\n\n    Jobs jobs = new Jobs();\n    jobs._jobs = new Job[1];\n    jobs._jobs[0] = (Job) ice;\n    s.jobs = new JobV3[0]; // Give PojoUtils.copyProperties the destination type.\n    s.fillFromImpl(jobs);\n    return s;\n  }","id":31373,"modified_method":"@SuppressWarnings(\"unused\") // called through reflection by RequestServer\n  public Schema fetch(int version, JobsV3 s) {\n    Key key = s.job_id.key();\n    Value val = DKV.get(key);\n    if( null == val ) throw new IllegalArgumentException(\"Job is missing\");\n    Iced ice = val.get();\n    if( !(ice instanceof Job) ) throw new IllegalArgumentException(\"Must be a Job not a \"+ice.getClass());\n\n    Job j = (Job) ice;\n    Jobs jobs = new Jobs();\n    jobs._jobs = new Job[1];\n    jobs._jobs[0] = (Job) ice;\n    s.jobs = new JobV3[1];\n    // s.fillFromImpl(jobs);\n\n    if (j instanceof ModelBuilder) {\n      // special case: need to add a ModelBuilderJobV3 next.\n      s.jobs[0] = new JobV3().fillFromImpl(j);  // TODO: new ModelBuilderJob\n    } else {\n      try {\n        s.jobs[0] = (JobV3) Schema.schema(version, j).fillFromImpl(j);\n      }\n      catch (H2ONotFoundArgumentException e) {\n        // no special schema for this job subclass, so fall back to JobV3\n        s.jobs[0] = new JobV3().fillFromImpl(j);\n      }\n    }\n\n    return s;\n  }","commit_id":"f0b0b28cf86e99046c7d9b67b6dbbb59d3d5cd0f","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@SuppressWarnings(\"unused\") // called through reflection by RequestServer\n  public Schema list(int version, JobsV3 s) {\n    Jobs j = new Jobs();\n    j._jobs = Job.jobs();\n    PojoUtils.copyProperties(s, j, PojoUtils.FieldNaming.ORIGIN_HAS_UNDERSCORES);\n    return s;\n  }","id":31374,"modified_method":"@SuppressWarnings(\"unused\") // called through reflection by RequestServer\n  public Schema list(int version, JobsV3 s) {\n    Job[] jobs = Job.jobs();\n    // Jobs j = new Jobs();\n    // j._jobs = Job.jobs();\n    // PojoUtils.copyProperties(s, j, PojoUtils.FieldNaming.ORIGIN_HAS_UNDERSCORES);\n    s.jobs = new JobV3[jobs.length];\n\n    int i = 0;\n    for (Job j : jobs) {\n      if (j instanceof ModelBuilder) {\n        // special case: need to add a ModelBuilderJobV3 next.\n        s.jobs[i] = new JobV3().fillFromImpl(j);  // TODO: new ModelBuilderJob\n      } else {\n        try {\n          s.jobs[i] = (JobV3) Schema.schema(version, j).fillFromImpl(j);\n        }\n        catch (H2ONotFoundArgumentException e) {\n          // no special schema for this job subclass, so fall back to JobV3\n          s.jobs[i] = new JobV3().fillFromImpl(j);\n        }\n      }\n      i++; // Java does the increment before the function call which throws?!\n    }\n    return s;\n  }","commit_id":"f0b0b28cf86e99046c7d9b67b6dbbb59d3d5cd0f","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Copy properties \"of the same name\" from one POJO to the other.  If the fields are\n   * named consistently (both sides have fields named \"_foo\" and/or \"bar\") this acts like\n   * Apache Commons PojoUtils.copyProperties(). If one side has leading underscores and\n   * the other does not then the names are conformed according to the field_naming\n   * parameter.\n   *\n   * @param dest Destination POJO\n   * @param origin Origin POJO\n   * @param field_naming Are the fields named consistently, or does one side have underscores?\n   * @param skip_fields Array of origin or destination field names to skip\n   * @param only_fields Array of origin or destination field names to include; ones not in this list will be skipped\n   */\n  public static void copyProperties(Object dest, Object origin, FieldNaming field_naming, String[] skip_fields, String[] only_fields) {\n    if (null == dest || null == origin) return;\n\n    Field[] dest_fields = Weaver.getWovenFields(dest  .getClass());\n    Field[] orig_fields = Weaver.getWovenFields(origin.getClass());\n\n    for (Field orig_field : orig_fields) {\n      String origin_name = orig_field.getName();\n\n      if (skip_fields != null & ArrayUtils.contains(skip_fields, origin_name))\n        continue;\n\n      if (only_fields != null & !ArrayUtils.contains(only_fields, origin_name))\n        continue;\n\n      String dest_name = null;\n      if (field_naming == FieldNaming.CONSISTENT) {\n        dest_name = origin_name;\n      } else if (field_naming == FieldNaming.DEST_HAS_UNDERSCORES) {\n        dest_name = \"_\" + origin_name;\n      } else if (field_naming == FieldNaming.ORIGIN_HAS_UNDERSCORES) {\n        dest_name = origin_name.substring(1);\n      }\n\n      if ( skip_fields != null & ArrayUtils.contains(skip_fields, dest_name) )\n        continue;\n\n      if (only_fields != null & !ArrayUtils.contains(only_fields, dest_name))\n        continue;\n\n      try {\n        Field dest_field = null;\n        for( Field fd : dest_fields ) {\n          if (fd.getName().equals(dest_name)) {\n            dest_field = fd;\n            break;\n          }\n        }\n\n        if( dest_field != null ) {\n          dest_field.setAccessible(true);\n          orig_field.setAccessible(true);\n          // Log.info(\"PojoUtils.copyProperties, origin field: \" + orig_field + \"; destination field: \" + dest_field);\n          if (null == orig_field.get(origin)) {\n            //\n            // Assigning null to dest.\n            //\n            dest_field.set(dest, null);\n          } else if (dest_field.getType().isArray() && orig_field.getType().isArray() && (dest_field.getType().getComponentType() != orig_field.getType().getComponentType())) {\n            //\n            // Assigning an array to another array.\n            //\n            // You can't use reflection to set an int[] with an Integer[].  Argh.\n            // TODO: other types of arrays. . .\n            if (dest_field.getType().getComponentType() == double.class && orig_field.getType().getComponentType() == Double.class) {\n              //\n              // Assigning an Double[] to an double[]\n              //\n              double[] copy = (double[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (dest_field.getType().getComponentType() == Double.class && orig_field.getType().getComponentType() == double.class) {\n              //\n              // Assigning an double[] to an Double[]\n              //\n              Double[] copy = (Double[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (dest_field.getType().getComponentType() == int.class && orig_field.getType().getComponentType() == Integer.class) {\n              //\n              // Assigning an Integer[] to an int[]\n              //\n              int[] copy = (int[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (dest_field.getType().getComponentType() == Integer.class && orig_field.getType().getComponentType() == int.class) {\n              //\n              // Assigning an int[] to an Integer[]\n              //\n              Integer[] copy = (Integer[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (Schema.class.isAssignableFrom(dest_field.getType().getComponentType()) && (Schema.getImplClass((Class<?extends Schema>)dest_field.getType().getComponentType())).isAssignableFrom(orig_field.getType().getComponentType())) {\n              //\n              // Assigning an array of impl fields to an array of schema fields, e.g. a DeepLearningParameters[] into a DeepLearningParametersV2[]\n              //\n              Class dest_component_class = dest_field.getType().getComponentType();\n              Schema[] translation = (Schema[]) Array.newInstance(dest_component_class, Array.getLength(orig_field.get(origin)));\n              int i = 0;\n              for (Iced impl : ((Iced[])orig_field.get(origin))) {\n                translation[i++] = ((Schema)dest_field.getType().getComponentType().newInstance()).fillFromImpl(impl);\n                // ## TODO Add handling for subclasses ##\n              }\n              dest_field.set(dest, translation);\n            } else if (Schema.class.isAssignableFrom(orig_field.getType().getComponentType()) && Iced.class.isAssignableFrom(dest_field.getType().getComponentType())) {\n              //\n              // Assigning an array of schema fields to an array of impl fields, e.g. a DeepLearningParametersV2[] into a DeepLearningParameters[]\n              //\n              // We can't check against the actual impl class I, because we can't instantiate the schema base classes to get the impl class from an instance:\n              // dest_field.getType().getComponentType().isAssignableFrom(((Schema)f.getType().getComponentType().newInstance()).getImplClass())) {\n              Class dest_component_class = dest_field.getType().getComponentType();\n              Iced[] translation = (Iced[]) Array.newInstance(dest_component_class, Array.getLength(orig_field.get(origin)));\n              int i = 0;\n              for (Schema s : ((Schema[])orig_field.get(origin))) {\n                translation[i++] = s.createImpl();\n              }\n              dest_field.set(dest, translation);\n            } else {\n              throw H2O.fail(\"Don't know how to cast an array of: \" + orig_field.getType().getComponentType() + \" to an array of: \" + dest_field.getType().getComponentType());\n            }\n            // end of array handling\n          } else if (dest_field.getType() == Key.class && Keyed.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a Keyed (e.g., a Frame or Model) to a Key.\n            //\n            dest_field.set(dest, ((Keyed) orig_field.get(origin))._key);\n          } else if (orig_field.getType() == Key.class && Keyed.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a Key (for e.g., a Frame or Model) to a Keyed (e.g., a Frame or Model).\n            //\n            Value v = DKV.get((Key) orig_field.get(origin));\n            dest_field.set(dest, (null == v ? null : v.get()));\n          } else if (KeyV3.class.isAssignableFrom(dest_field.getType()) && Keyed.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a Keyed (e.g., a Frame or Model) to a KeyV1.\n            //\n            dest_field.set(dest, KeyV3.make(((Class<? extends KeyV3>) dest_field.getType()), ((Keyed) orig_field.get(origin))._key));\n          } else if (KeyV3.class.isAssignableFrom(orig_field.getType()) && Keyed.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a KeyV1 (for e.g., a Frame or Model) to a Keyed (e.g., a Frame or Model).\n            //\n            KeyV3 k = (KeyV3)orig_field.get(origin);\n            Value v = DKV.get(Key.make(k.name));\n            dest_field.set(dest, (null == v ? null : v.get()));\n          } else if (KeyV3.class.isAssignableFrom(dest_field.getType()) && Key.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a Key to a KeyV1.\n            //\n            dest_field.set(dest, KeyV3.make(((Class<? extends KeyV3>) dest_field.getType()), (Key) orig_field.get(origin)));\n          } else if (KeyV3.class.isAssignableFrom(orig_field.getType()) && Key.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a KeyV1 to a Key.\n            //\n            KeyV3 k = (KeyV3)orig_field.get(origin);\n            dest_field.set(dest, (null == k.name ? null : Key.make(k.name)));\n          } else if (dest_field.getType() == Pattern.class && String.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a String to a Pattern.\n            //\n            dest_field.set(dest, Pattern.compile((String) orig_field.get(origin)));\n          } else if (orig_field.getType() == Pattern.class && String.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // We are assigning a Pattern to a String.\n            //\n            dest_field.set(dest, orig_field.get(origin).toString());\n          } else if (dest_field.getType() == FrameV3.ColSpecifierV3.class && String.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a String to a ColSpecifier.  Note that we currently support only the colname, not a frame name too.\n            //\n            dest_field.set(dest, new FrameV3.ColSpecifierV3((String) orig_field.get(origin)));\n          } else if (orig_field.getType() == FrameV3.ColSpecifierV3.class && String.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // We are assigning a ColSpecifierV2 to a String.  The column_name gets copied.\n            //\n            dest_field.set(dest, ((FrameV3.ColSpecifierV3)orig_field.get(origin)).column_name);\n          } else if (Enum.class.isAssignableFrom(dest_field.getType()) && String.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a String into an enum field.\n            //\n            Class<Enum> dest_class = (Class<Enum>)dest_field.getType();\n            dest_field.set(dest, Enum.valueOf(dest_class, (String) orig_field.get(origin)));\n          } else if (Enum.class.isAssignableFrom(orig_field.getType()) && String.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning an enum field into a String.\n            //\n            Object o = orig_field.get(origin);\n            dest_field.set(dest, (o == null ? null : o.toString()));\n          } else if (Schema.class.isAssignableFrom(dest_field.getType()) && Schema.getImplClass((Class<? extends Schema>) dest_field.getType()).isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning an impl field into a schema field, e.g. a DeepLearningParameters into a DeepLearningParametersV2.\n            //\n            dest_field.set(dest, Schema.schema(/* ((Schema)dest).getSchemaVersion() TODO: remove HACK!! */ 3, (Class<? extends Iced>)orig_field.get(origin).getClass()).fillFromImpl((Iced) orig_field.get(origin)));\n          } else if (Schema.class.isAssignableFrom(orig_field.getType()) && Schema.getImplClass((Class<? extends Schema>)orig_field.getType()).isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a schema field into an impl field, e.g. a DeepLearningParametersV2 into a DeepLearningParameters.\n            //\n            Schema s = ((Schema)orig_field.get(origin));\n            dest_field.set(dest, s.fillImpl(s.createImpl()));\n          } else if ((Schema.class.isAssignableFrom(dest_field.getType()) && Key.class.isAssignableFrom(orig_field.getType()))) {\n            //\n            // Assigning an impl field fetched via a Key into a schema field, e.g. a DeepLearningParameters into a DeepLearningParametersV2.\n            // Note that unlike the cases above we don't know the type of the impl class until we fetch in the body of the if.\n            //\n            Key origin_key = (Key) orig_field.get(origin);\n            Value v = DKV.get(origin_key);\n            if (null == v || null == v.get()) {\n              dest_field.set(dest, null);\n            } else {\n              if (((Schema)dest_field.get(dest)).getImplClass().isAssignableFrom(v.get().getClass())) {\n                Schema s = ((Schema)dest_field.get(dest));\n                dest_field.set(dest, Schema.schema(s.getSchemaVersion(), s.getImplClass()).fillFromImpl(v.get()));\n              } else {\n                Log.err(\"Can't fill Schema of type: \" + dest_field.getType() + \" with value of type: \" + v.getClass() + \" fetched from Key: \" + origin_key);\n                dest_field.set(dest, null);\n              }\n            }\n          } else if (Schema.class.isAssignableFrom(orig_field.getType()) && Keyed.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a schema field into a Key field, e.g. a DeepLearningV2 into a (DeepLearningParameters) key.\n            //\n            Schema s = ((Schema)orig_field.get(origin));\n            dest_field.set(dest, ((Keyed)s.fillImpl(s.createImpl()))._key);\n          } else {\n            //\n            // Normal case: not doing any type conversion.\n            //\n            dest_field.set(dest, orig_field.get(origin));\n          }\n        }\n      }\n      catch (IllegalAccessException e) {\n        Log.err(\"Illegal access exception trying to copy field: \" + origin_name + \" of class: \" + origin.getClass() + \" to field: \" + dest_name + \" of class: \" + dest.getClass());\n      }\n      catch (InstantiationException e) {\n        Log.err(\"Instantiation exception trying to copy field: \" + origin_name + \" of class: \" + origin.getClass() + \" to field: \" + dest_name + \" of class: \" + dest.getClass());\n      }\n    }\n  }","id":31375,"modified_method":"/**\n   * Copy properties \"of the same name\" from one POJO to the other.  If the fields are\n   * named consistently (both sides have fields named \"_foo\" and/or \"bar\") this acts like\n   * Apache Commons PojoUtils.copyProperties(). If one side has leading underscores and\n   * the other does not then the names are conformed according to the field_naming\n   * parameter.\n   *\n   * @param dest Destination POJO\n   * @param origin Origin POJO\n   * @param field_naming Are the fields named consistently, or does one side have underscores?\n   * @param skip_fields Array of origin or destination field names to skip\n   * @param only_fields Array of origin or destination field names to include; ones not in this list will be skipped\n   */\n  public static void copyProperties(Object dest, Object origin, FieldNaming field_naming, String[] skip_fields, String[] only_fields) {\n    if (null == dest || null == origin) return;\n\n    Field[] dest_fields = Weaver.getWovenFields(dest  .getClass());\n    Field[] orig_fields = Weaver.getWovenFields(origin.getClass());\n\n    for (Field orig_field : orig_fields) {\n      String origin_name = orig_field.getName();\n\n      if (skip_fields != null & ArrayUtils.contains(skip_fields, origin_name))\n        continue;\n\n      if (only_fields != null & !ArrayUtils.contains(only_fields, origin_name))\n        continue;\n\n      String dest_name = null;\n      if (field_naming == FieldNaming.CONSISTENT) {\n        dest_name = origin_name;\n      } else if (field_naming == FieldNaming.DEST_HAS_UNDERSCORES) {\n        dest_name = \"_\" + origin_name;\n      } else if (field_naming == FieldNaming.ORIGIN_HAS_UNDERSCORES) {\n        dest_name = origin_name.substring(1);\n      }\n\n      if ( skip_fields != null & ArrayUtils.contains(skip_fields, dest_name) )\n        continue;\n\n      if (only_fields != null & !ArrayUtils.contains(only_fields, dest_name))\n        continue;\n\n      try {\n        Field dest_field = null;\n        for( Field fd : dest_fields ) {\n          if (fd.getName().equals(dest_name)) {\n            dest_field = fd;\n            break;\n          }\n        }\n\n        if( dest_field != null ) {\n          dest_field.setAccessible(true);\n          orig_field.setAccessible(true);\n          // Log.info(\"PojoUtils.copyProperties, origin field: \" + orig_field + \"; destination field: \" + dest_field);\n          if (null == orig_field.get(origin)) {\n            //\n            // Assigning null to dest.\n            //\n            dest_field.set(dest, null);\n          } else if (dest_field.getType().isArray() && orig_field.getType().isArray() && (dest_field.getType().getComponentType() != orig_field.getType().getComponentType())) {\n            //\n            // Assigning an array to another array.\n            //\n            // You can't use reflection to set an int[] with an Integer[].  Argh.\n            // TODO: other types of arrays. . .\n            if (dest_field.getType().getComponentType() == double.class && orig_field.getType().getComponentType() == Double.class) {\n              //\n              // Assigning an Double[] to an double[]\n              //\n              double[] copy = (double[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (dest_field.getType().getComponentType() == Double.class && orig_field.getType().getComponentType() == double.class) {\n              //\n              // Assigning an double[] to an Double[]\n              //\n              Double[] copy = (Double[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (dest_field.getType().getComponentType() == int.class && orig_field.getType().getComponentType() == Integer.class) {\n              //\n              // Assigning an Integer[] to an int[]\n              //\n              int[] copy = (int[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (dest_field.getType().getComponentType() == Integer.class && orig_field.getType().getComponentType() == int.class) {\n              //\n              // Assigning an int[] to an Integer[]\n              //\n              Integer[] copy = (Integer[]) orig_field.get(origin);\n              dest_field.set(dest, copy);\n            } else if (Schema.class.isAssignableFrom(dest_field.getType().getComponentType()) && (Schema.getImplClass((Class<?extends Schema>)dest_field.getType().getComponentType())).isAssignableFrom(orig_field.getType().getComponentType())) {\n              //\n              // Assigning an array of impl fields to an array of schema fields, e.g. a DeepLearningParameters[] into a DeepLearningParametersV2[]\n              //\n              Class dest_component_class = dest_field.getType().getComponentType();\n              Schema[] translation = (Schema[]) Array.newInstance(dest_component_class, Array.getLength(orig_field.get(origin)));\n              int i = 0;\n              int version = ((Schema)dest).getSchemaVersion();\n\n              // Look up the schema for each element of the array; if not found fall back to the schema for the base class.\n              for (Iced impl : ((Iced[])orig_field.get(origin))) {\n                Schema s = null;\n                try {\n                  s = Schema.schema(version, impl);\n                }\n                catch (H2ONotFoundArgumentException e) {\n                  s = ((Schema)dest_field.getType().getComponentType().newInstance());\n                }\n                translation[i++] = s.fillFromImpl(impl);\n              }\n              dest_field.set(dest, translation);\n            } else if (Schema.class.isAssignableFrom(orig_field.getType().getComponentType()) && Iced.class.isAssignableFrom(dest_field.getType().getComponentType())) {\n              //\n              // Assigning an array of schema fields to an array of impl fields, e.g. a DeepLearningParametersV2[] into a DeepLearningParameters[]\n              //\n              // We can't check against the actual impl class I, because we can't instantiate the schema base classes to get the impl class from an instance:\n              // dest_field.getType().getComponentType().isAssignableFrom(((Schema)f.getType().getComponentType().newInstance()).getImplClass())) {\n              Class dest_component_class = dest_field.getType().getComponentType();\n              Iced[] translation = (Iced[]) Array.newInstance(dest_component_class, Array.getLength(orig_field.get(origin)));\n              int i = 0;\n              for (Schema s : ((Schema[])orig_field.get(origin))) {\n                translation[i++] = s.createImpl();\n              }\n              dest_field.set(dest, translation);\n            } else {\n              throw H2O.fail(\"Don't know how to cast an array of: \" + orig_field.getType().getComponentType() + \" to an array of: \" + dest_field.getType().getComponentType());\n            }\n            // end of array handling\n          } else if (dest_field.getType() == Key.class && Keyed.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a Keyed (e.g., a Frame or Model) to a Key.\n            //\n            dest_field.set(dest, ((Keyed) orig_field.get(origin))._key);\n          } else if (orig_field.getType() == Key.class && Keyed.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a Key (for e.g., a Frame or Model) to a Keyed (e.g., a Frame or Model).\n            //\n            Value v = DKV.get((Key) orig_field.get(origin));\n            dest_field.set(dest, (null == v ? null : v.get()));\n          } else if (KeyV3.class.isAssignableFrom(dest_field.getType()) && Keyed.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a Keyed (e.g., a Frame or Model) to a KeyV1.\n            //\n            dest_field.set(dest, KeyV3.make(((Class<? extends KeyV3>) dest_field.getType()), ((Keyed) orig_field.get(origin))._key));\n          } else if (KeyV3.class.isAssignableFrom(orig_field.getType()) && Keyed.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a KeyV1 (for e.g., a Frame or Model) to a Keyed (e.g., a Frame or Model).\n            //\n            KeyV3 k = (KeyV3)orig_field.get(origin);\n            Value v = DKV.get(Key.make(k.name));\n            dest_field.set(dest, (null == v ? null : v.get()));\n          } else if (KeyV3.class.isAssignableFrom(dest_field.getType()) && Key.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a Key to a KeyV1.\n            //\n            dest_field.set(dest, KeyV3.make(((Class<? extends KeyV3>) dest_field.getType()), (Key) orig_field.get(origin)));\n          } else if (KeyV3.class.isAssignableFrom(orig_field.getType()) && Key.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a KeyV1 to a Key.\n            //\n            KeyV3 k = (KeyV3)orig_field.get(origin);\n            dest_field.set(dest, (null == k.name ? null : Key.make(k.name)));\n          } else if (dest_field.getType() == Pattern.class && String.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a String to a Pattern.\n            //\n            dest_field.set(dest, Pattern.compile((String) orig_field.get(origin)));\n          } else if (orig_field.getType() == Pattern.class && String.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // We are assigning a Pattern to a String.\n            //\n            dest_field.set(dest, orig_field.get(origin).toString());\n          } else if (dest_field.getType() == FrameV3.ColSpecifierV3.class && String.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a String to a ColSpecifier.  Note that we currently support only the colname, not a frame name too.\n            //\n            dest_field.set(dest, new FrameV3.ColSpecifierV3((String) orig_field.get(origin)));\n          } else if (orig_field.getType() == FrameV3.ColSpecifierV3.class && String.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // We are assigning a ColSpecifierV2 to a String.  The column_name gets copied.\n            //\n            dest_field.set(dest, ((FrameV3.ColSpecifierV3)orig_field.get(origin)).column_name);\n          } else if (Enum.class.isAssignableFrom(dest_field.getType()) && String.class.isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning a String into an enum field.\n            //\n            Class<Enum> dest_class = (Class<Enum>)dest_field.getType();\n            dest_field.set(dest, Enum.valueOf(dest_class, (String) orig_field.get(origin)));\n          } else if (Enum.class.isAssignableFrom(orig_field.getType()) && String.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning an enum field into a String.\n            //\n            Object o = orig_field.get(origin);\n            dest_field.set(dest, (o == null ? null : o.toString()));\n          } else if (Schema.class.isAssignableFrom(dest_field.getType()) && Schema.getImplClass((Class<? extends Schema>) dest_field.getType()).isAssignableFrom(orig_field.getType())) {\n            //\n            // Assigning an impl field into a schema field, e.g. a DeepLearningParameters into a DeepLearningParametersV2.\n            //\n            dest_field.set(dest, Schema.schema(/* ((Schema)dest).getSchemaVersion() TODO: remove HACK!! */ 3, (Class<? extends Iced>)orig_field.get(origin).getClass()).fillFromImpl((Iced) orig_field.get(origin)));\n          } else if (Schema.class.isAssignableFrom(orig_field.getType()) && Schema.getImplClass((Class<? extends Schema>)orig_field.getType()).isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a schema field into an impl field, e.g. a DeepLearningParametersV2 into a DeepLearningParameters.\n            //\n            Schema s = ((Schema)orig_field.get(origin));\n            dest_field.set(dest, s.fillImpl(s.createImpl()));\n          } else if ((Schema.class.isAssignableFrom(dest_field.getType()) && Key.class.isAssignableFrom(orig_field.getType()))) {\n            //\n            // Assigning an impl field fetched via a Key into a schema field, e.g. a DeepLearningParameters into a DeepLearningParametersV2.\n            // Note that unlike the cases above we don't know the type of the impl class until we fetch in the body of the if.\n            //\n            Key origin_key = (Key) orig_field.get(origin);\n            Value v = DKV.get(origin_key);\n            if (null == v || null == v.get()) {\n              dest_field.set(dest, null);\n            } else {\n              if (((Schema)dest_field.get(dest)).getImplClass().isAssignableFrom(v.get().getClass())) {\n                Schema s = ((Schema)dest_field.get(dest));\n                dest_field.set(dest, Schema.schema(s.getSchemaVersion(), s.getImplClass()).fillFromImpl(v.get()));\n              } else {\n                Log.err(\"Can't fill Schema of type: \" + dest_field.getType() + \" with value of type: \" + v.getClass() + \" fetched from Key: \" + origin_key);\n                dest_field.set(dest, null);\n              }\n            }\n          } else if (Schema.class.isAssignableFrom(orig_field.getType()) && Keyed.class.isAssignableFrom(dest_field.getType())) {\n            //\n            // Assigning a schema field into a Key field, e.g. a DeepLearningV2 into a (DeepLearningParameters) key.\n            //\n            Schema s = ((Schema)orig_field.get(origin));\n            dest_field.set(dest, ((Keyed)s.fillImpl(s.createImpl()))._key);\n          } else {\n            //\n            // Normal case: not doing any type conversion.\n            //\n            dest_field.set(dest, orig_field.get(origin));\n          }\n        }\n      }\n      catch (IllegalAccessException e) {\n        Log.err(\"Illegal access exception trying to copy field: \" + origin_name + \" of class: \" + origin.getClass() + \" to field: \" + dest_name + \" of class: \" + dest.getClass());\n      }\n      catch (InstantiationException e) {\n        Log.err(\"Instantiation exception trying to copy field: \" + origin_name + \" of class: \" + origin.getClass() + \" to field: \" + dest_name + \" of class: \" + dest.getClass());\n      }\n    }\n  }","commit_id":"f0b0b28cf86e99046c7d9b67b6dbbb59d3d5cd0f","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void bg(CommandSession session, String[] argv) {\n        final String[] usage = {\n                \"bg - put job in background\",\n                \"Usage: bg [OPTIONS] [jobid]\",\n                \"  -? --help                show help\",\n        };\n        Process process = Process.current();\n        Options opt = Options.compile(usage).parse(argv);\n        if (opt.isSet(\"help\")) {\n            opt.usage(process.err());\n            return;\n        }\n        if (opt.args().size() > 1) {\n            process.err().println(\"usage: bg [jobid]\");\n            process.error(2);\n            return;\n        }\n        List<Job> jobs = session.jobs();\n        Collections.reverse(jobs);\n        Job current = Job.current();\n        if (argv.length == 0) {\n            Job job = jobs.stream().filter(j -> j != current)\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.background();\n            } else {\n                process.err().println(\"bg: no current job\");\n                process.error(1);\n            }\n        } else {\n            Job job = jobs.stream().filter(j -> j != current && argv[0].equals(Integer.toString(j.id())))\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.background();\n            } else {\n                process.err().println(\"bg: job not found: \" + argv[0]);\n                process.error(1);\n            }\n        }\n    }","id":31376,"modified_method":"public void bg(CommandSession session, String[] argv) {\n        final String[] usage = {\n                \"bg - put job in background\",\n                \"Usage: bg [OPTIONS] [jobid]\",\n                \"  -? --help                show help\",\n        };\n        Process process = Process.current();\n        Options opt = Options.compile(usage).parse(argv);\n        if (opt.isSet(\"help\")) {\n            opt.usage(process.err());\n            return;\n        }\n        if (opt.args().size() > 1) {\n            process.err().println(\"usage: bg [jobid]\");\n            process.error(2);\n            return;\n        }\n        List<Job> jobs = new ArrayList<>(session.jobs());\n        Collections.reverse(jobs);\n        Job current = Job.current();\n        if (argv.length == 0) {\n            Job job = jobs.stream().filter(j -> j != current)\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.background();\n            } else {\n                process.err().println(\"bg: no current job\");\n                process.error(1);\n            }\n        } else {\n            Job job = jobs.stream().filter(j -> j != current && argv[0].equals(Integer.toString(j.id())))\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.background();\n            } else {\n                process.err().println(\"bg: job not found: \" + argv[0]);\n                process.error(1);\n            }\n        }\n    }","commit_id":"9693945301804d1efe1da63b5e13ec512633f0b1","url":"https://github.com/apache/felix"},{"original_method":"public void fg(CommandSession session, String[] argv) {\n        final String[] usage = {\n                \"fg - put job in foreground\",\n                \"Usage: fg [OPTIONS] [jobid]\",\n                \"  -? --help                show help\",\n        };\n        Process process = Process.current();\n        Options opt = Options.compile(usage).parse(argv);\n        if (opt.isSet(\"help\")) {\n            opt.usage(process.err());\n            return;\n        }\n        if (opt.args().size() > 1) {\n            process.err().println(\"usage: fg [jobid]\");\n            process.error(2);\n            return;\n        }\n        List<Job> jobs = session.jobs();\n        Collections.reverse(jobs);\n        Job current = Job.current();\n        if (argv.length == 0) {\n            Job job = jobs.stream().filter(j -> j != current)\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.foreground();\n            } else {\n                process.err().println(\"fg: no current job\");\n                process.error(1);\n            }\n        } else {\n            Job job = jobs.stream().filter(j -> j != current && argv[0].equals(Integer.toString(j.id())))\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.foreground();\n            } else {\n                process.err().println(\"fg: job not found: \" + argv[0]);\n                process.error(1);\n            }\n        }\n    }","id":31377,"modified_method":"public void fg(CommandSession session, String[] argv) {\n        final String[] usage = {\n                \"fg - put job in foreground\",\n                \"Usage: fg [OPTIONS] [jobid]\",\n                \"  -? --help                show help\",\n        };\n        Process process = Process.current();\n        Options opt = Options.compile(usage).parse(argv);\n        if (opt.isSet(\"help\")) {\n            opt.usage(process.err());\n            return;\n        }\n        if (opt.args().size() > 1) {\n            process.err().println(\"usage: fg [jobid]\");\n            process.error(2);\n            return;\n        }\n        List<Job> jobs = new ArrayList<>(session.jobs());\n        Collections.reverse(jobs);\n        Job current = Job.current();\n        if (argv.length == 0) {\n            Job job = jobs.stream().filter(j -> j != current)\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.foreground();\n            } else {\n                process.err().println(\"fg: no current job\");\n                process.error(1);\n            }\n        } else {\n            Job job = jobs.stream().filter(j -> j != current && argv[0].equals(Integer.toString(j.id())))\n                    .findFirst().orElse(null);\n            if (job != null) {\n                job.foreground();\n            } else {\n                process.err().println(\"fg: job not found: \" + argv[0]);\n                process.error(1);\n            }\n        }\n    }","commit_id":"9693945301804d1efe1da63b5e13ec512633f0b1","url":"https://github.com/apache/felix"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      ToolbarPopupMenu moreMenu = new ToolbarPopupMenu();\n      moreMenu.addItem(commands_.vcsRevert().createMenuItem(false));\n      moreMenu.addItem(commands_.vcsIgnore().createMenuItem(false));\n      moreMenu.addSeparator();\n      moreMenu.addItem(commands_.vcsPull().createMenuItem(false));\n      moreMenu.addItem(commands_.vcsPush().createMenuItem(false));\n      moreMenu.addSeparator();\n      moreMenu.addItem(commands_.showShellDialog().createMenuItem(false));\n\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.vcsDiff().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsCommit().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsShowHistory().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(new ToolbarButton(\n            \"More\",\n            StandardIcons.INSTANCE.more_actions(),\n            moreMenu));\n\n      toolbar.addRightWidget(branchToolbarButton_);\n      \n      toolbar.addRightWidget(new ToolbarButton(\n            commands_.vcsRefresh().getImageResource(),\n            new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  table_.showProgress();\n                  commands_.vcsRefresh().execute();\n               }\n            }));\n      return toolbar;\n   }","id":31378,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      ToolbarPopupMenu moreMenu = new ToolbarPopupMenu();\n      moreMenu.addItem(commands_.vcsRevert().createMenuItem(false));\n      moreMenu.addItem(commands_.vcsIgnore().createMenuItem(false));\n      moreMenu.addSeparator();\n      moreMenu.addItem(commands_.showShellDialog().createMenuItem(false));\n\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.vcsDiff().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsCommit().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(pullButton_ = commands_.vcsPull().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(pushButton_ = commands_.vcsPush().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(historyButton_ = commands_.vcsShowHistory().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(moreButton_ = new ToolbarButton(\n            \"More\",\n            StandardIcons.INSTANCE.more_actions(),\n            moreMenu));\n\n      toolbar.addRightWidget(branchToolbarButton_);\n      \n      toolbar.addRightWidget(new ToolbarButton(\n            commands_.vcsRefresh().getImageResource(),\n            new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  table_.showProgress();\n                  commands_.vcsRefresh().execute();\n               }\n            }));\n      \n      return toolbar;\n   }","commit_id":"fd0d55ec9867a2c53b679f82d2f5ccebb69393bb","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void installStandardUI()\n   {\n      // plot history navigation\n      addLeftWidget(commands_.previousPlot().createToolbarButton());\n      addLeftWidget(commands_.nextPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // popout current plot\n      addLeftWidget(commands_.zoomPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // export commands\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.savePlotAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.savePlotAsPdf().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.copyPlotToClipboard().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.publishPlotToRPubs().createMenuItem(false));\n      ToolbarButton exportButton = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      addLeftWidget(exportButton);\n      addLeftSeparator();\n      \n      addLeftWidget(commands_.removePlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // clear all plots\n      addLeftWidget(commands_.clearPlots().createToolbarButton());\n      \n      // refresh\n      addLeftSeparator();\n      addLeftWidget(commands_.refreshPlot().createToolbarButton());\n   }","id":31379,"modified_method":"private void installStandardUI()\n   {\n      // plot history navigation\n      addLeftWidget(commands_.previousPlot().createToolbarButton());\n      addLeftWidget(commands_.nextPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // popout current plot\n      addLeftWidget(commands_.zoomPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // export commands\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.savePlotAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.savePlotAsPdf().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.copyPlotToClipboard().createMenuItem(false));\n      ToolbarButton exportButton = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      addLeftWidget(exportButton);\n      addLeftSeparator();\n      \n      addLeftWidget(commands_.removePlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // clear all plots\n      addLeftWidget(commands_.clearPlots().createToolbarButton());\n      \n      // refresh\n      addLeftSeparator();\n      addLeftWidget(commands_.refreshPlot().createToolbarButton());\n      \n      // publish\n      addRightWidget( commands_.publishPlotToRPubs().createToolbarButton());\n   }","commit_id":"e78910ecec46df473ac7428a1813805478776060","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void navigate(String url)\n   {\n      navigate(url, false);\n      publishButton_.setVisible(false);\n      rmdPreviewParams_ = null;\n   }","id":31380,"modified_method":"@Override\n   public void navigate(String url)\n   {\n      navigate(url, false);\n      publishButton_.setVisible(false);\n      rpubsPublishButton_.setVisible(commands_.viewerPublishToRPubs().isVisible());\n      rmdPreviewParams_ = null;\n   }","commit_id":"e78910ecec46df473ac7428a1813805478776060","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void previewRmd(RmdPreviewParams params)\n   {\n      navigate(params.getOutputUrl(), true);\n      publishButton_.setVisible(!params.isShinyDocument());\n      if (!params.isShinyDocument())\n         publishButton_.setText(params.getResult().getRpubsPublished() ? \n               \"Republish\" : \"Publish\");\n      rmdPreviewParams_ = params;\n      toolbar_.invalidateSeparators();\n   }","id":31381,"modified_method":"@Override\n   public void previewRmd(RmdPreviewParams params)\n   {\n      navigate(params.getOutputUrl(), true);\n      rpubsPublishButton_.setVisible(false);\n      publishButton_.setVisible(!params.isShinyDocument());\n      if (!params.isShinyDocument())\n         publishButton_.setText(params.getResult().getRpubsPublished() ? \n               \"Republish\" : \"Publish\");\n      rmdPreviewParams_ = params;\n      toolbar_.invalidateSeparators();\n   }","commit_id":"e78910ecec46df473ac7428a1813805478776060","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      toolbar_ = new Toolbar();\n      \n      // add html widget buttons\n      toolbar_.addLeftWidget(commands_.viewerBack().createToolbarButton());\n      toolbar_.addLeftWidget(commands_.viewerForward().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerZoom().createToolbarButton());\n      \n      // export commands\n      exportButtonSeparator_ = toolbar_.addLeftSeparator();\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.viewerSaveAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.viewerCopyToClipboard().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.viewerSaveAsWebPage().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.viewerPublishToRPubs().createMenuItem(false));\n      \n      exportButton_ = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      toolbar_.addLeftWidget(exportButton_);  \n      exportButton_.setVisible(false);\n      exportButtonSeparator_.setVisible(false);\n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClear().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClearAll().createToolbarButton());\n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerRefresh().createToolbarButton());\n     \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerPopout().createToolbarButton());\n     \n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerStop().createToolbarButton());\n     \n      // add publish button \n      publishButton_ = commands_.publishHTML().createToolbarButton(false);\n      toolbar_.addRightWidget(publishButton_);\n      publishButton_.setVisible(false);\n      \n      return toolbar_;\n   }","id":31382,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      toolbar_ = new Toolbar();\n      \n      // add html widget buttons\n      toolbar_.addLeftWidget(commands_.viewerBack().createToolbarButton());\n      toolbar_.addLeftWidget(commands_.viewerForward().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerZoom().createToolbarButton());\n      \n      // export commands\n      exportButtonSeparator_ = toolbar_.addLeftSeparator();\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.viewerSaveAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.viewerCopyToClipboard().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.viewerSaveAsWebPage().createMenuItem(false));\n      \n      exportButton_ = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      toolbar_.addLeftWidget(exportButton_);  \n      exportButton_.setVisible(false);\n      exportButtonSeparator_.setVisible(false);\n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClear().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClearAll().createToolbarButton());\n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerRefresh().createToolbarButton());\n     \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerPopout().createToolbarButton());\n     \n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerStop().createToolbarButton());\n     \n      // add html document publish button \n      publishButton_ = commands_.publishHTML().createToolbarButton(false);\n      toolbar_.addRightWidget(publishButton_);\n      publishButton_.setVisible(false);\n      \n      // add rpubs publish button\n      rpubsPublishButton_ = toolbar_.addRightWidget(\n                commands_.viewerPublishToRPubs().createToolbarButton(false));\n      \n      return toolbar_;\n   }","commit_id":"e78910ecec46df473ac7428a1813805478776060","url":"https://github.com/rstudio/rstudio"},{"original_method":"private Toolbar createToolbar(TextFileType fileType)\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n       \n      toolbar.addLeftSeparator();\n      if (SourceWindowManager.isMainSourceWindow())\n         toolbar.addLeftWidget(commands_.popoutDoc().createToolbarButton());\n      toolbar.addLeftWidget(commands_.returnDocToMain().createToolbarButton());\n      toolbar.addLeftSeparator();\n\n      toolbar.addLeftWidget(commands_.saveSourceDoc().createToolbarButton());\n      sourceOnSave_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(sourceOnSave_);\n      srcOnSaveLabel_.getElement().getStyle().setMarginRight(9, Unit.PX);\n      toolbar.addLeftWidget(srcOnSaveLabel_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.checkSpelling().createToolbarButton());\n      \n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n      toolbar.addLeftWidget(createCodeTransformMenuButton());\n      \n      notebookSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(notebookToolbarButton_ = \n            commands_.compileNotebook().createToolbarButton());\n      \n      int mod = BrowseCap.hasMetaKey() ? KeyboardShortcut.META : \n         KeyboardShortcut.CTRL;\n      String cmdText = \n        new KeyboardShortcut(mod + KeyboardShortcut.SHIFT, 'K').toString(true);\n      cmdText = DomUtils.htmlToText(cmdText);\n      notebookToolbarButton_.setTitle(\"Compile Notebook (\" + cmdText + \")\");\n      \n      texSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(texToolbarButton_ = createLatexFormatButton());\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(previewHTMLButton_ = commands_.previewHTML().createToolbarButton());\n      knitDocumentButton_ = commands_.knitDocument().createToolbarButton(false);\n      knitDocumentButton_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(knitDocumentButton_);\n      toolbar.addLeftWidget(compilePdfButton_ = commands_.compilePDF().createToolbarButton());\n      rmdFormatButton_ = new ToolbarPopupMenuButton(false, true);\n      toolbar.addLeftWidget(rmdFormatButton_);\n      \n      ToolbarPopupMenu rmdOptionsMenu = new ToolbarPopupMenu();\n      rmdOptionsMenu.addItem(commands_.editRmdFormatOptions().createMenuItem(false));\n      \n      rmdOptionsButton_ = new ToolbarButton(\n            null,  \n            StandardIcons.INSTANCE.options(),\n            rmdOptionsMenu, \n            false);\n      \n      toolbar.addLeftWidget(rmdOptionsButton_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.synctexSearch().createToolbarButton());\n\n      toolbar.addRightWidget(runButton_ = commands_.executeCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(runLastButton_ = commands_.executeLastCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      final String SOURCE_BUTTON_TITLE = \"Source the active document\"; \n      \n      sourceButton_ = new ToolbarButton(\n            \"Source\", \n            commands_.sourceActiveDocument().getImageResource(), \n            new ClickHandler() \n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (uiPrefs_.sourceWithEcho().getValue())\n                     commands_.sourceActiveDocumentWithEcho().execute();\n                  else\n                     commands_.sourceActiveDocument().execute();\n               }\n            });\n      \n      sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n      toolbar.addRightWidget(sourceButton_);\n      \n      uiPrefs_.sourceWithEcho().addValueChangeHandler(\n                                       new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            if (event.getValue())\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE + \" (with echo)\");\n            else\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n         }\n      });\n            \n      ToolbarPopupMenu sourceMenu = new ToolbarPopupMenu();\n      sourceMenu.addItem(commands_.sourceActiveDocument().createMenuItem(false));\n      sourceMenu.addItem(commands_.sourceActiveDocumentWithEcho().createMenuItem(false));\n         \n      sourceMenuButton_ = new ToolbarButton(sourceMenu, true);\n      toolbar.addRightWidget(sourceMenuButton_);  \n\n      //toolbar.addRightSeparator();\n     \n      ToolbarPopupMenu chunksMenu = new ToolbarPopupMenu();\n      chunksMenu.addItem(commands_.insertChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.jumpTo().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeSetupChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executePreviousChunks().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeCurrentChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeNextChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeAllCode().createMenuItem(false));\n      chunksButton_ = new ToolbarButton(\n                       \"Chunks\",  \n                       StandardIcons.INSTANCE.chunk_menu(), \n                       chunksMenu, \n                       true);\n      toolbar.addRightWidget(chunksButton_);\n      \n      ToolbarPopupMenu shinyLaunchMenu = shinyViewerMenu_;\n      shinyLaunchButton_ = new ToolbarButton(\n                       shinyLaunchMenu, \n                       true);\n      shinyLaunchButton_.setVisible(false);\n      toolbar.addRightWidget(shinyLaunchButton_);\n      if (SessionUtils.showPublishUi(session_, uiPrefs_))\n      {\n         toolbar.addRightSeparator();\n         publishButton_ = new RSConnectPublishButton(\n               RSConnect.CONTENT_TYPE_APP, false, null);\n         toolbar.addRightWidget(publishButton_);\n      }\n      \n      toggleDocOutlineButton_ = new LatchingToolbarButton(\n         \"\",\n            StandardIcons.INSTANCE.outline(),\n            new ClickHandler()\n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  final double initialSize = editorPanel_.getWidgetSize(docOutlineWidget_);\n                  \n                  // Clicking the icon toggles the outline widget's visibility. The\n                  // 'destination' below is the width we would like to set -- we\n                  // animate to that position for a slightly nicer visual treatment.\n                  final double destination = docOutlineWidget_.getOffsetWidth() > 5\n                        ? 0\n                        : target_.getPreferredOutlineWidgetSize();\n                  \n                  // Update tooltip ('Show'/'Hide' depending on current visibility)\n                  String title = toggleDocOutlineButton_.getTitle();\n                  if (destination != 0)\n                     title = title.replace(\"Show \", \"Hide \");\n                  else\n                     title = title.replace(\"Hide \", \"Show \");\n                  toggleDocOutlineButton_.setTitle(title);\n                  \n                  toggleDocOutlineButton_.setLatched(destination != 0);\n                  \n                  new Animation()\n                  {\n                     @Override\n                     protected void onUpdate(double progress)\n                     {\n                        double size =\n                              destination * progress +\n                              initialSize * (1 - progress);\n                        editorPanel_.setWidgetSize(docOutlineWidget_, size);\n                        editor_.onResize();\n                     }\n                     \n                     @Override\n                     protected void onComplete()\n                     {\n                        target_.setPreferredOutlineWidgetVisibility(destination != 0);\n                     }\n                  }.run(500);\n               }\n            });\n      \n      // Time-out setting the latch just to ensure the document outline\n      // has actually been appropriately rendered.\n      new Timer()\n      {\n         @Override\n         public void run()\n         {\n            String title = commands_.toggleDocumentOutline().getTooltip();\n            title = editorPanel_.getWidgetSize(docOutlineWidget_) > 0\n                  ? title.replace(\"Show \", \"Hide \")\n                  : title.replace(\"Hide \", \"Show \");\n            toggleDocOutlineButton_.setTitle(title);\n            toggleDocOutlineButton_.setLatched(docOutlineWidget_.getOffsetWidth() > 0);\n         }\n      }.schedule(100);\n      \n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(toggleDocOutlineButton_);\n      \n      return toolbar;\n   }","id":31383,"modified_method":"private Toolbar createToolbar(TextFileType fileType)\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n       \n      toolbar.addLeftSeparator();\n      if (SourceWindowManager.isMainSourceWindow())\n         toolbar.addLeftWidget(commands_.popoutDoc().createToolbarButton());\n      toolbar.addLeftWidget(commands_.returnDocToMain().createToolbarButton());\n      toolbar.addLeftSeparator();\n\n      toolbar.addLeftWidget(commands_.saveSourceDoc().createToolbarButton());\n      sourceOnSave_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(sourceOnSave_);\n      srcOnSaveLabel_.getElement().getStyle().setMarginRight(9, Unit.PX);\n      toolbar.addLeftWidget(srcOnSaveLabel_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.checkSpelling().createToolbarButton());\n      \n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n      toolbar.addLeftWidget(createCodeTransformMenuButton());\n      \n      notebookSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(notebookToolbarButton_ = \n            commands_.compileNotebook().createToolbarButton());\n      \n      int mod = BrowseCap.hasMetaKey() ? KeyboardShortcut.META : \n         KeyboardShortcut.CTRL;\n      String cmdText = \n        new KeyboardShortcut(mod + KeyboardShortcut.SHIFT, 'K').toString(true);\n      cmdText = DomUtils.htmlToText(cmdText);\n      notebookToolbarButton_.setTitle(\"Compile Notebook (\" + cmdText + \")\");\n      \n      texSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(texToolbarButton_ = createLatexFormatButton());\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(previewHTMLButton_ = commands_.previewHTML().createToolbarButton());\n      knitDocumentButton_ = commands_.knitDocument().createToolbarButton(false);\n      knitDocumentButton_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(knitDocumentButton_);\n      toolbar.addLeftWidget(compilePdfButton_ = commands_.compilePDF().createToolbarButton());\n      rmdFormatButton_ = new ToolbarPopupMenuButton(false, true);\n      toolbar.addLeftWidget(rmdFormatButton_);\n      \n      ToolbarPopupMenu rmdOptionsMenu = new ToolbarPopupMenu();\n      rmdOptionsMenu.addItem(commands_.editRmdFormatOptions().createMenuItem(false));\n      \n      rmdOptionsButton_ = new ToolbarButton(\n            null,  \n            StandardIcons.INSTANCE.options(),\n            rmdOptionsMenu, \n            false);\n      \n      toolbar.addLeftWidget(rmdOptionsButton_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.synctexSearch().createToolbarButton());\n\n      toolbar.addRightWidget(insertChunkButton_ = commands_.insertChunk().createToolbarButton());\n      toolbar.addRightWidget(runButton_ = commands_.executeCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(runLastButton_ = commands_.executeLastCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      final String SOURCE_BUTTON_TITLE = \"Source the active document\"; \n      \n      sourceButton_ = new ToolbarButton(\n            \"Source\", \n            commands_.sourceActiveDocument().getImageResource(), \n            new ClickHandler() \n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (uiPrefs_.sourceWithEcho().getValue())\n                     commands_.sourceActiveDocumentWithEcho().execute();\n                  else\n                     commands_.sourceActiveDocument().execute();\n               }\n            });\n      \n      sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n      toolbar.addRightWidget(sourceButton_);\n      \n      uiPrefs_.sourceWithEcho().addValueChangeHandler(\n                                       new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            if (event.getValue())\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE + \" (with echo)\");\n            else\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n         }\n      });\n            \n      ToolbarPopupMenu sourceMenu = new ToolbarPopupMenu();\n      sourceMenu.addItem(commands_.sourceActiveDocument().createMenuItem(false));\n      sourceMenu.addItem(commands_.sourceActiveDocumentWithEcho().createMenuItem(false));\n         \n      sourceMenuButton_ = new ToolbarButton(sourceMenu, true);\n      toolbar.addRightWidget(sourceMenuButton_);  \n\n      //toolbar.addRightSeparator();\n     \n      ToolbarPopupMenu chunksMenu = new ToolbarPopupMenu();\n      chunksMenu.addItem(commands_.executeSetupChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executePreviousChunks().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeCurrentChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeNextChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeAllCode().createMenuItem(false));\n      chunksButton_ = new ToolbarButton(\n                       \"Run\",  \n                       commands_.executeCode().getImageResource(),\n                       chunksMenu, \n                       true);\n      toolbar.addRightWidget(chunksButton_);\n      \n      ToolbarPopupMenu shinyLaunchMenu = shinyViewerMenu_;\n      shinyLaunchButton_ = new ToolbarButton(\n                       shinyLaunchMenu, \n                       true);\n      shinyLaunchButton_.setVisible(false);\n      toolbar.addRightWidget(shinyLaunchButton_);\n      if (SessionUtils.showPublishUi(session_, uiPrefs_))\n      {\n         toolbar.addRightSeparator();\n         publishButton_ = new RSConnectPublishButton(\n               RSConnect.CONTENT_TYPE_APP, false, null);\n         toolbar.addRightWidget(publishButton_);\n      }\n      \n      toggleDocOutlineButton_ = new LatchingToolbarButton(\n         \"\",\n            StandardIcons.INSTANCE.outline(),\n            new ClickHandler()\n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  final double initialSize = editorPanel_.getWidgetSize(docOutlineWidget_);\n                  \n                  // Clicking the icon toggles the outline widget's visibility. The\n                  // 'destination' below is the width we would like to set -- we\n                  // animate to that position for a slightly nicer visual treatment.\n                  final double destination = docOutlineWidget_.getOffsetWidth() > 5\n                        ? 0\n                        : target_.getPreferredOutlineWidgetSize();\n                  \n                  // Update tooltip ('Show'/'Hide' depending on current visibility)\n                  String title = toggleDocOutlineButton_.getTitle();\n                  if (destination != 0)\n                     title = title.replace(\"Show \", \"Hide \");\n                  else\n                     title = title.replace(\"Hide \", \"Show \");\n                  toggleDocOutlineButton_.setTitle(title);\n                  \n                  toggleDocOutlineButton_.setLatched(destination != 0);\n                  \n                  new Animation()\n                  {\n                     @Override\n                     protected void onUpdate(double progress)\n                     {\n                        double size =\n                              destination * progress +\n                              initialSize * (1 - progress);\n                        editorPanel_.setWidgetSize(docOutlineWidget_, size);\n                        editor_.onResize();\n                     }\n                     \n                     @Override\n                     protected void onComplete()\n                     {\n                        target_.setPreferredOutlineWidgetVisibility(destination != 0);\n                     }\n                  }.run(500);\n               }\n            });\n      \n      // Time-out setting the latch just to ensure the document outline\n      // has actually been appropriately rendered.\n      new Timer()\n      {\n         @Override\n         public void run()\n         {\n            String title = commands_.toggleDocumentOutline().getTooltip();\n            title = editorPanel_.getWidgetSize(docOutlineWidget_) > 0\n                  ? title.replace(\"Show \", \"Hide \")\n                  : title.replace(\"Hide \", \"Show \");\n            toggleDocOutlineButton_.setTitle(title);\n            toggleDocOutlineButton_.setLatched(docOutlineWidget_.getOffsetWidth() > 0);\n         }\n      }.schedule(100);\n      \n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(toggleDocOutlineButton_);\n      \n      return toolbar;\n   }","commit_id":"e0dc8cf54944707d1b7a6b389a67cc44082ec6b8","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void adaptToFileType(TextFileType fileType)\n   {\n      editor_.setFileType(fileType);\n      boolean canCompilePdf = fileType.canCompilePDF();\n      boolean canKnitToHTML = fileType.canKnitToHTML();\n      boolean canCompileNotebook = fileType.canCompileNotebook();\n      boolean canSource = fileType.canSource();\n      boolean canSourceWithEcho = fileType.canSourceWithEcho();\n      boolean canSourceOnSave = fileType.canSourceOnSave();\n      boolean canExecuteCode = fileType.canExecuteCode();\n      boolean canExecuteChunks = fileType.canExecuteChunks();\n      boolean isPlainMarkdown = fileType.isPlainMarkdown();\n      boolean isCpp = fileType.isCpp();\n      boolean isScript = fileType.isScript();\n      boolean isRMarkdown2 = extendedType_.equals(\"rmarkdown\");\n      boolean canPreviewFromR = fileType.canPreviewFromR();\n      \n      // don't show the run buttons for cpp files, or R files in Shiny\n      runButton_.setVisible(canExecuteCode && !isCpp && !isShinyFile());\n      runLastButton_.setVisible(runButton_.isVisible() && !canExecuteChunks);\n      \n      sourceOnSave_.setVisible(canSourceOnSave);\n      srcOnSaveLabel_.setVisible(canSourceOnSave);\n      if (fileType.isRd() || canPreviewFromR)\n         srcOnSaveLabel_.setText(fileType.getPreviewButtonText() + \" on Save\");\n      else\n         srcOnSaveLabel_.setText(\"Source on Save\");\n      codeTransform_.setVisible(\n            (canExecuteCode && !fileType.canAuthorContent()) ||\n            fileType.isC() || fileType.isStan());   \n     \n      sourceButton_.setVisible(canSource && !isPlainMarkdown);\n      sourceMenuButton_.setVisible(canSourceWithEcho && \n                                   !isPlainMarkdown && \n                                   !isScript &&\n                                   !canPreviewFromR);\n   \n      texSeparatorWidget_.setVisible(canCompilePdf);\n      texToolbarButton_.setVisible(canCompilePdf);\n      compilePdfButton_.setVisible(canCompilePdf);\n      chunksButton_.setVisible(canExecuteChunks);\n      \n      notebookSeparatorWidget_.setVisible(canCompileNotebook);\n      notebookToolbarButton_.setVisible(canCompileNotebook);\n      \n      knitDocumentButton_.setVisible(canKnitToHTML);\n      \n      rmdFormatButton_.setVisible(isRMarkdown2);\n      rmdOptionsButton_.setVisible(isRMarkdown2);\n      rmdOptionsButton_.setEnabled(isRMarkdown2);\n     \n      if (isShinyFile())\n      {\n         sourceOnSave_.setVisible(false);\n         srcOnSaveLabel_.setVisible(false);\n         runButton_.setVisible(false);\n         sourceMenuButton_.setVisible(false);\n         chunksButton_.setVisible(false);\n         shinyLaunchButton_.setVisible(true);\n         setSourceButtonFromShinyState();\n      }\n      else\n      {\n         setSourceButtonFromScriptState(isScript, \n                                        canPreviewFromR,\n                                        fileType.getPreviewButtonText());\n      }\n      \n      // set the content type based on the extended type\n      setPublishPath(extendedType_, publishPath_);\n      \n      // make toggle outline visible if we have a scope tree\n      toggleDocOutlineButton_.setVisible(fileType.canShowScopeTree());\n      if (!fileType.canShowScopeTree())\n      {\n         editorPanel_.setWidgetSize(docOutlineWidget_, 0);\n         toggleDocOutlineButton_.setLatched(false);\n      }\n      \n      toolbar_.invalidateSeparators();\n   }","id":31384,"modified_method":"public void adaptToFileType(TextFileType fileType)\n   {\n      editor_.setFileType(fileType);\n      boolean canCompilePdf = fileType.canCompilePDF();\n      boolean canKnitToHTML = fileType.canKnitToHTML();\n      boolean canCompileNotebook = fileType.canCompileNotebook();\n      boolean canSource = fileType.canSource();\n      boolean canSourceWithEcho = fileType.canSourceWithEcho();\n      boolean canSourceOnSave = fileType.canSourceOnSave();\n      boolean canExecuteCode = fileType.canExecuteCode();\n      boolean canExecuteChunks = fileType.canExecuteChunks();\n      boolean isPlainMarkdown = fileType.isPlainMarkdown();\n      boolean isCpp = fileType.isCpp();\n      boolean isScript = fileType.isScript();\n      boolean isRMarkdown2 = extendedType_.equals(\"rmarkdown\");\n      boolean canPreviewFromR = fileType.canPreviewFromR();\n      \n      // don't show the run buttons for cpp files, or R files in Shiny\n      runButton_.setVisible(canExecuteCode && !canExecuteChunks && !isCpp && !isShinyFile());\n      runLastButton_.setVisible(runButton_.isVisible() && !canExecuteChunks);\n      \n      // show insert chunk button\n      insertChunkButton_.setVisible(canExecuteChunks);\n      \n      sourceOnSave_.setVisible(canSourceOnSave);\n      srcOnSaveLabel_.setVisible(canSourceOnSave);\n      if (fileType.isRd() || canPreviewFromR)\n         srcOnSaveLabel_.setText(fileType.getPreviewButtonText() + \" on Save\");\n      else\n         srcOnSaveLabel_.setText(\"Source on Save\");\n      codeTransform_.setVisible(\n            (canExecuteCode && !fileType.canAuthorContent()) ||\n            fileType.isC() || fileType.isStan());   \n     \n      sourceButton_.setVisible(canSource && !isPlainMarkdown);\n      sourceMenuButton_.setVisible(canSourceWithEcho && \n                                   !isPlainMarkdown && \n                                   !isScript &&\n                                   !canPreviewFromR);\n   \n      texSeparatorWidget_.setVisible(canCompilePdf);\n      texToolbarButton_.setVisible(canCompilePdf);\n      compilePdfButton_.setVisible(canCompilePdf);\n      chunksButton_.setVisible(canExecuteChunks);\n      \n      notebookSeparatorWidget_.setVisible(canCompileNotebook);\n      notebookToolbarButton_.setVisible(canCompileNotebook);\n      \n      knitDocumentButton_.setVisible(canKnitToHTML);\n      \n      rmdFormatButton_.setVisible(isRMarkdown2);\n      rmdOptionsButton_.setVisible(isRMarkdown2);\n      rmdOptionsButton_.setEnabled(isRMarkdown2);\n     \n      if (isShinyFile())\n      {\n         sourceOnSave_.setVisible(false);\n         srcOnSaveLabel_.setVisible(false);\n         runButton_.setVisible(false);\n         sourceMenuButton_.setVisible(false);\n         chunksButton_.setVisible(false);\n         shinyLaunchButton_.setVisible(true);\n         setSourceButtonFromShinyState();\n      }\n      else\n      {\n         setSourceButtonFromScriptState(isScript, \n                                        canPreviewFromR,\n                                        fileType.getPreviewButtonText());\n      }\n      \n      // set the content type based on the extended type\n      setPublishPath(extendedType_, publishPath_);\n      \n      // make toggle outline visible if we have a scope tree\n      toggleDocOutlineButton_.setVisible(fileType.canShowScopeTree());\n      if (!fileType.canShowScopeTree())\n      {\n         editorPanel_.setWidgetSize(docOutlineWidget_, 0);\n         toggleDocOutlineButton_.setLatched(false);\n      }\n      \n      toolbar_.invalidateSeparators();\n   }","commit_id":"e0dc8cf54944707d1b7a6b389a67cc44082ec6b8","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void manageToolbarSizes()\n   {\n      // sometimes width is passed in as 0 (not sure why)\n      int width = getOffsetWidth();\n      if (width == 0)\n         return;\n      \n      texToolbarButton_.setText(width < 520 ? \"\" : \"Format\");\n      runButton_.setText(((width < 480) || isShinyFile()) ? \"\" : \"Run\");\n      compilePdfButton_.setText(width < 450 ? \"\" : \"Compile PDF\");\n      previewHTMLButton_.setText(width < 450 ? \"\" : previewCommandText_);                                                       \n      knitDocumentButton_.setText(width < 450 ? \"\" : knitCommandText_);\n      \n      if (editor_.getFileType().isRd() || editor_.getFileType().canPreviewFromR())\n      {\n         String preview = editor_.getFileType().getPreviewButtonText();\n         srcOnSaveLabel_.setText(width < 450 ? preview : preview + \" on Save\");\n      }\n      else\n         srcOnSaveLabel_.setText(width < 450 ? \"Source\" : \"Source on Save\");\n      sourceButton_.setText(width < 400 ? \"\" : sourceCommandText_);\n      chunksButton_.setText(width < 400 ? \"\" : \"Chunks\");\n   }","id":31385,"modified_method":"private void manageToolbarSizes()\n   {\n      // sometimes width is passed in as 0 (not sure why)\n      int width = getOffsetWidth();\n      if (width == 0)\n         return;\n      \n      texToolbarButton_.setText(width < 520 ? \"\" : \"Format\");\n      runButton_.setText(((width < 480) || isShinyFile()) ? \"\" : \"Run\");\n      compilePdfButton_.setText(width < 450 ? \"\" : \"Compile PDF\");\n      previewHTMLButton_.setText(width < 450 ? \"\" : previewCommandText_);                                                       \n      knitDocumentButton_.setText(width < 450 ? \"\" : knitCommandText_);\n      \n      if (editor_.getFileType().isRd() || editor_.getFileType().canPreviewFromR())\n      {\n         String preview = editor_.getFileType().getPreviewButtonText();\n         srcOnSaveLabel_.setText(width < 450 ? preview : preview + \" on Save\");\n      }\n      else\n         srcOnSaveLabel_.setText(width < 450 ? \"Source\" : \"Source on Save\");\n      sourceButton_.setText(width < 400 ? \"\" : sourceCommandText_);\n      chunksButton_.setText(width < 400 ? \"\" : \"Run\");\n   }","commit_id":"e0dc8cf54944707d1b7a6b389a67cc44082ec6b8","url":"https://github.com/rstudio/rstudio"},{"original_method":"public PowerFilterChain(List<FilterContext> filterChainCopy, FilterChain containerFilterChain,\n            ResourceMonitor resourceMontior, PowerFilterRouter router, ReposeInstanceInfo instanceInfo, MetricsService metricsService)\n            throws PowerFilterChainException {\n\n        this.filterChainCopy = new LinkedList<FilterContext>(filterChainCopy);\n        this.containerFilterChain = containerFilterChain;\n        this.containerClassLoader = Thread.currentThread().getContextClassLoader();\n        this.resourceMonitor = resourceMontior;\n        this.router = router;\n        this.metricsService = metricsService;\n        if (metricsService != null) {\n            mbcFilterProcessingTime = metricsService.newMeterByCategory(FilterProcessingTime.class, \"PowerFilterChain\", \"ProcessingTime\", TimeUnit.SECONDS);\n        }\n        Thread.currentThread().setName(instanceInfo.toString());\n    }","id":31386,"modified_method":"public PowerFilterChain(List<FilterContext> filterChainCopy, FilterChain containerFilterChain,\n            ResourceMonitor resourceMontior, PowerFilterRouter router, ReposeInstanceInfo instanceInfo, MetricsService metricsService)\n            throws PowerFilterChainException {\n\n        this.filterChainCopy = new LinkedList<FilterContext>(filterChainCopy);\n        this.containerFilterChain = containerFilterChain;\n        this.containerClassLoader = Thread.currentThread().getContextClassLoader();\n        this.resourceMonitor = resourceMontior;\n        this.router = router;\n        this.metricsService = metricsService;\n        if (metricsService != null) {\n            filterProcessingTime = metricsService.newTimer(FilterProcessingTime.class, \"testName\", \"testScope\",\n                    TimeUnit.SECONDS, TimeUnit.SECONDS);\n        }\n        Thread.currentThread().setName(instanceInfo.toString());\n    }","commit_id":"257cf1931cfb031c26f411c8e3e0b8735e37105d","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)\n            throws IOException, ServletException {\n        final MutableHttpServletRequest mutableHttpRequest =\n                MutableHttpServletRequest.wrap((HttpServletRequest) servletRequest);\n        final MutableHttpServletResponse mutableHttpResponse =\n                MutableHttpServletResponse.wrap(mutableHttpRequest, (HttpServletResponse) servletResponse);\n\n        if (filterChainAvailable && position < currentFilters.size()) {\n            FilterContext filter = currentFilters.get(position++);\n            long start = tracer.traceEnter();\n            setStartTimeForHttpLogger(start, mutableHttpRequest);\n            doReposeFilter(mutableHttpRequest, servletResponse, filter);\n            long delay = tracer.traceExit(mutableHttpResponse, filter.getFilterConfig().getName(), start);\n            if (mbcFilterProcessingTime != null) {\n                mbcFilterProcessingTime.mark(filter.getName(), delay);\n            }\n        } else {\n            long start = tracer.traceEnter();\n            doRouting(mutableHttpRequest, servletResponse);\n            tracer.traceExit(mutableHttpResponse, \"route\", start);\n        }\n    }","id":31387,"modified_method":"@Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)\n            throws IOException, ServletException {\n        final MutableHttpServletRequest mutableHttpRequest =\n                MutableHttpServletRequest.wrap((HttpServletRequest) servletRequest);\n        final MutableHttpServletResponse mutableHttpResponse =\n                MutableHttpServletResponse.wrap(mutableHttpRequest, (HttpServletResponse) servletResponse);\n\n        if (filterChainAvailable && position < currentFilters.size()) {\n            FilterContext filter = currentFilters.get(position++);\n            long start = tracer.traceEnter();\n            if (filterProcessingTime != null) {\n                TimerContext timerContext = filterProcessingTime.time();\n                setStartTimeForHttpLogger(start, mutableHttpRequest);\n                doReposeFilter(mutableHttpRequest, servletResponse, filter);\n                timerContext.stop();\n            } else {\n                setStartTimeForHttpLogger(start, mutableHttpRequest);\n                doReposeFilter(mutableHttpRequest, servletResponse, filter);\n            }\n            tracer.traceExit(mutableHttpResponse, filter.getFilterConfig().getName(), start);\n        } else {\n            long start = tracer.traceEnter();\n            doRouting(mutableHttpRequest, servletResponse);\n            tracer.traceExit(mutableHttpResponse, \"route\", start);\n        }\n    }","commit_id":"257cf1931cfb031c26f411c8e3e0b8735e37105d","url":"https://github.com/rackerlabs/repose"},{"original_method":"public long traceExit(MutableHttpServletResponse response, String filterName, long myStart) {\n        if (!trace) {\n            return Long.MIN_VALUE;\n        }\n        long totalRequestTime = new Date().getTime() - requestStart;\n        long myTime = totalRequestTime - myStart - accumulatedTime;\n        accumulatedTime += myTime;\n        response.addHeader(\"X-\" + filterName + \"-Time\", myTime + \"ms\");\n\n        return myTime;\n    }","id":31388,"modified_method":"public void traceExit(MutableHttpServletResponse response, String filterName, long myStart) {\n        if (!trace) {\n            return;\n        }\n        long totalRequestTime = new Date().getTime() - requestStart;\n        long myTime = totalRequestTime - myStart - accumulatedTime;\n        accumulatedTime += myTime;\n        response.addHeader(\"X-\" + filterName + \"-Time\", myTime + \"ms\");\n    }","commit_id":"257cf1931cfb031c26f411c8e3e0b8735e37105d","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)\n            throws IOException, ServletException {\n        final MutableHttpServletRequest mutableHttpRequest =\n                MutableHttpServletRequest.wrap((HttpServletRequest) servletRequest);\n        final MutableHttpServletResponse mutableHttpResponse =\n                MutableHttpServletResponse.wrap(mutableHttpRequest, (HttpServletResponse) servletResponse);\n\n        if (filterChainAvailable && position < currentFilters.size()) {\n            FilterContext filter = currentFilters.get(position++);\n            long start = tracer.traceEnter();\n            if (filterTimer != null) {\n                TimerContext timerContext = filterTimer.time(filter.getName());\n                setStartTimeForHttpLogger(start, mutableHttpRequest);\n                doReposeFilter(mutableHttpRequest, servletResponse, filter);\n                timerContext.stop();\n            } else {\n                setStartTimeForHttpLogger(start, mutableHttpRequest);\n                doReposeFilter(mutableHttpRequest, servletResponse, filter);\n            }\n            tracer.traceExit(mutableHttpResponse, filter.getFilterConfig().getName(), start);\n        } else {\n            long start = tracer.traceEnter();\n            doRouting(mutableHttpRequest, servletResponse);\n            tracer.traceExit(mutableHttpResponse, \"route\", start);\n        }\n    }","id":31389,"modified_method":"@Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)\n            throws IOException, ServletException {\n        final MutableHttpServletRequest mutableHttpRequest =\n                MutableHttpServletRequest.wrap((HttpServletRequest) servletRequest);\n        final MutableHttpServletResponse mutableHttpResponse =\n                MutableHttpServletResponse.wrap(mutableHttpRequest, (HttpServletResponse) servletResponse);\n\n        if (filterChainAvailable && position < currentFilters.size()) {\n            FilterContext filter = currentFilters.get(position++);\n            long start = tracer.traceEnter();\n            setStartTimeForHttpLogger(start, mutableHttpRequest);\n            doReposeFilter(mutableHttpRequest, servletResponse, filter);\n            if( filterTimer != null) {\n                filterTimer.update(filter.getFilterConfig().getName(), tracer.traceExit(mutableHttpResponse,\n                        filter.getFilterConfig().getName(), start), TimeUnit.MILLISECONDS);\n            } else {\n                tracer.traceExit(mutableHttpResponse, filter.getFilterConfig().getName(), start);\n            }\n        } else {\n            long start = tracer.traceEnter();\n            doRouting(mutableHttpRequest, servletResponse);\n            if (filterTimer != null) {\n                filterTimer.update(\"route\", tracer.traceExit(mutableHttpResponse, \"route\", start), TimeUnit.MILLISECONDS);\n            } else {\n                tracer.traceExit(mutableHttpResponse, \"route\", start);\n            }\n        }\n    }","commit_id":"d878cc1613485f1f6fe6ff53489f837658e95653","url":"https://github.com/rackerlabs/repose"},{"original_method":"public void startFilterChain(ServletRequest servletRequest, ServletResponse servletResponse)\n            throws IOException, ServletException {\n        resourceMonitor.use();\n\n        try {\n            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n            tracer = new RequestTracer(traceRequest(request));\n            currentFilters = getFilterChainForRequest(request.getRequestURI());\n            filterChainAvailable = isCurrentFilterChainAvailable();\n            servletRequest.setAttribute(\"filterChainAvailableForRequest\", filterChainAvailable);\n\n            doFilter(servletRequest, servletResponse);\n        } finally {\n            resourceMonitor.released();\n        }\n    }","id":31390,"modified_method":"public void startFilterChain(ServletRequest servletRequest, ServletResponse servletResponse)\n            throws IOException, ServletException {\n        resourceMonitor.use();\n\n        try {\n            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n            tracer = new RequestTracer(traceRequest(request) || metricsService != null, traceRequest(request));\n            currentFilters = getFilterChainForRequest(request.getRequestURI());\n            filterChainAvailable = isCurrentFilterChainAvailable();\n            servletRequest.setAttribute(\"filterChainAvailableForRequest\", filterChainAvailable);\n\n            doFilter(servletRequest, servletResponse);\n        } finally {\n            resourceMonitor.released();\n        }\n    }","commit_id":"d878cc1613485f1f6fe6ff53489f837658e95653","url":"https://github.com/rackerlabs/repose"},{"original_method":"public RequestTracer(boolean trace) {\n        this.trace = trace;\n        requestStart = new Date().getTime();\n    }","id":31391,"modified_method":"public RequestTracer(boolean trace, boolean addHeader) {\n        this.trace = trace;\n        this.addHeader = addHeader;\n        requestStart = new Date().getTime();\n    }","commit_id":"d878cc1613485f1f6fe6ff53489f837658e95653","url":"https://github.com/rackerlabs/repose"},{"original_method":"public void traceExit(MutableHttpServletResponse response, String filterName, long myStart) {\n        if (!trace) {\n            return;\n        }\n        long totalRequestTime = new Date().getTime() - requestStart;\n        long myTime = totalRequestTime - myStart - accumulatedTime;\n        accumulatedTime += myTime;\n        response.addHeader(\"X-\" + filterName + \"-Time\", myTime + \"ms\");\n    }","id":31392,"modified_method":"public long traceExit(MutableHttpServletResponse response, String filterName, long myStart) {\n        if (!trace) {\n            return 0;\n        }\n\n        long totalRequestTime = new Date().getTime() - requestStart;\n        long myTime = totalRequestTime - myStart - accumulatedTime;\n        accumulatedTime += myTime;\n\n        if (addHeader)\n            response.addHeader(\"X-\" + filterName + \"-Time\", myTime + \"ms\");\n\n        return myTime;\n    }","commit_id":"d878cc1613485f1f6fe6ff53489f837658e95653","url":"https://github.com/rackerlabs/repose"},{"original_method":"public void redistributeSummaries() throws IOException\n    {\n        Pair<List<SSTableReader>, Map<UUID, LifecycleTransaction>> compactingAndNonCompacting = getCompactingAndNonCompactingSSTables();\n        try\n        {\n            redistributeSummaries(compactingAndNonCompacting.left, compactingAndNonCompacting.right, this.memoryPoolBytes);\n        }\n        finally\n        {\n            for (LifecycleTransaction modifier : compactingAndNonCompacting.right.values())\n                modifier.close();\n        }\n    }","id":31393,"modified_method":"public void redistributeSummaries() throws IOException\n    {\n        Pair<List<SSTableReader>, Map<UUID, LifecycleTransaction>> compactingAndNonCompacting = getCompactingAndNonCompactingSSTables();\n        try\n        {\n            redistributeSummaries(new IndexSummaryRedistribution(compactingAndNonCompacting.left,\n                                                                 compactingAndNonCompacting.right,\n                                                                 this.memoryPoolBytes));\n        }\n        finally\n        {\n            for (LifecycleTransaction modifier : compactingAndNonCompacting.right.values())\n                modifier.close();\n        }\n    }","commit_id":"b447ffc4242c1514dd33e4ace96b719d892ff4a2","url":"https://github.com/apache/cassandra"},{"original_method":"@Test(timeout = 10000)\n    public void testRedistributeSummaries() throws IOException\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        int numSSTables = 4;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        int minSamplingLevel = (BASE_SAMPLING_LEVEL * cfs.metadata.params.minIndexInterval) / cfs.metadata.params.maxIndexInterval;\n\n        List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        long singleSummaryOffHeapSpace = sstables.get(0).getIndexSummaryOffHeapSize();\n\n        // there should be enough space to not downsample anything\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * numSSTables));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL, sstable.getIndexSummarySamplingLevel());\n        assertEquals(singleSummaryOffHeapSpace * numSSTables, totalOffHeapSize(sstables));\n        validateData(cfs, numRows);\n\n        // everything should get cut in half\n        assert sstables.size() == 4;\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * (numSSTables / 2)));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL / 2, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // everything should get cut to a quarter\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * (numSSTables / 4)));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL / 4, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // upsample back up to half\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * (numSSTables / 2) + 4));\n        }\n        assert sstables.size() == 4;\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL / 2, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // upsample back up to the original index summary\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * numSSTables));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // make two of the four sstables cold, only leave enough space for three full index summaries,\n        // so the two cold sstables should get downsampled to be half of their original size\n        sstables.get(0).overrideReadMeter(new RestorableMeter(50.0, 50.0));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(50.0, 50.0));\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * 3));\n        }\n        Collections.sort(sstables, hotnessComparator);\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(0).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(1).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(2).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // small increases or decreases in the read rate don't result in downsampling or upsampling\n        double lowerRate = 50.0 * (DOWNSAMPLE_THESHOLD + (DOWNSAMPLE_THESHOLD * 0.10));\n        double higherRate = 50.0 * (UPSAMPLE_THRESHOLD - (UPSAMPLE_THRESHOLD * 0.10));\n        sstables.get(0).overrideReadMeter(new RestorableMeter(lowerRate, lowerRate));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(higherRate, higherRate));\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * 3));\n        }\n        Collections.sort(sstables, hotnessComparator);\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(0).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(1).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(2).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // reset, and then this time, leave enough space for one of the cold sstables to not get downsampled\n        sstables = resetSummaries(cfs, sstables, singleSummaryOffHeapSpace);\n        sstables.get(0).overrideReadMeter(new RestorableMeter(1.0, 1.0));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(2.0, 2.0));\n        sstables.get(2).overrideReadMeter(new RestorableMeter(1000.0, 1000.0));\n        sstables.get(3).overrideReadMeter(new RestorableMeter(1000.0, 1000.0));\n\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * 3) + 50);\n        }\n        Collections.sort(sstables, hotnessComparator);\n\n        if (sstables.get(0).getIndexSummarySamplingLevel() == minSamplingLevel)\n            assertEquals(BASE_SAMPLING_LEVEL, sstables.get(1).getIndexSummarySamplingLevel());\n        else\n            assertEquals(BASE_SAMPLING_LEVEL, sstables.get(0).getIndexSummarySamplingLevel());\n\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(2).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n\n        // Cause a mix of upsampling and downsampling. We'll leave enough space for two full index summaries. The two\n        // coldest sstables will get downsampled to 4/128 of their size, leaving us with 1 and 92/128th index\n        // summaries worth of space.  The hottest sstable should get a full index summary, and the one in the middle\n        // should get the remainder.\n        sstables.get(0).overrideReadMeter(new RestorableMeter(0.0, 0.0));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(0.0, 0.0));\n        sstables.get(2).overrideReadMeter(new RestorableMeter(92, 92));\n        sstables.get(3).overrideReadMeter(new RestorableMeter(128.0, 128.0));\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (long) (singleSummaryOffHeapSpace + (singleSummaryOffHeapSpace * (92.0 / BASE_SAMPLING_LEVEL))));\n        }\n        Collections.sort(sstables, hotnessComparator);\n        assertEquals(1, sstables.get(0).getIndexSummarySize());  // at the min sampling level\n        assertEquals(1, sstables.get(0).getIndexSummarySize());  // at the min sampling level\n        assertTrue(sstables.get(2).getIndexSummarySamplingLevel() > minSamplingLevel);\n        assertTrue(sstables.get(2).getIndexSummarySamplingLevel() < BASE_SAMPLING_LEVEL);\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // Don't leave enough space for even the minimal index summaries\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 10);\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(1, sstable.getIndexSummarySize());  // at the min sampling level\n        validateData(cfs, numRows);\n    }","id":31394,"modified_method":"@Test(timeout = 10000)\n    public void testRedistributeSummaries() throws IOException\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        int numSSTables = 4;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        int minSamplingLevel = (BASE_SAMPLING_LEVEL * cfs.metadata.params.minIndexInterval) / cfs.metadata.params.maxIndexInterval;\n\n        List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        long singleSummaryOffHeapSpace = sstables.get(0).getIndexSummaryOffHeapSize();\n\n        // there should be enough space to not downsample anything\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * numSSTables)));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL, sstable.getIndexSummarySamplingLevel());\n        assertEquals(singleSummaryOffHeapSpace * numSSTables, totalOffHeapSize(sstables));\n        validateData(cfs, numRows);\n\n        // everything should get cut in half\n        assert sstables.size() == 4;\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * (numSSTables / 2))));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL / 2, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // everything should get cut to a quarter\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * (numSSTables / 4))));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL / 4, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // upsample back up to half\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * (numSSTables / 2) + 4)));\n        }\n        assert sstables.size() == 4;\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL / 2, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // upsample back up to the original index summary\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * numSSTables)));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL, sstable.getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // make two of the four sstables cold, only leave enough space for three full index summaries,\n        // so the two cold sstables should get downsampled to be half of their original size\n        sstables.get(0).overrideReadMeter(new RestorableMeter(50.0, 50.0));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(50.0, 50.0));\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * 3)));\n        }\n        Collections.sort(sstables, hotnessComparator);\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(0).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(1).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(2).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // small increases or decreases in the read rate don't result in downsampling or upsampling\n        double lowerRate = 50.0 * (DOWNSAMPLE_THESHOLD + (DOWNSAMPLE_THESHOLD * 0.10));\n        double higherRate = 50.0 * (UPSAMPLE_THRESHOLD - (UPSAMPLE_THRESHOLD * 0.10));\n        sstables.get(0).overrideReadMeter(new RestorableMeter(lowerRate, lowerRate));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(higherRate, higherRate));\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * 3)));\n        }\n        Collections.sort(sstables, hotnessComparator);\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(0).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL / 2, sstables.get(1).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(2).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // reset, and then this time, leave enough space for one of the cold sstables to not get downsampled\n        sstables = resetSummaries(cfs, sstables, singleSummaryOffHeapSpace);\n        sstables.get(0).overrideReadMeter(new RestorableMeter(1.0, 1.0));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(2.0, 2.0));\n        sstables.get(2).overrideReadMeter(new RestorableMeter(1000.0, 1000.0));\n        sstables.get(3).overrideReadMeter(new RestorableMeter(1000.0, 1000.0));\n\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (singleSummaryOffHeapSpace * 3) + 50));\n        }\n        Collections.sort(sstables, hotnessComparator);\n\n        if (sstables.get(0).getIndexSummarySamplingLevel() == minSamplingLevel)\n            assertEquals(BASE_SAMPLING_LEVEL, sstables.get(1).getIndexSummarySamplingLevel());\n        else\n            assertEquals(BASE_SAMPLING_LEVEL, sstables.get(0).getIndexSummarySamplingLevel());\n\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(2).getIndexSummarySamplingLevel());\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n\n        // Cause a mix of upsampling and downsampling. We'll leave enough space for two full index summaries. The two\n        // coldest sstables will get downsampled to 4/128 of their size, leaving us with 1 and 92/128th index\n        // summaries worth of space.  The hottest sstable should get a full index summary, and the one in the middle\n        // should get the remainder.\n        sstables.get(0).overrideReadMeter(new RestorableMeter(0.0, 0.0));\n        sstables.get(1).overrideReadMeter(new RestorableMeter(0.0, 0.0));\n        sstables.get(2).overrideReadMeter(new RestorableMeter(92, 92));\n        sstables.get(3).overrideReadMeter(new RestorableMeter(128.0, 128.0));\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (long) (singleSummaryOffHeapSpace + (singleSummaryOffHeapSpace * (92.0 / BASE_SAMPLING_LEVEL)))));\n        }\n        Collections.sort(sstables, hotnessComparator);\n        assertEquals(1, sstables.get(0).getIndexSummarySize());  // at the min sampling level\n        assertEquals(1, sstables.get(0).getIndexSummarySize());  // at the min sampling level\n        assertTrue(sstables.get(2).getIndexSummarySamplingLevel() > minSamplingLevel);\n        assertTrue(sstables.get(2).getIndexSummarySamplingLevel() < BASE_SAMPLING_LEVEL);\n        assertEquals(BASE_SAMPLING_LEVEL, sstables.get(3).getIndexSummarySamplingLevel());\n        validateData(cfs, numRows);\n\n        // Don't leave enough space for even the minimal index summaries\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 10));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(1, sstable.getIndexSummarySize());  // at the min sampling level\n        validateData(cfs, numRows);\n    }","commit_id":"b447ffc4242c1514dd33e4ace96b719d892ff4a2","url":"https://github.com/apache/cassandra"},{"original_method":"private static List<SSTableReader> resetSummaries(ColumnFamilyStore cfs, List<SSTableReader> sstables, long originalOffHeapSize) throws IOException\n    {\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), originalOffHeapSize * sstables.size());\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL, sstable.getIndexSummarySamplingLevel());\n\n        return sstables;\n    }","id":31395,"modified_method":"private static List<SSTableReader> resetSummaries(ColumnFamilyStore cfs, List<SSTableReader> sstables, long originalOffHeapSize) throws IOException\n    {\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            sstables = redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), originalOffHeapSize * sstables.size()));\n        }\n        for (SSTableReader sstable : sstables)\n            assertEquals(BASE_SAMPLING_LEVEL, sstable.getIndexSummarySamplingLevel());\n\n        return sstables;\n    }","commit_id":"b447ffc4242c1514dd33e4ace96b719d892ff4a2","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testChangeMaxIndexInterval() throws IOException\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        int numSSTables = 1;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 10);\n        }\n        sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            assertEquals(cfs.metadata.params.maxIndexInterval, sstable.getEffectiveIndexInterval(), 0.01);\n\n        // halve the max_index_interval\n        cfs.metadata.maxIndexInterval(cfs.metadata.params.maxIndexInterval / 2);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 1);\n        }\n        sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n        {\n            assertEquals(cfs.metadata.params.maxIndexInterval, sstable.getEffectiveIndexInterval(), 0.01);\n            assertEquals(numRows / cfs.metadata.params.maxIndexInterval, sstable.getIndexSummarySize());\n        }\n\n        // return max_index_interval to its original value\n        cfs.metadata.maxIndexInterval(cfs.metadata.params.maxIndexInterval * 2);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 1);\n        }\n        for (SSTableReader sstable : cfs.getLiveSSTables())\n        {\n            assertEquals(cfs.metadata.params.maxIndexInterval, sstable.getEffectiveIndexInterval(), 0.01);\n            assertEquals(numRows / cfs.metadata.params.maxIndexInterval, sstable.getIndexSummarySize());\n        }\n    }","id":31396,"modified_method":"@Test\n    public void testChangeMaxIndexInterval() throws IOException\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        int numSSTables = 1;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 10));\n        }\n        sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            assertEquals(cfs.metadata.params.maxIndexInterval, sstable.getEffectiveIndexInterval(), 0.01);\n\n        // halve the max_index_interval\n        cfs.metadata.maxIndexInterval(cfs.metadata.params.maxIndexInterval / 2);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 1));\n        }\n        sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n        {\n            assertEquals(cfs.metadata.params.maxIndexInterval, sstable.getEffectiveIndexInterval(), 0.01);\n            assertEquals(numRows / cfs.metadata.params.maxIndexInterval, sstable.getIndexSummarySize());\n        }\n\n        // return max_index_interval to its original value\n        cfs.metadata.maxIndexInterval(cfs.metadata.params.maxIndexInterval * 2);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n        {\n            redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 1));\n        }\n        for (SSTableReader sstable : cfs.getLiveSSTables())\n        {\n            assertEquals(cfs.metadata.params.maxIndexInterval, sstable.getEffectiveIndexInterval(), 0.01);\n            assertEquals(numRows / cfs.metadata.params.maxIndexInterval, sstable.getIndexSummarySize());\n        }\n    }","commit_id":"b447ffc4242c1514dd33e4ace96b719d892ff4a2","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testChangeMinIndexInterval() throws IOException\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        int numSSTables = 1;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        for (SSTableReader sstable : sstables)\n            assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n\n        // double the min_index_interval\n        cfs.metadata.minIndexInterval(originalMinIndexInterval * 2);\n        IndexSummaryManager.instance.redistributeSummaries();\n        for (SSTableReader sstable : cfs.getLiveSSTables())\n        {\n            assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n            assertEquals(numRows / cfs.metadata.params.minIndexInterval, sstable.getIndexSummarySize());\n        }\n\n        // return min_index_interval to its original value\n        cfs.metadata.minIndexInterval(originalMinIndexInterval);\n        IndexSummaryManager.instance.redistributeSummaries();\n        for (SSTableReader sstable : cfs.getLiveSSTables())\n        {\n            assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n            assertEquals(numRows / cfs.metadata.params.minIndexInterval, sstable.getIndexSummarySize());\n        }\n\n        // halve the min_index_interval, but constrain the available space to exactly what we have now; as a result,\n        // the summary shouldn't change\n        cfs.metadata.minIndexInterval(originalMinIndexInterval / 2);\n        SSTableReader sstable = cfs.getLiveSSTables().iterator().next();\n        long summarySpace = sstable.getIndexSummaryOffHeapSize();\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), summarySpace);\n        }\n\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(originalMinIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n        assertEquals(numRows / originalMinIndexInterval, sstable.getIndexSummarySize());\n\n        // keep the min_index_interval the same, but now give the summary enough space to grow by 50%\n        double previousInterval = sstable.getEffectiveIndexInterval();\n        int previousSize = sstable.getIndexSummarySize();\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (long) Math.ceil(summarySpace * 1.5));\n        }\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(previousSize * 1.5, (double) sstable.getIndexSummarySize(), 1);\n        assertEquals(previousInterval * (1.0 / 1.5), sstable.getEffectiveIndexInterval(), 0.001);\n\n        // return min_index_interval to it's original value (double it), but only give the summary enough space\n        // to have an effective index interval of twice the new min\n        cfs.metadata.minIndexInterval(originalMinIndexInterval);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (long) Math.ceil(summarySpace / 2.0));\n        }\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(originalMinIndexInterval * 2, sstable.getEffectiveIndexInterval(), 0.001);\n        assertEquals(numRows / (originalMinIndexInterval * 2), sstable.getIndexSummarySize());\n\n        // raise the min_index_interval above our current effective interval, but set the max_index_interval lower\n        // than what we actually have space for (meaning the index summary would ideally be smaller, but this would\n        // result in an effective interval above the new max)\n        cfs.metadata.minIndexInterval(originalMinIndexInterval * 4);\n        cfs.metadata.maxIndexInterval(originalMinIndexInterval * 4);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 10);\n        }\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n    }","id":31397,"modified_method":"@Test\n    public void testChangeMinIndexInterval() throws IOException\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        int numSSTables = 1;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        for (SSTableReader sstable : sstables)\n            assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n\n        // double the min_index_interval\n        cfs.metadata.minIndexInterval(originalMinIndexInterval * 2);\n        IndexSummaryManager.instance.redistributeSummaries();\n        for (SSTableReader sstable : cfs.getLiveSSTables())\n        {\n            assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n            assertEquals(numRows / cfs.metadata.params.minIndexInterval, sstable.getIndexSummarySize());\n        }\n\n        // return min_index_interval to its original value\n        cfs.metadata.minIndexInterval(originalMinIndexInterval);\n        IndexSummaryManager.instance.redistributeSummaries();\n        for (SSTableReader sstable : cfs.getLiveSSTables())\n        {\n            assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n            assertEquals(numRows / cfs.metadata.params.minIndexInterval, sstable.getIndexSummarySize());\n        }\n\n        // halve the min_index_interval, but constrain the available space to exactly what we have now; as a result,\n        // the summary shouldn't change\n        cfs.metadata.minIndexInterval(originalMinIndexInterval / 2);\n        SSTableReader sstable = cfs.getLiveSSTables().iterator().next();\n        long summarySpace = sstable.getIndexSummaryOffHeapSize();\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), summarySpace));\n        }\n\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(originalMinIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n        assertEquals(numRows / originalMinIndexInterval, sstable.getIndexSummarySize());\n\n        // keep the min_index_interval the same, but now give the summary enough space to grow by 50%\n        double previousInterval = sstable.getEffectiveIndexInterval();\n        int previousSize = sstable.getIndexSummarySize();\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (long) Math.ceil(summarySpace * 1.5)));\n        }\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(previousSize * 1.5, (double) sstable.getIndexSummarySize(), 1);\n        assertEquals(previousInterval * (1.0 / 1.5), sstable.getEffectiveIndexInterval(), 0.001);\n\n        // return min_index_interval to it's original value (double it), but only give the summary enough space\n        // to have an effective index interval of twice the new min\n        cfs.metadata.minIndexInterval(originalMinIndexInterval);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), (long) Math.ceil(summarySpace / 2.0)));\n        }\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(originalMinIndexInterval * 2, sstable.getEffectiveIndexInterval(), 0.001);\n        assertEquals(numRows / (originalMinIndexInterval * 2), sstable.getIndexSummarySize());\n\n        // raise the min_index_interval above our current effective interval, but set the max_index_interval lower\n        // than what we actually have space for (meaning the index summary would ideally be smaller, but this would\n        // result in an effective interval above the new max)\n        cfs.metadata.minIndexInterval(originalMinIndexInterval * 4);\n        cfs.metadata.maxIndexInterval(originalMinIndexInterval * 4);\n        try (LifecycleTransaction txn = cfs.getTracker().tryModify(asList(sstable), OperationType.UNKNOWN))\n        {\n            redistributeSummaries(redistribution(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), 10));\n        }\n        sstable = cfs.getLiveSSTables().iterator().next();\n        assertEquals(cfs.metadata.params.minIndexInterval, sstable.getEffectiveIndexInterval(), 0.001);\n    }","commit_id":"b447ffc4242c1514dd33e4ace96b719d892ff4a2","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testCancelIndex() throws Exception\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        final int numSSTables = 4;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        final List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        final long singleSummaryOffHeapSpace = sstables.get(0).getIndexSummaryOffHeapSize();\n\n        // everything should get cut in half\n        final AtomicReference<CompactionInterruptedException> exception = new AtomicReference<>();\n\n        Thread t = new Thread(new Runnable()\n        {\n            public void run()\n            {\n                try\n                {\n                    // Don't leave enough space for even the minimal index summaries\n                    try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n                    {\n                        redistributeSummaries(Collections.EMPTY_LIST, of(cfs.metadata.cfId, txn), singleSummaryOffHeapSpace);\n                    }\n                }\n                catch (CompactionInterruptedException ex)\n                {\n                    exception.set(ex);\n                }\n                catch (IOException ignored)\n                {\n                }\n            }\n        });\n        t.start();\n        while (CompactionManager.instance.getActiveCompactions() == 0 && t.isAlive())\n            Thread.sleep(1);\n        CompactionManager.instance.stopCompaction(\"INDEX_SUMMARY\");\n        t.join();\n\n        assertNotNull(\"Expected compaction interrupted exception\", exception.get());\n        assertTrue(\"Expected no active compactions\", CompactionMetrics.getCompactions().isEmpty());\n\n        Set<SSTableReader> beforeRedistributionSSTables = new HashSet<>(sstables);\n        Set<SSTableReader> afterCancelSSTables = new HashSet<>(cfs.getLiveSSTables());\n        Set<SSTableReader> disjoint = Sets.symmetricDifference(beforeRedistributionSSTables, afterCancelSSTables);\n        assertTrue(String.format(\"Mismatched files before and after cancelling redistribution: %s\",\n                                 Joiner.on(\",\").join(disjoint)),\n                   disjoint.isEmpty());\n\n        validateData(cfs, numRows);\n    }","id":31398,"modified_method":"@Test\n    public void testCancelIndex() throws Exception\n    {\n        String ksname = KEYSPACE1;\n        String cfname = CF_STANDARDLOWiINTERVAL; // index interval of 8, no key caching\n        Keyspace keyspace = Keyspace.open(ksname);\n        final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);\n        final int numSSTables = 4;\n        int numRows = 256;\n        createSSTables(ksname, cfname, numSSTables, numRows);\n\n        final List<SSTableReader> sstables = new ArrayList<>(cfs.getLiveSSTables());\n        for (SSTableReader sstable : sstables)\n            sstable.overrideReadMeter(new RestorableMeter(100.0, 100.0));\n\n        final long singleSummaryOffHeapSpace = sstables.get(0).getIndexSummaryOffHeapSize();\n\n        // everything should get cut in half\n        final AtomicReference<CompactionInterruptedException> exception = new AtomicReference<>();\n\n        // barrier to control when redistribution runs\n        final CountDownLatch barrier = new CountDownLatch(1);\n\n        Thread t = new Thread(new Runnable()\n        {\n            public void run()\n            {\n                try\n                {\n                    // Don't leave enough space for even the minimal index summaries\n                    try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstables, OperationType.UNKNOWN))\n                    {\n                        redistributeSummaries(new ObservableRedistribution(Collections.EMPTY_LIST,\n                                                                           of(cfs.metadata.cfId, txn),\n                                                                           singleSummaryOffHeapSpace,\n                                                                           barrier));\n                    }\n                }\n                catch (CompactionInterruptedException ex)\n                {\n                    exception.set(ex);\n                }\n                catch (IOException ignored)\n                {\n                }\n            }\n        });\n        t.start();\n        while (CompactionManager.instance.getActiveCompactions() == 0 && t.isAlive())\n            Thread.sleep(1);\n        // to ensure that the stop condition check in IndexSummaryRedistribution::redistributeSummaries\n        // is made *after* the halt request is made to the CompactionManager, don't allow the redistribution\n        // to proceed until stopCompaction has been called.\n        CompactionManager.instance.stopCompaction(\"INDEX_SUMMARY\");\n        // allows the redistribution to proceed\n        barrier.countDown();\n\n        t.join();\n\n        assertNotNull(\"Expected compaction interrupted exception\", exception.get());\n        assertTrue(\"Expected no active compactions\", CompactionMetrics.getCompactions().isEmpty());\n\n        Set<SSTableReader> beforeRedistributionSSTables = new HashSet<>(sstables);\n        Set<SSTableReader> afterCancelSSTables = new HashSet<>(cfs.getLiveSSTables());\n        Set<SSTableReader> disjoint = Sets.symmetricDifference(beforeRedistributionSSTables, afterCancelSSTables);\n        assertTrue(String.format(\"Mismatched files before and after cancelling redistribution: %s\",\n                                 Joiner.on(\",\").join(disjoint)),\n                   disjoint.isEmpty());\n\n        validateData(cfs, numRows);\n    }","commit_id":"b447ffc4242c1514dd33e4ace96b719d892ff4a2","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n  protected void processIntention(@NotNull PsiElement element, Project project, Editor editor) throws IncorrectOperationException {\n    PsiElement parent = element.getParent();\n\n    if (!\"if\".equals(element.getText()) || !(parent instanceof GrIfStatement)) {\n      throw new IncorrectOperationException(\"Not invoked on an if\");\n    }\n    GrIfStatement parentIf = (GrIfStatement)parent;\n    GroovyPsiElementFactory groovyPsiElementFactory = GroovyPsiElementFactory.getInstance(project);\n\n\n    GrExpression condition = parentIf.getCondition();\n    if (condition == null) {\n      throw new IncorrectOperationException(\"Invoked on an if with empty condition\");\n    }\n\n    GrExpression negatedCondition = null;\n    if (condition instanceof GrUnaryExpression) {\n      GrUnaryExpression unaryCondition = (GrUnaryExpression)condition;\n      if (\"!\".equals(unaryCondition.getOperationToken().getText())) {\n        negatedCondition = stripParenthesis(unaryCondition.getOperand());\n      }\n    }\n\n    if (negatedCondition == null) {\n      // Now check whether this is a simple expression\n      condition = stripParenthesis(condition);\n      String negatedExpressionText;\n      if (condition instanceof GrCallExpression || condition instanceof GrReferenceExpression) {\n        negatedExpressionText = \"!\" + condition.getText();\n      }\n      else {\n        negatedExpressionText = \"!(\" + condition.getText() + \")\";\n      }\n      negatedCondition = groovyPsiElementFactory.createExpressionFromText(negatedExpressionText, parentIf);\n    }\n\n\n    GrStatement thenBranch = parentIf.getThenBranch();\n    String newIfText = \"if (\" + negatedCondition.getText() + \") \" + generateElseBranchTextAndRemoveTailStatements(parentIf);\n\n    boolean isThenEmpty = thenBranch == null ||\n                          (thenBranch instanceof GrBlockStatement) && ((GrBlockStatement)thenBranch).getBlock().getStatements().length == 0;\n    if (!isThenEmpty) {\n      newIfText += \" else \" + thenBranch.getText();\n    }\n\n    GrIfStatement newIf = (GrIfStatement)groovyPsiElementFactory.createStatementFromText(newIfText, parentIf.getContext());\n    parentIf.replace(CodeStyleManager.getInstance(project).reformat(newIf));\n  }","id":31399,"modified_method":"@Override\n  protected void processIntention(@NotNull PsiElement element, Project project, Editor editor) throws IncorrectOperationException {\n    PsiElement parent = element.getParent();\n\n    if (!\"if\".equals(element.getText()) || !(parent instanceof GrIfStatement)) {\n      throw new IncorrectOperationException(\"Not invoked on an if\");\n    }\n    GrIfStatement parentIf = (GrIfStatement)parent;\n    GroovyPsiElementFactory groovyPsiElementFactory = GroovyPsiElementFactory.getInstance(project);\n\n\n    GrExpression condition = parentIf.getCondition();\n    if (condition == null) {\n      throw new IncorrectOperationException(\"Invoked on an if with empty condition\");\n    }\n\n    GrExpression negatedCondition = null;\n    if (condition instanceof GrUnaryExpression) {\n      GrUnaryExpression unaryCondition = (GrUnaryExpression)condition;\n      if (\"!\".equals(unaryCondition.getOperationToken().getText())) {\n        negatedCondition = stripParenthesis(unaryCondition.getOperand());\n      }\n    }\n\n    if (negatedCondition == null) {\n      // Now check whether this is a simple expression\n      condition = stripParenthesis(condition);\n      String negatedExpressionText;\n      if (condition instanceof GrCallExpression || condition instanceof GrReferenceExpression) {\n        negatedExpressionText = \"!\" + condition.getText();\n      }\n      else {\n        negatedExpressionText = \"!(\" + condition.getText() + \")\";\n      }\n      negatedCondition = groovyPsiElementFactory.createExpressionFromText(negatedExpressionText, parentIf);\n    }\n\n\n    GrStatement thenBranch = parentIf.getThenBranch();\n    final boolean thenIsNotEmpty = isNotEmpty(thenBranch);\n\n    String newIfText = \"if (\" + negatedCondition.getText() + \") {}\";\n    if (thenIsNotEmpty) {\n      newIfText += \" else {}\";\n    }\n\n    GrIfStatement newIf = (GrIfStatement)groovyPsiElementFactory.createStatementFromText(newIfText, parentIf.getContext());\n    generateElseBranchTextAndRemoveTailStatements(parentIf, newIf);\n\n    if (thenIsNotEmpty) {\n      final GrStatement elseBranch = newIf.getElseBranch();\n      assert elseBranch != null;\n      elseBranch.replaceWithStatement(thenBranch);\n    }\n\n    parentIf.replace(newIf);\n  }","commit_id":"cc72459b6f3d636ac8200a5b5efd3ec9ac518ac6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String generateElseBranchTextAndRemoveTailStatements(GrIfStatement ifStatement) {\n    GrStatement elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      return elseBranch.getText();\n    }\n\n    PsiElement parent = ifStatement.getParent();\n    if (!(parent instanceof GrStatementOwner)) {\n      return \"{}\";\n    }\n\n    String text = parent.getText();\n    int start = ifStatement.getTextRange().getEndOffset() - parent.getTextRange().getStartOffset();\n    PsiElement rbrace = parent instanceof GrCodeBlock ? ((GrCodeBlock)parent).getRBrace() : null;\n    int end = rbrace != null ? rbrace.getStartOffsetInParent() : text.length();\n\n    String lastStatements = text.substring(start, end);\n\n    deleteLastStatements((GrStatementOwner)parent, ifStatement, rbrace);\n    return \"{\\n\" + lastStatements.trim() + \"\\n}\";\n  }","id":31400,"modified_method":"private static void generateElseBranchTextAndRemoveTailStatements(@NotNull GrIfStatement ifStatement, @NotNull GrIfStatement newIf) {\n    final GrStatement thenBranch = newIf.getThenBranch();\n    assert thenBranch != null;\n\n    GrStatement elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      thenBranch.replaceWithStatement(elseBranch);\n      return;\n    }\n\n    PsiElement parent = ifStatement.getParent();\n    if (!(parent instanceof GrStatementOwner)) return;\n\n    if (!isTailAfterIf(ifStatement, ((GrStatementOwner)parent))) return;\n\n    final PsiElement start = ifStatement.getNextSibling();\n    PsiElement end = parent instanceof GrCodeBlock ? ((GrCodeBlock)parent).getRBrace().getPrevSibling() : parent.getLastChild();\n\n    final GrOpenBlock block = ((GrBlockStatement)thenBranch).getBlock();\n    block.addRangeAfter(start, end, block.getLBrace());\n    parent.deleteChildRange(start, end);\n  }","commit_id":"cc72459b6f3d636ac8200a5b5efd3ec9ac518ac6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void deleteLastStatements(GrStatementOwner statementOwner, GrIfStatement ifStatement, PsiElement rbrace) {\n    PsiElement next = ifStatement.getNextSibling();\n    if (next == null) return;\n\n    if (rbrace == null) {\n      statementOwner.getNode().removeRange(next.getNode(), null);\n    }\n    else {\n      statementOwner.getNode().removeRange(next.getNode(), rbrace.getNode());\n    }\n  }","id":31401,"modified_method":"private static boolean isTailAfterIf(@NotNull GrIfStatement ifStatement, @NotNull GrStatementOwner owner) {\n    final GrControlFlowOwner flowOwner = ControlFlowUtils.findControlFlowOwner(ifStatement);\n    if (flowOwner == null) return false;\n\n    final Instruction[] flow = flowOwner.getControlFlow();\n\n    final GrStatement[] statements = owner.getStatements();\n    final int index = ArrayUtilRt.find(statements, ifStatement);\n    if (index == statements.length - 1) return false;\n\n    final GrStatement then = ifStatement.getThenBranch();\n\n    for (Instruction i : flow) {\n      final PsiElement element = i.getElement();\n      if (element == null || !PsiTreeUtil.isAncestor(then, element, true)) continue;\n\n      for (Instruction succ : i.allSuccessors()) {\n        if (succ instanceof IfEndInstruction) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"cc72459b6f3d636ac8200a5b5efd3ec9ac518ac6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiClass moveClass(@NotNull PsiClass aClass, @NotNull PsiClass targetClass) {\n    if (!(aClass instanceof GrTypeDefinition)) return null;\n\n    GroovyChangeContextUtil.encodeContextInfo(aClass);\n\n\n    PsiDocComment doc = aClass.getDocComment();\n    PsiClass newClass = (PsiClass)targetClass.addBefore(aClass, targetClass.getRBrace());\n    if (doc != null) {\n      targetClass.addBefore(doc, newClass);\n    }\n\n    if (targetClass.isInterface()) {\n      PsiUtil.setModifierProperty(newClass, PsiModifier.PUBLIC, true);\n    }\n    else {\n      PsiUtil.setModifierProperty(newClass, PsiModifier.STATIC, true);\n    }\n    GroovyChangeContextUtil.decodeContextInfo(newClass, null, null);\n\n    return newClass;\n  }","id":31402,"modified_method":"@Override\n  public PsiClass moveClass(@NotNull PsiClass aClass, @NotNull PsiClass targetClass) {\n    if (!(aClass instanceof GrTypeDefinition)) return null;\n\n    GroovyChangeContextUtil.encodeContextInfo(aClass);\n\n\n    PsiDocComment doc = aClass.getDocComment();\n\n    PsiElement brace = targetClass.getRBrace();\n    PsiClass newClass = (PsiClass)targetClass.addBefore(aClass, brace);\n    PsiElement sibling = newClass.getPrevSibling();\n    GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(targetClass.getProject());\n    if (!org.jetbrains.plugins.groovy.lang.psi.util.PsiUtil.isNewLine(sibling)) {\n      targetClass.addBefore(factory.createLineTerminator(\"\\n \"), newClass);\n    }\n    else if (doc != null) {\n      LOG.assertTrue(sibling != null);\n      sibling.replace(factory.createLineTerminator(sibling.getText() + \" \"));\n    }\n\n    if (doc != null) {\n      targetClass.addBefore(doc, newClass);\n      targetClass.addBefore(factory.createLineTerminator(\"\\n\"), newClass);\n    }\n\n    if (targetClass.isInterface()) {\n      PsiUtil.setModifierProperty(newClass, PsiModifier.PUBLIC, true);\n    }\n    else {\n      PsiUtil.setModifierProperty(newClass, PsiModifier.STATIC, true);\n    }\n    GroovyChangeContextUtil.decodeContextInfo(newClass, null, null);\n\n    return newClass;\n  }","commit_id":"b1f4fb96a3c4b30a7a85ceff79820d10ccead926","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compare(Object arg0, Object arg1) {\n\t\tUserAlert a0 = (UserAlert) arg0;\n\t\tUserAlert a1 = (UserAlert) arg1;\n\t\tif(a0 == a1) return 0; // common case, also we should be consistent with == even with proxyuseralert's\n\t\treturn a0.getPriorityClass() - a1.getPriorityClass();\n\t}","id":31403,"modified_method":"public int compare(Object arg0, Object arg1) {\n\t\tUserAlert a0 = (UserAlert) arg0;\n\t\tUserAlert a1 = (UserAlert) arg1;\n\t\tif(a0 == a1) return 0; // common case, also we should be consistent with == even with proxyuseralert's\n\t\tshort prio0 = a0.getPriorityClass();\n\t\tshort prio1 = a1.getPriorityClass();\n\t\tif(prio0 - prio1 == 0) {\n\t\t\tint hash0 = a0.hashCode();\n\t\t\tint hash1 = a1.hashCode();\n\t\t\tif(hash0 > hash1) return 1;\n\t\t\tif(hash1 > hash0) return -1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif(prio0 > prio1) return 1;\n\t\t\telse return -1;\n\t\t}\n\t}","commit_id":"0fa206c524e6ba9875c6759e105e641e42c17a51","url":"https://github.com/freenet/fred"},{"original_method":"SendableRequest removeFirstInner(int fuzz, RandomSource random, OfferedKeysList[] offeredKeys, RequestStarter starter, ClientRequestSchedulerNonPersistent schedTransient, boolean transientOnly, boolean notTransient, short maxPrio, int retryCount, ClientContext context, ObjectContainer container) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tboolean tryOfferedKeys = offeredKeys != null && (!notTransient) && random.nextBoolean();\n\t\tint choosenPriorityClass = removeFirstAccordingToPriorities(tryOfferedKeys, fuzz, random, offeredKeys, schedTransient, transientOnly, maxPrio, container);\n\t\tif(choosenPriorityClass == -1 && offeredKeys != null && (!tryOfferedKeys) && (!notTransient)) {\n\t\t\ttryOfferedKeys = true;\n\t\t\tchoosenPriorityClass = removeFirstAccordingToPriorities(tryOfferedKeys, fuzz, random, offeredKeys, schedTransient, transientOnly, maxPrio, container);\n\t\t}\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tif(maxPrio >= RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\tmaxPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\n\t\tfor(;choosenPriorityClass <= maxPrio;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tif(tryOfferedKeys) {\n\t\t\t\tif(offeredKeys[choosenPriorityClass].hasValidKeys(this, null, context))\n\t\t\t\t\treturn offeredKeys[choosenPriorityClass];\n\t\t\t}\n\t\t\tSortedVectorByNumber perm = null;\n\t\t\tif(!transientOnly)\n\t\t\t\tperm = priorities[choosenPriorityClass];\n\t\t\tSortedVectorByNumber trans = null;\n\t\t\tif(!notTransient)\n\t\t\t\ttrans = schedTransient.priorities[choosenPriorityClass];\n\t\t\tif(perm == null && trans == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\tint permRetryIndex = 0;\n\t\t\tint transRetryIndex = 0;\n\t\t\twhile(true) {\n\t\t\t\tint permRetryCount = perm == null ? Integer.MAX_VALUE : perm.getNumberByIndex(permRetryIndex);\n\t\t\t\tint transRetryCount = trans == null ? Integer.MAX_VALUE : trans.getNumberByIndex(transRetryIndex);\n\t\t\t\tif(choosenPriorityClass == maxPrio) {\n\t\t\t\t\tif(permRetryCount >= retryCount) {\n\t\t\t\t\t\tpermRetryCount = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(transRetryCount >= retryCount) {\n\t\t\t\t\t\ttransRetryCount = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(permRetryCount == Integer.MAX_VALUE && transRetryCount == Integer.MAX_VALUE) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: ran out of retrycounts on chosen priority\");\n\t\t\t\t\tbreak; // Try next priority\n\t\t\t\t}\n\t\t\t\tSectoredRandomGrabArrayWithInt chosenTracker = null;\n\t\t\t\tSortedVectorByNumber trackerParent = null;\n\t\t\t\tif(permRetryCount == transRetryCount) {\n\t\t\t\t\t// Choose between them.\n\t\t\t\t\tSectoredRandomGrabArrayWithInt permRetryTracker = (SectoredRandomGrabArrayWithInt) perm.getByIndex(permRetryIndex);\n\t\t\t\t\tif(persistent() && permRetryTracker != null)\n\t\t\t\t\t\tcontainer.activate(permRetryTracker, 1);\n\t\t\t\t\tSectoredRandomGrabArrayWithInt transRetryTracker = (SectoredRandomGrabArrayWithInt) trans.getByIndex(transRetryIndex);\n\t\t\t\t\tint permTrackerSize = permRetryTracker.size();\n\t\t\t\t\tint transTrackerSize = transRetryTracker.size();\n\t\t\t\t\tif(permTrackerSize + transTrackerSize == 0) {\n\t\t\t\t\t\tpermRetryIndex++;\n\t\t\t\t\t\ttransRetryIndex++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(random.nextInt(permTrackerSize + transTrackerSize) > permTrackerSize) {\n\t\t\t\t\t\tchosenTracker = permRetryTracker;\n\t\t\t\t\t\ttrackerParent = perm;\n\t\t\t\t\t\tpermRetryIndex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchosenTracker = transRetryTracker;\n\t\t\t\t\t\ttrackerParent = trans;\n\t\t\t\t\t\ttransRetryIndex++;\n\t\t\t\t\t}\n\t\t\t\t} else if(permRetryCount < transRetryCount) {\n\t\t\t\t\tchosenTracker = (SectoredRandomGrabArrayWithInt) perm.getByIndex(permRetryIndex);\n\t\t\t\t\tif(persistent() && chosenTracker != null)\n\t\t\t\t\t\tcontainer.activate(chosenTracker, 1);\n\t\t\t\t\ttrackerParent = perm;\n\t\t\t\t\tpermRetryIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tchosenTracker = (SectoredRandomGrabArrayWithInt) trans.getByIndex(transRetryIndex);\n\t\t\t\t\ttrackerParent = trans;\n\t\t\t\t\ttransRetryIndex++;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got retry count tracker \"+chosenTracker);\n\t\t\t\tSendableRequest req = (SendableRequest) chosenTracker.removeRandom(starter, container, context);\n\t\t\t\tif(chosenTracker.isEmpty()) {\n\t\t\t\t\ttrackerParent.remove(chosenTracker.getNumber(), container);\n\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\tchosenTracker.removeFrom(container);\n\t\t\t\t\tif(trackerParent.isEmpty()) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Should remove priority\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(req == null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests, adjusted retrycount \"+chosenTracker.getNumber()+\" (\"+chosenTracker+\") of priority \"+choosenPriorityClass);\n\t\t\t\t\tcontinue; // Try next retry count.\n\t\t\t\t}\n\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\tcontainer.activate(req, 1); // FIXME\n\t\t\t\tif(req.persistent() != trackerParent.persistent()) {\n\t\t\t\t\tLogger.error(this, \"Request.persistent()=\"+req.persistent()+\" but is in the queue for persistent=\"+trackerParent.persistent()+\" for \"+req);\n\t\t\t\t\t// FIXME fix it\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass(container) != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass(container)+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tSectoredRandomGrabArrayWithObject clientGrabber = (SectoredRandomGrabArrayWithObject) chosenTracker.getGrabber(req.getClient(container));\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\t\tcontainer.activate(clientGrabber, 1);\n\t\t\t\t\t\tRandomGrabArray baseRGA = (RandomGrabArray) clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\tbaseRGA.remove(req, container);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient(container)+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tif(req.persistent())\n\t\t\t\t\t\tinnerRegister(req, random, container, null);\n\t\t\t\t\telse\n\t\t\t\t\t\tschedTransient.innerRegister(req, random, container, null);\n\t\t\t\t\tcontinue; // Try the next one on this retry count.\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * For transient requests, we keep a list of recently succeeded BaseSendableGet's,\n\t\t\t\t * because transient requests are chosen individually.\n\t\t\t\t * But for persistent requests, we keep a list of RandomGrabArray's, because\n\t\t\t\t * persistent requests are chosen a whole SendableRequest at a time.\n\t\t\t\t * \n\t\t\t\t * FIXME: Only replaces persistent requests with persistent requests (of similar priority and retry count), or transient with transient.\n\t\t\t\t * Probably this is acceptable.\n\t\t\t\t */\n\t\t\t\tif(!req.persistent()) {\n\t\t\t\t\tList recent = schedTransient.recentSuccesses;\n\t\t\t\t\tSendableRequest altReq = null;\n\t\t\t\t\tif(!recent.isEmpty()) {\n\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\taltReq = (BaseSendableGet) recent.remove(recent.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled(container) || altReq.isEmpty(container))) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && altReq.getPriorityClass(container) <= choosenPriorityClass && \n\t\t\t\t\t\t\tfixRetryCount(altReq.getRetryCount()) <= chosenTracker.getNumber() && !altReq.isEmpty(container) && altReq != req) {\n\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t} else if(altReq != null) {\n\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\trecent.add(altReq);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRandomGrabArray altRGA = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!(recentSuccesses.isEmpty() || random.nextBoolean())) {\n\t\t\t\t\t\t\taltRGA = recentSuccesses.remove(recentSuccesses.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainer.activate(altRGA, 1);\n\t\t\t\t\tif(altRGA != null && container.ext().isStored(altRGA) && !altRGA.isEmpty()) {\n\t\t\t\t\t\tcontainer.activate(altRGA, 1);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Maybe using recently succeeded item from \"+altRGA);\n\t\t\t\t\t\tSendableRequest altReq = (SendableRequest) altRGA.removeRandom(starter, container, context);\n\t\t\t\t\t\tcontainer.activate(altReq, 1);\n\t\t\t\t\t\tif(altReq != null) {\n\t\t\t\t\t\t\tif(altReq.getPriorityClass(container) <= choosenPriorityClass &&\n\t\t\t\t\t\t\t\t\tfixRetryCount(altReq.getRetryCount()) <= chosenTracker.getNumber() && !altReq.isEmpty(container) && altReq != req) {\n\t\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (persistent) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t\t} else if(altReq != null) {\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen (persistent) req \"+req+\" is better, reregistering recently succeeded \"+altRGA+\" for \"+altReq);\n\t\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\t\trecentSuccesses.add(altRGA);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (\"+chosenTracker.getNumber()+\", prio \"+\n\t\t\t\t\t\treq.getPriorityClass(container)+\", retries \"+req.getRetryCount()+\", client \"+req.getClient(container)+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\treturn req;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","id":31404,"modified_method":"SendableRequest removeFirstInner(int fuzz, RandomSource random, OfferedKeysList[] offeredKeys, RequestStarter starter, ClientRequestSchedulerNonPersistent schedTransient, boolean transientOnly, boolean notTransient, short maxPrio, int retryCount, ClientContext context, ObjectContainer container) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tboolean tryOfferedKeys = offeredKeys != null && (!notTransient) && random.nextBoolean();\n\t\tint choosenPriorityClass = removeFirstAccordingToPriorities(tryOfferedKeys, fuzz, random, offeredKeys, schedTransient, transientOnly, maxPrio, container);\n\t\tif(choosenPriorityClass == -1 && offeredKeys != null && (!tryOfferedKeys) && (!notTransient)) {\n\t\t\ttryOfferedKeys = true;\n\t\t\tchoosenPriorityClass = removeFirstAccordingToPriorities(tryOfferedKeys, fuzz, random, offeredKeys, schedTransient, transientOnly, maxPrio, container);\n\t\t}\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tif(maxPrio >= RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\tmaxPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\n\t\tfor(;choosenPriorityClass <= maxPrio;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tif(tryOfferedKeys) {\n\t\t\t\tif(offeredKeys[choosenPriorityClass].hasValidKeys(this, null, context))\n\t\t\t\t\treturn offeredKeys[choosenPriorityClass];\n\t\t\t}\n\t\t\tSortedVectorByNumber perm = null;\n\t\t\tif(!transientOnly)\n\t\t\t\tperm = priorities[choosenPriorityClass];\n\t\t\tSortedVectorByNumber trans = null;\n\t\t\tif(!notTransient)\n\t\t\t\ttrans = schedTransient.priorities[choosenPriorityClass];\n\t\t\tif(perm == null && trans == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\tint permRetryIndex = 0;\n\t\t\tint transRetryIndex = 0;\n\t\t\twhile(true) {\n\t\t\t\tint permRetryCount = perm == null ? Integer.MAX_VALUE : perm.getNumberByIndex(permRetryIndex);\n\t\t\t\tint transRetryCount = trans == null ? Integer.MAX_VALUE : trans.getNumberByIndex(transRetryIndex);\n\t\t\t\tif(choosenPriorityClass == maxPrio) {\n\t\t\t\t\tif(permRetryCount >= retryCount) {\n\t\t\t\t\t\tpermRetryCount = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(transRetryCount >= retryCount) {\n\t\t\t\t\t\ttransRetryCount = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(permRetryCount == Integer.MAX_VALUE && transRetryCount == Integer.MAX_VALUE) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: ran out of retrycounts on chosen priority\");\n\t\t\t\t\tbreak; // Try next priority\n\t\t\t\t}\n\t\t\t\tSectoredRandomGrabArrayWithInt chosenTracker = null;\n\t\t\t\tSortedVectorByNumber trackerParent = null;\n\t\t\t\tif(permRetryCount == transRetryCount) {\n\t\t\t\t\t// Choose between them.\n\t\t\t\t\tSectoredRandomGrabArrayWithInt permRetryTracker = (SectoredRandomGrabArrayWithInt) perm.getByIndex(permRetryIndex);\n\t\t\t\t\tif(persistent() && permRetryTracker != null)\n\t\t\t\t\t\tcontainer.activate(permRetryTracker, 1);\n\t\t\t\t\tSectoredRandomGrabArrayWithInt transRetryTracker = (SectoredRandomGrabArrayWithInt) trans.getByIndex(transRetryIndex);\n\t\t\t\t\tint permTrackerSize = permRetryTracker.size();\n\t\t\t\t\tint transTrackerSize = transRetryTracker.size();\n\t\t\t\t\tif(permTrackerSize + transTrackerSize == 0) {\n\t\t\t\t\t\tpermRetryIndex++;\n\t\t\t\t\t\ttransRetryIndex++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(random.nextInt(permTrackerSize + transTrackerSize) > permTrackerSize) {\n\t\t\t\t\t\tchosenTracker = permRetryTracker;\n\t\t\t\t\t\ttrackerParent = perm;\n\t\t\t\t\t\tpermRetryIndex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchosenTracker = transRetryTracker;\n\t\t\t\t\t\ttrackerParent = trans;\n\t\t\t\t\t\ttransRetryIndex++;\n\t\t\t\t\t}\n\t\t\t\t} else if(permRetryCount < transRetryCount) {\n\t\t\t\t\tchosenTracker = (SectoredRandomGrabArrayWithInt) perm.getByIndex(permRetryIndex);\n\t\t\t\t\tif(persistent() && chosenTracker != null)\n\t\t\t\t\t\tcontainer.activate(chosenTracker, 1);\n\t\t\t\t\ttrackerParent = perm;\n\t\t\t\t\tpermRetryIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tchosenTracker = (SectoredRandomGrabArrayWithInt) trans.getByIndex(transRetryIndex);\n\t\t\t\t\ttrackerParent = trans;\n\t\t\t\t\ttransRetryIndex++;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got retry count tracker \"+chosenTracker);\n\t\t\t\tSendableRequest req = (SendableRequest) chosenTracker.removeRandom(starter, container, context);\n\t\t\t\tif(chosenTracker.isEmpty()) {\n\t\t\t\t\ttrackerParent.remove(chosenTracker.getNumber(), container);\n\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\tchosenTracker.removeFrom(container);\n\t\t\t\t\tif(trackerParent.isEmpty()) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Should remove priority\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(req == null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests, adjusted retrycount \"+chosenTracker.getNumber()+\" (\"+chosenTracker+\") of priority \"+choosenPriorityClass);\n\t\t\t\t\tcontinue; // Try next retry count.\n\t\t\t\t}\n\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\tcontainer.activate(req, 1); // FIXME\n\t\t\t\tif(req.persistent() != trackerParent.persistent()) {\n\t\t\t\t\tLogger.error(this, \"Request.persistent()=\"+req.persistent()+\" but is in the queue for persistent=\"+trackerParent.persistent()+\" for \"+req);\n\t\t\t\t\t// FIXME fix it\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass(container) != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass(container)+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tSectoredRandomGrabArrayWithObject clientGrabber = (SectoredRandomGrabArrayWithObject) chosenTracker.getGrabber(req.getClient(container));\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\t\tcontainer.activate(clientGrabber, 1);\n\t\t\t\t\t\tRandomGrabArray baseRGA = (RandomGrabArray) clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\tbaseRGA.remove(req, container);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient(container)+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tif(req.persistent())\n\t\t\t\t\t\tinnerRegister(req, random, container, null);\n\t\t\t\t\telse\n\t\t\t\t\t\tschedTransient.innerRegister(req, random, container, null);\n\t\t\t\t\tcontinue; // Try the next one on this retry count.\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * For transient requests, we keep a list of recently succeeded BaseSendableGet's,\n\t\t\t\t * because transient requests are chosen individually.\n\t\t\t\t * But for persistent requests, we keep a list of RandomGrabArray's, because\n\t\t\t\t * persistent requests are chosen a whole SendableRequest at a time.\n\t\t\t\t * \n\t\t\t\t * FIXME: Only replaces persistent requests with persistent requests (of similar priority and retry count), or transient with transient.\n\t\t\t\t * Probably this is acceptable.\n\t\t\t\t */\n\t\t\t\tif(!req.persistent()) {\n\t\t\t\t\tList recent = schedTransient.recentSuccesses;\n\t\t\t\t\tSendableRequest altReq = null;\n\t\t\t\t\tif(!recent.isEmpty()) {\n\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\taltReq = (BaseSendableGet) recent.remove(recent.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled(container) || altReq.isEmpty(container))) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tint prio = altReq.getPriorityClass(container);\n\t\t\t\t\tif(altReq != null && \n\t\t\t\t\t\t\t(prio < choosenPriorityClass || (prio == choosenPriorityClass && fixRetryCount(altReq.getRetryCount()) <= chosenTracker.getNumber()))\n\t\t\t\t\t\t\t\t\t&& !altReq.isEmpty(container) && altReq != req) {\n\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t} else if(altReq != null) {\n\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\trecent.add(altReq);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRandomGrabArray altRGA = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!(recentSuccesses.isEmpty() || random.nextBoolean())) {\n\t\t\t\t\t\t\taltRGA = recentSuccesses.remove(recentSuccesses.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainer.activate(altRGA, 1);\n\t\t\t\t\tif(altRGA != null && container.ext().isStored(altRGA) && !altRGA.isEmpty()) {\n\t\t\t\t\t\tcontainer.activate(altRGA, 1);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Maybe using recently succeeded item from \"+altRGA);\n\t\t\t\t\t\tSendableRequest altReq = (SendableRequest) altRGA.removeRandom(starter, container, context);\n\t\t\t\t\t\tcontainer.activate(altReq, 1);\n\t\t\t\t\t\tif(altReq != null) {\n\t\t\t\t\t\t\tint prio = altReq.getPriorityClass(container);\n\t\t\t\t\t\t\tif(altReq != null && \n\t\t\t\t\t\t\t\t\t(prio < choosenPriorityClass || (prio == choosenPriorityClass && fixRetryCount(altReq.getRetryCount()) <= chosenTracker.getNumber()))\n\t\t\t\t\t\t\t\t\t\t\t&& !altReq.isEmpty(container) && altReq != req) {\n\t\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (persistent) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t\t} else if(altReq != null) {\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen (persistent) req \"+req+\" is better, reregistering recently succeeded \"+altRGA+\" for \"+altReq);\n\t\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\t\trecentSuccesses.add(altRGA);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (\"+chosenTracker.getNumber()+\", prio \"+\n\t\t\t\t\t\treq.getPriorityClass(container)+\", retries \"+req.getRetryCount()+\", client \"+req.getClient(container)+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\treturn req;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","commit_id":"65a953603c72f47c30ae62a360f90d8b129e045b","url":"https://github.com/freenet/fred"},{"original_method":"private void populateAssetQueue()\n\tthrows org.osid.repository.RepositoryException, org.osid.shared.SharedException\n\n  {\n  \tHashMap\t\tparameterMap;\n  \tint\t\t\t\tassetsAdded;\n\n\t\t/*\n\t\t * Search properties\n\t\t */\n  \tparameterMap = new HashMap();\n  \tparameterMap.put(\"searchString\", \"\");\n  \tparameterMap.put(\"database\", database);\n\n  \tparameterMap.put(\"guid\", searchProperties.getProperty(\"guid\"));\n  \tparameterMap.put(\"url\", searchProperties.getProperty(\"baseUrl\"));\n\n  \tparameterMap.put(\"sortBy\", searchProperties.getProperty(\"sortBy\"));\n  \tparameterMap.put(\"maxRecords\", getIntegerProperty(searchProperties, \"maxRecords\"));\n\t\t/*\n\t\t * Search type (internal use only)\n\t\t */\n  \tparameterMap.put(\"action\", \"requestResults\");\n\t\t/*\n\t\t * Starting record, page size\n\t\t */\n\t\tsessionContext.putInt(\"startRecord\", startRecord);\n\t\tsessionContext.putInt(\"pageSize\", pageSize);\n\t\t/*\n\t\t * Send the \"more results\" request, parse the server response\n\t\t */\n\t\tqueryBase.parseRequest(parameterMap);\n\t\tqueryBase.doQuery();\n\n  \tsearchResult.initialize(queryBase);\n\t\tsearchResult.doParse();\n\t\t/*\n\t\t * Save the assets (matching records) returned frm the server\n\t\t *\n\t\t * These have been stored in an intermediate list of MatchItem objects,\n\t\t * largely as \"PartPairs\", a part id/part content pair.\n\t\t */\n\t\tassetsAdded = 0;\n\t  for (Iterator iterator = searchResult.iterator(); iterator.hasNext(); )\n\t  {\n  \t\torg.osid.repository.Asset \t\tasset;\n  \t\torg.osid.repository.Record\t\trecord;\n  \t\torg.osid.repository.Part\t\t\tpart;\n\n  \t\tMatchItem item;\n  \t\tIterator\tpartPairIterator;\n\n\t\t\titem \t= (MatchItem) iterator.next();\n\t\t\t/*\n\t\t\t * Create a new Asset (what \"content\"?)\n\t\t\t */\n\t\t\tasset = new Asset(item.getDisplayName(), item.getDescription(),\n  \t\t\t\t\t\t\t\t\t\t\tgetId(), repositoryId);\n\t\t\tasset.updateContent(\"\");\n\t\t\t/*\n\t\t\t * and Record\n\t\t\t */\n\t\t\trecord = asset.createRecord(RecordStructure.getInstance().getId());\n\t\t\t/*\n\t\t\t * Populate the Record with all available Parts\n\t\t\t */\n\t\t\tpartPairIterator = item.partPairIterator();\n\t\t\twhile (partPairIterator.hasNext())\n\t\t\t{\n\t\t\t\tMatchItem.PartPair partPair = (MatchItem.PartPair) partPairIterator.next();\n\t\t\t\trecord.createPart(partPair.getId(), partPair.getValue());\n\t\t\t}\n\t\t\t/*\n\t\t\t * Save this asset\n\t\t\t */\n\t\t\taddAsset(asset);\n\t\t\tassetsAdded++;\n\n//\t\t_log.debug(\"populate() Added \" + asset\n//\t\t\t\t\t+  \t \", vector size = \"  + assetVectorSize()\n//\t\t\t\t\t+    \", populated = \"    + populated);\n\n\t\t\tif (populated >= maximumRecords)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Update the starting record number\n\t\t */\n\t\tstartRecord += assetsAdded; // WAS: Math.min(pageSize, assetsAdded);\n\t\tsessionContext.putInt(\"startRecord\", startRecord);\n\t\tsessionContext.putInt(\"pageSize\", pageSize);\n  }","id":31405,"modified_method":"private void populateAssetQueue()\n\tthrows org.osid.repository.RepositoryException, org.osid.shared.SharedException\n\n  {\n  \tHashMap\t\tparameterMap;\n  \tint\t\t\t\tassetsAdded;\n\n\t\t/*\n\t\t * Search properties\n\t\t */\n  \tparameterMap = new HashMap();\n  \tparameterMap.put(\"searchString\", \"\");\n  \tparameterMap.put(\"database\", database);\n\n  \tparameterMap.put(\"guid\", searchProperties.getProperty(\"guid\"));\n  \tparameterMap.put(\"url\", searchProperties.getProperty(\"baseUrl\"));\n\n  \tparameterMap.put(\"sortBy\", searchProperties.getProperty(\"sortBy\"));\n  \tparameterMap.put(\"maxRecords\", getIntegerProperty(searchProperties, \"maxRecords\"));\n\t\t/*\n\t\t * Search type (internal use only)\n\t\t */\n  \tparameterMap.put(\"action\", \"requestResults\");\n\t\t/*\n\t\t * Starting record, page size\n\t\t */\n\t\tsessionContext.putInt(\"startRecord\", startRecord);\n\t\tsessionContext.putInt(\"pageSize\", pageSize);\n\t\t/*\n\t\t * Send the \"more results\" request, parse the server response\n\t\t */\n\t\tqueryBase.parseRequest(parameterMap);\n\t\tqueryBase.doQuery();\n\n  \tsearchResult.initialize(queryBase);\n\t\tsearchResult.doParse();\n\t\t/*\n\t\t * Save the assets (matching records) returned frm the server\n\t\t *\n\t\t * These have been stored in an intermediate list of MatchItem objects,\n\t\t * largely as \"PartPairs\", a part id/part content pair.\n\t\t */\n\t\tassetsAdded = 0;\n\t  for (Iterator iterator = searchResult.iterator(); iterator.hasNext(); )\n\t  {\n  \t\torg.osid.repository.Asset \t\tasset;\n  \t\torg.osid.repository.Record\t\trecord;\n  \t\torg.osid.repository.Part\t\t\tpart;\n\n  \t\tMatchItem item;\n  \t\tIterator\tpartPairIterator;\n\n\t\t\titem \t= (MatchItem) iterator.next();\n\t\t\t/*\n\t\t\t * Create a new Asset (what \"content\"?)\n\t\t\t */\n\t\t\tasset = new Asset(item.getDisplayName(), item.getDescription(),\n  \t\t\t\t\t\t\t\t\t\t\tgetId(), repositoryId);\n\t\t\tasset.updateContent(\"\");\n\t\t\t/*\n\t\t\t * and Record\n\t\t\t */\n\t\t\trecord = asset.createRecord(RecordStructure.getInstance().getId());\n\t\t\t/*\n\t\t\t * Populate the Record with all available Parts\n\t\t\t */\n\t\t\tpartPairIterator = item.partPairIterator();\n\t\t\twhile (partPairIterator.hasNext())\n\t\t\t{\n\t\t\t\tMatchItem.PartPair partPair = (MatchItem.PartPair) partPairIterator.next();\n\t\t\t\trecord.createPart(partPair.getId(), partPair.getValue());\n\t\t\t}\n\t\t\t/*\n\t\t\t * Save this asset\n\t\t\t */\n\t\t\taddAsset(asset);\n\t\t\tassetsAdded++;\n\n//\t\t_log.debug(\"populate() Added \" + asset\n//\t\t\t\t\t+  \t \", vector size = \"  + assetVectorSize()\n//\t\t\t\t\t+    \", populated = \"    + populated);\n\n\t\t\tif (populated >= getMaximumRecords())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Update the starting record number\n\t\t */\n\t\tstartRecord += assetsAdded; // WAS: Math.min(pageSize, assetsAdded);\n\t\tsessionContext.putInt(\"startRecord\", startRecord);\n\t\tsessionContext.putInt(\"pageSize\", pageSize);\n  }","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Initialize\n\t * @param searchProperties Property list (search characteristics, provided by our caller)\n\t */\n\tprotected void initialize(org.osid.shared.Properties searchProperties) throws org.osid.shared.SharedException\n\t{\n\t\ttry\n\t\t{\n\t\t\tInteger\tmax = getIntegerProperty(searchProperties, \"maxRecords\");\n    \tint \t\tm1 \t= sessionContext.getInt(\"maxRecords\");\n    \tint \t\tm2;\n\n\t\t\t/*\n\t\t\t * Determine maximum number of search result records to request\n\t\t\t */\n    \tm2 = (max == null) ? m1 : max.intValue();\n\n    \tthis.maximumRecords = Math.min(m1, m2);\n    \tthis.assetVector \t\t= new Vector(maximumRecords);\n    \tthis.index\t\t\t\t\t= 0;\n    \tthis.populated\t\t\t= 0;\n\t\t\t/*\n\t\t\t * Save starting record number, page size, properties pointer\n\t\t\t */\n\t\t\tstartRecord\t= getIntegerProperty(searchProperties, \"startRecord\").intValue();\n\t\t\tpageSize\t\t= getIntegerProperty(searchProperties, \"pageSize\").intValue();\n\n    \tthis.searchProperties\t= searchProperties;\n\n    \t_log.debug(\"AssetIterator max = \" + maximumRecords + \", page = \" + pageSize + \", start = \" + startRecord);\n    }\n    catch (Throwable throwable)\n    {\n    \t_log.error(\"initialize() \" + throwable);\n    \tthrow new org.osid.repository.RepositoryException(org.osid.shared.SharedException.OPERATION_FAILED);\n  \t}\n\n\t}","id":31406,"modified_method":"/**\n\t * Initialize\n\t * @param searchProperties Property list (search characteristics, provided by our caller)\n\t */\n\tprotected void initialize(org.osid.shared.Properties searchProperties) throws org.osid.shared.SharedException\n\t{\n\t\ttry\n\t\t{\n    \tthis.assetVector  = new Vector();\n    \tthis.index\t\t\t\t= 0;\n    \tthis.populated\t\t= 0;\n\t\t\t/*\n\t\t\t * Save starting record number, page size, properties pointer\n\t\t\t */\n\t\t\tstartRecord\t= getIntegerProperty(searchProperties, \"startRecord\").intValue();\n\t\t\tpageSize\t\t= getIntegerProperty(searchProperties, \"pageSize\").intValue();\n\n    \tthis.searchProperties\t= searchProperties;\n\n    \t_log.debug(\"AssetIterator max = \" + getMaximumRecords() + \", page = \" + pageSize + \", start = \" + startRecord);\n    }\n    catch (Throwable throwable)\n    {\n    \t_log.error(\"initialize() \" + throwable);\n    \tthrow new org.osid.repository.RepositoryException(org.osid.shared.SharedException.OPERATION_FAILED);\n  \t}\n\t}","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Is another Asset available?  If so, set the search status as \"complete\".\n\t * @return true if an Asset is available, false if not\n\t */\n  public boolean hasNextAsset()\n  throws org.osid.repository.RepositoryException\n  {\n\t\ttry\n\t\t{\n\t\t\tboolean moreRecords = (index < maximumRecords);\n\n    \t_log.debug(\"AssetIterator.hasNext() = \" + moreRecords);\n    \tif (!moreRecords)\n    \t{\n    \t\tStatusUtils.setAllComplete(sessionContext);\n    \t}\n      return moreRecords;\n    }\n    catch (Throwable throwable)\n    {\n    \t_log.error(\"hasNextAsset() \" + throwable);\n    \tthrow new org.osid.repository.RepositoryException(org.osid.shared.SharedException.OPERATION_FAILED);\n  \t}\n  }","id":31407,"modified_method":"/**\n\t * Is another Asset available?  If so, set the search status as \"complete\".\n\t * @return true if an Asset is available, false if not\n\t */\n  public boolean hasNextAsset()\n  throws org.osid.repository.RepositoryException\n  {\n\t\ttry\n\t\t{\n\t\t  boolean moreRecords;\n\n    _log.debug(\"hasNextAsset: index=\" + index\n            +  \", maximum records=\" + getMaximumRecords()\n            +  \", async init=\" + StatusUtils.doingAsyncInit(sessionContext));\n      /*\n       * During asynchronous initialization, we assume there are more assets\n       */\n      if (StatusUtils.doingAsyncInit(sessionContext))\n      {\n        return true;\n      }\n      /*\n       * Normal use, are there any more assets?\n       */\n\t\t\tmoreRecords = (index < getMaximumRecords());\n    \t_log.debug(\"AssetIterator.hasNext() = \" + moreRecords);\n\n    \tif (!moreRecords)\n    \t{\n    \t\tStatusUtils.setAllComplete(sessionContext);\n    \t}\n      return moreRecords;\n    }\n    catch (Throwable throwable)\n    {\n    \t_log.error(\"hasNextAsset() \" + throwable);\n    \tthrow new org.osid.repository.RepositoryException(org.osid.shared.SharedException.OPERATION_FAILED);\n  \t}\n  }","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Fetch the next available search result (from the \"Asset queue\")\n\t * @return The next search result (as an Asset)\n\t */\n  public org.osid.repository.Asset nextAsset()\n  throws org.osid.repository.RepositoryException\n  {\n\t\torg.osid.repository.Asset asset;\n\n\t\t/*\n\t\t * End-of-file?\n\t\t */\n    if (index >= maximumRecords)\n    {\n    \tStatusUtils.setAllComplete(sessionContext);\n    \tthrow new org.osid.repository.RepositoryException(org.osid.shared.SharedException.NO_MORE_ITERATOR_ELEMENTS);\n    }\n\t\t/*\n\t\t * Additional assets should be available from the server\n\t\t */\n    if ((index >= populated) || (populated == 0))\n    {\n    \t/*\n    \t * The cache is depleted, request more assets\n    \t */\n    \tif (sessionContext.getInt(\"active\") == 0)\n    \t{\n\t\t\t\t/*\n\t\t\t\t * End-of-file?  Every search has been marked \"complete\" (unxepected).\n\t\t\t\t */\n        throw new org.osid.repository.RepositoryException(org.osid.shared.SharedException.NO_MORE_ITERATOR_ELEMENTS);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Populate the Asset queue with new results\n\t\t\t */\n\t\t\ttry\n\t\t\t{\n      \tpopulateAssetQueue();\n      }\n\t\t\tcatch (SessionTimeoutException sessionTimeoutException)\n\t\t\t{\n\t    \t_log.error(\"nextAsset() session timeout: \" + sessionTimeoutException);\n\t    \tthrow new MetasearchException(MetasearchException.SESSION_TIMED_OUT);\n\t\t\t}\n\t\t\tcatch (SearchException searchException)\n\t\t\t{\n\t    \t_log.error(\"nextAsset() search exception: \" + searchException);\n\t    \tthrow new MetasearchException(MetasearchException.METASEARCH_ERROR);\n\t\t\t}\n\t\t\tcatch (Throwable throwable)\n\t\t\t{\n\t    \t_log.error(\"nextAsset() general: \", throwable);\n\t\t\t\tthrow new org.osid.repository.RepositoryException(org.osid.OsidException.OPERATION_FAILED);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Finally, return the next Asset from the queue\n\t\t */\n    asset = getAsset();\n  \t_log.debug(\"AssetIterator.nextAsset() returns asset = \" + asset + \", index = \" + index + \", vector size = \" + assetVectorSize());\n    return asset;\n  }","id":31408,"modified_method":"/**\n\t * Fetch the next available search result (from the \"Asset queue\")\n\t * @return The next search result (as an Asset)\n\t */\n  public org.osid.repository.Asset nextAsset()\n  throws org.osid.repository.RepositoryException\n  {\n\t\torg.osid.repository.Asset asset;\n\n\t\t/*\n\t\t * End-of-file?\n\t\t */\n    if (!StatusUtils.doingAsyncInit(sessionContext))\n    {\n      if (index >= getMaximumRecords())\n      {\n      \tStatusUtils.setAllComplete(sessionContext);\n      \tthrow new org.osid.repository.RepositoryException(org.osid.shared.SharedException.NO_MORE_ITERATOR_ELEMENTS);\n      }\n    }\n\t\t/*\n\t\t * Additional assets should be available from the server\n\t\t */\n    _log.debug(\"nextAsset: index=\" + index\n            +  \", populated=\" + populated\n            +  \", async init=\" + StatusUtils.doingAsyncInit(sessionContext));\n\n    if ((index >= populated) || (populated == 0))\n    {\n      if (!StatusUtils.doingAsyncInit(sessionContext))\n      {\t/*\n      \t * The cache is depleted - we need to fetch more assets\n      \t */\n      \tif (sessionContext.getInt(\"active\") == 0)\n      \t{\t/*\n  \t\t\t\t * Every search has been marked \"complete\" (unexepected).\n  \t\t\t\t */\n          throw new org.osid.repository.RepositoryException(org.osid.shared.SharedException.NO_MORE_ITERATOR_ELEMENTS);\n  \t\t\t}\n      }\n\t\t\t/*\n\t\t\t * Populate the Asset queue with new results\n\t\t\t */\n\t\t\ttry\n\t\t\t{\n      \tpopulateAssetQueue();\n      }\n\t\t\tcatch (SessionTimeoutException sessionTimeoutException)\n\t\t\t{\n\t    \t_log.error(\"nextAsset() session timeout: \" + sessionTimeoutException);\n\t    \tthrow new MetasearchException(MetasearchException.SESSION_TIMED_OUT);\n\t\t\t}\n\t\t\tcatch (SearchException searchException)\n\t\t\t{ /*\n\t\t\t   * No assets ready?\n\t\t\t   */\n\t\t\t  if (searchException.getMessage().equals(SearchException.ASSET_NOT_READY))\n\t\t\t  {\n\t\t\t    throw new MetasearchException(MetasearchException.ASSET_NOT_FETCHED);\n\t\t\t  }\n\t\t\t  /*\n\t\t\t   * Unexpected error\n\t\t\t   */\n\t    \t_log.error(\"nextAsset() search exception: \" + searchException);\n\t    \tthrow new MetasearchException(MetasearchException.METASEARCH_ERROR);\n\t\t\t}\n\t\t\tcatch (Throwable throwable)\n\t\t\t{\n\t    \t_log.error(\"nextAsset() general: \", throwable);\n\t\t\t\tthrow new org.osid.repository.RepositoryException(org.osid.OsidException.OPERATION_FAILED);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Finally, return the next Asset from the queue\n\t\t */\n    asset = getAsset();\n  \t_log.debug(\"AssetIterator.nextAsset() returns asset at index \" + index + \", vector size = \" + assetVectorSize());\n    return asset;\n  }","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Save the initial search status (estimated hits, etc.) as session context information\r\n\t * @param document Server response\r\n\t * @rootElement Document root\r\n\t */\r\n\tprivate boolean setStatus(Document document) throws SearchException\r\n\t{\r\n    Element   rootElement = document.getDocumentElement();\r\n\t\tNodeList  nodeList \t\t= DomUtils.getElementList(rootElement, \"ITEM\");\r\n\t\tString    status      = \"0\";\r\n\t\tint       targetCount = nodeList.getLength();\r\n\t\tint       active\t\t\t= 0;\r\n\t\tint       total \t\t\t= 0;\r\n\t\tint       totalHits   = 0;\r\n\t\tint       complete    = 0;\r\n\r\n\t\t/*\r\n\t\t * Update the status map for each target\r\n\t\t */\r\n\t\tfor (int i = 0; i < targetCount; i++)\r\n\t\t{\r\n\t\t\tElement\t\trecordElement\t= (Element) nodeList.item(i);\r\n\t\t\tHashMap\t\tmap;\r\n\r\n\t\t\tString\t\ttext, target;\r\n\t\t\tElement\t\telement;\r\n\t\t\tint\t\t\t  estimate, hits;\r\n\r\n\t\t\t/*\r\n\t\t\t * Target (database)\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t\t\t                                                      \"ENTRY\",\r\n\t\t\t                                                      \"key\", \"targetID\");\r\n\t\t\ttarget\t= DomUtils.getText(element);\r\n\t\t\tmap \t  = StatusUtils.getStatusMapForTarget(getSessionContext(), target);\r\n\t\t\t/*\r\n\t\t\t * Get the current search status (we show this as \"percent complete\")\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t\t\t                                                       \"ENTRY\",\r\n\t\t\t                                                       \"key\", \"status\");\r\n\t\t\tif ((status\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\tstatus = \"0\";\r\n\t\t\t\t/*\r\n\t\t\t\t * No status value - did the search ever start?\r\n\t\t\t\t */\r\n  \t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t  \t\t                                                      \"ENTRY\",\r\n\t\t  \t                                                      \"key\", \"message\");\r\n\t\t\t  if ((text\t= DomUtils.getText(element)) != null)\r\n\t\t\t  {\r\n\t\t\t\t  if (\"Not Started\".equals(text))\r\n\t\t\t\t  {\r\n\t\t\t\t    status = \"100\";\r\n\t\t\t    }\r\n\t\t    }\r\n\t\t\t}\r\n\t\t\tmap.put(\"PERCENT_COMPLETE\", status);\r\n\t\t\t/*\r\n\t\t\t * Estimated match count\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t\t\t                                                      \"ENTRY\",\r\n\t\t\t                                                      \"key\", \"estimate\");\r\n\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t}\r\n\t\t\tmap.put(\"ESTIMATE\", text);\r\n\r\n\t\t\testimate = Integer.parseInt(text);\r\n      /*\r\n       * Any hits?\r\n       */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t\t\t                                                      \"ENTRY\",\r\n\t\t\t                                                      \"key\", \"hits\");\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t}\r\n\t\t\thits = Integer.parseInt(text);\r\n\t\t\t/*\r\n\t\t\t * Do final hit and estimate totals\r\n\t\t\t */\r\n \t\t\tmap.put(\"STATUS\", \"DONE\");\r\n      /*\r\n       * If we have hits, add this estimate to the grand total\r\n       */\r\n      if (hits > 0)\r\n      {\r\n        totalHits += hits;\r\n   \t\t\ttotal\t    += estimate;\r\n      }\r\n\t\t\t/*\r\n\t\t\t * This search target is active only if there are records available\r\n\t\t\t */\r\n\t\t\tif ((estimate > 0) && (hits > 0))\r\n\t\t\t{\r\n\t\t\t  int pageSize = Integer.parseInt(getPageSize());\r\n\r\n\t\t\t\tmap.put(\"STATUS\", \"ACTIVE\");\r\n\t\t\t\tactive++;\r\n        /*\r\n         * Try and exit the \"check status\" loop early: we consider this\r\n         * target complete if:\r\n         *\r\n         * -- It has hits\r\n         * -- We've already found enough result records (from all targets) to\r\n         *    fill our \"page\"\r\n         */\r\n        _log.debug(\"**** \" + target + \": \" + totalHits + \" hit(s) vs page size \" + pageSize);\r\n        if (totalHits >= pageSize)\r\n        {\r\n          status = \"100\";\r\n          _log.debug(\"**** Marking \"  + target + \" \\\"complete due to hit count\\\"\");\r\n        }\r\n\t\t\t}\r\n      /*\r\n       * Is this search complete?\r\n       */\r\n\t\t\tif (\"100\".equals(status))\r\n      {\r\n        complete++;\r\n      }\r\n\r\n  \t\t_log.debug(\"****** Target: \"\r\n  \t\t        +  target\r\n  \t\t        +  \", status = \"\r\n  \t\t        +  status);\r\n    }\r\n\t\t/*\r\n\t\t * Save in session context:\r\n\t\t *\r\n\t\t * -- The largest number of records we could possibly return\r\n\t\t * -- The count of \"in progress\" searches\r\n\t\t */\r\n\t\tgetSessionContext().put(\"maxRecords\", String.valueOf(total));\r\n\t\tgetSessionContext().putInt(\"TOTAL_ESTIMATE\", total);\r\n\t\tgetSessionContext().putInt(\"active\", active);\r\n\r\n\t\treturn complete == targetCount;\r\n\t}","id":31409,"modified_method":"/**\r\n\t * Save the current search status (estimated hits, etc.) as session\r\n\t * context information (status obtained by the PROGRESS command).\r\n\t *\r\n\t * @param document Server response\r\n\t * @param rootElement Document root\r\n\t * @return true If all targets have responded\r\n\t */\r\n\tprivate boolean setSearchStatus(Document document) throws SearchException\r\n\t{\r\n    Element   rootElement = document.getDocumentElement();\r\n\t\tNodeList  nodeList \t\t= DomUtils.getElementList(rootElement, \"ITEM\");\r\n\t\tString    status      = \"0\";\r\n\r\n\t\tint       targetCount = nodeList.getLength();\r\n\t\tint       active\t\t\t= 0;\r\n\t\tint       total \t\t\t= 0;\r\n\t\tint       totalHits   = 0;\r\n\t\tint       complete    = 0;\r\n\r\n\t\t/*\r\n\t\t * Update the status map for each target\r\n\t\t */\r\n\t\tfor (int i = 0; i < targetCount; i++)\r\n\t\t{\r\n\t\t\tElement\t\trecordElement\t= (Element) nodeList.item(i);\r\n\t\t\tHashMap\t\tmap;\r\n\r\n\t\t\tString\t\ttext, target;\r\n\t\t\tElement\t\telement;\r\n\t\t\tint\t\t\t  estimate, hits;\r\n\r\n\t\t\t/*\r\n\t\t\t * Look for the target (database name)\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t\t\t                                                      \"ENTRY\",\r\n\t\t\t                                                      \"key\", \"targetID\");\r\n\t\t\ttarget\t= DomUtils.getText(element);\r\n\t\t\tmap \t  = StatusUtils.getStatusMapForTarget(getSessionContext(), target);\r\n\t\t\t/*\r\n\t\t\t * Get the current search status (we show this as \"percent complete\")\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n  \t\t                                                      \"ENTRY\",\r\n\t\t\t                                                      \"key\", \"status\");\r\n\t\t\tif ((status\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\tstatus = \"0\";\r\n\t\t\t\t/*\r\n\t\t\t\t * No status value; if the search will never start, mark it complete\r\n\t\t\t\t */\r\n  \t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t  \t\t                                                      \"ENTRY\",\r\n\t\t  \t                                                      \"key\", \"message\");\r\n\t\t\t  if ((text\t= DomUtils.getText(element)) != null)\r\n\t\t\t  {\r\n\t\t\t\t  if (\"Not Started\".equals(text))\r\n\t\t\t\t  {\r\n\t\t\t\t    status = \"100\";\r\n\t\t\t    }\r\n\t\t    }\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * Find the estimated match count\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t\t\t                                                      \"ENTRY\",\r\n\t\t\t                                                      \"key\", \"estimate\");\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t}\r\n\t\t\testimate = Integer.parseInt(text);\r\n      /*\r\n       * Any hits? (unused for now)\r\n       */\r\n/*******************************************************************************\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue(recordElement,\r\n\t\t\t                                                      \"ENTRY\",\r\n\t\t\t                                                      \"key\", \"hits\");\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t}\r\n\t\t\thits = Integer.parseInt(text);\r\n*******************************************************************************/\r\n      /*\r\n       * Add this estimate to the grand total.\r\n       *\r\n       * Do we need to check for?\r\n       *\r\n       *    (hits > 0)\r\n       *    (status.equals(\"100\"))\r\n       */\r\n\t\t\tmap.put(\"ESTIMATE\", \"0\");\r\n \t\t\tmap.put(\"STATUS\", \"DONE\");\r\n\r\n \t\t\tif (estimate > 0)\r\n \t\t\t{\r\n  \t\t\tmap.put(\"ESTIMATE\", String.valueOf(estimate));\r\n   \t\t\ttotal\t+= estimate;\r\n\r\n\t\t\t\tmap.put(\"STATUS\", \"ACTIVE\");\r\n\t\t\t\tactive++;\r\n\r\n\t\t\t\tstatus = \"100\";\r\n \t\t\t}\r\n      /*\r\n       * Is this search complete?\r\n       */\r\n\t\t\tmap.put(\"PERCENT_COMPLETE\", status);\r\n\r\n\t\t\tif (\"100\".equals(status))\r\n      {\r\n        complete++;\r\n      }\r\n\r\n  \t\t_log.debug(\"****** Target: \"\r\n  \t\t        +  target\r\n  \t\t        +  \", status = \"\r\n  \t\t        +  status\r\n  \t\t        +  \", all searches complete? \"\r\n  \t\t        +  (complete == targetCount));\r\n    }\r\n\t\t/*\r\n\t\t * Save in session context:\r\n\t\t *\r\n\t\t * -- The largest number of records we could possibly return\r\n\t\t * -- The count of \"in progress\" searches\r\n\t\t */\r\n\t\tgetSessionContext().putInt(\"TOTAL_ESTIMATE\", total);\r\n\t\tgetSessionContext().putInt(\"maxRecords\", total);\r\n\t\tgetSessionContext().putInt(\"active\", active);\r\n\r\n\t\treturn (complete == targetCount);\r\n\t}","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Search\r\n\t */\r\n\tpublic void doQuery()\r\n\t{\r\n\t\tDocument \tdocument;\r\n\t\tString\t\taction;\r\n\t\t/*\r\n\t\t * Get the logical \"database\" (a name for the configuration for this search)\r\n\t\t */\r\n\t\t_database = getRequestParameter(\"database\");\r\n\t\t/*\r\n\t\t * We'll manage redirects, and submit with POST\r\n\t\t */\r\n\t\tsetRedirectBehavior(REDIRECT_MANAGED);\r\n\t\tsetQueryMethod(METHOD_POST);\r\n\t\t/*\r\n\t\t * Save the URL and query text\r\n\t\t */\r\n\t\tsetUrl(getRequestParameter(\"url\"));\r\n\t\tsetSearchString(getSearchString());\r\n\t\t/*\r\n\t\t * New search?\r\n\t\t */\r\n\t\taction = getRequestParameter(\"action\");\r\n\t\tif (action.equalsIgnoreCase(\"startSearch\"))\r\n\t\t{\r\n  \t\tint sleepCount, sleepLimit;\r\n  \t\tboolean done;\r\n\t\t  /*\r\n\t\t   * Initialize a new search context block\r\n\t\t   */\r\n\t\t\tStatusUtils.initialize(getSessionContext(), getRequestParameter(\"targets\"));\r\n\t\t\t/*\r\n\t\t\t * LOGOFF any previous session\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoLogoffCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tsetSessionId(null);\r\n\t\t\tdisplayXml(\"Logoff\", getResponseDocument());\r\n\t\t\t/*\r\n\t\t\t * LOGON\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoLogonCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tdisplayXml(\"Login\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"LOGON\");\r\n\t\t\t/*\r\n\t\t\t * Search\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoSearchCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tdisplayXml(\"Search\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"SEARCH\");\r\n\t\t\t/*\r\n\t\t\t * Pick up the current status\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoProgressCommand();\r\n\t\t\tsubmit();\r\n      /*\r\n       * Wait for a complete set of responses.  If not found, wait:\r\n       *\r\n       *     8 seconds (one source)\r\n       *    20 seconds (at most)\r\n       *\r\n       * The times are set via the math.min() and Thread.sleep() calls below.\r\n       */\r\n\t\t  sleepCount = 0;\r\n\t\t  sleepLimit = 5 + Math.min((getTargetCount() * 3), 20);\r\n\r\n\t\t  done = setStatus(getResponseDocument());\r\n      while (!done && (sleepCount++ < sleepLimit))\r\n\t\t\t{\r\n\t\t\t  displayXml(\"Progress\", getResponseDocument());\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tThread.sleep(1000);\r\n\t\t\t\t\t_log.debug(\"Sleeping (\" + sleepCount + \" of \" + sleepLimit + \")\");\r\n\t\t\t\t}\r\n\t\t\t\tcatch (InterruptedException ignore) { }\r\n\r\n  \t\t\tclearParameters();\r\n\t\t\t\tdoProgressCommand();\r\n\t\t\t\tsubmit();\r\n\r\n  \t\t  done = setStatus(getResponseDocument());\r\n\t\t\t}\r\n\r\n\t\t  displayXml(\"Status done\", getResponseDocument());\r\n\r\n\t\t\tvalidateResponse(\"PROGRESS\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t/*\r\n\t\t * Request additional results\r\n\t\t */\r\n\t\tdoResultsCommand();\r\n\t\tdisplayXml(\"Results\", getResponseDocument());\r\n\t}","id":31410,"modified_method":"/**\r\n\t * Search\r\n\t */\r\n\tpublic void doQuery()\r\n\t{\r\n\t\tDocument \tdocument;\r\n\t\tString\t\taction;\r\n\t\t/*\r\n\t\t * Get the logical \"database\" (a name for the configuration for this search)\r\n\t\t */\r\n\t\t_database = getRequestParameter(\"database\");\r\n\t\t/*\r\n\t\t * We'll manage redirects, and submit with POST\r\n\t\t */\r\n\t\tsetRedirectBehavior(REDIRECT_MANAGED);\r\n\t\tsetQueryMethod(METHOD_POST);\r\n\t\t/*\r\n\t\t * Save the URL and query text\r\n\t\t */\r\n\t\tsetUrl(getRequestParameter(\"url\"));\r\n\t\tsetSearchString(getSearchString());\r\n\t\t/*\r\n\t\t * New search?\r\n\t\t */\r\n\t\taction = getRequestParameter(\"action\");\r\n\t\tif (action.equalsIgnoreCase(\"startSearch\"))\r\n\t\t{\r\n\t\t  /*\r\n\t\t   * Initialize a new search context block.  Augment the standard\r\n\t\t   * (synchronous) initialization with the necessary asynchronous\r\n\t\t   * setup (an asynchronous search with initialization in progress).\r\n\t\t   */\r\n\t\t\tStatusUtils.initialize(getSessionContext(), getRequestParameter(\"targets\"));\r\n\t\t\tStatusUtils.setAsyncSearch(getSessionContext());\r\n\t\t\tStatusUtils.setAsyncInit(getSessionContext());\r\n\t\t\t/*\r\n\t\t\t * LOGOFF any previous session\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoLogoffCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tsetSessionId(null);\r\n\t\t\tdisplayXml(\"Logoff\", getResponseDocument());\r\n\t\t\t/*\r\n\t\t\t * LOGON\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoLogonCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tdisplayXml(\"Login\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"LOGON\");\r\n\t\t\t/*\r\n\t\t\t * Search\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoSearchCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tdisplayXml(\"Search\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"SEARCH\");\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n    /*\r\n     * Still doing asynchronous initialization?  If so, pick up the search\r\n     * status.  Throw \"no assets ready\" (to try again) if the estimates aren't\r\n     * available yet...\r\n     */\r\n    if (StatusUtils.doingAsyncInit(getSessionContext()))\r\n    {\r\n    \tclearParameters();\r\n\r\n  \t\tdoProgressCommand();\r\n  \t  submit();\r\n  \t\tdisplayXml(\"Progress command done\", getResponseDocument());\r\n\r\n  \t\tvalidateResponse(\"PROGRESS\");\r\n\t\t  if (!setSearchStatus(getResponseDocument()))\r\n\t\t\t{\r\n\t\t\t  throw new SearchException(SearchException.ASSET_NOT_READY);\r\n\t\t\t}\r\n      /*\r\n       * Asynchronous initialization is finished now.  If we found no hits,\r\n       * loop one more time to let hasNextAsset() reflect that fact...\r\n       */\r\n \t    StatusUtils.clearAsyncInit(getSessionContext());\r\n\r\n\t\t\tif (StatusUtils.getActiveTargetCount(getSessionContext()) == 0)\r\n\t\t\t{\r\n\t\t\t  throw new SearchException(SearchException.ASSET_NOT_READY);\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * Fetch additional results\r\n\t\t */\r\n\t\tdoResultsCommand();\r\n\t\tdisplayXml(\"Results\", getResponseDocument());\r\n\t}","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private String getPageSize()\r\n  {\r\n    return \"30\";\r\n/*******************************************************************************\r\n    int targets   = StatusUtils.getActiveTargetCount(getSessionContext());\r\n    int pageSize  = targets * MINIMUM_PAGESIZE;\r\n\r\n    if ((pageSize = Math.min(pageSize, MAXIMUM_PAGESIZE)) == 0)\r\n    {\r\n      pageSize = MINIMUM_PAGESIZE;\r\n    }\r\n    return String.valueOf(pageSize);\r\n*******************************************************************************/\r\n  }","id":31411,"modified_method":"/**\r\n   * Determine the page size (the number of results to request from the server)\r\n   * @return The page size (as a String)\r\n   */\r\n  private String getPageSize()\r\n  {\r\n    return \"30\";\r\n  }","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Parse the response\r\n\t */\r\n\tpublic void doParse()\r\n\t{\r\n\t\tDocument responseDocument = getSearchResponseDocument();\r\n\t\tElement resultElement;\r\n\t\tNodeList recordList;\r\n\r\n\t\t/*\r\n\t\t * Examine each RECORD\r\n\t\t */\r\n\t\tresultElement = responseDocument.getDocumentElement();\r\n\t\trecordList = DomUtils.getElementList(resultElement, \"RECORD\");\r\n\r\n    if (recordList.getLength() == 0)\r\n    {\r\n      String errorText = \"Unexpected server response (no search result records provided)\";\r\n\r\n\t\t\tLogUtils.displayXml(_log, errorText, responseDocument);\r\n\r\n\t\t\tStatusUtils.setGlobalError(sessionContext, errorText);\r\n\t\t\tthrow new SearchException(errorText);\r\n    }\r\n\r\n\t\tfor (int i = 0; i < recordList.getLength(); i++)\r\n\t\t{\r\n\t\t\tMatchItem item;\r\n\t\t\tElement dataElement, recordElement;\r\n\t\t\tNodeList nodeList;\r\n\t\t\tString title, description;\r\n\t\t\tString database, hit, target;\r\n\t\t\tString recordId, recordType;\r\n\t\t\tString content;\r\n\r\n\t\t\t/*\r\n\t\t\t * Pick up the database name & related information\r\n\t\t\t */\r\n\t\t\trecordElement = (Element) recordList.item(i);\r\n\r\n\t\t\thit = recordElement.getAttribute(\"hit\");\r\n\t\t\ttarget = recordElement.getAttribute(\"sourceID\");\r\n\t\t\tdatabase = recordElement.getAttribute(\"source\");\r\n\t\t\trecordId = recordElement.getAttribute(\"identifier\");\r\n\t\t\t/*\r\n\t\t\t * Update hit count\r\n\t\t\t */\r\n\t\t\tStatusUtils.updateHits(sessionContext, target);\r\n\t\t\t/*\r\n\t\t\t * The information we want resides in the DATA portion of the\r\n\t\t\t * document\r\n\t\t\t */\r\n\t\t\tif ((dataElement = DomUtils.getElement(recordElement, \"DATA\")) == null) {\r\n\t\t\t\t_log.error(\"No DATA element present in server response\");\r\n  \t\t\tdisplayXml(recordElement);\r\n\t\t\t\tthrow new SearchException(\r\n\t\t\t\t\t\t\"Missing mandatory <DATA> element in server response\");\r\n\t\t\t}\r\n\r\n\t\t\ttitle = getText(dataElement, \"TITLE\");\r\n\t\t\tif (StringUtils.isNull(title)) {\r\n\t\t\t\t_log.debug(\"No TITLE text in server response\");\r\n\t\t\t\ttitle = \"\";\r\n\t\t\t}\r\n\r\n\t\t\tdescription = getText(dataElement, \"DESCRIPTION\");\r\n\t\t\tif (StringUtils.isNull(description)) {\r\n\t\t\t\t_log.debug(\"No DESCRIPTION text in server response\");\r\n\t\t\t\tdescription = \"\";\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * Save select search result data\r\n\t\t\t */\r\n\t\t\titem = new MatchItem();\r\n\t\t\t/*\r\n\t\t\t * Title, abstract, record ID\r\n\t\t\t */\r\n\t\t\t_log.debug(\"Adding TITLE: \" + title);\r\n\r\n\t\t\titem.setDisplayName(title);\r\n\t\t\titem.setDescription(description);\r\n\t\t\titem.setId(recordId);\r\n\t\t\t/*\r\n\t\t\t * Publisher, language\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"PUBLICATION\", item,\r\n\t\t\t\t\tPublisherPartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"LANGUAGE\", item,\r\n\t\t\t\t\tLanguagePartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * In-line Citation information\r\n\t\t\t */\r\n\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION\", item,\r\n\t\t\t\t\tInLineCitationPartStructure.getPartStructureId())) {\r\n\r\n\t\t\t\tif (!addPartStructure(dataElement, \"SOURCE\", item,\r\n\t\t\t\t\t\tInLineCitationPartStructure.getPartStructureId())) {\r\n\r\n\t\t\t\t\tif (!addPartStructure(dataElement, \"DESCRIPTION\", item,\r\n\t\t\t\t\t\t\tInLineCitationPartStructure.getPartStructureId())) {\r\n\r\n\t\t\t\t\t\taddPartStructure(dataElement, \"TITLE\", item,\r\n\t\t\t\t\t\t\t\tInLineCitationPartStructure.getPartStructureId());\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\t * Title, volume, issue\r\n\t\t\t */\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION-JOURNAL-TITLE\", item,\r\n\t\t\t\t\tSourceTitlePartStructure.getPartStructureId())) {\r\n\t\t\t\taddPartStructure(dataElement, \"SOURCE\", item,\r\n\t\t\t\t\t\tSourceTitlePartStructure.getPartStructureId());\r\n\t\t\t}\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-VOLUME\", item,\r\n\t\t\t\t\tVolumePartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-ISSUE\", item,\r\n\t\t\t\t\tIssuePartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-PART\", item,\r\n\t\t\t\t\tEditionPartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Pages\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"CITATION-PAGES\", item,\r\n\t\t\t\t\tPagesPartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-START-PAGE\", item,\r\n\t\t\t\t\tStartPagePartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-END-PAGE\", item,\r\n\t\t\t\t\tEndPagePartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Date and Year\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"CITATION-DATE\", item,\r\n\t\t\t\t\tDatePartStructure.getPartStructureId());\r\n\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION-DATE-YEAR\", item,\r\n\t\t\t\t\tYearPartStructure.getPartStructureId())) {\r\n\t\t\t\taddPartStructure(dataElement, \"CITATION-DATE\", item,\r\n\t\t\t\t\t\tYearPartStructure.getPartStructureId());\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * Type of publication\r\n\t\t\t */\r\n\t\t\tif (!addPartStructure(dataElement, \"TYPE\", item, TypePartStructure\r\n\t\t\t\t\t.getPartStructureId())) {\r\n\t\t\t\tif (!addPartStructure(dataElement, \"PUBLICATION-TYPE\", item,\r\n\t\t\t\t\t\tTypePartStructure.getPartStructureId())) {\r\n\t\t\t\t\tif (getText(dataElement, \"CITATION-JOURNAL-TITLE\") != null) {\r\n\t\t\t\t\t\titem.addPartStructure(TypePartStructure\r\n\t\t\t\t\t\t\t\t.getPartStructureId(), \"Journal\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * URL\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"URL\", item, URLPartStructure\r\n\t\t\t\t\t.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Identifiers (ISSN, ISBN, DOI)\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"ISBN\", item,\r\n\t\t\t\t\tIsnIdentifierPartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"ISSN\", item,\r\n\t\t\t\t\tIsnIdentifierPartStructure.getPartStructureId());\r\n\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION-DOI\", item,\r\n\t\t\t\t\tDOIPartStructure.getPartStructureId())) {\r\n\t\t\t\taddPartStructure(dataElement, \"DOI\", item, DOIPartStructure\r\n\t\t\t\t\t\t.getPartStructureId());\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * Author (add each in turn)\r\n\t\t\t */\r\n\t\t\taddPartStructureList(dataElement, \"AUTHOR\", item,\r\n\t\t\t\t\tCreatorPartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Subject (add each)\r\n\t\t\t */\r\n\t\t\taddPartStructureList(dataElement, \"SUBJECT\", item,\r\n\t\t\t\t\tSubjectPartStructure.getPartStructureId());\r\n\r\n\t\t\tdoRegexParse(database, item);\r\n\r\n\t\t\t/*\r\n\t\t\t * Save the asset component we just created\r\n\t\t\t */\r\n\r\n\t\t\taddItem(item);\r\n\r\n\t\t}\r\n\t}","id":31412,"modified_method":"/**\r\n\t * Parse the response\r\n\t */\r\n\tpublic void doParse()\r\n\t{\r\n\t\tDocument responseDocument = getSearchResponseDocument();\r\n\t\tElement resultElement;\r\n\t\tNodeList recordList;\r\n\r\n\t\t/*\r\n\t\t * Examine each RECORD\r\n\t\t */\r\n\t\tresultElement = responseDocument.getDocumentElement();\r\n\t\trecordList = DomUtils.getElementList(resultElement, \"RECORD\");\r\n\r\n/*********************\r\n    if (recordList.getLength() == 0)\r\n    {\r\n      String errorText = \"Unexpected server response (no search result records provided)\";\r\n\r\n\t\t\tLogUtils.displayXml(_log, errorText, responseDocument);\r\n\r\n\t\t\tStatusUtils.setGlobalError(sessionContext, errorText);\r\n\t\t\tthrow new SearchException(errorText);\r\n    }\r\n**********************/\r\n\t\tfor (int i = 0; i < recordList.getLength(); i++)\r\n\t\t{\r\n\t\t\tMatchItem item;\r\n\t\t\tElement dataElement, recordElement;\r\n\t\t\tNodeList nodeList;\r\n\t\t\tString title, description;\r\n\t\t\tString database, hit, target;\r\n\t\t\tString recordId, recordType;\r\n\t\t\tString content;\r\n\r\n\t\t\t/*\r\n\t\t\t * Pick up the database name & related information\r\n\t\t\t */\r\n\t\t\trecordElement = (Element) recordList.item(i);\r\n\r\n\t\t\thit = recordElement.getAttribute(\"hit\");\r\n\t\t\ttarget = recordElement.getAttribute(\"sourceID\");\r\n\t\t\tdatabase = recordElement.getAttribute(\"source\");\r\n\t\t\trecordId = recordElement.getAttribute(\"identifier\");\r\n\t\t\t/*\r\n\t\t\t * Update hit count\r\n\t\t\t */\r\n\t\t\tStatusUtils.updateHits(sessionContext, target);\r\n\t\t\t/*\r\n\t\t\t * The information we want resides in the DATA portion of the\r\n\t\t\t * document\r\n\t\t\t */\r\n\t\t\tif ((dataElement = DomUtils.getElement(recordElement, \"DATA\")) == null) {\r\n\t\t\t\t_log.error(\"No DATA element present in server response\");\r\n  \t\t\tdisplayXml(recordElement);\r\n\t\t\t\tthrow new SearchException(\r\n\t\t\t\t\t\t\"Missing mandatory <DATA> element in server response\");\r\n\t\t\t}\r\n\r\n\t\t\ttitle = getText(dataElement, \"TITLE\");\r\n\t\t\tif (StringUtils.isNull(title)) {\r\n\t\t\t\t_log.debug(\"No TITLE text in server response\");\r\n\t\t\t\ttitle = \"\";\r\n\t\t\t}\r\n\r\n\t\t\tdescription = getText(dataElement, \"DESCRIPTION\");\r\n\t\t\tif (StringUtils.isNull(description)) {\r\n\t\t\t\t_log.debug(\"No DESCRIPTION text in server response\");\r\n\t\t\t\tdescription = \"\";\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * Save select search result data\r\n\t\t\t */\r\n\t\t\titem = new MatchItem();\r\n\t\t\t/*\r\n\t\t\t * Title, abstract, record ID\r\n\t\t\t */\r\n\t\t\t_log.debug(\"Adding TITLE: \" + title);\r\n\r\n\t\t\titem.setDisplayName(title);\r\n\t\t\titem.setDescription(description);\r\n\t\t\titem.setId(recordId);\r\n\t\t\t/*\r\n\t\t\t * Publisher, language\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"PUBLICATION\", item,\r\n\t\t\t\t\tPublisherPartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"LANGUAGE\", item,\r\n\t\t\t\t\tLanguagePartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * In-line Citation information\r\n\t\t\t */\r\n\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION\", item,\r\n\t\t\t\t\tInLineCitationPartStructure.getPartStructureId())) {\r\n\r\n\t\t\t\tif (!addPartStructure(dataElement, \"SOURCE\", item,\r\n\t\t\t\t\t\tInLineCitationPartStructure.getPartStructureId())) {\r\n\r\n\t\t\t\t\tif (!addPartStructure(dataElement, \"DESCRIPTION\", item,\r\n\t\t\t\t\t\t\tInLineCitationPartStructure.getPartStructureId())) {\r\n\r\n\t\t\t\t\t\taddPartStructure(dataElement, \"TITLE\", item,\r\n\t\t\t\t\t\t\t\tInLineCitationPartStructure.getPartStructureId());\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\t * Title, volume, issue\r\n\t\t\t */\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION-JOURNAL-TITLE\", item,\r\n\t\t\t\t\tSourceTitlePartStructure.getPartStructureId())) {\r\n\t\t\t\taddPartStructure(dataElement, \"SOURCE\", item,\r\n\t\t\t\t\t\tSourceTitlePartStructure.getPartStructureId());\r\n\t\t\t}\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-VOLUME\", item,\r\n\t\t\t\t\tVolumePartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-ISSUE\", item,\r\n\t\t\t\t\tIssuePartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-PART\", item,\r\n\t\t\t\t\tEditionPartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Pages\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"CITATION-PAGES\", item,\r\n\t\t\t\t\tPagesPartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-START-PAGE\", item,\r\n\t\t\t\t\tStartPagePartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"CITATION-END-PAGE\", item,\r\n\t\t\t\t\tEndPagePartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Date and Year\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"CITATION-DATE\", item,\r\n\t\t\t\t\tDatePartStructure.getPartStructureId());\r\n\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION-DATE-YEAR\", item,\r\n\t\t\t\t\tYearPartStructure.getPartStructureId())) {\r\n\t\t\t\taddPartStructure(dataElement, \"CITATION-DATE\", item,\r\n\t\t\t\t\t\tYearPartStructure.getPartStructureId());\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * Type of publication\r\n\t\t\t */\r\n\t\t\tif (!addPartStructure(dataElement, \"TYPE\", item, TypePartStructure\r\n\t\t\t\t\t.getPartStructureId())) {\r\n\t\t\t\tif (!addPartStructure(dataElement, \"PUBLICATION-TYPE\", item,\r\n\t\t\t\t\t\tTypePartStructure.getPartStructureId())) {\r\n\t\t\t\t\tif (getText(dataElement, \"CITATION-JOURNAL-TITLE\") != null) {\r\n\t\t\t\t\t\titem.addPartStructure(TypePartStructure\r\n\t\t\t\t\t\t\t\t.getPartStructureId(), \"Journal\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * URL\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"URL\", item, URLPartStructure\r\n\t\t\t\t\t.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Identifiers (ISSN, ISBN, DOI)\r\n\t\t\t */\r\n\t\t\taddPartStructure(dataElement, \"ISBN\", item,\r\n\t\t\t\t\tIsnIdentifierPartStructure.getPartStructureId());\r\n\r\n\t\t\taddPartStructure(dataElement, \"ISSN\", item,\r\n\t\t\t\t\tIsnIdentifierPartStructure.getPartStructureId());\r\n\r\n\t\t\tif (!addPartStructure(dataElement, \"CITATION-DOI\", item,\r\n\t\t\t\t\tDOIPartStructure.getPartStructureId())) {\r\n\t\t\t\taddPartStructure(dataElement, \"DOI\", item, DOIPartStructure\r\n\t\t\t\t\t\t.getPartStructureId());\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * Author (add each in turn)\r\n\t\t\t */\r\n\t\t\taddPartStructureList(dataElement, \"AUTHOR\", item,\r\n\t\t\t\t\tCreatorPartStructure.getPartStructureId());\r\n\t\t\t/*\r\n\t\t\t * Subject (add each)\r\n\t\t\t */\r\n\t\t\taddPartStructureList(dataElement, \"SUBJECT\", item,\r\n\t\t\t\t\tSubjectPartStructure.getPartStructureId());\r\n\r\n\t\t\tdoRegexParse(database, item);\r\n\r\n\t\t\t/*\r\n\t\t\t * Save the asset component we just created\r\n\t\t\t */\r\n\r\n\t\t\taddItem(item);\r\n\t\t}\r\n\t}","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Set up initial status information\n\t */\n\tpublic static void initialize(SessionContext sessionContext, String targets)\n\t{\n\t\tStringTokenizer parser \t\t= new StringTokenizer(targets, \" \\t,\");\n\t\tArrayList\t\t\t\tdbList\t\t= new ArrayList();\n\t\tHashMap\t\t\t\t\ttargetMap\t= getNewStatusMap(sessionContext);\n\n\t\t/*\n\t\t * Establish the DB list and initial (pre-LOGON) status\n\t\t */\n\t\twhile (parser.hasMoreTokens())\n\t\t{\n\t\t\tString \tdb \t\t\t\t= parser.nextToken();\n\t\t\tHashMap emptyMap \t= new HashMap();\n\n\t\t\t/*\n\t\t\t * Empty status entry\n\t\t\t */\n\t\t\temptyMap.put(\"STATUS\", \"INACTIVE\");\n\t\t\temptyMap.put(\"STATUS_MESSAGE\", \"<none>\");\n\n\t\t\temptyMap.put(\"HITS\", \"0\");\n\t\t\temptyMap.put(\"ESTIMATE\", \"0\");\n\t\t\temptyMap.put(\"MERGED\", \"0\");\n\t\t\t/*\n\t\t\t * Save\n\t\t\t */\n      dbList.add(db);\n      targetMap.put(db, emptyMap);\n\t\t}\n\n\t\tsessionContext.put(\"TARGETS\", dbList);\n\t\tsessionContext.putInt(\"active\", 0);\n\n\t\tsessionContext.put(\"STATUS\", \"INACTIVE\");\n\t\tsessionContext.put(\"STATUS_MESSAGE\", \"<none>\");\n\n\t\tsessionContext.putInt(\"TOTAL_ESTIMATE\", 0);\n\t\tsessionContext.putInt(\"TOTAL_HITS\", 0);\n\t}","id":31413,"modified_method":"/**\n\t * Set up initial status information\n\t */\n\tpublic static void initialize(SessionContext sessionContext, String targets)\n\t{\n\t\tStringTokenizer parser \t\t= new StringTokenizer(targets, \" \\t,\");\n\t\tArrayList\t\t\t\tdbList\t\t= new ArrayList();\n\t\tHashMap\t\t\t\t\ttargetMap\t= getNewStatusMap(sessionContext);\n\n\t\t/*\n\t\t * Establish the DB list and initial (pre-LOGON) status\n\t\t */\n\t\twhile (parser.hasMoreTokens())\n\t\t{\n\t\t\tString \tdb \t\t\t\t= parser.nextToken();\n\t\t\tHashMap emptyMap \t= new HashMap();\n\n\t\t\t/*\n\t\t\t * Empty status entry\n\t\t\t */\n\t\t\temptyMap.put(\"STATUS\", \"INACTIVE\");\n\t\t\temptyMap.put(\"STATUS_MESSAGE\", \"<none>\");\n\n\t\t\temptyMap.put(\"HITS\", \"0\");\n\t\t\temptyMap.put(\"ESTIMATE\", \"0\");\n\t\t\temptyMap.put(\"MERGED\", \"0\");\n\t\t\t/*\n\t\t\t * Save\n\t\t\t */\n      dbList.add(db);\n      targetMap.put(db, emptyMap);\n\t\t}\n    /*\n     * Search targets, global status\n     */\n\t\tsessionContext.put(\"TARGETS\", dbList);\n\t\tsessionContext.putInt(\"active\", 0);\n\n\t\tsessionContext.put(\"STATUS\", \"INACTIVE\");\n\t\tsessionContext.put(\"STATUS_MESSAGE\", \"<none>\");\n    /*\n     * Initial totals\n     */\n\t\tsessionContext.putInt(\"TOTAL_ESTIMATE\", 0);\n\t\tsessionContext.putInt(\"TOTAL_HITS\", 0);\n\t\tsessionContext.putInt(\"maxRecords\", 0);\n\n\t\t/*\n\t\t * Assume this search is synchronous.  An OSID that implements an\n\t\t * asynchronous search will need to set the async flags manually after\n\t\t * this code has finished.\n\t\t */\n\t\tclearAsyncSearch(sessionContext);\n\t\tclearAsyncInit(sessionContext);\n\t}","commit_id":"459f6391c514ff4917bc06eaba49e6f21706406f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Search\r\n\t */\r\n\tpublic void doQuery()\r\n\t{\r\n\t\tDocument \tdocument;\r\n\t\tString\t\taction;\r\n\r\n\t\t/*\r\n\t\t * Get the logical \"database\" (a name for the configuration for this search)\r\n\t\t */\r\n\t\t_database = getRequestParameter(\"database\");\r\n\t\t/*\r\n\t\t * We'll manage redirects, and submit with POST\r\n\t\t */\r\n\t\tsetRedirectBehavior(REDIRECT_MANAGED);\r\n\t\tsetQueryMethod(METHOD_POST);\r\n\t\t/*\r\n\t\t * Save the URL and query text\r\n\t\t */\r\n\t\tsetUrl(getRequestParameter(\"url\"));\r\n\t\tsetSearchString(getSearchString());\r\n\t\t/*\r\n\t\t * New search?\r\n\t\t */\r\n\t\taction = getRequestParameter(\"action\");\r\n\t\tif (action.equalsIgnoreCase(\"startSearch\"))\r\n\t\t{\t/*\r\n\t\t   * Initialize a new search context block\r\n\t\t   */\r\n\t\t\tStatusUtils.initialize(getSessionContext(), getRequestParameter(\"targets\"));\r\n\t\t\t/*\r\n\t\t\t * LOGOFF any previous session\r\n\t\t\t */\r\n\t\t\tdoLogoffCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\t_log.debug(DomUtils.serialize(getResponseDocument()));\r\n\t\t\t}\r\n\t\t\tcatch (Exception ignore) { }\r\n\r\n\t\t\t/*\r\n\t\t\t * LOGON\r\n\t\t\t */\r\n\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoLogonCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tLogUtils.displayXml(_log, \"Login\", getResponseDocument());\r\n\r\n\t\t\tvalidateResponse(\"LOGON\");\r\n\t\t\t/*\r\n\t\t\t * Search\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoSearchCommand();\r\n\t\t\tsubmit();\r\n\t\t\tLogUtils.displayXml(_log, \"Search\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"SEARCH\");\r\n\t\t\t/*\r\n\t\t\t * Pick up the current status\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoStatusCommand();\r\n\t\t\tsubmit();\r\n\r\n//\t\t\tisStatusReadyToBeRead(getResponseDocument());\r\n\r\n\t\t\tint sleepCount;\r\n\t\t  boolean done;\r\n\r\n\t\t  sleepCount = 0;\r\n\t\t  done = setStatus(getResponseDocument(), getResponseDocument().getDocumentElement());\r\n\r\n//  \twhile (! isStatusReadyToBeRead(getResponseDocument()) && sleepCount < 5)\r\n      while (!done && (sleepCount < 5))\r\n\t\t\t{\r\n\t\t\t\t_log.info(\"Status is not ready to be read\");\r\n\t\t\t\tLogUtils.displayXml(_log, \"Progress\", getResponseDocument());\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tThread.sleep(1000);\r\n\t\t\t\t\t_log.debug(\"sleeping ...\");\r\n\t\t\t\t}\r\n\t\t\t\tcatch (InterruptedException ignore) { }\r\n\r\n\t\t\t\tdoStatusCommand();\r\n\t\t\t\tsubmit();\r\n\r\n\t\t\t\tsleepCount++;\r\n  \t\t  done = setStatus(getResponseDocument(), getResponseDocument().getDocumentElement());\r\n\t\t\t}\r\n\r\n\t\t\tLogUtils.displayXml(_log, \"Status\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"PROGRESS\");\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t/*\r\n\t\t * Request additional results\r\n\t\t */\r\n\t\tdoResultsCommand();\r\n\t\tLogUtils.displayXml(_log, \"Results\", getResponseDocument());\r\n\t}","id":31414,"modified_method":"/**\r\n\t * Search\r\n\t */\r\n\tpublic void doQuery()\r\n\t{\r\n\t\tDocument \tdocument;\r\n\t\tString\t\taction;\r\n\t\t/*\r\n\t\t * Get the logical \"database\" (a name for the configuration for this search)\r\n\t\t */\r\n\t\t_database = getRequestParameter(\"database\");\r\n\t\t/*\r\n\t\t * We'll manage redirects, and submit with POST\r\n\t\t */\r\n\t\tsetRedirectBehavior(REDIRECT_MANAGED);\r\n\t\tsetQueryMethod(METHOD_POST);\r\n\t\t/*\r\n\t\t * Save the URL and query text\r\n\t\t */\r\n\t\tsetUrl(getRequestParameter(\"url\"));\r\n\t\tsetSearchString(getSearchString());\r\n\t\t/*\r\n\t\t * New search?\r\n\t\t */\r\n\t\taction = getRequestParameter(\"action\");\r\n\t\tif (action.equalsIgnoreCase(\"startSearch\"))\r\n\t\t{\r\n  \t\tint sleepCount;\r\n  \t\tboolean done;\r\n\t\t  /*\r\n\t\t   * Initialize a new search context block\r\n\t\t   */\r\n\t\t\tStatusUtils.initialize(getSessionContext(), getRequestParameter(\"targets\"));\r\n\t\t\t/*\r\n\t\t\t * LOGOFF any previous session\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoLogoffCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tsetSessionId(null);\r\n\t\t\tdisplayXml(\"Logoff\", getResponseDocument());\r\n\t\t\t/*\r\n\t\t\t * LOGON\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoLogonCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tdisplayXml(\"Login\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"LOGON\");\r\n\t\t\t/*\r\n\t\t\t * Search\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoSearchCommand();\r\n\t\t\tsubmit();\r\n\r\n\t\t\tdisplayXml(\"Search\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"SEARCH\");\r\n\t\t\t/*\r\n\t\t\t * Pick up the current status\r\n\t\t\t */\r\n\t\t\tclearParameters();\r\n\r\n\t\t\tdoProgressCommand();\r\n\t\t\tsubmit();\r\n\r\n//\t\t\tisStatusReadyToBeRead(getResponseDocument());\r\n\r\n\t\t  sleepCount = 0;\r\n\t\t  done = setStatus(getResponseDocument());\r\n\r\n//  \twhile (! isStatusReadyToBeRead(getResponseDocument()) && sleepCount < 5)\r\n      while (!done && (sleepCount < 5))\r\n\t\t\t{\r\n\t\t\t\t_log.debug(\"Status is not finished\");\r\n\t\t\t\tdisplayXml(\"Progress\", getResponseDocument());\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tThread.sleep(1000);\r\n\t\t\t\t\t_log.debug(\"Sleeping ...\");\r\n\t\t\t\t}\r\n\t\t\t\tcatch (InterruptedException ignore) { }\r\n\r\n\t\t\t\tdoProgressCommand();\r\n\t\t\t\tsubmit();\r\n\r\n\t\t\t\tsleepCount++;\r\n  \t\t  done = setStatus(getResponseDocument());\r\n\t\t\t}\r\n\r\n\t\t\tdisplayXml(\"Status\", getResponseDocument());\r\n\t\t\tvalidateResponse(\"PROGRESS\");\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t/*\r\n\t\t * Request additional results\r\n\t\t */\r\n\t\tdoResultsCommand();\r\n\t\tdisplayXml(\"Results\", getResponseDocument());\r\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Generate a \"fetch results\" command\r\n\t */\r\n\tprivate void doResultsCommand() throws SearchException\r\n\t{\r\n\t\tint start = getSessionContext().getInt(\"startRecord\");\r\n\r\n\t\tclearParameters();\r\n\t\tdoMoreCommand(start);\r\n\r\n\t\tsubmit();\r\n\t\tvalidateResponse(\"MORE\");\r\n\t}","id":31415,"modified_method":"/**\r\n\t * Fetch more results\r\n\t */\r\n\tprivate void doResultsCommand() throws SearchException\r\n\t{\r\n\t\tint start = getSessionContext().getInt(\"startRecord\");\r\n    /*\r\n     * Only for the first result page: handle sparse results specially\r\n     */\r\n    if (start == 1)\r\n    {\r\n      int activeTargets   = StatusUtils.getActiveTargetCount(getSessionContext());\r\n      int pageSize        = Integer.parseInt((String) getSessionContext().get(\"pageSize\"));\r\n      int totalRemaining  = StatusUtils.getAllRemainingHits(getSessionContext());\r\n      /*\r\n       * If we have less than a full page of results, use \"PREVIOUS\"\r\n       */\r\n      if (pageSize > totalRemaining)\r\n      {\r\n        getSessionContext().put(\"pageSize\", String.valueOf(pageSize));\r\n\r\n     \t  clearParameters();\r\n     \t\tdoPaginationCommand(\"previous\", start);\r\n\r\n     \t\tsubmit();\r\n     \t\tvalidateResponse(\"PREVIOUS\");\r\n     \t\treturn;\r\n      }\r\n    }\r\n    /*\r\n     * The normal case, use MORE to pick up the results\r\n     */\r\n\t  clearParameters();\r\n\t  doMoreCommand(start);\r\n\r\n\t  submit();\r\n\t  validateResponse(\"MORE\");\r\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Save the name of the SEARCH result set\r\n\t * @param referenceId The SEARCH command reference id\r\n\t */\r\n\tprivate void setResultSetName(String referenceId)\r\n\t{\r\n\r\n\t\tStringBuilder resultSetName = new StringBuilder(\"sakaibrary-\");\r\n\r\n\t\tresultSetName.append(referenceId);\r\n\t\tresultSetName.append(\".xml\");\r\n\r\n\t\tgetSessionContext().put(\"RESULT_SET_NAME\", resultSetName.toString());\r\n\t\tgetSessionContext().put(\"RESULT_SET_NAME\", referenceId);\r\n\t}","id":31416,"modified_method":"/**\r\n\t * Save the name of the search result set\r\n\t * @param name The result set name\r\n\t */\r\n\tprivate void setResultSetName(String name)\r\n\t{\r\n\t\tgetSessionContext().put(\"RESULT_SET_NAME\", name);\r\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Generate a SEARCH command\r\n\t */\r\n\tprivate void doSearchCommand() throws SearchException\r\n\t{\r\n\t\tStringTokenizer targetParser;\r\n\t\tString searchCriteria, searchFilter, targets;\r\n\t\tString pageSize, sessionId, sortBy;\r\n\t\tint targetCount;\r\n\r\n\t\t/*\r\n\t\t * Set search criteria (use the search filter, if any is configured)\r\n\t\t */\r\n\t\tsearchCriteria = getSearchString();\r\n\t\t_log.debug(\"Search criteria: \" + searchCriteria);\r\n\r\n\t\tgetSessionContext().put(\"SEARCH_QUERY\", searchCriteria);\r\n\t\t/*\r\n\t\t * Determine database(s) to examine, sort mode, page size, etc.\r\n\t\t */\r\n\t\ttargets       = getRequestParameter(\"targets\");\r\n\t\ttargetParser  = new StringTokenizer(targets);\r\n\t\ttargetCount   = targetParser.countTokens();\r\n\r\n\t\tpageSize = getIntegerRequestParameter(\"pageSize\").toString();\r\n\t\t_log.debug(\"Page size: \" + pageSize);\r\n\t\t/*\r\n\t\t * Generate the search command\r\n\t\t */\r\n\t\tsetParameter(\"action\",    \"search\");\r\n\t\tsetParameter(\"xml\",       \"true\");\r\n\t\tsetParameter(\"sessionID\", getSessionId());\r\n\r\n\t\tsetParameter(\"queryStatement\", searchCriteria);\r\n\r\n\t\twhile (targetParser.hasMoreTokens())\r\n\t\t{\r\n      String target  = targetParser.nextToken();\r\n\r\n\t\t  setParameter(\"dbList\", target);\r\n\r\n \t\t\t_log.debug(\"SEARCH: added DB \" + target);\r\n\t\t}\r\n    /*\r\n     * Start an asynchronous query (no results are returned) to set things up\r\n     * for a subsequent PROGRESS (status) command\r\n     */\r\n\t\tsetParameter(\"start\", \"1\");\r\n\t\tsetParameter(\"firstRetrievedRecord\", \"0\");\r\n\t\tsetParameter(\"limitsMaxPerSource\", \"100\");\r\n\t\tsetParameter(\"limitsMaxPerPage\", \"0\");\r\n\r\n\t\tsetParameter(\"recordFormat\",    \"raw.xsl\");\r\n\t\tsetParameter(\"headerTemplate\",  \"xml/list-header.xml\");\r\n\t\tsetParameter(\"footerTemplate\",  \"xml/list-footer.xml\");\r\n\t\tsetParameter(\"errorTemplate\",   \"xml/error.xml\");\r\n\t\tsetParameter(\"errorFormat\",     \"error2XML.xsl\");\r\n\t}","id":31417,"modified_method":"/**\r\n\t * Generate a SEARCH command\r\n\t */\r\n\tprivate void doSearchCommand() throws SearchException\r\n\t{\r\n\t\tStringTokenizer targetParser;\r\n\t\tString searchCriteria, searchFilter, targets;\r\n\t\tString pageSize, sessionId, sortBy;\r\n\t\t/*\r\n\t\t * Set search criteria\r\n\t\t */\r\n\t\tsearchCriteria = getSearchString();\r\n\t\t_log.debug(\"Search criteria: \" + searchCriteria);\r\n\t\t/*\r\n\t\t * Determine database(s) to examine, sort mode, page size, etc.\r\n\t\t */\r\n\t\tpageSize = getIntegerRequestParameter(\"pageSize\").toString();\r\n\t\t_log.debug(\"Page size: \" + pageSize);\r\n\t\t/*\r\n\t\t * Generate the search command\r\n\t\t */\r\n\t\tsetParameter(\"action\",    \"search\");\r\n\t\tsetParameter(\"xml\",       \"true\");\r\n\t\tsetParameter(\"sessionID\", getSessionId());\r\n\r\n\t\tsetParameter(\"queryStatement\", searchCriteria);\r\n\r\n\t\ttargets       = getRequestParameter(\"targets\");\r\n\t\ttargetParser  = new StringTokenizer(targets);\r\n\r\n\t\twhile (targetParser.hasMoreTokens())\r\n\t\t{\r\n      String target  = targetParser.nextToken();\r\n\r\n\t\t  setParameter(\"dbList\", target);\r\n\r\n \t\t\t_log.debug(\"SEARCH: added DB \" + target);\r\n\t\t}\r\n    /*\r\n     * Start an asynchronous query (no results are returned) to set things up\r\n     * for a subsequent PROGRESS (status) command\r\n     */\r\n\t\tsetParameter(\"start\", \"1\");\r\n//\t\tsetParameter(\"firstRetrievedRecord\", \"1\");\r\n\t\tsetParameter(\"limitsMaxPerSource\", RECORDS_PER_TARGET);\r\n\t\tsetParameter(\"limitsMaxPerPage\", \"0\");\r\n\r\n\t\tsetParameter(\"recordFormat\",    \"raw.xsl\");\r\n\t\tsetParameter(\"headerTemplate\",  \"xml/list-header.xml\");\r\n\t\tsetParameter(\"footerTemplate\",  \"xml/list-footer.xml\");\r\n\t\tsetParameter(\"errorTemplate\",   \"xml/error.xml\");\r\n\t\tsetParameter(\"errorFormat\",     \"error2XML.xsl\");\r\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Save the initial search status (estimated hits, etc.) as session context information\r\n\t * @param document Server response\r\n\t * @rootElement Document root\r\n\t */\r\n\tprivate boolean setStatus(Document document, Element rootElement) throws SearchException\r\n\t{\r\n\t\tNodeList\tnodeList;\r\n\t\tint\t\t\t\tactive, total;\r\n\t\tboolean   complete;\r\n\r\n\t\tnodeList \t\t= DomUtils.getElementList(rootElement, \"ITEM\");\r\n\t\tactive\t\t\t= 0;\r\n\t\ttotal \t\t\t= 0;\r\n\t\tcomplete    = true;\r\n\r\n\t\t/*\r\n\t\t * Update the status map for each target\r\n\t\t */\r\n\r\n\t\tfor (int i = 0; i < nodeList.getLength(); i++)\r\n\t\t{\r\n\t\t\tElement\t\trecordElement\t= (Element) nodeList.item(i);\r\n\t\t\tHashMap\t\tmap;\r\n\r\n\t\t\tString\t\ttext, target;\r\n\t\t\tElement\t\telement;\r\n\t\t\tint\t\t\t  estimate;\r\n\r\n\t\t\t/*\r\n\t\t\t * Target (database)\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue (recordElement, \"ENTRY\", \"key\", \"targetID\");\r\n\t\t\ttarget\t= DomUtils.getText(element);\r\n\t\t\tmap \t  = StatusUtils.getStatusMapForTarget(getSessionContext(), target);\r\n\t\t\t/*\r\n\t\t\t * Percent complete\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue (recordElement, \"ENTRY\", \"key\", \"status\");\r\n\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t}\r\n\t\t\tmap.put(\"PERCENT_COMPLETE\", text);\r\n\t\t\t/*\r\n\t\t\t * Estimated match count\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue (recordElement, \"ENTRY\", \"key\", \"estimate\");\r\n\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t\tcomplete = false;\r\n\t\t\t}\r\n\t\t\tmap.put(\"ESTIMATE\", text);\r\n\r\n\t\t\testimate = Integer.parseInt(text);\r\n\t\t\ttotal\t\t+= estimate;\r\n\t\t\t/*\r\n\t\t\t * This search target is active only if there are records available\r\n\t\t\t */\r\n\t\t\tmap.put(\"STATUS\", \"DONE\");\r\n\r\n\t\t\tif (estimate > 0)\r\n\t\t\t{\r\n\t\t\t\tmap.put(\"STATUS\", \"ACTIVE\");\r\n\t\t\t\tactive++;\r\n\t\t\t}\r\n\t\t\t_log.debug(\"****** Target: \"\r\n\t\t\t        +  target\r\n\t\t\t        +  \", status = \"\r\n\t\t\t        +  map.get(\"STATUS\"));\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Save in session context:\r\n\t\t *\r\n\t\t * -- The largest number of records we could possibly return\r\n\t\t * -- The count of \"in progress\" searches\r\n\t\t */\r\n\r\n\t\tgetSessionContext().put(\"maxRecords\", String.valueOf(total));\r\n\t\tgetSessionContext().putInt(\"active\", active);\r\n\r\n\t\treturn complete;\r\n\t}","id":31418,"modified_method":"/**\r\n\t * Save the initial search status (estimated hits, etc.) as session context information\r\n\t * @param document Server response\r\n\t * @rootElement Document root\r\n\t */\r\n\tprivate boolean setStatus(Document document) throws SearchException\r\n\t{\r\n    Element   rootElement = document.getDocumentElement();\r\n\t\tNodeList  nodeList \t\t= DomUtils.getElementList(rootElement, \"ITEM\");\r\n\t\tint       active\t\t\t= 0;\r\n\t\tint       total \t\t\t= 0;\r\n\t\tboolean   complete    = true;\r\n\r\n\t\t/*\r\n\t\t * Update the status map for each target\r\n\t\t */\r\n\t\tfor (int i = 0; i < nodeList.getLength(); i++)\r\n\t\t{\r\n\t\t\tElement\t\trecordElement\t= (Element) nodeList.item(i);\r\n\t\t\tHashMap\t\tmap;\r\n\r\n\t\t\tString\t\ttext, target;\r\n\t\t\tElement\t\telement;\r\n\t\t\tint\t\t\t  estimate;\r\n\r\n\t\t\t/*\r\n\t\t\t * Target (database)\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue (recordElement, \"ENTRY\", \"key\", \"targetID\");\r\n\t\t\ttarget\t= DomUtils.getText(element);\r\n\t\t\tmap \t  = StatusUtils.getStatusMapForTarget(getSessionContext(), target);\r\n\t\t\t/*\r\n\t\t\t * Percent complete\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue (recordElement, \"ENTRY\", \"key\", \"status\");\r\n\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t}\r\n\t\t\tmap.put(\"PERCENT_COMPLETE\", text);\r\n\t\t\t/*\r\n\t\t\t * Estimated match count\r\n\t\t\t */\r\n\t\t\telement = DomUtils.selectFirstElementByAttributeValue (recordElement, \"ENTRY\", \"key\", \"estimate\");\r\n\r\n\t\t\tif ((text\t= DomUtils.getText(element)) == null)\r\n\t\t\t{\r\n\t\t\t\ttext = \"0\";\r\n\t\t\t\tcomplete = false;\r\n\t\t\t}\r\n\t\t\tmap.put(\"ESTIMATE\", text);\r\n\r\n\t\t\testimate = Integer.parseInt(text);\r\n\t\t\ttotal\t\t+= estimate;\r\n\t\t\t/*\r\n\t\t\t * This search target is active only if there are records available\r\n\t\t\t */\r\n\t\t\tmap.put(\"STATUS\", \"DONE\");\r\n\r\n\t\t\tif (estimate > 0)\r\n\t\t\t{\r\n\t\t\t\tmap.put(\"STATUS\", \"ACTIVE\");\r\n\t\t\t\tactive++;\r\n\t\t\t}\r\n\t\t\t_log.debug(\"****** Target: \"\r\n\t\t\t        +  target\r\n\t\t\t        +  \", status = \"\r\n\t\t\t        +  map.get(\"STATUS\"));\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Save in session context:\r\n\t\t *\r\n\t\t * -- The largest number of records we could possibly return\r\n\t\t * -- The count of \"in progress\" searches\r\n\t\t */\r\n\t\tgetSessionContext().put(\"maxRecords\", String.valueOf(total));\r\n\t\tgetSessionContext().putInt(\"TOTAL_ESTIMATE\", total);\r\n\t\tgetSessionContext().putInt(\"active\", active);\r\n\r\n\t\treturn complete;\r\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Generate a MORE data command\r\n\t * @param firstRecord First record to retrieve\r\n\t */\r\n\tprivate void doMoreCommand(int firstRecord)\r\n\t{\r\n\t\tIterator targetIterator;\r\n\r\n\t\t_log.debug(\"MORE: using result set name \\\"\" + getResultSetName() + \"\\\"\");\r\n\t\t_log.debug(\"MORE: queryStatement = \" + getSearchString());\r\n\r\n\t\tsetParameter(\"action\", \"more\");\r\n\t\tsetParameter(\"actionType\", \"SEARCH\");\r\n\t\tsetParameter(\"xml\", \"true\");\r\n\r\n\t\tsetParameter(\"sessionID\", getSessionId());\r\n\t\tsetParameter(\"searchReferenceID\", getReferenceId());\r\n\t\tsetParameter(\"resultSet\", getResultSetName());\r\n\r\n\t\tsetParameter(\"queryStatement\", getSearchString());\r\n\r\n\t\ttargetIterator = StatusUtils.getStatusMapEntrySetIterator(getSessionContext());\r\n\t\twhile (targetIterator.hasNext())\r\n\t\t{\r\n\t\t\tMap.Entry entry   = (Map.Entry) targetIterator.next();\r\n      String    target  = (String) entry.getKey();\r\n\r\n\t\t  Map       map     = StatusUtils.getStatusMapForTarget(getSessionContext(), target);\r\n\t\t  String    status  = (String) map.get(\"STATUS\");\r\n\r\n      if (\"ACTIVE\".equals(status))\r\n      {\r\n\t\t\t  setParameter(\"dbList\", target);\r\n\r\n\t\t\t\t_log.debug(\"MORE: added DB \" + target);\r\n      }\r\n\t\t}\r\n\r\n    _log.debug(\"MORE: firstRetrievedRecord = \" + firstRecord\r\n            +  \", totalRecords: \" + (firstRecord - 1));\r\n\r\n/*\r\n * Not necessary(?)\r\n *\t\tsetParameter(\"start\", Integer.toString(firstRecord));\r\n */\r\n\t\tsetParameter(\"firstRetrievedRecord\", Integer.toString(firstRecord));\r\n\t\tsetParameter(\"totalRecords\", Integer.toString(firstRecord - 1));\r\n\t\tsetParameter(\"limitsMaxPerSource\", RECORDS_PER_TARGET);\r\n\t\tsetParameter(\"limitsMaxPerPage\", (String) getSessionContext().get(\"pageSize\"));\r\n\r\n\t\tsetParameter(\"recordFormat\",    \"raw.xsl\");\r\n\t\tsetParameter(\"headerTemplate\",  \"xml/list-header.xml\");\r\n\t\tsetParameter(\"footerTemplate\",  \"xml/list-footer.xml\");\r\n\t\tsetParameter(\"errorTemplate\",   \"xml/error.xml\");\r\n\t\tsetParameter(\"errorFormat\",     \"error2XML.xsl\");\r\n\t}","id":31419,"modified_method":"/**\r\n\t * Generate a MORE data command\r\n\t * @param firstRecord First record to retrieve\r\n\t */\r\n\tprivate void doMoreCommand(int firstRecord)\r\n\t{\r\n\t\tIterator targetIterator;\r\n\r\n\t\t_log.debug(\"MORE: using result set name \\\"\" + getResultSetName() + \"\\\"\");\r\n\t\t_log.debug(\"MORE: queryStatement = \" + getSearchString());\r\n\r\n\t\tsetParameter(\"action\", \"more\");\r\n\t\tsetParameter(\"actionType\", \"SEARCH\");\r\n\t\tsetParameter(\"xml\", \"true\");\r\n\r\n\t\tsetParameter(\"sessionID\", getSessionId());\r\n\t\tsetParameter(\"searchReferenceID\", getReferenceId());\r\n\t\tsetParameter(\"resultSet\", getResultSetName());\r\n\r\n\t\tsetParameter(\"queryStatement\", getSearchString());\r\n\r\n\t\ttargetIterator = StatusUtils.getStatusMapEntrySetIterator(getSessionContext());\r\n\t\twhile (targetIterator.hasNext())\r\n\t\t{\r\n\t\t\tMap.Entry entry   = (Map.Entry) targetIterator.next();\r\n      String    target  = (String) entry.getKey();\r\n\r\n\t\t  Map       map     = StatusUtils.getStatusMapForTarget(getSessionContext(), target);\r\n\t\t  String    status  = (String) map.get(\"STATUS\");\r\n\r\n      if (\"ACTIVE\".equals(status))\r\n      {\r\n\t\t\t  setParameter(\"dbList\", target);\r\n\r\n\t\t\t\t_log.debug(\"MORE: added DB \" + target);\r\n      }\r\n\t\t}\r\n\r\n    _log.debug(\"MORE: firstRetrievedRecord = \" + firstRecord\r\n            +  \", totalRecords: \" + (firstRecord - 1));\r\n\r\n    String start = Integer.toString(firstRecord);\r\n    String total = Integer.toString(firstRecord - 1);\r\n\r\n    _log.debug(\"MORE: start = \" + start +  \", total = \" + total);\r\n\r\n\t\tsetParameter(\"start\", start);\r\n    setParameter(\"firstRetrievedRecord\", start);\r\n  \tsetParameter(\"totalRecords\", total);\r\n    setParameter(\"limitsMaxPerSource\", RECORDS_PER_TARGET);\r\n  \tsetParameter(\"limitsMaxPerPage\", (String) getSessionContext().get(\"pageSize\"));\r\n\r\n\t\tsetParameter(\"recordFormat\",    \"raw.xsl\");\r\n\t\tsetParameter(\"headerTemplate\",  \"xml/list-header.xml\");\r\n\t\tsetParameter(\"footerTemplate\",  \"xml/list-footer.xml\");\r\n\t\tsetParameter(\"errorTemplate\",   \"xml/error.xml\");\r\n\t  setParameter(\"errorFormat\",     \"error2XML.xsl\");\r\n  }","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Fetch the (Muse format) search string (overrides HttpTransactionQueryBase)\r\n\t * @return The native Muse query text\r\n\t */\r\n\tpublic String getSearchString()\r\n\t{\r\n\t  String searchCriteria = (String) getSessionContext().get(\"SEARCH_QUERY\");\r\n\r\n    _log.debug(\"getSearchString(): criteria = \" + searchCriteria);\r\n\r\n\t\treturn searchCriteria;\r\n\t}","id":31420,"modified_method":"/**\r\n\t * Fetch the (Muse format) search string (overrides HttpTransactionQueryBase)\r\n\t * @return The native Muse query text\r\n\t */\r\n\tpublic String getSearchString()\r\n\t{\r\n\t  return (String) getSessionContext().get(\"SEARCH_QUERY\");\r\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Initial response validation.  Verify:\r\n\t * <ul>\r\n\t * <li>Error code\r\n\t * <li>Correct <REFERENCE_ID> value\r\n\t * <\/ul>\r\n\t *<p>\r\n\t * @param action Server activity (SEARCH, LOGON, etc)\r\n\t */\r\n\tprivate void validateResponse(String action) throws SearchException\r\n\t{\r\n\t\tDocument \tdocument;\r\n\t\tElement \telement;\r\n\t\tString\t\tmessage, errorText;\r\n\r\n\t\tdocument  = getResponseDocument();\r\n\t\telement\t\t= document.getDocumentElement();\r\n\t\t/*\r\n\t\t * Success?\r\n\t\t */\r\n\t\t_log.debug(\"VALIDATE: \" + element.getTagName() + \" vs \" + action);\r\n\r\n\t\tif ((element!= null) && (element.getTagName().equals(action)))\r\n\t\t{\r\n\t\t\tif (action.equals(\"LOGON\"))\r\n\t\t\t{\r\n//\t\t\t\tif (getSessionId() == null)\r\n//\t\t\t\t{\r\n\t\t\t\t\tString sessionId;\r\n\r\n\t\t\t\t\telement   = DomUtils.getElement(element, \"SESSION_ID\");\r\n\t\t\t\t\tsessionId = DomUtils.getText(element);\r\n\t\t\t\t\tsetSessionId(sessionId);\r\n\r\n\t\t\t\t\t_log.debug(\"Saved Muse session ID \\\"\" + sessionId + \"\\\"\");\r\n//\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (action.equals(\"SEARCH\") || action.equals(\"MORE\"))\r\n\t\t\t{\r\n\t\t\t  Element searchElement;\r\n\t\t\t\tString  id;\r\n\r\n        searchElement = element;\r\n\t\t\t\telement = DomUtils.getElement(element, \"REFERENCE_ID\");\r\n\t\t\t\tid = DomUtils.getText(element);\r\n\r\n\t\t\t\tsetReferenceId(id);\r\n\t\t\t\t_log.debug(\"Saved search reference ID \\\"\" + getReferenceId() + \"\\\"\");\r\n\r\n\t\t\t\tif (action.equals(\"SEARCH\"))\r\n\t\t\t\t{\r\n  \t\t\t\telement = DomUtils.getElement(searchElement, \"RESULT_SET_NAME\");\r\n\t  \t\t\tid = DomUtils.getText(element);\r\n\r\n\t\t\t\t\tsetResultSetName(id);\r\n\t\t\t\t\t_log.debug(\"Saved result set name \\\"\" + getResultSetName() + \"\\\"\");\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (action.equals(\"PROGRESS\"))\r\n\t\t\t{\r\n//        setStatus(document, element);\r\n\r\n        return;\r\n\t\t\t}\r\n\r\n      _log.debug(\"Not implemented: \" + action);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t/*\r\n\t\t * Error\r\n\t\t */\r\n\t\telement = document.getDocumentElement();\r\n\t\tif ((element != null) && (element.getTagName().equals(\"ERROR\")))\r\n\t\t{\r\n\t\t\telement = DomUtils.getElement(element, \"MESSAGE\");\r\n\t\t}\r\n\r\n\t\tif (element == null)\r\n\t\t{\r\n\t\t\terrorText = action + \": Unexpected document format\";\r\n\r\n\t\t\tLogUtils.displayXml(_log, errorText, document);\r\n\r\n\t\t\tStatusUtils.setGlobalError(getSessionContext(), errorText);\r\n\t\t\tthrow new SearchException(errorText);\r\n\t\t}\r\n\t\t/*\r\n\t\t * Format and log the error\r\n\t\t */\r\n\t\tmessage   = DomUtils.getText(element);\r\n\r\n\t\terrorText = action\r\n\t\t+ \" error: \"\r\n\t\t+ (StringUtils.isNull(message) ? \"*unknown*\" : message);\r\n\r\n\t\tLogUtils.displayXml(_log, errorText, document);\r\n\t\t/*\r\n\t\t * Session timeout is a special case\r\n\t\t *\r\n\t\t * -- Re-initialize (clear the query URL)\r\n\t\t * -- Set \"global failure\" status\r\n\t\t * -- Throw the timeout exception\r\n\t\t */\r\n\t\tif (message.endsWith(NO_SESSION))\r\n\t\t{\r\n\t\t\tremoveQueryUrl(APPLICATION);\r\n\t\t\tStatusUtils.setGlobalError(getSessionContext(), \"Session timed out\");\r\n\t\t\tthrow new SessionTimeoutException();\r\n\t\t}\r\n\t\t/*\r\n\t\t * Set final status, abort\r\n\t\t */\r\n\t\tStatusUtils.setGlobalError(getSessionContext(), errorText);\r\n\t\tthrow new SearchException(errorText);\r\n\t}","id":31421,"modified_method":"/**\r\n\t * Initial response validation and cleanup activities.\r\n\t * <ul>\r\n\t * <li>Verify the response format (ERROR?)\r\n\t * <li>If no error, perform any cleanup required for the action in question\r\n\t * <\/ul>\r\n\t *<p>\r\n\t * @param action Server activity (SEARCH, LOGON, etc)\r\n\t */\r\n\tprivate void validateResponse(String action) throws SearchException\r\n\t{\r\n\t\tDocument \tdocument;\r\n\t\tElement \telement;\r\n\t\tString\t\tmessage, errorText;\r\n\r\n\r\n\t\t_log.debug(\"VALIDATE: \" + action);\r\n\t\t/*\r\n\t\t * Success?\r\n\t\t */\r\n\t\tdocument = getResponseDocument();\r\n\t\telement = document.getDocumentElement();\r\n\r\n\t\tif ((element!= null) && (element.getTagName().equals(action)))\r\n\t\t{\r\n\t\t\tif (action.equals(\"LOGON\"))\r\n\t\t\t{\r\n  \t\t\tString sessionId;\r\n\r\n\t\t\t\telement   = DomUtils.getElement(element, \"SESSION_ID\");\r\n\t  \t\tsessionId = DomUtils.getText(element);\r\n\t\t\t\tsetSessionId(sessionId);\r\n\r\n\t\t\t\t_log.debug(\"Saved Muse session ID \\\"\" + sessionId + \"\\\"\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (action.equals(\"SEARCH\") || action.equals(\"MORE\"))\r\n\t\t\t{\r\n\t\t\t  Element searchElement;\r\n\t\t\t\tString  id;\r\n\r\n        searchElement = element;\r\n\t\t\t\telement = DomUtils.getElement(element, \"REFERENCE_ID\");\r\n\t\t\t\tid = DomUtils.getText(element);\r\n\r\n\t\t\t\tsetReferenceId(id);\r\n\t\t\t\t_log.debug(\"Saved search reference ID \\\"\" + getReferenceId() + \"\\\"\");\r\n\r\n\t\t\t\tif (action.equals(\"SEARCH\"))\r\n\t\t\t\t{\r\n  \t\t\t\telement = DomUtils.getElement(searchElement, \"RESULT_SET_NAME\");\r\n\t  \t\t\tid = DomUtils.getText(element);\r\n\r\n\t\t\t\t\tsetResultSetName(id);\r\n\t\t\t\t\t_log.debug(\"Saved result set name \\\"\" + getResultSetName() + \"\\\"\");\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n      /*\r\n       * No cleanup activities for this action\r\n       */\r\n      _log.debug(\"No \\\"cleanup\\\" activities implemented for \" + action);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t/*\r\n\t\t * Error\r\n\t\t */\r\n\t\telement = document.getDocumentElement();\r\n\t\tif ((element != null) && (element.getTagName().equals(\"ERROR\")))\r\n\t\t{\r\n\t\t\telement = DomUtils.getElement(element, \"MESSAGE\");\r\n\t\t}\r\n\r\n\t\tif (element == null)\r\n\t\t{\r\n\t\t\terrorText = action + \": Unexpected document format\";\r\n\r\n\t\t\tLogUtils.displayXml(_log, errorText, document);\r\n\r\n\t\t\tStatusUtils.setGlobalError(getSessionContext(), errorText);\r\n\t\t\tthrow new SearchException(errorText);\r\n\t\t}\r\n\t\t/*\r\n\t\t * Format and log the error\r\n\t\t */\r\n\t\tmessage   = DomUtils.getText(element);\r\n\t\terrorText = action\r\n\t\t          + \" error: \"\r\n\t\t          + (StringUtils.isNull(message) ? \"*unknown*\" : message);\r\n\r\n\t\tLogUtils.displayXml(_log, errorText, document);\r\n\t\t/*\r\n\t\t * Session timeout is a special case\r\n\t\t *\r\n\t\t * -- Re-initialize (clear the query URL)\r\n\t\t * -- Set \"global failure\" status\r\n\t\t * -- Throw the timeout exception\r\n\t\t */\r\n\t\tif (message.endsWith(NO_SESSION))\r\n\t\t{\r\n\t\t\tremoveQueryUrl(APPLICATION);\r\n\t\t\tStatusUtils.setGlobalError(getSessionContext(), \"Session timed out\");\r\n\t\t\tthrow new SessionTimeoutException();\r\n\t\t}\r\n\t\t/*\r\n\t\t * Set final status, abort\r\n\t\t */\r\n\t\tStatusUtils.setGlobalError(getSessionContext(), errorText);\r\n\t\tthrow new SearchException(errorText);\r\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Set up initial status information\n\t */\n\tpublic static void initialize(SessionContext sessionContext, String targets)\n\t{\n\t\tStringTokenizer parser \t\t= new StringTokenizer(targets, \" \\t,\");\n\t\tArrayList\t\t\t\tdbList\t\t= new ArrayList();\n\t\tHashMap\t\t\t\t\ttargetMap\t= getNewStatusMap(sessionContext);\n\n\t\t/*\n\t\t * Establish the DB list and initial (pre-LOGON) status\n\t\t */\n\t\twhile (parser.hasMoreTokens())\n\t\t{\n\t\t\tString \tdb \t\t\t\t= parser.nextToken();\n\t\t\tHashMap emptyMap \t= new HashMap();\n\n\t\t\t/*\n\t\t\t * Empty status entry\n\t\t\t */\n\t\t\temptyMap.put(\"STATUS\", \"INACTIVE\");\n\t\t\temptyMap.put(\"STATUS_MESSAGE\", \"<none>\");\n\n\t\t\temptyMap.put(\"HITS\", \"0\");\n\t\t\temptyMap.put(\"ESTIMATE\", \"0\");\n\t\t\temptyMap.put(\"MERGED\", \"0\");\n\t\t\t/*\n\t\t\t * Save\n\t\t\t */\n      dbList.add(db);\n      targetMap.put(db, emptyMap);\n\t\t}\n\n\t\tsessionContext.put(\"TARGETS\", dbList);\n\t\tsessionContext.putInt(\"active\", 0);\n\n\t\tsessionContext.put(\"STATUS\", \"INACTIVE\");\n\t\tsessionContext.put(\"STATUS_MESSAGE\", \"<none>\");\n\t}","id":31422,"modified_method":"/**\n\t * Set up initial status information\n\t */\n\tpublic static void initialize(SessionContext sessionContext, String targets)\n\t{\n\t\tStringTokenizer parser \t\t= new StringTokenizer(targets, \" \\t,\");\n\t\tArrayList\t\t\t\tdbList\t\t= new ArrayList();\n\t\tHashMap\t\t\t\t\ttargetMap\t= getNewStatusMap(sessionContext);\n\n\t\t/*\n\t\t * Establish the DB list and initial (pre-LOGON) status\n\t\t */\n\t\twhile (parser.hasMoreTokens())\n\t\t{\n\t\t\tString \tdb \t\t\t\t= parser.nextToken();\n\t\t\tHashMap emptyMap \t= new HashMap();\n\n\t\t\t/*\n\t\t\t * Empty status entry\n\t\t\t */\n\t\t\temptyMap.put(\"STATUS\", \"INACTIVE\");\n\t\t\temptyMap.put(\"STATUS_MESSAGE\", \"<none>\");\n\n\t\t\temptyMap.put(\"HITS\", \"0\");\n\t\t\temptyMap.put(\"ESTIMATE\", \"0\");\n\t\t\temptyMap.put(\"MERGED\", \"0\");\n\t\t\t/*\n\t\t\t * Save\n\t\t\t */\n      dbList.add(db);\n      targetMap.put(db, emptyMap);\n\t\t}\n\n\t\tsessionContext.put(\"TARGETS\", dbList);\n\t\tsessionContext.putInt(\"active\", 0);\n\n\t\tsessionContext.put(\"STATUS\", \"INACTIVE\");\n\t\tsessionContext.put(\"STATUS_MESSAGE\", \"<none>\");\n\n\t\tsessionContext.putInt(\"TOTAL_ESTIMATE\", 0);\n\t\tsessionContext.putInt(\"TOTAL_HITS\", 0);\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Update the hit count for this target (database)\n\t * @param sessionContext Active SessionContext\n\t * @param target Database name\n\t * @return Updated hit count\n\t */\n\tpublic static int updateHits(SessionContext sessionContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t String target)\n\t{\n\t\tMap\t\t\t\ttargetMap;\n\t\tString\t\thits;\n\t\tint\t\t\t\ttotal, estimate;\n\n\t\tif (StringUtils.isNull(target))\n\t\t{\n\t\t\tthrow new SearchException(\"No target database to update\");\n\t\t}\n\n\t\tif ((targetMap = getStatusMapForTarget(sessionContext, target)) == null)\n\t\t{\n\t\t\tthrow new SearchException(\"No status map found for target database \" + target);\n\t\t}\n  \t_log.debug(\"Map for target \" + target + \": \" + targetMap);\n\t\t/*\n\t\t * Update total hits from this search source\n\t\t */\n\t\thits \t= (String) targetMap.get(\"HITS\");\n\t\ttotal = Integer.parseInt(hits) + 1;\n\t\ttargetMap.put(\"HITS\", String.valueOf(total));\n\t\t/*\n\t\t * Have we collected all available results?\n\t\t */\n\t\testimate = Integer.parseInt((String) targetMap.get(\"ESTIMATE\"));\n\t\tif (estimate == total)\n\t\t{\n\t\t\tint active = sessionContext.getInt(\"active\");\n\t\t\t/*\n\t\t\t * If this is the last active source, mark everything DONE\n\t\t\t */\n\t\t\tif (--active <= 0)\n\t\t\t{\n\t\t\t\tsetAllComplete(sessionContext);\n\t\t\t}\n\t\t\telse\n\t\t\t{\t/*\n\t\t\t\t * Just this source is finished\n\t\t\t\t */\n\t\t\t\ttargetMap.put(\"STATUS\", \"DONE\");\n\t\t\t\ttargetMap.put(\"STATUS_MESSAGE\", \"Search complete\");\n\t\t\t}\n\t\t\tsessionContext.putInt(\"active\", active);\n\t\t}\n\t\treturn total;\n\t}","id":31423,"modified_method":"/**\n\t * Update the hit count for this target (database)\n\t * @param sessionContext Active SessionContext\n\t * @param target Database name\n\t * @return Updated hit count\n\t */\n\tpublic static int updateHits(SessionContext sessionContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t String target)\n\t{\n\t\tMap\t\t\t\ttargetMap;\n\t\tString\t\thits;\n\t\tint\t\t\t\ttotal, totalHits, estimate;\n\n\t\tif (StringUtils.isNull(target))\n\t\t{\n\t\t\tthrow new SearchException(\"No target database to update\");\n\t\t}\n\n\t\tif ((targetMap = getStatusMapForTarget(sessionContext, target)) == null)\n\t\t{\n\t\t\tthrow new SearchException(\"No status map found for target database \" + target);\n\t\t}\n  \t_log.debug(\"Map for target \" + target + \": \" + targetMap);\n\t\t/*\n\t\t * Update total hits from this search source\n\t\t */\n\t\thits \t= (String) targetMap.get(\"HITS\");\n\t\ttotal = Integer.parseInt(hits) + 1;\n\t\ttargetMap.put(\"HITS\", String.valueOf(total));\n\n    totalHits = sessionContext.getInt(\"TOTAL_HITS\") + 1;\n\t\tsessionContext.putInt(\"TOTAL_HITS\", totalHits);\n\t\t/*\n\t\t * Have we collected all available results?\n\t\t */\n\t\testimate = Integer.parseInt((String) targetMap.get(\"ESTIMATE\"));\n\t\tif (estimate == total)\n\t\t{\n\t\t\tint active = sessionContext.getInt(\"active\");\n\t\t\t/*\n\t\t\t * If this is the last active source, mark everything DONE\n\t\t\t */\n\t\t\tif (--active <= 0)\n\t\t\t{\n\t\t\t\tsetAllComplete(sessionContext);\n\t\t\t}\n\t\t\telse\n\t\t\t{\t/*\n\t\t\t\t * Just this source is finished\n\t\t\t\t */\n\t\t\t\ttargetMap.put(\"STATUS\", \"DONE\");\n\t\t\t\ttargetMap.put(\"STATUS_MESSAGE\", \"Search complete\");\n\t\t\t}\n\t\t\tsessionContext.putInt(\"active\", active);\n\t\t}\n\t\treturn total;\n\t}","commit_id":"0fc19df1a8e9558cac3c64bf53fa25ff1e04706e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"List<JCStatement> transformSpecifiedMethodBody(Tree.MethodDeclaration  def, SpecifierExpression specifierExpression) {\n        final Method model = def.getDeclarationModel();\n        List<JCStatement> body;\n        MethodDeclaration methodDecl = (MethodDeclaration)def;\n        boolean returnNull = false;\n        JCExpression bodyExpr;\n        Tree.Term term = null;\n        if (specifierExpression != null\n                && specifierExpression.getExpression() != null) {\n            term = specifierExpression.getExpression().getTerm();\n        }\n        if (term instanceof Tree.FunctionArgument) {\n            // Method specified with lambda: Don't bother generating a \n            // Callable, just transform the expr to use as the method body.\n            Tree.FunctionArgument fa = (Tree.FunctionArgument)term;\n            ProducedType resultType = model.getType();\n            returnNull = isVoid(resultType) && fa.getExpression().getUnboxed();\n            final java.util.List<com.redhat.ceylon.compiler.typechecker.tree.Tree.Parameter> lambdaParams = fa.getParameterLists().get(0).getParameters();\n            final java.util.List<com.redhat.ceylon.compiler.typechecker.tree.Tree.Parameter> defParams = def.getParameterLists().get(0).getParameters();\n            List<Substitution> substitutions = List.nil();\n            for (int ii = 0; ii < lambdaParams.size(); ii++) {\n                substitutions = substitutions.append(naming.addVariableSubst(lambdaParams.get(ii).getDeclarationModel(), \n                        defParams.get(ii).getIdentifier().getText()));\n            }\n            bodyExpr = gen().expressionGen().transformExpression(fa.getExpression(), BoxingStrategy.UNBOXED, null);\n            bodyExpr = gen().expressionGen().applyErasureAndBoxing(bodyExpr, resultType, \n                    true, \n                    model.getUnboxed() ? BoxingStrategy.UNBOXED : BoxingStrategy.BOXED, \n                            resultType);\n            for (Substitution subs : substitutions) {\n                subs.close();\n            }\n        } else {\n            returnNull = isVoid(getReturnTypeOfCallable(term.getTypeModel())) && term.getUnboxed();\n            InvocationBuilder specifierBuilder = InvocationBuilder.forSpecifierInvocation(gen(), specifierExpression, methodDecl.getDeclarationModel());\n            bodyExpr = specifierBuilder.build();\n        }\n        if (!Decl.isUnboxedVoid(model) || Strategy.useBoxedVoid(model)) {\n            if (returnNull) {\n                body = List.<JCStatement>of(make().Exec(bodyExpr), make().Return(makeNull()));\n            } else {\n                body = List.<JCStatement>of(make().Return(bodyExpr));\n            }\n        } else {\n            body = List.<JCStatement>of(make().Exec(bodyExpr));\n        }\n        return body;\n    }","id":31424,"modified_method":"List<JCStatement> transformSpecifiedMethodBody(Tree.MethodDeclaration  def, SpecifierExpression specifierExpression) {\n        final Method model = def.getDeclarationModel();\n        List<JCStatement> body;\n        MethodDeclaration methodDecl = (MethodDeclaration)def;\n        boolean returnNull = false;\n        JCExpression bodyExpr;\n        Tree.Term term = null;\n        if (specifierExpression != null\n                && specifierExpression.getExpression() != null) {\n            term = specifierExpression.getExpression().getTerm();\n        }\n        if (term instanceof Tree.FunctionArgument) {\n            // Method specified with lambda: Don't bother generating a \n            // Callable, just transform the expr to use as the method body.\n            Tree.FunctionArgument fa = (Tree.FunctionArgument)term;\n            ProducedType resultType = model.getType();\n            returnNull = isVoid(resultType) && fa.getExpression().getUnboxed();\n            final java.util.List<com.redhat.ceylon.compiler.typechecker.tree.Tree.Parameter> lambdaParams = fa.getParameterLists().get(0).getParameters();\n            final java.util.List<com.redhat.ceylon.compiler.typechecker.tree.Tree.Parameter> defParams = def.getParameterLists().get(0).getParameters();\n            List<Substitution> substitutions = List.nil();\n            for (int ii = 0; ii < lambdaParams.size(); ii++) {\n                substitutions = substitutions.append(naming.addVariableSubst(lambdaParams.get(ii).getDeclarationModel(), \n                        defParams.get(ii).getIdentifier().getText()));\n            }\n            bodyExpr = gen().expressionGen().transformExpression(fa.getExpression(), BoxingStrategy.UNBOXED, null);\n            bodyExpr = gen().expressionGen().applyErasureAndBoxing(bodyExpr, resultType, \n                    true, \n                    model.getUnboxed() ? BoxingStrategy.UNBOXED : BoxingStrategy.BOXED, \n                            resultType);\n            for (Substitution subs : substitutions) {\n                subs.close();\n            }\n        } else if (term.getTypeModel() instanceof Functional) {\n            returnNull = isVoid(term.getTypeModel()) && term.getUnboxed();\n            InvocationBuilder specifierBuilder = InvocationBuilder.forSpecifierInvocation(gen(), specifierExpression, methodDecl.getDeclarationModel());\n            bodyExpr = specifierBuilder.build();\n        } else {\n            bodyExpr = expressionGen().transformExpression(term);\n        }\n        if (!Decl.isUnboxedVoid(model) || Strategy.useBoxedVoid(model)) {\n            if (returnNull) {\n                body = List.<JCStatement>of(make().Exec(bodyExpr), make().Return(makeNull()));\n            } else {\n                body = List.<JCStatement>of(make().Return(bodyExpr));\n            }\n        } else {\n            body = List.<JCStatement>of(make().Exec(bodyExpr));\n        }\n        return body;\n    }","commit_id":"5aa4585ef2f754506592470f4fc49fc6136aa256","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Tree.IfExpression that){\n        super.visit(that);\n        if(that.getIfClause() == null\n                || that.getElseClause() == null)\n            return;\n        Tree.Expression ifExpr = that.getIfClause().getExpression();\n        Tree.Expression elseExpr = that.getElseClause().getExpression();\n        if(ifExpr == null || elseExpr == null)\n            return;\n        if(CodegenUtil.isUnBoxed(ifExpr) \n                && CodegenUtil.isUnBoxed(elseExpr)\n                && !willEraseToObject(that.getTypeModel()))\n            CodegenUtil.markUnBoxed(that);\n        if(CodegenUtil.isRaw(ifExpr) || CodegenUtil.isRaw(elseExpr))\n            CodegenUtil.markRaw(that);\n        if(CodegenUtil.hasTypeErased(ifExpr) || CodegenUtil.hasTypeErased(elseExpr))\n            CodegenUtil.markTypeErased(that);\n        if(CodegenUtil.hasUntrustedType(ifExpr) || CodegenUtil.hasUntrustedType(elseExpr))\n            CodegenUtil.markUntrustedType(that);\n    }","id":31425,"modified_method":"@Override\n    public void visit(Tree.IfExpression that){\n        super.visit(that);\n        if(that.getIfClause() == null\n                || that.getElseClause() == null)\n            return;\n        Tree.Expression ifExpr = that.getIfClause().getExpression();\n        Tree.Expression elseExpr = that.getElseClause().getExpression();\n        if(ifExpr == null || elseExpr == null)\n            return;\n        if(CodegenUtil.isUnBoxed(ifExpr) \n                && CodegenUtil.isUnBoxed(elseExpr)\n                && !willEraseToObject(that.getUnit().denotableType(that.getTypeModel())))\n            CodegenUtil.markUnBoxed(that);\n        if(CodegenUtil.isRaw(ifExpr) || CodegenUtil.isRaw(elseExpr))\n            CodegenUtil.markRaw(that);\n        if(CodegenUtil.hasTypeErased(ifExpr) || CodegenUtil.hasTypeErased(elseExpr))\n            CodegenUtil.markTypeErased(that);\n        if(CodegenUtil.hasUntrustedType(ifExpr) || CodegenUtil.hasUntrustedType(elseExpr))\n            CodegenUtil.markUntrustedType(that);\n    }","commit_id":"307336728a8d31fe947b36f62b7e7806a023679f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Tree.SwitchExpression that){\n        super.visit(that);\n        SwitchCaseList caseList = that.getSwitchCaseList();\n        if(caseList == null || caseList.getCaseClauses() == null)\n            return;\n        boolean unboxed = true;\n        for(Tree.CaseClause caseClause : caseList.getCaseClauses()){\n            Expression expr = caseClause.getExpression();\n            if(expr == null)\n                return;\n            // a single boxed one makes the whole switch boxed\n            if(!CodegenUtil.isUnBoxed(expr))\n                unboxed = false;\n            // for the rest a single raw/erased/untrusted marks the switch as so\n            if(CodegenUtil.isRaw(expr))\n                CodegenUtil.markRaw(that);\n            if(CodegenUtil.hasTypeErased(expr))\n                CodegenUtil.markTypeErased(that);\n            if(CodegenUtil.hasUntrustedType(expr))\n                CodegenUtil.markUntrustedType(that);\n        }\n        if(caseList.getElseClause() != null){\n            Expression expr = caseList.getElseClause().getExpression();\n            if(expr == null)\n                return;\n            // a single boxed one makes the whole switch boxed\n            if(!CodegenUtil.isUnBoxed(expr))\n                unboxed = false;\n            // for the rest a single raw/erased/untrusted marks the switch as so\n            if(CodegenUtil.isRaw(expr))\n                CodegenUtil.markRaw(that);\n            if(CodegenUtil.hasTypeErased(expr))\n                CodegenUtil.markTypeErased(that);\n            if(CodegenUtil.hasUntrustedType(expr))\n                CodegenUtil.markUntrustedType(that);\n        }\n        if(unboxed \n                && !willEraseToObject(that.getTypeModel()))\n            CodegenUtil.markUnBoxed(that);\n    }","id":31426,"modified_method":"@Override\n    public void visit(Tree.SwitchExpression that){\n        super.visit(that);\n        SwitchCaseList caseList = that.getSwitchCaseList();\n        if(caseList == null || caseList.getCaseClauses() == null)\n            return;\n        boolean unboxed = true;\n        for(Tree.CaseClause caseClause : caseList.getCaseClauses()){\n            Expression expr = caseClause.getExpression();\n            if(expr == null)\n                return;\n            // a single boxed one makes the whole switch boxed\n            if(!CodegenUtil.isUnBoxed(expr))\n                unboxed = false;\n            // for the rest a single raw/erased/untrusted marks the switch as so\n            if(CodegenUtil.isRaw(expr))\n                CodegenUtil.markRaw(that);\n            if(CodegenUtil.hasTypeErased(expr))\n                CodegenUtil.markTypeErased(that);\n            if(CodegenUtil.hasUntrustedType(expr))\n                CodegenUtil.markUntrustedType(that);\n        }\n        if(caseList.getElseClause() != null){\n            Expression expr = caseList.getElseClause().getExpression();\n            if(expr == null)\n                return;\n            // a single boxed one makes the whole switch boxed\n            if(!CodegenUtil.isUnBoxed(expr))\n                unboxed = false;\n            // for the rest a single raw/erased/untrusted marks the switch as so\n            if(CodegenUtil.isRaw(expr))\n                CodegenUtil.markRaw(that);\n            if(CodegenUtil.hasTypeErased(expr))\n                CodegenUtil.markTypeErased(that);\n            if(CodegenUtil.hasUntrustedType(expr))\n                CodegenUtil.markUntrustedType(that);\n        }\n        if(unboxed \n                && !willEraseToObject(that.getUnit().denotableType(that.getTypeModel())))\n            CodegenUtil.markUnBoxed(that);\n    }","commit_id":"307336728a8d31fe947b36f62b7e7806a023679f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Test\n    public void testOrder_With1ExtraConfig() throws IOException\n    {\n        // Create home\n        File home = testdir.getFile(\"home\");\n        FS.ensureEmpty(home);\n        TestEnv.copyTestDir(\"dist-home\",home);\n\n        // Create common\n        File common = testdir.getFile(\"common\");\n        FS.ensureEmpty(common);\n\n        // Create base\n        File base = testdir.getFile(\"base\");\n        FS.ensureEmpty(base);\n        TestEnv.makeFile(base,\"start.ini\", //\n                \"jetty.http.host=127.0.0.1\",//\n                \"--include-jetty-dir=\" + common.getAbsolutePath());\n\n        ConfigSources sources = new ConfigSources();\n\n        String[] cmdLine = new String[0];\n        sources.add(new CommandLineConfigSource(cmdLine));\n        sources.add(new JettyHomeConfigSource(home.toPath()));\n        sources.add(new JettyBaseConfigSource(base.toPath()));\n\n        assertIdOrder(sources,\"<command-line>\",\"${jetty.base}\",common.getAbsolutePath(),\"${jetty.home}\");\n    }","id":31427,"modified_method":"@Test\n    public void testOrder_With1ExtraConfig() throws IOException\n    {\n        // Create home\n        File home = testdir.getFile(\"home\");\n        FS.ensureEmpty(home);\n        TestEnv.copyTestDir(\"dist-home\",home);\n\n        // Create common\n        Path common = testdir.getFile(\"common\").toPath();\n        FS.ensureEmpty(common.toFile());\n        common = common.toRealPath();\n\n        // Create base\n        File base = testdir.getFile(\"base\");\n        FS.ensureEmpty(base);\n        TestEnv.makeFile(base,\"start.ini\", //\n                \"jetty.http.host=127.0.0.1\",//\n                \"--include-jetty-dir=\" + common.toString());\n\n        ConfigSources sources = new ConfigSources();\n\n        String[] cmdLine = new String[0];\n        sources.add(new CommandLineConfigSource(cmdLine));\n        sources.add(new JettyHomeConfigSource(home.toPath().toRealPath()));\n        sources.add(new JettyBaseConfigSource(base.toPath().toRealPath()));\n\n        assertIdOrder(sources,\"<command-line>\",\"${jetty.base}\",common.toString(),\"${jetty.home}\");\n    }","commit_id":"194b1d349a0dca6b195df29e9a4b6e9cb559760a","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Create DirConfigSource with specified identifier and directory.\n     * \n     * @param id\n     *            the identifier for this {@link ConfigSource}\n     * @param dir\n     *            the directory for this {@link ConfigSource}\n     * @param weight\n     *            the configuration weight (used for search order)\n     * @param canHaveArgs\n     *            true if this directory can have start.ini or start.d entries. (false for directories like ${jetty.home}, for example)\n     * @throws IOException\n     *             if unable to load the configuration args\n     */\n    public DirConfigSource(String id, Path dir, int weight, boolean canHaveArgs) throws IOException\n    {\n        this.id = id;\n        this.dir = dir.toAbsolutePath();\n        this.weight = weight;\n        this.props = new Props();\n\n        this.args = new RawArgs();\n\n        if (canHaveArgs)\n        {\n            Path iniFile = dir.resolve(\"start.ini\").toRealPath();\n            if (FS.canReadFile(iniFile))\n            {\n                StartIni ini = new StartIni(iniFile);\n                args.addAll(ini.getLines(),iniFile);\n                parseAllArgs(ini.getLines(),iniFile.toString());\n            }\n\n            Path startDdir = dir.resolve(\"start.d\");\n\n            if (FS.canReadDirectory(startDdir))\n            {\n                DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>()\n                {\n                    PathMatcher iniMatcher = PathMatchers.getMatcher(\"glob:**/start.d/*.ini\");\n\n                    @Override\n                    public boolean accept(Path entry) throws IOException\n                    {\n                        return iniMatcher.matches(entry);\n                    }\n                };\n\n                List<Path> paths = new ArrayList<>();\n\n                for (Path diniFile : Files.newDirectoryStream(startDdir,filter))\n                {\n                    if (FS.canReadFile(diniFile))\n                    {\n                        paths.add(diniFile);\n                    }\n                }\n\n                Collections.sort(paths,new NaturalSort.Paths());\n\n                for (Path diniFile : paths)\n                {\n                    StartLog.debug(\"Reading %s/start.d/%s - %s\",id,diniFile.getFileName(),diniFile);\n                    StartIni ini = new StartIni(diniFile);\n                    args.addAll(ini.getLines(),diniFile);\n                    parseAllArgs(ini.getLines(),diniFile.toString());\n                }\n            }\n        }\n    }","id":31428,"modified_method":"/**\n     * Create DirConfigSource with specified identifier and directory.\n     * \n     * @param id\n     *            the identifier for this {@link ConfigSource}\n     * @param dir\n     *            the directory for this {@link ConfigSource}\n     * @param weight\n     *            the configuration weight (used for search order)\n     * @param canHaveArgs\n     *            true if this directory can have start.ini or start.d entries. (false for directories like ${jetty.home}, for example)\n     * @throws IOException\n     *             if unable to load the configuration args\n     */\n    public DirConfigSource(String id, Path dir, int weight, boolean canHaveArgs) throws IOException\n    {\n        this.id = id;\n        this.dir = dir.toAbsolutePath();\n        this.weight = weight;\n        this.props = new Props();\n\n        this.args = new RawArgs();\n\n        if (canHaveArgs)\n        {\n            Path iniFile = dir.resolve(\"start.ini\").normalize().toAbsolutePath();\n            \n            try\n            {\n                iniFile = iniFile.toRealPath();\n                if (FS.canReadFile(iniFile))\n                {\n                    StartIni ini = new StartIni(iniFile);\n                    args.addAll(ini.getLines(),iniFile);\n                    parseAllArgs(ini.getLines(),iniFile.toString());\n                }\n            }\n            catch (NoSuchFileException ignore)\n            {\n                // ignore\n            }\n\n            Path startDdir = dir.resolve(\"start.d\");\n\n            if (FS.canReadDirectory(startDdir))\n            {\n                DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>()\n                {\n                    PathMatcher iniMatcher = PathMatchers.getMatcher(\"glob:**/start.d/*.ini\");\n\n                    @Override\n                    public boolean accept(Path entry) throws IOException\n                    {\n                        return iniMatcher.matches(entry);\n                    }\n                };\n\n                List<Path> paths = new ArrayList<>();\n\n                for (Path diniFile : Files.newDirectoryStream(startDdir,filter))\n                {\n                    if (FS.canReadFile(diniFile))\n                    {\n                        paths.add(diniFile);\n                    }\n                }\n\n                Collections.sort(paths,new NaturalSort.Paths());\n\n                for (Path diniFile : paths)\n                {\n                    StartLog.debug(\"Reading %s/start.d/%s - %s\",id,diniFile.getFileName(),diniFile);\n                    StartIni ini = new StartIni(diniFile);\n                    args.addAll(ini.getLines(),diniFile);\n                    parseAllArgs(ini.getLines(),diniFile.toString());\n                }\n            }\n        }\n    }","commit_id":"194b1d349a0dca6b195df29e9a4b6e9cb559760a","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testWithHttp2() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n\n        File homePath = MavenTestingUtils.getTestResourceDir(\"dist-home\").getAbsoluteFile();\n        cmdLineArgs.add(\"jetty.home=\" + homePath);\n        cmdLineArgs.add(\"user.dir=\" + homePath);\n        cmdLineArgs.add(\"java.version=1.7.0_60\");\n\n        // Modules\n        cmdLineArgs.add(\"--module=deploy\");\n        cmdLineArgs.add(\"--module=http2\");\n\n        Main main = new Main();\n\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n\n        assertThat(\"jetty.home\",baseHome.getHome(),is(homePath.getAbsolutePath()));\n        assertThat(\"jetty.base\",baseHome.getBase(),is(homePath.getAbsolutePath()));\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home-with-http2.txt\");\n    }","id":31429,"modified_method":"@Test\n    public void testWithHttp2() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n\n        Path homePath = MavenTestingUtils.getTestResourceDir(\"dist-home\").toPath().toRealPath();\n        cmdLineArgs.add(\"jetty.home=\" + homePath);\n        cmdLineArgs.add(\"user.dir=\" + homePath);\n        cmdLineArgs.add(\"java.version=1.7.0_60\");\n\n        // Modules\n        cmdLineArgs.add(\"--module=deploy\");\n        cmdLineArgs.add(\"--module=http2\");\n\n        Main main = new Main();\n\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n\n        assertThat(\"jetty.home\",baseHome.getHome(),is(homePath.toString()));\n        assertThat(\"jetty.base\",baseHome.getBase(),is(homePath.toString()));\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home-with-http2.txt\");\n    }","commit_id":"194b1d349a0dca6b195df29e9a4b6e9cb559760a","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testBasicProcessing() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n        File testJettyHome = MavenTestingUtils.getTestResourceDir(\"dist-home\").getAbsoluteFile();\n        cmdLineArgs.add(\"user.dir=\" + testJettyHome);\n        cmdLineArgs.add(\"jetty.home=\" + testJettyHome);\n        cmdLineArgs.add(\"jetty.http.port=9090\");\n\n        Main main = new Main();\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n        System.err.println(args);\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home.txt\");\n    }","id":31430,"modified_method":"@Test\n    public void testBasicProcessing() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n        Path testJettyHome = MavenTestingUtils.getTestResourceDir(\"dist-home\").toPath().toRealPath();\n        cmdLineArgs.add(\"user.dir=\" + testJettyHome);\n        cmdLineArgs.add(\"jetty.home=\" + testJettyHome);\n        cmdLineArgs.add(\"jetty.http.port=9090\");\n\n        Main main = new Main();\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n        System.err.println(args);\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home.txt\");\n    }","commit_id":"194b1d349a0dca6b195df29e9a4b6e9cb559760a","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testWithCommandLine() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n\n        File homePath = MavenTestingUtils.getTestResourceDir(\"dist-home\").getAbsoluteFile();\n        cmdLineArgs.add(\"jetty.home=\" + homePath);\n        cmdLineArgs.add(\"user.dir=\" + homePath);\n\n        // JVM args\n        cmdLineArgs.add(\"--exec\");\n        cmdLineArgs.add(\"-Xms1024m\");\n        cmdLineArgs.add(\"-Xmx1024m\");\n\n        // Arbitrary Libs\n        Path extraJar = MavenTestingUtils.getTestResourceFile(\"extra-libs/example.jar\").toPath().normalize();\n        Path extraDir = MavenTestingUtils.getTestResourceDir(\"extra-resources\").toPath().normalize();\n        \n        extraJar = extraJar.toAbsolutePath();\n        extraDir = extraDir.toAbsolutePath();\n        \n        assertThat(\"Extra Jar exists: \" + extraJar,Files.exists(extraJar),is(true));\n        assertThat(\"Extra Dir exists: \" + extraDir,Files.exists(extraDir),is(true));\n        \n        StringBuilder lib = new StringBuilder();\n        lib.append(\"--lib=\");\n        lib.append(extraJar.toString());\n        lib.append(File.pathSeparator);\n        lib.append(extraDir.toString());\n        \n        cmdLineArgs.add(lib.toString());\n\n        // Arbitrary XMLs\n        cmdLineArgs.add(\"jetty.xml\");\n        cmdLineArgs.add(\"jetty-jmx.xml\");\n        cmdLineArgs.add(\"jetty-logging.xml\");\n\n        Main main = new Main();\n\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n\n        assertThat(\"jetty.home\",baseHome.getHome(),is(homePath.getAbsolutePath()));\n        assertThat(\"jetty.base\",baseHome.getBase(),is(homePath.getAbsolutePath()));\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home-with-jvm.txt\");\n    }","id":31431,"modified_method":"@Test\n    public void testWithCommandLine() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n\n        Path homePath = MavenTestingUtils.getTestResourceDir(\"dist-home\").toPath().toRealPath();\n        cmdLineArgs.add(\"jetty.home=\" + homePath.toString());\n        cmdLineArgs.add(\"user.dir=\" + homePath.toString());\n\n        // JVM args\n        cmdLineArgs.add(\"--exec\");\n        cmdLineArgs.add(\"-Xms1024m\");\n        cmdLineArgs.add(\"-Xmx1024m\");\n\n        // Arbitrary Libs\n        Path extraJar = MavenTestingUtils.getTestResourceFile(\"extra-libs/example.jar\").toPath().toRealPath();\n        Path extraDir = MavenTestingUtils.getTestResourceDir(\"extra-resources\").toPath().toRealPath();\n        \n        assertThat(\"Extra Jar exists: \" + extraJar,Files.exists(extraJar),is(true));\n        assertThat(\"Extra Dir exists: \" + extraDir,Files.exists(extraDir),is(true));\n        \n        StringBuilder lib = new StringBuilder();\n        lib.append(\"--lib=\");\n        lib.append(extraJar.toString());\n        lib.append(File.pathSeparator);\n        lib.append(extraDir.toString());\n        \n        cmdLineArgs.add(lib.toString());\n\n        // Arbitrary XMLs\n        cmdLineArgs.add(\"jetty.xml\");\n        cmdLineArgs.add(\"jetty-jmx.xml\");\n        cmdLineArgs.add(\"jetty-logging.xml\");\n\n        Main main = new Main();\n\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n\n        assertThat(\"jetty.home\",baseHome.getHome(),is(homePath.toString()));\n        assertThat(\"jetty.base\",baseHome.getBase(),is(homePath.toString()));\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home-with-jvm.txt\");\n    }","commit_id":"194b1d349a0dca6b195df29e9a4b6e9cb559760a","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testJettyHomeWithSpaces() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n\n        File homePath = MavenTestingUtils.getTestResourceDir(\"jetty home with spaces\").getAbsoluteFile();\n        cmdLineArgs.add(\"user.dir=\" + homePath);\n        cmdLineArgs.add(\"jetty.home=\" + homePath);\n\n        Main main = new Main();\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n\n        assertThat(\"jetty.home\",baseHome.getHome(),is(homePath.getAbsolutePath()));\n        assertThat(\"jetty.base\",baseHome.getBase(),is(homePath.getAbsolutePath()));\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home-with-spaces.txt\");\n    }","id":31432,"modified_method":"@Test\n    public void testJettyHomeWithSpaces() throws Exception\n    {\n        List<String> cmdLineArgs = new ArrayList<>();\n\n        Path homePath = MavenTestingUtils.getTestResourceDir(\"jetty home with spaces\").toPath().toRealPath();\n        cmdLineArgs.add(\"user.dir=\" + homePath);\n        cmdLineArgs.add(\"jetty.home=\" + homePath);\n\n        Main main = new Main();\n        StartArgs args = main.processCommandLine(cmdLineArgs.toArray(new String[cmdLineArgs.size()]));\n        BaseHome baseHome = main.getBaseHome();\n\n        assertThat(\"jetty.home\",baseHome.getHome(),is(homePath.toString()));\n        assertThat(\"jetty.base\",baseHome.getBase(),is(homePath.toString()));\n\n        ConfigurationAssert.assertConfiguration(baseHome,args,\"assert-home-with-spaces.txt\");\n    }","commit_id":"194b1d349a0dca6b195df29e9a4b6e9cb559760a","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected Field getField(\n\t\t\tElement dynamicElementElement, DDMStructure ddmStructure,\n\t\t\tString[] availableLanguageIds, String defaultLanguageId)\n\t\tthrows PortalException {\n\n\t\tField ddmField = new Field();\n\n\t\tddmField.setDDMStructureId(ddmStructure.getStructureId());\n\t\tddmField.setDefaultLocale(LocaleUtil.fromLanguageId(defaultLanguageId));\n\n\t\tString name = dynamicElementElement.attributeValue(\"name\");\n\n\t\tddmField.setName(name);\n\n\t\tString dataType = ddmStructure.getFieldDataType(name);\n\t\tString type = ddmStructure.getFieldType(name);\n\n\t\tSet<String> missingLanguageIds = SetUtil.fromArray(\n\t\t\tavailableLanguageIds);\n\n\t\tmissingLanguageIds.remove(defaultLanguageId);\n\n\t\tList<Element> dynamicContentElements = dynamicElementElement.elements(\n\t\t\t\"dynamic-content\");\n\n\t\tfor (Element dynamicContentElement : dynamicContentElements) {\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(defaultLanguageId);\n\n\t\t\tString languageId = dynamicContentElement.attributeValue(\n\t\t\t\t\"language-id\");\n\n\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\n\t\t\t\tmissingLanguageIds.remove(languageId);\n\t\t\t}\n\n\t\t\tSerializable serializable = getFieldValue(\n\t\t\t\tdataType, type, dynamicContentElement);\n\n\t\t\tddmField.addValue(locale, serializable);\n\t\t}\n\n\t\taddMissingFieldValues(ddmField, defaultLanguageId, missingLanguageIds);\n\n\t\treturn ddmField;\n\t}","id":31433,"modified_method":"protected Field getField(\n\t\t\tElement dynamicElementElement, DDMStructure ddmStructure,\n\t\t\tString[] availableLanguageIds, String defaultLanguageId)\n\t\tthrows PortalException {\n\n\t\tField ddmField = new Field();\n\n\t\tLocale defaultLocale = null;\n\n\t\tif (defaultLanguageId == null) {\n\t\t\tdefaultLocale = LocaleUtil.getSiteDefault();\n\t\t}\n\t\telse {\n\t\t\tdefaultLocale = LocaleUtil.fromLanguageId(defaultLanguageId);\n\t\t}\n\n\t\tddmField.setDDMStructureId(ddmStructure.getStructureId());\n\t\tddmField.setDefaultLocale(defaultLocale);\n\n\t\tString name = dynamicElementElement.attributeValue(\"name\");\n\n\t\tddmField.setName(name);\n\n\t\tString dataType = ddmStructure.getFieldDataType(name);\n\t\tString type = ddmStructure.getFieldType(name);\n\n\t\tSet<String> missingLanguageIds = SetUtil.fromArray(\n\t\t\tavailableLanguageIds);\n\n\t\tmissingLanguageIds.remove(defaultLanguageId);\n\n\t\tList<Element> dynamicContentElements = dynamicElementElement.elements(\n\t\t\t\"dynamic-content\");\n\n\t\tfor (Element dynamicContentElement : dynamicContentElements) {\n\t\t\tLocale locale = defaultLocale;\n\n\t\t\tString languageId = dynamicContentElement.attributeValue(\n\t\t\t\t\"language-id\");\n\n\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\n\t\t\t\tmissingLanguageIds.remove(languageId);\n\t\t\t}\n\n\t\t\tSerializable serializable = getFieldValue(\n\t\t\t\tdataType, type, dynamicContentElement);\n\n\t\t\tddmField.addValue(locale, serializable);\n\t\t}\n\n\t\taddMissingFieldValues(ddmField, defaultLanguageId, missingLanguageIds);\n\n\t\treturn ddmField;\n\t}","commit_id":"ec36a86b14ca5094c8580ffb41f26fc421d71939","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private ObjectValuePair<Map<String, Locale>, Map<String, Locale>>\n\t\t_createGroupLocales(long groupId) {\n\n\t\tString[] languageIds = null;\n\n\t\ttry {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\tgroup.getTypeSettingsProperties();\n\n\t\t\tlanguageIds = StringUtil.split(\n\t\t\t\ttypeSettingsProperties.getProperty(PropsKeys.LOCALES));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlanguageIds = PropsValues.LOCALES_ENABLED;\n\t\t}\n\n\t\tMap<String, Locale> groupLanguageCodeLocalesMap = new HashMap<>();\n\t\tMap<String, Locale> groupLanguageIdLocalesMap = new HashMap<>();\n\n\t\tfor (int i = 0; i < languageIds.length; i++) {\n\t\t\tString languageId = languageIds[i];\n\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(languageId, false);\n\n\t\t\tString language = languageId;\n\n\t\t\tint pos = languageId.indexOf(CharPool.UNDERLINE);\n\n\t\t\tif (pos > 0) {\n\t\t\t\tlanguage = languageId.substring(0, pos);\n\t\t\t}\n\n\t\t\tif (!groupLanguageCodeLocalesMap.containsKey(language)) {\n\t\t\t\tgroupLanguageCodeLocalesMap.put(language, locale);\n\t\t\t}\n\n\t\t\tgroupLanguageIdLocalesMap.put(\n\t\t\t\tLocaleUtil.toLanguageId(locale), locale);\n\t\t}\n\n\t\t_groupLanguageCodeLocalesMapMap.put(\n\t\t\tgroupId, groupLanguageCodeLocalesMap);\n\t\t_groupLanguageIdLocalesMap.put(groupId, groupLanguageIdLocalesMap);\n\n\t\treturn new ObjectValuePair<>(\n\t\t\tgroupLanguageCodeLocalesMap, groupLanguageIdLocalesMap);\n\t}","id":31434,"modified_method":"private ObjectValuePair<Map<String, Locale>, Map<String, Locale>>\n\t\t_createGroupLocales(long groupId) {\n\n\t\tString[] languageIds = PropsValues.LOCALES_ENABLED;\n\n\t\ttry {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\tgroup.getTypeSettingsProperties();\n\n\t\t\tlanguageIds = StringUtil.split(\n\t\t\t\ttypeSettingsProperties.getProperty(PropsKeys.LOCALES));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tMap<String, Locale> groupLanguageCodeLocalesMap = new HashMap<>();\n\t\tMap<String, Locale> groupLanguageIdLocalesMap = new HashMap<>();\n\n\t\tfor (String languageId : languageIds) {\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(languageId, false);\n\n\t\t\tString languageCode = languageId;\n\n\t\t\tint pos = languageId.indexOf(CharPool.UNDERLINE);\n\n\t\t\tif (pos > 0) {\n\t\t\t\tlanguageCode = languageId.substring(0, pos);\n\t\t\t}\n\n\t\t\tif (!groupLanguageCodeLocalesMap.containsKey(languageCode)) {\n\t\t\t\tgroupLanguageCodeLocalesMap.put(languageCode, locale);\n\t\t\t}\n\n\t\t\tgroupLanguageIdLocalesMap.put(languageId, locale);\n\t\t}\n\n\t\t_groupLanguageCodeLocalesMapMap.put(\n\t\t\tgroupId, groupLanguageCodeLocalesMap);\n\t\t_groupLanguageIdLocalesMap.put(groupId, groupLanguageIdLocalesMap);\n\n\t\treturn new ObjectValuePair<>(\n\t\t\tgroupLanguageCodeLocalesMap, groupLanguageIdLocalesMap);\n\t}","commit_id":"ad35315868ff3edbcbb9eac288af186ce9c0fad3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private LanguageImpl(long companyId) {\n\t\tString[] languageIds = PropsValues.LOCALES;\n\n\t\tif (companyId != CompanyConstants.SYSTEM) {\n\t\t\ttry {\n\t\t\t\tlanguageIds = PrefsPropsUtil.getStringArray(\n\t\t\t\t\tcompanyId, PropsKeys.LOCALES, StringPool.COMMA,\n\t\t\t\t\tPropsValues.LOCALES_ENABLED);\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tlanguageIds = PropsValues.LOCALES_ENABLED;\n\t\t\t}\n\t\t}\n\n\t\t_duplicateLanguageCodes = new HashSet<>();\n\t\t_languageCodeLocalesMap = new HashMap<>();\n\t\t_languageIdLocalesMap = new HashMap<>();\n\n\t\tfor (int i = 0; i < languageIds.length; i++) {\n\t\t\tString languageId = languageIds[i];\n\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(languageId, false);\n\n\t\t\tString language = languageId;\n\n\t\t\tint pos = languageId.indexOf(CharPool.UNDERLINE);\n\n\t\t\tif (pos > 0) {\n\t\t\t\tlanguage = languageId.substring(0, pos);\n\t\t\t}\n\n\t\t\tif (_languageCodeLocalesMap.containsKey(language)) {\n\t\t\t\t_duplicateLanguageCodes.add(language);\n\t\t\t}\n\n\t\t\tif (!_languageCodeLocalesMap.containsKey(language)) {\n\t\t\t\t_languageCodeLocalesMap.put(language, locale);\n\t\t\t}\n\n\t\t\t_languageIdLocalesMap.put(LocaleUtil.toLanguageId(locale), locale);\n\t\t}\n\n\t\tString[] localesBetaArray = PropsValues.LOCALES_BETA;\n\n\t\t_localesBetaSet = new HashSet<>();\n\n\t\tfor (String languageId : localesBetaArray) {\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(languageId, false);\n\n\t\t\t_localesBetaSet.add(locale);\n\t\t}\n\n\t\t_supportedLocalesSet = new HashSet<>(_languageIdLocalesMap.values());\n\n\t\t_supportedLocalesSet.removeAll(_localesBetaSet);\n\t}","id":31435,"modified_method":"private LanguageImpl(long companyId) {\n\t\tString[] languageIds = PropsValues.LOCALES;\n\n\t\tif (companyId != CompanyConstants.SYSTEM) {\n\t\t\ttry {\n\t\t\t\tlanguageIds = PrefsPropsUtil.getStringArray(\n\t\t\t\t\tcompanyId, PropsKeys.LOCALES, StringPool.COMMA,\n\t\t\t\t\tPropsValues.LOCALES_ENABLED);\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tlanguageIds = PropsValues.LOCALES_ENABLED;\n\t\t\t}\n\t\t}\n\n\t\tfor (String languageId : languageIds) {\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(languageId, false);\n\n\t\t\tString languageCode = languageId;\n\n\t\t\tint pos = languageId.indexOf(CharPool.UNDERLINE);\n\n\t\t\tif (pos > 0) {\n\t\t\t\tlanguageCode = languageId.substring(0, pos);\n\t\t\t}\n\n\t\t\tif (_languageCodeLocalesMap.containsKey(languageCode)) {\n\t\t\t\t_duplicateLanguageCodes.add(languageCode);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_languageCodeLocalesMap.put(languageCode, locale);\n\t\t\t}\n\n\t\t\t_languageIdLocalesMap.put(languageId, locale);\n\t\t}\n\n\t\tfor (String languageId : PropsValues.LOCALES_BETA) {\n\t\t\t_localesBetaSet.add(LocaleUtil.fromLanguageId(languageId, false));\n\t\t}\n\n\t\t_supportedLocalesSet = new HashSet<>(_languageIdLocalesMap.values());\n\n\t\t_supportedLocalesSet.removeAll(_localesBetaSet);\n\t}","commit_id":"ad35315868ff3edbcbb9eac288af186ce9c0fad3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean processTemplate(Writer writer) throws TemplateException {\n\t\tXSLURIResolver uriResolver = _xslTemplateResource.getURIResolver();\n\n\t\tLocale locale = null;\n\n\t\tif (uriResolver == null) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(null);\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.fromLanguageId(uriResolver.getLanguageId());\n\t\t}\n\n\t\tXSLErrorListener xslErrorListener = new XSLErrorListener(locale);\n\n\t\tTransformerFactory transformerFactory =\n\t\t\tTransformerFactory.newInstance();\n\n\t\ttransformerFactory.setErrorListener(xslErrorListener);\n\t\ttransformerFactory.setURIResolver(uriResolver);\n\n\t\tStreamSource xmlSource = new StreamSource(\n\t\t\t_xslTemplateResource.getXMLReader());\n\n\t\tTransformer transformer = _getTransformer(\n\t\t\ttransformerFactory, _xslTemplateResource);\n\n\t\tif (_errorTemplateResource == null) {\n\t\t\ttry {\n\t\t\t\ttransformer.transform(xmlSource, new StreamResult(writer));\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new TemplateException(\n\t\t\t\t\t\"Unable to process XSL template \" +\n\t\t\t\t\t\t_xslTemplateResource.getTemplateId(),\n\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter();\n\n\t\t\ttransformer.setParameter(WRITER, unsyncStringWriter);\n\n\t\t\ttransformer.transform(\n\t\t\t\txmlSource, new StreamResult(unsyncStringWriter));\n\n\t\t\tStringBundler sb = unsyncStringWriter.getStringBundler();\n\n\t\t\tsb.writeTo(writer);\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\tTransformer errorTransformer = _getTransformer(\n\t\t\t\ttransformerFactory, _errorTemplateResource);\n\n\t\t\terrorTransformer.setParameter(WRITER, writer);\n\t\t\terrorTransformer.setParameter(\n\t\t\t\t\"exception\", xslErrorListener.getMessageAndLocation());\n\n\t\t\tif (_errorTemplateResource instanceof StringTemplateResource) {\n\t\t\t\tStringTemplateResource stringTemplateResource =\n\t\t\t\t\t(StringTemplateResource)_errorTemplateResource;\n\n\t\t\t\terrorTransformer.setParameter(\n\t\t\t\t\t\"script\", stringTemplateResource.getContent());\n\t\t\t}\n\n\t\t\tif (xslErrorListener.getLocation() != null) {\n\t\t\t\terrorTransformer.setParameter(\n\t\t\t\t\t\"column\", new Integer(xslErrorListener.getColumnNumber()));\n\t\t\t\terrorTransformer.setParameter(\n\t\t\t\t\t\"line\", new Integer(xslErrorListener.getLineNumber()));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\terrorTransformer.transform(xmlSource, new StreamResult(writer));\n\t\t\t}\n\t\t\tcatch (Exception e2) {\n\t\t\t\tthrow new TemplateException(\n\t\t\t\t\t\"Unable to process XSL template \" +\n\t\t\t\t\t\t_errorTemplateResource.getTemplateId(),\n\t\t\t\t\te2);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}","id":31436,"modified_method":"public boolean processTemplate(Writer writer) throws TemplateException {\n\t\tXSLURIResolver uriResolver = _xslTemplateResource.getURIResolver();\n\n\t\tString languageId = null;\n\n\t\tif (uriResolver != null) {\n\t\t\tlanguageId = uriResolver.getLanguageId();\n\t\t}\n\n\t\tLocale locale = LocaleUtil.fromLanguageId(languageId);\n\n\t\tXSLErrorListener xslErrorListener = new XSLErrorListener(locale);\n\n\t\tTransformerFactory transformerFactory =\n\t\t\tTransformerFactory.newInstance();\n\n\t\ttransformerFactory.setErrorListener(xslErrorListener);\n\t\ttransformerFactory.setURIResolver(uriResolver);\n\n\t\tStreamSource xmlSource = new StreamSource(\n\t\t\t_xslTemplateResource.getXMLReader());\n\n\t\tTransformer transformer = _getTransformer(\n\t\t\ttransformerFactory, _xslTemplateResource);\n\n\t\tif (_errorTemplateResource == null) {\n\t\t\ttry {\n\t\t\t\ttransformer.transform(xmlSource, new StreamResult(writer));\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new TemplateException(\n\t\t\t\t\t\"Unable to process XSL template \" +\n\t\t\t\t\t\t_xslTemplateResource.getTemplateId(),\n\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter();\n\n\t\t\ttransformer.setParameter(WRITER, unsyncStringWriter);\n\n\t\t\ttransformer.transform(\n\t\t\t\txmlSource, new StreamResult(unsyncStringWriter));\n\n\t\t\tStringBundler sb = unsyncStringWriter.getStringBundler();\n\n\t\t\tsb.writeTo(writer);\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\tTransformer errorTransformer = _getTransformer(\n\t\t\t\ttransformerFactory, _errorTemplateResource);\n\n\t\t\terrorTransformer.setParameter(WRITER, writer);\n\t\t\terrorTransformer.setParameter(\n\t\t\t\t\"exception\", xslErrorListener.getMessageAndLocation());\n\n\t\t\tif (_errorTemplateResource instanceof StringTemplateResource) {\n\t\t\t\tStringTemplateResource stringTemplateResource =\n\t\t\t\t\t(StringTemplateResource)_errorTemplateResource;\n\n\t\t\t\terrorTransformer.setParameter(\n\t\t\t\t\t\"script\", stringTemplateResource.getContent());\n\t\t\t}\n\n\t\t\tif (xslErrorListener.getLocation() != null) {\n\t\t\t\terrorTransformer.setParameter(\n\t\t\t\t\t\"column\", new Integer(xslErrorListener.getColumnNumber()));\n\t\t\t\terrorTransformer.setParameter(\n\t\t\t\t\t\"line\", new Integer(xslErrorListener.getLineNumber()));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\terrorTransformer.transform(xmlSource, new StreamResult(writer));\n\t\t\t}\n\t\t\tcatch (Exception e2) {\n\t\t\t\tthrow new TemplateException(\n\t\t\t\t\t\"Unable to process XSL template \" +\n\t\t\t\t\t\t_errorTemplateResource.getTemplateId(),\n\t\t\t\t\te2);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"b7570317a1b9f8d17618f4463a06377717176947","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void readExternal(ObjectInput objectInput)\n\t\tthrows ClassNotFoundException, IOException {\n\n\t\t_templateId = objectInput.readUTF();\n\t\t_lastModified = objectInput.readLong();\n\t\t_xsl = objectInput.readUTF();\n\t\t_xml = objectInput.readUTF();\n\n\t\tObject object = objectInput.readObject();\n\n\t\tif (object instanceof XSLURIResolver) {\n\t\t\t_uriResolver = (XSLURIResolver)object;\n\t\t}\n\t}","id":31437,"modified_method":"public void readExternal(ObjectInput objectInput)\n\t\tthrows ClassNotFoundException, IOException {\n\n\t\t_templateId = objectInput.readUTF();\n\t\t_lastModified = objectInput.readLong();\n\t\t_xsl = objectInput.readUTF();\n\t\t_xml = objectInput.readUTF();\n\t\t_uriResolver = (XSLURIResolver)objectInput.readObject();\n\t}","commit_id":"b7570317a1b9f8d17618f4463a06377717176947","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeUTF(_templateId);\n\t\tobjectOutput.writeLong(_lastModified);\n\t\tobjectOutput.writeUTF(_xsl);\n\t\tobjectOutput.writeUTF(_xml);\n\n\t\tif (_uriResolver != null) {\n\t\t\tobjectOutput.writeObject(_uriResolver);\n\t\t}\n\t\telse {\n\t\t\tobjectOutput.writeObject(_DUMMY_OBJECT);\n\t\t}\n\t}","id":31438,"modified_method":"public void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeUTF(_templateId);\n\t\tobjectOutput.writeLong(_lastModified);\n\t\tobjectOutput.writeUTF(_xsl);\n\t\tobjectOutput.writeUTF(_xml);\n\t\tobjectOutput.writeObject(_uriResolver);\n\t}","commit_id":"b7570317a1b9f8d17618f4463a06377717176947","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tSpelNodeImpl leftOp = getLeftOperand();\n\t\tSpelNodeImpl rightOp = getRightOperand();\n\t\tif (rightOp == null) { // If only one operand, then this is unary plus\n\t\t\tObject operandOne = leftOp.getValueInternal(state).getValue();\n\t\t\tif (operandOne instanceof Number) {\n\t\t\t\tif (operandOne instanceof Double) {\n\t\t\t\t\treturn new TypedValue(((Double) operandOne).doubleValue());\n\t\t\t\t} else if (operandOne instanceof Long) {\n\t\t\t\t\treturn new TypedValue(((Long) operandOne).longValue());\n\t\t\t\t} else {\n\t\t\t\t\treturn new TypedValue(((Integer) operandOne).intValue());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn state.operate(Operation.ADD, operandOne, null);\n\t\t}\n\t\telse {\n\t\t\tObject operandOne = leftOp.getValueInternal(state).getValue();\n\t\t\tObject operandTwo = rightOp.getValueInternal(state).getValue();\n\t\t\tif (operandOne instanceof Number && operandTwo instanceof Number) {\n\t\t\t\tNumber op1 = (Number) operandOne;\n\t\t\t\tNumber op2 = (Number) operandTwo;\n\t\t\t\tif (op1 instanceof Double || op2 instanceof Double) {\n\t\t\t\t\treturn new TypedValue(op1.doubleValue() + op2.doubleValue());\n\t\t\t\t} else if (op1 instanceof Long || op2 instanceof Long) {\n\t\t\t\t\treturn new TypedValue(op1.longValue() + op2.longValue());\n\t\t\t\t} else { // TODO what about overflow?\n\t\t\t\t\treturn new TypedValue(op1.intValue() + op2.intValue());\n\t\t\t\t}\n\t\t\t} else if (operandOne instanceof String && operandTwo instanceof String) {\n\t\t\t\treturn new TypedValue(new StringBuilder((String) operandOne).append((String) operandTwo).toString());\n\t\t\t} else if (operandOne instanceof String) {\n\t\t\t\tStringBuilder result = new StringBuilder((String)operandOne);\n\t\t\t\tresult.append((operandTwo==null?\"null\":operandTwo.toString()));\n\t\t\t\treturn new TypedValue(result.toString());\t\t\t\t\n\t\t\t} else if (operandTwo instanceof String) {\n\t\t\t\tStringBuilder result = new StringBuilder((operandOne==null?\"null\":operandOne.toString()));\n\t\t\t\tresult.append((String)operandTwo);\n\t\t\t\treturn new TypedValue(result.toString());\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\treturn state.operate(Operation.ADD, operandOne, operandTwo);\n\t\t}\n\t}","id":31439,"modified_method":"@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tSpelNodeImpl leftOp = getLeftOperand();\n\t\tSpelNodeImpl rightOp = getRightOperand();\n\t\tif (rightOp == null) { // If only one operand, then this is unary plus\n\t\t\tObject operandOne = leftOp.getValueInternal(state).getValue();\n\t\t\tif (operandOne instanceof Number) {\n\t\t\t\tif (operandOne instanceof Double || operandOne instanceof Long) {\n\t\t\t\t\treturn new TypedValue(operandOne);\n\t\t\t\t} else {\n\t\t\t\t\treturn new TypedValue(((Number) operandOne).intValue());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn state.operate(Operation.ADD, operandOne, null);\n\t\t}\n\t\telse {\n\t\t\tfinal TypedValue operandOneValue = leftOp.getValueInternal(state);\n\t\t\tfinal Object operandOne = operandOneValue.getValue();\n\n\t\t\tfinal TypedValue operandTwoValue = rightOp.getValueInternal(state);\n\t\t\tfinal Object operandTwo = operandTwoValue.getValue();\n\n\t\t\tif (operandOne instanceof Number && operandTwo instanceof Number) {\n\t\t\t\tNumber op1 = (Number) operandOne;\n\t\t\t\tNumber op2 = (Number) operandTwo;\n\t\t\t\tif (op1 instanceof Double || op2 instanceof Double) {\n\t\t\t\t\treturn new TypedValue(op1.doubleValue() + op2.doubleValue());\n\t\t\t\t} else if (op1 instanceof Long || op2 instanceof Long) {\n\t\t\t\t\treturn new TypedValue(op1.longValue() + op2.longValue());\n\t\t\t\t} else { // TODO what about overflow?\n\t\t\t\t\treturn new TypedValue(op1.intValue() + op2.intValue());\n\t\t\t\t}\n\t\t\t} else if (operandOne instanceof String && operandTwo instanceof String) {\n\t\t\t\treturn new TypedValue(new StringBuilder((String) operandOne).append((String) operandTwo).toString());\n\t\t\t} else if (operandOne instanceof String) {\n\t\t\t\tStringBuilder result = new StringBuilder((String) operandOne);\n\t\t\t\tresult.append((operandTwo == null ? \"null\" : convertTypedValueToString(operandTwoValue, state)));\n\t\t\t\treturn new TypedValue(result.toString());\n\t\t\t} else if (operandTwo instanceof String) {\n\t\t\t\tStringBuilder result = new StringBuilder((operandOne == null ? \"null\" : convertTypedValueToString(\n\t\t\t\t\t\toperandOneValue, state)));\n\t\t\t\tresult.append((String) operandTwo);\n\t\t\t\treturn new TypedValue(result.toString());\n\t\t\t}\n\t\t\treturn state.operate(Operation.ADD, operandOne, operandTwo);\n\t\t}\n\t}","commit_id":"7cdfaf3e0d9e1add3a326db7527a37905edd5e6e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public OpPlus(int pos, SpelNodeImpl... operands) {\n\t\tsuper(\"+\", pos, operands);\n\t}","id":31440,"modified_method":"public OpPlus(int pos, SpelNodeImpl... operands) {\n\t\tsuper(\"+\", pos, operands);\n\t\tAssert.notEmpty(operands);\n\t}","commit_id":"7cdfaf3e0d9e1add3a326db7527a37905edd5e6e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private Map<String, Integer> countConsensusAlleles(ReferenceContext ref,\n                                                       Map<String, AlignmentContext> contexts,\n                                                       AlignmentContextUtils.ReadOrientation contextType) {\n        final GenomeLoc loc = ref.getLocus();\n        HashMap<String, Integer> consensusIndelStrings = new HashMap<String, Integer>();\n\n        int insCount = 0, delCount = 0;\n        // quick check of total number of indels in pileup\n        for (Map.Entry<String, AlignmentContext> sample : contexts.entrySet()) {\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            if (context.hasExtendedEventPileup()) {\n                final ReadBackedExtendedEventPileup indelPileup = context.getExtendedEventPileup();\n                insCount += indelPileup.getNumberOfInsertions();\n                delCount += indelPileup.getNumberOfDeletions();\n            }\n            else {\n                final ReadBackedPileup indelPileup = context.getBasePileup();\n                insCount += indelPileup.getNumberOfInsertionsAfterThisElement();\n                delCount += indelPileup.getNumberOfDeletionsAfterThisElement();\n             }\n        }\n\n        if (insCount < minIndelCountForGenotyping && delCount < minIndelCountForGenotyping)\n            return Collections.emptyMap();\n\n        for (Map.Entry<String, AlignmentContext> sample : contexts.entrySet()) {\n            // todo -- warning, can be duplicating expensive partition here\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            final ReadBackedPileup indelPileup;\n\n            final int nIndelReads, nReadsOverall;\n\n            if (context.hasExtendedEventPileup()) {\n                indelPileup = context.getExtendedEventPileup();\n                nIndelReads = ((ReadBackedExtendedEventPileup)indelPileup).getNumberOfInsertions() + indelPileup.getNumberOfDeletions();\n                nReadsOverall = indelPileup.getNumberOfElements();\n            }\n            else {\n                indelPileup = context.getBasePileup();\n                nIndelReads = indelPileup.getNumberOfInsertionsAfterThisElement() + indelPileup.getNumberOfDeletionsAfterThisElement();\n                nReadsOverall = indelPileup.getNumberOfElements();\n            }\n            if ( nIndelReads == 0 || (nIndelReads / (1.0 * nReadsOverall)) < minFractionInOneSample) {\n//                if ( nIndelReads > 0 )\n//                    logger.info(\"Skipping sample \" + sample.getKey() + \" with nIndelReads \" + nIndelReads + \" nReads \" + nReadsOverall);\n                continue;\n//            } else {\n//                logger.info(\"### Keeping sample \" + sample.getKey() + \" with nIndelReads \" + nIndelReads + \" nReads \" + nReadsOverall);\n            }\n\n\n            for (PileupElement p : indelPileup) {\n                final GATKSAMRecord read = ReadClipper.hardClipAdaptorSequence(p.getRead());\n                if (read == null)\n                    continue;\n                if (ReadUtils.is454Read(read)) {\n                    continue;\n                }\n\n/*                if (DEBUG && p.isIndel()) {\n                    System.out.format(\"Read: %s, cigar: %s, aln start: %d, aln end: %d, p.len:%d, Type:%s, EventBases:%s\\n\",\n                            read.getReadName(),read.getCigar().toString(),read.getAlignmentStart(),read.getAlignmentEnd(),\n                            p.getEventLength(),p.getType().toString(), p.getEventBases());\n                }\n   */\n                String indelString = p.getEventBases();\n\n                if (isInsertion(p)) {\n                    boolean foundKey = false;\n                    // copy of hashmap into temp arrayList\n                    ArrayList<Pair<String,Integer>> cList = new ArrayList<Pair<String,Integer>>();\n                    for (String s : consensusIndelStrings.keySet()) {\n                        cList.add(new Pair<String, Integer>(s,consensusIndelStrings.get(s)));\n                    }\n\n                    if (read.getAlignmentEnd() == loc.getStart()) {\n                        // first corner condition: a read has an insertion at the end, and we're right at the insertion.\n                        // In this case, the read could have any of the inserted bases and we need to build a consensus\n\n                        for (int k=0; k < cList.size(); k++) {\n                            String s = cList.get(k).getFirst();\n                            int cnt = cList.get(k).getSecond();\n                            // case 1: current insertion is prefix of indel in hash map\n                            if (s.startsWith(indelString)) {\n                                cList.set(k,new Pair<String, Integer>(s,cnt+1));\n                                foundKey = true;\n                            }\n                            else if (indelString.startsWith(s)) {\n                                // case 2: indel stored in hash table is prefix of current insertion\n                                // In this case, new bases are new key.\n                                foundKey = true;\n                                cList.set(k,new Pair<String, Integer>(indelString,cnt+1));\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            cList.add(new Pair<String, Integer>(indelString,1));\n\n                    }\n                    else if (read.getAlignmentStart() == loc.getStart()+1) {\n                        // opposite corner condition: read will start at current locus with an insertion\n                        for (int k=0; k < cList.size(); k++) {\n                            String s = cList.get(k).getFirst();\n                            int cnt = cList.get(k).getSecond();\n                            if (s.endsWith(indelString)) {\n                                // case 1: current insertion (indelString) is suffix of indel in hash map (s)\n                                cList.set(k,new Pair<String, Integer>(s,cnt+1));\n                                foundKey = true;\n                            }\n                            else if (indelString.endsWith(s)) {\n                                // case 2: indel stored in hash table is prefix of current insertion\n                                // In this case, new bases are new key.\n                                foundKey = true;\n                                cList.set(k,new Pair<String, Integer>(indelString,cnt+1));\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            cList.add(new Pair<String, Integer>(indelString,1));\n\n\n                    }\n                    else {\n                        // normal case: insertion somewhere in the middle of a read: add count to arrayList\n                        int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                        cList.add(new Pair<String, Integer>(indelString,cnt+1));\n                    }\n\n                    // copy back arrayList into hashMap\n                    consensusIndelStrings.clear();\n                    for (Pair<String,Integer> pair : cList) {\n                        consensusIndelStrings.put(pair.getFirst(),pair.getSecond());\n                    }\n\n                }\n                else if (isDeletion(p)) {\n                    indelString = String.format(\"D%d\",p.getEventLength());\n                    int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                    consensusIndelStrings.put(indelString,cnt+1);\n\n                }\n            }\n        }\n\n        return consensusIndelStrings;\n    }","id":31441,"modified_method":"private Map<String, Integer> countConsensusAlleles(ReferenceContext ref,\n                                                       Map<String, AlignmentContext> contexts,\n                                                       AlignmentContextUtils.ReadOrientation contextType) {\n        final GenomeLoc loc = ref.getLocus();\n        HashMap<String, Integer> consensusIndelStrings = new HashMap<String, Integer>();\n\n        int insCount = 0, delCount = 0;\n        // quick check of total number of indels in pileup\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            final AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            if ( context.hasBasePileup() ) {\n                final ReadBackedPileup indelPileup = context.getBasePileup();\n                insCount += indelPileup.getNumberOfInsertionsAfterThisElement();\n                delCount += indelPileup.getNumberOfDeletionsAfterThisElement();\n             }\n        }\n\n        if ( insCount < minIndelCountForGenotyping && delCount < minIndelCountForGenotyping )\n            return Collections.emptyMap();\n\n        for (Map.Entry<String, AlignmentContext> sample : contexts.entrySet()) {\n            // todo -- warning, can be duplicating expensive partition here\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            if ( !context.hasBasePileup() )\n                continue;\n\n            final ReadBackedPileup indelPileup = context.getBasePileup();\n\n            final int nIndelReads = indelPileup.getNumberOfInsertionsAfterThisElement() + indelPileup.getNumberOfDeletionsAfterThisElement();\n            final int nReadsOverall = indelPileup.getNumberOfElements();\n\n            if ( nIndelReads == 0 || (nIndelReads / (1.0 * nReadsOverall)) < minFractionInOneSample ) {\n//                if ( nIndelReads > 0 )\n//                    logger.info(\"Skipping sample \" + sample.getKey() + \" with nIndelReads \" + nIndelReads + \" nReads \" + nReadsOverall);\n                continue;\n//            } else {\n//                logger.info(\"### Keeping sample \" + sample.getKey() + \" with nIndelReads \" + nIndelReads + \" nReads \" + nReadsOverall);\n            }\n\n\n            for (PileupElement p : indelPileup) {\n                final GATKSAMRecord read = ReadClipper.hardClipAdaptorSequence(p.getRead());\n                if (read == null)\n                    continue;\n                if (ReadUtils.is454Read(read)) {\n                    continue;\n                }\n\n/*                if (DEBUG && p.isIndel()) {\n                    System.out.format(\"Read: %s, cigar: %s, aln start: %d, aln end: %d, p.len:%d, Type:%s, EventBases:%s\\n\",\n                            read.getReadName(),read.getCigar().toString(),read.getAlignmentStart(),read.getAlignmentEnd(),\n                            p.getEventLength(),p.getType().toString(), p.getEventBases());\n                }\n   */\n                String indelString = p.getEventBases();\n\n                if ( p.isBeforeInsertion() ) {\n                    boolean foundKey = false;\n                    // copy of hashmap into temp arrayList\n                    ArrayList<Pair<String,Integer>> cList = new ArrayList<Pair<String,Integer>>();\n                    for (String s : consensusIndelStrings.keySet()) {\n                        cList.add(new Pair<String, Integer>(s,consensusIndelStrings.get(s)));\n                    }\n\n                    if (read.getAlignmentEnd() == loc.getStart()) {\n                        // first corner condition: a read has an insertion at the end, and we're right at the insertion.\n                        // In this case, the read could have any of the inserted bases and we need to build a consensus\n\n                        for (int k=0; k < cList.size(); k++) {\n                            String s = cList.get(k).getFirst();\n                            int cnt = cList.get(k).getSecond();\n                            // case 1: current insertion is prefix of indel in hash map\n                            if (s.startsWith(indelString)) {\n                                cList.set(k,new Pair<String, Integer>(s,cnt+1));\n                                foundKey = true;\n                            }\n                            else if (indelString.startsWith(s)) {\n                                // case 2: indel stored in hash table is prefix of current insertion\n                                // In this case, new bases are new key.\n                                foundKey = true;\n                                cList.set(k,new Pair<String, Integer>(indelString,cnt+1));\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            cList.add(new Pair<String, Integer>(indelString,1));\n\n                    }\n                    else if (read.getAlignmentStart() == loc.getStart()+1) {\n                        // opposite corner condition: read will start at current locus with an insertion\n                        for (int k=0; k < cList.size(); k++) {\n                            String s = cList.get(k).getFirst();\n                            int cnt = cList.get(k).getSecond();\n                            if (s.endsWith(indelString)) {\n                                // case 1: current insertion (indelString) is suffix of indel in hash map (s)\n                                cList.set(k,new Pair<String, Integer>(s,cnt+1));\n                                foundKey = true;\n                            }\n                            else if (indelString.endsWith(s)) {\n                                // case 2: indel stored in hash table is prefix of current insertion\n                                // In this case, new bases are new key.\n                                foundKey = true;\n                                cList.set(k,new Pair<String, Integer>(indelString,cnt+1));\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            cList.add(new Pair<String, Integer>(indelString,1));\n\n\n                    }\n                    else {\n                        // normal case: insertion somewhere in the middle of a read: add count to arrayList\n                        int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                        cList.add(new Pair<String, Integer>(indelString,cnt+1));\n                    }\n\n                    // copy back arrayList into hashMap\n                    consensusIndelStrings.clear();\n                    for (Pair<String,Integer> pair : cList) {\n                        consensusIndelStrings.put(pair.getFirst(),pair.getSecond());\n                    }\n\n                }\n                else if ( p.isBeforeDeletion() ) {\n                    indelString = String.format(\"D%d\",p.getEventLength());\n                    int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                    consensusIndelStrings.put(indelString,cnt+1);\n\n                }\n            }\n        }\n\n        return consensusIndelStrings;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static final ArrayList<double[]> getGLs(GenotypesContext GLs) {\n        ArrayList<double[]> genotypeLikelihoods = new ArrayList<double[]>(GLs.size());\n\n        genotypeLikelihoods.add(new double[]{0.0,0.0,0.0}); // dummy\n        for ( Genotype sample : GLs.iterateInSampleNameOrder() ) {\n            if ( sample.hasLikelihoods() ) {\n                double[] gls = sample.getLikelihoods().getAsVector();\n\n                if ( MathUtils.sum(gls) < VariantContextUtils.SUM_GL_THRESH_NOCALL )\n                    genotypeLikelihoods.add(gls);\n            }\n        }\n\n        return genotypeLikelihoods;\n    }","id":31442,"modified_method":"private static final ArrayList<double[]> getGLs(GenotypesContext GLs) {\n        ArrayList<double[]> genotypeLikelihoods = new ArrayList<double[]>(GLs.size());\n\n        genotypeLikelihoods.add(new double[]{0.0,0.0,0.0}); // dummy\n        for ( Genotype sample : GLs.iterateInSampleNameOrder() ) {\n            if ( sample.hasLikelihoods() ) {\n                double[] gls = sample.getLikelihoods().getAsVector();\n\n                if ( MathUtils.sum(gls) < UnifiedGenotyperEngine.SUM_GL_THRESH_NOCALL )\n                    genotypeLikelihoods.add(gls);\n            }\n        }\n\n        return genotypeLikelihoods;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"public CountedData map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        final CountedData counter = new CountedData();\n\n        // For some reason RodWalkers get map calls with null trackers\n        if( tracker == null )\n            return counter;\n\n        VariantContext vcComp = tracker.getFirstValue(alleles);\n        if( vcComp == null )\n            return counter;\n\n        //todo - not sure I want this, may be misleading to filter extended indel events.\n        if (isInsideExtendedIndel(vcComp,  ref))\n            return counter;\n\n        // Do not operate on variants that are not covered to the optional minimum depth\n        if (!context.hasReads() || !context.hasBasePileup() || (minDepth > 0 && context.getBasePileup().getBases().length < minDepth)) {\n            counter.nUncovered = 1L;\n            if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                counter.nAltNotCalled = 1L;\n            else if (vcComp.getAttribute(\"GV\").equals(\"F\"))\n                counter.nRefNotCalled = 1L;\n            else\n                counter.nNoStatusNotCalled = 1L;\n\n            return counter;\n        }\n\n        VariantCallContext call;\n        if ( vcComp.isSNP() ) {\n            call = snpEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context);\n        } else if ( vcComp.isIndel() ) {\n            call = indelEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context);\n        } else if ( bamIsTruth ) {\n            // assume it's a SNP if no variation is present; this is necessary so that we can test supposed monomorphic sites against the truth bam\n            call = snpEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context);\n        } else {\n            logger.info(\"Not SNP or INDEL \" + vcComp.getChr() + \":\" + vcComp.getStart() + \" \" + vcComp.getAlleles());\n            return counter;\n        }\n\n\n        boolean writeVariant = true;\n\n        if (bamIsTruth) {\n            if (call.confidentlyCalled) {\n                // If truth is a confident REF call\n                if (call.isVariant()) {\n                    if (vcComp.isVariant())\n                        counter.nAltCalledAlt = 1L;\n                    else {\n                        counter.nAltCalledRef = 1L;\n                        if ( printInterestingSites )\n                            System.out.println(\"Truth=ALT Call=REF at \" + call.getChr() + \":\" + call.getStart());\n                    }\n                }\n                // If truth is a confident ALT call\n                else {\n                    if (vcComp.isVariant()) {\n                        counter.nRefCalledAlt = 1L;\n                        if ( printInterestingSites )\n                            System.out.println(\"Truth=REF Call=ALT at \" + call.getChr() + \":\" + call.getStart());\n                    } else\n                        counter.nRefCalledRef = 1L;\n                }\n            }\n            else {\n                counter.nNotConfidentCalls = 1L;\n                if ( printInterestingSites )\n                    System.out.println(\"Truth is not confident at \" + call.getChr() + \":\" + call.getStart());\n                writeVariant = false;\n            }\n        }\n        else {\n//            if (!vcComp.hasAttribute(\"GV\"))\n//                throw new UserException.BadInput(\"Variant has no GV annotation in the INFO field. \" + vcComp.getChr() + \":\" + vcComp.getStart());\n\n            if (call.isCalledAlt(callConf)) {\n                if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                    counter.nAltCalledAlt = 1L;\n                else if (vcComp.getAttribute(\"GV\").equals(\"F\")) {\n                    counter.nRefCalledAlt = 1L;\n                    if ( printInterestingSites )\n                        System.out.println(\"Truth=REF Call=ALT at \" + call.getChr() + \":\" + call.getStart());\n                }\n                else\n                    counter.nNoStatusCalledAlt = 1L;\n            }\n            else if (call.isCalledRef(callConf)) {\n                if (vcComp.getAttribute(\"GV\").equals(\"T\")) {\n                    counter.nAltCalledRef = 1L;\n                    if ( printInterestingSites )\n                        System.out.println(\"Truth=ALT Call=REF at \" + call.getChr() + \":\" + call.getStart());\n                }\n                else if (vcComp.getAttribute(\"GV\").equals(\"F\"))\n                    counter.nRefCalledRef = 1L;\n\n                else\n                    counter.nNoStatusCalledRef = 1L;\n            }\n            else {\n                counter.nNotConfidentCalls = 1L;\n                if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                    counter.nAltNotCalled = 1L;\n                else if (vcComp.getAttribute(\"GV\").equals(\"F\"))\n                    counter.nRefNotCalled = 1L;\n                else\n                    counter.nNoStatusNotCalled = 1L;\n\n                if ( printInterestingSites )\n                    System.out.println(\"Truth is not confident at \" + call.getChr() + \":\" + call.getStart());\n                writeVariant = false;\n            }\n        }\n\n        if (vcfWriter != null && writeVariant) {\n            if (!vcComp.hasAttribute(\"callStatus\")) {\n                vcfWriter.add(new VariantContextBuilder(vcComp).attribute(\"callStatus\", call.isCalledAlt(callConf) ? \"ALT\" : \"REF\").make());\n            }\n            else\n                vcfWriter.add(vcComp);\n        }\n        return counter;\n    }","id":31443,"modified_method":"public CountedData map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        final CountedData counter = new CountedData();\n\n        // For some reason RodWalkers get map calls with null trackers\n        if( tracker == null )\n            return counter;\n\n        VariantContext vcComp = tracker.getFirstValue(alleles);\n        if( vcComp == null )\n            return counter;\n\n        //todo - not sure I want this, may be misleading to filter extended indel events.\n        if (isInsideExtendedIndel(vcComp,  ref))\n            return counter;\n\n        // Do not operate on variants that are not covered to the optional minimum depth\n        if (!context.hasReads() || !context.hasBasePileup() || (minDepth > 0 && context.getBasePileup().getBases().length < minDepth)) {\n            counter.nUncovered = 1L;\n            if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                counter.nAltNotCalled = 1L;\n            else if (vcComp.getAttribute(\"GV\").equals(\"F\"))\n                counter.nRefNotCalled = 1L;\n            else\n                counter.nNoStatusNotCalled = 1L;\n\n            return counter;\n        }\n\n        VariantCallContext call;\n        if ( vcComp.isSNP() ) {\n            call = snpEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context).get(0);\n        } else if ( vcComp.isIndel() ) {\n            call = indelEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context).get(0);\n        } else if ( bamIsTruth ) {\n            // assume it's a SNP if no variation is present; this is necessary so that we can test supposed monomorphic sites against the truth bam\n            call = snpEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context).get(0);\n        } else {\n            logger.info(\"Not SNP or INDEL \" + vcComp.getChr() + \":\" + vcComp.getStart() + \" \" + vcComp.getAlleles());\n            return counter;\n        }\n\n\n        boolean writeVariant = true;\n\n        if (bamIsTruth) {\n            if (call.confidentlyCalled) {\n                // If truth is a confident REF call\n                if (call.isVariant()) {\n                    if (vcComp.isVariant())\n                        counter.nAltCalledAlt = 1L;\n                    else {\n                        counter.nAltCalledRef = 1L;\n                        if ( printInterestingSites )\n                            System.out.println(\"Truth=ALT Call=REF at \" + call.getChr() + \":\" + call.getStart());\n                    }\n                }\n                // If truth is a confident ALT call\n                else {\n                    if (vcComp.isVariant()) {\n                        counter.nRefCalledAlt = 1L;\n                        if ( printInterestingSites )\n                            System.out.println(\"Truth=REF Call=ALT at \" + call.getChr() + \":\" + call.getStart());\n                    } else\n                        counter.nRefCalledRef = 1L;\n                }\n            }\n            else {\n                counter.nNotConfidentCalls = 1L;\n                if ( printInterestingSites )\n                    System.out.println(\"Truth is not confident at \" + call.getChr() + \":\" + call.getStart());\n                writeVariant = false;\n            }\n        }\n        else {\n//            if (!vcComp.hasAttribute(\"GV\"))\n//                throw new UserException.BadInput(\"Variant has no GV annotation in the INFO field. \" + vcComp.getChr() + \":\" + vcComp.getStart());\n\n            if (call.isCalledAlt(callConf)) {\n                if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                    counter.nAltCalledAlt = 1L;\n                else if (vcComp.getAttribute(\"GV\").equals(\"F\")) {\n                    counter.nRefCalledAlt = 1L;\n                    if ( printInterestingSites )\n                        System.out.println(\"Truth=REF Call=ALT at \" + call.getChr() + \":\" + call.getStart());\n                }\n                else\n                    counter.nNoStatusCalledAlt = 1L;\n            }\n            else if (call.isCalledRef(callConf)) {\n                if (vcComp.getAttribute(\"GV\").equals(\"T\")) {\n                    counter.nAltCalledRef = 1L;\n                    if ( printInterestingSites )\n                        System.out.println(\"Truth=ALT Call=REF at \" + call.getChr() + \":\" + call.getStart());\n                }\n                else if (vcComp.getAttribute(\"GV\").equals(\"F\"))\n                    counter.nRefCalledRef = 1L;\n\n                else\n                    counter.nNoStatusCalledRef = 1L;\n            }\n            else {\n                counter.nNotConfidentCalls = 1L;\n                if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                    counter.nAltNotCalled = 1L;\n                else if (vcComp.getAttribute(\"GV\").equals(\"F\"))\n                    counter.nRefNotCalled = 1L;\n                else\n                    counter.nNoStatusNotCalled = 1L;\n\n                if ( printInterestingSites )\n                    System.out.println(\"Truth is not confident at \" + call.getChr() + \":\" + call.getStart());\n                writeVariant = false;\n            }\n        }\n\n        if (vcfWriter != null && writeVariant) {\n            if (!vcComp.hasAttribute(\"callStatus\")) {\n                vcfWriter.add(new VariantContextBuilder(vcComp).attribute(\"callStatus\", call.isCalledAlt(callConf) ? \"ALT\" : \"REF\").make());\n            }\n            else\n                vcfWriter.add(vcComp);\n        }\n        return counter;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"public UGStatistics reduce(VariantCallContext value, UGStatistics sum) {\n        // we get a point for reaching reduce\n        sum.nBasesVisited++;\n\n        // can't call the locus because of no coverage\n        if ( value == null )\n            return sum;\n\n        // A call was attempted -- the base was potentially callable\n        sum.nBasesCallable++;\n\n        // the base was confidently callable\n        sum.nBasesCalledConfidently += value.confidentlyCalled ? 1 : 0;\n\n        // can't make a call here\n        if ( !value.shouldEmit )\n            return sum;\n\n        try {\n            // we are actually making a call\n            sum.nCallsMade++;\n            writer.add(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(e.getMessage());\n        }\n\n        return sum;\n    }","id":31444,"modified_method":"public UGStatistics reduce(List<VariantCallContext> calls, UGStatistics sum) {\n        // we get a point for reaching reduce\n        sum.nBasesVisited++;\n\n        boolean wasCallable = false;\n        boolean wasConfidentlyCalled = false;\n\n        for ( VariantCallContext call : calls ) {\n            if ( call == null )\n                continue;\n\n            // A call was attempted -- the base was callable\n            wasCallable = true;\n\n            // was the base confidently callable?\n            wasConfidentlyCalled = call.confidentlyCalled;\n\n            if ( call.shouldEmit ) {\n                try {\n                    // we are actually making a call\n                    sum.nCallsMade++;\n                    writer.add(call);\n                } catch (IllegalArgumentException e) {\n                    throw new IllegalArgumentException(e.getMessage());\n                }\n            }\n        }\n\n        if ( wasCallable )\n            sum.nBasesCallable++;\n\n        if ( wasConfidentlyCalled )\n            sum.nBasesCalledConfidently++;\n\n        return sum;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<String, AlignmentContext> getFilteredAndStratifiedContexts(UnifiedArgumentCollection UAC, ReferenceContext refContext, AlignmentContext rawContext, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        Map<String, AlignmentContext> stratifiedContexts = null;\n\n        if ( !BaseUtils.isRegularBase( refContext.getBase() ) )\n            return null;\n\n        if ( model.name().toUpperCase().contains(\"INDEL\")) {\n\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                // regular pileup in this case\n                ReadBackedPileup pileup = rawContext.getBasePileup() .getMappingFilteredPileup(UAC.MIN_BASE_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.getNumberOfElements() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            } else {\n\n                // todo - tmp will get rid of extended events so this wont be needed\n                if (!rawContext.hasExtendedEventPileup())\n                    return null;\n                ReadBackedExtendedEventPileup rawPileup = rawContext.getExtendedEventPileup();\n\n                // filter the context based on min mapping quality\n                ReadBackedExtendedEventPileup pileup = rawPileup.getMappingFilteredPileup(UAC.MIN_BASE_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.getNumberOfElements() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n            }\n        } else if ( model.name().toUpperCase().contains(\"SNP\") ) {\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(rawContext.getBasePileup());\n\n            if( !(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) ) {\n                int numDeletions = 0;\n                for( final PileupElement p : rawContext.getBasePileup() ) {\n                    if( p.isDeletion() ) { numDeletions++; }\n                }\n                if( ((double) numDeletions) / ((double) rawContext.getBasePileup().getNumberOfElements()) > UAC.MAX_DELETION_FRACTION ) {\n                    return null;\n                }\n            }\n        }\n\n        return stratifiedContexts;\n    }","id":31445,"modified_method":"private Map<String, AlignmentContext> getFilteredAndStratifiedContexts(UnifiedArgumentCollection UAC, ReferenceContext refContext, AlignmentContext rawContext, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        if ( !BaseUtils.isRegularBase(refContext.getBase()) || !rawContext.hasBasePileup() )\n            return null;\n\n        Map<String, AlignmentContext> stratifiedContexts = null;\n\n        if ( model.name().contains(\"INDEL\") ) {\n\n            final ReadBackedPileup pileup = rawContext.getBasePileup().getMappingFilteredPileup(UAC.MIN_BASE_QUALTY_SCORE);\n            // don't call when there is no coverage\n            if ( pileup.getNumberOfElements() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                return null;\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n        } else if ( model.name().contains(\"SNP\") ) {\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(rawContext.getBasePileup());\n\n            if ( !(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) ) {\n                int numDeletions = 0;\n                for ( final PileupElement p : rawContext.getBasePileup() ) {\n                    if ( p.isDeletion() )\n                        numDeletions++;\n                }\n                if ( ((double) numDeletions) / ((double) rawContext.getBasePileup().getNumberOfElements()) > UAC.MAX_DELETION_FRACTION ) {\n                    return null;\n                }\n            }\n        }\n\n        return stratifiedContexts;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static Map<String,GenotypeLikelihoodsCalculationModel> getGenotypeLikelihoodsCalculationObject(Logger logger, UnifiedArgumentCollection UAC) {\n\n\n        Map<String, GenotypeLikelihoodsCalculationModel> glcm = new HashMap<String, GenotypeLikelihoodsCalculationModel>();\n       // GenotypeLikelihoodsCalculationModel.Model.\n        List<Class<? extends GenotypeLikelihoodsCalculationModel>> glmClasses = new PluginManager<GenotypeLikelihoodsCalculationModel>(GenotypeLikelihoodsCalculationModel.class).getPlugins();\n\n        for (int i = 0; i < glmClasses.size(); i++) {\n            Class<? extends GenotypeLikelihoodsCalculationModel> glmClass = glmClasses.get(i);\n            String key = glmClass.getSimpleName().replaceAll(\"GenotypeLikelihoodsCalculationModel\",\"\").toUpperCase();\n            //System.out.println(\"KEY:\"+key+\"\\t\" + glmClass.getSimpleName());\n            try {\n                Object args[] = new Object[]{UAC,logger};\n                Constructor c = glmClass.getDeclaredConstructor(UnifiedArgumentCollection.class, Logger.class);\n                glcm.put(key, (GenotypeLikelihoodsCalculationModel)c.newInstance(args));\n            }\n            catch (Exception e) {\n                throw new UserException(\"Incorrect specification for argument glm:\"+UAC.GLmodel+e.getMessage());\n            }\n         }\n\n        return glcm;\n    }","id":31446,"modified_method":"private static Map<String, GenotypeLikelihoodsCalculationModel> getGenotypeLikelihoodsCalculationObject(Logger logger, UnifiedArgumentCollection UAC) {\n\n        final Map<String, GenotypeLikelihoodsCalculationModel> glcm = new HashMap<String, GenotypeLikelihoodsCalculationModel>();\n        final List<Class<? extends GenotypeLikelihoodsCalculationModel>> glmClasses = new PluginManager<GenotypeLikelihoodsCalculationModel>(GenotypeLikelihoodsCalculationModel.class).getPlugins();\n\n        for (int i = 0; i < glmClasses.size(); i++) {\n            final Class<? extends GenotypeLikelihoodsCalculationModel> glmClass = glmClasses.get(i);\n            final String key = glmClass.getSimpleName().replaceAll(\"GenotypeLikelihoodsCalculationModel\",\"\").toUpperCase();\n            try {\n                final Object args[] = new Object[]{UAC,logger};\n                final Constructor c = glmClass.getDeclaredConstructor(UnifiedArgumentCollection.class, Logger.class);\n                glcm.put(key, (GenotypeLikelihoodsCalculationModel)c.newInstance(args));\n            }\n            catch (Exception e) {\n                throw new UserException(\"The likelihoods model provided for the -glm argument (\" + UAC.GLmodel + \") is not a valid option: \" + e.getMessage());\n            }\n         }\n\n        return glcm;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"public VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        boolean limitedContext = tracker == null || refContext == null || rawContext == null || stratifiedContexts == null;\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n            alleleFrequencyCalculationResult.set(new AlleleFrequencyCalculationResult(UAC.MAX_ALTERNATE_ALLELES));\n            posteriorsArray.set(new double[2]);\n        }\n        AlleleFrequencyCalculationResult AFresult = alleleFrequencyCalculationResult.get();\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 ) {\n            if ( limitedContext )\n                return null;\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n        }\n\n        AFresult.reset();\n        List<Allele> allelesUsedInGenotyping = afcm.get().getLog10PNonRef(vc, getAlleleFrequencyPriors(model), AFresult);\n\n        // is the most likely frequency conformation AC=0 for all alternate alleles?\n        boolean bestGuessIsRef = true;\n\n        // determine which alternate alleles have AF>0\n        final List<Allele> myAlleles = new ArrayList<Allele>(vc.getAlleles().size());\n        myAlleles.add(vc.getReference());\n        for ( int i = 0; i < vc.getAlternateAlleles().size(); i++ ) {\n            final Allele alternateAllele = vc.getAlternateAllele(i);\n            final int indexOfAllele = allelesUsedInGenotyping.indexOf(alternateAllele);\n            // the genotyping model may have stripped it out\n            if ( indexOfAllele == -1 )\n                continue;\n\n            int indexOfBestAC = AFresult.getAlleleCountsOfMAP()[indexOfAllele-1];\n\n            // if the most likely AC is not 0, then this is a good alternate allele to use\n            if ( indexOfBestAC != 0 ) {\n                myAlleles.add(alternateAllele);\n                bestGuessIsRef = false;\n            }\n            // if in GENOTYPE_GIVEN_ALLELES mode, we still want to allow the use of a poor allele\n            else if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n                myAlleles.add(alternateAllele);\n            }\n        }\n\n        // calculate p(f>0):\n        final double[] normalizedPosteriors = generateNormalizedPosteriors(AFresult, posteriorsArray.get());\n        final double PofF = 1.0 - normalizedPosteriors[0];\n\n        double phredScaledConfidence;\n        if ( !bestGuessIsRef || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(normalizedPosteriors[0]);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * AFresult.getLog10PosteriorOfAFzero();\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PofF);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                final double sum = AFresult.getLog10PosteriorMatrixSum();\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestGuessIsRef) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return limitedContext ? null : estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), true, 1.0 - PofF);\n        }\n\n        // start constructing the resulting VC\n        final GenomeLoc loc = genomeLocParser.createGenomeLoc(vc);\n        final VariantContextBuilder builder = new VariantContextBuilder(\"UG_call\", loc.getContig(), loc.getStart(), loc.getStop(), myAlleles);\n        builder.log10PError(phredScaledConfidence/-10.0);\n        if ( ! passesCallThreshold(phredScaledConfidence) )\n            builder.filters(filter);\n        if ( limitedContext ) {\n            builder.referenceBaseForIndel(vc.getReferenceBaseForIndel());\n        } else {\n            builder.referenceBaseForIndel(refContext.getBase());\n        }\n\n        // create the genotypes\n        final GenotypesContext genotypes = VariantContextUtils.subsetAlleles(vc, myAlleles, true);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null && !limitedContext )\n            printVerboseData(refContext.getLocus().toString(), vc, PofF, phredScaledConfidence, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        final HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // if the site was downsampled, record that fact\n        if ( !limitedContext && rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n        if ( !UAC.NO_SLOD && !limitedContext && !bestGuessIsRef ) {\n            //final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            //double overallLog10PofNull = AFresult.log10AlleleFrequencyPosteriors[0];\n            double overallLog10PofF = AFresult.getLog10PosteriorMatrixSum();\n            //if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            List<Allele> alternateAllelesToUse = builder.make().getAlternateAlleles();\n            \n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, alternateAllelesToUse, false, model);\n            AFresult.reset();\n            afcm.get().getLog10PNonRef(vcForward, getAlleleFrequencyPriors(model), AFresult);\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double forwardLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double forwardLog10PofF = AFresult.getLog10PosteriorMatrixSum();\n            //if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, alternateAllelesToUse, false, model);\n            AFresult.reset();\n            afcm.get().getLog10PNonRef(vcReverse, getAlleleFrequencyPriors(model), AFresult);\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double reverseLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double reverseLog10PofF = AFresult.getLog10PosteriorMatrixSum();\n            //if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            //if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            if ( !Double.isNaN(strandScore) )\n                attributes.put(\"SB\", strandScore);\n        }\n\n        // finish constructing the resulting VC\n        builder.genotypes(genotypes);\n        builder.attributes(attributes);\n        VariantContext vcCall = builder.make();\n\n        if ( annotationEngine != null && !limitedContext ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vcCall = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall);\n        }\n\n        return new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PofF));\n    }","id":31447,"modified_method":"public VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        boolean limitedContext = tracker == null || refContext == null || rawContext == null || stratifiedContexts == null;\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n            alleleFrequencyCalculationResult.set(new AlleleFrequencyCalculationResult(UAC.MAX_ALTERNATE_ALLELES));\n            posteriorsArray.set(new double[2]);\n        }\n        AlleleFrequencyCalculationResult AFresult = alleleFrequencyCalculationResult.get();\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 ) {\n            if ( limitedContext )\n                return null;\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n        }\n\n        AFresult.reset();\n        List<Allele> allelesUsedInGenotyping = afcm.get().getLog10PNonRef(vc, getAlleleFrequencyPriors(model), AFresult);\n\n        // is the most likely frequency conformation AC=0 for all alternate alleles?\n        boolean bestGuessIsRef = true;\n\n        // determine which alternate alleles have AF>0\n        final List<Allele> myAlleles = new ArrayList<Allele>(vc.getAlleles().size());\n        myAlleles.add(vc.getReference());\n        for ( int i = 0; i < vc.getAlternateAlleles().size(); i++ ) {\n            final Allele alternateAllele = vc.getAlternateAllele(i);\n            final int indexOfAllele = allelesUsedInGenotyping.indexOf(alternateAllele);\n            // the genotyping model may have stripped it out\n            if ( indexOfAllele == -1 )\n                continue;\n\n            int indexOfBestAC = AFresult.getAlleleCountsOfMAP()[indexOfAllele-1];\n\n            // if the most likely AC is not 0, then this is a good alternate allele to use\n            if ( indexOfBestAC != 0 ) {\n                myAlleles.add(alternateAllele);\n                bestGuessIsRef = false;\n            }\n            // if in GENOTYPE_GIVEN_ALLELES mode, we still want to allow the use of a poor allele\n            else if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n                myAlleles.add(alternateAllele);\n            }\n        }\n\n        // calculate p(f>0):\n        final double[] normalizedPosteriors = generateNormalizedPosteriors(AFresult, posteriorsArray.get());\n        final double PofF = 1.0 - normalizedPosteriors[0];\n\n        double phredScaledConfidence;\n        if ( !bestGuessIsRef || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(normalizedPosteriors[0]);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * AFresult.getLog10PosteriorOfAFzero();\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PofF);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                final double sum = AFresult.getLog10PosteriorMatrixSum();\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestGuessIsRef) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return limitedContext ? null : estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), true, 1.0 - PofF);\n        }\n\n        // start constructing the resulting VC\n        final GenomeLoc loc = genomeLocParser.createGenomeLoc(vc);\n        final VariantContextBuilder builder = new VariantContextBuilder(\"UG_call\", loc.getContig(), loc.getStart(), loc.getStop(), myAlleles);\n        builder.log10PError(phredScaledConfidence/-10.0);\n        if ( ! passesCallThreshold(phredScaledConfidence) )\n            builder.filters(filter);\n        if ( limitedContext ) {\n            builder.referenceBaseForIndel(vc.getReferenceBaseForIndel());\n        } else {\n            builder.referenceBaseForIndel(refContext.getBase());\n        }\n\n        // create the genotypes\n        final GenotypesContext genotypes = VariantContextUtils.subsetAlleles(vc, myAlleles, true);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null && !limitedContext )\n            printVerboseData(refContext.getLocus().toString(), vc, PofF, phredScaledConfidence, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        final HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // if the site was downsampled, record that fact\n        if ( !limitedContext && rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n        if ( !UAC.NO_SLOD && !limitedContext && !bestGuessIsRef ) {\n            //final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            //double overallLog10PofNull = AFresult.log10AlleleFrequencyPosteriors[0];\n            double overallLog10PofF = AFresult.getLog10PosteriorMatrixSum();\n            //if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            List<Allele> alternateAllelesToUse = builder.make().getAlternateAlleles();\n            \n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, alternateAllelesToUse, false, model);\n            AFresult.reset();\n            afcm.get().getLog10PNonRef(vcForward, getAlleleFrequencyPriors(model), AFresult);\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double forwardLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double forwardLog10PofF = AFresult.getLog10PosteriorMatrixSum();\n            //if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, alternateAllelesToUse, false, model);\n            AFresult.reset();\n            afcm.get().getLog10PNonRef(vcReverse, getAlleleFrequencyPriors(model), AFresult);\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double reverseLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double reverseLog10PofF = AFresult.getLog10PosteriorMatrixSum();\n            //if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            //if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            if ( !Double.isNaN(strandScore) )\n                attributes.put(\"SB\", strandScore);\n        }\n\n        // finish constructing the resulting VC\n        builder.genotypes(genotypes);\n        builder.attributes(attributes);\n        VariantContext vcCall = builder.make();\n\n        if ( annotationEngine != null && !limitedContext && rawContext.hasBasePileup() ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            final ReadBackedPileup pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vcCall = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall);\n        }\n\n        return new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PofF));\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute genotypes at a given locus. Entry point for engine calls from UGCallVariants.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @param vc         the GL-annotated variant context\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, VariantContext vc) {\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel(tracker, refContext, rawContext );\n        if( model == null ) {\n            return null;\n        }\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model);\n    }","id":31448,"modified_method":"/**\n     * Compute genotypes at a given locus. Entry point for engine calls from UGCallVariants.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @param vc         the GL-annotated variant context\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, VariantContext vc) {\n        final List<GenotypeLikelihoodsCalculationModel.Model> models = getGLModelsToUse(tracker, refContext, rawContext);\n        if ( models.isEmpty() ) {\n            return null;\n        }\n\n        // return the first one\n        final GenotypeLikelihoodsCalculationModel.Model model = models.get(0);\n        final Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model);\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantCallContext estimateReferenceConfidence(VariantContext vc, Map<String, AlignmentContext> contexts, double theta, boolean ignoreCoveredSamples, double initialPofRef) {\n        if ( contexts == null )\n            return null;\n\n        double P_of_ref = initialPofRef;\n\n        // for each sample that we haven't examined yet\n        for ( String sample : samples ) {\n            boolean isCovered = contexts.containsKey(sample);\n            if ( ignoreCoveredSamples && isCovered )\n                continue;\n\n\n            int depth = 0;\n\n            if (isCovered) {\n                AlignmentContext context =  contexts.get(sample);\n                if (context.hasBasePileup())\n                    depth = context.getBasePileup().depthOfCoverage();\n                else if (context.hasExtendedEventPileup())\n                    depth = context.getExtendedEventPileup().depthOfCoverage();\n            }\n\n            P_of_ref *= 1.0 - (theta / 2.0) * getRefBinomialProb(depth);\n        }\n\n        return new VariantCallContext(vc, QualityUtils.phredScaleErrorRate(1.0 - P_of_ref) >= UAC.STANDARD_CONFIDENCE_FOR_CALLING, false);\n    }","id":31449,"modified_method":"private VariantCallContext estimateReferenceConfidence(VariantContext vc, Map<String, AlignmentContext> contexts, double theta, boolean ignoreCoveredSamples, double initialPofRef) {\n        if ( contexts == null )\n            return null;\n\n        double P_of_ref = initialPofRef;\n\n        // for each sample that we haven't examined yet\n        for ( String sample : samples ) {\n            boolean isCovered = contexts.containsKey(sample);\n            if ( ignoreCoveredSamples && isCovered )\n                continue;\n\n\n            int depth = 0;\n\n            if ( isCovered ) {\n                AlignmentContext context =  contexts.get(sample);\n                if ( context.hasBasePileup() )\n                    depth = context.getBasePileup().depthOfCoverage();\n            }\n\n            P_of_ref *= 1.0 - (theta / 2.0) * getRefBinomialProb(depth);\n        }\n\n        return new VariantCallContext(vc, QualityUtils.phredScaleErrorRate(1.0 - P_of_ref) >= UAC.STANDARD_CONFIDENCE_FOR_CALLING, false);\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"private GenotypeLikelihoodsCalculationModel.Model getCurrentGLModel(final RefMetaDataTracker tracker, final ReferenceContext refContext,\n                                                                        final AlignmentContext rawContext ) {\n        if (rawContext.hasExtendedEventPileup() ) {\n            // todo - remove this code\n            if ((UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL) &&\n                   (UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) )\n                return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n        }\n        else {\n            // no extended event pileup\n            // if we're genotyping given alleles and we have a requested SNP at this position, do SNP\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                VariantContext vcInput = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, refContext, rawContext.getLocation(), false, logger, UAC.alleles);\n                if (vcInput == null)\n                    return null;\n\n                // todo - no support to genotype MNP's yet\n                if  (vcInput.isMNP())\n                    return null;\n\n                if (vcInput.isSNP())  {\n                    if ( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH )\n                        return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                    else if ( UAC.GLmodel.name().toUpperCase().contains(\"SNP\"))\n                        return UAC.GLmodel;\n                    else\n                        // ignore SNP's if user chose INDEL mode\n                        return null;\n                }\n                else if ((vcInput.isIndel() || vcInput.isMixed())) {\n                    if ( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH )\n                        return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n                    else if (UAC.GLmodel.name().toUpperCase().contains(\"INDEL\"))\n                        return UAC.GLmodel;\n                }\n            }\n            else {\n                // todo - this assumes SNP's take priority when BOTH is selected, should do a smarter way once extended events are removed\n                if( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH )\n                    return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                else if (UAC.GLmodel.name().toUpperCase().contains(\"SNP\") || UAC.GLmodel.name().toUpperCase().contains(\"INDEL\"))\n                    return UAC.GLmodel;\n            }\n        }\n        return null;\n    }","id":31450,"modified_method":"private List<GenotypeLikelihoodsCalculationModel.Model> getGLModelsToUse(final RefMetaDataTracker tracker,\n                                                                             final ReferenceContext refContext,\n                                                                             final AlignmentContext rawContext) {\n\n        final List<GenotypeLikelihoodsCalculationModel.Model> models = new ArrayList<GenotypeLikelihoodsCalculationModel.Model>(2);\n\n        if ( rawContext.hasBasePileup() ) {\n            // if we're genotyping given alleles and we have a requested SNP at this position, do SNP\n            if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n                final VariantContext vcInput = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, refContext, rawContext.getLocation(), false, logger, UAC.alleles);\n                if ( vcInput == null )\n                    return null;\n\n                if ( vcInput.isSNP() )  {\n                    // ignore SNPs if the user chose INDEL mode only\n                    if ( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH )\n                        models.add(GenotypeLikelihoodsCalculationModel.Model.SNP);\n                    else if ( UAC.GLmodel.name().toUpperCase().contains(\"SNP\") )\n                        models.add(UAC.GLmodel);\n                }\n                else if ( vcInput.isIndel() || vcInput.isMixed() ) {\n                    // ignore INDELs if the user chose SNP mode only\n                    if ( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH )\n                        models.add(GenotypeLikelihoodsCalculationModel.Model.INDEL);\n                    else if (UAC.GLmodel.name().toUpperCase().contains(\"INDEL\"))\n                        models.add(UAC.GLmodel);\n                }\n                // No support for other types yet\n            }\n            else {\n                if ( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH ) {\n                    models.add(GenotypeLikelihoodsCalculationModel.Model.SNP);\n                    models.add(GenotypeLikelihoodsCalculationModel.Model.INDEL);\n                }\n                else {\n                    models.add(UAC.GLmodel);\n                }\n            }\n        }\n\n        return models;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute full calls at a given locus. Entry point for engine calls from the UnifiedGenotyper.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel(tracker, refContext, rawContext );\n        if( model == null ) {\n            return (UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, null, rawContext) : null);\n        }\n\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        if ( stratifiedContexts == null ) {\n            return (UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext) : null);\n        }\n        \n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n        if ( vc == null )\n            return null;\n\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model);\n    }","id":31451,"modified_method":"/**\n     * Compute full calls at a given locus. Entry point for engine calls from the UnifiedGenotyper.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public List<VariantCallContext> calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        final List<VariantCallContext> results = new ArrayList<VariantCallContext>(2);\n\n        final List<GenotypeLikelihoodsCalculationModel.Model> models = getGLModelsToUse(tracker, refContext, rawContext);\n        if ( models.isEmpty() ) {\n            results.add(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, null, rawContext) : null);\n        }\n        else {\n            for ( final GenotypeLikelihoodsCalculationModel.Model model : models ) {\n                final Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n                if ( stratifiedContexts == null ) {\n                    results.add(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext) : null);\n                }\n                else {\n                    final VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n                    if ( vc != null )\n                        results.add(calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model));\n                }\n            }        \n        }\n\n        return results;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantCallContext generateEmptyContext(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, AlignmentContext rawContext) {\n        VariantContext vc;\n        if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            VariantContext vcInput = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, ref, rawContext.getLocation(), false, logger, UAC.alleles);\n            if ( vcInput == null )\n                return null;\n            vc = new VariantContextBuilder(\"UG_call\", ref.getLocus().getContig(), vcInput.getStart(), vcInput.getEnd(), vcInput.getAlleles()).referenceBaseForIndel(vcInput.getReferenceBaseForIndel()).make();\n        } else {\n            // deal with bad/non-standard reference bases\n            if ( !Allele.acceptableAlleleBases(new byte[]{ref.getBase()}) )\n                return null;\n\n            Set<Allele> alleles = new HashSet<Allele>();\n            alleles.add(Allele.create(ref.getBase(), true));\n            vc = new VariantContextBuilder(\"UG_call\", ref.getLocus().getContig(), ref.getLocus().getStart(), ref.getLocus().getStart(), alleles).make();\n        }\n        \n        if ( annotationEngine != null ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vc = annotationEngine.annotateContext(tracker, ref, stratifiedContexts, vc);\n        }\n\n        return new VariantCallContext(vc, false);\n    }","id":31452,"modified_method":"private VariantCallContext generateEmptyContext(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, AlignmentContext rawContext) {\n        VariantContext vc;\n        if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            VariantContext vcInput = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, ref, rawContext.getLocation(), false, logger, UAC.alleles);\n            if ( vcInput == null )\n                return null;\n            vc = new VariantContextBuilder(\"UG_call\", ref.getLocus().getContig(), vcInput.getStart(), vcInput.getEnd(), vcInput.getAlleles()).referenceBaseForIndel(vcInput.getReferenceBaseForIndel()).make();\n        } else {\n            // deal with bad/non-standard reference bases\n            if ( !Allele.acceptableAlleleBases(new byte[]{ref.getBase()}) )\n                return null;\n\n            Set<Allele> alleles = new HashSet<Allele>();\n            alleles.add(Allele.create(ref.getBase(), true));\n            vc = new VariantContextBuilder(\"UG_call\", ref.getLocus().getContig(), ref.getLocus().getStart(), ref.getLocus().getStart(), alleles).make();\n        }\n        \n        if ( annotationEngine != null && rawContext.hasBasePileup() ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            final ReadBackedPileup pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vc = annotationEngine.annotateContext(tracker, ref, stratifiedContexts, vc);\n        }\n\n        return new VariantCallContext(vc, false);\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute GLs at a given locus. Entry point for engine calls from UGCalcLikelihoods.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel( tracker, refContext, rawContext );\n        if( model == null )\n            return null;\n\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        if ( stratifiedContexts == null )\n            return null;\n\n        return calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n    }","id":31453,"modified_method":"/**\n     * Compute GLs at a given locus. Entry point for engine calls from UGCalcLikelihoods.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        final List<GenotypeLikelihoodsCalculationModel.Model> models = getGLModelsToUse(tracker, refContext, rawContext);\n        if ( models.isEmpty() ) {\n            return null;\n        }\n\n        for ( final GenotypeLikelihoodsCalculationModel.Model model : models ) {\n            final Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n            // return the first valid one we encounter\n            if ( stratifiedContexts != null )\n                return calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n\n        }\n\n        return null;\n    }","commit_id":"e4469a83ee37599da1430cc5f6df2a6cefaefce6","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void writeSampleLikelihoods( StringBuffer out, VariantContext vc, double[] log10Likelihoods ) {\n        if ( VQSRCalibrator != null )\n            log10Likelihoods = VQSRCalibrator.includeErrorRateInLikelihoods(VQSLOD_KEY, vc, log10Likelihoods);\n\n        double[] normalizedLog10Likelihoods = MathUtils.normalizeFromLog10(log10Likelihoods);\n        // see if we need to randomly mask out genotype in this position.\n        // todo -- remove me after testing\n        if ( log10Likelihoods == HAPLOID_FLAT_LOG10_LIKELIHOODS || log10Likelihoods == DIPLOID_FLAT_LOG10_LIKELIHOODS )\n            for (double likeVal: normalizedLog10Likelihoods)\n                out.append(String.format(\"%.2f \",likeVal));\n        else\n            for (double likeVal: normalizedLog10Likelihoods)\n                out.append(String.format(\"%5.4f \",likeVal));\n    }","id":31454,"modified_method":"private void writeSampleLikelihoods( StringBuffer out, VariantContext vc, double[] log10Likelihoods ) {\n        if ( VQSRCalibrator != null )\n            log10Likelihoods = VQSRCalibrator.includeErrorRateInLikelihoods(VQSLOD_KEY, vc, log10Likelihoods);\n\n        double[] normalizedLikelihoods = MathUtils.normalizeFromLog10(log10Likelihoods);\n        // see if we need to randomly mask out genotype in this position.\n        // todo -- remove me after testing\n        if ( REMAIN_COMPATIBLE_WITH_PREVIOUS_IO && (log10Likelihoods == HAPLOID_FLAT_LOG10_LIKELIHOODS || log10Likelihoods == DIPLOID_FLAT_LOG10_LIKELIHOODS) )\n            for (double likeVal: normalizedLikelihoods)\n                out.append(String.format(\"%.2f \",likeVal));\n        else\n            for (double likeVal: normalizedLikelihoods) {\n                out.append(String.format(\"%5.4f \",likeVal));\n            }\n    }","commit_id":"b99e27bf9b71f52b5b9c9b2cfdff5816859939c0","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Set<VCFHeaderLine> getHeaderInfo() {\n        Set<VCFHeaderLine> headerInfo = new HashSet<VCFHeaderLine>();\n\n        // all annotation fields from VariantAnnotatorEngine\n        headerInfo.addAll(annotationEngine.getVCFAnnotationDescriptions());\n\n        // annotation (INFO) fields from UnifiedGenotyper\n        if ( !UAC.NO_SLOD )\n            headerInfo.add(new VCFInfoHeaderLine(VCFConstants.STRAND_BIAS_KEY, 1, VCFHeaderLineType.Float, \"Strand Bias\"));\n        headerInfo.add(new VCFInfoHeaderLine(VCFConstants.DOWNSAMPLED_KEY, 0, VCFHeaderLineType.Flag, \"Were any of the samples downsampled?\"));\n\n        // also, check to see whether comp rods were included\n        List<ReferenceOrderedDataSource> dataSources = getToolkit().getRodDataSources();\n        for ( ReferenceOrderedDataSource source : dataSources ) {\n            if ( source.getName().equals(DbSNPHelper.STANDARD_DBSNP_TRACK_NAME) ) {\n                headerInfo.add(new VCFInfoHeaderLine(VCFConstants.DBSNP_KEY, 0, VCFHeaderLineType.Flag, \"dbSNP Membership\"));\n            }\n            else if ( source.getName().startsWith(VariantAnnotatorEngine.dbPrefix) ) {\n                String name = source.getName().substring(VariantAnnotatorEngine.dbPrefix.length());\n                headerInfo.add(new VCFInfoHeaderLine(name, 0, VCFHeaderLineType.Flag, name + \" Membership\"));\n            }\n        }\n\n        // FORMAT and INFO fields\n        headerInfo.addAll(VCFUtils.getSupportedHeaderStrings(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY));\n\n        // FILTER fields\n        if ( UAC.STANDARD_CONFIDENCE_FOR_EMITTING < UAC.STANDARD_CONFIDENCE_FOR_CALLING )\n            headerInfo.add(new VCFFilterHeaderLine(UnifiedGenotyperEngine.LOW_QUAL_FILTER_NAME, \"Low quality\"));\n\n        return headerInfo;\n    }","id":31455,"modified_method":"private Set<VCFHeaderLine> getHeaderInfo() {\n        Set<VCFHeaderLine> headerInfo = new HashSet<VCFHeaderLine>();\n\n        // all annotation fields from VariantAnnotatorEngine\n        headerInfo.addAll(annotationEngine.getVCFAnnotationDescriptions());\n\n        // annotation (INFO) fields from UnifiedGenotyper\n        if ( !UAC.NO_SLOD )\n            headerInfo.add(new VCFInfoHeaderLine(VCFConstants.STRAND_BIAS_KEY, 1, VCFHeaderLineType.Float, \"Strand Bias\"));\n        headerInfo.add(new VCFInfoHeaderLine(VCFConstants.DOWNSAMPLED_KEY, 0, VCFHeaderLineType.Flag, \"Were any of the samples downsampled?\"));\n\n        // also, check to see whether comp rods were included\n        List<ReferenceOrderedDataSource> dataSources = getToolkit().getRodDataSources();\n        for ( ReferenceOrderedDataSource source : dataSources ) {\n            if ( source.getName().equals(DbSNPHelper.STANDARD_DBSNP_TRACK_NAME) ) {\n                headerInfo.add(new VCFInfoHeaderLine(VCFConstants.DBSNP_KEY, 0, VCFHeaderLineType.Flag, \"dbSNP Membership\"));\n            }\n            else if ( source.getName().startsWith(VariantAnnotatorEngine.dbPrefix) ) {\n                String name = source.getName().substring(VariantAnnotatorEngine.dbPrefix.length());\n                headerInfo.add(new VCFInfoHeaderLine(name, 0, VCFHeaderLineType.Flag, name + \" Membership\"));\n            }\n        }\n\n        // FORMAT and INFO fields\n        headerInfo.addAll(VCFUtils.getSupportedHeaderStrings());\n\n        // FILTER fields\n        if ( UAC.STANDARD_CONFIDENCE_FOR_EMITTING < UAC.STANDARD_CONFIDENCE_FOR_CALLING )\n            headerInfo.add(new VCFFilterHeaderLine(UnifiedGenotyperEngine.LOW_QUAL_FILTER_NAME, \"Low quality\"));\n\n        return headerInfo;\n    }","commit_id":"b99e27bf9b71f52b5b9c9b2cfdff5816859939c0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute full calls at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        if ( UAC.COVERAGE_AT_WHICH_TO_ABORT > 0 && rawContext.size() > UAC.COVERAGE_AT_WHICH_TO_ABORT )\n            return null;\n\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        if ( stratifiedContexts == null )\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ? null : new VariantCallContext(generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext), refContext.getBase(), false));\n\n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE, null);\n        if ( vc == null )\n            return null;\n\n        VariantCallContext vcc = calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc);\n        vcc.vc = GLsToPLs(vcc.vc);\n        return vcc;\n    }","id":31456,"modified_method":"/**\n     * Compute full calls at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        if ( UAC.COVERAGE_AT_WHICH_TO_ABORT > 0 && rawContext.size() > UAC.COVERAGE_AT_WHICH_TO_ABORT )\n            return null;\n\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        if ( stratifiedContexts == null )\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ? null : new VariantCallContext(generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext), refContext.getBase(), false));\n\n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE, null);\n        if ( vc == null )\n            return null;\n\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc);\n    }","commit_id":"b99e27bf9b71f52b5b9c9b2cfdff5816859939c0","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantContext createVariantContextFromLikelihoods(ReferenceContext refContext, Allele refAllele, Map<String, BiallelicGenotypeLikelihoods> GLs) {\n        // no-call everyone for now\n        List<Allele> noCall = new ArrayList<Allele>();\n        noCall.add(Allele.NO_CALL);\n\n        Set<Allele> alleles = new HashSet<Allele>();\n        alleles.add(refAllele);\n        boolean addedAltAllele = false;\n\n        HashMap<String, Genotype> genotypes = new HashMap<String, Genotype>();\n        for ( BiallelicGenotypeLikelihoods GL : GLs.values() ) {\n            if ( !addedAltAllele ) {\n                addedAltAllele = true;\n                alleles.add(GL.getAlleleA());\n                alleles.add(GL.getAlleleB());\n            }\n\n            HashMap<String, Object> attributes = new HashMap<String, Object>();\n            GenotypeLikelihoods likelihoods = new GenotypeLikelihoods(GL.getLikelihoods());\n            attributes.put(VCFConstants.DEPTH_KEY, GL.getDepth());\n            attributes.put(VCFConstants.GENOTYPE_LIKELIHOODS_KEY, likelihoods);\n\n            genotypes.put(GL.getSample(), new Genotype(GL.getSample(), noCall, Genotype.NO_NEG_LOG_10PERROR, null, attributes, false));\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n        int endLoc = calculateEndPos(alleles, refAllele, loc);\n\n        return new VariantContext(\"UG_call\",\n                loc.getContig(),\n                loc.getStart(),\n                endLoc,\n                alleles,\n                genotypes,\n                VariantContext.NO_NEG_LOG_10PERROR,\n                null,\n                null);\n    }","id":31457,"modified_method":"private VariantContext createVariantContextFromLikelihoods(ReferenceContext refContext, Allele refAllele, Map<String, BiallelicGenotypeLikelihoods> GLs) {\n        // no-call everyone for now\n        List<Allele> noCall = new ArrayList<Allele>();\n        noCall.add(Allele.NO_CALL);\n\n        Set<Allele> alleles = new HashSet<Allele>();\n        alleles.add(refAllele);\n        boolean addedAltAllele = false;\n\n        HashMap<String, Genotype> genotypes = new HashMap<String, Genotype>();\n        for ( BiallelicGenotypeLikelihoods GL : GLs.values() ) {\n            if ( !addedAltAllele ) {\n                addedAltAllele = true;\n                alleles.add(GL.getAlleleA());\n                alleles.add(GL.getAlleleB());\n            }\n\n            HashMap<String, Object> attributes = new HashMap<String, Object>();\n            //GenotypeLikelihoods likelihoods = new GenotypeLikelihoods(GL.getLikelihoods());\n            GenotypeLikelihoods likelihoods = GenotypeLikelihoods.fromLog10Likelihoods(GL.getLikelihoods());\n            attributes.put(VCFConstants.DEPTH_KEY, GL.getDepth());\n            attributes.put(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, likelihoods);\n\n            genotypes.put(GL.getSample(), new Genotype(GL.getSample(), noCall, Genotype.NO_NEG_LOG_10PERROR, null, attributes, false));\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n        int endLoc = calculateEndPos(alleles, refAllele, loc);\n\n        return new VariantContext(\"UG_call\",\n                loc.getContig(),\n                loc.getStart(),\n                endLoc,\n                alleles,\n                genotypes,\n                VariantContext.NO_NEG_LOG_10PERROR,\n                null,\n                null);\n    }","commit_id":"b99e27bf9b71f52b5b9c9b2cfdff5816859939c0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute GLs at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @param alternateAlleleToUse the alternate allele to use, null if not set\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Allele alternateAlleleToUse) {\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        if ( stratifiedContexts == null )\n            return null;\n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE, alternateAlleleToUse);\n        return GLsToPLs(vc);\n    }","id":31458,"modified_method":"/**\n     * Compute GLs at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @param alternateAlleleToUse the alternate allele to use, null if not set\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Allele alternateAlleleToUse) {\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        if ( stratifiedContexts == null )\n            return null;\n        return calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE, alternateAlleleToUse);\n    }","commit_id":"b99e27bf9b71f52b5b9c9b2cfdff5816859939c0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * return a set of supported format lines; what we currently support for output in the genotype fields of a VCF\n     * @return a set of VCF format lines\n     */\n    public static Set<VCFFormatHeaderLine> getSupportedHeaderStrings(String glType) {\n        Set<VCFFormatHeaderLine> result = new HashSet<VCFFormatHeaderLine>();\n        result.add(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_KEY, 1, VCFHeaderLineType.String, \"Genotype\"));\n        result.add(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_QUALITY_KEY, 1, VCFHeaderLineType.Float, \"Genotype Quality\"));\n        result.add(new VCFFormatHeaderLine(VCFConstants.DEPTH_KEY, 1, VCFHeaderLineType.Integer, \"Read Depth (only filtered reads used for calling)\"));\n\n        if ( glType == VCFConstants.GENOTYPE_LIKELIHOODS_KEY )\n            result.add(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_LIKELIHOODS_KEY, 3, VCFHeaderLineType.Float, \"Log-scaled likelihoods for AA,AB,BB genotypes where A=ref and B=alt; not applicable if site is not biallelic\"));\n        else if ( glType == VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY )\n                result.add(new VCFFormatHeaderLine(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, 3, VCFHeaderLineType.Float, \"Normalized, Phred-scaled likelihoods for AA,AB,BB genotypes where A=ref and B=alt; not applicable if site is not biallelic\"));\n        else\n            throw new ReviewedStingException(\"Unexpected GL type \" + glType);\n\n        return result;\n    }","id":31459,"modified_method":"/**\n     * return a set of supported format lines; what we currently support for output in the genotype fields of a VCF\n     * @return a set of VCF format lines\n     */\n    public static Set<VCFFormatHeaderLine> getSupportedHeaderStrings() {\n        Set<VCFFormatHeaderLine> result = new HashSet<VCFFormatHeaderLine>();\n        result.add(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_KEY, 1, VCFHeaderLineType.String, \"Genotype\"));\n        result.add(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_QUALITY_KEY, 1, VCFHeaderLineType.Float, \"Genotype Quality\"));\n        result.add(new VCFFormatHeaderLine(VCFConstants.DEPTH_KEY, 1, VCFHeaderLineType.Integer, \"Read Depth (only filtered reads used for calling)\"));\n        result.add(new VCFFormatHeaderLine(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, 3, VCFHeaderLineType.Float, \"Normalized, Phred-scaled likelihoods for AA,AB,BB genotypes where A=ref and B=alt; not applicable if site is not biallelic\"));\n\n        return result;\n    }","commit_id":"b99e27bf9b71f52b5b9c9b2cfdff5816859939c0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Can be overridden by concrete subclasses\n     * @param vc                   variant context with genotype likelihoods\n     * @param log10AlleleFrequencyPosteriors    allele frequency results\n     * @param AFofMaxLikelihood    allele frequency of max likelihood\n     *\n     * @return calls\n     */\n    public Map<String, Genotype> assignGenotypes(VariantContext vc,\n                                                 double[] log10AlleleFrequencyPosteriors,\n                                                 int AFofMaxLikelihood) {\n        if ( !vc.isVariant() )\n            throw new UserException(\"The VCF record passed in does not contain an ALT allele at \" + vc.getChr() + \":\" + vc.getStart());\n\n        Allele refAllele = vc.getReference();\n        Allele altAllele = vc.getAlternateAllele(0);\n\n        Map<String, Genotype> GLs = vc.getGenotypes();\n        double[][] pathMetricArray = new double[GLs.size()+1][AFofMaxLikelihood+1];\n        int[][] tracebackArray = new int[GLs.size()+1][AFofMaxLikelihood+1];\n\n        ArrayList<String> sampleIndices = new ArrayList<String>();\n        int sampleIdx = 0;\n\n        // todo - optimize initialization\n        for (int k=0; k <= AFofMaxLikelihood; k++)\n            for (int j=0; j <= GLs.size(); j++)\n                pathMetricArray[j][k] = -1e30;\n\n        pathMetricArray[0][0] = 0.0;\n\n        if (SIMPLE_GREEDY_GENOTYPER) {\n            sampleIndices.addAll(GLs.keySet());\n            sampleIdx = GLs.size();\n        }\n        else {\n\n            for ( Map.Entry<String, Genotype> sample : GLs.entrySet() ) {\n                if ( !sample.getValue().hasLikelihoods() )\n                    continue;\n\n                double[] likelihoods = sample.getValue().getLikelihoods().getAsVector();\n                sampleIndices.add(sample.getKey());\n\n                for (int k=0; k <= AFofMaxLikelihood; k++) {\n\n                    double bestMetric = pathMetricArray[sampleIdx][k] + likelihoods[0];\n                    int bestIndex = k;\n\n                    if (k>0) {\n                        double m2 =  pathMetricArray[sampleIdx][k-1] + likelihoods[1];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-1;\n                        }\n                    }\n\n                    if (k>1) {\n                        double m2 =  pathMetricArray[sampleIdx][k-2] + likelihoods[2];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-2;\n                        }\n                    }\n\n                    pathMetricArray[sampleIdx+1][k] = bestMetric;\n                    tracebackArray[sampleIdx+1][k] = bestIndex;\n                }\n                sampleIdx++;\n            }\n        }\n\n        HashMap<String, Genotype> calls = new HashMap<String, Genotype>();\n\n        int startIdx = AFofMaxLikelihood;\n        for (int k = sampleIdx; k > 0; k--) {\n            int bestGTguess;\n            String sample = sampleIndices.get(k-1);\n            Genotype g = GLs.get(sample);\n            if ( !g.hasLikelihoods() )\n                continue;\n\n            if (SIMPLE_GREEDY_GENOTYPER)\n                bestGTguess = Utils.findIndexOfMaxEntry(g.getLikelihoods().getAsVector());\n            else {\n                int newIdx = tracebackArray[k][startIdx];\n                bestGTguess = startIdx - newIdx;\n                startIdx = newIdx;\n            }\n\n            ArrayList<Allele> myAlleles = new ArrayList<Allele>();\n\n            double qual;\n            double[] likelihoods = g.getLikelihoods().getAsVector();\n\n            if (bestGTguess == 0) {\n                myAlleles.add(refAllele);\n                myAlleles.add(refAllele);\n                qual = likelihoods[0] - Math.max(likelihoods[1], likelihoods[2]);\n            } else if(bestGTguess == 1) {\n                myAlleles.add(refAllele);\n                myAlleles.add(altAllele);\n                qual = likelihoods[1] - Math.max(likelihoods[0], likelihoods[2]);\n\n            }  else {\n                myAlleles.add(altAllele);\n                myAlleles.add(altAllele);\n                qual = likelihoods[2] - Math.max(likelihoods[1], likelihoods[0]);\n            }\n\n\n            if (qual < 0) {\n                // QUAL can be negative if the chosen genotype is not the most likely one individually.\n                // In this case, we compute the actual genotype probability and QUAL is the likelihood of it not being the chosen on\n                double[] normalized = MathUtils.normalizeFromLog10(likelihoods);\n                double chosenGenotype = normalized[bestGTguess];\n                qual = -1.0 * Math.log10(1.0 - chosenGenotype);\n            }\n\n            HashMap<String, Object> attributes = new HashMap<String, Object>(g.getAttributes());\n            attributes.remove(VCFConstants.GENOTYPE_LIKELIHOODS_KEY);\n            attributes.put(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, GenotypeLikelihoods.GLsToPLs(likelihoods));\n\n            calls.put(sample, new Genotype(sample, myAlleles, qual, null, attributes, false));\n\n        }\n\n        return calls;\n    }","id":31460,"modified_method":"/**\n     * Can be overridden by concrete subclasses\n     * @param vc                   variant context with genotype likelihoods\n     * @param log10AlleleFrequencyPosteriors    allele frequency results\n     * @param AFofMaxLikelihood    allele frequency of max likelihood\n     *\n     * @return calls\n     */\n    public Map<String, Genotype> assignGenotypes(VariantContext vc,\n                                                 double[] log10AlleleFrequencyPosteriors,\n                                                 int AFofMaxLikelihood) {\n        if ( !vc.isVariant() )\n            throw new UserException(\"The VCF record passed in does not contain an ALT allele at \" + vc.getChr() + \":\" + vc.getStart());\n\n        Allele refAllele = vc.getReference();\n        Allele altAllele = vc.getAlternateAllele(0);\n\n        Map<String, Genotype> GLs = vc.getGenotypes();\n        double[][] pathMetricArray = new double[GLs.size()+1][AFofMaxLikelihood+1];\n        int[][] tracebackArray = new int[GLs.size()+1][AFofMaxLikelihood+1];\n\n        ArrayList<String> sampleIndices = new ArrayList<String>();\n        int sampleIdx = 0;\n\n        // todo - optimize initialization\n        for (int k=0; k <= AFofMaxLikelihood; k++)\n            for (int j=0; j <= GLs.size(); j++)\n                pathMetricArray[j][k] = -1e30;\n\n        pathMetricArray[0][0] = 0.0;\n\n        if (SIMPLE_GREEDY_GENOTYPER) {\n            sampleIndices.addAll(GLs.keySet());\n            sampleIdx = GLs.size();\n        }\n        else {\n\n            for ( Map.Entry<String, Genotype> sample : GLs.entrySet() ) {\n                if ( !sample.getValue().hasLikelihoods() )\n                    continue;\n\n                double[] likelihoods = sample.getValue().getLikelihoods().getAsVector();\n                sampleIndices.add(sample.getKey());\n\n                for (int k=0; k <= AFofMaxLikelihood; k++) {\n\n                    double bestMetric = pathMetricArray[sampleIdx][k] + likelihoods[0];\n                    int bestIndex = k;\n\n                    if (k>0) {\n                        double m2 =  pathMetricArray[sampleIdx][k-1] + likelihoods[1];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-1;\n                        }\n                    }\n\n                    if (k>1) {\n                        double m2 =  pathMetricArray[sampleIdx][k-2] + likelihoods[2];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-2;\n                        }\n                    }\n\n                    pathMetricArray[sampleIdx+1][k] = bestMetric;\n                    tracebackArray[sampleIdx+1][k] = bestIndex;\n                }\n                sampleIdx++;\n            }\n        }\n\n        HashMap<String, Genotype> calls = new HashMap<String, Genotype>();\n\n        int startIdx = AFofMaxLikelihood;\n        for (int k = sampleIdx; k > 0; k--) {\n            int bestGTguess;\n            String sample = sampleIndices.get(k-1);\n            Genotype g = GLs.get(sample);\n            if ( !g.hasLikelihoods() )\n                continue;\n\n            if (SIMPLE_GREEDY_GENOTYPER)\n                bestGTguess = Utils.findIndexOfMaxEntry(g.getLikelihoods().getAsVector());\n            else {\n                int newIdx = tracebackArray[k][startIdx];\n                bestGTguess = startIdx - newIdx;\n                startIdx = newIdx;\n            }\n\n            ArrayList<Allele> myAlleles = new ArrayList<Allele>();\n\n            double qual;\n            double[] likelihoods = g.getLikelihoods().getAsVector();\n\n            if (bestGTguess == 0) {\n                myAlleles.add(refAllele);\n                myAlleles.add(refAllele);\n                qual = likelihoods[0] - Math.max(likelihoods[1], likelihoods[2]);\n            } else if(bestGTguess == 1) {\n                myAlleles.add(refAllele);\n                myAlleles.add(altAllele);\n                qual = likelihoods[1] - Math.max(likelihoods[0], likelihoods[2]);\n\n            }  else {\n                myAlleles.add(altAllele);\n                myAlleles.add(altAllele);\n                qual = likelihoods[2] - Math.max(likelihoods[1], likelihoods[0]);\n            }\n\n\n            if (qual < 0) {\n                // QUAL can be negative if the chosen genotype is not the most likely one individually.\n                // In this case, we compute the actual genotype probability and QUAL is the likelihood of it not being the chosen on\n                double[] normalized = MathUtils.normalizeFromLog10(likelihoods);\n                double chosenGenotype = normalized[bestGTguess];\n                qual = -1.0 * Math.log10(1.0 - chosenGenotype);\n            }\n\n            calls.put(sample, new Genotype(sample, myAlleles, qual, null, g.getAttributes(), false));\n\n        }\n\n        return calls;\n    }","commit_id":"222cd42ceb8e2162e6824f7f986d57ab9c1cfdb3","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Overrides the super class\n     * @param vc                   variant context with genotype likelihoods\n     * @param log10AlleleFrequencyPosteriors    allele frequency results\n     * @param AFofMaxLikelihood    allele frequency of max likelihood\n     *\n     * @return calls\n     */\n    protected Map<String, Genotype> assignGenotypes(VariantContext vc,\n                                                    double[] log10AlleleFrequencyPosteriors,\n                                                    int AFofMaxLikelihood) {\n        if ( !vc.isVariant() )\n            throw new UserException(\"The VCF record passed in does not contain an ALT allele at \" + vc.getChr() + \":\" + vc.getStart());\n\n        Allele refAllele = vc.getReference();\n        Allele altAllele = vc.getAlternateAllele(0);\n        HashMap<String, Genotype> calls = new HashMap<String, Genotype>();\n\n        // first, the potential alt calls\n        for ( String sample : AFMatrix.getSamples() ) {\n            Genotype g = vc.getGenotype(sample);\n\n            // set the genotype and confidence\n            Pair<Integer, Double> AFbasedGenotype = AFMatrix.getGenotype(AFofMaxLikelihood, sample);\n            ArrayList<Allele> myAlleles = new ArrayList<Allele>();\n            if ( AFbasedGenotype.first == GenotypeType.AA.ordinal() ) {\n                myAlleles.add(refAllele);\n                myAlleles.add(refAllele);\n            } else if ( AFbasedGenotype.first == GenotypeType.AB.ordinal() ) {\n                myAlleles.add(refAllele);\n                myAlleles.add(altAllele);\n            } else { // ( AFbasedGenotype.first == GenotypeType.BB.ordinal() )\n                myAlleles.add(altAllele);\n                myAlleles.add(altAllele);\n            }\n\n            HashMap<String, Object> attributes = new HashMap<String, Object>(g.getAttributes());\n            attributes.remove(VCFConstants.GENOTYPE_LIKELIHOODS_KEY);\n            attributes.put(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, GenotypeLikelihoods.GLsToPLs(g.getLikelihoods().getAsVector()));\n\n            calls.put(sample, new Genotype(sample, myAlleles, AFbasedGenotype.second, null, attributes, false));\n        }\n\n        return calls;\n    }","id":31461,"modified_method":"/**\n     * Overrides the super class\n     * @param vc                   variant context with genotype likelihoods\n     * @param log10AlleleFrequencyPosteriors    allele frequency results\n     * @param AFofMaxLikelihood    allele frequency of max likelihood\n     *\n     * @return calls\n     */\n    protected Map<String, Genotype> assignGenotypes(VariantContext vc,\n                                                    double[] log10AlleleFrequencyPosteriors,\n                                                    int AFofMaxLikelihood) {\n        if ( !vc.isVariant() )\n            throw new UserException(\"The VCF record passed in does not contain an ALT allele at \" + vc.getChr() + \":\" + vc.getStart());\n\n        Allele refAllele = vc.getReference();\n        Allele altAllele = vc.getAlternateAllele(0);\n        HashMap<String, Genotype> calls = new HashMap<String, Genotype>();\n\n        // first, the potential alt calls\n        for ( String sample : AFMatrix.getSamples() ) {\n            Genotype g = vc.getGenotype(sample);\n\n            // set the genotype and confidence\n            Pair<Integer, Double> AFbasedGenotype = AFMatrix.getGenotype(AFofMaxLikelihood, sample);\n            ArrayList<Allele> myAlleles = new ArrayList<Allele>();\n            if ( AFbasedGenotype.first == GenotypeType.AA.ordinal() ) {\n                myAlleles.add(refAllele);\n                myAlleles.add(refAllele);\n            } else if ( AFbasedGenotype.first == GenotypeType.AB.ordinal() ) {\n                myAlleles.add(refAllele);\n                myAlleles.add(altAllele);\n            } else { // ( AFbasedGenotype.first == GenotypeType.BB.ordinal() )\n                myAlleles.add(altAllele);\n                myAlleles.add(altAllele);\n            }\n\n            calls.put(sample, new Genotype(sample, myAlleles, AFbasedGenotype.second, null, g.getAttributes(), false));\n        }\n\n        return calls;\n    }","commit_id":"222cd42ceb8e2162e6824f7f986d57ab9c1cfdb3","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute GLs at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        return calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE);\n    }","id":31462,"modified_method":"/**\n     * Compute GLs at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE);\n        return GLsToPLs(vc);\n    }","commit_id":"222cd42ceb8e2162e6824f7f986d57ab9c1cfdb3","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute full calls at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE);\n        return vc == null ? null : calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc);\n    }","id":31463,"modified_method":"/**\n     * Compute full calls at a given locus.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        Map<String, StratifiedAlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext);\n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, StratifiedAlignmentContext.StratifiedContextType.COMPLETE);\n        if ( vc == null )\n            return null;\n\n        VariantCallContext vcc = calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc);\n        vcc.vc = GLsToPLs(vcc.vc);\n        return vcc;\n    }","commit_id":"222cd42ceb8e2162e6824f7f986d57ab9c1cfdb3","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static int getNotificationType(\n\t\t\tMicroblogsEntry microblogsEntry, long userId)\n\t\tthrows PortalException {\n\n\t\tif (isTaggedUser(\n\t\t\t\tmicroblogsEntry.getMicroblogsEntryId(), false, userId)) {\n\n\t\t\treturn MicroblogsEntryConstants.TYPE_TAG;\n\t\t}\n\t\telse if (microblogsEntry.getType() ==\n\t\t\t\t\tMicroblogsEntryConstants.TYPE_REPLY) {\n\n\t\t\tlong parentMicroblogsEntryId = getParentMicroblogsEntryId(\n\t\t\t\tmicroblogsEntry);\n\n\t\t\tif ((getParentMicroblogsUserId(microblogsEntry) == userId)) {\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY;\n\t\t\t}\n\t\t\telse if (hasReplied(parentMicroblogsEntryId, userId)) {\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY_TO_REPLY;\n\t\t\t}\n\t\t\telse if (MicroblogsUtil.isTaggedUser(\n\t\t\t\t\t\tparentMicroblogsEntryId, true, userId)) {\n\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY_TO_TAG;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}","id":31464,"modified_method":"public static int getNotificationType(\n\t\t\tMicroblogsEntry microblogsEntry, long userId)\n\t\tthrows PortalException {\n\n\t\tif (isTaggedUser(\n\t\t\t\tmicroblogsEntry.getMicroblogsEntryId(), false, userId) &&\n\t\t\tUserNotificationManagerUtil.isDeliver(\n\t\t\t\tuserId, PortletKeys.MICROBLOGS, 0,\n\t\t\t\tMicroblogsEntryConstants.TYPE_TAG,\n\t\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE)) {\n\n\t\t\treturn MicroblogsEntryConstants.TYPE_TAG;\n\t\t}\n\t\telse if (microblogsEntry.getType() ==\n\t\t\t\t\tMicroblogsEntryConstants.TYPE_REPLY) {\n\n\t\t\tlong parentMicroblogsEntryId = getParentMicroblogsEntryId(\n\t\t\t\tmicroblogsEntry);\n\n\t\t\tif ((getParentMicroblogsUserId(microblogsEntry) == userId) &&\n\t\t\t\tUserNotificationManagerUtil.isDeliver(\n\t\t\t\t\t\tuserId, PortletKeys.MICROBLOGS, 0,\n\t\t\t\t\t\tMicroblogsEntryConstants.TYPE_REPLY,\n\t\t\t\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE)) {\n\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY;\n\t\t\t}\n\t\t\telse if (hasReplied(parentMicroblogsEntryId, userId) &&\n\t\t\t\t\t UserNotificationManagerUtil.isDeliver(\n\t\t\t\t\t\tuserId, PortletKeys.MICROBLOGS, 0,\n\t\t\t\t\t\tMicroblogsEntryConstants.TYPE_REPLY_TO_REPLY,\n\t\t\t\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE)) {\n\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY_TO_REPLY;\n\t\t\t}\n\t\t\telse if (MicroblogsUtil.isTaggedUser(\n\t\t\t\t\t\tparentMicroblogsEntryId, true, userId) &&\n\t\t\t\t\t UserNotificationManagerUtil.isDeliver(\n\t\t\t\t\t\tuserId, PortletKeys.MICROBLOGS, 0,\n\t\t\t\t\t\tMicroblogsEntryConstants.TYPE_REPLY_TO_TAG,\n\t\t\t\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE)) {\n\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY_TO_TAG;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}","commit_id":"7144a48c2d969cdc977027c803421ff574532436","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static int getNotificationType(\n\t\t\tMicroblogsEntry microblogsEntry, long userId)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong parentMicroblogsEntryId =\n\t\t\tMicroblogsUtil.getParentMicroblogsEntryId(microblogsEntry);\n\n\t\tif (MicroblogsUtil.isTaggedUser(\n\t\t\t\tmicroblogsEntry.getMicroblogsEntryId(), false,\n\t\t\t\tserviceContext.getUserId())) {\n\n\t\t\ttitle = serviceContext.translate(\n\t\t\t\t\"x-tagged-you-in-a-post\", userFullName);\n\t\t}\n\t\telse if (microblogsEntry.getType() ==\n\t\t\t\t\tMicroblogsEntryConstants.TYPE_REPLY) {\n\n\t\t\tif (MicroblogsUtil.getParentMicroblogsUserId(microblogsEntry) ==\n\t\t\t\t\tserviceContext.getUserId()) {\n\n\t\t\t\ttitle = serviceContext.translate(\n\t\t\t\t\t\"x-commented-on-your-post\", userFullName);\n\t\t\t}\n\t\t\telse if (MicroblogsUtil.hasReplied(\n\t\t\t\t\t\tparentMicroblogsEntryId, serviceContext.getUserId())) {\n\n\t\t\t\tUser receiverUser = UserLocalServiceUtil.fetchUser(\n\t\t\t\t\tmicroblogsEntry.getReceiverUserId());\n\n\t\t\t\tif (receiverUser != null) {\n\t\t\t\t\ttitle = serviceContext.translate(\n\t\t\t\t\t\t\"x-also-commented-on-x's-post\", userFullName,\n\t\t\t\t\t\treceiverUser.getFullName());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (MicroblogsUtil.isTaggedUser(\n\t\t\t\t\t\tparentMicroblogsEntryId, true,\n\t\t\t\t\t\tserviceContext.getUserId())) {\n\n\t\t\t\ttitle = serviceContext.translate(\n\t\t\t\t\t\"x-commented-on-a-post-you-are-tagged-in\", userFullName);\n\t\t\t}\n\t\t}\n\t}","id":31465,"modified_method":"public static int getNotificationType(\n\t\t\tMicroblogsEntry microblogsEntry, long userId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (isTaggedUser(\n\t\t\t\tmicroblogsEntry.getMicroblogsEntryId(), false, userId)) {\n\n\t\t\treturn MicroblogsEntryConstants.TYPE_TAG;\n\t\t}\n\t\telse if (microblogsEntry.getType() ==\n\t\t\t\t\tMicroblogsEntryConstants.TYPE_REPLY) {\n\n\t\t\tlong parentMicroblogsEntryId = getParentMicroblogsEntryId(\n\t\t\t\tmicroblogsEntry);\n\n\t\t\tif ((getParentMicroblogsUserId(microblogsEntry) == userId)) {\n\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY;\n\t\t\t}\n\t\t\telse if (hasReplied(parentMicroblogsEntryId, userId)) {\n\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY_TO_REPLY;\n\t\t\t}\n\t\t\telse if (MicroblogsUtil.isTaggedUser(\n\t\t\t\t\t\tparentMicroblogsEntryId, true, userId)) {\n\n\t\t\t\treturn MicroblogsEntryConstants.TYPE_REPLY_TO_TAG;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}","commit_id":"89296afd5daef216c21dc23f7071003824f8d8dd","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Object lookup(Object joinValue, final boolean iReturnRIDS) {\n    Object result = null;\n\n    if (joinValue != null) {\n      if (sqlQuery == null && index == null) {\n        // ONLY THE FIRST TIME\n        if (lookup.toUpperCase().startsWith(\"SELECT\"))\n          sqlQuery = new OSQLSynchQuery<ODocument>(lookup);\n        else {\n          index = db.getMetadata().getIndexManager().getIndex(lookup);\n          if (index == null) {\n            log(OETLProcessor.LOG_LEVELS.DEBUG, \"WARNING: index %s not found. Lookups could be really slow\", lookup);\n            final String[] parts = lookup.split(\"\\\\.\");\n            sqlQuery = new OSQLSynchQuery<ODocument>(\"SELECT FROM \" + parts[0] + \" WHERE \" + parts[1] + \" = ?\");\n          }\n        }\n      }\n\n      if (index != null) {\n        final OType idxFieldType = index.getDefinition().getTypes()[0];\n        joinValue = idxFieldType.convert(joinValue, idxFieldType.getDefaultJavaType());\n        result = index.get(joinValue);\n      } else\n        result = db.query(sqlQuery, joinValue);\n\n      if (result != null)\n        if (result instanceof Collection) {\n          if (!((Collection) result).isEmpty())\n            result = ((Collection<OIdentifiable>) result).iterator().next().getRecord();\n          else\n            result = null;\n        } else if (result instanceof OIdentifiable)\n          result = ((OIdentifiable) result).getRecord();\n\n      if (iReturnRIDS && result instanceof ORecord)\n        result = ((ORecord) result).getIdentity();\n\n    }\n\n    return result;\n  }","id":31466,"modified_method":"protected Object lookup(Object joinValue, final boolean iReturnRIDS) {\n    Object result = null;\n\n    if (joinValue != null) {\n      if (sqlQuery == null && index == null) {\n        // ONLY THE FIRST TIME\n        if (lookup.toUpperCase().startsWith(\"SELECT\"))\n          sqlQuery = new OSQLSynchQuery<ODocument>(lookup);\n        else {\n          index = db.getMetadata().getIndexManager().getIndex(lookup);\n          if (index == null) {\n            log(OETLProcessor.LOG_LEVELS.DEBUG, \"WARNING: index %s not found. Lookups could be really slow\", lookup);\n            final String[] parts = lookup.split(\"\\\\.\");\n            sqlQuery = new OSQLSynchQuery<ODocument>(\"SELECT FROM \" + parts[0] + \" WHERE \" + parts[1] + \" = ?\");\n          }\n        }\n      }\n\n      if (index != null) {\n        final OType idxFieldType = index.getDefinition().getTypes()[0];\n        joinValue = OType.convert(joinValue, idxFieldType.getDefaultJavaType());\n        result = index.get(joinValue);\n      } else\n        result = db.query(sqlQuery, joinValue);\n\n      if (result != null)\n        if (result instanceof Collection) {\n          if (!((Collection) result).isEmpty())\n            result = ((Collection<OIdentifiable>) result).iterator().next().getRecord();\n          else\n            result = null;\n        } else if (result instanceof OIdentifiable)\n          result = ((OIdentifiable) result).getRecord();\n\n      if (iReturnRIDS && result instanceof ORecord)\n        result = ((ORecord) result).getIdentity();\n\n    }\n\n    return result;\n  }","commit_id":"3588d8199ec8f8a8258ff058d2617f6cff14d4da","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void configure(OETLProcessor iProcessor, ODocument iConfiguration, OBasicCommandContext iContext) {\n    final Object value = iConfiguration.field(\"value\");\n\n    if (value != null) {\n      String stringContent;\n      if (value instanceof ODocument)\n        stringContent = ((ODocument) value).toJSON(null).toString();\n      else if (OMultiValue.isMultiValue(value)) {\n        stringContent = \"[\";\n        int i = 0;\n        for (Object o : OMultiValue.getMultiValueIterable(value)) {\n          if (o != null) {\n            if (i > 0)\n              stringContent += \",\";\n\n            if (o instanceof ODocument)\n              stringContent += ((ODocument) o).toJSON(null).toString();\n            else\n              stringContent += o.toString();\n            ++i;\n          }\n        }\n        stringContent += \"]\";\n      } else\n        stringContent = value.toString();\n\n      this.reader = new BufferedReader(new StringReader(stringContent));\n    } else\n      throw new IllegalArgumentException(getName() + \" Source has no 'value' set\");\n  }","id":31467,"modified_method":"@Override\n  public void configure(OETLProcessor iProcessor, ODocument iConfiguration, OBasicCommandContext iContext) {\n    final Object value = iConfiguration.field(\"value\");\n    if (value != null) {\n      String stringContent;\n      if (value instanceof ODocument)\n        stringContent = ((ODocument) value).toJSON(null);\n      else if (OMultiValue.isMultiValue(value)) {\n        stringContent = \"[\";\n        int i = 0;\n        for (Object o : OMultiValue.getMultiValueIterable(value)) {\n          if (o != null) {\n            if (i > 0)\n              stringContent += \",\";\n\n            if (o instanceof ODocument)\n              stringContent += ((ODocument) o).toJSON(null);\n            else\n              stringContent += o.toString();\n            ++i;\n          }\n        }\n        stringContent += \"]\";\n      } else\n        stringContent = value.toString();\n\n      this.reader = new BufferedReader(new StringReader(stringContent));\n    } else\n      throw new IllegalArgumentException(getName() + \" Source has no 'value' set\");\n  }","commit_id":"3588d8199ec8f8a8258ff058d2617f6cff14d4da","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected static Collection<ODocument> parseTransformers(final String value) {\n    final ArrayList<ODocument> cfgTransformers = new ArrayList<ODocument>();\n    if (!value.isEmpty()) {\n      if (value.charAt(0) == '{') {\n        cfgTransformers.add((ODocument) new ODocument().fromJSON(value, \"noMap\"));\n      } else if (value.charAt(0) == '[') {\n        final ArrayList<String> items = new ArrayList<String>();\n        OStringSerializerHelper.getCollection(value, 0, items);\n        for (String item : items)\n          cfgTransformers.add((ODocument) new ODocument().fromJSON(item, \"noMap\"));\n      }\n    }\n    return cfgTransformers;\n  }","id":31468,"modified_method":"protected static Collection<ODocument> parseTransformers(final String value) {\n    final Collection<ODocument> cfgTransformers = new ArrayList<ODocument>();\n    if (!value.isEmpty()) {\n      if (value.charAt(0) == '{') {\n        cfgTransformers.add(new ODocument().fromJSON(value, \"noMap\"));\n      } else if (value.charAt(0) == '[') {\n        final List<String> items = new ArrayList<String>();\n        OStringSerializerHelper.getCollection(value, 0, items);\n        for (String item : items)\n          cfgTransformers.add(new ODocument().fromJSON(item, \"noMap\"));\n      }\n    }\n    return cfgTransformers;\n  }","commit_id":"3588d8199ec8f8a8258ff058d2617f6cff14d4da","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void begin() {\n    out(LOG_LEVELS.INFO, \"BEGIN ETL PROCESSOR\");\n\n    final Integer cfgMaxRetries = (Integer) context.getVariable(\"maxRetries\");\n    if (cfgMaxRetries != null)\n      maxRetries = cfgMaxRetries;\n\n    final int dumpEveryMs = (Integer) context.getVariable(\"dumpEveryMs\");\n    if (dumpEveryMs > 0) {\n      dumpTask = new TimerTask() {\n        @Override\n        public void run() {\n          dumpProgress();\n        }\n      };\n\n      Orient.instance().getTimer().schedule(dumpTask, dumpEveryMs, dumpEveryMs);\n\n      startTime = System.currentTimeMillis();\n    }\n\n    for (OBlock t : beginBlocks) {\n      t.begin();\n      t.execute();\n      t.end();\n    }\n\n    if (source != null)\n      source.begin();\n    extractor.begin();\n  }","id":31469,"modified_method":"protected void begin() {\n    out(LOG_LEVELS.INFO, \"BEGIN ETL PROCESSOR\");\n\n    final Integer cfgMaxRetries = (Integer) context.getVariable(\"maxRetries\");\n    if (cfgMaxRetries != null)\n      maxRetries = cfgMaxRetries;\n\n    final int dumpEveryMs = (Integer) context.getVariable(\"dumpEveryMs\");\n    if (dumpEveryMs > 0) {\n      dumpTask = new TimerTask() {\n        @Override\n        public void run() {\n          dumpProgress();\n        }\n      };\n\n      Orient.instance().scheduleTask(dumpTask, dumpEveryMs, dumpEveryMs);\n\n      startTime = System.currentTimeMillis();\n    }\n\n    for (OBlock t : beginBlocks) {\n      t.begin();\n      t.execute();\n      t.end();\n    }\n\n    if (source != null)\n      source.begin();\n    extractor.begin();\n  }","commit_id":"3588d8199ec8f8a8258ff058d2617f6cff14d4da","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void init() {\n    final String cfgLog = (String) context.getVariable(\"log\");\n    if (cfgLog != null)\n      logLevel = LOG_LEVELS.valueOf(cfgLog.toUpperCase());\n\n    final Object parallelSetting = context.getVariable(\"parallel\");\n    if (parallelSetting != null)\n      parallel = ((Boolean) parallelSetting).booleanValue();\n\n    if (parallel) {\n      final int cores = Runtime.getRuntime().availableProcessors();\n      threads = new Thread[cores];\n      for (int i = 0; i < cores; ++i) {\n        threads[i] = new Thread(\"OrientDB ETL Pipeline-\" + i);\n      }\n    }\n  }","id":31470,"modified_method":"protected void init() {\n    final String cfgLog = (String) context.getVariable(\"log\");\n    if (cfgLog != null)\n      logLevel = LOG_LEVELS.valueOf(cfgLog.toUpperCase());\n\n    final Object parallelSetting = context.getVariable(\"parallel\");\n    if (parallelSetting != null)\n      parallel = (Boolean) parallelSetting;\n\n    if (parallel) {\n      final int cores = Runtime.getRuntime().availableProcessors();\n      threads = new Thread[cores];\n      for (int i = 0; i < cores; ++i) {\n        threads[i] = new Thread(\"OrientDB ETL Pipeline-\" + i);\n      }\n    }\n  }","commit_id":"3588d8199ec8f8a8258ff058d2617f6cff14d4da","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void begin() {\n    if (path instanceof File) {\n      final File file = (File) path;\n\n      try {\n        final String fileMode = lockFile ? \"rw\" : \"r\";\n        raf = new RandomAccessFile(file, fileMode);\n        channel = raf.getChannel();\n        fis = new FileInputStream(file);\n        if (fileName.endsWith(\".gz\"))\n          fileReader = new InputStreamReader(new GZIPInputStream(fis));\n        else {\n          fileReader = new FileReader(file);\n          byteToParse = file.length();\n        }\n\n      } catch (Exception e) {\n        end();\n      }\n    } else if (path instanceof InputStream) {\n      fileName = null;\n      byteToParse = -1;\n      fileReader = new InputStreamReader((InputStream) path);\n    } else if (path instanceof InputStreamReader) {\n      fileName = null;\n      byteToParse = -1;\n      fileReader = (InputStreamReader) path;\n    } else\n      throw new OSourceException(\"[File source] Unknown input '\" + path + \"' of class '\" + path.getClass() + \"'\");\n\n    byteParsed = 0;\n\n    if (lockFile)\n      try {\n        lock = channel.lock();\n      } catch (IOException e) {\n        OLogManager.instance().error(this, \"Error on locking file: %s\", e, fileName);\n      }\n\n    log(OETLProcessor.LOG_LEVELS.DEBUG, \"Reading from file \" + path);\n\n    final long startTime = System.currentTimeMillis();\n  }","id":31471,"modified_method":"@Override\n  public void begin() {\n    if (path instanceof File) {\n      final File file = (File) path;\n\n      try {\n        final String fileMode = lockFile ? \"rw\" : \"r\";\n        raf = new RandomAccessFile(file, fileMode);\n        channel = raf.getChannel();\n        fis = new FileInputStream(file);\n        if (fileName.endsWith(\".gz\"))\n          fileReader = new InputStreamReader(new GZIPInputStream(fis));\n        else {\n          fileReader = new FileReader(file);\n          byteToParse = file.length();\n        }\n\n      } catch (Exception e) {\n        end();\n      }\n    } else if (path instanceof InputStream) {\n      fileName = null;\n      byteToParse = -1;\n      fileReader = new InputStreamReader((InputStream) path);\n    } else if (path instanceof InputStreamReader) {\n      fileName = null;\n      byteToParse = -1;\n      fileReader = (InputStreamReader) path;\n    } else\n      throw new OSourceException(\"[File source] Unknown input '\" + path + \"' of class '\" + path.getClass() + \"'\");\n\n    byteParsed = 0;\n\n    if (lockFile)\n      try {\n        lock = channel.lock();\n      } catch (IOException e) {\n        OLogManager.instance().error(this, \"Error on locking file: %s\", e, fileName);\n      }\n\n    log(OETLProcessor.LOG_LEVELS.DEBUG, \"Reading from file \" + path);\n  }","commit_id":"3588d8199ec8f8a8258ff058d2617f6cff14d4da","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void load(final Object input, OCommandContext context) {\n    if (input == null)\n      return;\n\n    if (dbAutoCreateProperties) {\n      if (dbType == DB_TYPE.DOCUMENT) {\n        if (input instanceof ODocument) {\n          final ODocument doc = (ODocument) input;\n          final ODatabaseDocumentTx documentDatabase = pipeline.getDocumentDatabase();\n          final OClass cls;\n          if (className != null)\n            cls = getOrCreateClass(className, null);\n          else\n            cls = doc.getSchemaClass();\n\n          for (String f : doc.fieldNames()) {\n            final String newName = transformFieldName(f);\n            final String fName = newName != null ? newName : f;\n\n            OProperty p = cls.getProperty(fName);\n            if (p == null) {\n              final Object fValue = doc.field(f);\n              createProperty(cls, fName, fValue);\n              if (newName != null) {\n                // REPLACE IT\n                doc.removeField(f);\n                doc.field(newName, fValue);\n              }\n            }\n          }\n        }\n      } else if (dbType == DB_TYPE.GRAPH) {\n        if (input instanceof OrientElement) {\n          final OrientElement element = (OrientElement) input;\n\n          final OClass cls;\n          final String clsName = className != null ? className : (element instanceof OrientVertex ? ((OrientVertex) element)\n              .getLabel() : ((OrientEdge) element).getLabel());\n          if (clsName != null)\n            cls = getOrCreateClass(clsName, element.getBaseClassName());\n          else\n            throw new IllegalArgumentException(\"No class defined on graph element: \" + input);\n\n          for (String f : element.getPropertyKeys()) {\n            final String newName = transformFieldName(f);\n            final String fName = newName != null ? newName : f;\n\n            OProperty p = cls.getProperty(fName);\n            if (p == null) {\n              final Object fValue = element.getProperty(f);\n              createProperty(cls, fName, fValue);\n              if (newName != null) {\n                // REPLACE IT\n                element.removeProperty(f);\n                element.setProperty(newName, fValue);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (tx && dbType == DB_TYPE.DOCUMENT) {\n      final ODatabaseDocumentTx documentDatabase = pipeline.getDocumentDatabase();\n      if (!documentDatabase.getTransaction().isActive())\n        // BEGIN THE TRANSACTION FIRST\n        documentDatabase.begin();\n    }\n\n    if (input instanceof OrientVertex) {\n      // VERTEX\n      final OrientVertex v = (OrientVertex) input;\n\n      if (clusterName != null)\n        // SAVE INTO THE CUSTOM CLUSTER\n        v.save(clusterName);\n      else\n        // SAVE INTO THE DEFAULT CLUSTER\n        v.save();\n\n    } else if (input instanceof ODocument) {\n      // DOCUMENT\n      final ODocument doc = (ODocument) input;\n\n      if (className != null)\n        doc.setClassName(className);\n\n      if (clusterName != null)\n        // SAVE INTO THE CUSTOM CLUSTER\n        doc.save(clusterName);\n      else\n        // SAVE INTO THE DEFAULT CLUSTER\n        doc.save();\n    }\n\n    progress.incrementAndGet();\n\n    if (batchCommit > 0) {\n      if (batchCounter > batchCommit) {\n        if (dbType == DB_TYPE.DOCUMENT) {\n          final ODatabaseDocumentTx documentDatabase = pipeline.getDocumentDatabase();\n          documentDatabase.commit();\n          documentDatabase.begin();\n        } else {\n          pipeline.getGraphDatabase().commit();\n        }\n        batchCounter = 0;\n      } else\n        batchCounter++;\n    }\n  }","id":31472,"modified_method":"@Override\n  public void load(final Object input, OCommandContext context) {\n    if (input == null)\n      return;\n\n    if (dbAutoCreateProperties) {\n      if (dbType == DB_TYPE.DOCUMENT) {\n        if (input instanceof ODocument) {\n          final ODocument doc = (ODocument) input;\n          final ODatabaseDocumentTx documentDatabase = pipeline.getDocumentDatabase();\n          final OClass cls;\n          if (className != null)\n            cls = getOrCreateClass(className, null);\n          else\n            cls = doc.getSchemaClass();\n\n          for (String f : doc.fieldNames()) {\n            final String newName = transformFieldName(f);\n            final String fName = newName != null ? newName : f;\n\n            OProperty p = cls.getProperty(fName);\n            if (p == null) {\n              final Object fValue = doc.field(f);\n              createProperty(cls, fName, fValue);\n              if (newName != null) {\n                // REPLACE IT\n                doc.removeField(f);\n                doc.field(newName, fValue);\n              }\n            }\n          }\n        }\n      } else if (dbType == DB_TYPE.GRAPH) {\n        if (input instanceof OrientElement) {\n          final OrientElement element = (OrientElement) input;\n\n          final OClass cls;\n          final String clsName = className != null ? className : (element instanceof OrientVertex ? element\n              .getLabel() : element.getLabel());\n          if (clsName != null)\n            cls = getOrCreateClass(clsName, element.getBaseClassName());\n          else\n            throw new IllegalArgumentException(\"No class defined on graph element: \" + input);\n\n          for (String f : element.getPropertyKeys()) {\n            final String newName = transformFieldName(f);\n            final String fName = newName != null ? newName : f;\n\n            OProperty p = cls.getProperty(fName);\n            if (p == null) {\n              final Object fValue = element.getProperty(f);\n              createProperty(cls, fName, fValue);\n              if (newName != null) {\n                // REPLACE IT\n                element.removeProperty(f);\n                element.setProperty(newName, fValue);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (tx && dbType == DB_TYPE.DOCUMENT) {\n      final ODatabaseDocumentTx documentDatabase = pipeline.getDocumentDatabase();\n      if (!documentDatabase.getTransaction().isActive())\n        // BEGIN THE TRANSACTION FIRST\n        documentDatabase.begin();\n    }\n\n    if (input instanceof OrientVertex) {\n      // VERTEX\n      final OrientVertex v = (OrientVertex) input;\n\n      if (clusterName != null)\n        // SAVE INTO THE CUSTOM CLUSTER\n        v.save(clusterName);\n      else\n        // SAVE INTO THE DEFAULT CLUSTER\n        v.save();\n\n    } else if (input instanceof ODocument) {\n      // DOCUMENT\n      final ODocument doc = (ODocument) input;\n\n      if (className != null)\n        doc.setClassName(className);\n\n      if (clusterName != null)\n        // SAVE INTO THE CUSTOM CLUSTER\n        doc.save(clusterName);\n      else\n        // SAVE INTO THE DEFAULT CLUSTER\n        doc.save();\n    }\n\n    progress.incrementAndGet();\n\n    if (batchCommit > 0) {\n      if (batchCounter > batchCommit) {\n        if (dbType == DB_TYPE.DOCUMENT) {\n          final ODatabaseDocumentTx documentDatabase = pipeline.getDocumentDatabase();\n          documentDatabase.commit();\n          documentDatabase.begin();\n        } else {\n          pipeline.getGraphDatabase().commit();\n        }\n        batchCounter = 0;\n      } else\n        batchCounter++;\n    }\n  }","commit_id":"3588d8199ec8f8a8258ff058d2617f6cff14d4da","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void run(String[] ids) throws ActionException {\n\n\t\t// Hot deploy\n\n\t\tHotDeployUtil.unregisterListeners();\n\n\t\t// Instant messenger AIM\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down AIM\");\n\n\t\t\tAIMConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Instant messenger ICQ\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down ICQ\");\n\n\t\t\tICQConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Instant messenger MSN\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down MSN\");\n\n\t\t\tMSNConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Instant messenger YM\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down YM\");\n\n\t\t\tYMConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down JCR\");\n\n\t\t\tJCRFactoryUtil.shutdown();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// POP server\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tPOPServerUtil.stop();\n\t\t}\n\n\t\t// Scheduler Engines\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.SCHEDULER,\n\t\t\tJSONUtil.serialize(\n\t\t\t\tnew SchedulerRequest(SchedulerRequest.SHUTDOWN_TYPE)));\n\n\t\t// Scheduler\n\n\t\ttry {\n\t\t\tJobSchedulerUtil.shutdown();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Reset log to default JDK 1.4 logger. This will allow WARs dependent\n\t\t// on the portal to still log events after the portal WAR has been\n\t\t// destroyed.\n\n\t\ttry {\n\t\t\tLogFactoryUtil.setLogFactory(new Jdk14LogFactoryImpl());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Programmatically exit\n\n\t\tif (GetterUtil.getBoolean(PropsUtil.get(\n\t\t\t\tPropsUtil.SHUTDOWN_PROGRAMMATICALLY_EXIT))) {\n\n\t\t\tThread thread = Thread.currentThread();\n\n\t\t\tThreadGroup threadGroup = thread.getThreadGroup();\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (threadGroup.getParent() == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthreadGroup = threadGroup.getParent();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//threadGroup.list();\n\n\t\t\tThread[] threads = new Thread[threadGroup.activeCount() * 2];\n\n\t\t\tthreadGroup.enumerate(threads);\n\n\t\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\t\tThread curThread = threads[i];\n\n\t\t\t\tif ((curThread != null) && (curThread != thread)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcurThread.interrupt();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthreadGroup.destroy();\n\t\t}\n\t}","id":31473,"modified_method":"public void run(String[] ids) throws ActionException {\n\n\t\t// Hot deploy\n\n\t\tHotDeployUtil.unregisterListeners();\n\n\t\t// Instant messenger AIM\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down AIM\");\n\n\t\t\tAIMConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Instant messenger ICQ\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down ICQ\");\n\n\t\t\tICQConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Instant messenger MSN\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down MSN\");\n\n\t\t\tMSNConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Instant messenger YM\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down YM\");\n\n\t\t\tYMConnector.disconnect();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\t_log.debug(\"Shutting down JCR\");\n\n\t\t\tJCRFactoryUtil.shutdown();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// POP server\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tPOPServerUtil.stop();\n\t\t}\n\n\t\t// Scheduler\n\n\t\ttry {\n\t\t\tJobSchedulerUtil.shutdown();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.SCHEDULER,\n\t\t\tJSONUtil.serialize(\n\t\t\t\tnew SchedulerRequest(SchedulerRequest.COMMAND_SHUTDOWN)));\n\n\t\t// Reset log to default JDK 1.4 logger. This will allow WARs dependent\n\t\t// on the portal to still log events after the portal WAR has been\n\t\t// destroyed.\n\n\t\ttry {\n\t\t\tLogFactoryUtil.setLogFactory(new Jdk14LogFactoryImpl());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\t// Programmatically exit\n\n\t\tif (GetterUtil.getBoolean(PropsUtil.get(\n\t\t\t\tPropsUtil.SHUTDOWN_PROGRAMMATICALLY_EXIT))) {\n\n\t\t\tThread thread = Thread.currentThread();\n\n\t\t\tThreadGroup threadGroup = thread.getThreadGroup();\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (threadGroup.getParent() == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthreadGroup = threadGroup.getParent();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//threadGroup.list();\n\n\t\t\tThread[] threads = new Thread[threadGroup.activeCount() * 2];\n\n\t\t\tthreadGroup.enumerate(threads);\n\n\t\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\t\tThread curThread = threads[i];\n\n\t\t\t\tif ((curThread != null) && (curThread != thread)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcurThread.interrupt();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthreadGroup.destroy();\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object _deserialize(String json) {\n\t\ttry {\n\t\t\treturn _serializer.fromJSON(json);\n\t\t}\n\t\tcatch (UnmarshallException ue) {\n\t\t\t _log.error(ue, ue);\n\n\t\t\tthrow new IllegalStateException(\"Unable to deserialize oject\", ue);\n\t\t}\n\t}","id":31474,"modified_method":"private Object _deserialize(String json) {\n\t\ttry {\n\t\t\treturn _serializer.fromJSON(json);\n\t\t}\n\t\tcatch (UnmarshallException ue) {\n\t\t\t _log.error(ue, ue);\n\n\t\t\tthrow new IllegalStateException(\"Unable to deserialize oject\", ue);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _serialize(Object obj) {\n\t\ttry {\n\t\t\treturn _serializer.toJSON(obj).toString();\n\t\t}\n\t\tcatch (MarshallException me) {\n\t\t\t_log.error(me, me);\n\n\t\t\tthrow new IllegalStateException(\"Unable to serialize oject\", me);\n\t\t}\n\t}","id":31475,"modified_method":"private String _serialize(Object obj) {\n\t\ttry {\n\t\t\treturn _serializer.toJSON(obj);\n\t\t}\n\t\tcatch (MarshallException me) {\n\t\t\t_log.error(me, me);\n\n\t\t\tthrow new IllegalStateException(\"Unable to serialize oject\", me);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void receive(String message) {\n\t\ttry {\n\t\t\tIndexWriterMessage iwm = (IndexWriterMessage)JSONUtil.deserialize(\n\t\t\t\tmessage);\n\n\t\t\tString command = iwm.getCommand();\n\n\t\t\tif (command.equals(IndexWriterMessage.ADD)) {\n\t\t\t\tLuceneSearchEngineUtil.addDocument(\n\t\t\t\t\tiwm.getCompanyId(), iwm.getDocument());\n\t\t\t}\n\t\t\telse if (command.equals(IndexWriterMessage.DELETE)) {\n\t\t\t\tLuceneSearchEngineUtil.deleteDocument(\n\t\t\t\t\tiwm.getCompanyId(), iwm.getId());\n\t\t\t}\n\t\t\telse if (command.equals(\n\t\t\t\t\t\tIndexWriterMessage.DELETE_PORTLET_DOCS)) {\n\n\t\t\t\tLuceneSearchEngineUtil.deletePortletDocuments(\n\t\t\t\t\tiwm.getCompanyId(), iwm.getId());\n\t\t\t}\n\t\t\telse if (command.equals(IndexWriterMessage.UPDATE)) {\n\t\t\t\tLuceneSearchEngineUtil.updateDocument(\n\t\t\t\t\tiwm.getCompanyId(), iwm.getId(), iwm.getDocument());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to process message \" + message, e);\n\t\t}\n\t}","id":31476,"modified_method":"public void receive(String message) {\n\t\ttry {\n\t\t\tdoReceive(message);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to process message \" + message, e);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void execute(JobExecutionContext jobExecutionContext)\n\t\tthrows JobExecutionException {\n\n\t\ttry {\n\t\t\tJobDetail detail = jobExecutionContext.getJobDetail();\n\n\t\t\tString messageBody = detail.getJobDataMap().getString(\n\t\t\t\tSchedulerEngine.MESSAGE_BODY);\n\t\t\tString destinationName = detail.getJobDataMap().getString(\n\t\t\t\tSchedulerEngine.DESTINATION_NAME);\n\n\t\t\tMessageBusUtil.sendMessage(destinationName, messageBody);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JobExecutionException(\"Unable to send message\", e);\n\t\t}\n\t}","id":31477,"modified_method":"public void execute(JobExecutionContext jobExecutionContext)\n\t\tthrows JobExecutionException {\n\n\t\ttry {\n\t\t\tJobDetail jobDetail = jobExecutionContext.getJobDetail();\n\n\t\t\tJobDataMap jobDataMap = jobDetail.getJobDataMap();\n\n\t\t\tString destination = jobDataMap.getString(\n\t\t\t\tSchedulerEngine.DESTINATION);\n\t\t\tString messageBody = jobDataMap.getString(\n\t\t\t\tSchedulerEngine.MESSAGE_BODY);\n\n\t\t\tMessageBusUtil.sendMessage(destination, messageBody);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Connection getConnection() throws SQLException {\n\t\tConnection conn = null;\n\n\t\ttry {\n\t\t\tconn = PortalJNDIUtil.getDataSource().getConnection();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn conn;\n\t}","id":31478,"modified_method":"public Connection getConnection() throws SQLException {\n\t\tConnection con = null;\n\n\t\ttry {\n\t\t\tcon = PortalJNDIUtil.getDataSource().getConnection();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn con;\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void receive(String message) {\n\t\ttry {\n\t\t\tJSONObject jsonObj = new JSONObject(message);\n\n\t\t\tString responseDestination = jsonObj.optString(\n\t\t\t\t\"lfrResponseDestination\");\n\t\t\tString responseId = jsonObj.optString(\"lfrResponseId\");\n\n\t\t\tjsonObj.remove(\"lfrResponseDestination\");\n\t\t\tjsonObj.remove(\"lfrResponseId\");\n\n\t\t\tSchedulerRequest request =\n\t\t\t\t(SchedulerRequest)_serializer.fromJSON(jsonObj.toString());\n\n\t\t\tString type = request.getType();\n\n\t\t\tif (type.equals(SchedulerRequest.REGISTER_TYPE)) {\n\t\t\t\tQuartzSchedulerEngineUtil.schedule(\n\t\t\t\t\tString.valueOf(request.hashCode()), request.getGroupName(),\n\t\t\t\t\trequest.getCronText(), request.getDestinationName(),\n\t\t\t\t\trequest.getMessageBody(), request.getStartDate(),\n\t\t\t\t\trequest.getEndDate(), request.getDescription());\n\t\t\t}\n\t\t\telse if (type.equals(SchedulerRequest.RETRIEVE_TYPE)) {\n\t\t\t\tCollection<SchedulerRequest> requests =\n\t\t\t\t\tQuartzSchedulerEngineUtil.retrieveScheduledJobs(\n\t\t\t\t\t\trequest.getGroupName());\n\n\t\t\t\tJSONObject jsonObject = new JSONObject();\n\t\t\t\tjsonObject.put(\"lfrResponseId\", responseId);\n\t\t\t\tjsonObject.put(\"requests\", _serializer.toJSON(requests));\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tresponseDestination, jsonObject.toString());\n\t\t\t}\n\t\t\telse if (type.equals(SchedulerRequest.SHUTDOWN_TYPE)) {\n\t\t\t\tQuartzSchedulerEngineUtil.shutdown();\n\t\t\t}\n\t\t\telse if (type.equals(SchedulerRequest.UNREGISTER_TYPE)) {\n\t\t\t\tQuartzSchedulerEngineUtil.unschedule(\n\t\t\t\t\trequest.getJobName(), request.getGroupName());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":31479,"modified_method":"public void receive(String message) {\n\t\ttry {\n\t\t\tdoReceive(message);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to process message \" + message, e);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void schedule(\n\t\t\tString jobName, String groupName, String cronText,\n\t\t\tString destinationName, String messageBody, Date startDate,\n\t\t\tDate endDate, String description)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\tCronTrigger trigger = new CronTrigger(jobName, groupName, cronText);\n\n\t\t\tif (startDate != null) {\n\t\t\t\ttrigger.setStartTime(startDate);\n\t\t\t}\n\n\t\t\tif (endDate != null) {\n\t\t\t\ttrigger.setEndTime(endDate);\n\t\t\t}\n\n\t\t\tJobDetail detail = new JobDetail(\n\t\t\t\tjobName, groupName, MessageSenderJob.class);\n\n\t\t\tdetail.getJobDataMap().put(DESCRIPTION, description);\n\t\t\tdetail.getJobDataMap().put(DESTINATION_NAME, destinationName);\n\t\t\tdetail.getJobDataMap().put(MESSAGE_BODY, messageBody);\n\n\t\t\t_scheduler.scheduleJob(detail, trigger);\n\t\t}\n\t\tcatch (ObjectAlreadyExistsException oare) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Message is already scheduled\");\n\t\t\t}\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tthrow new SchedulerException(\"Unable to parse cron text\", pe);\n\t\t}\n\t\tcatch (org.quartz.SchedulerException se) {\n\t\t\tthrow new SchedulerException(\"Unable to scheduled job\", se);\n\t\t}\n\t}","id":31480,"modified_method":"public void schedule(\n\t\t\tString jobName, String groupName, String cronText, Date startDate,\n\t\t\tDate endDate, String description, String destination,\n\t\t\tString messageBody)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\tCronTrigger cronTrigger = new CronTrigger(\n\t\t\t\tjobName, groupName, cronText);\n\n\t\t\tif (startDate != null) {\n\t\t\t\tcronTrigger.setStartTime(startDate);\n\t\t\t}\n\n\t\t\tif (endDate != null) {\n\t\t\t\tcronTrigger.setEndTime(endDate);\n\t\t\t}\n\n\t\t\tJobDetail jobDetail = new JobDetail(\n\t\t\t\tjobName, groupName, MessageSenderJob.class);\n\n\t\t\tJobDataMap jobDataMap = jobDetail.getJobDataMap();\n\n\t\t\tjobDataMap.put(DESCRIPTION, description);\n\t\t\tjobDataMap.put(DESTINATION, destination);\n\t\t\tjobDataMap.put(MESSAGE_BODY, messageBody);\n\n\t\t\t_scheduler.scheduleJob(jobDetail, cronTrigger);\n\t\t}\n\t\tcatch (ObjectAlreadyExistsException oare) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Message is already scheduled\");\n\t\t\t}\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tthrow new SchedulerException(\"Unable to parse cron text\", pe);\n\t\t}\n\t\tcatch (org.quartz.SchedulerException se) {\n\t\t\tthrow new SchedulerException(\"Unable to scheduled job\", se);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void unschedule(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\t_scheduler.unscheduleJob(jobName, groupName);\n\t\t}\n\t\tcatch (org.quartz.SchedulerException se) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to unschedule job: \" + jobName + \",\" + groupName , se);\n\t\t}\n\t}","id":31481,"modified_method":"public void unschedule(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\t_scheduler.unscheduleJob(jobName, groupName);\n\t\t}\n\t\tcatch (org.quartz.SchedulerException se) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to unschedule job {jobName=\" + jobName +\n\t\t\t\t\t\", groupName=\" + groupName + \"}\",\n\t\t\t\tse);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public QuartzSchedulerEngineImpl() {\n\t\ttry {\n\t\t\t// Message Bus registration\n\t\t\tDestination destination = new SerialDestination(\n\t\t\t\tDestinationNames.SCHEDULER);\n\n\t\t\tMessageBusUtil.addDestination(destination);\n\n\t\t\tMessageBusUtil.registerMessageListener(\n\t\t\t\tdestination.getName(), new QuartzMessageListener());\n\n\t\t\t// Quartz properties\n\n\t\t\tProperties props = new Properties();\n\n\t\t\tprops.put(\n\t\t\t\tStdSchedulerFactory.PROP_SCHED_INSTANCE_ID,\n\t\t\t\tStdSchedulerFactory.AUTO_GENERATE_INSTANCE_ID);\n\t\t\tprops.put(\n\t\t\t\tStdSchedulerFactory.PROP_THREAD_POOL_CLASS,\n\t\t\t\tPropsUtil.get(PropsUtil.QUARTZ_THREAD_POOL_CLASS));\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.threadPool.threadCount\",\n\t\t\t\tPropsUtil.get(PropsUtil.QUARTZ_THREAD_POOL_COUNT));\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.threadPool.threadPriority\",\n\t\t\t\tPropsUtil.get(PropsUtil.QUARTZ_THREAD_POOL_PRIORITY));\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.jobStore.misfireThreshold\",\n\t\t\t\tPropsUtil.get(PropsUtil.QUARTZ_JOBSTORE_MISFIRE_THRESHOLD));\n\t\t\tprops.put(\n\t\t\t\tStdSchedulerFactory.PROP_JOB_STORE_CLASS,\n\t\t\t\tPropsUtil.get(PropsUtil.QUARTZ_JOBSTORE_CLASS));\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.jobStore.isClustered\",\n\t\t\t\tPropsUtil.get(PropsUtil.QUARTZ_JOBSTORE_CLUSTERED));\n\t\t\tprops.put(\n\t\t\t\tStdSchedulerFactory.PROP_JOB_STORE_USE_PROP, \"true\");\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.jobStore.dataSource\", \"ds\");\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.dataSource.ds.connectionProvider.class\",\n\t\t\t\tQuartzConnectionProviderImpl.class.getName());\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.jobStore.tablePrefix\", \"quartz_\");\n\t\t\tprops.put(\n\t\t\t\t\"org.quartz.jobStore.driverDelegateClass\",\n\t\t\t\tgetDriverDelegateClass());\n\n\t\t\tStdSchedulerFactory factory = new StdSchedulerFactory();\n\n\t\t\tfactory.initialize(props);\n\n\t\t\t_scheduler = factory.getScheduler();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to initialize engine\", e);\n\t\t}\n\t}","id":31482,"modified_method":"public QuartzSchedulerEngineImpl() {\n\t\ttry {\n\t\t\tDestination destination = new SerialDestination(\n\t\t\t\tDestinationNames.SCHEDULER);\n\n\t\t\tMessageBusUtil.addDestination(destination);\n\n\t\t\tMessageBusUtil.registerMessageListener(\n\t\t\t\tdestination.getName(), new QuartzMessageListener());\n\n\t\t\tProperties props = new Properties();\n\n\t\t\tEnumeration<Object> enu = PropsUtil.getProperties().keys();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString key = (String)enu.nextElement();\n\n\t\t\t\tif (key.startsWith(\"org.quartz.\")) {\n\t\t\t\t\tprops.setProperty(key, PropsUtil.get(key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStdSchedulerFactory schedulerFactory = new StdSchedulerFactory();\n\n\t\t\tschedulerFactory.initialize(props);\n\n\t\t\t_scheduler = schedulerFactory.getScheduler();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to initialize engine\", e);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Collection<SchedulerRequest> retrieveScheduledJobs(String groupName)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\tString names[] = _scheduler.getJobNames(groupName);\n\n\t\t\tList<SchedulerRequest> requests =\n\t\t\t\tnew ArrayList<SchedulerRequest>();\n\n\t\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\t\tJobDetail detail = _scheduler.getJobDetail(names[i], groupName);\n\n\t\t\t\tString description = detail.getJobDataMap().getString(\n\t\t\t\t\tSchedulerEngine.DESCRIPTION);\n\t\t\t\tString messageBody = detail.getJobDataMap().getString(\n\t\t\t\t\tSchedulerEngine.MESSAGE_BODY);\n\n\t\t\t\tCronTrigger trigger = (CronTrigger)_scheduler.getTrigger(\n\t\t\t\t\tnames[i], groupName);\n\n\t\t\t\tSchedulerRequest sr = new SchedulerRequest(\n\t\t\t\t\ttrigger.getCronExpression(), groupName, names[i],\n\t\t\t\t\tmessageBody, trigger.getStartTime(), trigger.getEndTime(),\n\t\t\t\t\tdescription);\n\n\t\t\t\trequests.add(sr);\n\t\t\t}\n\n\t\t\treturn requests;\n\t\t}\n\t\tcatch (org.quartz.SchedulerException se) {\n\t\t\tthrow new SchedulerException(\"Unable to retrieve job\", se);\n\t\t}\n\t}","id":31483,"modified_method":"public Collection<SchedulerRequest> getScheduledJobs(String groupName)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\tString[] jobNames = _scheduler.getJobNames(groupName);\n\n\t\t\tList<SchedulerRequest> requests = new ArrayList<SchedulerRequest>();\n\n\t\t\tfor (String jobName : jobNames) {\n\t\t\t\tJobDetail jobDetail = _scheduler.getJobDetail(\n\t\t\t\t\tjobName, groupName);\n\n\t\t\t\tJobDataMap jobDataMap = jobDetail.getJobDataMap();\n\n\t\t\t\tString description = jobDataMap.getString(DESCRIPTION);\n\t\t\t\tString messageBody = jobDataMap.getString(MESSAGE_BODY);\n\n\t\t\t\tCronTrigger cronTrigger = (CronTrigger)_scheduler.getTrigger(\n\t\t\t\t\tjobName, groupName);\n\n\t\t\t\tSchedulerRequest schedulerRequest = new SchedulerRequest(\n\t\t\t\t\tnull, jobName, groupName, cronTrigger.getCronExpression(),\n\t\t\t\t\tcronTrigger.getStartTime(), cronTrigger.getEndTime(),\n\t\t\t\t\tdescription, null, messageBody);\n\n\t\t\t\trequests.add(schedulerRequest);\n\t\t\t}\n\n\t\t\treturn requests;\n\t\t}\n\t\tcatch (org.quartz.SchedulerException se) {\n\t\t\tthrow new SchedulerException(\"Unable to retrieve job\", se);\n\t\t}\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Collection<SchedulerRequest> retrieveScheduledJobs(\n\t\t\tString groupName)\n\t\tthrows SchedulerException {\n\n\t\treturn _engine.retrieveScheduledJobs(groupName);\n\t}","id":31484,"modified_method":"public static Collection<SchedulerRequest> getScheduledJobs(\n\t\t\tString groupName)\n\t\tthrows SchedulerException {\n\n\t\treturn _engine.getScheduledJobs(groupName);\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void schedule(\n\t\t\tString jobName, String groupName, String cronText,\n\t\t\tString destinationName, String messageBody, Date startDate,\n\t\t\tDate endDate, String description)\n\t\tthrows SchedulerException {\n\n\t\t_engine.schedule(\n\t\t\tjobName, groupName, cronText, destinationName, messageBody,\n\t\t\tstartDate, endDate, description);\n\t}","id":31485,"modified_method":"public static void schedule(\n\t\t\tString jobName, String groupName, String cronText,\n\t\t\tDate startDate, Date endDate, String description,\n\t\t\tString destination, String messageBody)\n\t\tthrows SchedulerException {\n\n\t\t_engine.schedule(\n\t\t\tjobName, groupName, cronText, startDate, endDate, description,\n\t\t\tdestination, messageBody);\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SchedulerException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}","id":31486,"modified_method":"public SchedulerException(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SchedulerException(String message) {\n\t\tsuper(message);\n\t}","id":31487,"modified_method":"public SchedulerException(String msg) {\n\t\tsuper(msg);\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getDestinationName() {\n\t\treturn _destinationName;\n\t}","id":31488,"modified_method":"public String getDestination() {\n\t\treturn _destination;\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SchedulerRequest(String type) {\n\t\tthis(null, type);\n\t}","id":31489,"modified_method":"public SchedulerRequest(String command) {\n\t\tthis(command, null, null, null, null, null, null, null, null);\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SchedulerRequest(\n\t\tString cronText, String destinationName, String groupName,\n\t\tString messageBody, Date startDate, Date endDate, String type) {\n\n\t\tthis(\n\t\t\tcronText, destinationName, groupName, null, messageBody, startDate,\n\t\t\tendDate, type);\n\t}","id":31490,"modified_method":"public SchedulerRequest(\n\t\tString command, String jobName, String groupName, String cronText,\n\t\tDate startDate, Date endDate, String description, String destination,\n\t\tString messageBody) {\n\n\t\t_command = command;\n\t\t_jobName = jobName;\n\t\t_groupName = groupName;\n\t\t_cronText = cronText;\n\t\t_startDate = startDate;\n\t\t_endDate = endDate;\n\t\t_description = description;\n\t\t_destination = destination;\n\t\t_messageBody = messageBody;\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setDestinationName(String destinationName) {\n\t\t_destinationName = destinationName;\n\t}","id":31491,"modified_method":"public void setDestination(String destination) {\n\t\t_destination = destination;\n\t}","commit_id":"86d91a3f2d6a489b8605a03ab0a1a4ebaea54d4a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void appendToResponse(ERXRestRequestNode node, IERXRestResponse response, ERXRestFormat.Delegate delegate, ERXRestContext context) {\n\t\tnode = processNode(node);\n\t\tif (node != null) {\n\t\t\tnode._removeRedundantTypes();\n\t\t}\n\t\t\n\t\tappendHeadersToResponse(node, response, context);\n\t\tObject object = node.toJavaCollection(delegate);\n\t\tif (object == null) {\n\t\t\tresponse.appendContentString(\"undefined\");\n\t\t}\n\t\telse if (ERXRestUtils.isPrimitive(object)) {\n\t\t\tresponse.appendContentString(String.valueOf(object));\n\t\t}\n\t\telse {\n\t\t\tresponse.appendContentString(JSONSerializer.toJSON(object, configWithContext(context)).toString());\n\t\t}\n\t\tresponse.appendContentString(\"\\n\");\n\t}","id":31492,"modified_method":"public void appendToResponse(ERXRestRequestNode node, IERXRestResponse response, ERXRestFormat.Delegate delegate, ERXRestContext context) {\n\t\tnode = processNode(node);\n\t\tif (node != null) {\n\t\t\tnode._removeRedundantTypes();\n\t\t}\n\t\t\n\t\tappendHeadersToResponse(node, response, context);\n\t\tObject object = node.toJavaCollection(delegate);\n\t\tif (object == null) {\n\t\t\tresponse.appendContentString(\"undefined\");\n\t\t}\n\t\telse if (ERXRestUtils.isPrimitive(object)) {\n\t\t\tresponse.appendContentString(String.valueOf(object));\n\t\t}\n\t\telse {\n\t\t\tJSON jsonObject = JSONSerializer.toJSON(object, configWithContext(context));\n\t\t\tString json = (CONSTANTS.SHOULD_PRETTY_PRINT ? jsonObject.toString(CONSTANTS.PRETTY_PRINT_INDENT) : jsonObject.toString());\n\t\t\tresponse.appendContentString(json);\n\t\t}\n\t\tresponse.appendContentString(\"\\n\");\n\t}","commit_id":"5deaf865a46351e0465873564efa82065906c658","url":"https://github.com/wocommunity/wonder"},{"original_method":"public RepositoryCacheManager getRepositoryCacheManager() {\n        return new DefaultRepositoryCacheManager();\n    }","id":31493,"modified_method":"public RepositoryCacheManager getRepositoryCacheManager() {\n        return new NoOpRepositoryCacheManager(getName());\n    }","commit_id":"107df2e24b11586a678eafee2019acd38c9bfb71","url":"https://github.com/gradle/gradle"},{"original_method":"private void initializeResolvers(IvySettings ivySettings, List<DependencyResolver> allResolvers) {\n        for (DependencyResolver dependencyResolver : allResolvers) {\n            ivySettings.addResolver(dependencyResolver);\n            if (dependencyResolver.getRepositoryCacheManager() instanceof DefaultRepositoryCacheManager) {\n                ((DefaultRepositoryCacheManager) dependencyResolver.getRepositoryCacheManager()).setSettings(ivySettings);\n            }\n            if (dependencyResolver instanceof RepositoryResolver) {\n                Repository repository = ((RepositoryResolver) dependencyResolver).getRepository();\n                if (!repository.hasTransferListener(transferListener)) {\n                    repository.addTransferListener(transferListener);\n                }\n            }\n        }\n    }","id":31494,"modified_method":"private void initializeResolvers(IvySettings ivySettings, List<DependencyResolver> allResolvers) {\n        for (DependencyResolver dependencyResolver : allResolvers) {\n            ivySettings.addResolver(dependencyResolver);\n            RepositoryCacheManager cacheManager = dependencyResolver.getRepositoryCacheManager();\n            // Validate that each resolver is sharing the same cache instance (ignoring caches which don't actually cache anything)\n            if (cacheManager != ivySettings.getDefaultRepositoryCacheManager()\n                    && !(cacheManager instanceof NoOpRepositoryCacheManager)\n                    && !(cacheManager instanceof LocalFileRepositoryCacheManager)) {\n                throw new IllegalStateException(String.format(\"Unexpected cache manager %s for repository %s (%s)\", cacheManager, dependencyResolver.getName(), dependencyResolver));\n            }\n            if (dependencyResolver instanceof RepositoryResolver) {\n                Repository repository = ((RepositoryResolver) dependencyResolver).getRepository();\n                if (!repository.hasTransferListener(transferListener)) {\n                    repository.addTransferListener(transferListener);\n                }\n            }\n        }\n    }","commit_id":"107df2e24b11586a678eafee2019acd38c9bfb71","url":"https://github.com/gradle/gradle"},{"original_method":"protected SettingsConverter createSettingsConverter() {\n        return new DefaultSettingsConverter(\n                get(ProgressLoggerFactory.class),\n                new IvySettingsFactory(\n                        get(ArtifactCacheMetaData.class),\n                        get(LockHolderFactory.class)),\n                get(ModuleResolutionCache.class));\n    }","id":31495,"modified_method":"protected SettingsConverter createSettingsConverter() {\n        return new DefaultSettingsConverter(\n                get(ProgressLoggerFactory.class),\n                new IvySettingsFactory(\n                        get(ArtifactCacheMetaData.class),\n                        get(LockHolderFactory.class)),\n                get(ModuleResolutionCache.class),\n                get(ModuleDescriptorCache.class));\n    }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"private UserResolverChain createUserResolverChain() {\n        UserResolverChain chainResolver = new UserResolverChain(moduleResolutionCache);\n        chainResolver.setName(USER_RESOLVER_CHAIN_NAME);\n        chainResolver.setReturnFirst(true);\n        chainResolver.setRepositoryCacheManager(new NoOpRepositoryCacheManager(chainResolver.getName()));\n        return chainResolver;\n    }","id":31496,"modified_method":"private UserResolverChain createUserResolverChain() {\n        UserResolverChain chainResolver = new UserResolverChain(moduleResolutionCache, moduleDescriptorCache);\n        chainResolver.setName(USER_RESOLVER_CHAIN_NAME);\n        chainResolver.setReturnFirst(true);\n        chainResolver.setRepositoryCacheManager(new NoOpRepositoryCacheManager(chainResolver.getName()));\n        return chainResolver;\n    }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"public IvySettings convertForResolve(List<DependencyResolver> dependencyResolvers, ResolutionStrategyInternal resolutionStrategy) {\n        if (resolveSettings == null) {\n            resolveSettings = settingsFactory.create();\n            userResolverChain = createUserResolverChain();\n            resolveSettings.addResolver(userResolverChain);\n            resolveSettings.setDefaultResolver(USER_RESOLVER_CHAIN_NAME);\n        }\n        \n        userResolverChain.setCachePolicy(resolutionStrategy.getCachePolicy());\n        replaceResolvers(dependencyResolvers, userResolverChain);\n        return resolveSettings;\n    }","id":31497,"modified_method":"public IvySettings convertForResolve(List<DependencyResolver> dependencyResolvers, ResolutionStrategyInternal resolutionStrategy) {\n        if (resolveSettings == null) {\n            resolveSettings = settingsFactory.create();\n            userResolverChain = createUserResolverChain();\n            resolveSettings.addResolver(userResolverChain);\n            resolveSettings.setDefaultResolver(USER_RESOLVER_CHAIN_NAME);\n        }\n\n        ((IvySettingsAware) moduleDescriptorCache).setSettings(resolveSettings);\n        userResolverChain.setCachePolicy(resolutionStrategy.getCachePolicy());\n        replaceResolvers(dependencyResolvers, userResolverChain);\n        return resolveSettings;\n    }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultSettingsConverter(ProgressLoggerFactory progressLoggerFactory, Factory<IvySettings> settingsFactory,\n                                    ModuleResolutionCache moduleResolutionCache) {\n        this.progressLoggerFactory = progressLoggerFactory;\n        this.settingsFactory = settingsFactory;\n        this.moduleResolutionCache = moduleResolutionCache;\n        Message.setDefaultLogger(new IvyLoggingAdaper());\n    }","id":31498,"modified_method":"public DefaultSettingsConverter(ProgressLoggerFactory progressLoggerFactory, Factory<IvySettings> settingsFactory,\n                                    ModuleResolutionCache moduleResolutionCache, ModuleDescriptorCache moduleDescriptorCache) {\n        this.progressLoggerFactory = progressLoggerFactory;\n        this.settingsFactory = settingsFactory;\n        this.moduleResolutionCache = moduleResolutionCache;\n        this.moduleDescriptorCache = moduleDescriptorCache;\n        Message.setDefaultLogger(new IvyLoggingAdaper());\n    }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"public UserResolverChain(ModuleResolutionCache moduleResolutionCache) {\n        dynamicRevisions = new DynamicRevisionDependencyConverter(moduleResolutionCache);\n    }","id":31499,"modified_method":"public UserResolverChain(ModuleResolutionCache moduleResolutionCache, ModuleDescriptorCache moduleDescriptorCache) {\n        dynamicRevisions = new DynamicRevisionDependencyConverter(moduleResolutionCache);\n        this.moduleDescriptorCache = moduleDescriptorCache;\n    }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"public void lookupModuleInCache() {\n            resolvedDescriptor = dynamicRevisions.maybeResolveDynamicRevision(resolver, descriptor);\n            resolvedModule = findModuleInCache(resolver, resolvedDescriptor, resolveData);\n        }","id":31500,"modified_method":"public void lookupModuleInCache() {\n            resolvedDescriptor = dynamicRevisions.maybeResolveDynamicRevision(resolver, dependencyDescriptor);\n            resolvedModule = findModuleInCache(resolver, resolvedDescriptor, resolveData);\n        }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleResolution(DependencyResolver resolver, DependencyDescriptor moduleDescriptor, ResolveData resolveData, boolean staticVersion) {\n            this.resolver = resolver;\n            this.descriptor = moduleDescriptor;\n            this.resolveData = resolveData;\n            this.staticVersion = staticVersion;\n        }","id":31501,"modified_method":"public ModuleResolution(DependencyResolver resolver, DependencyDescriptor moduleDescriptor, ResolveData resolveData, boolean staticVersion) {\n            this.resolver = resolver;\n            this.dependencyDescriptor = moduleDescriptor;\n            this.resolveData = resolveData;\n            this.staticVersion = staticVersion;\n        }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"private ResolvedModuleRevision findModuleInCache(DependencyResolver resolver, DependencyDescriptor dd, ResolveData resolveData) {\n            CacheMetadataOptions cacheOptions = getCacheMetadataOptions(resolver, resolveData);\n            return resolver.getRepositoryCacheManager().findModuleInCache(dd, dd.getDependencyRevisionId(), cacheOptions, resolver.getName());\n        }","id":31502,"modified_method":"private ResolvedModuleRevision findModuleInCache(DependencyResolver resolver, DependencyDescriptor dd, ResolveData resolveData) {\n            // TODO:DAZ remove isChanging check when we use ModuleDescriptorCache for tracking changing modules\n            if (resolver.getRepositoryCacheManager() instanceof LocalFileRepositoryCacheManager || dd.isChanging()) {\n                return null;\n            }\n            \n            // TODO:DAZ Move changing module timeout to here\n            // TODO:DAZ Cache non-existence of module in resolver...\n            ModuleDescriptorCache.CachedModuleDescriptor cachedModuleDescriptor = moduleDescriptorCache.getCachedModuleDescriptor(resolver, dd.getDependencyRevisionId());\n            if (cachedModuleDescriptor == null) {\n                return null;\n            }\n\n            return new ResolvedModuleRevision(resolver, resolver, cachedModuleDescriptor.getModule(), null);\n        }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolveModule() {\n            try {\n                // TODO:DAZ This should take the resolved descriptor, but this means that local repositories use cached dynamic version resolution\n                // Need to ensure that no caching is performed for local repositories before we make the switch\n                resolvedModule = resolver.getDependency(descriptor, resolveData);\n                dynamicRevisions.maybeSaveDynamicRevision(descriptor, resolvedModule);\n            } catch (ParseException e) {\n                throw new RuntimeException(e);\n            }\n        }","id":31503,"modified_method":"public void resolveModule() {\n            try {\n                // TODO:DAZ This should take the resolved descriptor, but this means that local repositories use cached dynamic version resolution\n                // Need to ensure that no caching is performed for local repositories before we make the switch\n                resolvedModule = resolver.getDependency(dependencyDescriptor, resolveData);\n                dynamicRevisions.maybeSaveDynamicRevision(dependencyDescriptor, resolvedModule);\n\n                // TODO:DAZ Set changing flag correctly\n                // TODO:DAZ Record missing module\n                if (resolvedModule != null) {\n                    moduleDescriptorCache.cacheModuleDescriptor(resolver, resolvedModule.getDescriptor(), false);\n                }\n            } catch (ParseException e) {\n                throw new RuntimeException(e);\n            }\n        }","commit_id":"0a3299879859c24716cef2b47e5437c149ce075c","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactRepository createRepository(Object userDescription) {\n        if (userDescription instanceof ArtifactRepository) {\n            return (ArtifactRepository) userDescription;\n        }\n\n        if (userDescription instanceof String) {\n            MavenArtifactRepository repository = createMavenRepository();\n            repository.setUrl(userDescription);\n            return repository;\n        } else if (userDescription instanceof Map) {\n            Map<String, ?> userDescriptionMap = (Map<String, ?>) userDescription;\n            MavenArtifactRepository repository = createMavenRepository();\n            ConfigureUtil.configureByMap(userDescriptionMap, repository);\n            return repository;\n        }\n\n        DependencyResolver result;\n        if (userDescription instanceof DependencyResolver) {\n            result = (DependencyResolver) userDescription;\n        } else {\n            throw new InvalidUserDataException(String.format(\"Cannot create a DependencyResolver instance from %s\", userDescription));\n        }\n        return new CustomResolverArtifactRepository(result, progressLoggerFactory, localCacheManager, downloadingCacheManager);\n    }","id":31504,"modified_method":"public ArtifactRepository createRepository(Object userDescription) {\n        if (userDescription instanceof ArtifactRepository) {\n            return (ArtifactRepository) userDescription;\n        }\n\n        if (userDescription instanceof String) {\n            MavenArtifactRepository repository = createMavenRepository();\n            repository.setUrl(userDescription);\n            return repository;\n        } else if (userDescription instanceof Map) {\n            Map<String, ?> userDescriptionMap = (Map<String, ?>) userDescription;\n            MavenArtifactRepository repository = createMavenRepository();\n            ConfigureUtil.configureByMap(userDescriptionMap, repository);\n            return repository;\n        }\n\n        if (userDescription instanceof DependencyResolver) {\n            return legacyDependencyResolverRepositoryFactory.createRepository((DependencyResolver) userDescription);\n        }\n        throw new InvalidUserDataException(String.format(\"Cannot create a DependencyResolver instance from %s\", userDescription));\n    }","commit_id":"c40aa498a92400d7655fc485dff8eaaec7bf06c0","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultBaseRepositoryFactory(LocalMavenRepositoryLocator localMavenRepositoryLocator,\n                                        FileResolver fileResolver,\n                                        Instantiator instantiator,\n                                        RepositoryTransportFactory transportFactory,\n                                        LocallyAvailableResourceFinder<ArtifactRevisionId> locallyAvailableResourceFinder,\n                                        ProgressLoggerFactory progressLoggerFactory,\n                                        RepositoryCacheManager localCacheManager,\n                                        RepositoryCacheManager downloadingCacheManager,\n                                        MetaDataParser metaDataParser,\n                                        ModuleMetadataProcessor metadataProcessor) {\n        this.localMavenRepositoryLocator = localMavenRepositoryLocator;\n        this.fileResolver = fileResolver;\n        this.instantiator = instantiator;\n        this.transportFactory = transportFactory;\n        this.locallyAvailableResourceFinder = locallyAvailableResourceFinder;\n        this.progressLoggerFactory = progressLoggerFactory;\n        this.localCacheManager = localCacheManager;\n        this.downloadingCacheManager = downloadingCacheManager;\n        this.metaDataParser = metaDataParser;\n        this.metadataProcessor = metadataProcessor;\n    }","id":31505,"modified_method":"public DefaultBaseRepositoryFactory(LocalMavenRepositoryLocator localMavenRepositoryLocator,\n                                        FileResolver fileResolver,\n                                        Instantiator instantiator,\n                                        RepositoryTransportFactory transportFactory,\n                                        LocallyAvailableResourceFinder<ArtifactRevisionId> locallyAvailableResourceFinder,\n                                        MetaDataParser metaDataParser,\n                                        ModuleMetadataProcessor metadataProcessor,\n                                        LegacyDependencyResolverRepositoryFactory legacyDependencyResolverRepositoryFactory) {\n        this.localMavenRepositoryLocator = localMavenRepositoryLocator;\n        this.fileResolver = fileResolver;\n        this.instantiator = instantiator;\n        this.transportFactory = transportFactory;\n        this.locallyAvailableResourceFinder = locallyAvailableResourceFinder;\n        this.metaDataParser = metaDataParser;\n        this.metadataProcessor = metadataProcessor;\n        this.legacyDependencyResolverRepositoryFactory = legacyDependencyResolverRepositoryFactory;\n    }","commit_id":"c40aa498a92400d7655fc485dff8eaaec7bf06c0","url":"https://github.com/gradle/gradle"},{"original_method":"public BaseRepositoryFactory getBaseRepositoryFactory() {\n            if (baseRepositoryFactory == null) {\n                Instantiator instantiator = parent.get(Instantiator.class);\n                //noinspection unchecked\n                baseRepositoryFactory = new DefaultBaseRepositoryFactory(\n                        get(LocalMavenRepositoryLocator.class),\n                        fileResolver,\n                        instantiator,\n                        get(RepositoryTransportFactory.class),\n                        get(LocallyAvailableResourceFinder.class),\n                        get(ProgressLoggerFactory.class),\n                        get(LocalFileRepositoryCacheManager.class),\n                        get(DownloadingRepositoryCacheManager.class),\n                        new DefaultMetaDataParser(new ParserRegistry()),\n                        getComponentMetadataHandler()\n                );\n            }\n\n            return baseRepositoryFactory;\n        }","id":31506,"modified_method":"public BaseRepositoryFactory getBaseRepositoryFactory() {\n            if (baseRepositoryFactory == null) {\n                Instantiator instantiator = parent.get(Instantiator.class);\n                //noinspection unchecked\n                baseRepositoryFactory = new DefaultBaseRepositoryFactory(\n                        get(LocalMavenRepositoryLocator.class),\n                        fileResolver,\n                        instantiator,\n                        get(RepositoryTransportFactory.class),\n                        get(LocallyAvailableResourceFinder.class),\n                        new DefaultMetaDataParser(new ParserRegistry()),\n                        getComponentMetadataHandler(),\n                        get(LegacyDependencyResolverRepositoryFactory.class)\n                );\n            }\n\n            return baseRepositoryFactory;\n        }","commit_id":"c40aa498a92400d7655fc485dff8eaaec7bf06c0","url":"https://github.com/gradle/gradle"},{"original_method":"protected LocalFileRepositoryCacheManager createLocalRepositoryCacheManager() {\n        return new LocalFileRepositoryCacheManager(\"local\");\n    }","id":31507,"modified_method":"protected LocalFileRepositoryArtifactCache createLocalRepositoryArtifactCache() {\n        return new LocalFileRepositoryArtifactCache();\n    }","commit_id":"c40aa498a92400d7655fc485dff8eaaec7bf06c0","url":"https://github.com/gradle/gradle"},{"original_method":"protected DownloadingRepositoryCacheManager createDownloadingRepositoryCacheManager() {\n        return new DownloadingRepositoryCacheManager(\"downloading\", get(ArtifactRevisionIdFileStore.class), get(ByUrlCachedExternalResourceIndex.class),\n                new TmpDirTemporaryFileProvider(), get(CacheLockingManager.class));\n    }","id":31508,"modified_method":"protected DownloadingRepositoryArtifactCache createDownloadingRepositoryArtifactCache() {\n        return new DownloadingRepositoryArtifactCache(get(ArtifactRevisionIdFileStore.class), get(ByUrlCachedExternalResourceIndex.class),\n                new TmpDirTemporaryFileProvider(), get(CacheLockingManager.class));\n    }","commit_id":"c40aa498a92400d7655fc485dff8eaaec7bf06c0","url":"https://github.com/gradle/gradle"},{"original_method":"protected RepositoryTransportFactory createRepositoryTransportFactory() {\n        return new RepositoryTransportFactory(\n                get(ProgressLoggerFactory.class),\n                get(LocalFileRepositoryCacheManager.class),\n                get(DownloadingRepositoryCacheManager.class),\n                new TmpDirTemporaryFileProvider(),\n                get(ByUrlCachedExternalResourceIndex.class)\n        );\n    }","id":31509,"modified_method":"protected RepositoryTransportFactory createRepositoryTransportFactory() {\n        return new RepositoryTransportFactory(\n                get(ProgressLoggerFactory.class),\n                get(LocalFileRepositoryArtifactCache.class),\n                get(DownloadingRepositoryArtifactCache.class),\n                new TmpDirTemporaryFileProvider(),\n                get(ByUrlCachedExternalResourceIndex.class)\n        );\n    }","commit_id":"c40aa498a92400d7655fc485dff8eaaec7bf06c0","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean isLocal() {\n        return ((RepositoryArtifactCache) resolver.getRepositoryCacheManager()).isLocal();\n    }","id":31510,"modified_method":"public boolean isLocal() {\n        return resolver.getRepositoryCacheManager() instanceof LocalFileRepositoryCacheManager;\n    }","commit_id":"c40aa498a92400d7655fc485dff8eaaec7bf06c0","url":"https://github.com/gradle/gradle"},{"original_method":"protected void maybeSendAnnouncement() {\n\t\tsynchronized(this) {\n\t\t\tif(!started) return;\n\t\t}\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"maybeSendAnnouncement()\");\n\t\tlong now = System.currentTimeMillis();\n\t\tif(!node.isOpennetEnabled()) return;\n\t\tif(enoughPeers()) {\n\t\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tint running;\n\t\t\t\t\tsynchronized(Announcer.this) {\n\t\t\t\t\t\trunning = runningAnnouncements;\n\t\t\t\t\t}\n\t\t\t\t\tif(enoughPeers()) {\n\t\t\t\t\t\tfor(SeedServerPeerNode pn : node.peers.getConnectedSeedServerPeersVector(null)) {\n\t\t\t\t\t\t\tnode.peers.disconnect(pn, true, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Re-check every minute. Something bad might happen (e.g. cpu starvation), causing us to have to reseed.\n\t\t\t\t\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tmaybeSendAnnouncement();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, RETRY_DELAY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tmaybeSendAnnouncement();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, RETRY_DELAY);\n\t\t\t\t\t\tif(running != 0)\n\t\t\t\t\t\t\tmaybeSendAnnouncement();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, FINAL_DELAY);\n\t\t\treturn;\n\t\t}\n\t\tif((!ignoreIPUndetected) && (!node.ipDetector.hasValidIP())) {\n\t\t\tif(node.ipDetector.ipDetectorManager.hasDetectors()) {\n\t\t\t\tif(now - toldUserNoIP > 60*1000)\n\t\t\t\t\tSystem.out.println(\"Don't know our IP address, waiting for another 2 minutes...\");\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tdontKnowOurIPAddress = true;\n\t\t\t\t}\n\t\t\t\t// Wait a bit\n\t\t\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tsynchronized(Announcer.this) {\n\t\t\t\t\t\t\tif(ignoreIPUndetected) return;\n\t\t\t\t\t\t\tignoreIPUndetected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaybeSendAnnouncement();\n\t\t\t\t\t}\n\t\t\t\t}, FORCE_ANNOUNCEMENT_NO_IP);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsynchronized(this) {\n\t\t\tdontKnowOurIPAddress = false;\n\t\t\t// Double check after taking the lock.\n\t\t\tif(enoughPeers()) return;\n\t\t\t// Second, do we have many announcements running?\n\t\t\tif(runningAnnouncements > WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Running announcements already\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// In cooling-off period?\n\t\t\tif(System.currentTimeMillis() < startTime) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"In cooling-off period for next \"+TimeUtil.formatTime(startTime - System.currentTimeMillis()));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(sentAnnouncements >= WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Sent enough announcements\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Now find a node to announce to\n\t\t\tVector<SeedServerPeerNode> seeds = node.peers.getConnectedSeedServerPeersVector(announcedToIdentities);\n\t\t\twhile(sentAnnouncements < WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(seeds.isEmpty()) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No more seednodes, announcedTo = \"+announcedToIdentities.size());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfinal SeedServerPeerNode seed = seeds.remove(node.random.nextInt(seeds.size()));\n\t\t\t\tInetAddress[] addrs = seed.getInetAddresses();\n\t\t\t\tif(!newAnnouncedIPs(addrs)) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not announcing to \"+seed+\" because already used those IPs\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\taddAnnouncedIPs(addrs);\n\t\t\t\tsentAnnouncements++;\n\t\t\t\trunningAnnouncements++;\n\t\t\t\tannouncedToIdentities.add(new ByteArrayWrapper(seed.getIdentity()));\n\t\t\t\tsendAnnouncement(seed);\n\t\t\t}\n\t\t\tif(runningAnnouncements >= WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Running \"+runningAnnouncements+\" announcements\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Do we want to connect some more seednodes?\n\t\t\tif(now - timeAddedSeeds < MIN_ADDED_SEEDS_INTERVAL) {\n\t\t\t\t// Don't connect seednodes yet\n\t\t\t\tLogger.minor(this, \"Waiting for MIN_ADDED_SEEDS_INTERVAL\");\n\t\t\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tmaybeSendAnnouncement();\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\tLogger.error(this, \"Caught \"+t+\" trying to send announcements\", t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, (timeAddedSeeds + MIN_ADDED_SEEDS_INTERVAL) - now);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconnectSomeSeednodes();\n\t}","id":31511,"modified_method":"protected void maybeSendAnnouncement() {\n\t\tsynchronized(this) {\n\t\t\tif(!started) return;\n\t\t}\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"maybeSendAnnouncement()\");\n\t\tlong now = System.currentTimeMillis();\n\t\tif(!node.isOpennetEnabled()) return;\n\t\tif(enoughPeers()) {\n\t\t\tnode.getTicker().queueTimedJob(checker, FINAL_DELAY);\n\t\t\treturn;\n\t\t}\n\t\tif((!ignoreIPUndetected) && (!node.ipDetector.hasValidIP())) {\n\t\t\tif(node.ipDetector.ipDetectorManager.hasDetectors()) {\n\t\t\t\tif(now - toldUserNoIP > 60*1000)\n\t\t\t\t\tSystem.out.println(\"Don't know our IP address, waiting for another 2 minutes...\");\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tdontKnowOurIPAddress = true;\n\t\t\t\t}\n\t\t\t\t// Wait a bit\n\t\t\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tsynchronized(Announcer.this) {\n\t\t\t\t\t\t\tif(ignoreIPUndetected) return;\n\t\t\t\t\t\t\tignoreIPUndetected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaybeSendAnnouncement();\n\t\t\t\t\t}\n\t\t\t\t}, FORCE_ANNOUNCEMENT_NO_IP);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsynchronized(this) {\n\t\t\tdontKnowOurIPAddress = false;\n\t\t\t// Double check after taking the lock.\n\t\t\tif(enoughPeers()) return;\n\t\t\t// Second, do we have many announcements running?\n\t\t\tif(runningAnnouncements > WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Running announcements already\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// In cooling-off period?\n\t\t\tif(System.currentTimeMillis() < startTime) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"In cooling-off period for next \"+TimeUtil.formatTime(startTime - System.currentTimeMillis()));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(sentAnnouncements >= WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Sent enough announcements\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Now find a node to announce to\n\t\t\tVector<SeedServerPeerNode> seeds = node.peers.getConnectedSeedServerPeersVector(announcedToIdentities);\n\t\t\twhile(sentAnnouncements < WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(seeds.isEmpty()) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No more seednodes, announcedTo = \"+announcedToIdentities.size());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfinal SeedServerPeerNode seed = seeds.remove(node.random.nextInt(seeds.size()));\n\t\t\t\tInetAddress[] addrs = seed.getInetAddresses();\n\t\t\t\tif(!newAnnouncedIPs(addrs)) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not announcing to \"+seed+\" because already used those IPs\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\taddAnnouncedIPs(addrs);\n\t\t\t\tsentAnnouncements++;\n\t\t\t\trunningAnnouncements++;\n\t\t\t\tannouncedToIdentities.add(new ByteArrayWrapper(seed.getIdentity()));\n\t\t\t\tsendAnnouncement(seed);\n\t\t\t}\n\t\t\tif(runningAnnouncements >= WANT_ANNOUNCEMENTS) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Running \"+runningAnnouncements+\" announcements\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Do we want to connect some more seednodes?\n\t\t\tif(now - timeAddedSeeds < MIN_ADDED_SEEDS_INTERVAL) {\n\t\t\t\t// Don't connect seednodes yet\n\t\t\t\tLogger.minor(this, \"Waiting for MIN_ADDED_SEEDS_INTERVAL\");\n\t\t\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tmaybeSendAnnouncement();\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\tLogger.error(this, \"Caught \"+t+\" trying to send announcements\", t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, (timeAddedSeeds + MIN_ADDED_SEEDS_INTERVAL) - now);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconnectSomeSeednodes();\n\t}","commit_id":"453a95aaafe7d00b7cec9b733bb66c70b73eb0ba","url":"https://github.com/freenet/fred"},{"original_method":"public void testDeduping() throws InterruptedException {\n\t\tif(!TestProperty.EXTENSIVE) return; // FIXME unreliable test, only run on -Dtest.extensive=true\n\t\tsynchronized(PrioritizedTickerTest.this) {\n\t\t\trunCount = 0;\n\t\t}\n\t\tassert(ticker.queuedJobs() == 0);\n        assert(ticker.queuedJobsUniqueTimes() == 0);\n\t\tticker.queueTimedJob(simpleRunnable, \"De-dupe test\", 200, false, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n\t\tticker.queueTimedJob(simpleRunnable, \"De-dupe test\", 300, false, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n\t\tThread.sleep(220);\n\t\tsynchronized(PrioritizedTickerTest.this) {\n\t\t\tassert(runCount == 1);\n\t\t}\n\t\tassert(ticker.queuedJobs() == 0);\n        assert(ticker.queuedJobsUniqueTimes() == 0);\n\t\tThread.sleep(200);\n\t\tsynchronized(PrioritizedTickerTest.this) {\n\t\t\tassert(runCount == 1);\n\t\t}\n\t\t// Now backwards\n\t\tticker.queueTimedJob(simpleRunnable, \"De-dupe test\", 300, false, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n\t\tticker.queueTimedJob(simpleRunnable, \"De-dupe test\", 200, false, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n\t\tThread.sleep(220);\n\t\tsynchronized(PrioritizedTickerTest.this) {\n\t\t\tassert(runCount == 2);\n\t\t}\n\t\tassert(ticker.queuedJobs() == 0);\n\t\tThread.sleep(200);\n\t\tsynchronized(PrioritizedTickerTest.this) {\n\t\t\tassert(runCount == 2);\n\t\t}\n\t\t\n\t}","id":31512,"modified_method":"public void testDeduping() throws InterruptedException {\n\t    synchronized(PrioritizedTickerTest.this) {\n\t\t\trunCount = 0;\n\t\t}\n\t\tassert(ticker.queuedJobs() == 0);\n        assert(ticker.queuedJobsUniqueTimes() == 0);\n        BlockTickerJob blocker = new BlockTickerJob();\n        ticker.queueTimedJob(blocker, \"Block the ticker\", 0, true, false);\n        blocker.waitForBlocking();\n        long runAt = System.currentTimeMillis();\n\t\tticker.queueTimedJobAbsolute(simpleRunnable, \"De-dupe test\", runAt, true, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n\t\tticker.queueTimedJobAbsolute(simpleRunnable, \"De-dupe test\", runAt+1, true, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n        blocker.unblockAndWait();\n        ticker.waitForIdle();\n\t\tsynchronized(PrioritizedTickerTest.this) {\n\t\t\tassert(runCount == 1);\n\t\t}\n\t\tassert(ticker.queuedJobs() == 0);\n        assert(ticker.queuedJobsUniqueTimes() == 0);\n\t\t// Now backwards\n        blocker = new BlockTickerJob();\n        ticker.queueTimedJob(blocker, \"Block the ticker\", 0, true, false);\n        blocker.waitForBlocking();\n        runAt = System.currentTimeMillis();\n\t\tticker.queueTimedJobAbsolute(simpleRunnable, \"De-dupe test\", runAt+1, false, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n\t\tticker.queueTimedJobAbsolute(simpleRunnable, \"De-dupe test\", runAt, false, true);\n\t\tassert(ticker.queuedJobs() == 1);\n        assert(ticker.queuedJobsUniqueTimes() == 1);\n        blocker.unblockAndWait();\n        ticker.waitForIdle();\n        assert(ticker.queuedJobs() == 0);\n        assert(ticker.queuedJobsUniqueTimes() == 0);\n\t\tsynchronized(PrioritizedTickerTest.this) {\n\t\t\tassert(runCount == 2);\n\t\t}\n\t}","commit_id":"2a121e43d10aa82e56486e085ae283e67be2bc76","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Will get all needed info from the plugin, put it into the Wrapper. Then\n\t * the Pluginstarter will be greated, and the plugin fedto it, starting the\n\t * plugin.\n\t * \n\t * the pluginInfoWrapper will then be returned\n\t * \n\t * @param plug\n\t */\n\tpublic static PluginInfoWrapper startPlugin(PluginManager pm, String filename, FredPlugin plug, PluginRespirator pr) {\n\t\tfinal PluginInfoWrapper pi = new PluginInfoWrapper(plug, filename);\n\t\tfinal PluginStarter ps = new PluginStarter(pr, pi);\n\t\tif(!pi.isThreadlessPlugin()) // No point otherwise\n\t\t\tpi.setThread(ps);\n\t\t\n\t\tps.setPlugin(pm, plug);\n\t\t// Run after startup\n\t\t// FIXME this is horrible, wastes a thread, need to make PluginStarter a Runnable \n\t\t// not a Thread, and then deal with the consequences of that (removePlugin(Thread)) ...\n\t\tpm.getTicker().queueTimedJob(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (!pi.isThreadlessPlugin())\n\t\t\t\t\tps.start();\n\t\t\t\telse\n\t\t\t\t\tps.run();\n\t\t\t}\n\t\t}, 0);\n\t\treturn pi;\n\t}","id":31513,"modified_method":"/**\n\t * Will get all needed info from the plugin, put it into the Wrapper. Then\n\t * the Pluginstarter will be greated, and the plugin fedto it, starting the\n\t * plugin.\n\t * \n\t * the pluginInfoWrapper will then be returned\n\t * \n\t * @param plug\n\t */\n\tpublic static PluginInfoWrapper startPlugin(PluginManager pm, String filename, FredPlugin plug, PluginRespirator pr) {\n\t\tfinal PluginInfoWrapper pi = new PluginInfoWrapper(plug, filename);\n\t\tfinal PluginStarter ps = new PluginStarter(pr, pi);\n\t\tps.setPlugin(pm, plug);\n\t\t// We must start the plugin *after startup has finished*\n\t\tRunnable job;\n\t\tif(!pi.isThreadlessPlugin()) {\n\t\t\tfinal Thread t = new Thread(ps);\n\t\t\tt.setDaemon(true);\n\t\t\tpi.setThread(t);\n\t\t\tjob = new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tt.start();\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tjob = ps;\n\t\t}\n\t\t// Run immediately after startup\n\t\tpm.getTicker().queueTimedJob(job, 0);\n\t\treturn pi;\n\t}","commit_id":"24cdd12c94113e868e861fe2e81c5281f6e2fc48","url":"https://github.com/freenet/fred"},{"original_method":"public PluginStarter(PluginRespirator pr, PluginInfoWrapper pi) {\n\t\t\tthis.pr = pr;\n\t\t\tthis.pi = pi;\n\t\t\tsetDaemon(true);\n\t\t}","id":31514,"modified_method":"public PluginStarter(PluginRespirator pr, PluginInfoWrapper pi) {\n\t\t\tthis.pr = pr;\n\t\t\tthis.pi = pi;\n\t\t}","commit_id":"24cdd12c94113e868e861fe2e81c5281f6e2fc48","url":"https://github.com/freenet/fred"},{"original_method":"public void lazyWriteMetadata() {\n        ticker.queueTimedJob(writeMetadataJob, \"Write metadata for splitfile\", \n                LAZY_WRITE_METADATA_DELAY, false, true);\n    }","id":31515,"modified_method":"public void lazyWriteMetadata() {\n        if(LAZY_WRITE_METADATA_DELAY != 0)\n            ticker.queueTimedJob(writeMetadataJob, \"Write metadata for splitfile\", \n                    LAZY_WRITE_METADATA_DELAY, false, true);\n        else\n            executor.execute(writeMetadataJob); // Must still be off-thread, multiple segments, possible locking issues...\n    }","commit_id":"411d0f0963e53e6eb5bbc923b32be68bdf9ef987","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Internal delivery of interests to pending filter listeners\n\t * @param ireg\n\t */\n\tprotected void deliverInterest(InterestRegistration ireg) {\n\t\t_stats.increment(StatsEnum.DeliverInterest);\n\n\t\t// Call any listeners with matching filters\n\t\tfor (Filter filter : _myFilters.getValues(ireg.interest.name())) {\n\t\t\tif (filter.owner != ireg.owner) {\n\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, formatMessage(\"Schedule delivery for interest: {0}\"), ireg.interest);\n\t\t\t\tif (filter.add(ireg.interest)) {\n\t\t\t\t\tfilter.deliver();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":31516,"modified_method":"/**\n\t * Internal delivery of interests to pending filter listeners\n\t * @param ireg\n\t */\n\tprotected void deliverInterest(InterestRegistration ireg, Interest interest) {\n\t\t_stats.increment(StatsEnum.DeliverInterest);\n\n\t\t// Call any listeners with matching filters\n\t\tfor (Filter filter : _myFilters.getValues(ireg.interest.name())) {\n\t\t\tif (filter.owner != ireg.owner) {\n\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, formatMessage(\"Schedule delivery for interest: {0}\"), interest);\n\t\t\t\tfilter.deliver(interest);\n\t\t\t}\n\t\t}\n\t}","commit_id":"6343f27a3bfef6d95102e2f9e7bd727c38cfabd8","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public synchronized boolean add(Interest i) {\n\t\t\tif (null == interest) {\n\t\t\t\tinterest = i;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// Special case, more than 1 interest pending for delivery\n\t\t\t\t// Only 1 interest gets added at a time, but more than 1 \n\t\t\t\t// may arrive before a callback is dispatched\n\t\t\t\tif (null == extra) {\n\t\t\t\t\textra = new ArrayList<Interest>(1);\n\t\t\t\t}\n\t\t\t\textra.add(i);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}","id":31517,"modified_method":"/**\n\t\t * Deliver interest to a registered handler\n\t\t */\n\t\tpublic void deliver(Interest interest) {\n\t\t\ttry {\n\t\t\t\tCCNFilterListener handler = (CCNFilterListener)this.listener;\n\n\t\t\t\t// Call into client code without holding any library locks\n\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Filter callback for: {0}\", prefix);\n\t\t\t\thandler.handleInterest(interest);\n\t\t\t\t// Now extra callbacks for additional interests\n\t\t\t} catch (RuntimeException ex) {\n\t\t\t\t_stats.increment(StatsEnum.DeliverInterestFailed);\n\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"failed to deliver interest: {0}\", ex);\n\t\t\t\tLog.warningStackTrace(ex);\n\t\t\t}\n\t\t}","commit_id":"6343f27a3bfef6d95102e2f9e7bd727c38cfabd8","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t\t * Return true if data was added.\n\t\t * If data is already pending for delivery for this interest, the \n\t\t * interest is already consumed and this new data cannot be delivered.\n\t\t * @throws NullPointerException If obj is null \n\t\t */\n\t\tpublic synchronized boolean add(ContentObject obj) {\n\t\t\tif (null == data) {\n\t\t\t\t// No data pending, this obj will consume interest\n\t\t\t\tthis.data = obj; // we let this raise exception if obj == null\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// Data is already pending, this interest is already consumed, cannot add obj\n\t\t\t\t_stats.increment(StatsEnum.ContentObjectsIgnored);\n\t\t\t\tif (Log.isLoggable(Log.FAC_NETMANAGER, Level.WARNING))\n\t\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"{0} is not handled - data already pending\", obj.name());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}","id":31518,"modified_method":"/**\n\t\t * Deliver content to a registered handler\n\t\t */\n\t\tpublic void deliver(ContentObject co) {\n\t\t\ttry {\n\t\t\t\tif (null != this.listener) {\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Interest callback (\" + co + \" data) for: {0}\", this.interest.name());\n\n\t\t\t\t\tunregisterInterest(this);\n\t\t\t\t\tCCNInterestListener handler = (CCNInterestListener)this.listener;\n\n\t\t\t\t\t// Callback the client - we can't hold any locks here!\n\t\t\t\t\tInterest updatedInterest = handler.handleContent(co, interest);\n\n\t\t\t\t\t// Possibly we should optimize here for the case where the same interest is returned back\n\t\t\t\t\t// (now we would unregister it, then reregister it) but need to be careful that the timing\n\t\t\t\t\t// behavior is right if we do that\n\t\t\t\t\tif (null != updatedInterest) {\n\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Interest callback: updated interest to express: {0}\", updatedInterest.name());\n\t\t\t\t\t\t// luckily we saved the listener\n\t\t\t\t\t\t// if we want to cancel this one before we get any data, we need to remember the\n\t\t\t\t\t\t// updated interest in the listener\n\t\t\t\t\t\texpressInterest(this.owner, updatedInterest, handler);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// This is the \"get\" case\n\t\t\t\t\tcontent = co;\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tif (null != this.sema) {\n\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Data consumes pending get: {0}\", this.interest.name());\n\t\t\t\t\t\t\t// Waiting thread will pickup data -- wake it up\n\t\t\t\t\t\t\t// If this interest came from net or waiting thread timed out,\n\t\t\t\t\t\t\t// then no thread will be waiting but no harm is done\n\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\n\t\t\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, \"releasing {0}\", this.sema);\n\t\t\t\t\t\t\tthis.sema.release();\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t\tif (null == this.sema) {\n\t\t\t\t\t\t// this is no longer valid registration\n\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Interest callback skipped (not valid) for: {0}\", this.interest.name());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\t_stats.increment(StatsEnum.DeliverContentFailed);\n\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"failed to deliver data: {0}\", ex);\n\t\t\t\tLog.warningStackTrace(ex);\n\t\t\t}\n\t\t}","commit_id":"6343f27a3bfef6d95102e2f9e7bd727c38cfabd8","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Thread method: this thread will handle reading datagrams and \n\t * starts threads to dispatch data to handlers registered for it.\n\t */\n\tpublic void run() {\n\t\tif (! _run) {\n\t\t\tLog.warning(Log.FAC_NETMANAGER, formatMessage(\"CCNNetworkManager run() called after shutdown\"));\n\t\t\treturn;\n\t\t}\n\t\t//WirePacket packet = new WirePacket();\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\n\t\t\tLog.info(Log.FAC_NETMANAGER, formatMessage(\"CCNNetworkManager processing thread started for port: \" + _port));\n\t\twhile (_run) {\n\t\t\ttry {\n\t\t\t\tboolean wasConnected = _channel.isConnected();\n\t\t\t\tXMLEncodable packet = _channel.getPacket();\n\t\t\t\tif (null == packet) {\n\t\t\t\t\tif (!wasConnected && _channel.isConnected())\n\t\t\t\t\t\treregisterPrefixes();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (packet instanceof ContentObject) {\n\t\t\t\t\t_stats.increment(StatsEnum.ReceiveObject);\n\t\t\t\t\tContentObject co = (ContentObject)packet;\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, formatMessage(\"Data from net for port: \" + _port + \" {0}\"), co.name());\n\n\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\n\n\t\t\t\t\tdeliverData(co);\n\t\t\t\t\t// External data never goes back to network, never held onto here\n\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\n\t\t\t\t} else if (packet instanceof Interest) {\n\t\t\t\t\t_stats.increment(StatsEnum.ReceiveInterest);\n\t\t\t\t\tInterest interest = (Interest)\tpacket;\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\n\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, formatMessage(\"Interest from net for port: \" + _port + \" {0}\"), interest);\n\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(interest, null, null);\n\t\t\t\t\tdeliverInterest(oInterest);\n\t\t\t\t\t// External interests never go back to network\n\t\t\t\t}  else { // for interests\n\t\t\t\t\t_stats.increment(StatsEnum.ReceiveUnknown);\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\t_stats.increment(StatsEnum.ReceiveErrors);\n\t\t\t\tLog.severe(Log.FAC_NETMANAGER, formatMessage(\"Processing thread failure (UNKNOWN): \" + ex.getMessage() + \" for port: \" + _port));\n                Log.warningStackTrace(ex);\n\t\t\t}\n\t\t}\n\n\t\tLog.info(Log.FAC_NETMANAGER, formatMessage(\"Shutdown complete for port: \" + _port));\n\t}","id":31519,"modified_method":"/**\n\t * Thread method: this thread will handle reading datagrams and \n\t * starts threads to dispatch data to handlers registered for it.\n\t */\n\tpublic void run() {\n\t\tif (! _run) {\n\t\t\tLog.warning(Log.FAC_NETMANAGER, formatMessage(\"CCNNetworkManager run() called after shutdown\"));\n\t\t\treturn;\n\t\t}\n\t\t//WirePacket packet = new WirePacket();\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\n\t\t\tLog.info(Log.FAC_NETMANAGER, formatMessage(\"CCNNetworkManager processing thread started for port: \" + _port));\n\t\twhile (_run) {\n\t\t\ttry {\n\t\t\t\tboolean wasConnected = _channel.isConnected();\n\t\t\t\tXMLEncodable packet = _channel.getPacket();\n\t\t\t\tif (null == packet) {\n\t\t\t\t\tif (!wasConnected && _channel.isConnected())\n\t\t\t\t\t\treregisterPrefixes();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (packet instanceof ContentObject) {\n\t\t\t\t\t_stats.increment(StatsEnum.ReceiveObject);\n\t\t\t\t\tContentObject co = (ContentObject)packet;\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, formatMessage(\"Data from net for port: \" + _port + \" {0}\"), co.name());\n\n\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\n\n\t\t\t\t\tdeliverData(co);\n\t\t\t\t\t// External data never goes back to network, never held onto here\n\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\n\t\t\t\t} else if (packet instanceof Interest) {\n\t\t\t\t\t_stats.increment(StatsEnum.ReceiveInterest);\n\t\t\t\t\tInterest interest = (Interest)\tpacket;\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\n\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, formatMessage(\"Interest from net for port: \" + _port + \" {0}\"), interest);\n\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(interest, null, null);\n\t\t\t\t\tdeliverInterest(oInterest, interest);\n\t\t\t\t\t// External interests never go back to network\n\t\t\t\t}  else { // for interests\n\t\t\t\t\t_stats.increment(StatsEnum.ReceiveUnknown);\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\t_stats.increment(StatsEnum.ReceiveErrors);\n\t\t\t\tLog.severe(Log.FAC_NETMANAGER, formatMessage(\"Processing thread failure (UNKNOWN): \" + ex.getMessage() + \" for port: \" + _port));\n                Log.warningStackTrace(ex);\n\t\t\t}\n\t\t}\n\n\t\tLog.info(Log.FAC_NETMANAGER, formatMessage(\"Shutdown complete for port: \" + _port));\n\t}","commit_id":"6343f27a3bfef6d95102e2f9e7bd727c38cfabd8","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void run() {\t\n\t\t\tboolean refreshError = false;\t\t\t\n\t\t\tif (_protocol == NetworkProtocol.UDP) {\n\t\t\t\tif (!_channel.isConnected()) {\n                    //we are not connected.  reconnect attempt is in the heartbeat function...\n\t\t\t\t\t_channel.heartbeat();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!_channel.isConnected()) {\n                //we tried to reconnect and failed, try again next loop\n                Log.fine(Log.FAC_NETMANAGER, \"Not Connected to ccnd, try again in {0}ms\", CCNNetworkChannel.SOCKET_TIMEOUT);\n                _lastHeartbeat = 0;\n                if (_run)\n                        _periodicTimer.schedule(new PeriodicWriter(), CCNNetworkChannel.SOCKET_TIMEOUT);\n                return;\n            }\n\n            long ourTime = System.currentTimeMillis();\n            long minInterestRefreshTime = PERIOD + ourTime;\n\t\t\t\t\n\t\t\t// Re-express interests that need to be re-expressed\n            // TODO Interest refresh time is supposed to \"decay\" over time but there are currently\n    \t\t// unresolved problems with this.\n\t\t\ttry {\n\t\t\t\tfor (Entry<InterestRegistration> entry : _myInterests.values()) {\n\t\t\t\t\tInterestRegistration reg = entry.value();\n\t\t\t\t\t // allow some slop for scheduling\n                    if (ourTime + 20 > reg.nextRefresh) {\n                            if( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n                                    Log.finer(Log.FAC_NETMANAGER, \"Refresh interest: {0}\", reg.interest);\n                            _lastHeartbeat = ourTime;\n                            reg.nextRefresh = ourTime + reg.nextRefreshPeriod;\n                            try {\n                                write(reg.interest);\n                        } catch (NotYetConnectedException nyce) {\n                                refreshError = true;\n                        }\n                    }\n\t\t\t\t\tif (minInterestRefreshTime > reg.nextRefresh)\n\t\t\t\t\t\tminInterestRefreshTime = reg.nextRefresh;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} catch (ContentEncodingException xmlex) {\n                Log.severe(Log.FAC_NETMANAGER, \"PeriodicWriter interest refresh thread failure (Malformed datagram): {0}\", xmlex.getMessage());\n                Log.warningStackTrace(xmlex);\n                refreshError = true;\n\t\t\t}\n\n\t\t\t// Re-express prefix registrations that need to be re-expressed\n            // FIXME: The lifetime of a prefix is returned in seconds, not milliseconds.  The refresh code needs\n            // to understand this.  This isn't a problem for now because the lifetime we request when we register a\n            // prefix we use Integer.MAX_VALUE as the requested lifetime.\n            // FIXME: so lets not go around the loop doing nothing... for now.\n            long minFilterRefreshTime = PERIOD + ourTime;\n            if (false && _usePrefixReg) {\n            \tsynchronized (_registeredPrefixes) {\n                    for (ContentName prefix : _registeredPrefixes.keySet()) {\n                    \tRegisteredPrefix rp = _registeredPrefixes.get(prefix);\n\t\t\t\t\t\tif (null != rp._forwarding && rp._lifetime != -1 && rp._nextRefresh != -1) {\n\t\t\t\t\t\t\tif (ourTime > rp._nextRefresh) {\n\t\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Refresh registration: {0}\", prefix);\n\t\t\t\t\t\t\t\trp._nextRefresh = -1;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tForwardingEntry forwarding = _prefixMgr.selfRegisterPrefix(prefix);\n\t\t\t\t\t\t\t\t\tif (null != forwarding) {\n\t\t\t\t\t\t\t\t\t\trp._lifetime = forwarding.getLifetime();\n//\t\t\t\t\t\t\t\t\t\tfilter.nextRefresh = new Date().getTime() + (filter.lifetime / 2);\n\t\t\t\t\t\t\t\t\t\t_lastHeartbeat = System.currentTimeMillis();\n\t\t\t\t\t\t\t\t\t\trp._nextRefresh = _lastHeartbeat + (rp._lifetime / 2);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\trp._forwarding = forwarding;\n\n\t\t\t\t\t\t\t\t} catch (CCNDaemonException e) {\n\t\t\t\t\t\t\t\t\tLog.warning(e.getMessage());\n\t\t\t\t\t\t\t\t\t// XXX - don't think this is right\n\t\t\t\t\t\t\t\t\trp._forwarding = null;\n\t\t\t\t\t\t\t\t\trp._lifetime = -1;\n\t\t\t\t\t\t\t\t\trp._nextRefresh = -1;\n\t\t\t\t\t\t\t\t\trefreshError = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (minFilterRefreshTime > rp._nextRefresh)\n\t\t\t\t\t\t\t\tminFilterRefreshTime = rp._nextRefresh;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t// for (Entry<Filter> entry: _myFilters.values())\n\t\t\t\t}\t// synchronized (_myFilters)\n\t\t\t} // _usePrefixReg\n        \t\n        \tif (refreshError) {\n                Log.warning(Log.FAC_NETMANAGER, \"we have had an error when refreshing an interest or prefix registration...  do we need to reconnect to ccnd?\");\n        \t}\n\n        \t// Calculate when we should next be run\n\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\tlong checkInterestDelay = minInterestRefreshTime - currentTime;\n\t\t\tif (checkInterestDelay < 0)\n\t\t\t\tcheckInterestDelay = 0;\n\t\t\tif (checkInterestDelay > PERIOD)\n\t\t\t\tcheckInterestDelay = PERIOD;\n\n\t\t\tlong checkPrefixDelay = minFilterRefreshTime - currentTime;\n\t\t\tif (checkPrefixDelay < 0)\n\t\t\t\tcheckPrefixDelay = 0;\n\t\t\tif (checkPrefixDelay > PERIOD)\n\t\t\t\tcheckPrefixDelay = PERIOD;\n\t\t\t\n\t\t\tlong useMe;\n\t\t\tif (checkInterestDelay < checkPrefixDelay) {\n\t\t\t\tuseMe = checkInterestDelay;\n\t\t\t} else {\n\t\t\t\tuseMe = checkPrefixDelay;\n\t\t\t}\n\n\t\t\tif (_protocol == NetworkProtocol.UDP) {\n\n\t\t\t\t\t//we haven't sent anything...  maybe need to send a heartbeat\n\t\t\t\tif ((currentTime - _lastHeartbeat) >= CCNNetworkChannel.HEARTBEAT_PERIOD) {\n\t\t\t\t\t_lastHeartbeat = currentTime;\n\t\t\t\t\t_channel.heartbeat();\n\t\t\t\t}\t\t\t\t\n\t\n\t\t\t\t//now factor in heartbeat time\n\t\t\t\tlong timeToHeartbeat = CCNNetworkChannel.HEARTBEAT_PERIOD - (currentTime - _lastHeartbeat);\n\t\t\t\tif (useMe > timeToHeartbeat)\n\t\t\t\t\tuseMe = timeToHeartbeat;\n\t\t\t}\n\n\t\t\tif (useMe < 20) {\n\t\t\t\tuseMe = 20;\n\t\t\t}\n\t\t\tif (_run)\n\t\t\t\t_periodicTimer.schedule(new PeriodicWriter(), useMe);\n\t\t}","id":31520,"modified_method":"public void run() {\t\n\t\t\tboolean refreshError = false;\t\t\t\n\t\t\tif (_protocol == NetworkProtocol.UDP) {\n\t\t\t\tif (!_channel.isConnected()) {\n                    //we are not connected.  reconnect attempt is in the heartbeat function...\n\t\t\t\t\t_channel.heartbeat();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!_channel.isConnected()) {\n                //we tried to reconnect and failed, try again next loop\n                Log.fine(Log.FAC_NETMANAGER, \"Not Connected to ccnd, try again in {0}ms\", CCNNetworkChannel.SOCKET_TIMEOUT);\n                _lastHeartbeat = 0;\n                if (_run)\n                        _periodicTimer.schedule(new PeriodicWriter(), CCNNetworkChannel.SOCKET_TIMEOUT);\n                return;\n            }\n\n            long ourTime = System.currentTimeMillis();\n            long minInterestRefreshTime = PERIOD + ourTime;\n\t\t\t\t\n\t\t\t// Re-express interests that need to be re-expressed\n            // TODO Interest refresh time is supposed to \"decay\" over time but there are currently\n    \t\t// unresolved problems with this.\n\t\t\ttry {\n\t\t\t\tfor (Entry<InterestRegistration> entry : _myInterests.values()) {\n\t\t\t\t\tInterestRegistration reg = entry.value();\n\t\t\t\t\t // allow some slop for scheduling\n                    if (ourTime + 20 > reg.nextRefresh) {\n                            if( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n                                    Log.finer(Log.FAC_NETMANAGER, \"Refresh interest: {0}\", reg.interest);\n                            _lastHeartbeat = ourTime;\n                            reg.nextRefresh = ourTime + reg.nextRefreshPeriod;\n                            try {\n                                write(reg.interest);\n                        } catch (NotYetConnectedException nyce) {\n                                refreshError = true;\n                        }\n                    }\n\t\t\t\t\tif (minInterestRefreshTime > reg.nextRefresh)\n\t\t\t\t\t\tminInterestRefreshTime = reg.nextRefresh;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} catch (ContentEncodingException xmlex) {\n                Log.severe(Log.FAC_NETMANAGER, \"PeriodicWriter interest refresh thread failure (Malformed datagram): {0}\", xmlex.getMessage());\n                Log.warningStackTrace(xmlex);\n                refreshError = true;\n\t\t\t}\n\n\t\t\t// Re-express prefix registrations that need to be re-expressed\n            // FIXME: The lifetime of a prefix is returned in seconds, not milliseconds.  The refresh code needs\n            // to understand this.  This isn't a problem for now because the lifetime we request when we register a\n            // prefix we use Integer.MAX_VALUE as the requested lifetime.\n            // FIXME: so lets not go around the loop doing nothing... for now.\n            long minFilterRefreshTime = PERIOD + ourTime;\n            /* if (_usePrefixReg) {\n            \tsynchronized (_registeredPrefixes) {\n                    for (ContentName prefix : _registeredPrefixes.keySet()) {\n                    \tRegisteredPrefix rp = _registeredPrefixes.get(prefix);\n\t\t\t\t\t\tif (null != rp._forwarding && rp._lifetime != -1 && rp._nextRefresh != -1) {\n\t\t\t\t\t\t\tif (ourTime > rp._nextRefresh) {\n\t\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\n\t\t\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Refresh registration: {0}\", prefix);\n\t\t\t\t\t\t\t\trp._nextRefresh = -1;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tForwardingEntry forwarding = _prefixMgr.selfRegisterPrefix(prefix);\n\t\t\t\t\t\t\t\t\tif (null != forwarding) {\n\t\t\t\t\t\t\t\t\t\trp._lifetime = forwarding.getLifetime();\n//\t\t\t\t\t\t\t\t\t\tfilter.nextRefresh = new Date().getTime() + (filter.lifetime / 2);\n\t\t\t\t\t\t\t\t\t\t_lastHeartbeat = System.currentTimeMillis();\n\t\t\t\t\t\t\t\t\t\trp._nextRefresh = _lastHeartbeat + (rp._lifetime / 2);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\trp._forwarding = forwarding;\n\n\t\t\t\t\t\t\t\t} catch (CCNDaemonException e) {\n\t\t\t\t\t\t\t\t\tLog.warning(e.getMessage());\n\t\t\t\t\t\t\t\t\t// XXX - don't think this is right\n\t\t\t\t\t\t\t\t\trp._forwarding = null;\n\t\t\t\t\t\t\t\t\trp._lifetime = -1;\n\t\t\t\t\t\t\t\t\trp._nextRefresh = -1;\n\t\t\t\t\t\t\t\t\trefreshError = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (minFilterRefreshTime > rp._nextRefresh)\n\t\t\t\t\t\t\t\tminFilterRefreshTime = rp._nextRefresh;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t// for (Entry<Filter> entry: _myFilters.values())\n\t\t\t\t}\t// synchronized (_myFilters)\n\t\t\t} // _usePrefixReg */\n        \t\n        \tif (refreshError) {\n                Log.warning(Log.FAC_NETMANAGER, \"we have had an error when refreshing an interest or prefix registration...  do we need to reconnect to ccnd?\");\n        \t}\n\n        \t// Calculate when we should next be run\n\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\tlong checkInterestDelay = minInterestRefreshTime - currentTime;\n\t\t\tif (checkInterestDelay < 0)\n\t\t\t\tcheckInterestDelay = 0;\n\t\t\tif (checkInterestDelay > PERIOD)\n\t\t\t\tcheckInterestDelay = PERIOD;\n\n\t\t\tlong checkPrefixDelay = minFilterRefreshTime - currentTime;\n\t\t\tif (checkPrefixDelay < 0)\n\t\t\t\tcheckPrefixDelay = 0;\n\t\t\tif (checkPrefixDelay > PERIOD)\n\t\t\t\tcheckPrefixDelay = PERIOD;\n\t\t\t\n\t\t\tlong useMe;\n\t\t\tif (checkInterestDelay < checkPrefixDelay) {\n\t\t\t\tuseMe = checkInterestDelay;\n\t\t\t} else {\n\t\t\t\tuseMe = checkPrefixDelay;\n\t\t\t}\n\n\t\t\tif (_protocol == NetworkProtocol.UDP) {\n\n\t\t\t\t\t//we haven't sent anything...  maybe need to send a heartbeat\n\t\t\t\tif ((currentTime - _lastHeartbeat) >= CCNNetworkChannel.HEARTBEAT_PERIOD) {\n\t\t\t\t\t_lastHeartbeat = currentTime;\n\t\t\t\t\t_channel.heartbeat();\n\t\t\t\t}\t\t\t\t\n\t\n\t\t\t\t//now factor in heartbeat time\n\t\t\t\tlong timeToHeartbeat = CCNNetworkChannel.HEARTBEAT_PERIOD - (currentTime - _lastHeartbeat);\n\t\t\t\tif (useMe > timeToHeartbeat)\n\t\t\t\t\tuseMe = timeToHeartbeat;\n\t\t\t}\n\n\t\t\tif (useMe < 20) {\n\t\t\t\tuseMe = 20;\n\t\t\t}\n\t\t\tif (_run)\n\t\t\t\t_periodicTimer.schedule(new PeriodicWriter(), useMe);\n\t\t}","commit_id":"6343f27a3bfef6d95102e2f9e7bd727c38cfabd8","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t *  Deliver data to blocked getters and registered interests\n\t * @param co\n\t */\n\tprotected void deliverData(ContentObject co) {\n\t\t_stats.increment(StatsEnum.DeliverContent);\n\n\t\tfor (InterestRegistration ireg : _myInterests.getValues(co)) {\n\t\t\tif (ireg.add(co)) { // this is a copy of the data\n\t\t\t\t_stats.increment(StatsEnum.DeliverContentMatchingInterests);\n\t\t\t\tireg.deliver();\t\t\n\t\t\t}\n\t\t}\n\t}","id":31521,"modified_method":"/**\n\t *  Deliver data to blocked getters and registered interests\n\t * @param co\n\t */\n\tprotected void deliverData(ContentObject co) {\n\t\t_stats.increment(StatsEnum.DeliverContent);\n\n\t\tfor (InterestRegistration ireg : _myInterests.getValues(co)) {\n\t\t\t_stats.increment(StatsEnum.DeliverContentMatchingInterests);\n\t\t\tireg.deliver(co);\t\t\n\t\t}\n\t}","commit_id":"6343f27a3bfef6d95102e2f9e7bd727c38cfabd8","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * get content matching an interest from ccnd. Expresses an interest, waits for ccnd to\n\t * return matching the data, then removes the interest and returns the data to the caller.\n\t * \n\t * TODO should probably handle InterruptedException at this level instead of throwing it to\n\t * \t\thigher levels\n\t * \n\t * @param interest\tthe interest\n\t * @param timeout\ttime to wait for return in ms\n\t * @return\tContentObject or null on timeout\n\t * @throws IOException \ton incorrect interest data\n\t * @throws InterruptedException\tif process is interrupted during wait\n\t */\n\tpublic ContentObject get(Interest interest, long timeout) throws IOException, InterruptedException {\n\t\t_stats.increment(StatsEnum.Gets);\n\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINE) )\n\t\t\tLog.fine(Log.FAC_NETMANAGER, formatMessage(\"get: {0} with timeout: {1}\"), interest, timeout);\n\t\tInterestRegistration reg = new InterestRegistration(interest, null, null);\n\t\texpressInterest(reg);\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\n\t\t\tLog.finest(Log.FAC_NETMANAGER, formatMessage(\"blocking for {0} on {1}\"), interest.name(), reg.sema);\n\t\t// Await data to consume the interest\n\t\tif (timeout == SystemConfiguration.NO_TIMEOUT)\n\t\t\treg.sema.acquire(); // currently no timeouts\n\t\telse\n\t\t\treg.sema.tryAcquire(timeout, TimeUnit.MILLISECONDS);\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\n\t\t\tLog.finest(Log.FAC_NETMANAGER, formatMessage(\"unblocked for {0} on {1}\"), interest.name(), reg.sema);\n\t\t// Typically the main processing thread will have registered the interest\n\t\t// which must be undone here, but no harm if never registered\n\t\tunregisterInterest(reg);\n\t\treturn reg.popData(); \n\t}","id":31522,"modified_method":"/**\n\t * get content matching an interest from ccnd. Expresses an interest, waits for ccnd to\n\t * return matching the data, then removes the interest and returns the data to the caller.\n\t * \n\t * TODO should probably handle InterruptedException at this level instead of throwing it to\n\t * \t\thigher levels\n\t * \n\t * @param interest\tthe interest\n\t * @param timeout\ttime to wait for return in ms\n\t * @return\tContentObject or null on timeout\n\t * @throws IOException \ton incorrect interest data\n\t * @throws InterruptedException\tif process is interrupted during wait\n\t */\n\tpublic ContentObject get(Interest interest, long timeout) throws IOException, InterruptedException {\n\t\t_stats.increment(StatsEnum.Gets);\n\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINE) )\n\t\t\tLog.fine(Log.FAC_NETMANAGER, formatMessage(\"get: {0} with timeout: {1}\"), interest, timeout);\n\t\tInterestRegistration reg = new InterestRegistration(interest, null, null);\n\t\texpressInterest(reg);\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\n\t\t\tLog.finest(Log.FAC_NETMANAGER, formatMessage(\"blocking for {0} on {1}\"), interest.name(), reg.sema);\n\t\t// Await data to consume the interest\n\t\tif (timeout == SystemConfiguration.NO_TIMEOUT)\n\t\t\treg.sema.acquire(); // currently no timeouts\n\t\telse\n\t\t\treg.sema.tryAcquire(timeout, TimeUnit.MILLISECONDS);\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\n\t\t\tLog.finest(Log.FAC_NETMANAGER, formatMessage(\"unblocked for {0} on {1}\"), interest.name(), reg.sema);\n\t\t// Typically the main processing thread will have registered the interest\n\t\t// which must be undone here, but no harm if never registered\n\t\tunregisterInterest(reg);\n\t\treturn reg.content; \n\t}","commit_id":"6343f27a3bfef6d95102e2f9e7bd727c38cfabd8","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n   * Default constructor when no channels.\n   */\n  public NotificationService(Settings settings, DefaultNotificationManager manager, NotificationDispatcher[] dispatchers) {\n    this(settings, manager, dispatchers, new NotificationChannel[0]);\n    Logs.INFO.warn(\"There is no channels - all notifications would be ignored!\");\n  }","id":31523,"modified_method":"/**\n   * Default constructor when no channels.\n   */\n  public NotificationService(Settings settings, DefaultNotificationManager manager, NotificationDispatcher[] dispatchers) {\n    this(settings, manager, dispatchers, new NotificationChannel[0]);\n    Logs.INFO.warn(\"There is no channels - all notifications will be ignored!\");\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Visibility has been relaxed for tests.\n   */\n  void deliver(Notification notification) {\n    Logs.INFO.debug(\"Delivering notification \" + notification);\n    SetMultimap<String, NotificationChannel> recipients = HashMultimap.create();\n    for (NotificationChannel channel : channels) {\n      for (NotificationDispatcher dispatcher : dispatchers) {\n        final Set<String> possibleRecipients = Sets.newHashSet();\n        NotificationDispatcher.Context context = new NotificationDispatcher.Context() {\n          public void addUser(String username) {\n            if (username != null) {\n              possibleRecipients.add(username);\n            }\n          }\n        };\n        try {\n          dispatcher.dispatch(notification, context);\n        } catch (Exception e) { // catch all exceptions in order to dispatch using other dispatchers\n          Logs.INFO.warn(\"Unable to dispatch notification \" + notification + \" using \" + dispatcher, e);\n        }\n        for (String username : possibleRecipients) {\n          if (manager.isEnabled(username, channel.getKey(), dispatcher.getKey())) {\n            recipients.put(username, channel);\n          }\n        }\n      }\n    }\n    for (Map.Entry<String, Collection<NotificationChannel>> entry : recipients.asMap().entrySet()) {\n      String username = entry.getKey();\n      Collection<NotificationChannel> userChannels = entry.getValue();\n      Logs.INFO.debug(\"For user {} via {}\", username, userChannels);\n      for (NotificationChannel channel : userChannels) {\n        try {\n          channel.deliver(notification, username);\n        } catch (Exception e) { // catch all exceptions in order to deliver via other channels\n          Logs.INFO.warn(\"Unable to deliver notification \" + notification + \" for user \" + username + \" via \" + channel, e);\n        }\n      }\n    }\n  }","id":31524,"modified_method":"private void deliver(Notification notification) {\n    Logs.INFO.debug(\"Delivering notification \" + notification);\n    SetMultimap<String, NotificationChannel> recipients = HashMultimap.create();\n    for (NotificationChannel channel : channels) {\n      for (NotificationDispatcher dispatcher : dispatchers) {\n        final Set<String> possibleRecipients = Sets.newHashSet();\n        NotificationDispatcher.Context context = new NotificationDispatcher.Context() {\n          public void addUser(String username) {\n            if (username != null) {\n              possibleRecipients.add(username);\n            }\n          }\n        };\n        try {\n          dispatcher.dispatch(notification, context);\n        } catch (Exception e) { // catch all exceptions in order to dispatch using other dispatchers\n          Logs.INFO.warn(\"Unable to dispatch notification \" + notification + \" using \" + dispatcher, e);\n        }\n        for (String username : possibleRecipients) {\n          if (manager.isEnabled(username, channel.getKey(), dispatcher.getKey())) {\n            recipients.put(username, channel);\n          }\n        }\n      }\n    }\n    for (Map.Entry<String, Collection<NotificationChannel>> entry : recipients.asMap().entrySet()) {\n      String username = entry.getKey();\n      Collection<NotificationChannel> userChannels = entry.getValue();\n      Logs.INFO.debug(\"For user {} via {}\", username, userChannels);\n      for (NotificationChannel channel : userChannels) {\n        try {\n          channel.deliver(notification, username);\n        } catch (Exception e) { // catch all exceptions in order to deliver via other channels\n          Logs.INFO.warn(\"Unable to deliver notification \" + notification + \" for user \" + username + \" via \" + channel, e);\n        }\n      }\n    }\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void stop() {\n    try {\n      stopping = true;\n      executorService.awaitTermination(5, TimeUnit.SECONDS);\n      executorService.shutdown();\n    } catch (InterruptedException e) {\n      Logs.INFO.error(\"Error during stop of notification service\", e);\n    }\n    Logs.INFO.info(\"Notification service stopped\");\n  }","id":31525,"modified_method":"public void stop() {\n    try {\n      stopping = true;\n      executorService.shutdown();\n      executorService.awaitTermination(5, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Logs.INFO.error(\"Error during stop of notification service\", e);\n    }\n    Logs.INFO.info(\"Notification service stopped\");\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Visibility has been relaxed for tests.\n   */\n  void processQueue() {\n    TIME_PROFILER.start(\"Processing notifications queue\");\n    NotificationQueueElement queueElement = manager.getFromQueue();\n    while (queueElement != null) {\n      deliver(queueElement.getNotification());\n      if (stopping) {\n        break;\n      }\n      queueElement = manager.getFromQueue();\n    }\n    TIME_PROFILER.stop();\n  }","id":31526,"modified_method":"@VisibleForTesting\n  synchronized void processQueue() {\n    TIME_PROFILER.start(\"Processing notifications queue\");\n\n    NotificationQueueElement queueElement = manager.getFromQueue();\n    while (queueElement != null) {\n      deliver(queueElement.getNotification());\n      if (stopping) {\n        break;\n      }\n      queueElement = manager.getFromQueue();\n    }\n\n    TIME_PROFILER.stop();\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Given:\n   * Nobody wants to receive notifications.\n   * \n   * When:\n   * Freddy adds comment to review created by Evgeny and assigned to Simon.\n   * \n   * Then:\n   * No notifications.\n   */\n  @Test\n  public void scenario4() {\n    Notification notification = mock(Notification.class);\n    creator = USER_EVGENY;\n    assignee = USER_SIMON;\n\n    service.deliver(notification);\n\n    verify(emailChannel, atLeast(1)).getKey();\n    verify(gtalkChannel, atLeast(1)).getKey();\n    verifyNoMoreInteractions(emailChannel);\n    verifyNoMoreInteractions(gtalkChannel);\n  }","id":31527,"modified_method":"/**\n   * Given:\n   * Nobody wants to receive notifications.\n   * \n   * When:\n   * Freddy adds comment to review created by Evgeny and assigned to Simon.\n   * \n   * Then:\n   * No notifications.\n   */\n  @Test\n  public void scenario4() {\n    setUpMocks(CREATOR_EVGENY, ASSIGNEE_SIMON);\n\n    service.start();\n    service.stop();\n\n    verify(emailChannel, never()).deliver(any(Notification.class), anyString());\n    verify(gtalkChannel, never()).deliver(any(Notification.class), anyString());\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Given:\n   * Simon wants to receive notifications by Email and GTLak on comments for reviews assigned to him.\n   * \n   * When:\n   * Freddy adds comment to review created by Evgeny and assigned to Simon.\n   * \n   * Then:\n   * Two notifications should be delivered to Simon - one by Email and another by GTalk.\n   */\n  @Test\n  public void scenario3() {\n    doReturn(true).when(manager).isEnabled(USER_SIMON, \"email\", \"comment on review assigned to me\");\n    doReturn(true).when(manager).isEnabled(USER_SIMON, \"gtalk\", \"comment on review assigned to me\");\n\n    Notification notification = mock(Notification.class);\n    creator = USER_EVGENY;\n    assignee = USER_SIMON;\n\n    service.deliver(notification);\n\n    verify(emailChannel, atLeast(1)).getKey();\n    verify(gtalkChannel, atLeast(1)).getKey();\n    verify(emailChannel).deliver(notification, USER_SIMON);\n    verify(gtalkChannel).deliver(notification, USER_SIMON);\n    verifyNoMoreInteractions(emailChannel);\n    verifyNoMoreInteractions(gtalkChannel);\n  }","id":31528,"modified_method":"/**\n   * Given:\n   * Simon wants to receive notifications by Email and GTLak on comments for reviews assigned to him.\n   * \n   * When:\n   * Freddy adds comment to review created by Evgeny and assigned to Simon.\n   * \n   * Then:\n   * Two notifications should be delivered to Simon - one by Email and another by GTalk.\n   */\n  @Test\n  public void scenario3() {\n    setUpMocks(CREATOR_EVGENY, ASSIGNEE_SIMON);\n    when(manager.isEnabled(ASSIGNEE_SIMON, \"email\", \"comment on review assigned to me\")).thenReturn(true);\n    when(manager.isEnabled(ASSIGNEE_SIMON, \"gtalk\", \"comment on review assigned to me\")).thenReturn(true);\n\n    service.start();\n    verify(emailChannel, timeout(2000)).deliver(notification, ASSIGNEE_SIMON);\n    verify(gtalkChannel, timeout(2000)).deliver(notification, ASSIGNEE_SIMON);\n    service.stop();\n\n    verify(emailChannel, never()).deliver(notification, CREATOR_EVGENY);\n    verify(gtalkChannel, never()).deliver(notification, CREATOR_EVGENY);\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Given:\n   * Evgeny wants to receive notification by GTalk on comments for reviews created by him.\n   * Simon wants to receive notification by Email on comments for reviews assigned to him.\n   * \n   * When:\n   * Freddy adds comment to review created by Evgeny and assigned to Simon.\n   * \n   * Then:\n   * Two notifications should be delivered - one to Simon by Email and another to Evgeny by GTalk.\n   */\n  @Test\n  public void scenario2() {\n    doReturn(true).when(manager).isEnabled(USER_EVGENY, \"gtalk\", \"comment on review created by me\");\n    doReturn(true).when(manager).isEnabled(USER_SIMON, \"email\", \"comment on review assigned to me\");\n\n    Notification notification = mock(Notification.class);\n    creator = USER_EVGENY;\n    assignee = USER_SIMON;\n\n    service.deliver(notification);\n\n    verify(emailChannel, atLeast(1)).getKey();\n    verify(gtalkChannel, atLeast(1)).getKey();\n    verify(emailChannel).deliver(notification, USER_SIMON);\n    verify(gtalkChannel).deliver(notification, USER_EVGENY);\n    verifyNoMoreInteractions(emailChannel);\n    verifyNoMoreInteractions(gtalkChannel);\n  }","id":31529,"modified_method":"/**\n   * Given:\n   * Evgeny wants to receive notification by GTalk on comments for reviews created by him.\n   * Simon wants to receive notification by Email on comments for reviews assigned to him.\n   * \n   * When:\n   * Freddy adds comment to review created by Evgeny and assigned to Simon.\n   * \n   * Then:\n   * Two notifications should be delivered - one to Simon by Email and another to Evgeny by GTalk.\n   */\n  @Test\n  public void scenario2() {\n    setUpMocks(CREATOR_EVGENY, ASSIGNEE_SIMON);\n    when(manager.isEnabled(CREATOR_EVGENY, \"gtalk\", \"comment on review created by me\")).thenReturn(true);\n    when(manager.isEnabled(ASSIGNEE_SIMON, \"email\", \"comment on review assigned to me\")).thenReturn(true);\n\n    service.start();\n    verify(emailChannel, timeout(2000)).deliver(notification, ASSIGNEE_SIMON);\n    verify(gtalkChannel, timeout(2000)).deliver(notification, CREATOR_EVGENY);\n    service.stop();\n\n    verify(emailChannel, never()).deliver(notification, CREATOR_EVGENY);\n    verify(gtalkChannel, never()).deliver(notification, ASSIGNEE_SIMON);\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Given:\n   * Simon wants to receive notifications by email on comments for reviews assigned to him or created by him.\n   *\n   * When:\n   * Freddy adds comment to review created by Simon and assigned to Simon.\n   * \n   * Then:\n   * Only one notification should be delivered to Simon by Email.\n   */\n  @Test\n  public void scenario1() {\n    doReturn(true).when(manager).isEnabled(USER_SIMON, \"email\", \"comment on review assigned to me\");\n    doReturn(true).when(manager).isEnabled(USER_SIMON, \"email\", \"comment on review created by me\");\n\n    Notification notification = mock(Notification.class);\n    creator = USER_SIMON;\n    assignee = USER_SIMON;\n\n    service.deliver(notification);\n\n    verify(emailChannel, atLeast(1)).getKey();\n    verify(gtalkChannel, atLeast(1)).getKey();\n    verify(emailChannel).deliver(notification, USER_SIMON);\n    verifyNoMoreInteractions(emailChannel);\n    verifyNoMoreInteractions(gtalkChannel);\n  }","id":31530,"modified_method":"/**\n   * Given:\n   * Simon wants to receive notifications by email on comments for reviews assigned to him or created by him.\n   *\n   * When:\n   * Freddy adds comment to review created by Simon and assigned to Simon.\n   * \n   * Then:\n   * Only one notification should be delivered to Simon by Email.\n   */\n  @Test\n  public void scenario1() {\n    setUpMocks(CREATOR_SIMON, ASSIGNEE_SIMON);\n    when(manager.isEnabled(CREATOR_SIMON, \"email\", \"comment on review created by me\")).thenReturn(true);\n    when(manager.isEnabled(ASSIGNEE_SIMON, \"email\", \"comment on review assigned to me\")).thenReturn(true);\n\n    service.start();\n    verify(emailChannel, timeout(2000)).deliver(notification, ASSIGNEE_SIMON);\n    service.stop();\n\n    verify(gtalkChannel, never()).deliver(notification, ASSIGNEE_SIMON);\n  }","commit_id":"d9ec502ee20a45003ab3d55884cd95e1adfc22f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Default constructor.\n     * \n     * @param listener {@link ClickListener} for buttons.\n     */\n    public ButtonPanel(ClickListener listener)\n    {\n        filterStylesCheckBox = new CheckBox(Strings.INSTANCE.importerFilterStylesCheckBoxCaption());\n        add(filterStylesCheckBox);\n        importButton = new Button(Strings.INSTANCE.importerImportButtonCaption());\n        importButton.addStyleName(\"xImporterImportButton\");\n        importButton.addClickListener(listener);\n        add(importButton);\n        cancelButton = new Button(Strings.INSTANCE.importerCancelButtonCaption());\n        cancelButton.addStyleName(\"xImporterCancelButton\");\n        cancelButton.addClickListener(listener);\n        add(cancelButton);\n    }","id":31531,"modified_method":"/**\n     * Default constructor.\n     * \n     * @param listener {@link ClickListener} for buttons.\n     */\n    public ButtonPanel(ClickListener listener)\n    {\n        filterStylesCheckBox = new CheckBox(Strings.INSTANCE.importerFilterStylesCheckBoxCaption());\n        add(filterStylesCheckBox, DockPanel.WEST);\n        setCellHorizontalAlignment(filterStylesCheckBox, HasHorizontalAlignment.ALIGN_LEFT);\n        setCellWidth(filterStylesCheckBox, STYLES_CHECKBOX_WIDTH);\n        cancelButton = new Button(Strings.INSTANCE.importerCancelButtonCaption());\n        cancelButton.addStyleName(\"xImporterCancelButton\");\n        cancelButton.addClickListener(listener);\n        add(cancelButton, DockPanel.EAST);\n        setCellHorizontalAlignment(cancelButton, HasHorizontalAlignment.ALIGN_RIGHT);\n        setCellWidth(cancelButton, BUTTON_WIDTH);\n        importButton = new Button(Strings.INSTANCE.importerImportButtonCaption());\n        importButton.addStyleName(\"xImporterImportButton\");\n        importButton.addClickListener(listener);\n        add(importButton, DockPanel.EAST);\n        setCellHorizontalAlignment(importButton, HasHorizontalAlignment.ALIGN_RIGHT);\n        setCellWidth(importButton, BUTTON_WIDTH);\n        setWidth(BUTTON_PANEL_WIDTH);\n    }","commit_id":"631e93563662a0218b1eab41927b19aebca75c51","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getIcon() {\n\n        return \"myIcon\";\n    }","id":31532,"modified_method":"public Resource getIcon() {\n\n        return FontAwesome.AMBULANCE;\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public Component createComponent() {\n\n        if (m_app == null) {\n            m_app = m_appConfig.getAppInstance();\n            return new AppViewComponent(m_app);\n        }\n        return null;\n    }","id":31533,"modified_method":"public Component createComponent() {\n\n        if (m_app == null) {\n            m_app = m_appConfig.getAppInstance();\n            CmsAppViewLayout layout = new CmsAppViewLayout();\n            layout.setMenu(createMenu());\n\n            layout.addStyleName(ValoTheme.UI_WITH_MENU);\n            layout.getAppContainer().addComponent(m_app);\n            return layout;\n        }\n        return null;\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public CmsAppView(I_CmsWorkplaceAppConfiguration appConfig) {\n\n        m_appConfig = appConfig;\n    }","id":31534,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param appConfig the app configuration\n     */\n    public CmsAppView(I_CmsWorkplaceAppConfiguration appConfig) {\n\n        m_appConfig = appConfig;\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void enter(ViewChangeEvent event) {\n\n        String newState = event.getParameters();\n        if (newState.startsWith(NavigationState.PARAM_SEPARATOR)) {\n            newState = newState.substring(1);\n        }\n        m_app.onStateChange(newState);\n    }","id":31535,"modified_method":"/**\n     * @see com.vaadin.navigator.View#enter(com.vaadin.navigator.ViewChangeListener.ViewChangeEvent)\n     */\n    public void enter(ViewChangeEvent event) {\n\n        String newState = event.getParameters();\n        if (newState.startsWith(NavigationState.PARAM_SEPARATOR)) {\n            newState = newState.substring(1);\n        }\n        m_app.onStateChange(newState);\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"protected Component createMenu() {\n\n        VerticalLayout result = new VerticalLayout();\n        result.addComponent(new Label(\"Menu\"));\n        Button homeButton = new Button(\"Home\");\n        result.addComponent(homeButton);\n        homeButton.addClickListener(new ClickListener() {\n\n            public void buttonClick(ClickEvent event) {\n\n                CmsAppWorkplaceUi ui = getWorkplaceUi();\n                ui.showHome();\n            }\n        });\n        return result;\n\n    }","id":31536,"modified_method":"/**\n     * Creates the menu component.<p>\n     * \n     * @return the menu\n     */\n    protected Component createMenu() {\n\n        CssLayout menu = new CssLayout();\n        final Label title = new Label(\"<h3>OpenCms <strong>\"\n            + m_appConfig.getName(getWorkplaceUi().getLocale())\n            + \"<\/strong><\/h3>\", ContentMode.HTML);\n        title.setSizeUndefined();\n        title.addStyleName(\"valo-menu-title\");\n        menu.addComponent(title);\n        CssLayout menuItemsLayout = new CssLayout();\n        menuItemsLayout.setPrimaryStyleName(\"valo-menuitems\");\n        menu.addComponent(menuItemsLayout);\n        CmsAppWorkplaceUi ui = (CmsAppWorkplaceUi)A_CmsUI.get();\n        for (final I_CmsMenuItem item : ui.getMenuItems()) {\n            Button button = new Button(item.getDisplayName(getWorkplaceUi().getLocale()), item.getIcon());\n            button.setPrimaryStyleName(\"valo-menu-item\");\n            menuItemsLayout.addComponent(button);\n            button.addClickListener(new ClickListener() {\n\n                private static final long serialVersionUID = 1L;\n\n                public void buttonClick(ClickEvent event) {\n\n                    item.executeAction();\n                }\n            });\n        }\n\n        return menu;\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"protected Component createAppIconWidget(final I_CmsWorkplaceAppConfiguration appConfig, final Locale locale) {\n\n        Button button = new Button(appConfig.getName(locale));\n        button.addClickListener(new ClickListener() {\n\n            public void buttonClick(ClickEvent event) {\n\n                CmsAppWorkplaceUi ui = (CmsAppWorkplaceUi)A_CmsUI.get();\n                ui.showApp(appConfig);\n            }\n        });\n        return button;\n    }","id":31537,"modified_method":"protected Component createAppIconWidget(final I_CmsWorkplaceAppConfiguration appConfig, final Locale locale) {\n\n        Button button = new Button(appConfig.getName(locale));\n        button.addClickListener(new ClickListener() {\n\n            public void buttonClick(ClickEvent event) {\n\n                CmsAppWorkplaceUi ui = (CmsAppWorkplaceUi)A_CmsUI.get();\n                ui.showApp(appConfig);\n            }\n        });\n        Resource icon = appConfig.getIcon();\n        if (icon != null) {\n            button.setIcon(icon);\n        }\n        return button;\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public String getIcon() {\n\n        // TODO Auto-generated method stub\n        return null;\n    }","id":31538,"modified_method":"public Resource getIcon() {\n\n        return FontAwesome.USER;\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public String getIcon() {\n\n        // TODO Auto-generated method stub\n        return null;\n    }","id":31539,"modified_method":"public Resource getIcon() {\n\n        return FontAwesome.AMBULANCE;\n    }","commit_id":"b0c6d040ad741ae24628cb46ac8421a93b269a5d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@BeforeClass\n    public static void init() {\n        Config config = new Config();\n        hz = Hazelcast.newHazelcastInstance(config);\n        ss = new SerializationServiceImpl(0);\n        dataKey = ss.toData(name);\n    }","id":31540,"modified_method":"@BeforeClass\n    public static void init() {\n        Config config = new Config();\n        hz = Hazelcast.newHazelcastInstance(config);\n\n        HazelcastInstance hz1 = Hazelcast.newHazelcastInstance(config);\n        HazelcastInstance hz2 = Hazelcast.newHazelcastInstance(config);\n\n        ss = new SerializationServiceImpl(0);\n        dataKey = ss.toData(name);\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testAddAll() throws IOException {\n\n        List<Data> list = new ArrayList<Data>();\n        list.add(ss.toData(\"item1\"));\n        list.add(ss.toData(\"item2\"));\n        list.add(ss.toData(\"item3\"));\n        list.add(ss.toData(\"item4\"));\n\n\n\n        c.send(new AddAllRequest(setProxyId, dataKey, getThreadId(), list));\n        Object result = c.receive();\n        assertTrue((Boolean) result);\n        int size = hz.getSet(name).size();\n        assertEquals(size, list.size());\n\n    }","id":31541,"modified_method":"@Test\n    public void testAddAll() throws IOException {\n\n        List<Data> list = new ArrayList<Data>();\n        list.add(ss.toData(\"item1\"));\n        list.add(ss.toData(\"item2\"));\n        list.add(ss.toData(\"item3\"));\n        list.add(ss.toData(\"item4\"));\n\n\n\n        c.send(new AddAllRequest(listProxyId, dataKey, getThreadId(), list));\n        Object result = c.receive();\n        assertTrue((Boolean) result);\n        int size = hz.getList(name).size();\n        assertEquals(size, list.size());\n\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@After\n    public void closeClient() throws IOException {\n        hz.getMultiMap(name).clear();\n        hz.getSet(name).clear();\n        c.close();\n    }","id":31542,"modified_method":"@After\n    public void closeClient() throws IOException {\n        hz.getMultiMap(name).clear();\n        hz.getList(name).clear();\n        c.close();\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public PortableFactory createFactory() {\n        return new PortableFactory() {\n            public Portable create(int classId) {\n                switch (classId){\n                    case ADD_ALL:\n                        return new AddAllRequest();\n                    case CLEAR:\n                        return new ClearRequest();\n                }\n                return null;\n            }\n        };\n    }","id":31543,"modified_method":"public PortableFactory createFactory() {\n        return new PortableFactory() {\n            public Portable create(int classId) {\n                switch (classId){\n                    case ADD_ALL:\n                        return new AddAllRequest();\n                    case CLEAR:\n                        return new ClearRequest();\n                    case COMPARE_AND_REMOVE:\n                        return new CompareAndRemoveRequest();\n                    case CONTAINS_ALL:\n                        return new ContainsAllRequest();\n                    case CONTAINS_ENTRY:\n                        return new ContainsEntryRequest();\n                    case CONTAINS:\n                        return new ContainsRequest();\n                    case COUNT:\n                        return new CountRequest();\n                    case ENTRY_SET:\n                        return new EntrySetRequest();\n                    case GET_ALL:\n                        return new GetAllRequest();\n                    case GET:\n                        return new GetRequest();\n                    case INDEX_OF:\n                        return new IndexOfRequest();\n                    case KEY_SET:\n                        return new KeySetRequest();\n                    case PUT:\n                        return new PutRequest();\n                    case REMOVE_ALL:\n                        return new RemoveAllRequest();\n                    case REMOVE_INDEX:\n                        return new RemoveIndexRequest();\n                    case REMOVE:\n                        return new RemoveRequest();\n                    case SET:\n                        return new SetRequest();\n                    case SIZE:\n                        return new SizeRequest();\n                    case VALUES:\n                        return new ValuesRequest();\n                }\n                return null;\n            }\n        };\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() throws Exception {\n        CollectionWrapper wrapper = getCollectionWrapper();\n        if (wrapper == null){\n            response = false;\n            return;\n        }\n        idSet = new HashSet<Long>();\n        for (Data data : dataList) {\n            Object obj = isBinary() ? data : toObject(data);\n            Iterator<CollectionRecord> iter = wrapper.getCollection().iterator();\n            while (iter.hasNext()) {\n                CollectionRecord record = iter.next();\n                boolean equals = obj.equals(record.getObject());\n                if ((equals && !retain) || (!equals && retain)) {\n                    idSet.add(record.getRecordId());\n                    iter.remove();\n                }\n            }\n        }\n        response = !idSet.isEmpty();\n    }","id":31544,"modified_method":"public void run() throws Exception {\n        CollectionWrapper wrapper = getCollectionWrapper();\n        if (wrapper == null){\n            response = false;\n            return;\n        }\n        idSet = new HashSet<Long>();\n        List objList = dataList;\n        if (!isBinary()){\n            objList = new ArrayList(dataList.size());\n            for (Data data: dataList){\n                objList.add(toObject(data));\n            }\n        }\n        Iterator<CollectionRecord> iter = wrapper.getCollection().iterator();\n        while (iter.hasNext()) {\n            CollectionRecord record = iter.next();\n            boolean contains = objList.contains(record.getObject());\n            if ((contains && !retain) || (!contains && retain)) {\n                idSet.add(record.getRecordId());\n                iter.remove();\n            }\n        }\n        response = !idSet.isEmpty();\n        if (wrapper.getCollection().isEmpty()){\n            removeCollection();\n        }\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Set<Map.Entry<Data, Data>> getDataEntrySet(NodeEngine nodeEngine) {\n        Set<Map.Entry<Data, Data>> entrySet = new HashSet<Map.Entry<Data, Data>>();\n        for (Map.Entry<Data, Collection<Data>> entry : map.entrySet()) {\n            Data key = entry.getKey();\n            Collection<Data> coll = entry.getValue();\n            for (Data data : coll) {\n                entrySet.add(new AbstractMap.SimpleEntry<Data, Data>(key, data));\n            }\n        }\n        return entrySet;\n    }","id":31545,"modified_method":"public Set<Map.Entry<Data, Data>> getDataEntrySet() {\n        Set<Map.Entry<Data, Data>> entrySet = new HashSet<Map.Entry<Data, Data>>();\n        for (Map.Entry<Data, Collection<Data>> entry : map.entrySet()) {\n            Data key = entry.getKey();\n            Collection<Data> coll = entry.getValue();\n            for (Data data : coll) {\n                entrySet.add(new AbstractMap.SimpleEntry<Data, Data>(key, data));\n            }\n        }\n        return entrySet;\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() throws Exception {\n        List<CollectionRecord> list = (List<CollectionRecord>) getCollectionWrapper();\n        try {\n            CollectionRecord record = list.get(index);\n            response = isBinary() ? (Data) record.getObject() : toData(record.getObject());\n        } catch (IndexOutOfBoundsException e) {\n            response = e;\n        }\n\n    }","id":31546,"modified_method":"public void run() throws Exception {\n        CollectionWrapper wrapper = getCollectionWrapper();\n        List<CollectionRecord> list = (List<CollectionRecord>)wrapper.getCollection();\n        try {\n            CollectionRecord record = list.get(index);\n            response = isBinary() ? (Data) record.getObject() : toData(record.getObject());\n        } catch (IndexOutOfBoundsException e) {\n            response = e;\n        }\n\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() throws Exception {\n        List<CollectionRecord> list = (List<CollectionRecord>) getOrCreateCollectionWrapper();\n        list.remove(index);\n        response = true;\n    }","id":31547,"modified_method":"public void run() throws Exception {\n        List<CollectionRecord> list = (List<CollectionRecord>) getOrCreateCollectionWrapper().getCollection();\n        list.remove(index);\n        response = true;\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() throws Exception {\n        List<CollectionRecord> list = (List<CollectionRecord>) getOrCreateCollectionWrapper();\n        try {\n            CollectionRecord record = list.remove(index);\n            response = record == null ? null : record.getObject();\n        } catch (IndexOutOfBoundsException e) {\n            response = e;\n        }\n    }","id":31548,"modified_method":"public void run() throws Exception {\n        List<CollectionRecord> list = (List<CollectionRecord>) getOrCreateCollectionWrapper().getCollection();\n        try {\n            CollectionRecord record = list.remove(index);\n            response = record == null ? null : record.getObject();\n        } catch (IndexOutOfBoundsException e) {\n            response = e;\n        }\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() throws Exception {\n        CollectionRecord record = new CollectionRecord(recordId, isBinary() ? value : toObject(value));\n        List<CollectionRecord> list = (List<CollectionRecord>) getOrCreateCollectionWrapper();\n        list.set(index, record);\n        response = true;\n    }","id":31549,"modified_method":"public void run() throws Exception {\n        CollectionRecord record = new CollectionRecord(recordId, isBinary() ? value : toObject(value));\n        List<CollectionRecord> list = (List<CollectionRecord>) getOrCreateCollectionWrapper().getCollection();\n        list.set(index, record);\n        response = true;\n    }","commit_id":"379b1b9111d375a7b529c99749da5e98fd436a76","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n   * Processes import statements to obtain class paths of contributed\n   * libraries. This would be needed for compilation check. Also, adds\n   * stuff(jar files, class files, candy) from the code folder. And it looks\n   * messed up.\n   */\n  protected void prepareCompilerClasspath() {\n    if (!loadCompClass) {\n      return;\n    }\n\n    synchronized (classpathJars) {\n      // log(\"1..\");\n      classpathJars = new ArrayList<URL>();\n      String entry = \"\";\n      boolean codeFolderChecked = false;\n      for (ImportStatement impstat : programImports) {\n        String item = impstat.getImportName();\n        int dot = item.lastIndexOf('.');\n        entry = (dot == -1) ? item : item.substring(0, dot);\n\n        entry = entry.substring(6).trim();\n        // log(\"Entry--\" + entry);\n        if (ignorableImport(entry)) {\n          // log(\"Ignoring: \" + entry);\n          continue;\n        }\n        Library library = null;\n\n        // Try to get the library classpath and add it to the list\n        try {\n          library = editor.getMode().getLibrary(entry);\n          // log(\"lib->\" + library.getClassPath() + \"<-\");\n          String libraryPath[] = PApplet.split(library.getClassPath()\n              .substring(1).trim(), File.pathSeparatorChar);\n          for (int i = 0; i < libraryPath.length; i++) {\n            // log(entry + \" ::\"\n            // + new File(libraryPath[i]).toURI().toURL());\n            classpathJars.add(new File(libraryPath[i]).toURI().toURL());\n          }\n          // log(\"-- \");\n          // classpath[count] = (new File(library.getClassPath()\n          // .substring(1))).toURI().toURL();\n          // log(\"  found \");\n          // log(library.getClassPath().substring(1));\n        } catch (Exception e) {\n          if (library == null && !codeFolderChecked) {\n            // log(1);\n            // Look around in the code folder for jar files\n            if (editor.getSketch().hasCodeFolder()) {\n              File codeFolder = editor.getSketch().getCodeFolder();\n\n              // get a list of .jar files in the \"code\" folder\n              // (class files in subfolders should also be picked up)\n              String codeFolderClassPath = Base.contentsToClassPath(codeFolder);\n              codeFolderChecked = true;\n              if (codeFolderClassPath.equalsIgnoreCase(\"\")) {\n                System.err.println(\"Cannot find \\\"\"\n                    + entry\n                    + \"\\\" library. Line: \"\n                    + impstat.getLineNumber()\n                    + \" in tab: \"\n                    + editor.getSketch().getCode(impstat.getTab()).getPrettyName());\n                System.out.println(\"Please make sure that the library is present in <sketchbook \"\n                        + \"folder>/libraries folder or in the code folder of your sketch\");\n\n              }\n              else {\n                String codeFolderPath[] =\n                  PApplet.split(codeFolderClassPath.substring(1).trim(),\n                                File.pathSeparatorChar);\n                try {\n                  for (String pathItem : codeFolderPath) {\n                    classpathJars.add(new File(pathItem).toURI().toURL());\n                  }\n\n                } catch (Exception e2) {\n                  e2.printStackTrace();\n                }\n              }\n            } else {\n              System.err.println(\"Experimental Mode: Yikes! Can't find \\\"\"\n                  + entry\n                  + \"\\\" library! Line: \"\n                  + impstat.getLineNumber()\n                  + \" in tab: \"\n                  + editor.getSketch().getCode(impstat.getTab())\n                      .getPrettyName());\n              System.out\n                  .println(\"Please make sure that the library is present in <sketchbook \"\n                      + \"folder>/libraries folder or in the code folder of your sketch\");\n            }\n\n          } else {\n            System.err\n                .println(\"Yikes! There was some problem in prepareImports(): \"\n                    + e);\n            System.err.println(\"I was processing: \" + entry);\n\n            // e.printStackTrace();\n          }\n        }\n\n      }\n    }\n    new Thread(new Runnable() {\n      public void run() {\n        astGenerator.loadJars(); // update jar file for completion lookup\n      }\n    }).start();\n  }","id":31550,"modified_method":"/**\n   * Processes import statements to obtain class paths of contributed\n   * libraries. This would be needed for compilation check. Also, adds\n   * stuff(jar files, class files, candy) from the code folder. And it looks\n   * messed up.\n   */\n  protected void prepareCompilerClasspath() {\n    if (!loadCompClass) {\n      return;\n    }\n\n    synchronized (classpathJars) {\n      // log(\"1..\");\n      classpathJars = new ArrayList<URL>();\n      String entry = \"\";\n      boolean codeFolderChecked = false;\n      for (ImportStatement impstat : programImports) {\n        String item = impstat.getImportName();\n        int dot = item.lastIndexOf('.');\n        entry = (dot == -1) ? item : item.substring(0, dot);\n\n        entry = entry.substring(6).trim();\n        // log(\"Entry--\" + entry);\n        if (ignorableImport(entry)) {\n          // log(\"Ignoring: \" + entry);\n          continue;\n        }\n        Library library = null;\n\n        // Try to get the library classpath and add it to the list\n        try {\n          library = editor.getMode().getLibrary(entry);\n          String[] libraryPath =\n            PApplet.split(library.getClassPath().substring(1).trim(),\n                          File.pathSeparatorChar);\n          for (String pathItem : libraryPath) {\n            classpathJars.add(new File(pathItem).toURI().toURL());\n          }\n        } catch (Exception e) {\n          if (library == null && !codeFolderChecked) {\n            // Look around in the code folder for jar files\n            if (editor.getSketch().hasCodeFolder()) {\n              File codeFolder = editor.getSketch().getCodeFolder();\n\n              // get a list of .jar files in the \"code\" folder\n              // (class files in subfolders should also be picked up)\n              String codeFolderClassPath = Base.contentsToClassPath(codeFolder);\n              codeFolderChecked = true;\n              // huh? doesn't this mean .length() == 0? [fry]\n              if (codeFolderClassPath.equalsIgnoreCase(\"\")) {\n                System.err.format(\"Cannot find \\\"%s\\\" library. Line %d in tab %s%n\",\n                                  entry, impstat.getLineNumber(),\n                                  editor.getSketch().getCode(impstat.getTab()).getPrettyName());\n                System.err.println(\"Make sure that the library is installed properly.\");\n\n              } else {\n                String codeFolderPath[] =\n                  PApplet.split(codeFolderClassPath.substring(1).trim(),\n                                File.pathSeparatorChar);\n                try {\n                  for (String pathItem : codeFolderPath) {\n                    classpathJars.add(new File(pathItem).toURI().toURL());\n                  }\n                } catch (Exception e2) {\n                  e2.printStackTrace();\n                }\n              }\n            } else {\n              System.err.format(\"Cannot find \\\"%s\\\" library. Line %d in tab %s%n\",\n                                entry, impstat.getLineNumber(),\n                                editor.getSketch().getCode(impstat.getTab()).getPrettyName());\n            }\n\n          } else {\n            new Exception(\"Error while handling '\" + entry + \"'\", e).printStackTrace();\n          }\n        }\n      }\n    }\n\n    new Thread(new Runnable() {\n      public void run() {\n        astGenerator.loadJars(); // update jar file for completion lookup\n      }\n    }).start();\n  }","commit_id":"c2dbc71a055c9d7ff8eae224b6ecf7d17f589140","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Ignore processing packages, java.*.*. etc.\n   *\n   * @param packageName\n   * @return boolean\n   */\n  protected boolean ignorableImport(String packageName) {\n    // packageName.startsWith(\"processing.\")\n    // ||\n    if (packageName.startsWith(\"java.\") || packageName.startsWith(\"javax.\")) {\n      return true;\n    }\n    return false;\n  }","id":31551,"modified_method":"/**\n   * Ignore processing packages, java.*.*. etc.\n   */\n  protected boolean ignorableImport(String packageName) {\n    return (packageName.startsWith(\"java.\") ||\n            packageName.startsWith(\"javax.\"));\n  }","commit_id":"c2dbc71a055c9d7ff8eae224b6ecf7d17f589140","url":"https://github.com/processing/processing"},{"original_method":"@Override\n  public String getDescription() {\n    return \"Calls a \" + ElementType.SERVICE.getPrettyName() + \"endpoint.\" +\n           \"The header is formatted as \\\"{'key' : 'value', ...}\\\" and the body is a String.\";\n  }","id":31552,"modified_method":"@Override\n  public String getDescription() {\n    return String.format(\"Calls a %s endpoint. The header is formatted as \\\"{'key':'value', ...}\\\"\" +\n                         \" and the body is a String.\", ElementType.SERVICE.getPrettyName());\n  }","commit_id":"6ebaa880a7bfc081f7bb9384d100d1ba85ecfc1a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DefaultCommands(Injector injector) {\n    this.commands = ImmutableList.<Command>builder()\n      .add(injector.getInstance(ExitCommand.class))\n      .add(injector.getInstance(CallProcedureCommand.class))\n      .add(injector.getInstance(ConnectCommand.class))\n      .add(injector.getInstance(CreateDatasetInstanceCommand.class))\n      .add(injector.getInstance(CreateStreamCommand.class))\n      .add(injector.getInstance(DeleteAppCommand.class))\n      .add(injector.getInstance(DeleteDatasetInstanceCommand.class))\n      .add(injector.getInstance(DeleteDatasetModuleCommand.class))\n      .add(injector.getInstance(DeployAppCommand.class))\n      .add(injector.getInstance(DeployDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeAppCommand.class))\n      .add(injector.getInstance(DescribeDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeDatasetTypeCommand.class))\n      .add(injector.getInstance(DescribeStreamCommand.class))\n      .add(injector.getInstance(ExecuteQueryCommand.class))\n      .addAll(injector.getInstance(GetProgramRunsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramInstancesCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLiveInfoCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLogsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramStatusCommandSet.class).getCommands())\n      .add(injector.getInstance(GetStreamEventsCommand.class))\n      .add(injector.getInstance(ListAllProgramsCommand.class))\n      .add(injector.getInstance(ListAppsCommand.class))\n      .add(injector.getInstance(ListDatasetInstancesCommand.class))\n      .add(injector.getInstance(ListDatasetModulesCommand.class))\n      .add(injector.getInstance(ListDatasetTypesCommand.class))\n      .addAll(injector.getInstance(ListProgramsCommandSet.class).getCommands())\n      .add(injector.getInstance(ListStreamsCommand.class))\n      .add(injector.getInstance(SendStreamEventCommand.class))\n      .addAll(injector.getInstance(SetProgramInstancesCommandSet.class).getCommands())\n      .add(injector.getInstance(SetStreamTTLCommand.class))\n      .addAll(injector.getInstance(StartProgramCommandSet.class).getCommands())\n      .addAll(injector.getInstance(StopProgramCommandSet.class).getCommands())\n      .add(injector.getInstance(TruncateDatasetInstanceCommand.class))\n      .add(injector.getInstance(TruncateStreamCommand.class))\n      .add(injector.getInstance(CallServiceCommand.class))\n      .add(injector.getInstance(GetServiceEndpointsCommand.class))\n      .build();\n  }","id":31553,"modified_method":"@Inject\n  public DefaultCommands(Injector injector) {\n    this.commands = ImmutableList.<Command>builder()\n      .add(injector.getInstance(VersionCommand.class))\n      .add(injector.getInstance(ExitCommand.class))\n      .add(injector.getInstance(CallProcedureCommand.class))\n      .add(injector.getInstance(ConnectCommand.class))\n      .add(injector.getInstance(CreateDatasetInstanceCommand.class))\n      .add(injector.getInstance(CreateStreamCommand.class))\n      .add(injector.getInstance(DeleteAppCommand.class))\n      .add(injector.getInstance(DeleteDatasetInstanceCommand.class))\n      .add(injector.getInstance(DeleteDatasetModuleCommand.class))\n      .add(injector.getInstance(DeployAppCommand.class))\n      .add(injector.getInstance(DeployDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeAppCommand.class))\n      .add(injector.getInstance(DescribeDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeDatasetTypeCommand.class))\n      .add(injector.getInstance(DescribeStreamCommand.class))\n      .add(injector.getInstance(ExecuteQueryCommand.class))\n      .addAll(injector.getInstance(GetProgramRunsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramInstancesCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLiveInfoCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLogsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramStatusCommandSet.class).getCommands())\n      .add(injector.getInstance(GetStreamEventsCommand.class))\n      .add(injector.getInstance(ListAllProgramsCommand.class))\n      .add(injector.getInstance(ListAppsCommand.class))\n      .add(injector.getInstance(ListDatasetInstancesCommand.class))\n      .add(injector.getInstance(ListDatasetModulesCommand.class))\n      .add(injector.getInstance(ListDatasetTypesCommand.class))\n      .addAll(injector.getInstance(ListProgramsCommandSet.class).getCommands())\n      .add(injector.getInstance(ListStreamsCommand.class))\n      .add(injector.getInstance(SendStreamEventCommand.class))\n      .addAll(injector.getInstance(SetProgramInstancesCommandSet.class).getCommands())\n      .add(injector.getInstance(SetStreamTTLCommand.class))\n      .addAll(injector.getInstance(StartProgramCommandSet.class).getCommands())\n      .addAll(injector.getInstance(StopProgramCommandSet.class).getCommands())\n      .add(injector.getInstance(TruncateDatasetInstanceCommand.class))\n      .add(injector.getInstance(TruncateStreamCommand.class))\n      .add(injector.getInstance(CallServiceCommand.class))\n      .add(injector.getInstance(GetServiceEndpointsCommand.class))\n      .build();\n  }","commit_id":"6ebaa880a7bfc081f7bb9384d100d1ba85ecfc1a","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void main(String[] args) throws Exception {\n    String hostname = Objects.firstNonNull(System.getenv(Constants.EV_HOSTNAME), \"localhost\");\n    PrintStream output = System.out;\n\n    CLIConfig config = new CLIConfig(hostname);\n    GenerateCLIDocsTable generateCLIDocsTable = new GenerateCLIDocsTable(config);\n    generateCLIDocsTable.printDocsCommand.execute(null, output);\n  }","id":31554,"modified_method":"public static void main(String[] args) throws Exception {\n    PrintStream output = System.out;\n\n    CLIConfig config = new CLIConfig(null);\n    GenerateCLIDocsTable generateCLIDocsTable = new GenerateCLIDocsTable(config);\n    generateCLIDocsTable.printDocsCommand.execute(null, output);\n  }","commit_id":"6ebaa880a7bfc081f7bb9384d100d1ba85ecfc1a","url":"https://github.com/caskdata/cdap"},{"original_method":"public GenerateCLIDocsTable(final CLIConfig cliConfig) throws URISyntaxException, IOException {\n    this.printDocsCommand = new Command() {\n\n      @Override\n      public void execute(Arguments arguments, PrintStream output) throws Exception {\n        List<Command> commandList = com.googlecode.concurrenttrees.common.Iterables.toList(commands);\n        Collections.sort(commandList, new Comparator<Command>() {\n          @Override\n          public int compare(Command command, Command command2) {\n            return command.getPattern().compareTo(command2.getPattern());\n          }\n        });\n        for (Command command : commandList) {\n          output.printf(\"   ``%s``,%s\\n\", command.getPattern(), command.getDescription());\n        }\n      }\n\n      @Override\n      public String getPattern() {\n        return \"null\";\n      }\n\n      @Override\n      public String getDescription() {\n        return \"null\";\n      }\n    };\n\n    Injector injector = Guice.createInjector(\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(CLIConfig.class).toInstance(cliConfig);\n          bind(ClientConfig.class).toInstance(cliConfig.getClientConfig());\n          bind(CConfiguration.class).toInstance(CConfiguration.create());\n        }\n      }\n    );\n\n    this.commands = Iterables.concat(new DefaultCommands(injector).get(),\n                                     ImmutableList.<Command>of(new HelpCommand(null, null)));\n  }","id":31555,"modified_method":"public GenerateCLIDocsTable(final CLIConfig cliConfig) throws URISyntaxException, IOException {\n    Injector injector = Guice.createInjector(\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(CLIConfig.class).toInstance(cliConfig);\n          bind(ClientConfig.class).toInstance(cliConfig.getClientConfig());\n          bind(CConfiguration.class).toInstance(CConfiguration.create());\n        }\n      }\n    );\n    Iterable<Command> commands = Iterables.concat(new DefaultCommands(injector).get(),\n                                                  ImmutableList.<Command>of(new HelpCommand(null, null)));\n    this.printDocsCommand = new PrintCLIDocsTableCommand(commands);\n  }","commit_id":"6ebaa880a7bfc081f7bb9384d100d1ba85ecfc1a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String getDescription() {\n    return \"Gets events from a \" + ElementType.STREAM.getPrettyName() + \". \" +\n      \"The time format for <start-time> and <end-time> could be timestamp in milliseconds or \" +\n      \"relative time in the form of [+\\\\-][0-9]+[hms]. \" +\n      \"For <start-time>, it is relative to current time, \" +\n      \"while for <end-time>, it's relative to start time. \" +\n      \"Special constants \\\"min\\\" and \\\"max\\\" can also be used to represent 0 and max timestamp respectively.\";\n  }","id":31556,"modified_method":"@Override\n  public String getDescription() {\n    return \"Gets events from a \" + ElementType.STREAM.getPrettyName() + \". \" +\n      \"The time format for <start-time> and <end-time> can be a timestamp in milliseconds or \" +\n      \"a relative time in the form of [+\\\\-][0-9]+[hms]. \" +\n      \"For <start-time>, it is relative to current time; \" +\n      \"for <end-time>, it is relative to start time. \" +\n      \"Special constants \\\"min\\\" and \\\"max\\\" can also be used to represent \\\"0\\\" and \\\"max timestamp\\\" respectively.\";\n  }","commit_id":"6ebaa880a7bfc081f7bb9384d100d1ba85ecfc1a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void checkNamedArgs(GrNamedArgument[] namedArguments, boolean forArgList) {\n    MultiMap<String, GrArgumentLabel> map = new MultiMap<String, GrArgumentLabel>();\n    for (GrNamedArgument element : namedArguments) {\n      final GrArgumentLabel label = element.getLabel();\n      if (label != null) {\n        final String name = label.getName();\n        if (name != null) {\n          map.putValue(name, label);\n        }\n      }\n    }\n\n    for (String key : map.keySet()) {\n      final List<GrArgumentLabel> arguments = (List<GrArgumentLabel>)map.get(key);\n      if (arguments.size() > 1) {\n        for (int i = 1; i < arguments.size(); i++) {\n          final GrArgumentLabel label = arguments.get(i);\n          if (forArgList) {\n            myHolder.createErrorAnnotation(label, GroovyBundle.message(\"duplicated.named.parameter\", key));\n          }\n          else {\n            myHolder.createWarningAnnotation(label, GroovyBundle.message(\"duplicate.element.in.the.map\"));\n          }\n        }\n      }\n    }\n  }","id":31557,"modified_method":"private void checkNamedArgs(GrNamedArgument[] namedArguments, boolean forArgList) {\n    highlightNamedArgs(namedArguments);\n\n    MultiMap<String, GrArgumentLabel> map = new MultiMap<String, GrArgumentLabel>();\n    for (GrNamedArgument element : namedArguments) {\n      final GrArgumentLabel label = element.getLabel();\n      if (label != null) {\n        final String name = label.getName();\n        if (name != null) {\n          map.putValue(name, label);\n        }\n      }\n    }\n\n    for (String key : map.keySet()) {\n      final List<GrArgumentLabel> arguments = (List<GrArgumentLabel>)map.get(key);\n      if (arguments.size() > 1) {\n        for (int i = 1; i < arguments.size(); i++) {\n          final GrArgumentLabel label = arguments.get(i);\n          if (forArgList) {\n            myHolder.createErrorAnnotation(label, GroovyBundle.message(\"duplicated.named.parameter\", key));\n          }\n          else {\n            myHolder.createWarningAnnotation(label, GroovyBundle.message(\"duplicate.element.in.the.map\"));\n          }\n        }\n      }\n    }\n  }","commit_id":"bb6188284e45cdd390de450abf2108fd87a7a55d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void highlightAnnotation(AnnotationHolder holder, PsiElement refElement, GroovyResolveResult result) {\n    PsiElement element = result.getElement();\n    PsiElement parent = refElement.getParent();\n    if (element instanceof PsiClass) {\n      if (((PsiClass)element).isAnnotationType() && !(parent instanceof GrImportStatement)) {\n        Annotation annotation = holder.createInfoAnnotation(parent, null);\n        annotation.setTextAttributes(DefaultHighlighter.ANNOTATION);\n        GroovyPsiElement context = result.getCurrentFileResolveContext();\n        if (context instanceof GrImportStatement) {\n          annotation = holder.createInfoAnnotation(((GrImportStatement)context).getImportReference(), null);\n          annotation.setTextAttributes(DefaultHighlighter.ANNOTATION);\n        }\n      } else {\n        highligtClassReference(holder, refElement);\n      }\n    }\n  }","id":31558,"modified_method":"private static void highlightAnnotation(AnnotationHolder holder, PsiElement refElement, GroovyResolveResult result) {\n    PsiElement element = result.getElement();\n    PsiElement parent = refElement.getParent();\n    if (element instanceof PsiClass) {\n      if (((PsiClass)element).isAnnotationType() && !(parent instanceof GrImportStatement)) {\n        Annotation annotation = holder.createInfoAnnotation(parent, null);\n        annotation.setTextAttributes(DefaultHighlighter.ANNOTATION);\n        GroovyPsiElement context = result.getCurrentFileResolveContext();\n        if (context instanceof GrImportStatement) {\n          final GrCodeReferenceElement importReference = ((GrImportStatement)context).getImportReference();\n          LOG.assertTrue(importReference != null);\n          annotation = holder.createInfoAnnotation(importReference, null);\n          annotation.setTextAttributes(DefaultHighlighter.ANNOTATION);\n        }\n      } else {\n        highligtClassReference(holder, refElement);\n      }\n    }\n  }","commit_id":"bb6188284e45cdd390de450abf2108fd87a7a55d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    registerUsedImport(refExpr, resolveResult);\n    PsiElement resolved = resolveResult.getElement();\n    if (resolved != null) {\n      if (resolved instanceof PsiMember) {\n        highlightMemberResolved(holder, refExpr, ((PsiMember) resolved));\n      }\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      }\n      if (!resolveResult.isStaticsOK() && resolved instanceof PsiModifierListOwner) {\n        final String key = ((PsiModifierListOwner) resolved).hasModifierProperty(PsiModifier.STATIC) ?\n            \"cannot.reference.static\" :\n            \"cannot.reference.nonstatic\";\n        String message = GroovyBundle.message(key, refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (refExpr.getParent() instanceof GrCall) {\n        if (resolved instanceof PsiMethod && resolved.getUserData(GrMethod.BUILDER_METHOD) == null) {\n          checkMethodApplicability(resolveResult, refExpr, holder);\n        } else {\n          checkClosureApplicability(resolveResult, refExpr, holder);\n        }\n      }\n      if (isAssignmentLHS(refExpr) || resolved instanceof PsiPackage) return;\n    } else {\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        if (isAssignmentLHS(refExpr)) return;\n\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n          return;\n        }\n      }\n    }\n\n    if (refExpr.getType() == null) {\n      PsiElement refNameElement = refExpr.getReferenceNameElement();\n      PsiElement elt = refNameElement == null ? refExpr : refNameElement;\n      Annotation annotation = holder.createInfoAnnotation(elt, null);\n      if (resolved == null && refExpr.getQualifierExpression() == null) {\n        if (!(refExpr.getParent() instanceof GrCallExpression)) {\n          registerCreateClassByTypeFix(refExpr, annotation, false);\n        }\n        registerAddImportFixes(refExpr, annotation);\n      }\n\n      if (isNeedsAddDynPropertiesAnnotation(refExpr)) {\n        annotation.setTextAttributes(DefaultHighlighter.UNTYPED_ACCESS);\n        addDynPropertyAnnotation(annotation, refExpr);\n      }\n\n      //annotation.setEnforcedTextAttributes(new TextAttributes(Color.black, null, Color.black, EffectType.LINE_UNDERSCORE, 0));\n    }\n  }","id":31559,"modified_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    registerUsedImport(refExpr, resolveResult);\n    PsiElement resolved = resolveResult.getElement();\n    if (resolved != null) {\n      if (resolved instanceof PsiMember) {\n        highlightMemberResolved(holder, refExpr, ((PsiMember) resolved));\n      }\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      }\n      if (!resolveResult.isStaticsOK() && resolved instanceof PsiModifierListOwner) {\n        final String key = ((PsiModifierListOwner) resolved).hasModifierProperty(PsiModifier.STATIC) ?\n            \"cannot.reference.static\" :\n            \"cannot.reference.nonstatic\";\n        String message = GroovyBundle.message(key, refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (refExpr.getParent() instanceof GrCall) {\n        if (resolved instanceof PsiMethod && resolved.getUserData(GrMethod.BUILDER_METHOD) == null) {\n          checkMethodApplicability(resolveResult, refExpr, holder);\n        } else {\n          checkClosureApplicability(resolveResult, refExpr, holder);\n        }\n      }\n      if (isAssignmentLHS(refExpr) || resolved instanceof PsiPackage) return;\n    } else {\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        if (isAssignmentLHS(refExpr)) return;\n\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n          return;\n        }\n      }\n    }\n\n    if (refExpr.getType() == null) {\n      PsiElement refNameElement = refExpr.getReferenceNameElement();\n      PsiElement elt = refNameElement == null ? refExpr : refNameElement;\n      Annotation annotation = holder.createInfoAnnotation(elt, null);\n      if (resolved == null && refExpr.getQualifierExpression() == null) {\n        if (!(refExpr.getParent() instanceof GrCallExpression)) {\n          registerCreateClassByTypeFix(refExpr, annotation, false);\n        }\n        registerAddImportFixes(refExpr, annotation);\n      }\n\n//todo please, fix java.lang.IllegalArgumentException in GSP\n/*\n      if (isNeedsAddDynPropertiesAnnotation(refExpr)) {\n        addDynPropertyAnnotation(annotation, refExpr);\n      }\n*/\n      annotation.setTextAttributes(DefaultHighlighter.UNTYPED_ACCESS);\n\n      //annotation.setEnforcedTextAttributes(new TextAttributes(Color.black, null, Color.black, EffectType.LINE_UNDERSCORE, 0));\n    }\n  }","commit_id":"b353aca843ae03262634934268bbc43721d9d8fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n    if (element instanceof GrCodeReferenceElement) {\n      checkReferenceElement(holder, (GrCodeReferenceElement) element);\n    } else if (element instanceof GrReferenceExpression) {\n      checkReferenceExpression(holder, (GrReferenceExpression) element);\n    } else if (element instanceof GrTypeDefinition) {\n      final GrTypeDefinition typeDefinition = (GrTypeDefinition) element;\n      checkTypeDefinition(holder, typeDefinition);\n      checkTypeDefinitionModifiers(holder, typeDefinition);\n      final GrTypeDefinitionBody body = typeDefinition.getBody();\n      if (body != null) checkDuplicateMethod(body.getMethods(), holder);\n      checkImplementedMethodsOfClass(holder, typeDefinition);\n    } else if (element instanceof GrMethod) {\n      final GrMethod method = (GrMethod) element;\n      checkMethodDefinitionModifiers(holder, method);\n      checkInnerMethod(holder, method);\n      checkMethodReturnExpression(holder, method);\n      addOverrideGutter(holder, method);\n    } else if (element instanceof GrVariableDeclaration) {\n      checkVariableDeclaration(holder, (GrVariableDeclaration) element);\n    } else if (element instanceof GrVariable) {\n      if (element instanceof GrMember) highlightMember(holder, ((GrMember) element));\n      checkVariable(holder, (GrVariable) element);\n    } else if (element instanceof GrAssignmentExpression) {\n      checkAssignmentExpression((GrAssignmentExpression) element, holder);\n    } else if (element instanceof GrNamedArgument) {\n      checkCommandArgument((GrNamedArgument) element, holder);\n    } else if (element instanceof GrReturnStatement) {\n      checkReturnStatement((GrReturnStatement) element, holder);\n    } else if (element instanceof GrListOrMap) {\n      checkMap(((GrListOrMap) element).getNamedArguments(), holder);\n    } else if (element instanceof GrNewExpression) {\n      checkNewExpression(holder, (GrNewExpression) element);\n    } else if (element instanceof GrConstructorInvocation) {\n      checkConstructorInvocation(holder, (GrConstructorInvocation) element);\n    } else if (element instanceof GrPackageDefinition) {\n      //todo: if reference isn't resolved it construct package definition \n      checkPackageReference(holder, (GrPackageDefinition) element);\n    } else if (element instanceof GroovyFile) {\n      final GroovyFile file = (GroovyFile) element;\n      if (file.isScript()) {\n        checkScriptDuplicateMethod(file.getTopLevelDefinitions(), holder);\n      }\n      if (DomainClassUtils.isDomainClass(element.getContainingFile().getVirtualFile())) {\n        checkDomainClass((GroovyFile) element, holder);\n      }\n    } else {\n      final ASTNode node = element.getNode();\n      if (node != null && !(element instanceof PsiWhiteSpace) && !GroovyTokenTypes.COMMENT_SET.contains(node.getElementType()) &&\n          element.getContainingFile() instanceof GroovyFile) {\n        GroovyImportsTracker.getInstance(element.getProject()).markFileAnnotated((GroovyFile) element.getContainingFile());\n      }\n    }\n  }","id":31560,"modified_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n    if (element instanceof GrCodeReferenceElement) {\n      checkReferenceElement(holder, (GrCodeReferenceElement) element);\n    } else if (element instanceof GrReferenceExpression) {\n      checkReferenceExpression(holder, (GrReferenceExpression) element);\n    } else if (element instanceof GrTypeDefinition) {\n      final GrTypeDefinition typeDefinition = (GrTypeDefinition) element;\n      checkTypeDefinition(holder, typeDefinition);\n      checkTypeDefinitionModifiers(holder, typeDefinition);\n      final GrTypeDefinitionBody body = typeDefinition.getBody();\n      if (body != null) checkDuplicateMethod(body.getMethods(), holder);\n      checkImplementedMethodsOfClass(holder, typeDefinition);\n    } else if (element instanceof GrMethod) {\n      final GrMethod method = (GrMethod) element;\n      checkMethodDefinitionModifiers(holder, method);\n      checkInnerMethod(holder, method);\n      checkMethodReturnExpression(holder, method);\n      addOverrideGutter(holder, method);\n    } else if (element instanceof GrVariableDeclaration) {\n      checkVariableDeclaration(holder, (GrVariableDeclaration) element);\n    } else if (element instanceof GrVariable) {\n      if (element instanceof GrMember) highlightMember(holder, ((GrMember) element));\n      checkVariable(holder, (GrVariable) element);\n    } else if (element instanceof GrAssignmentExpression) {\n      checkAssignmentExpression((GrAssignmentExpression) element, holder);\n    } else if (element instanceof GrNamedArgument) {\n      checkCommandArgument((GrNamedArgument) element, holder);\n    } else if (element instanceof GrReturnStatement) {\n      checkReturnStatement((GrReturnStatement) element, holder);\n    } else if (element instanceof GrListOrMap) {\n      checkMap(((GrListOrMap) element).getNamedArguments(), holder);\n    } else if (element instanceof GrNewExpression) {\n      checkNewExpression(holder, (GrNewExpression) element);\n    } else if (element instanceof GrConstructorInvocation) {\n      checkConstructorInvocation(holder, (GrConstructorInvocation) element);\n    } else if (element instanceof GrPackageDefinition) {\n      //todo: if reference isn't resolved it construct package definition \n      checkPackageReference(holder, (GrPackageDefinition) element);\n    } else if (element instanceof GroovyFile) {\n      final GroovyFile file = (GroovyFile) element;\n      if (file.isScript()) {\n        checkScriptDuplicateMethod(file.getTopLevelDefinitions(), holder);\n      }\n      if (DomainClassUtils.isDomainClassFile(element.getContainingFile().getVirtualFile())) {\n        checkDomainClass((GroovyFile) element, holder);\n      }\n    } else {\n      final ASTNode node = element.getNode();\n      if (node != null && !(element instanceof PsiWhiteSpace) && !GroovyTokenTypes.COMMENT_SET.contains(node.getElementType()) &&\n          element.getContainingFile() instanceof GroovyFile) {\n        GroovyImportsTracker.getInstance(element.getProject()).markFileAnnotated((GroovyFile) element.getContainingFile());\n      }\n    }\n  }","commit_id":"b353aca843ae03262634934268bbc43721d9d8fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerSuggestVariableNameCompletion() {\n    CompletionVariant variant = new CompletionVariant(new ParentElementFilter(new ClassFilter(GrVariable.class)));\n    variant.includeScopeClass(LeafPsiElement.class);\n    variant.addCompletionFilterOnElement(TrueFilter.INSTANCE);\n    variant.addCompletion(new SuggestedVariableNamesGetter(), TailType.NONE);\n    registerVariant(variant);\n  }","id":31561,"modified_method":"private void registerSuggestVariableNameCompletion() {\n    CompletionVariant variant = new CompletionVariant(new ParentElementFilter(new ClassFilter(GrVariable.class)));\n    variant.includeScopeClass(LeafPsiElement.class);\n    variant.addCompletionFilterOnElement(TrueFilter.INSTANCE);\n    variant.addCompletion(new SuggestedVariableNamesGetter(), TailType.NONE);\n    VariableNameSuggesterRegistry registry = VariableNameSuggesterRegistry.getInstance();\n    for (ContextGetter getter : registry.getNameSuggesters()) {\n      variant.addCompletion(getter, TailType.NONE);\n    }\n    registerVariant(variant);\n  }","commit_id":"b353aca843ae03262634934268bbc43721d9d8fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void loadGroovy() {\n    ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            FileTypeManager.getInstance().registerFileType(GroovyFileType.GROOVY_FILE_TYPE, GROOVY_EXTENSIONS.toArray(new String[GROOVY_EXTENSIONS.size()]));\n          }\n        }\n    );\n\n    //todo add composite completion data\n    CompletionDataRegistry completionDataRegistry = CompletionDataRegistry.getInstance();\n    CompletionData[] otherDatas = completionDataRegistry.getCompletionDatas();\n    CompletionData[] datas = ArrayUtil.mergeArrays(new CompletionData[]{new GroovyCompletionData()}, otherDatas, CompletionData.class);\n    CompletionUtil.registerCompletionData(GroovyFileType.GROOVY_FILE_TYPE, new CompositeCompletionData(datas));\n\n    MethodReferencesSearch.INSTANCE.registerExecutor(new AccessorReferencesSearcher());\n    MethodReferencesSearch.INSTANCE.registerExecutor(new MethodLateBoundReferencesSearcher());\n\n    ReferencesSearch.INSTANCE.registerExecutor(new ConstructorReferencesSearcher());\n\n    ReferencesSearch.INSTANCE.registerExecutor(new PropertyReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new TypeAliasReferenceSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new LateBoundReferencesSearcher());\n\n    TypedHandler.registerQuoteHandler(GroovyFileType.GROOVY_FILE_TYPE, new GroovyQuoteHandler());\n\n    ProjectManager.getInstance().addProjectManagerListener(new ProjectManagerAdapter() {\n      public void projectOpened(Project project) {\n        TextEditorHighlightingPassRegistrar registrar = TextEditorHighlightingPassRegistrar.getInstance(project);\n        GroovyUnusedImportsPassFactory unusedImportsPassFactory = project.getComponent(GroovyUnusedImportsPassFactory.class);\n        registrar.registerTextEditorHighlightingPass(unusedImportsPassFactory, new int[]{Pass.UPDATE_ALL}, null, true, -1);\n\n        WolfTheProblemSolver.getInstance(project).registerFileHighlightFilter(new Condition<VirtualFile>() {\n          public boolean value(VirtualFile virtualFile) {\n            return FileTypeManager.getInstance().getFileTypeByFile(virtualFile) == GroovyFileType.GROOVY_FILE_TYPE;\n          }\n        }, project);\n\n        CompilerManager compilerManager = CompilerManager.getInstance(project);\n        GroovyToJavaGenerator generator = new GroovyToJavaGenerator(project);\n        compilerManager.addCompiler(generator);\n        compilerManager.addCompilationStatusListener(generator);\n\n        compilerManager.addCompiler(new GroovyCompiler(project));\n        compilerManager.addCompilableFileType(GroovyFileType.GROOVY_FILE_TYPE);\n\n        DebuggerManager.getInstance(project).registerPositionManagerFactory(new Function<DebugProcess, PositionManager>() {\n          public PositionManager fun(DebugProcess debugProcess) {\n            return new GroovyPositionManager(debugProcess);\n          }\n        });\n\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrLiteral.class, new PropertiesReferenceProvider());\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrReferenceExpression.class, new DynamicPropertiesReferenceProvider());\n      }\n    });\n  }","id":31562,"modified_method":"private static void loadGroovy() {\n    ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            FileTypeManager.getInstance().registerFileType(GroovyFileType.GROOVY_FILE_TYPE, GROOVY_EXTENSIONS.toArray(new String[GROOVY_EXTENSIONS.size()]));\n          }\n        }\n    );\n\n    CompletionUtil.registerCompletionData(GroovyFileType.GROOVY_FILE_TYPE, new GroovyCompletionData());\n\n    MethodReferencesSearch.INSTANCE.registerExecutor(new AccessorReferencesSearcher());\n    MethodReferencesSearch.INSTANCE.registerExecutor(new MethodLateBoundReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new ConstructorReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new PropertyReferencesSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new TypeAliasReferenceSearcher());\n    ReferencesSearch.INSTANCE.registerExecutor(new LateBoundReferencesSearcher());\n\n    TypedHandler.registerQuoteHandler(GroovyFileType.GROOVY_FILE_TYPE, new GroovyQuoteHandler());\n\n    ProjectManager.getInstance().addProjectManagerListener(new ProjectManagerAdapter() {\n      public void projectOpened(Project project) {\n        TextEditorHighlightingPassRegistrar registrar = TextEditorHighlightingPassRegistrar.getInstance(project);\n        GroovyUnusedImportsPassFactory unusedImportsPassFactory = project.getComponent(GroovyUnusedImportsPassFactory.class);\n        registrar.registerTextEditorHighlightingPass(unusedImportsPassFactory, new int[]{Pass.UPDATE_ALL}, null, true, -1);\n\n        WolfTheProblemSolver.getInstance(project).registerFileHighlightFilter(new Condition<VirtualFile>() {\n          public boolean value(VirtualFile virtualFile) {\n            return FileTypeManager.getInstance().getFileTypeByFile(virtualFile) == GroovyFileType.GROOVY_FILE_TYPE;\n          }\n        }, project);\n\n        CompilerManager compilerManager = CompilerManager.getInstance(project);\n        GroovyToJavaGenerator generator = new GroovyToJavaGenerator(project);\n        compilerManager.addCompiler(generator);\n        compilerManager.addCompilationStatusListener(generator);\n\n        compilerManager.addCompiler(new GroovyCompiler(project));\n        compilerManager.addCompilableFileType(GroovyFileType.GROOVY_FILE_TYPE);\n\n        DebuggerManager.getInstance(project).registerPositionManagerFactory(new Function<DebugProcess, PositionManager>() {\n          public PositionManager fun(DebugProcess debugProcess) {\n            return new GroovyPositionManager(debugProcess);\n          }\n        });\n\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrLiteral.class, new PropertiesReferenceProvider());\n        ReferenceProvidersRegistry.getInstance(project).registerReferenceProvider(GrReferenceExpression.class, new DynamicPropertiesReferenceProvider());\n      }\n    });\n  }","commit_id":"b353aca843ae03262634934268bbc43721d9d8fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyReferenceExpression(PyReferenceExpression node) {\n    if (PyNames.UnderscoredNames.contains(node.getName())) {\n      // things like __len__\n      if (\n        (node.getQualifier() != null) // foo.__len__\n        || (PyResolveUtil.getConcealingParent(node) instanceof PyClass) // class Foo: ... __len__ = myLenImpl\n      ) {\n        final ASTNode astNode = node.getNode();\n        if (astNode != null) {\n          ASTNode tgt = astNode.findChildByType(PyTokenTypes.IDENTIFIER); // only the id, not all qualifiers subtree\n          if (tgt != null) {\n            Annotation ann = getHolder().createInfoAnnotation(tgt, null);\n            ann.setTextAttributes(PyHighlighter.PY_PREDEFINED_USAGE);\n          }\n        }\n      }\n    }\n    else if (node.getQualifier() == null) {\n      // things like len()\n      ResolveResult[] resolved = node.multiResolve(false); // constructors, etc give multiple results...\n      if (resolved.length > 0) {\n        if (PyBuiltinCache.hasInBuiltins(resolved[0].getElement())) { // ...but we only care about single-resolvers\n          Annotation ann = getHolder().createInfoAnnotation(node, null);\n          ann.setTextAttributes(PyHighlighter.PY_BUILTIN_NAME);\n        }\n      }\n    }\n  }","id":31563,"modified_method":"@Override\n  public void visitPyReferenceExpression(PyReferenceExpression node) {\n    if (PyNames.UnderscoredNames.contains(node.getName())) {\n      // things like __len__\n      if (\n        (node.getQualifier() != null) // foo.__len__\n        || (PyResolveUtil.getConcealingParent(node) instanceof PyClass) // class Foo: ... __len__ = myLenImpl\n      ) {\n        final ASTNode astNode = node.getNode();\n        if (astNode != null) {\n          ASTNode tgt = astNode.findChildByType(PyTokenTypes.IDENTIFIER); // only the id, not all qualifiers subtree\n          if (tgt != null) {\n            Annotation ann = getHolder().createInfoAnnotation(tgt, null);\n            ann.setTextAttributes(PyHighlighter.PY_PREDEFINED_USAGE);\n          }\n        }\n      }\n    }\n    else if (node.getQualifier() == null) {\n      // things like len()\n      ResolveResult[] resolved = node.multiResolve(false); // constructors, etc give multiple results...\n      if (resolved.length > 0) {\n        if (PyBuiltinCache.hasInBuiltins(resolved[0].getElement())) { // ...but we only care about single-resolvers\n          Annotation ann;\n          PsiElement parent = node.getParent();\n          if (parent instanceof PyDecorator) {\n            // don't mark the entire decorator, only mark the \"@\", else we'll conflict with deco annotator\n            ann = getHolder().createInfoAnnotation(parent.getFirstChild(), null); // first child is there, or we'd not parse as deco\n          }\n          else ann = getHolder().createInfoAnnotation(node, null);\n          ann.setTextAttributes(PyHighlighter.PY_BUILTIN_NAME);\n        }\n      }\n    }\n  }","commit_id":"9ed98bb503b1a0aadf0dc1683c8185f646c2d904","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void highlightMember(AnnotationHolder holder, GrMember member) {\n    if (member instanceof PsiField) {\n      GrField field = (GrField)member;\n      PsiElement identifier = field.getNameIdentifierGroovy();\n      if (field.hasModifierProperty(PsiModifier.STATIC)) {\n        Annotation annotation = holder.createInfoAnnotation(identifier, null);\n        annotation.setTextAttributes(DefaultHighlighter.STATIC_FIELD);\n      }\n    }\n  }","id":31564,"modified_method":"private static void highlightMember(AnnotationHolder holder, GrMember member) {\n    if (member instanceof PsiField) {\n      GrField field = (GrField)member;\n      PsiElement identifier = field.getNameIdentifierGroovy();\n      final boolean isStatic = field.hasModifierProperty(PsiModifier.STATIC);\n      holder.createInfoAnnotation(identifier, null).setTextAttributes(isStatic ? DefaultHighlighter.STATIC_FIELD : DefaultHighlighter.INSTANCE_FIELD);\n    }\n  }","commit_id":"0a9462fe71fb298ab5a17ec5f17180434693b004","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void highlightMemberResolved(AnnotationHolder holder, GrReferenceExpression refExpr, PsiMember member) {\n    boolean isStatic = member.hasModifierProperty(PsiModifier.STATIC);\n    Annotation annotation = holder.createInfoAnnotation(refExpr.getReferenceNameElement(), null);\n    if (member instanceof GrAccessorMethod) member = ((GrAccessorMethod)member).getProperty();\n\n    if (member instanceof PsiField && isStatic) {\n      annotation.setTextAttributes(DefaultHighlighter.STATIC_FIELD);\n      return;\n    }\n    if (member instanceof PsiMethod) {\n      annotation.setTextAttributes(!isStatic ? DefaultHighlighter.METHOD_CALL : DefaultHighlighter.STATIC_METHOD_ACCESS);\n    }\n  }","id":31565,"modified_method":"private static void highlightMemberResolved(AnnotationHolder holder, GrReferenceExpression refExpr, PsiMember member) {\n    boolean isStatic = member.hasModifierProperty(PsiModifier.STATIC);\n    Annotation annotation = holder.createInfoAnnotation(refExpr.getReferenceNameElement(), null);\n    if (member instanceof GrAccessorMethod) member = ((GrAccessorMethod)member).getProperty();\n\n    if (member instanceof PsiField ) {\n      annotation.setTextAttributes(isStatic ? DefaultHighlighter.STATIC_FIELD : DefaultHighlighter.INSTANCE_FIELD);\n      return;\n    }\n    if (member instanceof PsiMethod) {\n      annotation.setTextAttributes(!isStatic ? DefaultHighlighter.METHOD_CALL : DefaultHighlighter.STATIC_METHOD_ACCESS);\n    }\n  }","commit_id":"0a9462fe71fb298ab5a17ec5f17180434693b004","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls\n  @NotNull\n  public String getDemoText() {\n    return \"import javax.swing.JPanel\\n\" +\n           \"  ### \\n\" +\n           \"<gdoc>/**\\n\" +\n           \" * This is Groovydoc comment\\n\" +\n           \" * <doctag>@see<\/doctag> java.lang.String#equals\\n\" +\n           \" */<\/gdoc>\\n\" +\n           \"<annotation>@SpecialBean<\/annotation> \\n\" +\n           \"class Demo {\\n\" +\n           \"//This is a line comment\\n\" +\n           \"/* This is a block comment */\\n\" +\n           \"  static def foo(int i) { return [i, i] }\\n\" +\n           \"  static def <statfield>panel<\/statfield> = new JPanel()\\n\" +\n           \"}\\n\" +\n           \"\\n\" +\n           \"Demo.<statfield>panel<\/statfield>.size = \" +\n           \"Demo.<statmet>foo<\/statmet>(\\\"123${456}789\\\".toInteger()) \\n\" +\n           \"'JetBrains'.matches(/Jw+Bw+/) \\n\" +\n           \"def untyped\\n\" +\n           \"<untyped>untyped<\/untyped>.<unresolved>doSomething<\/unresolved>()\\n\" +\n           \"def x=1 + <unresolved>unresolved<\/unresolved>\"      \n      ;\n  }","id":31566,"modified_method":"@NonNls\n  @NotNull\n  public String getDemoText() {\n    return \"import javax.swing.JPanel\\n\" +\n           \"  ### \\n\" +\n           \"<gdoc>/**\\n\" +\n           \" * This is Groovydoc comment\\n\" +\n           \" * <doctag>@see<\/doctag> java.lang.String#equals\\n\" +\n           \" */<\/gdoc>\\n\" +\n           \"<annotation>@SpecialBean<\/annotation> \\n\" +\n           \"class Demo {\\n\" +\n           \"  def <instfield>property<\/instfield>\\n\" +\n           \"//This is a line comment\\n\" +\n           \"/* This is a block comment */\\n\" +\n           \"  static def foo(int i) { return [i, i, <instfield>property<\/instfield>] }\\n\" +\n           \"  static def <statfield>panel<\/statfield> = new JPanel()\\n\" +\n           \"}\\n\" +\n           \"\\n\" +\n           \"Demo.<statfield>panel<\/statfield>.size = \" +\n           \"Demo.<statmet>foo<\/statmet>(\\\"123${456}789\\\".toInteger()) \\n\" +\n           \"'JetBrains'.matches(/Jw+Bw+/) \\n\" +\n           \"def untyped\\n\" +\n           \"<untyped>untyped<\/untyped>.<unresolved>doSomething<\/unresolved>()\\n\" +\n           \"def x=1 + <unresolved>unresolved<\/unresolved>\"      \n      ;\n  }","commit_id":"0a9462fe71fb298ab5a17ec5f17180434693b004","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap() {\n    Map<String, TextAttributesKey> map = new HashMap<String, TextAttributesKey>();\n    map.put(\"annotation\", DefaultHighlighter.ANNOTATION);\n    map.put(\"statmet\", DefaultHighlighter.STATIC_METHOD_ACCESS);\n    map.put(\"statfield\", DefaultHighlighter.STATIC_FIELD);\n    map.put(\"untyped\", DefaultHighlighter.UNTYPED_ACCESS);\n    map.put(\"gdoc\", DefaultHighlighter.DOC_COMMENT_CONTENT);\n    map.put(\"doctag\", DefaultHighlighter.DOC_COMMENT_TAG);\n    map.put(\"unresolved\", DefaultHighlighter.UNRESOLVED_ACCESS);\n\n    return map;\n  }","id":31567,"modified_method":"@Nullable\n  public Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap() {\n    Map<String, TextAttributesKey> map = new HashMap<String, TextAttributesKey>();\n    map.put(\"annotation\", DefaultHighlighter.ANNOTATION);\n    map.put(\"statmet\", DefaultHighlighter.STATIC_METHOD_ACCESS);\n    map.put(\"statfield\", DefaultHighlighter.STATIC_FIELD);\n    map.put(\"instfield\", DefaultHighlighter.INSTANCE_FIELD);\n    map.put(\"untyped\", DefaultHighlighter.UNTYPED_ACCESS);\n    map.put(\"gdoc\", DefaultHighlighter.DOC_COMMENT_CONTENT);\n    map.put(\"doctag\", DefaultHighlighter.DOC_COMMENT_TAG);\n    map.put(\"unresolved\", DefaultHighlighter.UNRESOLVED_ACCESS);\n\n    return map;\n  }","commit_id":"0a9462fe71fb298ab5a17ec5f17180434693b004","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Sets the <tt>MediaFormat<\/tt> in which this <tt>MediaDeviceSession<\/tt>\n     * outputs the media captured by its <tt>MediaDevice<\/tt>.\n     *\n     * @param format the <tt>MediaFormat<\/tt> in which this\n     * <tt>MediaDeviceSession<\/tt> is to output the media captured by its\n     * <tt>MediaDevice<\/tt>\n     */\n    public void setFormat(MediaFormat format)\n    {\n        MediaType mediaType = getMediaType();\n\n        if (!mediaType.equals(format.getMediaType()))\n            throw new IllegalArgumentException(\"format\");\n\n        /*\n         * We need javax.media.Format and we know how to convert MediaFormat to\n         * it only for MediaFormatImpl so assert early.\n         */\n        MediaFormatImpl<? extends Format> mediaFormatImpl\n            = (MediaFormatImpl<? extends Format>) format;\n\n        this.format = mediaFormatImpl.getFormat();\n\n        /*\n         * If the processor is after Configured, setting a different format will\n         * silently fail. Recreate the processor in order to be able to set the\n         * different format.\n         */\n        if (processor != null)\n        {\n            int processorState = processor.getState();\n\n            if (processorState == Processor.Configured)\n                setFormat(processor, this.format);\n            else if (processorIsPrematurelyClosed\n                        || ((processorState > Processor.Configured)\n                                && !format.equals(getFormat())))\n                setProcessor(null);\n        }\n    }","id":31568,"modified_method":"/**\n     * Sets the <tt>MediaFormat<\/tt> in which this <tt>MediaDeviceSession<\/tt>\n     * outputs the media captured by its <tt>MediaDevice<\/tt>.\n     *\n     * @param format the <tt>MediaFormat<\/tt> in which this\n     * <tt>MediaDeviceSession<\/tt> is to output the media captured by its\n     * <tt>MediaDevice<\/tt>\n     */\n    public void setFormat(MediaFormat format)\n    {\n        MediaType mediaType = getMediaType();\n\n        if (!mediaType.equals(format.getMediaType()))\n            throw new IllegalArgumentException(\"format\");\n\n        /*\n         * We need javax.media.Format and we know how to convert MediaFormat to\n         * it only for MediaFormatImpl so assert early.\n         */\n        @SuppressWarnings(\"unchecked\")\n        MediaFormatImpl<? extends Format> mediaFormatImpl\n            = (MediaFormatImpl<? extends Format>) format;\n\n        this.format = mediaFormatImpl.getFormat();\n\n        /*\n         * If the processor is after Configured, setting a different format will\n         * silently fail. Recreate the processor in order to be able to set the\n         * different format.\n         */\n        if (processor != null)\n        {\n            int processorState = processor.getState();\n\n            if (processorState == Processor.Configured)\n                setProcessorFormat(processor, this.format);\n            else if (processorIsPrematurelyClosed\n                        || ((processorState > Processor.Configured)\n                                && !format.equals(getFormat())))\n                setProcessor(null);\n        }\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the JMF <tt>Format<\/tt> in which a specific <tt>Processor<\/tt> is to\n     * output media data.\n     *\n     * @param processor the <tt>Processor<\/tt> to set the output <tt>Format<\/tt>\n     * of\n     * @param format the JMF <tt>Format<\/tt> to set to <tt>processor<\/tt>\n     */\n    protected void setFormat(Processor processor, Format format)\n    {\n        TrackControl[] trackControls = processor.getTrackControls();\n        MediaType mediaType = getMediaType();\n\n        for (int trackIndex = 0;\n                trackIndex < trackControls.length;\n                trackIndex++)\n        {\n            TrackControl trackControl = trackControls[trackIndex];\n\n            if (!trackControl.isEnabled())\n                continue;\n\n            Format[] supportedFormats = trackControl.getSupportedFormats();\n\n            if ((supportedFormats == null) || (supportedFormats.length < 1))\n            {\n                trackControl.setEnabled(false);\n                continue;\n            }\n\n            Format supportedFormat = null;\n\n            switch (mediaType)\n            {\n            case AUDIO:\n                if (supportedFormats[0] instanceof AudioFormat)\n                {\n                    if (FMJConditionals.FORCE_AUDIO_FORMAT != null)\n                        trackControl\n                            .setFormat(FMJConditionals.FORCE_AUDIO_FORMAT);\n                    else\n                    {\n                        supportedFormat\n                            = findFirstMatchingFormat(supportedFormats, format);\n\n                        /*\n                         * We've failed to find a supported format so try to use\n                         * whatever we've been told and, if it fails, the caller\n                         * will at least know why.\n                         */\n                        if (supportedFormat == null)\n                            supportedFormat = format;\n                    }\n                }\n                break;\n            case VIDEO:\n                if (supportedFormats[0] instanceof VideoFormat)\n                {\n                    VideoFormat tmp = (VideoFormat)format;\n                    Dimension size = tmp.getSize();\n\n                    if(size != null)\n                    {\n                        /* We have been explictely told to use\n                         * a specified output size so create a \n                         * custom SwScaler that will rescale and \n                         * change format in one call\n                         */\n                        Codec ar[] = new Codec[1];\n                        SwScaler scaler = new SwScaler();\n\n                        scaler.setOutputSize(size);\n                        ar[0] = scaler;\n\n                        /* add our custom SwScaler to the codec chain so that\n                         * it will be used instead of default SwScaler\n                         */\n                        try\n                        {\n                            trackControl.setCodecChain(ar);\n                        }\n                        catch(Exception e)\n                        {\n                            System.out.println(\"Error setCodecChain: \" + e);\n                        }\n                    }\n\n                    supportedFormat \n                        = findFirstMatchingFormat(supportedFormats, format);\n\n                    /*\n                     * We've failed to find a supported format so try to use\n                     * whatever we've been told and, if it fails, the caller\n                     * will at least know why.\n                     */\n                    if (supportedFormat == null)\n                        supportedFormat = format;\n\n                    if (supportedFormat != null)\n                        supportedFormat\n                            = assertSize((VideoFormat) supportedFormat);\n                }\n                break;\n            }\n\n            if (supportedFormat == null)\n                trackControl.setEnabled(false);\n            else if (!supportedFormat.equals(trackControl.getFormat()))\n            {\n                Format setFormat = trackControl.setFormat(supportedFormat);\n\n                if (setFormat == null)\n                    logger\n                        .error(\n                            \"Failed to set format of track \"\n                                + trackIndex\n                                + \" to \"\n                                + supportedFormat\n                                + \". Processor is in state \"\n                                + processor.getState());\n                else if (setFormat != supportedFormat)\n                    logger\n                        .warn(\n                            \"Failed to change format of track \"\n                                + trackIndex\n                                + \" from \"\n                                + setFormat\n                                + \" to \"\n                                + supportedFormat\n                                + \". Processor is in state \"\n                                + processor.getState());\n                else if (logger.isTraceEnabled())\n                    logger\n                        .trace(\n                            \"Set format of track \"\n                                + trackIndex\n                                + \" to \"\n                                + setFormat);\n            }\n        }\n    }","id":31569,"modified_method":"/**\n     * Sets the JMF <tt>Format<\/tt> in which a specific <tt>Processor<\/tt>\n     * producing media to be streamed to the remote peer is to output.\n     *\n     * @param processor the <tt>Processor<\/tt> to set the output <tt>Format<\/tt>\n     * of\n     * @param format the JMF <tt>Format<\/tt> to set to <tt>processor<\/tt>\n     */\n    protected void setProcessorFormat(Processor processor, Format format)\n    {\n        TrackControl[] trackControls = processor.getTrackControls();\n        MediaType mediaType = getMediaType();\n\n        for (int trackIndex = 0;\n                trackIndex < trackControls.length;\n                trackIndex++)\n        {\n            TrackControl trackControl = trackControls[trackIndex];\n\n            if (!trackControl.isEnabled())\n                continue;\n\n            Format[] supportedFormats = trackControl.getSupportedFormats();\n\n            if ((supportedFormats == null) || (supportedFormats.length < 1))\n            {\n                trackControl.setEnabled(false);\n                continue;\n            }\n\n            Format supportedFormat = null;\n\n            switch (mediaType)\n            {\n            case AUDIO:\n                if (supportedFormats[0] instanceof AudioFormat)\n                {\n                    if (FMJConditionals.FORCE_AUDIO_FORMAT != null)\n                        trackControl\n                            .setFormat(FMJConditionals.FORCE_AUDIO_FORMAT);\n                    else\n                    {\n                        supportedFormat\n                            = findFirstMatchingFormat(supportedFormats, format);\n\n                        /*\n                         * We've failed to find a supported format so try to use\n                         * whatever we've been told and, if it fails, the caller\n                         * will at least know why.\n                         */\n                        if (supportedFormat == null)\n                            supportedFormat = format;\n                    }\n                }\n                break;\n            case VIDEO:\n                if (supportedFormats[0] instanceof VideoFormat)\n                {\n                    supportedFormat \n                        = findFirstMatchingFormat(supportedFormats, format);\n\n                    /*\n                     * We've failed to find a supported format so try to use\n                     * whatever we've been told and, if it fails, the caller\n                     * will at least know why.\n                     */\n                    if (supportedFormat == null)\n                        supportedFormat = format;\n\n                    if (supportedFormat != null)\n                        supportedFormat\n                            = assertSize((VideoFormat) supportedFormat);\n                }\n                break;\n            }\n\n            if (supportedFormat == null)\n                trackControl.setEnabled(false);\n            else if (!supportedFormat.equals(trackControl.getFormat()))\n            {\n                Format setFormat\n                    = setProcessorFormat(trackControl, supportedFormat);\n\n                if (setFormat == null)\n                    logger\n                        .error(\n                            \"Failed to set format of track \"\n                                + trackIndex\n                                + \" to \"\n                                + supportedFormat\n                                + \". Processor is in state \"\n                                + processor.getState());\n                else if (setFormat != supportedFormat)\n                    logger\n                        .warn(\n                            \"Failed to change format of track \"\n                                + trackIndex\n                                + \" from \"\n                                + setFormat\n                                + \" to \"\n                                + supportedFormat\n                                + \". Processor is in state \"\n                                + processor.getState());\n                else if (logger.isTraceEnabled())\n                    logger\n                        .trace(\n                            \"Set format of track \"\n                                + trackIndex\n                                + \" to \"\n                                + setFormat);\n            }\n        }\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by\n     * {@link #processor}.\n     *\n     * @param event the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     */\n    protected void processorControllerUpdate(ControllerEvent event)\n    {\n        if (event instanceof ConfigureCompleteEvent)\n        {\n            Processor processor = (Processor) event.getSourceController();\n\n            if (processor != null)\n            {\n                try\n                {\n                    processor\n                        .setContentDescriptor(\n                            new ContentDescriptor(\n                                    ContentDescriptor.RAW_RTP));\n                }\n                catch (NotConfiguredError nce)\n                {\n                    logger\n                        .error(\n                            \"Failed to set ContentDescriptor to Processor.\",\n                            nce);\n                }\n\n                if (format != null)\n                    setFormat(processor, format);\n            }\n        }\n        else if (event instanceof ControllerClosedEvent)\n        {\n            Processor processor = (Processor) event.getSourceController();\n\n            /*\n             * If everything goes according to plan, we should've removed the\n             * ControllerListener from the processor by now.\n             */\n            logger.warn(event);\n\n            // TODO Should the access to processor be synchronized?\n            if ((processor != null) && (this.processor == processor))\n                processorIsPrematurelyClosed = true;\n        }\n    }","id":31570,"modified_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by\n     * {@link #processor}.\n     *\n     * @param event the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     */\n    protected void processorControllerUpdate(ControllerEvent event)\n    {\n        if (event instanceof ConfigureCompleteEvent)\n        {\n            Processor processor = (Processor) event.getSourceController();\n\n            if (processor != null)\n            {\n                try\n                {\n                    processor\n                        .setContentDescriptor(\n                            new ContentDescriptor(\n                                    ContentDescriptor.RAW_RTP));\n                }\n                catch (NotConfiguredError nce)\n                {\n                    logger\n                        .error(\n                            \"Failed to set ContentDescriptor to Processor.\",\n                            nce);\n                }\n\n                if (format != null)\n                    setProcessorFormat(processor, format);\n            }\n        }\n        else if (event instanceof ControllerClosedEvent)\n        {\n            Processor processor = (Processor) event.getSourceController();\n\n            /*\n             * If everything goes according to plan, we should've removed the\n             * ControllerListener from the processor by now.\n             */\n            logger.warn(event);\n\n            // TODO Should the access to processor be synchronized?\n            if ((processor != null) && (this.processor == processor))\n                processorIsPrematurelyClosed = true;\n        }\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets output size.\n     *\n     * @param size size to set\n     */\n    public void setOutputSize(Dimension size)\n    {\n        if(size == null)\n            size = new Dimension(640, 480);\n\n        supportedOutputFormats[0] = new YUVFormat(size, -1, Format.byteArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[1] = new YUVFormat(size, -1, Format.intArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[2] = new YUVFormat(size, -1, Format.shortArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[3] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[4] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[5] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[6] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[7] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[8] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 24, -1, -1, -1);\n    }","id":31571,"modified_method":"/**\n     * Sets output size.\n     *\n     * @param size size to set\n     */\n    public void setOutputSize(Dimension size)\n    {\n        if(size == null)\n            size = new Dimension(640, 480);\n\n        supportedOutputFormats[0] = new YUVFormat(size, -1, Format.byteArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[1] = new YUVFormat(size, -1, Format.intArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[2] = new YUVFormat(size, -1, Format.shortArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[3] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[4] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[5] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[6] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[7] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[8] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 24, -1, -1, -1);\n\n        // Set the size to the outputFormat as well.\n        VideoFormat outputFormat = (VideoFormat) this.outputFormat;\n\n        if (outputFormat != null)\n            setOutputFormat(\n                new VideoFormat(\n                        outputFormat.getEncoding(),\n                        size,\n                        outputFormat.getMaxDataLength(),\n                        outputFormat.getDataType(),\n                        outputFormat.getFrameRate())\n                    .intersects(outputFormat));\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by a specific\n     * <tt>Player<\/tt> of remote content.\n     *\n     * @param event the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     * @see MediaDeviceSession#playerControllerUpdate(ControllerEvent)\n     */\n    @Override\n    protected void playerControllerUpdate(ControllerEvent event)\n    {\n        super.playerControllerUpdate(event);\n\n        if (event instanceof SizeChangeEvent)\n            playerSizeChange((SizeChangeEvent) event);\n    }","id":31572,"modified_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by a specific\n     * <tt>Player<\/tt> of remote content.\n     *\n     * @param event the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     * @see MediaDeviceSession#playerControllerUpdate(ControllerEvent)\n     */\n    @Override\n    protected void playerControllerUpdate(ControllerEvent event)\n    {\n        super.playerControllerUpdate(event);\n\n        if (event instanceof SizeChangeEvent)\n        {\n            SizeChangeEvent sizeChangeEvent = (SizeChangeEvent) event;\n\n            playerSizeChange(\n                sizeChangeEvent.getSourceController(),\n                sizeChangeEvent.getWidth(),\n                sizeChangeEvent.getHeight());\n        }\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies this instance that a specific <tt>Player<\/tt> of remote content\n     * has generated a <tt>RealizeCompleteEvent<\/tt>.\n     *\n     * @param player the <tt>Player<\/tt> which is the source of a\n     * <tt>RealizeCompleteEvent<\/tt>.\n     * @see MediaDeviceSession#playerRealizeComplete(Processor)\n     */\n    @Override\n    protected void playerRealizeComplete(Processor player)\n    {\n        super.playerRealizeComplete(player);\n\n        Component visualComponent = getVisualComponent(player);\n\n        if (visualComponent != null)\n            fireVideoEvent(\n                VideoEvent.VIDEO_ADDED,\n                visualComponent,\n                VideoEvent.REMOTE);\n    }","id":31573,"modified_method":"/**\n     * Notifies this instance that a specific <tt>Player<\/tt> of remote content\n     * has generated a <tt>RealizeCompleteEvent<\/tt>.\n     *\n     * @param player the <tt>Player<\/tt> which is the source of a\n     * <tt>RealizeCompleteEvent<\/tt>.\n     * @see MediaDeviceSession#playerRealizeComplete(Processor)\n     */\n    @Override\n    protected void playerRealizeComplete(final Processor player)\n    {\n        super.playerRealizeComplete(player);\n\n        Component visualComponent = getVisualComponent(player);\n\n        if (visualComponent != null)\n        {\n            /*\n             * SwScaler seems to be very good at scaling with respect to image\n             * quality so use it for the scaling in the player replacing the\n             * scaling it does upon rendering.\n             */\n            visualComponent.addComponentListener(new ComponentAdapter()\n            {\n                @Override\n                public void componentResized(ComponentEvent e)\n                {\n                    playerVisualComponentResized(player, e);\n                }\n            });\n\n            fireVideoEvent(\n                VideoEvent.VIDEO_ADDED,\n                visualComponent,\n                VideoEvent.REMOTE);\n        }\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by\n     * {@link #localPlayer}.\n     *\n     * @param controllerEvent the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     */\n    private void controllerUpdateForCreateLocalVisualComponent(\n            ControllerEvent controllerEvent)\n    {\n        if (controllerEvent instanceof RealizeCompleteEvent)\n        {\n            Player player = (Player) controllerEvent.getSourceController();\n            Component visualComponent = player.getVisualComponent();\n\n            if ((visualComponent != null)\n                    && !fireVideoEvent(\n                            VideoEvent.VIDEO_ADDED,\n                            visualComponent,\n                            VideoEvent.LOCAL))\n            {\n                // No listener interrested in our event so free resources.\n                if(localPlayer == player)\n                    localPlayer = null;\n\n                player.stop();\n                player.deallocate();\n                player.close();\n            }\n        }\n    }","id":31574,"modified_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by\n     * {@link #localPlayer}.\n     *\n     * @param controllerEvent the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     */\n    private void controllerUpdateForCreateLocalVisualComponent(\n            ControllerEvent controllerEvent)\n    {\n        if (controllerEvent instanceof RealizeCompleteEvent)\n        {\n            Player player = (Player) controllerEvent.getSourceController();\n            Component visualComponent = player.getVisualComponent();\n\n            if (visualComponent != null)\n            {\n                if (fireVideoEvent(\n                        VideoEvent.VIDEO_ADDED,\n                        visualComponent,\n                        VideoEvent.LOCAL))\n                {\n                    localVisualComponentConsumed(visualComponent, player);\n                }\n                else\n                {\n                    // No listener interested in our event so free resources.\n                    if(localPlayer == player)\n                        localPlayer = null;\n    \n                    player.stop();\n                    player.deallocate();\n                    player.close();\n                }\n            }\n        }\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the JMF <tt>Format<\/tt> in which a specific <tt>Processor<\/tt> is to\n     * output media data.\n     *\n     * @param processor the <tt>Processor<\/tt> to set the output <tt>Format<\/tt>\n     * of\n     * @param format the JMF <tt>Format<\/tt> to set to <tt>processor<\/tt>\n     */\n    @Override\n    protected void setFormat(Processor processor, Format format)\n    {\n        Format newFormat = null;\n        VideoFormat tmp = (VideoFormat)format;\n\n        /* add a size in the output format, as VideoFormat has no\n         * set accessors, we recreate the object\n         */\n        if(outputSize != null)\n        {\n            newFormat = new VideoFormat(tmp.getEncoding(), outputSize, \n                    tmp.getMaxDataLength(), tmp.getDataType(), \n                    tmp.getFrameRate());\n        }\n\n        super.setFormat(processor, newFormat != null ? newFormat : format);\n    }","id":31575,"modified_method":"/**\n     * Sets the JMF <tt>Format<\/tt> in which a specific <tt>Processor<\/tt>\n     * producing media to be streamed to the remote peer is to output.\n     *\n     * @param processor the <tt>Processor<\/tt> to set the output <tt>Format<\/tt>\n     * of\n     * @param format the JMF <tt>Format<\/tt> to set to <tt>processor<\/tt>\n     * @see MediaDeviceSession#setProcessorFormat(Processor, Format)\n     */\n    @Override\n    protected void setProcessorFormat(Processor processor, Format format)\n    {\n        Format newFormat = null;\n        VideoFormat tmp = (VideoFormat)format;\n\n        /* Add a size in the output format. As VideoFormat has no setter, we\n         * recreate the object.\n         */\n        if(outputSize != null)\n        {\n            newFormat = new VideoFormat(tmp.getEncoding(), outputSize, \n                    tmp.getMaxDataLength(), tmp.getDataType(), \n                    tmp.getFrameRate());\n        }\n\n        super.setProcessorFormat(\n                processor,\n                newFormat != null ? newFormat : format);\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies this instance that a specific <tt>Player<\/tt> of remote content\n     * has generated a <tt>SizeChangeEvent<\/tt>.\n     *\n     * @param event the <tt>SizeChangeEvent<\/tt> specifying the <tt>Player<\/tt>\n     * which is the source of the event and the additional details related to\n     * the event\n     * @see SizeChangeEvent\n     */\n    protected void playerSizeChange(SizeChangeEvent event)\n    {\n        Player player = (Player) event.getSourceController();\n        Component visualComponent = getVisualComponent(player);\n\n        if (visualComponent != null)\n            fireVideoEvent(\n                new SizeChangeVideoEvent(\n                        this,\n                        visualComponent,\n                        SizeChangeVideoEvent.REMOTE,\n                        event.getWidth(),\n                        event.getHeight()));\n    }","id":31576,"modified_method":"/**\n     * Notifies this instance that a specific <tt>Player<\/tt> of remote content\n     * has generated a <tt>SizeChangeEvent<\/tt>.\n     *\n     * @param sourceController the <tt>Player<\/tt> which is the source of the\n     * event\n     * @param width the width reported in the event\n     * @param height the height reported in the event\n     * @see SizeChangeEvent\n     */\n    protected void playerSizeChange(\n            final Controller sourceController,\n            final int width,\n            final int height)\n    {\n        /*\n         * Invoking anything that is likely to change the UI in the Player\n         * thread seems like a performance hit so bring it into the event\n         * thread.\n         */\n        if (!SwingUtilities.isEventDispatchThread())\n        {\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    playerSizeChange(sourceController, width, height);\n                }\n            });\n            return;\n        }\n\n        Player player = (Player) sourceController;\n        Component visualComponent = getVisualComponent(player);\n\n        if (visualComponent != null)\n            fireVideoEvent(\n                new SizeChangeVideoEvent(\n                        this,\n                        visualComponent,\n                        SizeChangeVideoEvent.REMOTE,\n                        width,\n                        height));\n    }","commit_id":"7f3bc173999926d99187a7532db11a8b4b9db93f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by the\n     * <tt>Player<\/tt> instances in {@link #players}.\n     *\n     * @param event the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     */\n    private void playerControllerUpdate(ControllerEvent event)\n    {\n        if (event instanceof RealizeCompleteEvent)\n        {\n            Player player = (Player) event.getSourceController();\n\n            if (player != null)\n            {\n                player.start();\n\n                realizeComplete(player);\n            }\n        }\n    }","id":31577,"modified_method":"/**\n     * Gets notified about <tt>ControllerEvent<\/tt>s generated by the\n     * <tt>Player<\/tt> instances in {@link #players}.\n     *\n     * @param event the <tt>ControllerEvent<\/tt> specifying the\n     * <tt>Controller<\/tt> which is the source of the event and the very type of\n     * the event\n     */\n    private void playerControllerUpdate(ControllerEvent event)\n    {\n        if (event instanceof RealizeCompleteEvent)\n        {\n            Player player = (Player) event.getSourceController();\n\n            if (player != null)\n            {\n                if (logger.isTraceEnabled())\n                    logger\n                        .trace(\n                            \"Realized Player with hashCode \"\n                                + player.hashCode());\n\n                player.start();\n\n                realizeComplete(player);\n            }\n        }\n    }","commit_id":"7512cd471a44a83dbe1abe655c50f7310852a299","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a <tt>ReceiveStream<\/tt> to this <tt>MediaDeviceSession<\/tt> to be\n     * played back on the associated <tt>MediaDevice<\/tt> and a specific\n     * <tt>DataSource<\/tt> is to be used to access its media data during the\n     * playback. The <tt>DataSource<\/tt> is explicitly specified in order to\n     * allow extenders to override the <tt>DataSource<\/tt> of the\n     * <tt>ReceiveStream<\/tt> (e.g. create a clone of it).\n     *\n     * @param receiveStream the <tt>ReceiveStream<\/tt> to be played back by this\n     * <tt>MediaDeviceSession<\/tt> on its associated <tt>MediaDevice<\/tt>\n     * @param receiveStreamDataSource the <tt>DataSource<\/tt> to be used for\n     * accessing the media data of <tt>receiveStream<\/tt> during its playback\n     */\n    protected void addReceiveStream(\n            ReceiveStream receiveStream,\n            DataSource receiveStreamDataSource)\n    {\n\n        /*\n         * Though we check for null in #addReceiveStream(ReceiveStream), we have\n         * to check again because we may have been overridden.\n         */\n        if (receiveStreamDataSource == null)\n            return;\n\n        receiveStreams.put(receiveStream, receiveStreamDataSource);\n\n        synchronized (players)\n        {\n            Player player = players.get(receiveStreamDataSource);\n\n            if (player == null)\n            {\n                Throwable exception = null;\n\n                try\n                {\n                    player = Manager.createPlayer(receiveStreamDataSource);\n                }\n                catch (IOException ioe)\n                {\n                    exception = ioe;\n                }\n                catch (NoPlayerException npe)\n                {\n                    exception = npe;\n                }\n\n                if (exception != null)\n                    logger\n                        .error(\n                            \"Failed to create player for new receive stream \"\n                                + receiveStream,\n                            exception);\n                else\n                {\n                    if (playerControllerListener == null)\n                        playerControllerListener = new ControllerListener()\n                        {\n\n                            /**\n                             * Notifies this <tt>ControllerListener<\/tt> that\n                             * the <tt>Controller<\/tt> which it is registered\n                             * with has generated an event.\n                             *\n                             * @param event the <tt>ControllerEvent<\/tt>\n                             * specifying the <tt>Controller<\/tt> which is the\n                             * source of the event and the very type of the\n                             * event\n                             * @see ControllerListener#controllerUpdate(\n                             * ControllerEvent)\n                             */\n                            public void controllerUpdate(ControllerEvent event)\n                            {\n                                playerControllerUpdate(event);\n                            }\n                        };\n                    player.addControllerListener(playerControllerListener);\n                    player.realize();\n\n                    players.put(receiveStreamDataSource, player);\n                }\n            }\n        }\n    }","id":31578,"modified_method":"/**\n     * Adds a <tt>ReceiveStream<\/tt> to this <tt>MediaDeviceSession<\/tt> to be\n     * played back on the associated <tt>MediaDevice<\/tt> and a specific\n     * <tt>DataSource<\/tt> is to be used to access its media data during the\n     * playback. The <tt>DataSource<\/tt> is explicitly specified in order to\n     * allow extenders to override the <tt>DataSource<\/tt> of the\n     * <tt>ReceiveStream<\/tt> (e.g. create a clone of it).\n     *\n     * @param receiveStream the <tt>ReceiveStream<\/tt> to be played back by this\n     * <tt>MediaDeviceSession<\/tt> on its associated <tt>MediaDevice<\/tt>\n     * @param receiveStreamDataSource the <tt>DataSource<\/tt> to be used for\n     * accessing the media data of <tt>receiveStream<\/tt> during its playback\n     */\n    protected void addReceiveStream(\n            ReceiveStream receiveStream,\n            DataSource receiveStreamDataSource)\n    {\n\n        /*\n         * Though we check for null in #addReceiveStream(ReceiveStream), we have\n         * to check again because we may have been overridden.\n         */\n        if (receiveStreamDataSource == null)\n            return;\n\n        receiveStreams.put(receiveStream, receiveStreamDataSource);\n        if (logger.isTraceEnabled())\n            logger\n                .trace(\n                    \"Added ReceiveStream with ssrc \" + receiveStream.getSSRC());\n\n        synchronized (players)\n        {\n            Player player = players.get(receiveStreamDataSource);\n\n            if (player == null)\n            {\n                Throwable exception = null;\n\n                try\n                {\n                    player = Manager.createPlayer(receiveStreamDataSource);\n                }\n                catch (IOException ioe)\n                {\n                    exception = ioe;\n                }\n                catch (NoPlayerException npe)\n                {\n                    exception = npe;\n                }\n\n                if (exception != null)\n                    logger\n                        .error(\n                            \"Failed to create player for new receive stream \"\n                                + receiveStream,\n                            exception);\n                else\n                {\n                    if (playerControllerListener == null)\n                        playerControllerListener = new ControllerListener()\n                        {\n\n                            /**\n                             * Notifies this <tt>ControllerListener<\/tt> that\n                             * the <tt>Controller<\/tt> which it is registered\n                             * with has generated an event.\n                             *\n                             * @param event the <tt>ControllerEvent<\/tt>\n                             * specifying the <tt>Controller<\/tt> which is the\n                             * source of the event and the very type of the\n                             * event\n                             * @see ControllerListener#controllerUpdate(\n                             * ControllerEvent)\n                             */\n                            public void controllerUpdate(ControllerEvent event)\n                            {\n                                playerControllerUpdate(event);\n                            }\n                        };\n                    player.addControllerListener(playerControllerListener);\n                    player.realize();\n\n                    if (logger.isTraceEnabled())\n                        logger\n                            .trace(\n                                \"Created Player with hashCode \"\n                                    + player.hashCode()\n                                    + \" for ReceiveStream with ssrc \"\n                                    + receiveStream.getSSRC());\n\n                    players.put(receiveStreamDataSource, player);\n                }\n            }\n        }\n    }","commit_id":"7512cd471a44a83dbe1abe655c50f7310852a299","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies this <tt>ReceiveStreamListener<\/tt> that the <tt>RTPManager<\/tt>\n     * it is registered with has generated an event related to a <tt>ReceiveStream<\/tt>.\n     *\n     * @param event the <tt>ReceiveStreamEvent<\/tt> which specifies the\n     * <tt>ReceiveStream<\/tt> that is the cause of the event and the very type\n     * of the event\n     * @see ReceiveStreamListener#update(ReceiveStreamEvent)\n     */\n    public void update(ReceiveStreamEvent event)\n    {\n        if (event instanceof NewReceiveStreamEvent)\n        {\n            ReceiveStream receiveStream = event.getReceiveStream();\n\n            if (receiveStream != null)\n                synchronized (receiveStreams)\n                {\n                    if (!receiveStreams.contains(receiveStream)\n                            && receiveStreams.add(receiveStream))\n                    {\n                        MediaDeviceSession deviceSession = getDeviceSession();\n\n                        if (deviceSession != null)\n                            deviceSession.addReceiveStream(receiveStream);\n                    }\n                }\n        }\n        else if (event instanceof TimeoutEvent)\n        {\n            ReceiveStream receiveStream = event.getReceiveStream();\n\n            if (receiveStream != null)\n                synchronized (receiveStreams)\n                {\n                    if (receiveStreams.remove(receiveStream))\n                    {\n                        MediaDeviceSession deviceSession = getDeviceSession();\n\n                        if (deviceSession != null)\n                            deviceSession.removeReceiveStream(receiveStream);\n                    }\n                }\n        }\n    }","id":31579,"modified_method":"/**\n     * Notifies this <tt>ReceiveStreamListener<\/tt> that the <tt>RTPManager<\/tt>\n     * it is registered with has generated an event related to a <tt>ReceiveStream<\/tt>.\n     *\n     * @param event the <tt>ReceiveStreamEvent<\/tt> which specifies the\n     * <tt>ReceiveStream<\/tt> that is the cause of the event and the very type\n     * of the event\n     * @see ReceiveStreamListener#update(ReceiveStreamEvent)\n     */\n    public void update(ReceiveStreamEvent event)\n    {\n        if (event instanceof NewReceiveStreamEvent)\n        {\n            ReceiveStream receiveStream = event.getReceiveStream();\n\n            if (receiveStream != null)\n            {\n                if (logger.isTraceEnabled())\n                    logger\n                        .trace(\n                            \"Received new ReceiveStream with ssrc \"\n                                + receiveStream.getSSRC());\n\n                synchronized (receiveStreams)\n                {\n                    if (!receiveStreams.contains(receiveStream)\n                            && receiveStreams.add(receiveStream))\n                    {\n                        MediaDeviceSession deviceSession = getDeviceSession();\n\n                        if (deviceSession != null)\n                            deviceSession.addReceiveStream(receiveStream);\n                    }\n                }\n            }\n        }\n        else if (event instanceof TimeoutEvent)\n        {\n            ReceiveStream receiveStream = event.getReceiveStream();\n\n            if (receiveStream != null)\n                synchronized (receiveStreams)\n                {\n                    if (receiveStreams.remove(receiveStream))\n                    {\n                        MediaDeviceSession deviceSession = getDeviceSession();\n\n                        if (deviceSession != null)\n                            deviceSession.removeReceiveStream(receiveStream);\n                    }\n                }\n        }\n    }","commit_id":"7512cd471a44a83dbe1abe655c50f7310852a299","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies the <tt>VideoListener<\/tt>s registered with this instance about\n     * a specific type of change in the availability of a specific visual\n     * <tt>Component<\/tt> depicting video.\n     *\n     * @param type the type of change as defined by <tt>VideoEvent<\/tt> in the\n     * availability of the specified visual <tt>Component<\/tt> depicting video\n     * @param visualComponent the visual <tt>Component<\/tt> depicting video\n     * which has been added or removed in this instance\n     * @param origin {@link VideoEvent#LOCAL} if the origin of the video is\n     * local (e.g. it is being locally captured); {@link VideoEvent#REMOTE} if\n     * the origin of the video is remote (e.g. a remote peer is streaming it)\n     */\n    protected void fireVideoEvent(\n            int type,\n            Component visualComponent,\n            int origin)\n    {\n        videoNotifierSupport.fireVideoEvent(type, visualComponent, origin);\n    }","id":31580,"modified_method":"/**\n     * Notifies the <tt>VideoListener<\/tt>s registered with this instance about\n     * a specific type of change in the availability of a specific visual\n     * <tt>Component<\/tt> depicting video.\n     *\n     * @param type the type of change as defined by <tt>VideoEvent<\/tt> in the\n     * availability of the specified visual <tt>Component<\/tt> depicting video\n     * @param visualComponent the visual <tt>Component<\/tt> depicting video\n     * which has been added or removed in this instance\n     * @param origin {@link VideoEvent#LOCAL} if the origin of the video is\n     * local (e.g. it is being locally captured); {@link VideoEvent#REMOTE} if\n     * the origin of the video is remote (e.g. a remote peer is streaming it)\n     * @return <tt>true<\/tt> if this event and, more specifically, the visual\n     * <tt>Component<\/tt> it describes have been consumed and should be\n     * considered owned, referenced (which is important because\n     * <tt>Component<\/tt>s belong to a single <tt>Container<\/tt> at a time);\n     * otherwise, <tt>false<\/tt>\n     */\n    protected boolean fireVideoEvent(\n            int type,\n            Component visualComponent,\n            int origin)\n    {\n        if (logger.isTraceEnabled())\n            logger\n                .trace(\n                    \"Firing VideoEvent with type \"\n                        + VideoEvent.typeToString(type)\n                        + \" and origin \"\n                        + VideoEvent.originToString(origin));\n\n        return\n            videoNotifierSupport.fireVideoEvent(type, visualComponent, origin);\n    }","commit_id":"7512cd471a44a83dbe1abe655c50f7310852a299","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies the <tt>VideoListener<\/tt>s registered with this\n     * <tt>VideoMediaStream<\/tt> about a specific type of change in the\n     * availability of a specific visual <tt>Component<\/tt> depicting video.\n     *\n     * @param type the type of change as defined by <tt>VideoEvent<\/tt> in the\n     * availability of the specified visual <tt>Component<\/tt> depicting video\n     * @param visualComponent the visual <tt>Component<\/tt> depicting video\n     * which has been added or removed in this <tt>VideoMediaStream<\/tt>\n     * @param origin {@link VideoEvent#LOCAL} if the origin of the video is\n     * local (e.g. it is being locally captured); {@link VideoEvent#REMOTE} if\n     * the origin of the video is remote (e.g. a remote peer is streaming it)\n     */\n    protected void fireVideoEvent(\n            int type,\n            Component visualComponent,\n            int origin)\n    {\n        videoNotifierSupport.fireVideoEvent(type, visualComponent, origin);\n    }","id":31581,"modified_method":"/**\n     * Notifies the <tt>VideoListener<\/tt>s registered with this\n     * <tt>VideoMediaStream<\/tt> about a specific type of change in the\n     * availability of a specific visual <tt>Component<\/tt> depicting video.\n     *\n     * @param type the type of change as defined by <tt>VideoEvent<\/tt> in the\n     * availability of the specified visual <tt>Component<\/tt> depicting video\n     * @param visualComponent the visual <tt>Component<\/tt> depicting video\n     * which has been added or removed in this <tt>VideoMediaStream<\/tt>\n     * @param origin {@link VideoEvent#LOCAL} if the origin of the video is\n     * local (e.g. it is being locally captured); {@link VideoEvent#REMOTE} if\n     * the origin of the video is remote (e.g. a remote peer is streaming it)\n     * @return <tt>true<\/tt> if this event and, more specifically, the visual\n     * <tt>Component<\/tt> it describes have been consumed and should be\n     * considered owned, referenced (which is important because\n     * <tt>Component<\/tt>s belong to a single <tt>Container<\/tt> at a time);\n     * otherwise, <tt>false<\/tt>\n     */\n    protected boolean fireVideoEvent(\n            int type,\n            Component visualComponent,\n            int origin)\n    {\n        if (logger.isTraceEnabled())\n            logger\n                .trace(\n                    \"Firing VideoEvent with type \"\n                        + VideoEvent.typeToString(type)\n                        + \" and origin \"\n                        + VideoEvent.originToString(origin));\n\n        return\n            videoNotifierSupport.fireVideoEvent(type, visualComponent, origin);\n    }","commit_id":"7512cd471a44a83dbe1abe655c50f7310852a299","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies this <tt>MediaStream<\/tt> that the <tt>MediaDevice<\/tt> (and\n     * respectively the <tt>MediaDeviceSession<\/tt> with it) which this instance\n     * uses for capture and playback of media has been changed. Makes sure that\n     * the <tt>VideoListener<\/tt>s of this instance get <tt>VideoEvent<\/tt>s for\n     * the new/current <tt>VideoMediaDeviceSession<\/tt> and not for the old one.\n     *\n     * @param oldValue the <tt>MediaDeviceSession<\/tt> with the\n     * <tt>MediaDevice<\/tt> this instance used work with\n     * @param newValue the <tt>MediaDeviceSession<\/tt> with the\n     * <tt>MediaDevice<\/tt> this instance is to work with\n     * @see MediaStreamImpl#deviceSessionChanged(MediaDeviceSession,\n     * MediaDeviceSession)\n     */\n    @Override\n    protected void deviceSessionChanged(\n            MediaDeviceSession oldValue,\n            MediaDeviceSession newValue)\n    {\n        super.deviceSessionChanged(oldValue, newValue);\n\n        if ((oldValue instanceof VideoMediaDeviceSession)\n                && (deviceSessionVideoListener != null))\n            ((VideoMediaDeviceSession) oldValue)\n                .removeVideoListener(deviceSessionVideoListener);\n        if (newValue instanceof VideoMediaDeviceSession)\n        {\n            if (deviceSessionVideoListener == null)\n                deviceSessionVideoListener = new VideoListener()\n                {\n\n                    /**\n                     * Notifies that a visual <tt>Component<\/tt> representing\n                     * video has been added to the provider this listener has\n                     * been added to.\n                     *\n                     * @param e a <tt>VideoEvent<\/tt> describing the added\n                     * visual <tt>Component<\/tt> representing video and the\n                     * provider it was added into\n                     * @see VideoListener#videoAdded(VideoEvent)\n                     */\n                    public void videoAdded(VideoEvent e)\n                    {\n                        fireVideoEvent(\n                            e.getType(),\n                            e.getVisualComponent(),\n                            e.getOrigin());\n                    }\n\n                    /**\n                     * Notifies that a visual <tt>Component<\/tt> representing\n                     * video has been removed from the provider this listener\n                     * has been added to.\n                     *\n                     * @param e a <tt>VideoEvent<\/tt> describing the removed\n                     * visual <tt>Component<\/tt> representing video and the\n                     * provider it was removed from\n                     * @see VideoListener#videoRemoved(VideoEvent)\n                     */\n                    public void videoRemoved(VideoEvent e)\n                    {\n                        fireVideoEvent(\n                            e.getType(),\n                            e.getVisualComponent(),\n                            e.getOrigin());\n                    }\n                };\n\n            ((VideoMediaDeviceSession) newValue)\n                .addVideoListener(deviceSessionVideoListener);\n        }\n    }","id":31582,"modified_method":"/**\n     * Notifies this <tt>MediaStream<\/tt> that the <tt>MediaDevice<\/tt> (and\n     * respectively the <tt>MediaDeviceSession<\/tt> with it) which this instance\n     * uses for capture and playback of media has been changed. Makes sure that\n     * the <tt>VideoListener<\/tt>s of this instance get <tt>VideoEvent<\/tt>s for\n     * the new/current <tt>VideoMediaDeviceSession<\/tt> and not for the old one.\n     *\n     * @param oldValue the <tt>MediaDeviceSession<\/tt> with the\n     * <tt>MediaDevice<\/tt> this instance used work with\n     * @param newValue the <tt>MediaDeviceSession<\/tt> with the\n     * <tt>MediaDevice<\/tt> this instance is to work with\n     * @see MediaStreamImpl#deviceSessionChanged(MediaDeviceSession,\n     * MediaDeviceSession)\n     */\n    @Override\n    protected void deviceSessionChanged(\n            MediaDeviceSession oldValue,\n            MediaDeviceSession newValue)\n    {\n        super.deviceSessionChanged(oldValue, newValue);\n\n        if ((oldValue instanceof VideoMediaDeviceSession)\n                && (deviceSessionVideoListener != null))\n            ((VideoMediaDeviceSession) oldValue)\n                .removeVideoListener(deviceSessionVideoListener);\n        if (newValue instanceof VideoMediaDeviceSession)\n        {\n            if (deviceSessionVideoListener == null)\n                deviceSessionVideoListener = new VideoListener()\n                {\n\n                    /**\n                     * Notifies that a visual <tt>Component<\/tt> representing\n                     * video has been added to the provider this listener has\n                     * been added to.\n                     *\n                     * @param e a <tt>VideoEvent<\/tt> describing the added\n                     * visual <tt>Component<\/tt> representing video and the\n                     * provider it was added into\n                     * @see VideoListener#videoAdded(VideoEvent)\n                     */\n                    public void videoAdded(VideoEvent e)\n                    {\n                        if (fireVideoEvent(\n                                e.getType(),\n                                e.getVisualComponent(),\n                                e.getOrigin()))\n                            e.consume();\n                    }\n\n                    /**\n                     * Notifies that a visual <tt>Component<\/tt> representing\n                     * video has been removed from the provider this listener\n                     * has been added to.\n                     *\n                     * @param e a <tt>VideoEvent<\/tt> describing the removed\n                     * visual <tt>Component<\/tt> representing video and the\n                     * provider it was removed from\n                     * @see VideoListener#videoRemoved(VideoEvent)\n                     */\n                    public void videoRemoved(VideoEvent e)\n                    {\n                        if (fireVideoEvent(\n                                e.getType(),\n                                e.getVisualComponent(),\n                                e.getOrigin()))\n                            e.consume();\n                    }\n                };\n\n            ((VideoMediaDeviceSession) newValue)\n                .addVideoListener(deviceSessionVideoListener);\n        }\n    }","commit_id":"7512cd471a44a83dbe1abe655c50f7310852a299","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies the <tt>VideoListener<\/tt>s registered with this\n     * <tt>VideoMediaStream<\/tt> about a specific type of change in the\n     * availability of a specific visual <tt>Component<\/tt> depicting video.\n     *\n     * @param type the type of change as defined by <tt>VideoEvent<\/tt> in the\n     * availability of the specified visual <tt>Component<\/tt> depicting video\n     * @param visualComponent the visual <tt>Component<\/tt> depicting video\n     * which has been added or removed\n     * @param origin {@link VideoEvent#LOCAL} if the origin of the video is\n     * local (e.g. it is being locally captured); {@link VideoEvent#REMOTE} if\n     * the origin of the video is remote (e.g. a remote peer is streaming it)\n     */\n    public void fireVideoEvent(\n            int type,\n            Component visualComponent,\n            int origin)\n    {\n        VideoListener[] listeners;\n\n        synchronized (this.listeners)\n        {\n            listeners\n                = this.listeners\n                    .toArray(new VideoListener[this.listeners.size()]);\n        }\n\n        if (listeners.length > 0)\n        {\n            VideoEvent event\n                = new VideoEvent(source, type, visualComponent, origin);\n\n            for (VideoListener listener : listeners)\n                switch (type)\n                {\n                    case VideoEvent.VIDEO_ADDED:\n                        listener.videoAdded(event);\n                        break;\n                    case VideoEvent.VIDEO_REMOVED:\n                        listener.videoRemoved(event);\n                        break;\n                }\n        }\n    }","id":31583,"modified_method":"/**\n     * Notifies the <tt>VideoListener<\/tt>s registered with this\n     * <tt>VideoMediaStream<\/tt> about a specific type of change in the\n     * availability of a specific visual <tt>Component<\/tt> depicting video.\n     *\n     * @param type the type of change as defined by <tt>VideoEvent<\/tt> in the\n     * availability of the specified visual <tt>Component<\/tt> depicting video\n     * @param visualComponent the visual <tt>Component<\/tt> depicting video\n     * which has been added or removed\n     * @param origin {@link VideoEvent#LOCAL} if the origin of the video is\n     * local (e.g. it is being locally captured); {@link VideoEvent#REMOTE} if\n     * the origin of the video is remote (e.g. a remote peer is streaming it)\n     * @return <tt>true<\/tt> if this event and, more specifically, the visual\n     * <tt>Component<\/tt> it describes have been consumed and should be\n     * considered owned, referenced (which is important because\n     * <tt>Component<\/tt>s belong to a single <tt>Container<\/tt> at a time);\n     * otherwise, <tt>false<\/tt>\n     */\n    public boolean fireVideoEvent(\n            int type,\n            Component visualComponent,\n            int origin)\n    {\n        VideoListener[] listeners;\n\n        synchronized (this.listeners)\n        {\n            listeners\n                = this.listeners\n                    .toArray(new VideoListener[this.listeners.size()]);\n        }\n\n        boolean consumed;\n\n        if (listeners.length > 0)\n        {\n            VideoEvent event\n                = new VideoEvent(source, type, visualComponent, origin);\n\n            for (VideoListener listener : listeners)\n                switch (type)\n                {\n                    case VideoEvent.VIDEO_ADDED:\n                        listener.videoAdded(event);\n                        break;\n                    case VideoEvent.VIDEO_REMOVED:\n                        listener.videoRemoved(event);\n                        break;\n                }\n\n            consumed = event.isConsumed();\n        }\n        else\n            consumed = false;\n        return consumed;\n    }","commit_id":"7512cd471a44a83dbe1abe655c50f7310852a299","url":"https://github.com/jitsi/jitsi"},{"original_method":"protected boolean isInTrashContainer(ClassedModel classedModel)\n\t\tthrows Exception {\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassedModel.getModelClass().getName());\n\n\t\treturn trashHandler.isInTrashContainer(getAssetClassPK(baseModel));\n\t}","id":31584,"modified_method":"protected boolean isInTrashContainer(ClassedModel classedModel)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = classedModel.getModelClass();\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclazz.getName());\n\n\t\treturn trashHandler.isInTrashContainer(getAssetClassPK(baseModel));\n\t}","commit_id":"7e44ffdfe6c5abfa3712b5ea8d26a3edb8c48786","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> updateBaseModel(\n\t\t\tlong primaryKey, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJournalArticle article = JournalArticleLocalServiceUtil.getArticle(\n\t\t\tprimaryKey);\n\n\t\tString title = \"Content: Enterprise. Open Source. For Life.\";\n\n\t\treturn JournalTestUtil.updateArticle(\n\t\t\tarticle, title, article.getContent());\n\t}","id":31585,"modified_method":"@Override\n\tprotected BaseModel<?> updateBaseModel(\n\t\t\tlong primaryKey, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJournalArticle article = JournalArticleLocalServiceUtil.getArticle(\n\t\t\tprimaryKey);\n\n\t\treturn JournalTestUtil.updateArticle(\n\t\t\tarticle, \"Content: Enterprise. Open Source. For Life.\",\n\t\t\tarticle.getContent());\n\t}","commit_id":"7e44ffdfe6c5abfa3712b5ea8d26a3edb8c48786","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendStatusMessage() {\n\t\tif (!BackgroundTaskThreadLocal.hasBackgroundTask()) {\n\t\t\treturn;\n\t\t}\n\n\t\tIndexer<?> indexer = IndexerRegistryUtil.getIndexer(getModelClass());\n\n\t\tReindexStatusMessageSenderUtil.sendStatusMessage(\n\t\t\tindexer.getClassName(), _progress, _count);\n\t}","id":31586,"modified_method":"protected void sendStatusMessage() {\n\t\tif (!BackgroundTaskThreadLocal.hasBackgroundTask()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> modelClass = getModelClass();\n\n\t\tReindexStatusMessageSenderUtil.sendStatusMessage(\n\t\t\tmodelClass.getName(), _progress, _count);\n\t}","commit_id":"754254154f7759b6fbdbd9f197bf96e105a0244d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected AssetEntry fetchAssetEntry(ClassedModel classedModel)\n\t\tthrows Exception {\n\n\t\treturn fetchAssetEntry(\n\t\t\tclassedModel.getModelClass(),\n\t\t\t(Long)classedModel.getPrimaryKeyObj());\n\t}","id":31587,"modified_method":"protected AssetEntry fetchAssetEntry(ClassedModel classedModel)\n\t\tthrows Exception {\n\n\t\tClass<?> modelClass = classedModel.getModelClass();\n\n\t\treturn AssetEntryLocalServiceUtil.fetchEntry(\n\t\t\tmodelClass.getName(), (Long)classedModel.getPrimaryKeyObj());\n\t}","commit_id":"3f82e0ecb60149a9d5d1b9c8202bd6be2a3be5ca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testVariableExpressionInThen() {\n    final OgnlConditionalExpression expression = parse(\"true ? #this : 1\");\n\n    final OgnlExpression thenExpression = (OgnlExpression) expression.getThen();\n    assertElementType(OgnlElementTypes.VARIABLE_EXPRESSION, thenExpression);\n  }","id":31588,"modified_method":"public void testVariableExpressionInThen() {\n    final OgnlConditionalExpression expression = parse(\"true ? #this : 1\");\n\n    final OgnlExpression thenExpression = expression.getThen();\n    assertElementType(OgnlElementTypes.VARIABLE_EXPRESSION, thenExpression);\n  }","commit_id":"94f526a3320a65fb7d0ccdc2f239737d2401d6a1","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testBinaryExpressionInThen() {\n    final OgnlConditionalExpression expression = parse(\"true ? 1 + 2 : 1\");\n\n    final OgnlExpression thenExpression = (OgnlExpression) expression.getThen();\n    assertElementType(OgnlElementTypes.BINARY_EXPRESSION, thenExpression);\n  }","id":31589,"modified_method":"public void testBinaryExpressionInThen() {\n    final OgnlConditionalExpression expression = parse(\"true ? 1 + 2 : 1\");\n\n    final OgnlExpression thenExpression = expression.getThen();\n    assertElementType(OgnlElementTypes.BINARY_EXPRESSION, thenExpression);\n  }","commit_id":"94f526a3320a65fb7d0ccdc2f239737d2401d6a1","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testParenthesizedExpressionInThen() {\n    final OgnlConditionalExpression expression = parse(\"true ? (1 + 2) : 1\");\n\n    final OgnlElement thenExpression = expression.getThen();\n    assertEquals(OgnlElementTypes.PARENTHESIZED_EXPRESSION, thenExpression.getNode().getElementType());\n  }","id":31590,"modified_method":"public void testParenthesizedExpressionInThen() {\n    final OgnlConditionalExpression expression = parse(\"true ? (1 + 2) : 1\");\n\n    final OgnlExpression thenExpression = expression.getThen();\n    assertElementType(OgnlElementTypes.PARENTHESIZED_EXPRESSION, thenExpression);\n  }","commit_id":"94f526a3320a65fb7d0ccdc2f239737d2401d6a1","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testSimple() {\n    final OgnlConditionalExpression expression = parse(\"true ? 0:1\");\n\n    final OgnlExpression condition = expression.getCondition();\n    assertEquals(\"true\", condition.getText());\n    assertElementType(OgnlElementTypes.BOOLEAN_LITERAL, condition);\n\n    final OgnlExpression thenExpression = (OgnlExpression) expression.getThen();\n    assertEquals(0, thenExpression.getConstantValue());\n    assertElementType(OgnlElementTypes.INTEGER_LITERAL, thenExpression);\n\n    final OgnlExpression elseExpression = (OgnlExpression) expression.getElse();\n    assertEquals(1, elseExpression.getConstantValue());\n    assertElementType(OgnlElementTypes.INTEGER_LITERAL, elseExpression);\n  }","id":31591,"modified_method":"public void testSimple() {\n    final OgnlConditionalExpression expression = parse(\"true ? 0:1\");\n\n    final OgnlExpression condition = expression.getCondition();\n    assertEquals(\"true\", condition.getText());\n    assertElementType(OgnlElementTypes.BOOLEAN_LITERAL, condition);\n\n    final OgnlExpression thenExpression = expression.getThen();\n    assertEquals(0, thenExpression.getConstantValue());\n    assertElementType(OgnlElementTypes.INTEGER_LITERAL, thenExpression);\n\n    final OgnlExpression elseExpression = expression.getElse();\n    assertEquals(1, elseExpression.getConstantValue());\n    assertElementType(OgnlElementTypes.INTEGER_LITERAL, elseExpression);\n  }","commit_id":"94f526a3320a65fb7d0ccdc2f239737d2401d6a1","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public OgnlElement getThen() {\n    return findElement(1);\n  }","id":31592,"modified_method":"@NotNull\n  public OgnlExpression getThen() {\n    return findExpression(1);\n  }","commit_id":"94f526a3320a65fb7d0ccdc2f239737d2401d6a1","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public OgnlElement getElse() {\n    return findElement(2);\n  }","id":31593,"modified_method":"@NotNull\n  public OgnlExpression getElse() {\n    return findExpression(2);\n  }","commit_id":"94f526a3320a65fb7d0ccdc2f239737d2401d6a1","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Prints the results and statistics about performance.\n     * @param procedure The name of the stored procedure that was tested.\n     *        fw        File writer object to write stats to.\n     * @throws Exception if anything unexpected happens.\n     */\n    public synchronized void printResults(String procedure, FileWriter fw, String suffix) throws Exception {\n        ClientStats stats = fullStatsContext.fetchAndResetBaseline().getStats();\n        double execTimeInMicroSec = 0.0;\n\n        // 1. Results and performance statistics\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Results\");\n        System.out.println(HORIZONTAL_RULE);\n\n        System.out.printf(\"Average throughput: %,9d txns/sec\\n\", stats.getTxnThroughput());\n\n        VoltTable procStats = client.callProcedure(\"@Statistics\",\n                                                   \"procedureprofile\",\n                                                   0).getResults()[0];\n\n        while (procStats.advanceRow()) {\n            String procName = procStats.getString(\"PROCEDURE\");\n            if (procName.equals(procedure)) {\n                execTimeInMicroSec = (procStats.getLong(\"AVG\") / 1000.0);\n                System.out.printf(\"Average execution time: %,9f usec\\n\", execTimeInMicroSec);\n                break;\n            }\n        }\n\n        // 3. Write stats to file if requested\n        fw.append(String.format(\"%s,%d,-1,%d,0,0,0,%.2f,0,0,0,0,0,0\\n\",\n                                suffix,\n                                stats.getStartTimestamp(),\n                                stats.getTxnThroughput(),\n                                execTimeInMicroSec));\n\n        // Expecting the custom insert/delete procedure names ex. ids_insert\n        if (procedure.split(\"_\")[1].equals(\"insert\")) {\n            if (insert_throughput > 0) {\n                insert_throughput = Math.abs(insert_throughput - stats.getTxnThroughput());\n                insert_execute = Math.abs(insert_execute - execTimeInMicroSec);\n                fw.append(String.format(\"%s,%d,-1,%d,0,0,0,%.2f,0,0,0,0,0,0\\n\",\n                                        \"Insert_Diff\",\n                                        stats.getStartTimestamp(),\n                                        insert_throughput,\n                                        insert_execute));\n            } else {\n                insert_throughput = stats.getTxnThroughput();\n                insert_execute = execTimeInMicroSec;\n            }\n        } else {\n            if (delete_throughput > 0) {\n                delete_throughput = Math.abs(delete_throughput - stats.getTxnThroughput());\n                delete_execute = Math.abs(delete_execute - execTimeInMicroSec);\n                fw.append(String.format(\"%s,%d,-1,%d,0,0,0,%.2f,0,0,0,0,0,0\\n\",\n                                        \"Delete_Diff\",\n                                        stats.getStartTimestamp(),\n                                        delete_throughput,\n                                        delete_execute));\n            } else {\n                delete_throughput = stats.getTxnThroughput();\n                delete_execute = execTimeInMicroSec;\n            }\n        }\n    }","id":31594,"modified_method":"/**\n     * Prints the results and statistics about performance.\n     * @param procedure The name of the stored procedure that was tested.\n     *        fw        File writer object to write stats to.\n     * @throws Exception if anything unexpected happens.\n     */\n    public synchronized void printResults(String procedure, FileWriter fw, String suffix) throws Exception {\n        ClientStats stats = fullStatsContext.fetchAndResetBaseline().getStats();\n        double execTimeInMicroSec = 0.0;\n\n        // 1. Results and performance statistics\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Results\");\n        System.out.println(HORIZONTAL_RULE);\n\n        System.out.printf(\"Average throughput: %,9d txns/sec\\n\", stats.getTxnThroughput());\n\n        VoltTable procStats = client.callProcedure(\"@Statistics\",\n                                                   \"procedureprofile\",\n                                                   0).getResults()[0];\n\n        while (procStats.advanceRow()) {\n            String procName = procStats.getString(\"PROCEDURE\");\n            if (procName.equals(procedure)) {\n                execTimeInMicroSec = (procStats.getLong(\"AVG\") / 1000.0);\n                System.out.printf(\"Average execution time: %,9f usec\\n\", execTimeInMicroSec);\n                break;\n            }\n        }\n\n        // 3. Write stats to file if requested\n        fw.append(String.format(\"%s,%d,-1,%d,0,0,0,%.2f,0,0,0,0,0,0\\n\",\n                                suffix,\n                                stats.getStartTimestamp(),\n                                stats.getTxnThroughput(),\n                                execTimeInMicroSec));\n\n        // Expecting the custom insert/delete procedure names ex. ids_insert\n        if (procedure.split(\"_\")[1].equals(\"insert\")) {\n            if (insert_throughput > 0) {\n                insert_throughput = (((stats.getTxnThroughput() - insert_throughput) /\n                                      stats.getTxnThroughput()) * 100);\n                insert_execute = (((insert_execute - execTimeInMicroSec) /\n                                   execTimeInMicroSec) * 100);\n                fw.append(String.format(\"%s,%d,-1,%.2f,0,0,0,%.2f,0,0,0,0,0,0\\n\",\n                                        \"Insert Diff\",\n                                        stats.getStartTimestamp(),\n                                        insert_throughput,\n                                        insert_execute));\n            } else {\n                insert_throughput = (double)stats.getTxnThroughput();\n                insert_execute = execTimeInMicroSec;\n            }\n        } else {\n            if (delete_throughput > 0) {\n                delete_throughput = (((stats.getTxnThroughput() - delete_throughput) /\n                                      stats.getTxnThroughput()) * 100.0);\n                delete_execute = (((delete_execute - execTimeInMicroSec) /\n                                   execTimeInMicroSec) * 100);\n                fw.append(String.format(\"%s,%d,-1,%.2f,0,0,0,%.2f,0,0,0,0,0,0\\n\",\n                                        \"Delete Diff\",\n                                        stats.getStartTimestamp(),\n                                        delete_throughput,\n                                        delete_execute));\n            } else {\n                delete_throughput = (double)stats.getTxnThroughput();\n                delete_execute = execTimeInMicroSec;\n            }\n        }\n    }","commit_id":"db737733a7172643f53d69214253d46bcfa57429","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @param configPath  path to configuration file\n     *\n     * @throws Exception\n     */\n    public void runBenchmark() throws Exception {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // connect to one or more servers, loop until success\n        connect(config.servers);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Starting Benchmark\");\n        System.out.println(HORIZONTAL_RULE);\n\n        benchmarkActive = true;\n\n        // Run the benchmark loop for the requested warmup time\n        // The throughput may be throttled depending on client configuration\n        if (config.warmup > 0) {\n            System.out.println(\"Warming up...\");\n            for (int i=0; i<config.warmup; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_insert\",\n                                     i,\n                                     i);\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_insert\",\n                                     i,\n                                     i);\n            }\n            client.drain();\n            for (int i=0; i<config.warmup; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_delete\",\n                                     i);\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_delete\",\n                                     i);\n            }\n            client.drain();\n        }\n\n        int grp = 1;\n        FileWriter fw = null;\n        if ((config.statsfile != null) && (config.statsfile.length() != 0)) {\n            fw = new FileWriter(config.statsfile);\n        }\n\n        // reset the stats after warmup\n        fullStatsContext.fetchAndResetBaseline();\n        periodicStatsContext.fetchAndResetBaseline();\n\n        // print periodic statistics to the console\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n\n        // Run the benchmark for the requested duration.\n        System.out.println(\"\\nRunning benchmark...\\n\");\n        System.out.println(\"\\n\\nInserting into table w/ materialized view...\\n\");\n\n        if (config.group > 0) {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_insert\",\n                                     i,\n                                     grp);\n                if (grp == config.group) {\n                    grp = 1;\n                } else {\n                    grp++;\n                }\n            }\n        } else {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_insert\",\n                                     i,\n                                     i);\n            }\n        }\n        timer.cancel();\n        client.drain();\n\n        grp = 1;\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"idsWithMatView_insert\");\n        } else {\n            printResults(\"idsWithMatView_insert\", fw, \"insert_wmv\");\n        }\n        System.out.print(HORIZONTAL_RULE);\n\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n\n        System.out.println(\"\\n\\nDeleting from table w/ materialized view...\\n\");\n        for (int i=0; i<config.txn; i++){\n            client.callProcedure(new NullCallback(),\n                                 \"idsWithMatView_delete\",\n                                 i);\n        }\n        timer.cancel();\n        client.drain();\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"idsWithMatView_delete\");\n        } else {\n            printResults(\"idsWithMatView_delete\", fw, \"delete_wmv\");\n        }\n        System.out.print(HORIZONTAL_RULE);\n\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n        System.out.println(\"\\n\\nInserting into table w/o materialized view...\\n\");\n        if (config.group > 0) {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_insert\",\n                                     i,\n                                     grp);\n                if (grp == config.group) {\n                    grp = 1;\n                } else {\n                    grp++;\n                }\n            }\n        } else {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_insert\",\n                                     i,\n                                     i);\n            }\n        }\n        timer.cancel();\n        client.drain();\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"ids_insert\");\n        } else {\n            printResults(\"ids_insert\", fw, \"insert_womv\");\n        }\n        System.out.print(HORIZONTAL_RULE);\n\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n        System.out.println(\"\\n\\nDeleting from table w/o materialized view...\\n\");\n        for (int i=0; i<config.txn; i++){\n            client.callProcedure(new NullCallback(),\n                                 \"ids_delete\",\n                                 i);\n        }\n        timer.cancel();\n        client.drain();\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"ids_delete\");\n        } else {\n            printResults(\"ids_delete\", fw, \"delete_womv\");\n            fw.close();\n        }\n        benchmarkActive = false;\n\n        // close down the client connections\n        client.close();\n    }","id":31595,"modified_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @param configPath  path to configuration file\n     *\n     * @throws Exception\n     */\n    public void runBenchmark() throws Exception {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // connect to one or more servers, loop until success\n        connect(config.servers);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Starting Benchmark\");\n        System.out.println(HORIZONTAL_RULE);\n\n        benchmarkActive = true;\n\n        // Run the benchmark loop for the requested warmup time\n        // The throughput may be throttled depending on client configuration\n        if (config.warmup > 0) {\n            System.out.println(\"Warming up...\");\n            for (int i=0; i<config.warmup; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_insert\",\n                                     i,\n                                     i);\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_insert\",\n                                     i,\n                                     i);\n            }\n            client.drain();\n            for (int i=0; i<config.warmup; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_delete\",\n                                     i);\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_delete\",\n                                     i);\n            }\n            client.drain();\n        }\n\n        int grp = 1;\n        FileWriter fw = null;\n        if ((config.statsfile != null) && (config.statsfile.length() != 0)) {\n            fw = new FileWriter(config.statsfile);\n        }\n\n        // reset the stats after warmup\n        fullStatsContext.fetchAndResetBaseline();\n        periodicStatsContext.fetchAndResetBaseline();\n\n        // print periodic statistics to the console\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n\n        // Run the benchmark for the requested duration.\n        System.out.println(\"\\nRunning benchmark...\\n\");\n        System.out.println(\"\\n\\nInserting into table w/ materialized view...\\n\");\n\n        if (config.group > 0) {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_insert\",\n                                     i,\n                                     grp);\n                if (grp == config.group) {\n                    grp = 1;\n                } else {\n                    grp++;\n                }\n            }\n        } else {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"idsWithMatView_insert\",\n                                     i,\n                                     i);\n            }\n        }\n        timer.cancel();\n        client.drain();\n\n        grp = 1;\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"idsWithMatView_insert\");\n        } else {\n            printResults(\"idsWithMatView_insert\", fw, \"Insert w/ MV\");\n        }\n        System.out.print(HORIZONTAL_RULE);\n\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n\n        System.out.println(\"\\n\\nDeleting from table w/ materialized view...\\n\");\n        for (int i=0; i<config.txn; i++){\n            client.callProcedure(new NullCallback(),\n                                 \"idsWithMatView_delete\",\n                                 i);\n        }\n        timer.cancel();\n        client.drain();\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"idsWithMatView_delete\");\n        } else {\n            printResults(\"idsWithMatView_delete\", fw, \"Delete w/ MV\");\n        }\n        System.out.print(HORIZONTAL_RULE);\n\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n        System.out.println(\"\\n\\nInserting into table w/o materialized view...\\n\");\n        if (config.group > 0) {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_insert\",\n                                     i,\n                                     grp);\n                if (grp == config.group) {\n                    grp = 1;\n                } else {\n                    grp++;\n                }\n            }\n        } else {\n            for (int i=0; i<config.txn; i++){\n                client.callProcedure(new NullCallback(),\n                                     \"ids_insert\",\n                                     i,\n                                     i);\n            }\n        }\n        timer.cancel();\n        client.drain();\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"ids_insert\");\n        } else {\n            printResults(\"ids_insert\", fw, \"Insert w/o MV\");\n        }\n        System.out.print(HORIZONTAL_RULE);\n\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n        System.out.println(\"\\n\\nDeleting from table w/o materialized view...\\n\");\n        for (int i=0; i<config.txn; i++){\n            client.callProcedure(new NullCallback(),\n                                 \"ids_delete\",\n                                 i);\n        }\n        timer.cancel();\n        client.drain();\n\n        if ((config.statsfile == null) || (config.statsfile.length() == 0)) {\n            printResults(\"ids_delete\");\n        } else {\n            printResults(\"ids_delete\", fw, \"Delete w/o MV\");\n            fw.close();\n        }\n        benchmarkActive = false;\n\n        // close down the client connections\n        client.close();\n    }","commit_id":"db737733a7172643f53d69214253d46bcfa57429","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testIntBraceListOptiStore() {\n        final String script = \"int x = 1; def y = new ArrayList(); y.add(0); y[0] = x; return y[0];\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;II)\"));\n        assertEquals(1, exec(script));\n    }","id":31596,"modified_method":"public void testIntBraceListOptiStore() {\n        final String script = \"int x = 1; def y = new ArrayList(); y.add(0); y[0] = x; return y[0];\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;II)\");\n        assertEquals(1, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleFieldListOptiLoad() {\n        final String script = \"double x = 0; def y = new ArrayList(); y.add(5.0); x = y.0;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;)D\"));\n        assertEquals(5.0, exec(script));\n    }","id":31597,"modified_method":"public void testDoubleFieldListOptiLoad() {\n        final String script = \"double x = 0; def y = new ArrayList(); y.add(5.0); x = y.0;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;)D\");\n        assertEquals(5.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIllegalCast() {\n        final String script = \"int x;\\ndef y = new HashMap();\\ny['double'] = 1.0;\\nx = y.get('double');\\n\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)I\"));\n        final Exception exception = expectThrows(ClassCastException.class, () -> {\n            exec(script);\n        });\n\n        assertTrue(exception.getMessage().contains(\"Cannot cast java.lang.Double to java.lang.Integer\"));\n    }","id":31598,"modified_method":"public void testIllegalCast() {\n        final String script = \"int x;\\ndef y = new HashMap();\\ny['double'] = 1.0;\\nx = y.get('double');\\n\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)I\");\n\n        final Exception exception = expectThrows(ClassCastException.class, () -> {\n            exec(script);\n        });\n        assertTrue(exception.getMessage().contains(\"Cannot cast java.lang.Double to java.lang.Integer\"));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleBraceArrayOptiLoad() {\n        final String script = \"double x = 0; def y = new double[1]; y[0] = 5.0; x = y[0]; return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)D\"));\n        assertEquals(5.0, exec(script));\n    }","id":31599,"modified_method":"public void testDoubleBraceArrayOptiLoad() {\n        final String script = \"double x = 0; def y = new double[1]; y[0] = 5.0; x = y[0]; return x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)D\");\n        assertEquals(5.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleBraceMapOptiLoad() {\n        final String script = \"double x = 0.0; def y = new HashMap(); y.put(0, 5.0); x = y[0];\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)D\"));\n        assertEquals(5.0, exec(script));\n    }","id":31600,"modified_method":"public void testDoubleBraceMapOptiLoad() {\n        final String script = \"double x = 0.0; def y = new HashMap(); y.put(0, 5.0); x = y[0];\";\n\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)D\");\n        assertEquals(5.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntBraceListOptiLoad() {\n        final String script = \"int x = 0; def y = new ArrayList(); y.add(5); x = y[0]; return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)I\"));\n        assertEquals(5, exec(script));\n    }","id":31601,"modified_method":"public void testIntBraceListOptiLoad() {\n        final String script = \"int x = 0; def y = new ArrayList(); y.add(5); x = y[0]; return x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)I\");\n        assertEquals(5, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleBraceListOptiStore() {\n        final String script = \"double x = 1.0; def y = new ArrayList(); y.add(0.0); y[0] = x; return y[0];\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;ID)\"));\n        assertEquals(1.0, exec(script));\n    }","id":31602,"modified_method":"public void testDoubleBraceListOptiStore() {\n        final String script = \"double x = 1.0; def y = new ArrayList(); y.add(0.0); y[0] = x; return y[0];\";\n\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;ID)\");\n        assertEquals(1.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleFieldListOptiStore() {\n        final String script = \"double x = 1.0; def y = new ArrayList(); y.add(0); y.0 = x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;D)\"));\n        assertEquals(1.0, exec(script));\n    }","id":31603,"modified_method":"public void testDoubleFieldListOptiStore() {\n        final String script = \"double x = 1.0; def y = new ArrayList(); y.add(0); y.0 = x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;D)\");\n        assertEquals(1.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntBraceMapOptiStore() {\n        final String script = \"int x = 1; def y = new HashMap(); y.put(0, 1); y[0] = x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;II)\"));\n        assertEquals(1, exec(script));\n    }","id":31604,"modified_method":"public void testIntBraceMapOptiStore() {\n        final String script = \"int x = 1; def y = new HashMap(); y.put(0, 1); y[0] = x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;II)\");\n        assertEquals(1, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleCall0Opti() {\n        final String script = \"double x; def y = new HashMap(); y['double'] = 1.0; x = y.get('double'); return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)D\"));\n        assertEquals(1.0, exec(script));\n    }","id":31605,"modified_method":"public void testDoubleCall0Opti() {\n        final String script = \"double x; def y = new HashMap(); y['double'] = 1.0; x = y.get('double'); return x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)D\");\n        assertEquals(1.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntFieldListOptiStore() {\n        final String script = \"int x = 1; def y = new ArrayList(); y.add(0); y.0 = x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;I)\"));\n        assertEquals(1, exec(script));\n    }","id":31606,"modified_method":"public void testIntFieldListOptiStore() {\n        final String script = \"int x = 1; def y = new ArrayList(); y.add(0); y.0 = x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;I)\");\n        assertEquals(1, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleBraceMapOptiStore() {\n        final String script = \"double x = 1.0; def y = new HashMap(); y.put(0, 2.0); y[0] = x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;ID)\"));\n        assertEquals(1.0, exec(script));\n    }","id":31607,"modified_method":"public void testDoubleBraceMapOptiStore() {\n        final String script = \"double x = 1.0; def y = new HashMap(); y.put(0, 2.0); y[0] = x;\";\n\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;ID)\");\n        assertEquals(1.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntBraceArrayOptiStore() {\n        final String script = \"int x = 1; def y = new int[1]; y[0] = x; return y[0];\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;II)\"));\n        assertEquals(1, exec(script));\n    }","id":31608,"modified_method":"public void testIntBraceArrayOptiStore() {\n        final String script = \"int x = 1; def y = new int[1]; y[0] = x; return y[0];\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;II)\");\n        assertEquals(1, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntFieldListOptiLoad() {\n        final String script = \"int x = 0; def y = new ArrayList(); y.add(5); x = y.0;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;)I\"));\n        assertEquals(5, exec(script));\n    }","id":31609,"modified_method":"public void testIntFieldListOptiLoad() {\n        final String script = \"int x = 0; def y = new ArrayList(); y.add(5); x = y.0;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;)I\");\n        assertEquals(5, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleFieldMapOptiLoad() {\n        final String script = \"double x = 0; def y = new HashMap(); y.put('0', 5.0); x = y.0; return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;)D\"));\n        assertEquals(5.0, exec(script));\n    }","id":31610,"modified_method":"public void testDoubleFieldMapOptiLoad() {\n        final String script = \"double x = 0; def y = new HashMap(); y.put('0', 5.0); x = y.0; return x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;)D\");\n        assertEquals(5.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntBraceArrayOptiLoad() {\n        final String script = \"int x = 0; def y = new int[1]; y[0] = 5; x = y[0]; return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)I\"));\n        assertEquals(5, exec(script));\n    }","id":31611,"modified_method":"public void testIntBraceArrayOptiLoad() {\n        final String script = \"int x = 0; def y = new int[1]; y[0] = 5; x = y[0]; return x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)I\");\n        assertEquals(5, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntFieldMapOptiStore() {\n        final String script = \"int x = 1; def y = new HashMap(); y.put('0', 1); y.0 = x; return y.0;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;I)\"));\n        assertEquals(1, exec(script));\n    }","id":31612,"modified_method":"public void testIntFieldMapOptiStore() {\n        final String script = \"int x = 1; def y = new HashMap(); y.put('0', 1); y.0 = x; return y.0;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;I)\");\n        assertEquals(1, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleCall1Opti() {\n        final String script = \"double x; def y = new HashMap(); y['double'] = 1.0; x = y.get('double');\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)D\"));\n        assertEquals(1.0, exec(script));\n    }","id":31613,"modified_method":"public void testDoubleCall1Opti() {\n        final String script = \"double x; def y = new HashMap(); y['double'] = 1.0; x = y.get('double');\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)D\");\n        assertEquals(1.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntCall0Opti() {\n        final String script = \"int x; def y = new HashMap(); y['int'] = 1; x = y.get('int'); return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)I\"));\n        assertEquals(1, exec(script));\n    }","id":31614,"modified_method":"public void testIntCall0Opti() {\n        final String script = \"int x; def y = new HashMap(); y['int'] = 1; x = y.get('int'); return x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)I\");\n        assertEquals(1, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntCall1Opti() {\n        final String script = \"int x; def y = new HashMap(); y['int'] = 1; x = y.get('int');\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)I\"));\n        assertEquals(1, exec(script));\n    }","id":31615,"modified_method":"public void testIntCall1Opti() {\n        final String script = \"int x; def y = new HashMap(); y['int'] = 1; x = y.get('int');\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC get(Ljava/lang/Object;Ljava/lang/String;)I\");\n        assertEquals(1, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleBraceArrayOptiStore() {\n        final String script = \"double x = 1; def y = new double[1]; y[0] = x; return y[0];\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;ID)\"));\n        assertEquals(1.0, exec(script));\n    }","id":31616,"modified_method":"public void testDoubleBraceArrayOptiStore() {\n        final String script = \"double x = 1; def y = new double[1]; y[0] = x; return y[0];\";\n\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayStore(Ljava/lang/Object;ID)\");\n        assertEquals(1.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntFieldMapOptiLoad() {\n        final String script = \"int x = 0; def y = new HashMap(); y.put('0', 5); x = y.0; return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;)I\"));\n        assertEquals(5, exec(script));\n    }","id":31617,"modified_method":"public void testIntFieldMapOptiLoad() {\n        final String script = \"int x = 0; def y = new HashMap(); y.put('0', 5); x = y.0; return x;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;)I\");\n        assertEquals(5, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleBraceListOptiLoad() {\n        final String script = \"double x = 0.0; def y = new ArrayList(); y.add(5.0); x = y[0]; return x;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)D\"));\n        assertEquals(5.0, exec(script));\n    }","id":31618,"modified_method":"public void testDoubleBraceListOptiLoad() {\n        final String script = \"double x = 0.0; def y = new ArrayList(); y.add(5.0); x = y[0]; return x;\";\n\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)D\");\n        assertEquals(5.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDoubleFieldMapOptiStore() {\n        final String script = \"double x = 1.0; def y = new HashMap(); y.put('0', 1.0); y.0 = x; return y.0;\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC 0(Ljava/lang/Object;D)\"));\n        assertEquals(1.0, exec(script));\n    }","id":31619,"modified_method":"public void testDoubleFieldMapOptiStore() {\n        final String script = \"double x = 1.0; def y = new HashMap(); y.put('0', 1.0); y.0 = x; return y.0;\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC 0(Ljava/lang/Object;D)\");\n        assertEquals(1.0, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIntBraceMapOptiLoad() {\n        final String script = \"int x = 0; def y = new HashMap(); y.put(0, 5); x = y[0];\";\n        final String asm = Debugger.toString(script);\n\n        assertTrue(asm.contains(\"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)I\"));\n        assertEquals(5, exec(script));\n    }","id":31620,"modified_method":"public void testIntBraceMapOptiLoad() {\n        final String script = \"int x = 0; def y = new HashMap(); y.put(0, 5); x = y[0];\";\n        assertBytecodeExists(script, \"INVOKEDYNAMIC arrayLoad(Ljava/lang/Object;I)I\");\n        assertEquals(5, exec(script));\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void write(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        if (cat) {\n            WriterUtility.writeNewStrings(adapter);\n        }\n\n        final ALink last = links.get(links.size() - 1);\n\n        for (final ALink link : links) {\n            link.write(settings, definition, adapter);\n\n            if (link == last && link.store) {\n                if (cat) {\n                    WriterUtility.writeDup(adapter, link.size, 1);\n                    link.load(settings, definition, adapter);\n                    WriterUtility.writeAppendStrings(adapter, link.after.sort);\n\n                    expression.write(settings, definition, adapter);\n\n                    if (!(expression instanceof EBinary) ||\n                        ((EBinary)expression).operation != Operation.ADD || expression.actual.sort != Sort.STRING) {\n                        WriterUtility.writeAppendStrings(adapter, expression.actual.sort);\n                    }\n\n                    WriterUtility.writeToStrings(adapter);\n                    WriterUtility.writeCast(adapter, back);\n\n                    if (link.load) {\n                        WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                    }\n\n                    link.store(settings, definition, adapter);\n                } else if (operation != null) {\n                    WriterUtility.writeDup(adapter, link.size, 0);\n                    link.load(settings, definition, adapter);\n\n                    if (link.load && post) {\n                        WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                    }\n\n                    WriterUtility.writeCast(adapter, there);\n                    expression.write(settings, definition, adapter);\n                    WriterUtility.writeBinaryInstruction(settings, definition, adapter, location, promote, operation);\n\n                    if (!exact || !WriterUtility.writeExactInstruction(definition, adapter, promote.sort, link.after.sort)) {\n                        WriterUtility.writeCast(adapter, back);\n                    }\n\n                    if (link.load && !post) {\n                        WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                    }\n\n                    link.store(settings, definition, adapter);\n                } else {\n                    expression.write(settings, definition, adapter);\n\n                    if (link.load) {\n                        // storeValueType may be different from after, so use storeValueType if last is an ADefLink\n                        if (last instanceof ADefLink) {\n                            WriterUtility.writeDup(adapter, ((ADefLink)last).storeValueType.sort.size, link.size);\n                        } else {\n                            WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                        }\n                    }\n\n                    link.store(settings, definition, adapter);\n                }\n            } else {\n                link.load(settings, definition, adapter);\n            }\n        }\n\n        WriterUtility.writeBranch(adapter, tru, fals);\n    }","id":31621,"modified_method":"@Override\n    void write(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        if (cat) {\n            WriterUtility.writeNewStrings(adapter);\n        }\n\n        final ALink last = links.get(links.size() - 1);\n\n        for (final ALink link : links) {\n            link.write(settings, definition, adapter);\n\n            if (link == last && link.store) {\n                if (cat) {\n                    WriterUtility.writeDup(adapter, link.size, 1);\n                    link.load(settings, definition, adapter);\n                    WriterUtility.writeAppendStrings(adapter, link.after.sort);\n\n                    expression.write(settings, definition, adapter);\n\n                    if (!(expression instanceof EBinary) ||\n                        ((EBinary)expression).operation != Operation.ADD || expression.actual.sort != Sort.STRING) {\n                        WriterUtility.writeAppendStrings(adapter, expression.actual.sort);\n                    }\n\n                    WriterUtility.writeToStrings(adapter);\n                    WriterUtility.writeCast(adapter, back);\n\n                    if (link.load) {\n                        WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                    }\n\n                    link.store(settings, definition, adapter);\n                } else if (operation != null) {\n                    WriterUtility.writeDup(adapter, link.size, 0);\n                    link.load(settings, definition, adapter);\n\n                    if (link.load && post) {\n                        WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                    }\n\n                    WriterUtility.writeCast(adapter, there);\n                    expression.write(settings, definition, adapter);\n                    WriterUtility.writeBinaryInstruction(settings, definition, adapter, location, promote, operation);\n\n                    if (!exact || !WriterUtility.writeExactInstruction(definition, adapter, promote.sort, link.after.sort)) {\n                        WriterUtility.writeCast(adapter, back);\n                    }\n\n                    if (link.load && !post) {\n                        WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                    }\n\n                    link.store(settings, definition, adapter);\n                } else {\n                    expression.write(settings, definition, adapter);\n\n                    if (link.load) {\n                        WriterUtility.writeDup(adapter, link.after.sort.size, link.size);\n                    }\n\n                    link.store(settings, definition, adapter);\n                }\n            } else {\n                link.load(settings, definition, adapter);\n            }\n        }\n\n        WriterUtility.writeBranch(adapter, tru, fals);\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void analyzeWrite(final CompilerSettings settings, final Definition definition, final Variables variables) {\n        final ALink last = links.get(links.size() - 1);\n\n        // If the store node is a DEF node, we remove the cast to DEF from the expression\n        // and promote the real type to it:\n        if (last instanceof ADefLink) {\n            final ADefLink lastDef = (ADefLink) last;\n            expression.analyze(settings, definition, variables);\n            // TODO: does it make more sense to just re-use last.after instead of using storeValueType?\n            lastDef.storeValueType = expression.expected = expression.actual;\n            this.actual = read ? lastDef.storeValueType : definition.voidType;\n        } else {\n            // otherwise we adapt the type of the expression to the store type\n            expression.expected = last.after;\n            expression.analyze(settings, definition, variables);\n            this.actual = read ? last.after : definition.voidType;\n        }\n\n        expression = expression.cast(settings, definition, variables);\n        this.statement = true;\n    }","id":31622,"modified_method":"private void analyzeWrite(final CompilerSettings settings, final Definition definition, final Variables variables) {\n        final ALink last = links.get(links.size() - 1);\n\n        // If the store node is a DEF node, we remove the cast to DEF from the expression\n        // and promote the real type to it:\n        if (last instanceof IDefLink) {\n            expression.analyze(settings, definition, variables);\n            last.after = expression.expected = expression.actual;\n        } else {\n            // otherwise we adapt the type of the expression to the store type\n            expression.expected = last.after;\n            expression.analyze(settings, definition, variables);\n        }\n\n        expression = expression.cast(settings, definition, variables);\n\n        this.statement = true;\n        this.actual = read ? last.after : definition.voidType;\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void analyzeCompound(final CompilerSettings settings, final Definition definition, final Variables variables) {\n        final ALink last = links.get(links.size() - 1);\n\n        expression.analyze(settings, definition, variables);\n\n        if (operation == Operation.MUL) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.DIV) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.REM) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.ADD) {\n            promote = AnalyzerCaster.promoteAdd(definition, last.after, expression.actual);\n        } else if (operation == Operation.SUB) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.LSH) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false, true);\n        } else if (operation == Operation.RSH) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false, true);\n        } else if (operation == Operation.USH) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false, true);\n        } else if (operation == Operation.BWAND) {\n            promote = AnalyzerCaster.promoteXor(definition, last.after, expression.actual);\n        } else if (operation == Operation.XOR) {\n            promote = AnalyzerCaster.promoteXor(definition, last.after, expression.actual);\n        } else if (operation == Operation.BWOR) {\n            promote = AnalyzerCaster.promoteXor(definition, last.after, expression.actual);\n        } else {\n            throw new IllegalStateException(error(\"Illegal tree structure.\"));\n        }\n\n        if (promote == null) {\n            throw new ClassCastException(\"Cannot apply compound assignment \" +\n                \"[\" + operation.symbol + \"=] to types [\" + last.after + \"] and [\" + expression.actual + \"].\");\n        }\n\n        cat = operation == Operation.ADD && promote.sort == Sort.STRING;\n\n        if (cat) {\n            if (expression instanceof EBinary && ((EBinary)expression).operation == Operation.ADD &&\n                expression.actual.sort == Sort.STRING) {\n                ((EBinary)expression).cat = true;\n            }\n\n            expression.expected = expression.actual;\n        } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n            expression.expected = definition.intType;\n            expression.explicit = true;\n        } else {\n            expression.expected = promote;\n        }\n\n        expression = expression.cast(settings, definition, variables);\n\n        exact = !settings.getNumericOverflow() &&\n            (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM ||\n                operation == Operation.ADD || operation == Operation.SUB);\n        there = AnalyzerCaster.getLegalCast(definition, location, last.after, promote, false);\n        back = AnalyzerCaster.getLegalCast(definition, location, promote, last.after, true);\n\n        if (last instanceof ADefLink) {\n            final ADefLink lastDef = (ADefLink) last;\n            // Unfortunately, we don't know the real type because we load from DEF and store to DEF!\n            lastDef.storeValueType = last.after;\n        }\n\n        this.statement = true;\n        this.actual = read ? last.after : definition.voidType;\n    }","id":31623,"modified_method":"private void analyzeCompound(final CompilerSettings settings, final Definition definition, final Variables variables) {\n        final ALink last = links.get(links.size() - 1);\n\n        expression.analyze(settings, definition, variables);\n\n        if (operation == Operation.MUL) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.DIV) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.REM) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.ADD) {\n            promote = AnalyzerCaster.promoteAdd(definition, last.after, expression.actual);\n        } else if (operation == Operation.SUB) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true, true);\n        } else if (operation == Operation.LSH) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false, true);\n        } else if (operation == Operation.RSH) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false, true);\n        } else if (operation == Operation.USH) {\n            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false, true);\n        } else if (operation == Operation.BWAND) {\n            promote = AnalyzerCaster.promoteXor(definition, last.after, expression.actual);\n        } else if (operation == Operation.XOR) {\n            promote = AnalyzerCaster.promoteXor(definition, last.after, expression.actual);\n        } else if (operation == Operation.BWOR) {\n            promote = AnalyzerCaster.promoteXor(definition, last.after, expression.actual);\n        } else {\n            throw new IllegalStateException(error(\"Illegal tree structure.\"));\n        }\n\n        if (promote == null) {\n            throw new ClassCastException(\"Cannot apply compound assignment \" +\n                \"[\" + operation.symbol + \"=] to types [\" + last.after + \"] and [\" + expression.actual + \"].\");\n        }\n\n        cat = operation == Operation.ADD && promote.sort == Sort.STRING;\n\n        if (cat) {\n            if (expression instanceof EBinary && ((EBinary)expression).operation == Operation.ADD &&\n                expression.actual.sort == Sort.STRING) {\n                ((EBinary)expression).cat = true;\n            }\n\n            expression.expected = expression.actual;\n        } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n            expression.expected = definition.intType;\n            expression.explicit = true;\n        } else {\n            expression.expected = promote;\n        }\n\n        expression = expression.cast(settings, definition, variables);\n\n        exact = !settings.getNumericOverflow() &&\n            (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM ||\n                operation == Operation.ADD || operation == Operation.SUB);\n        there = AnalyzerCaster.getLegalCast(definition, location, last.after, promote, false);\n        back = AnalyzerCaster.getLegalCast(definition, location, promote, last.after, true);\n\n        this.statement = true;\n        this.actual = read ? last.after : definition.voidType;\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void analyzeRead() {\n        final ALink last = links.get(links.size() - 1);\n\n        // If the load node is a DEF node, we adapt its after type to use _this_ expected output type:\n        if (last instanceof ADefLink && this.expected != null) {\n            last.after = this.expected;\n        }\n\n        constant = last.string;\n        statement = last.statement;\n        actual = last.after;\n    }","id":31624,"modified_method":"private void analyzeRead() {\n        final ALink last = links.get(links.size() - 1);\n\n        // If the load node is a DEF node, we adapt its after type to use _this_ expected output type:\n        if (last instanceof IDefLink && this.expected != null) {\n            last.after = this.expected;\n        }\n\n        constant = last.string;\n        statement = last.statement;\n        actual = last.after;\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        if (storeValueType == null) {\n            throw new IllegalStateException(error(\"Illegal tree structure.\"));\n        }\n\n        final String desc = Type.getMethodDescriptor(definition.voidType.type, definition.defType.type,\n            index.actual.type, storeValueType.type);\n        adapter.invokeDynamic(\"arrayStore\", desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.ARRAY_STORE);\n    }","id":31625,"modified_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        final String desc = Type.getMethodDescriptor(definition.voidType.type, definition.defType.type,\n            index.actual.type, after.type);\n        adapter.invokeDynamic(\"arrayStore\", desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.ARRAY_STORE);\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        if (storeValueType == null) {\n            throw new IllegalStateException(error(\"Illegal tree structure.\"));\n        }\n        final String desc = Type.getMethodDescriptor(definition.voidType.type, definition.defType.type, storeValueType.type);\n        adapter.invokeDynamic(value, desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.STORE);\n    }","id":31626,"modified_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        final String desc = Type.getMethodDescriptor(definition.voidType.type, definition.defType.type, after.type);\n        adapter.invokeDynamic(value, desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.STORE);\n    }","commit_id":"3fd3d367ef836f8b24f52539d4938e5060b9d691","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public IParamsValue naryOperation(AbstractInsnNode insn, List<? extends IParamsValue> values) {\n    int size;\n    int opcode = insn.getOpcode();\n    if (opcode == MULTIANEWARRAY) {\n      size = 1;\n    } else {\n      String desc = (opcode == INVOKEDYNAMIC) ? ((InvokeDynamicInsnNode) insn).desc : ((MethodInsnNode) insn).desc;\n      size = Type.getReturnType(desc).getSize();\n    }\n    return size == 1 ? val1 : val2;\n  }","id":31627,"modified_method":"@Override\n  public IParamsValue naryOperation(AbstractInsnNode insn, List<? extends IParamsValue> values) {\n    int opcode = insn.getOpcode();\n    switch (opcode) {\n      case INVOKESTATIC:\n      case INVOKESPECIAL:\n      case INVOKEVIRTUAL:\n      case INVOKEINTERFACE:\n        for (IParamsValue value : values) {\n          leaking |= value.params;\n        }\n        break;\n      default:\n    }\n    int size;\n    if (opcode == MULTIANEWARRAY) {\n      size = 1;\n    } else {\n      String desc = (opcode == INVOKEDYNAMIC) ? ((InvokeDynamicInsnNode) insn).desc : ((MethodInsnNode) insn).desc;\n      size = Type.getReturnType(desc).getSize();\n    }\n    return size == 1 ? val1 : val2;\n  }","commit_id":"ad83b82d90cb80072f4a7472e8ed9e32a7806c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean[] fastLeakingParameters(String className, MethodNode methodNode) throws AnalyzerException {\n    Frame<IParamsValue>[] frames = new Analyzer<IParamsValue>(new IParametersUsage(methodNode)).analyze(className, methodNode);\n    InsnList insns = methodNode.instructions;\n    ILeakingParametersCollector collector = new ILeakingParametersCollector(methodNode);\n    for (int i = 0; i < frames.length; i++) {\n      AbstractInsnNode insnNode = insns.get(i);\n      Frame<IParamsValue> frame = frames[i];\n      if (frame != null) {\n        switch (insnNode.getType()) {\n          case AbstractInsnNode.LABEL:\n          case AbstractInsnNode.LINE:\n          case AbstractInsnNode.FRAME:\n            break;\n          default:\n            frame.execute(insnNode, collector);\n        }\n      }\n    }\n    int leakingMask = collector.leaking;\n    boolean[] result = new boolean[collector.arity];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = (leakingMask & (1 << i)) != 0;\n    }\n    return result;\n  }","id":31628,"modified_method":"static boolean[] fastLeakingParameters(String className, MethodNode methodNode) throws AnalyzerException {\n    IParametersUsage parametersUsage = new IParametersUsage(methodNode);\n    new Analyzer<IParamsValue>(parametersUsage).analyze(className, methodNode);\n    int leakingMask = parametersUsage.leaking;\n    boolean[] result = new boolean[parametersUsage.arity];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = (leakingMask & (1 << i)) != 0;\n    }\n    return result;\n  }","commit_id":"ad83b82d90cb80072f4a7472e8ed9e32a7806c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public IParamsValue binaryOperation(AbstractInsnNode insn, IParamsValue value1, IParamsValue value2) {\n    int size;\n    switch (insn.getOpcode()) {\n      case LALOAD:\n      case DALOAD:\n      case LADD:\n      case DADD:\n      case LSUB:\n      case DSUB:\n      case LMUL:\n      case DMUL:\n      case LDIV:\n      case DDIV:\n      case LREM:\n      case DREM:\n      case LSHL:\n      case LSHR:\n      case LUSHR:\n      case LAND:\n      case LOR:\n      case LXOR:\n        size = 2;\n        break;\n      default:\n        size = 1;\n    }\n    return size == 1 ? val1 : val2;\n  }","id":31629,"modified_method":"@Override\n  public IParamsValue binaryOperation(AbstractInsnNode insn, IParamsValue value1, IParamsValue value2) {\n    int size;\n    switch (insn.getOpcode()) {\n      case LALOAD:\n      case DALOAD:\n        size = 2;\n        leaking |= value1.params;\n        break;\n      case LADD:\n      case DADD:\n      case LSUB:\n      case DSUB:\n      case LMUL:\n      case DMUL:\n      case LDIV:\n      case DDIV:\n      case LREM:\n      case DREM:\n      case LSHL:\n      case LSHR:\n      case LUSHR:\n      case LAND:\n      case LOR:\n      case LXOR:\n        size = 2;\n        break;\n      case IALOAD:\n      case FALOAD:\n      case AALOAD:\n      case BALOAD:\n      case CALOAD:\n      case SALOAD:\n      case PUTFIELD:\n        leaking |= value1.params;\n        size = 1;\n        break;\n      default:\n        size = 1;\n    }\n    return size == 1 ? val1 : val2;\n  }","commit_id":"ad83b82d90cb80072f4a7472e8ed9e32a7806c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public IParamsValue ternaryOperation(AbstractInsnNode insn, IParamsValue value1, IParamsValue value2, IParamsValue value3) {\n    return val1;\n  }","id":31630,"modified_method":"@Override\n  public IParamsValue ternaryOperation(AbstractInsnNode insn, IParamsValue value1, IParamsValue value2, IParamsValue value3) {\n    switch (insn.getOpcode()) {\n      case IASTORE:\n      case LASTORE:\n      case FASTORE:\n      case DASTORE:\n      case AASTORE:\n      case BASTORE:\n      case CASTORE:\n      case SASTORE:\n        leaking |= value1.params;\n        break;\n      default:\n    }\n    return val1;\n  }","commit_id":"ad83b82d90cb80072f4a7472e8ed9e32a7806c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public ParamsValue unaryOperation(AbstractInsnNode insn, ParamsValue value) {\n    int size;\n    switch (insn.getOpcode()) {\n      case CHECKCAST:\n        return new ParamsValue(value.params, Type.getObjectType(((TypeInsnNode)insn).desc).getSize());\n      case LNEG:\n      case DNEG:\n      case I2L:\n      case I2D:\n      case L2D:\n      case F2L:\n      case F2D:\n      case D2L:\n        size = 2;\n        break;\n      case GETFIELD:\n        size = Type.getType(((FieldInsnNode) insn).desc).getSize();\n        break;\n      default:\n        size = 1;\n    }\n    return size == 1 ? val1 : val2;\n  }","id":31631,"modified_method":"@Override\n  public ParamsValue unaryOperation(AbstractInsnNode insn, ParamsValue value) {\n    int size;\n    switch (insn.getOpcode()) {\n      case CHECKCAST:\n        return value;\n      case LNEG:\n      case DNEG:\n      case I2L:\n      case I2D:\n      case L2D:\n      case F2L:\n      case F2D:\n      case D2L:\n        size = 2;\n        break;\n      case GETFIELD:\n        size = Type.getType(((FieldInsnNode) insn).desc).getSize();\n        break;\n      default:\n        size = 1;\n    }\n    return size == 1 ? val1 : val2;\n  }","commit_id":"ad83b82d90cb80072f4a7472e8ed9e32a7806c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public IParamsValue unaryOperation(AbstractInsnNode insn, IParamsValue value) {\n    int size;\n    switch (insn.getOpcode()) {\n      case CHECKCAST:\n        return value;\n      case LNEG:\n      case DNEG:\n      case I2L:\n      case I2D:\n      case L2D:\n      case F2L:\n      case F2D:\n      case D2L:\n        size = 2;\n        break;\n      case GETFIELD:\n        size = Type.getType(((FieldInsnNode) insn).desc).getSize();\n        break;\n      default:\n        size = 1;\n    }\n    return size == 1 ? val1 : val2;\n  }","id":31632,"modified_method":"@Override\n  public IParamsValue unaryOperation(AbstractInsnNode insn, IParamsValue value) {\n    int size;\n    switch (insn.getOpcode()) {\n      case CHECKCAST:\n        return value;\n      case LNEG:\n      case DNEG:\n      case I2L:\n      case I2D:\n      case L2D:\n      case F2L:\n      case F2D:\n      case D2L:\n        size = 2;\n        break;\n      case GETFIELD:\n        size = Type.getType(((FieldInsnNode) insn).desc).getSize();\n        leaking |= value.params;\n        break;\n      case ARRAYLENGTH:\n      case MONITORENTER:\n      case INSTANCEOF:\n      case IRETURN:\n      case ARETURN:\n      case IFNONNULL:\n      case IFNULL:\n      case IFEQ:\n      case IFNE:\n        size = 1;\n        leaking |= value.params;\n        break;\n      default:\n        size = 1;\n    }\n    return size == 1 ? val1 : val2;\n  }","commit_id":"ad83b82d90cb80072f4a7472e8ed9e32a7806c93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ControlFlowBuilder(String className, MethodNode methodNode) {\n    super(INTERPRETER);\n    this.className = className;\n    this.methodNode = methodNode;\n    transitions = new TIntArrayList[methodNode.instructions.size()];\n    for (int i = 0; i < transitions.length; i++) {\n      transitions[i] = new TIntArrayList();\n    }\n    errorTransitions = new HashSet<Edge>();\n  }","id":31633,"modified_method":"ControlFlowBuilder(String className, MethodNode methodNode) {\n    this.className = className;\n    this.methodNode = methodNode;\n    transitions = new TIntArrayList[methodNode.instructions.size()];\n    for (int i = 0; i < transitions.length; i++) {\n      transitions[i] = new TIntArrayList();\n    }\n    errorTransitions = new HashSet<Edge>();\n  }","commit_id":"a7c1c1ab4501519cc4a07777879f1c0cafb4d98f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"final ControlFlowGraph buildCFG() throws AnalyzerException {\n    analyze(className, methodNode);\n    int[][] resultTransitions = new int[transitions.length][];\n    for (int i = 0; i < resultTransitions.length; i++) {\n      resultTransitions[i] = transitions[i].toNativeArray();\n    }\n    return new ControlFlowGraph(className, methodNode, resultTransitions, errorTransitions);\n  }","id":31634,"modified_method":"final ControlFlowGraph buildCFG() throws AnalyzerException {\n    if ((methodNode.access & (ACC_ABSTRACT | ACC_NATIVE)) == 0) {\n      analyze(methodNode);\n    }\n    int[][] resultTransitions = new int[transitions.length][];\n    for (int i = 0; i < resultTransitions.length; i++) {\n      resultTransitions[i] = transitions[i].toNativeArray();\n    }\n    return new ControlFlowGraph(className, methodNode, resultTransitions, errorTransitions);\n  }","commit_id":"a7c1c1ab4501519cc4a07777879f1c0cafb4d98f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void analyze(AnalyzeContextInfo contextInfo, OrderSpec orderBy[]) throws XPathException {\n        // Save the local variable stack\n\t\tLocalVariable mark = context.markLocalVariables(false);\n\t\t\n\t\tcontextInfo.setParent(this);\n\t\tinputSequence.analyze(contextInfo);\n\t\t\n\t\t// Declare the iteration variable\n        LocalVariable inVar = new LocalVariable(QName.parse(context, varName, null));\n        inVar.setSequenceType(sequenceType);\n\t\tcontext.declareVariableBinding(inVar);\n\t\t\n\t\t// Declare positional variable\n\t\tif(positionalVariable != null) {\n\t\t\tLocalVariable posVar = new LocalVariable(QName.parse(context, positionalVariable, null));\n            posVar.setSequenceType(POSITIONAL_VAR_TYPE);\n            context.declareVariableBinding(posVar);\n        }\n        \n\t\tif(whereExpr != null) {\n\t\t\tAnalyzeContextInfo newContextInfo = new AnalyzeContextInfo(contextInfo);\n\t\t\tnewContextInfo.setFlags(contextInfo.getFlags() | IN_PREDICATE | IN_WHERE_CLAUSE);\n\t\t\tnewContextInfo.setContextId(getExpressionId());\n\t\t    whereExpr.analyze(newContextInfo);\n\t\t}\n\t\t// the order by specs should be analyzed by the last binding expression\n\t\t// in the chain to have access to all variables. So if the return expression\n\t\t// is another binding expression, we just forward the order specs.\n\t\tif(returnExpr instanceof BindingExpression) {\n\t\t\tAnalyzeContextInfo newContextInfo = new AnalyzeContextInfo(contextInfo);\n\t\t\tnewContextInfo.addFlag(SINGLE_STEP_EXECUTION);\n\t\t    ((BindingExpression)returnExpr).analyze(newContextInfo, orderBy);\n\t\t} else {\n\t\t    // analyze the order specs\n\t\t\tif(orderBy != null) {\n\t\t\t\tAnalyzeContextInfo newContextInfo = new AnalyzeContextInfo(contextInfo);\n\t\t\t\tnewContextInfo.addFlag(SINGLE_STEP_EXECUTION);\n\t\t\t    for(int i = 0; i < orderBy.length; i++)\n\t\t\t        orderBy[i].analyze(newContextInfo);\n\t\t\t}\n\t\t\treturnExpr.analyze(contextInfo);\n\t\t}\n\t\t\n\t\t// restore the local variable stack\n\t\tcontext.popLocalVariables(mark);\n    }","id":31635,"modified_method":"public void analyze(AnalyzeContextInfo contextInfo, OrderSpec orderBy[]) throws XPathException {\n        // Save the local variable stack\n\t\tLocalVariable mark = context.markLocalVariables(false);\n\t\t\n\t\tcontextInfo.setParent(this);\n\t\tinputSequence.analyze(contextInfo);\n\t\t\n\t\t// Declare the iteration variable\n        LocalVariable inVar = new LocalVariable(QName.parse(context, varName, null));\n        inVar.setSequenceType(sequenceType);\n\t\tcontext.declareVariableBinding(inVar);\n\t\t\n\t\t// Declare positional variable\n\t\tif(positionalVariable != null) {\n\t\t\tLocalVariable posVar = new LocalVariable(QName.parse(context, positionalVariable, null));\n            posVar.setSequenceType(POSITIONAL_VAR_TYPE);\n            context.declareVariableBinding(posVar);\n        }\n        \n\t\tif(whereExpr != null) {\n\t\t\tAnalyzeContextInfo newContextInfo = new AnalyzeContextInfo(contextInfo);\n\t\t\tnewContextInfo.setFlags(contextInfo.getFlags() | IN_PREDICATE | IN_WHERE_CLAUSE);\n\t\t\tnewContextInfo.setContextId(getExpressionId());\n\t\t    whereExpr.analyze(newContextInfo);\n\t\t}\n\t\t// the order by specs should be analyzed by the last binding expression\n\t\t// in the chain to have access to all variables. So if the return expression\n\t\t// is another binding expression, we just forward the order specs.\n\t\tif(returnExpr instanceof BindingExpression) {\n\t\t\tAnalyzeContextInfo newContextInfo = new AnalyzeContextInfo(contextInfo);\n\t\t\tnewContextInfo.addFlag(SINGLE_STEP_EXECUTION);\n\t\t    ((BindingExpression)returnExpr).analyze(newContextInfo, orderBy);\n\t\t} else {\n\t\t\tAnalyzeContextInfo newContextInfo = new AnalyzeContextInfo(contextInfo);\n\t\t\tnewContextInfo.addFlag(SINGLE_STEP_EXECUTION);\n\t\t    // analyze the order specs\n\t\t\tif(orderBy != null) {\n\t\t\t    for(int i = 0; i < orderBy.length; i++)\n\t\t\t        orderBy[i].analyze(newContextInfo);\n\t\t\t}\n\t\t\treturnExpr.analyze(newContextInfo);\n\t\t}\n\t\t\n\t\t// restore the local variable stack\n\t\tcontext.popLocalVariables(mark);\n    }","commit_id":"af362601df4f2adf2e3ee250c2b13887f6d97fb4","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    void load(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        adapter.visitInvokeDynamicInsn(\n            \"arrayLoad\", DEF_DYNAMIC_ARRAY_LOAD_DESC, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.ARRAY_LOAD });\n\n    }","id":31636,"modified_method":"@Override\n    void load(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        final String desc = Type.getMethodDescriptor(definition.defType.type, definition.defType.type, index.actual.type);\n        adapter.visitInvokeDynamicInsn(\n            \"arrayLoad\", desc, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.ARRAY_LOAD });\n    }","commit_id":"1b10a14e8d26dcc197a359cb142a1e4eee8df87c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    ALink analyze(final CompilerSettings settings, final Definition definition, final Variables variables) {\n        index.expected = definition.objectType;\n        index.analyze(settings, definition, variables);\n        index = index.cast(settings, definition, variables);\n\n        after = definition.defType;\n\n        return this;\n    }","id":31637,"modified_method":"@Override\n    ALink analyze(final CompilerSettings settings, final Definition definition, final Variables variables) {\n        index.analyze(settings, definition, variables);\n        index.expected = index.actual;\n        index = index.cast(settings, definition, variables);\n\n        after = definition.defType;\n\n        return this;\n    }","commit_id":"1b10a14e8d26dcc197a359cb142a1e4eee8df87c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        adapter.visitInvokeDynamicInsn(\n            \"arrayStore\", DEF_DYNAMIC_ARRAY_STORE_DESC, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.ARRAY_STORE });\n    }","id":31638,"modified_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        final String desc = Type.getMethodDescriptor(definition.voidType.type, definition.defType.type,\n            index.actual.type, definition.defType.type);\n        adapter.visitInvokeDynamicInsn(\n            \"arrayStore\", desc, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.ARRAY_STORE });\n    }","commit_id":"1b10a14e8d26dcc197a359cb142a1e4eee8df87c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void load(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        adapter.visitInvokeDynamicInsn(value, DEF_DYNAMIC_LOAD_FIELD_DESC, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.LOAD });\n    }","id":31639,"modified_method":"@Override\n    void load(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        final String desc = Type.getMethodDescriptor(definition.defType.type, definition.defType.type);\n        adapter.visitInvokeDynamicInsn(value, desc, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.LOAD });\n    }","commit_id":"1b10a14e8d26dcc197a359cb142a1e4eee8df87c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        adapter.visitInvokeDynamicInsn(value, DEF_DYNAMIC_STORE_FIELD_DESC, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.STORE });\n    }","id":31640,"modified_method":"@Override\n    void store(final CompilerSettings settings, final Definition definition, final GeneratorAdapter adapter) {\n        final String desc = Type.getMethodDescriptor(definition.voidType.type, definition.defType.type, definition.defType.type);\n        adapter.visitInvokeDynamicInsn(value, desc, DEF_BOOTSTRAP_HANDLE, new Object[] { DefBootstrap.STORE });\n    }","commit_id":"1b10a14e8d26dcc197a359cb142a1e4eee8df87c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args)\n    {\n        String laf = null;\n        //laf = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n        //laf = javax.swing.UIManager.getCrossPlatformLookAndFeelClassName();\n        try {\n            if (laf != null)\n                javax.swing.UIManager.setLookAndFeel(laf);\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n        \n        // loading preferences\n        prefs = java.util.prefs.Preferences.userRoot().node(\"/\");\n        try {\n            FileInputStream fis = new FileInputStream(VUE_CONF);\n            prefs.importPreferences(fis);\n        } catch (Exception e) { System.out.println(e);}\n\n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        tabbedPane = new JTabbedPane();\n        tabbedPane.setTabPlacement(SwingConstants.BOTTOM);\n        tabbedPane.setPreferredSize(new Dimension(300,400));\n        \n        tabbedPane2 = new JTabbedPane();\n        tabbedPane2.setTabPlacement(SwingConstants.BOTTOM);\n        tabbedPane2.setPreferredSize(new Dimension(300,400));\n\n        if (true||args.length < 1) { // pathway code currently blowing us out unless we have these maps loaded\n            //-------------------------------------------------------\n            // Temporary: create example map(s)\n            //-------------------------------------------------------\n            //LWMap map1 = new LWMap(\"Test Nodes\");\n            //LWMap map2 = new LWMap(\"Example Map\");\n            LWMap map1 = new LWMap(\"Map 1\");\n            LWMap map2 = new LWMap(\"Map 2\");\n\n            installExampleNodes(map1);\n            installExampleMap(map2);\n\n            //map1.setFillColor(new Color(255, 255, 192));\n            \n            displayMap(map1);\n            displayMap(map2);\n            \n        }\n        \n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        toolPanel = new JPanel();\n        //JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        DRBrowser drBrowser = new DRBrowser();\n        if (args.length < 1 || !args[0].equals(\"-nodr\"))\n            toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n        toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(false);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n\n        viewerSplit = new JSplitPane();\n        viewerSplit.setOneTouchExpandable(true);\n        viewerSplit.setLeftComponent(tabbedPane);\n        viewerSplit.setRightComponent(tabbedPane2);\n        viewerSplit.setResizeWeight(0.5);\n        viewerSplit.setDividerLocation(9999);\n\n        //splitPane.setRightComponent(tabbedPane);\n        splitPane.setRightComponent(viewerSplit);\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        \n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        \n        ToolWindow drBrowserTool  = new ToolWindow(\"DR Browser\", frame);\n        drBrowserTool.addTool(drBrowser);\n        \n        // The real tool palette window withtools and contextual tools\n        ToolWindow toolbarWindow = new ToolWindow( VueResources.getString(\"tbWindowName\"), frame);\n        VueToolbarController tbc = VueToolbarController.getController();\n        tbc.setToolWindow( toolbarWindow);\n        toolbarWindow.getContentPane().add( tbc.getToolbar() );\n        toolbarWindow.pack();\n        ModelSelection.addListener(tbc);\n        frame.getContentPane().add( tbc.getToolbar(), BorderLayout.NORTH);\n\t\t\n\t\t// Map Inspector\n\t\t\n\t\t// get the proper scree/main frame size\n\t\tToolWindow mapInspector = new ToolWindow(  VueResources.getString(\"mapInspectorTitle\"), frame);\n\t\tMapInspectorPanel mip = new MapInspectorPanel();\n\t\tModelSelection.addListener( mip);\n\t\tmapInspector.addTool( mip );\n\t\t\n\t\t\n\t\t\t\n\t\tToolWindow objectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tObjectInspectorPanel oip = new ObjectInspectorPanel();\n\t\tModelSelection.addListener( oip);\n\t\tobjectInspector.addTool( oip);\n\t\t\n\t\t\n\t\tif( false) {\n\t\t\tJFrame testFrame = new JFrame(\"Debug\");\n\t\t\ttestFrame.setSize( 300,300);\n\t\t\t//testFrame.getContentPane().add( new NodeInspectorPanel() );\n\t\t\ttestFrame.getContentPane().add( oip);\n\t\t\ttestFrame.show();\n\t\t}\n\t\t\n\t\t\n        //addtion by the power team\n        pathwayInspector = new LWPathwayInspector(frame);\n        control = new PathwayControl(frame);\n        \n        hierarchyTree = new LWHierarchyTree(frame);\n        outlineViewTree = new LWOutlineViewTree(frame);\n        //end of addition\n       \n        Action[] windowActions = { toolbarWindow.getDisplayAction(),\n        \t\t\t\t\t\t\tpannerTool.getDisplayAction(),\n                                   inspectorTool.getDisplayAction(),\n                                   drBrowserTool.getDisplayAction(),\n                                   pathwayInspector.getDisplayAction(),\n                                   control.getDisplayAction(), \n                                   hierarchyTree.getDisplayAction(),\n                                   mapInspector.getDisplayAction(),\n                                   objectInspector.getDisplayAction(),\n                                   outlineViewTree.getDisplayAction()\n                                 };\n        \n        // adding the menus and toolbars\n        setMenuToolbars(frame, windowActions);\n        System.out.println(\"after setting menu toolbars...\");\n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        Dimension d = frame.getToolkit().getScreenSize();\n        int x = d.width/2 - frame.getWidth()/2;\n        int y = d.height/2 - frame.getHeight()/2;\n        frame.setLocation(x, y);\n        \n        // position inspectors pased on frame location\n        int inspectorx = x + frame.getWidth() - mapInspector.getWidth();\n        mapInspector.setLocation( inspectorx, y);\n        objectInspector.setLocation( inspectorx, y + mapInspector.getHeight() );\n        \n        \n        \n        frame.show();\n        System.out.println(\"after showing frame...\");\n        if (args.length > 0) {\n            try {\n                OpenAction oa = null;\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i].charAt(0) == '-')\n                        continue;\n                    if (oa == null)\n                        oa = new OpenAction();\n                    VUE.activateWaitCursor();\n                    LWMap map = oa.loadMap(args[i]);\n                    if (map != null)\n                        displayMap(map);\n                }\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n        //setViewerScrollbarsDisplayed(true);\n        System.out.println(\"VUE.main completed.\");\n    }","id":31641,"modified_method":"public static void main(String[] args)\n    {\n        String laf = null;\n        //laf = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n        //laf = javax.swing.UIManager.getCrossPlatformLookAndFeelClassName();\n        try {\n            if (laf != null)\n                javax.swing.UIManager.setLookAndFeel(laf);\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n        \n        // loading preferences\n        prefs = java.util.prefs.Preferences.userRoot().node(\"/\");\n        try {\n            FileInputStream fis = new FileInputStream(VUE_CONF);\n            prefs.importPreferences(fis);\n        } catch (Exception e) { System.out.println(e);}\n\n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        tabbedPane = new JTabbedPane();\n        tabbedPane.setTabPlacement(SwingConstants.BOTTOM);\n        tabbedPane.setPreferredSize(new Dimension(300,400));\n        \n        tabbedPane2 = new JTabbedPane();\n        tabbedPane2.setTabPlacement(SwingConstants.BOTTOM);\n        tabbedPane2.setPreferredSize(new Dimension(300,400));\n\n        if (true||args.length < 1) { // pathway code currently blowing us out unless we have these maps loaded\n            //-------------------------------------------------------\n            // Temporary: create example map(s)\n            //-------------------------------------------------------\n            //LWMap map1 = new LWMap(\"Test Nodes\");\n            //LWMap map2 = new LWMap(\"Example Map\");\n            LWMap map1 = new LWMap(\"Map 1\");\n            LWMap map2 = new LWMap(\"Map 2\");\n\n            installExampleNodes(map1);\n            installExampleMap(map2);\n\n            //map1.setFillColor(new Color(255, 255, 192));\n            \n            displayMap(map1);\n            displayMap(map2);\n            \n        }\n        \n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        toolPanel = new JPanel();\n        //JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        //DRBrowser drBrowser = new DRBrowser();\n        DRBrowser drBrowser = null;\n        if (args.length < 1 || !args[0].equals(\"-nodr\"))\n            toolPanel.add(drBrowser = new DRBrowser(), BorderLayout.CENTER);\n        toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(false);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n\n        viewerSplit = new JSplitPane();\n        viewerSplit.setOneTouchExpandable(true);\n        viewerSplit.setLeftComponent(tabbedPane);\n        viewerSplit.setRightComponent(tabbedPane2);\n        viewerSplit.setResizeWeight(0.5);\n        viewerSplit.setDividerLocation(9999);\n\n        //splitPane.setRightComponent(tabbedPane);\n        splitPane.setRightComponent(viewerSplit);\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        \n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        \n        ToolWindow drBrowserTool  = new ToolWindow(\"DR Browser\", frame);\n        if (drBrowser != null)\n            drBrowserTool.addTool(drBrowser);\n        \n        // The real tool palette window withtools and contextual tools\n        ToolWindow toolbarWindow = new ToolWindow( VueResources.getString(\"tbWindowName\"), frame);\n        VueToolbarController tbc = VueToolbarController.getController();\n        tbc.setToolWindow( toolbarWindow);\n        toolbarWindow.getContentPane().add( tbc.getToolbar() );\n        toolbarWindow.pack();\n        ModelSelection.addListener(tbc);\n        frame.getContentPane().add( tbc.getToolbar(), BorderLayout.NORTH);\n\t\t\n\t\t// Map Inspector\n\t\t\n\t\t// get the proper scree/main frame size\n\t\tToolWindow mapInspector = new ToolWindow(  VueResources.getString(\"mapInspectorTitle\"), frame);\n\t\tMapInspectorPanel mip = new MapInspectorPanel();\n\t\tModelSelection.addListener( mip);\n\t\tmapInspector.addTool( mip );\n\t\t\n\t\t\n\t\t\t\n\t\tToolWindow objectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tObjectInspectorPanel oip = new ObjectInspectorPanel();\n\t\tModelSelection.addListener( oip);\n\t\tobjectInspector.addTool( oip);\n\t\t\n\t\t\n\t\tif( false) {\n\t\t\tJFrame testFrame = new JFrame(\"Debug\");\n\t\t\ttestFrame.setSize( 300,300);\n\t\t\t//testFrame.getContentPane().add( new NodeInspectorPanel() );\n\t\t\ttestFrame.getContentPane().add( oip);\n\t\t\ttestFrame.show();\n\t\t}\n\t\t\n\t\t\n        //addtion by the power team\n        pathwayInspector = new LWPathwayInspector(frame);\n        control = new PathwayControl(frame);\n        \n        hierarchyTree = new LWHierarchyTree(frame);\n        outlineViewTree = new LWOutlineViewTree(frame);\n        //end of addition\n       \n        Action[] windowActions = { toolbarWindow.getDisplayAction(),\n        \t\t\t\t\t\t\tpannerTool.getDisplayAction(),\n                                   inspectorTool.getDisplayAction(),\n                                   drBrowserTool.getDisplayAction(),\n                                   pathwayInspector.getDisplayAction(),\n                                   control.getDisplayAction(), \n                                   hierarchyTree.getDisplayAction(),\n                                   mapInspector.getDisplayAction(),\n                                   objectInspector.getDisplayAction(),\n                                   outlineViewTree.getDisplayAction()\n                                 };\n        \n        // adding the menus and toolbars\n        setMenuToolbars(frame, windowActions);\n        System.out.println(\"after setting menu toolbars...\");\n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        Dimension d = frame.getToolkit().getScreenSize();\n        int x = d.width/2 - frame.getWidth()/2;\n        int y = d.height/2 - frame.getHeight()/2;\n        frame.setLocation(x, y);\n        \n        // position inspectors pased on frame location\n        int inspectorx = x + frame.getWidth() - mapInspector.getWidth();\n        mapInspector.setLocation( inspectorx, y);\n        objectInspector.setLocation( inspectorx, y + mapInspector.getHeight() );\n        \n        \n        \n        frame.show();\n        System.out.println(\"after showing frame...\");\n        if (args.length > 0) {\n            try {\n                OpenAction oa = null;\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i].charAt(0) == '-')\n                        continue;\n                    if (oa == null)\n                        oa = new OpenAction();\n                    VUE.activateWaitCursor();\n                    LWMap map = oa.loadMap(args[i]);\n                    if (map != null)\n                        displayMap(map);\n                }\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n        //setViewerScrollbarsDisplayed(true);\n        System.out.println(\"VUE.main completed.\");\n    }","commit_id":"696bd64ed569f0034d88f2cde8a025f541790083","url":"https://github.com/VUE/VUE"},{"original_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n        PageEditViewParameters params = null;\n\n        String pageId = null;\n        \n        UIBranchContainer mode = null;\n        \n        try {\n            params = (PageEditViewParameters) arg1;\n            pageId = params.pageId;\n            \n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n            UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n            return;\n        }    \n        \n        if (\"nil\".equals(pageId)) {\n            mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n            UIOutput.make(mode, \"message\", messageLocator\n                    .getMessage(\"error_pageid\"));\n        }\n        else {\n            try {\n                Site site = handler.site;\n                SitePage page = site.getPage(pageId);\n                String title = page.getTitle();\n                site.removePage(page);\n                handler.saveSite(site);\n                mode = UIBranchContainer.make(arg0, \"mode-pass:\");\n                UIOutput.make(mode, \"pageId\", pageId);\n                UIOutput.make(mode, \"message\", title + \" \" + messageLocator\n                        .getMessage(\"success_removed\"));\n\n            } catch (IdUnusedException e) {\n                mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                e.printStackTrace();\n            } catch (PermissionException e) {\n                mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                e.printStackTrace();\n            }\n        }\n    }","id":31642,"modified_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n        PageEditViewParameters params = null;\n\n        String pageId = null;\n        \n        UIBranchContainer mode = null;\n        \n        try {\n            params = (PageEditViewParameters) arg1;\n            pageId = params.pageId;\n            \n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n            UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n            return;\n        }    \n        \n        if (\"nil\".equals(pageId)) {\n            mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n            UIOutput.make(mode, \"message\", messageLocator\n                    .getMessage(\"error_pageid\"));\n        }\n        else {\n            try {\n                String title = handler.removePage( pageId );\n\n                mode = UIBranchContainer.make(arg0, \"mode-pass:\");\n                UIOutput.make(mode, \"pageId\", pageId);\n                UIOutput.make(mode, \"message\", title + \" \" + messageLocator\n                        .getMessage(\"success_removed\"));\n\n            } catch (IdUnusedException e) {\n                mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                e.printStackTrace();\n            } catch (PermissionException e) {\n                mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n        PageEditViewParameters params = null;\n\n        String pageId = null;\n        String newTitle = null;\n        String visible = null;\n        String newConfig = null;\n \n        UIBranchContainer mode = null;\n \n        try {\n            params = (PageEditViewParameters) arg1;\n            pageId = params.pageId;\n            newTitle = params.newTitle;\n            visible = params.visible;\n            newConfig = params.newConfig;\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n            UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n            return;\n        }    \n\n        if (!\"nil\".equals(pageId)) {\n            if (!\"nil\".equals(newTitle)) {\n                if (newTitle != null && !\"\".equals(newTitle)) {\n                    try {\n                        Site site = handler.site;\n                        SitePage page = site.getPage(pageId);\n                        String oldTitle = page.getTitle();\n                        page.setTitle(newTitle);\n\n                        // TODO: Find a way to call each tool to ask what fields they need configured\n                        // and what methods to use to validate the input..\n                        if (page.getTools().size() == 1 && !\"nil\".equals(newConfig)) {\n                            ToolConfiguration tool = (ToolConfiguration) page.getTools().get(0);\n                            tool.setTitle(newTitle);\n                            if (\"sakai.iframe\".equals(tool.getToolId())) {\n                                tool.getPlacementConfig().setProperty(\"source\", newConfig);\n\n                            }\n                        }\n\n                        handler.saveSite(site);\n                        mode = UIBranchContainer.make(arg0, \"mode-pass:\");\n                        UIOutput.make(mode, \"page-title\", newTitle);\n                        UIOutput.make(mode, \"message\", oldTitle + \" \" + messageLocator\n                                .getMessage(\"success_changed\") + \" \" + newTitle);\n\n                    }\n                    catch (IdUnusedException e) {\n                        mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                        UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                        e.printStackTrace();\n                    } \n                    catch (PermissionException e) {\n                        mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                        UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                        e.printStackTrace();\n                    }\n                }\n                else {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", messageLocator\n                        .getMessage(\"error_title_null\"));\n                }\n            }\n\n            if (\"true\".equals(visible) || \"false\".equals(visible)) {\n                try {            \n                    if (\"true\".equals(visible)) {\n                        handler.showPage(pageId);\n                    }\n                    else {\n                        handler.hidePage(pageId);\n                    }\n                    Site site = handler.site;\n                    SitePage page = site.getPage(pageId);\n                    String oldTitle = page.getTitle();\n                    \n                    mode = UIBranchContainer.make(arg0, \"mode-pass:\");\n                    UIOutput.make(mode, \"page-title\", oldTitle);\n                    if (\"true\".equals(visible)) {\n                        UIOutput.make(mode, \"message\", oldTitle + \" \" + messageLocator\n                                .getMessage(\"success_visible\")); \n                    }\n                    else {\n                        UIOutput.make(mode, \"message\", oldTitle + \" \" + messageLocator\n                                .getMessage(\"success_hidden\")); \n                    }\n                } \n                catch (IdUnusedException e) {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                    e.printStackTrace();\n                }\n                catch (PermissionException e) {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                    e.printStackTrace();\n                }\n            }\n        }\n        else {\n            UIOutput.make(mode, \"message\", messageLocator\n                    .getMessage(\"error_pageid\"));\n        }\n    }","id":31643,"modified_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n        PageEditViewParameters params = null;\n\n        String pageId = null;\n        String newTitle = null;\n        String visible = null;\n        String newConfig = null;\n \n        UIBranchContainer mode = null;\n \n        try {\n            params = (PageEditViewParameters) arg1;\n            pageId = params.pageId;\n            newTitle = params.newTitle;\n            visible = params.visible;\n            newConfig = params.newConfig;\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n            UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n            return;\n        }    \n\n        if (!\"nil\".equals(pageId)) {\n            if (!\"nil\".equals(newTitle)) {\n                if (newTitle != null && !\"\".equals(newTitle)) {\n                    try {\n                        String oldTitle = handler.setTitle(pageId, newTitle);\n                      \n                        mode = UIBranchContainer.make(arg0, \"mode-pass:\");\n                        UIOutput.make(mode, \"page-title\", newTitle);\n                        UIOutput.make(mode, \"message\", oldTitle + \" \" + messageLocator\n                                .getMessage(\"success_changed\") + \" \" + newTitle);\n\n                    }\n                    catch (IdUnusedException e) {\n                        mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                        UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                        e.printStackTrace();\n                    } \n                    catch (PermissionException e) {\n                        mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                        UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                        e.printStackTrace();\n                    }\n                }\n                else {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", messageLocator\n                        .getMessage(\"error_title_null\"));\n                }\n            }\n            \n            if (newConfig != null && !\"nil\".equals(newConfig)) {\n                try {\n                    // TODO: Add ability to configure any arbitrary setting\n                    handler.setConfig(pageId, \"source\", newConfig);\n                }\n                catch (IdUnusedException e) {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                    e.printStackTrace();\n                } \n                catch (PermissionException e) {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                    e.printStackTrace();\n                }\n            }\n\n            if (\"true\".equals(visible) || \"false\".equals(visible)) {\n                try {            \n                    if (\"true\".equals(visible)) {\n                        handler.showPage(pageId);\n                    }\n                    else {\n                        handler.hidePage(pageId);\n                    }\n                    Site site = handler.site;\n                    SitePage page = site.getPage(pageId);\n                    String oldTitle = page.getTitle();\n                    \n                    mode = UIBranchContainer.make(arg0, \"mode-pass:\");\n                    UIOutput.make(mode, \"page-title\", oldTitle);\n                    if (\"true\".equals(visible)) {\n                        UIOutput.make(mode, \"message\", oldTitle + \" \" + messageLocator\n                                .getMessage(\"success_visible\")); \n                    }\n                    else {\n                        UIOutput.make(mode, \"message\", oldTitle + \" \" + messageLocator\n                                .getMessage(\"success_hidden\")); \n                    }\n                } \n                catch (IdUnusedException e) {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                    e.printStackTrace();\n                }\n                catch (PermissionException e) {\n                    mode = UIBranchContainer.make(arg0, \"mode-failed:\");\n                    UIOutput.make(mode, \"message\", e.getLocalizedMessage());\n                    e.printStackTrace();\n                }\n            }\n        }\n        else {\n            UIOutput.make(mode, \"message\", messageLocator\n                    .getMessage(\"error_pageid\"));\n        }\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Hides a page from any user who doesn't have site.upd\n     * Or atleast removes it from the portal navigation list\n     * \n     * @param pageId The Id of the Page\n     * @return true for sucess, false for failuer\n     * @throws IdUnusedException, PermissionException\n     */\n    public boolean hidePage(String pageId) throws IdUnusedException, PermissionException {\n        return  pageVisibilityHelper(pageId, false);\n    }","id":31644,"modified_method":"/**\n     * Hides a page from any user who doesn't have site.upd\n     * Or atleast removes it from the portal navigation list\n     * \n     * @param pageId The Id of the Page\n     * @return true for sucess, false for failuer\n     * @throws IdUnusedException, PermissionException\n     */\n    public boolean hidePage(String pageId) throws IdUnusedException, PermissionException {\n        EventTrackingService.post(\n            EventTrackingService.newEvent(PAGE_HIDE, \"/site/\" + site.getId() +\n                                         \"/page/\" + pageId, false));\n        return  pageVisibilityHelper(pageId, false);\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Unhides a page from any user who doesn't have site.upd\n     * Or atleast removes it from the portal navigation list\n     * \n     * @param pageId The Id of the Page\n     * @return true for sucess, false for failuer\n     * @throws IdUnusedException, PermissionException\n     */\n    public boolean showPage(String pageId) throws IdUnusedException, PermissionException {        \n        return pageVisibilityHelper(pageId, true);\n    }","id":31645,"modified_method":"/**\n     * Unhides a page from any user who doesn't have site.upd\n     * Or atleast removes it from the portal navigation list\n     * \n     * @param pageId The Id of the Page\n     * @return true for sucess, false for failuer\n     * @throws IdUnusedException, PermissionException\n     */\n    public boolean showPage(String pageId) throws IdUnusedException, PermissionException {\n        EventTrackingService.post(\n            EventTrackingService.newEvent(PAGE_SHOW, \"/site/\" + site.getId() +\n                                         \"/page/\" + pageId, false));\n      \n        return pageVisibilityHelper(pageId, true);\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Process the 'Save' post on page ordering.\n     *\n     */\n    public String savePages () {\n        if (state != null) {\n            String[] pages = state.split(\" \");\n            for (int i = 0; i < pages.length; i++) {\n                if (pages[i] != null) {\n                    SitePage realPage = site.getPage(pages[i]);\n                    realPage.setPosition(i);\n                }\n            }\n            site.setCustomPageOrdered(true);\n            try {\n                siteService.save(site);\n            } \n            catch (IdUnusedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } \n            catch (PermissionException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        ToolSession session = sessionManager.getCurrentToolSession();\n        session.setAttribute(ATTR_TOP_REFRESH, Boolean.TRUE);\n\n        return \"done\";\n    }","id":31646,"modified_method":"/**\n     * Process the 'Save' post on page ordering.\n     *\n     */\n    public String savePages () {\n        if (state != null) {\n            String[] pages = state.split(\" \");\n            for (int i = 0; i < pages.length; i++) {\n                if (pages[i] != null) {\n                    SitePage realPage = site.getPage(pages[i]);\n                    realPage.setPosition(i);\n                }\n            }\n            site.setCustomPageOrdered(true);\n            try {\n                siteService.save(site);\n                EventTrackingService.post(\n                    EventTrackingService.newEvent(SITE_REORDER, \"/site/\" + site.getId(), false));\n\n            } \n            catch (IdUnusedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } \n            catch (PermissionException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        ToolSession session = sessionManager.getCurrentToolSession();\n        session.setAttribute(ATTR_TOP_REFRESH, Boolean.TRUE);\n\n        return \"done\";\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Adds a new single tool page to the current site\n     * @param toolId\n     * @param title\n     * @return the newly added SitePage\n     */\n    public SitePage addPage (String toolId, String title) {\n        SitePage page = null;\n        try {\n            page = site.addPage();\n            page.setTitle(title);\n            page.addTool(toolId);        \n            siteService.save(site);\n        } \n        catch (IdUnusedException e) {\n            e.printStackTrace();\n            return null;\n        } \n        catch (PermissionException e) {\n            e.printStackTrace();\n            return null;\n        }\n        init();\n        \n        return page;\n    }","id":31647,"modified_method":"/**\n     * Adds a new single tool page to the current site\n     * @param toolId\n     * @param title\n     * @return the newly added SitePage\n     */\n    public SitePage addPage (String toolId, String title) {\n        SitePage page = null;\n        try {\n            page = site.addPage();\n            page.setTitle(title);\n            ToolConfiguration placement = page.addTool(toolId);        \n            siteService.save(site);\n            EventTrackingService.post(\n                EventTrackingService.newEvent(PAGE_ADD, \"/site/\" + site.getId() +\n                    \"/page/\" + page.getId() +\n                    \"/tool/\" + toolId +\n                    \"/placement/\" + placement.getId(), false));\n        } \n        catch (IdUnusedException e) {\n            e.printStackTrace();\n            return null;\n        } \n        catch (PermissionException e) {\n            e.printStackTrace();\n            return null;\n        }\n        init();\n        \n        return page;\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Process tool adds\n     * @return\n     */\n    public String addTools () {    \n        for (int i = 0; i < selectedTools.length; i++) {\n            SitePage page = null;\n            try {\n                page = site.addPage();\n                Tool tool = toolManager.getTool(selectedTools[i]);\n                page.setTitle(tool.getTitle());\n                page.addTool(tool.getId());\n                siteService.save(site);\n            } \n            catch (IdUnusedException e) {\n                e.printStackTrace();\n                return null;\n            } \n            catch (PermissionException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n      \n        return \"success\";\n    }","id":31648,"modified_method":"/**\n     * Process tool adds\n     * @return\n     */\n    public String addTools () {    \n        for (int i = 0; i < selectedTools.length; i++) {\n            SitePage page = null;\n            try {\n                page = site.addPage();\n                Tool tool = toolManager.getTool(selectedTools[i]);\n                page.setTitle(tool.getTitle());\n                ToolConfiguration placement = page.addTool(tool.getId());\n                siteService.save(site);\n                EventTrackingService.post(\n                    EventTrackingService.newEvent(PAGE_ADD, \"/site/\" + site.getId() +\n                        \"/page/\" + page.getId() +\n                        \"/tool/\" + selectedTools[i] +\n                        \"/placement/\" + placement.getId(), false));\n            } \n            catch (IdUnusedException e) {\n                e.printStackTrace();\n                return null;\n            } \n            catch (PermissionException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n      \n        return \"success\";\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String reset() {\n        site.setCustomPageOrdered(false);\n        try {\n            siteService.save(site);\n        } \n        catch (IdUnusedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } \n        catch (PermissionException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return \"\";\n    }","id":31649,"modified_method":"public String reset() {\n        site.setCustomPageOrdered(false);\n        try {\n            siteService.save(site);\n            EventTrackingService.post(\n                EventTrackingService.newEvent(SITE_RESET, \"/site/\" + site.getId(), false));\n\n        } \n        catch (IdUnusedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } \n        catch (PermissionException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return \"\";\n    }","commit_id":"5f35cd95e369d3e546fbf123bf6e544311be093f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final InspectionConfigTreeNode[] nodes = myTree.getSelectedNodes(InspectionConfigTreeNode.class, null);\n    final InspectionConfigTreeNode node = nodes[0];\n    final Descriptor descriptor = node.getDesriptor();\n    LOG.assertTrue(descriptor != null);\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    final InspectionProfileEntry tool = descriptor.getTool(); //copy\n    final List<String> availableScopes = getAvailableScopes(descriptor, project);\n\n    final int idx = Messages.showChooseDialog(myTree, \"Scope:\", \"Choose Scope\",\n                                              availableScopes.toArray(new String[availableScopes.size()]), availableScopes.get(0), Messages.getQuestionIcon());\n    if (idx == -1) return;\n    final ScopeToolState scopeToolState = getSelectedProfile().addScope(tool, NamedScopesHolder.getScope(project, availableScopes.get(idx)),\n                                                                     descriptor.getLevel(), tool.isEnabledByDefault());\n    final Descriptor addedDescriptor = new Descriptor(scopeToolState, getSelectedProfile());\n    if (node.getChildCount() == 0) {\n      node.add(new InspectionConfigTreeNode(descriptor, DefaultScopesProvider.getAllScope(), true, descriptor.isEnabled(), true, false));\n    }\n    node.insert(new InspectionConfigTreeNode(addedDescriptor, scopeToolState.getScope(), tool.isEnabledByDefault(), true, false), 0);\n    node.setInspectionNode(false);\n    node.isProperSetting = getSelectedProfile().isProperSetting(HighlightDisplayKey.find(tool.getShortName()));\n    ((DefaultTreeModel)myTree.getModel()).reload(node);\n    myTree.expandPath(new TreePath(node.getPath()));\n    myTree.revalidate();\n  }","id":31650,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final InspectionConfigTreeNode[] nodes = myTree.getSelectedNodes(InspectionConfigTreeNode.class, null);\n    final InspectionConfigTreeNode node = nodes[0];\n    final Descriptor descriptor = node.getDesriptor();\n    LOG.assertTrue(descriptor != null);\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    final InspectionProfileEntry tool = descriptor.getTool(); //copy\n    final List<String> availableScopes = getAvailableScopes(descriptor, project);\n\n    final int idx = Messages.showChooseDialog(myTree, \"Scope:\", \"Choose Scope\",\n                                              availableScopes.toArray(new String[availableScopes.size()]), availableScopes.get(0), Messages.getQuestionIcon());\n    if (idx == -1) return;\n    final ScopeToolState scopeToolState = getSelectedProfile().addScope(tool, NamedScopesHolder.getScope(project, availableScopes.get(idx)),\n                                                                     descriptor.getLevel(), tool.isEnabledByDefault());\n    final Descriptor addedDescriptor = new Descriptor(scopeToolState, getSelectedProfile());\n    if (node.getChildCount() == 0) {\n      node.add(new InspectionConfigTreeNode(descriptor, scopeToolState, true, true, false));\n    }\n    node.insert(new InspectionConfigTreeNode(addedDescriptor, scopeToolState, false, true, false), 0);\n    node.setInspectionNode(false);\n    node.isProperSetting = getSelectedProfile().isProperSetting(HighlightDisplayKey.find(tool.getShortName()));\n    ((DefaultTreeModel)myTree.getModel()).reload(node);\n    myTree.expandPath(new TreePath(node.getPath()));\n    myTree.revalidate();\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NamedScope getScope() {\n    return myScope;\n  }","id":31651,"modified_method":"@Nullable\n  public NamedScope getScope() {\n    return myState != null ? myState.getScope() : null;\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionConfigTreeNode(Object userObject, NamedScope scope, boolean enabled, boolean properSetting, boolean inspectionNode) {\n    this(userObject, scope, false, enabled, properSetting, inspectionNode);\n  }","id":31652,"modified_method":"public InspectionConfigTreeNode(Object userObject, ScopeToolState state, boolean byDefault, boolean properSetting, boolean inspectionNode) {\n    super(userObject);\n    myState = state;\n    myByDefault = byDefault;\n    isProperSetting = properSetting;\n    myInspectionNode = inspectionNode;\n    if (state != null) {\n      setChecked(state.isEnabled());\n    }\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionConfigTreeNode(Object userObject, NamedScope scope, boolean byDefault, boolean enabled, boolean properSetting, boolean inspectionNode) {\n    super(userObject);\n    myScope = scope;\n    myByDefault = byDefault;\n    isProperSetting = properSetting;\n    myInspectionNode = inspectionNode;\n    setChecked(enabled);\n  }","id":31653,"modified_method":"public InspectionConfigTreeNode(Descriptor descriptor, ScopeToolState state, boolean byDefault, boolean isEnabled, boolean properSetting,\n                                  boolean inspectionNode) {\n    this(descriptor, state, byDefault, properSetting, inspectionNode);\n    setChecked(isEnabled);\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setScope(NamedScope scope) {\n    myScope = scope;\n  }","id":31654,"modified_method":"@Nullable\n  public String getScopeName() {\n    return myState != null ? myState.getScopeName() : null;\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void customizeCellRenderer(final JTree tree,\n                                    final Object value,\n                                    final boolean selected,\n                                    final boolean expanded,\n                                    final boolean leaf,\n                                    final int row,\n                                    final boolean hasFocus) {\n\n    InspectionConfigTreeNode node = (InspectionConfigTreeNode)value;\n\n    Object object = node.getUserObject();\n\n    final Color background = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();\n    setBackground(background);\n\n    @NonNls String text = null;\n    int style = Font.PLAIN;\n    String hint = null;\n    if (object instanceof String) {\n      text = (String)object;\n      style = Font.BOLD;\n    }\n    else {\n      final Descriptor descriptor = node.getDesriptor();\n      final NamedScope namedScope = node.getScope();\n      if (namedScope != null) {\n        if (node.isByDefault()) {\n          text = \"Everywhere except\";\n        }\n        else {\n          text = \"In scope \\'\" + namedScope.getName() + \"\\'\";\n        }\n      } else {\n        text = descriptor.getText();\n      }\n      hint = getHint(descriptor);\n    }\n    Color foreground =\n      selected ? UIUtil.getTreeSelectionForeground() : node.isProperSetting ? Color.BLUE : UIUtil.getTreeTextForeground();\n    if (text != null) {\n      SearchUtil.appendFragments(getFilter(), text, style, foreground, background,\n                                 getTextRenderer());\n    }\n    if (hint != null) {\n      getTextRenderer()\n        .append(\" \" + hint, selected ? new SimpleTextAttributes(Font.PLAIN, foreground) : SimpleTextAttributes.GRAYED_ATTRIBUTES);\n    }\n    setForeground(foreground);\n  }","id":31655,"modified_method":"public void customizeCellRenderer(final JTree tree,\n                                    final Object value,\n                                    final boolean selected,\n                                    final boolean expanded,\n                                    final boolean leaf,\n                                    final int row,\n                                    final boolean hasFocus) {\n\n    InspectionConfigTreeNode node = (InspectionConfigTreeNode)value;\n\n    Object object = node.getUserObject();\n\n    final Color background = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();\n    setBackground(background);\n    Color foreground =\n      selected ? UIUtil.getTreeSelectionForeground() : node.isProperSetting ? Color.BLUE : UIUtil.getTreeTextForeground();\n\n    @NonNls String text = null;\n    int style = Font.PLAIN;\n    String hint = null;\n    if (object instanceof String) {\n      text = (String)object;\n      style = Font.BOLD;\n    }\n    else {\n      final Descriptor descriptor = node.getDesriptor();\n      final String scopeName = node.getScopeName();\n      if (scopeName != null) {\n        if (node.isByDefault()) {\n          text = \"Everywhere except\";\n        }\n        else {\n          text = \"In scope \\'\" + scopeName + \"\\'\";\n          if (node.getScope() == null) {\n            foreground = Color.RED;\n          }\n        }\n      } else {\n        text = descriptor.getText();\n      }\n      hint = getHint(descriptor);\n    }\n\n    if (text != null) {\n      SearchUtil.appendFragments(getFilter(), text, style, foreground, background,\n                                 getTextRenderer());\n    }\n    if (hint != null) {\n      getTextRenderer()\n        .append(\" \" + hint, selected ? new SimpleTextAttributes(Font.PLAIN, foreground) : SimpleTextAttributes.GRAYED_ATTRIBUTES);\n    }\n    setForeground(foreground);\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ScopeToolState(NamedScope scope, @NotNull InspectionProfileEntry tool, boolean enabled, HighlightDisplayLevel level) {\n    myScope = scope;\n    myTool = tool;\n    myEnabled = enabled;\n    myLevel = level;\n  }","id":31656,"modified_method":"public ScopeToolState(NamedScope scope, @NotNull InspectionProfileEntry tool, boolean enabled, HighlightDisplayLevel level) {\n    myScope = scope;\n    myScopeName = myScope.getName();\n    myTool = tool;\n    myEnabled = enabled;\n    myLevel = level;\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fillTreeData(String filter, boolean forceInclude) {\n    if (mySelectedProfile == null) return;\n    myRoot.removeAllChildren();\n    myRoot.setChecked(false);\n    myRoot.isProperSetting = false;\n    List<Set<String>> keySetList = new ArrayList<Set<String>>();\n    final Set<String> quated = new HashSet<String>();\n    if (filter != null && filter.length() > 0) {\n      keySetList.addAll(SearchUtil.findKeys(filter, quated));\n    }\n    for (Descriptor descriptor : myDescriptors.keySet()) {\n      final List<Descriptor> descriptors = myDescriptors.get(descriptor);\n      if (descriptor.getTool() != null && !(descriptor.getTool()instanceof LocalInspectionToolWrapper)) continue;\n      if (filter != null && filter.length() > 0 && !isDescriptorAccepted(descriptor, filter, forceInclude, keySetList, quated)) {\n        continue;\n      }\n      final HighlightDisplayKey key = descriptor.getKey();\n      final boolean enabled = mySelectedProfile.isToolEnabled(key);\n      final boolean properSetting = mySelectedProfile.isProperSetting(key);\n      final InspectionConfigTreeNode node = new InspectionConfigTreeNode(descriptor, null, descriptors.isEmpty(), enabled, properSetting, descriptors.isEmpty());\n      getGroupNode(myRoot, descriptor.getGroup(), properSetting).add(node);\n      if (!descriptors.isEmpty()) {\n        for (Descriptor des : descriptors) {\n          node.add(new InspectionConfigTreeNode(des, des.getScope(), des.getState().isEnabled(), properSetting, false));\n        }\n        node.add(new InspectionConfigTreeNode(descriptor, descriptor.getScope(), true, descriptor.getState().isEnabled(), properSetting, false));\n      }\n      myRoot.setEnabled(myRoot.isEnabled() || enabled);\n      myRoot.isProperSetting |= properSetting;\n    }\n    if (filter != null && forceInclude && myRoot.getChildCount() == 0) {\n      final Set<String> filters = SearchableOptionsRegistrar.getInstance().getProcessedWords(filter);\n      if (filters.size() > 1) {\n        fillTreeData(filter, false);\n      }\n    }\n    TreeUtil.sort(myRoot, new InspectionsConfigTreeComparator());\n  }","id":31657,"modified_method":"private void fillTreeData(String filter, boolean forceInclude) {\n    if (mySelectedProfile == null) return;\n    myRoot.removeAllChildren();\n    myRoot.setChecked(false);\n    myRoot.isProperSetting = false;\n    List<Set<String>> keySetList = new ArrayList<Set<String>>();\n    final Set<String> quated = new HashSet<String>();\n    if (filter != null && filter.length() > 0) {\n      keySetList.addAll(SearchUtil.findKeys(filter, quated));\n    }\n    for (Descriptor descriptor : myDescriptors.keySet()) {\n      final List<Descriptor> descriptors = myDescriptors.get(descriptor);\n      if (descriptor.getTool() != null && !(descriptor.getTool()instanceof LocalInspectionToolWrapper)) continue;\n      if (filter != null && filter.length() > 0 && !isDescriptorAccepted(descriptor, filter, forceInclude, keySetList, quated)) {\n        continue;\n      }\n      final HighlightDisplayKey key = descriptor.getKey();\n      final boolean enabled = mySelectedProfile.isToolEnabled(key);\n      final boolean properSetting = mySelectedProfile.isProperSetting(key);\n      final InspectionConfigTreeNode node = new InspectionConfigTreeNode(descriptor, null, descriptors.isEmpty(), enabled, properSetting, descriptors.isEmpty());\n      getGroupNode(myRoot, descriptor.getGroup(), properSetting).add(node);\n      if (!descriptors.isEmpty()) {\n        for (Descriptor des : descriptors) {\n          node.add(new InspectionConfigTreeNode(des, des.getState(), false, properSetting, false));\n        }\n        node.add(new InspectionConfigTreeNode(descriptor, descriptor.getState(), true, properSetting, false));\n      }\n      myRoot.setEnabled(myRoot.isEnabled() || enabled);\n      myRoot.isProperSetting |= properSetting;\n    }\n    if (filter != null && forceInclude && myRoot.getChildCount() == 0) {\n      final Set<String> filters = SearchableOptionsRegistrar.getInstance().getProcessedWords(filter);\n      if (filters.size() > 1) {\n        fillTreeData(filter, false);\n      }\n    }\n    TreeUtil.sort(myRoot, new InspectionsConfigTreeComparator());\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element toolElement, InspectionProfile profile) throws InvalidDataException {\n    final String levelName = toolElement.getAttributeValue(InspectionProfileImpl.LEVEL_TAG);\n    final ProfileManager profileManager = profile.getProfileManager();\n    HighlightDisplayLevel level =\n      HighlightDisplayLevel.find(((SeverityProvider)profileManager).getOwnSeverityRegistrar().getSeverity(levelName));\n    if (level == null || level == HighlightDisplayLevel.DO_NOT_SHOW) {//from old profiles\n      level = HighlightDisplayLevel.WARNING;\n    }\n    myDefaultState.setLevel(level);\n    final String enabled = toolElement.getAttributeValue(InspectionProfileImpl.ENABLED_TAG);\n    final boolean isEnabled = enabled != null && Boolean.parseBoolean(enabled);\n    myEnabled = isEnabled;\n\n    final String enabledTool = toolElement.getAttributeValue(ENABLED_TAG);\n    myDefaultState.setEnabled(enabledTool != null ? Boolean.parseBoolean(enabledTool) : isEnabled);\n    final InspectionProfileEntry tool = myDefaultState.getTool();\n    tool.readSettings(toolElement);\n    final List children = toolElement.getChildren(InspectionProfileImpl.SCOPE);\n    if (!children.isEmpty()) {\n      for (Object sO : children) {\n        final Element scopeElement = (Element)sO;\n        final String scopeName = scopeElement.getAttributeValue(InspectionProfileImpl.NAME);\n        if (scopeName != null) {\n          final NamedScopesHolder scopesHolder = profileManager.getScopesManager();\n          final NamedScope namedScope;\n          if (scopesHolder != null) {\n            namedScope = scopesHolder.getScope(scopeName);\n          } else {\n            final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n            if (projects.length > 0) {\n              namedScope = NamedScopesHolder.getScope(projects[0], scopeName);\n            } else {\n              namedScope = NamedScopesHolder.getScope(ProjectManager.getInstance().getDefaultProject(), scopeName);\n            }\n          }\n          if (namedScope != null) {\n            final String errorLevel = scopeElement.getAttributeValue(InspectionProfileImpl.LEVEL_TAG);\n            final String enabledInScope = scopeElement.getAttributeValue(InspectionProfileImpl.ENABLED_TAG);\n            final InspectionProfileEntry InspectionProfileEntry =\n              ((InspectionProfileImpl)profile).myRegistrar.createInspectionTool(myShortName, tool);\n            InspectionProfileEntry.readSettings(scopeElement);\n            addTool(namedScope, InspectionProfileEntry, enabledInScope != null && Boolean.parseBoolean(enabledInScope),\n                    errorLevel != null ? HighlightDisplayLevel\n                      .find(((SeverityProvider)profileManager).getOwnSeverityRegistrar().getSeverity(errorLevel)) : level);\n          }\n        }\n      }\n    }\n  }","id":31658,"modified_method":"public void readExternal(Element toolElement, InspectionProfile profile) throws InvalidDataException {\n    final String levelName = toolElement.getAttributeValue(InspectionProfileImpl.LEVEL_TAG);\n    final ProfileManager profileManager = profile.getProfileManager();\n    HighlightDisplayLevel level =\n      HighlightDisplayLevel.find(((SeverityProvider)profileManager).getOwnSeverityRegistrar().getSeverity(levelName));\n    if (level == null || level == HighlightDisplayLevel.DO_NOT_SHOW) {//from old profiles\n      level = HighlightDisplayLevel.WARNING;\n    }\n    myDefaultState.setLevel(level);\n    final String enabled = toolElement.getAttributeValue(InspectionProfileImpl.ENABLED_TAG);\n    final boolean isEnabled = enabled != null && Boolean.parseBoolean(enabled);\n    myEnabled = isEnabled;\n\n    final String enabledTool = toolElement.getAttributeValue(ENABLED_TAG);\n    myDefaultState.setEnabled(enabledTool != null ? Boolean.parseBoolean(enabledTool) : isEnabled);\n    final InspectionProfileEntry tool = myDefaultState.getTool();\n    tool.readSettings(toolElement);\n    final List children = toolElement.getChildren(InspectionProfileImpl.SCOPE);\n    if (!children.isEmpty()) {\n      for (Object sO : children) {\n        final Element scopeElement = (Element)sO;\n        final String scopeName = scopeElement.getAttributeValue(InspectionProfileImpl.NAME);\n        if (scopeName != null) {\n          final NamedScopesHolder scopesHolder = profileManager.getScopesManager();\n          final NamedScope namedScope;\n          if (scopesHolder != null) {\n            namedScope = scopesHolder.getScope(scopeName);\n          } else {\n            final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n            if (projects.length > 0) {\n              namedScope = NamedScopesHolder.getScope(projects[0], scopeName);\n            } else {\n              namedScope = NamedScopesHolder.getScope(ProjectManager.getInstance().getDefaultProject(), scopeName);\n            }\n          }\n          final String errorLevel = scopeElement.getAttributeValue(InspectionProfileImpl.LEVEL_TAG);\n          final String enabledInScope = scopeElement.getAttributeValue(InspectionProfileImpl.ENABLED_TAG);\n          final InspectionProfileEntry copyTool =\n            ((InspectionProfileImpl)profile).myRegistrar.createInspectionTool(myShortName, tool);\n          copyTool.readSettings(scopeElement);\n          final HighlightDisplayLevel scopeLevel = errorLevel != null ? HighlightDisplayLevel\n            .find(((SeverityProvider)profileManager).getOwnSeverityRegistrar().getSeverity(errorLevel)) : level;\n          if (namedScope != null) {\n            addTool(namedScope, copyTool, enabledInScope != null && Boolean.parseBoolean(enabledInScope), scopeLevel);\n          } else {\n            addTool(scopeName, copyTool, enabledInScope != null && Boolean.parseBoolean(enabledInScope), scopeLevel);\n          }\n        }\n      }\n    }\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(Element inspectionElement) throws WriteExternalException {\n    if (myTools != null) {\n      for (ScopeToolState state : myTools) {\n        final NamedScope namedScope = state.getScope();\n        final Element scopeElement = new Element(\"scope\");\n        scopeElement.setAttribute(\"name\", namedScope.getName());\n        scopeElement.setAttribute(InspectionProfileImpl.LEVEL_TAG, state.getLevel().toString());\n        scopeElement.setAttribute(InspectionProfileImpl.ENABLED_TAG, Boolean.toString(state.isEnabled()));\n        InspectionProfileEntry InspectionProfileEntry = state.getTool();\n        InspectionProfileEntry.writeSettings(scopeElement);\n        inspectionElement.addContent(scopeElement);\n      }\n    }\n    inspectionElement.setAttribute(InspectionProfileImpl.ENABLED_TAG, Boolean.toString(isEnabled()));\n    inspectionElement.setAttribute(InspectionProfileImpl.LEVEL_TAG, getLevel().toString());\n    inspectionElement.setAttribute(ENABLED_TAG, Boolean.toString(myDefaultState.isEnabled()));\n    myDefaultState.getTool().writeSettings(inspectionElement);\n  }","id":31659,"modified_method":"public void writeExternal(Element inspectionElement) throws WriteExternalException {\n    if (myTools != null) {\n      for (ScopeToolState state : myTools) {\n        final Element scopeElement = new Element(\"scope\");\n        scopeElement.setAttribute(\"name\", state.getScopeName());\n        scopeElement.setAttribute(InspectionProfileImpl.LEVEL_TAG, state.getLevel().toString());\n        scopeElement.setAttribute(InspectionProfileImpl.ENABLED_TAG, Boolean.toString(state.isEnabled()));\n        InspectionProfileEntry InspectionProfileEntry = state.getTool();\n        InspectionProfileEntry.writeSettings(scopeElement);\n        inspectionElement.addContent(scopeElement);\n      }\n    }\n    inspectionElement.setAttribute(InspectionProfileImpl.ENABLED_TAG, Boolean.toString(isEnabled()));\n    inspectionElement.setAttribute(InspectionProfileImpl.LEVEL_TAG, getLevel().toString());\n    inspectionElement.setAttribute(ENABLED_TAG, Boolean.toString(myDefaultState.isEnabled()));\n    myDefaultState.getTool().writeSettings(inspectionElement);\n  }","commit_id":"aa69ceb336a85ec7d8421bd2708f915ee6a3d1b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\treturn super.processRequest();\n\t}","id":31660,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tsuper.processRequest();\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\treturn super.processRequest();\n\t}","id":31661,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tsuper.processRequest();\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Object getParameterValue(String key) {\n\t\treturn _parameters.get(key);\n\t}","id":31662,"modified_method":"@Override\n\tpublic Object getParameterValue(String key) {\n\t\treturn _parameters.get(key);\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public <T> T executePost(\n\t\t\tString urlPath, Map<String, Object> parameters,\n\t\t\tResponseHandler<? extends T> responseHandler)\n\t\tthrows Exception {\n\n\t\tSession session = SessionManager.getSession(_syncAccountId);\n\n\t\treturn session.executePost(urlPath, parameters, responseHandler);\n\t}","id":31663,"modified_method":"public <T> T executePost(\n\t\t\tString urlPath, Map<String, Object> parameters,\n\t\t\tHandler<? extends T> handler)\n\t\tthrows Exception {\n\n\t\tSession session = SessionManager.getSession(_syncAccountId);\n\n\t\treturn session.executePost(urlPath, parameters, handler);\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected long getSyncAccountId() {\n\t\treturn _syncAccountId;\n\t}","id":31664,"modified_method":"@Override\n\tpublic long getSyncAccountId() {\n\t\treturn _syncAccountId;\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tString response = processRequest();\n\n\t\t\tif ((response == null) || handleRemoteException(response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocessResponse(response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(e.getMessage(), e);\n\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\t_syncAccountId);\n\n\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\n\t\t\tif (e instanceof HttpHostConnectException) {\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t\t}\n\t\t\telse if (e instanceof HttpResponseException) {\n\t\t\t\tHttpResponseException hre = (HttpResponseException)e;\n\n\t\t\t\tint statusCode = hre.getStatusCode();\n\n\t\t\t\tif (statusCode == HttpServletResponse.SC_UNAUTHORIZED) {\n\t\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\t\tSyncAccount.UI_EVENT_AUTHENTICATION_EXCEPTION);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\t\tSyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\tretryServerConnection();\n\t\t}\n\t}","id":31665,"modified_method":"@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tprocessRequest();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tHandler<?> handler = getHandler();\n\n\t\t\thandler.handleException(e);\n\t\t}\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public <T> T executeGet(\n\t\t\tString urlPath, ResponseHandler<? extends T> responseHandler)\n\t\tthrows Exception {\n\n\t\tSession session = SessionManager.getSession(_syncAccountId);\n\n\t\treturn session.executeGet(urlPath, responseHandler);\n\t}","id":31666,"modified_method":"public <T> T executeGet(String urlPath, Handler<? extends T> handler)\n\t\tthrows Exception {\n\n\t\tSession session = SessionManager.getSession(_syncAccountId);\n\n\t\treturn session.executeGet(urlPath, handler);\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Map<String, Object> getParameters() {\n\t\treturn _parameters;\n\t}","id":31667,"modified_method":"@Override\n\tpublic Map<String, Object> getParameters() {\n\t\treturn _parameters;\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String processRequest() throws Exception {\n\t\treturn executePost(_urlPath, _parameters, new BaseHandler());\n\t}","id":31668,"modified_method":"protected void processRequest() throws Exception {\n\t\texecutePost(_urlPath, _parameters, getHandler());\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic String handleResponse(HttpResponse httpResponse)\n\t\tthrows HttpResponseException, IOException {\n\n\t\tStatusLine statusLine = httpResponse.getStatusLine();\n\n\t\tif (statusLine.getStatusCode() != 200) {\n\t\t\t_logger.error(\"Status code {}\", statusLine.getStatusCode());\n\n\t\t\tthrow new HttpResponseException(\n\t\t\t\tstatusLine.getStatusCode(), statusLine.getReasonPhrase());\n\t\t}\n\n\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\n\t\treturn EntityUtils.toString(httpEntity);\n\t}","id":31669,"modified_method":"@Override\n\tpublic Void handleResponse(HttpResponse httpResponse) throws IOException {\n\t\ttry {\n\t\t\tStatusLine statusLine = httpResponse.getStatusLine();\n\n\t\t\tif (statusLine.getStatusCode() != 200) {\n\t\t\t\t_logger.error(\"Status code {}\", statusLine.getStatusCode());\n\n\t\t\t\tthrow new HttpResponseException(\n\t\t\t\t\tstatusLine.getStatusCode(), statusLine.getReasonPhrase());\n\t\t\t}\n\n\t\t\tdoHandleResponse(httpResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\thandleException(e);\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tStringBuilder sb = new StringBuilder(9);\n\n\t\tsb.append(replaceURLPath(getSyncAccountId()));\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getRepositoryId());\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getTypeUuid());\n\n\t\tif ((Boolean)getParameterValue(\"patch\")) {\n\t\t\tsb.append(\"?patch=true&sourceVersion=\");\n\t\t\tsb.append(getParameterValue(\"sourceVersion\"));\n\t\t\tsb.append(\"&targetVersion=\");\n\t\t\tsb.append(getParameterValue(\"targetVersion\"));\n\t\t}\n\n\t\treturn executeGet(sb.toString(), new BaseHandler());\n\t}","id":31670,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tStringBuilder sb = new StringBuilder(9);\n\n\t\tsb.append(replaceURLPath(getSyncAccountId()));\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getRepositoryId());\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getTypeUuid());\n\n\t\tif ((Boolean)getParameterValue(\"patch\")) {\n\t\t\tsb.append(\"?patch=true&sourceVersion=\");\n\t\t\tsb.append(getParameterValue(\"sourceVersion\"));\n\t\t\tsb.append(\"&targetVersion=\");\n\t\t\tsb.append(getParameterValue(\"targetVersion\"));\n\t\t}\n\n\t\texecuteGet(sb.toString(), getHandler());\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\tString filePathName = syncSite.getFilePathName();\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\tfilePathName, getSyncAccountId());\n\n\t\tif (syncFile == null) {\n\t\t\tFiles.createDirectories(Paths.get(filePathName));\n\n\t\t\tSyncFileService.addSyncFile(\n\t\t\t\tnull, null, filePathName, FileUtil.getFileKey(filePathName),\n\t\t\t\tfilePathName, null, filePathName, 0, syncSite.getGroupId(),\n\t\t\t\tsyncSite.getSyncAccountId(), SyncFile.TYPE_FOLDER);\n\t\t}\n\n\t\treturn super.processRequest();\n\t}","id":31671,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\tString filePathName = syncSite.getFilePathName();\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\tfilePathName, getSyncAccountId());\n\n\t\tif (syncFile == null) {\n\t\t\tFiles.createDirectories(Paths.get(filePathName));\n\n\t\t\tSyncFileService.addSyncFile(\n\t\t\t\tnull, null, filePathName, FileUtil.getFileKey(filePathName),\n\t\t\t\tfilePathName, null, filePathName, 0, syncSite.getGroupId(),\n\t\t\t\tsyncSite.getSyncAccountId(), SyncFile.TYPE_FOLDER);\n\t\t}\n\n\t\tsuper.processRequest();\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\t// Refetch for updated last remote sync time\n\n\t\tsyncSite = SyncSiteService.fetchSyncSite(\n\t\t\tsyncSite.getGroupId(), syncSite.getSyncAccountId());\n\n\t\tif (syncSite.getLastRemoteSyncTime() == 0) {\n\t\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\t\tparameters.put(\"folderId\", 0);\n\t\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\t\t\tparameters.put(\"syncSite\", syncSite);\n\n\t\t\tGetAllSyncDLObjectsEvent getAllSyncDLObjectsEvent =\n\t\t\t\tnew GetAllSyncDLObjectsEvent(getSyncAccountId(), parameters);\n\n\t\t\tgetAllSyncDLObjectsEvent.run();\n\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"companyId\", syncSite.getCompanyId());\n\t\tparameters.put(\"lastAccessTime\", syncSite.getLastRemoteSyncTime());\n\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\n\t\treturn executePost(_URL_PATH, parameters, new BaseHandler());\n\t}","id":31672,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\t// Refetch for updated last remote sync time\n\n\t\tsyncSite = SyncSiteService.fetchSyncSite(\n\t\t\tsyncSite.getGroupId(), syncSite.getSyncAccountId());\n\n\t\tif (syncSite.getLastRemoteSyncTime() == 0) {\n\t\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\t\tparameters.put(\"folderId\", 0);\n\t\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\t\t\tparameters.put(\"syncSite\", syncSite);\n\n\t\t\tGetAllSyncDLObjectsEvent getAllSyncDLObjectsEvent =\n\t\t\t\tnew GetAllSyncDLObjectsEvent(getSyncAccountId(), parameters);\n\n\t\t\tgetAllSyncDLObjectsEvent.run();\n\n\t\t\treturn;\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"companyId\", syncSite.getCompanyId());\n\t\tparameters.put(\"lastAccessTime\", syncSite.getLastRemoteSyncTime());\n\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\n\t\texecutePost(_URL_PATH, parameters, getHandler());\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\treturn super.processRequest();\n\t}","id":31673,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tsuper.processRequest();\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public <T> T executePost(\n\t\t\tString urlPath, Map<String, Object> parameters,\n\t\t\tResponseHandler<? extends T> responseHandler)\n\t\tthrows Exception {\n\n\t\tHttpPost httpPost = new HttpPost(_url.toString() + urlPath);\n\n\t\t_buildHttpPostBody(httpPost, parameters);\n\n\t\treturn _httpClient.execute(\n\t\t\t_httpHost, httpPost, responseHandler, _getBasicHttpContext());\n\t}","id":31674,"modified_method":"public <T> T executePost(\n\t\t\tString urlPath, Map<String, Object> parameters,\n\t\t\tHandler<? extends T> handler)\n\t\tthrows Exception {\n\n\t\tHttpPost httpPost = new HttpPost(_url.toString() + urlPath);\n\n\t\t_buildHttpPostBody(httpPost, parameters);\n\n\t\treturn _httpClient.execute(\n\t\t\t_httpHost, httpPost, handler, _getBasicHttpContext());\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public <T> T executeGet(\n\t\t\tString urlPath, ResponseHandler<? extends T> responseHandler)\n\t\tthrows Exception {\n\n\t\tHttpGet httpGet = new HttpGet(urlPath);\n\n\t\treturn _httpClient.execute(\n\t\t\t_httpHost, httpGet, responseHandler, _getBasicHttpContext());\n\t}","id":31675,"modified_method":"public <T> T executeGet(String urlPath, Handler<? extends T> handler)\n\t\tthrows Exception {\n\n\t\tHttpGet httpGet = new HttpGet(urlPath);\n\n\t\treturn _httpClient.execute(\n\t\t\t_httpHost, httpGet, handler, _getBasicHttpContext());\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\tif (getParameterValue(\"filePath\") != null) {\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPLOADING);\n\t\t}\n\n\t\tSyncFileService.update(syncFile);\n\n\t\treturn super.processRequest();\n\t}","id":31676,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\tif (getParameterValue(\"filePath\") != null) {\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPLOADING);\n\t\t}\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tsuper.processRequest();\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\treturn super.processRequest();\n\t}","id":31677,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tsuper.processRequest();\n\t}","commit_id":"36ef944cd56caa16bdc21cb96ec4a163ad674a28","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public BasicObservationReporter(Map<ResourceChangeListener, ObserverConfiguration> listeners) {\n        this.listeners = new HashMap<ResourceChangeListener, ObserverConfiguration>(listeners);\n        this.configs = new ArrayList<ObserverConfiguration>(listeners.values());\n    }","id":31678,"modified_method":"/**\n     * Create a reporter listening for resource provider changes\n     * @param infos The listeners map\n     */\n    public BasicObservationReporter(final Collection<ResourceChangeListenerInfo> infos) {\n        final Set<String> paths = new HashSet<String>();\n        for(final ResourceChangeListenerInfo info : infos) {\n            if ( !info.getProviderChangeTypes().isEmpty() ) {\n                for(final Path p : info.getPaths()) {\n                    paths.add(p.getPath());\n                }\n                fillListeners(info, info.getResourceChangeTypes());\n            }\n        }\n        final ObserverConfiguration cfg = new BasicObserverConfiguration(paths);\n        this.configs = Collections.singletonList(cfg);\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void reportChanges(Iterable<ResourceChange> changes, boolean distribute) {\n        for (Entry<ResourceChangeListener, ObserverConfiguration> e : listeners.entrySet()) {\n            List<ResourceChange> filtered = filterChanges(changes, e.getValue());\n            e.getKey().onChange(filtered);\n        }\n    }","id":31679,"modified_method":"@Override\n    public void reportChanges(final Iterable<ResourceChange> changes, final boolean distribute) {\n        final List<ResourceChange> changeList = new ArrayList<ResourceChange>();\n        for(final ResourceChange ch : changes) {\n            changeList.add(ch);\n        }\n        for (final Map.Entry<ListenerConfig, List<ResourceChangeListenerInfo>> entry : this.listeners.entrySet()) {\n            final List<ResourceChange> filtered = filterChanges(changeList, entry.getKey());\n            if ( !filtered.isEmpty() ) {\n                for(final ResourceChangeListenerInfo info : entry.getValue()) {\n                    info.getListener().onChange(filtered);\n                }\n            }\n        }\n        // TODO implement distribute\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"private List<ResourceChange> filterChanges(Iterable<ResourceChange> changes, ObserverConfiguration config) {\n        List<ResourceChange> filtered = new ArrayList<ResourceChange>();\n        for (ResourceChange c : changes) {\n            if (matches(c, config)) {\n                filtered.add(c);\n            }\n        }\n        return filtered;\n    }","id":31680,"modified_method":"/**\n     * Filter the change list based on the configuration\n     * @param changes The list of changes\n     * @param config The configuration\n     * @return The filtered list.\n     */\n    private List<ResourceChange> filterChanges(final List<ResourceChange> changes, final ListenerConfig config) {\n        final List<ResourceChange> filtered = new ArrayList<ResourceChange>();\n        for (final ResourceChange c : changes) {\n            if (matches(c, config)) {\n                filtered.add(c);\n            }\n        }\n        return filtered;\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"private boolean matches(ResourceChange change, ObserverConfiguration config) {\n        if (!config.getChangeTypes().contains(change.getType())) {\n            return false;\n        }\n        if (!config.includeExternal() && change.isExternal()) {\n            return false;\n        }\n        for (String excludedPath : config.getExcludedPaths()) {\n            if (change.getPath().startsWith(excludedPath)) {\n                return false;\n            }\n        }\n        boolean included = false;\n        for (String includedPath : config.getPaths()) {\n            if (change.getPath().startsWith(includedPath)) {\n                included = true;\n                break;\n            }\n        }\n        if (!included) {\n            return false;\n        }\n        return true;\n    }","id":31681,"modified_method":"/**\n     * Match a change against the configuration\n     * @param change The change\n     * @param config The configuration\n     * @return {@code true} whether it matches\n     */\n    private boolean matches(final ResourceChange change, final ListenerConfig config) {\n        if (!config.types.contains(change.getType())) {\n            return false;\n        }\n        if (!config.isExternal && change.isExternal()) {\n            return false;\n        }\n        if (!config.paths.matches(change.getPath())) {\n            return false;\n        }\n        return true;\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"private BasicObserverConfiguration(Builder builder) {\n        this.includeExternal = builder.isIncludeExternal();\n        this.paths = builder.getPaths();\n        this.excludedPaths = builder.getExludedPaths();\n        this.changeTypes = builder.getChangeTypes();\n    }","id":31682,"modified_method":"public BasicObserverConfiguration(final Set<String> paths) {\n        this.includeExternal = false;\n        this.paths = Collections.unmodifiableSet(paths);\n        final Set<ChangeType> types = new HashSet<ChangeType>();\n        types.add(ChangeType.PROVIDER_ADDED);\n        types.add(ChangeType.PROVIDER_REMOVED);\n        this.changeTypes = Collections.unmodifiableSet(types);\n        this.excludedPaths = Collections.emptySet();\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"public Set<ChangeType> getChangeTypes() {\n        return this.changeTypes;\n    }","id":31683,"modified_method":"public Set<ChangeType> getResourceChangeTypes() {\n        return this.resourceChangeTypes;\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"public ResourceChangeListenerInfo(final ServiceReference ref, final String[] searchPaths) {\n        boolean configValid = true;\n        final Set<String> pathsSet = new HashSet<String>();\n        final String paths[] = toStringArray(ref.getProperty(PATHS), null);\n        if ( paths != null ) {\n            for(final String p : paths) {\n                if ( p.isEmpty() ) {\n                    configValid = false;\n                } else if ( p.startsWith(\"/\") ) {\n                    pathsSet.add(p);\n                } else {\n                    for(final String sp : searchPaths) {\n                        if ( p.equals(\".\") ) {\n                            pathsSet.add(sp);\n                        } else {\n                            pathsSet.add(sp + p);\n                        }\n                    }\n                }\n            }\n        }\n        if ( pathsSet.isEmpty() ) {\n            configValid = false;\n        } else {\n            // check for sub paths\n            final Iterator<String> iter = pathsSet.iterator();\n            while ( iter.hasNext() ) {\n                final String path = iter.next();\n                boolean remove = false;\n                for(final String p : pathsSet) {\n                    if ( p.length() > path.length() && path.startsWith(p + \"/\") ) {\n                        remove = true;\n                        break;\n                    }\n                }\n                if ( remove ) {\n                    iter.remove();\n                }\n            }\n        }\n        this.paths = Collections.unmodifiableSet(pathsSet);\n        final Set<ChangeType> typesSet = new HashSet<ChangeType>();\n        if (ref.getProperty(CHANGES) != null ) {\n            for (String changeName : toStringArray(ref.getProperty(CHANGES))) {\n                try {\n                    this.changeTypes.add(ChangeType.valueOf(changeName));\n                } catch ( final IllegalArgumentException iae) {\n                    configValid = false;\n                }\n            }\n        } else {\n            // default is added, changed, removed\n            typesSet.add(ChangeType.ADDED);\n            typesSet.add(ChangeType.CHANGED);\n            typesSet.add(ChangeType.REMOVED);\n        }\n        this.changeTypes = Collections.unmodifiableSet(typesSet);\n        this.valid = configValid;\n    }","id":31684,"modified_method":"public ResourceChangeListenerInfo(final ServiceReference ref, final String[] searchPaths) {\n        boolean configValid = true;\n        final Set<String> pathsSet = new HashSet<String>();\n        final String paths[] = toStringArray(ref.getProperty(PATHS), null);\n        if ( paths != null ) {\n            for(final String p : paths) {\n                if ( p.isEmpty() ) {\n                    configValid = false;\n                } else if ( p.startsWith(\"/\") ) {\n                    pathsSet.add(p);\n                } else {\n                    for(final String sp : searchPaths) {\n                        if ( p.equals(\".\") ) {\n                            pathsSet.add(sp);\n                        } else {\n                            pathsSet.add(sp + p);\n                        }\n                    }\n                }\n            }\n        }\n        if ( pathsSet.isEmpty() ) {\n            configValid = false;\n        } else {\n            // check for sub paths\n            final Iterator<String> iter = pathsSet.iterator();\n            while ( iter.hasNext() ) {\n                final String path = iter.next();\n                boolean remove = false;\n                for(final String p : pathsSet) {\n                    if ( p.length() > path.length() && path.startsWith(p + \"/\") ) {\n                        remove = true;\n                        break;\n                    }\n                }\n                if ( remove ) {\n                    iter.remove();\n                }\n            }\n        }\n        this.paths = new PathSet(pathsSet);\n        final Set<ChangeType> typesSet = new HashSet<ChangeType>();\n        if (ref.getProperty(CHANGES) != null ) {\n            for (String changeName : toStringArray(ref.getProperty(CHANGES))) {\n                try {\n                    typesSet.add(ChangeType.valueOf(changeName));\n                } catch ( final IllegalArgumentException iae) {\n                    configValid = false;\n                }\n            }\n        } else {\n            // default is added, changed, removed\n            typesSet.add(ChangeType.ADDED);\n            typesSet.add(ChangeType.CHANGED);\n            typesSet.add(ChangeType.REMOVED);\n        }\n        final Set<ChangeType> rts = new HashSet<ChangeType>();\n        if ( typesSet.contains(ChangeType.ADDED)) {\n            rts.add(ChangeType.ADDED);\n        }\n        if ( typesSet.contains(ChangeType.CHANGED)) {\n            rts.add(ChangeType.CHANGED);\n        }\n        if ( typesSet.contains(ChangeType.REMOVED)) {\n            rts.add(ChangeType.REMOVED);\n        }\n        this.resourceChangeTypes = Collections.unmodifiableSet(rts);\n\n        final Set<ChangeType> pts = new HashSet<ChangeType>();\n        if ( typesSet.contains(ChangeType.PROVIDER_ADDED)) {\n            pts.add(ChangeType.PROVIDER_ADDED);\n        }\n        if ( typesSet.contains(ChangeType.PROVIDER_REMOVED)) {\n            pts.add(ChangeType.PROVIDER_REMOVED);\n        }\n        this.providerChangeTypes = Collections.unmodifiableSet(pts);\n\n        this.valid = configValid;\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"private void updateProviderTracker() {\n        // TODO\n        this.resourceProviderTracker.setObservationReporter(EMPTY_REPORTER);\n    }","id":31685,"modified_method":"private void updateProviderTracker() {\n        this.resourceProviderTracker.setObservationReporterGenerator(this);\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"public void deactivate() {\n        if ( this.tracker != null ) {\n            this.tracker.close();\n            this.tracker = null;\n        }\n        this.searchPaths = null;\n        this.resourceProviderTracker.setObservationReporter(EMPTY_REPORTER);\n        this.resourceProviderTracker = null;\n    }","id":31686,"modified_method":"public void deactivate() {\n        if ( this.tracker != null ) {\n            this.tracker.close();\n            this.tracker = null;\n        }\n        this.resourceProviderTracker.setObservationReporterGenerator(NOP_GENERATOR);\n        this.resourceProviderTracker = null;\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"public void activate(final BundleContext bundleContext,\n            final ResourceProviderTracker resourceProviderTracker,\n            final String[] searchPaths) {\n        this.searchPaths = searchPaths;\n        this.resourceProviderTracker = resourceProviderTracker;\n        this.resourceProviderTracker.setObservationReporter(EMPTY_REPORTER);\n        this.tracker = new ServiceTracker(bundleContext,\n                ResourceChangeListener.class.getName(),\n                new ServiceTrackerCustomizer() {\n\n            @Override\n            public void removedService(final ServiceReference reference, final Object service) {\n                final ServiceReference ref = (ServiceReference)service;\n                final ResourceChangeListenerInfo info = listeners.remove(ref);\n                if ( info != null ) {\n                    updateProviderTracker();\n                }\n            }\n\n            @Override\n            public void modifiedService(final ServiceReference reference, final Object service) {\n                removedService(reference, service);\n                addingService(reference);\n            }\n\n            @Override\n            public Object addingService(final ServiceReference reference) {\n                final ResourceChangeListenerInfo info = new ResourceChangeListenerInfo(reference, searchPaths);\n                if ( info.isValid() ) {\n                    final ResourceChangeListener listener = (ResourceChangeListener) bundleContext.getService(reference);\n                    if ( listener != null ) {\n                        info.setExternal(listener instanceof ExternalResourceListener);\n                        listeners.put(reference, info);\n                        updateProviderTracker();\n                    }\n                }\n                return reference;\n            }\n        });\n        this.tracker.open();\n    }","id":31687,"modified_method":"public void activate(final BundleContext bundleContext,\n            final ResourceProviderTracker resourceProviderTracker,\n            final String[] searchPaths) {\n        this.resourceProviderTracker = resourceProviderTracker;\n        this.resourceProviderTracker.setObservationReporterGenerator(this);\n        this.tracker = new ServiceTracker(bundleContext,\n                ResourceChangeListener.class.getName(),\n                new ServiceTrackerCustomizer() {\n\n            @Override\n            public void removedService(final ServiceReference reference, final Object service) {\n                final ServiceReference ref = (ServiceReference)service;\n                final ResourceChangeListenerInfo info = listeners.remove(ref);\n                if ( info != null ) {\n                    updateProviderTracker();\n                }\n            }\n\n            @Override\n            public void modifiedService(final ServiceReference reference, final Object service) {\n                removedService(reference, service);\n                addingService(reference);\n            }\n\n            @Override\n            public Object addingService(final ServiceReference reference) {\n                final ResourceChangeListenerInfo info = new ResourceChangeListenerInfo(reference, searchPaths);\n                if ( info.isValid() ) {\n                    final ResourceChangeListener listener = (ResourceChangeListener) bundleContext.getService(reference);\n                    if ( listener != null ) {\n                        info.setListener(listener);\n                        listeners.put(reference, info);\n                        updateProviderTracker();\n                    }\n                }\n                return reference;\n            }\n        });\n        this.tracker.open();\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"public void setObservationReporter(final ObservationReporter report) {\n        this.reporter = report;\n    }","id":31688,"modified_method":"public void setObservationReporterGenerator(final ObservationReporterGenerator generator) {\n        this.reporterGenerator = generator;\n        this.providerReporter = generator.createProviderReporter();\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"private void postResourceProviderChange(ChangeType type, final ResourceProviderInfo info) {\n        ResourceChange change = new ResourceChange(type, info.getPath(), false, null, null, null);\n        this.reporter.reportChanges(Collections.singletonList(change), false);\n    }","id":31689,"modified_method":"/**\n     * Post a change event for a resource provider change\n     * @param type The change type\n     * @param info The resource provider\n     */\n    private void postResourceProviderChange(ChangeType type, final ResourceProviderInfo info) {\n        ResourceChange change = new ResourceChange(type, info.getPath(), false, null, null, null);\n        this.providerReporter.reportChanges(Collections.singletonList(change), false);\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"private ProviderContext createProviderContext(final ResourceProviderHandler handler) {\n        final Set<String> excludedPaths = new HashSet<String>();\n        String path = handler.getInfo().getPath();\n        for (String providerPath : handlers.keySet()) {\n            if (providerPath.startsWith(path)) {\n                excludedPaths.add(providerPath);\n            }\n        }\n        excludedPaths.remove(path);\n        return new ProviderContextImpl(reporter, excludedPaths);\n    }","id":31690,"modified_method":"private ProviderContext createProviderContext(final ResourceProviderHandler handler) {\n        final Set<String> excludedPaths = new HashSet<String>();\n        final Path handlerPath = new Path(handler.getPath());\n        for(final String otherPath : handlers.keySet()) {\n            if ( !handler.getPath().equals(otherPath) && handlerPath.matches(otherPath) ) {\n                excludedPaths.add(otherPath);\n            }\n        }\n        return new ProviderContextImpl(reporterGenerator.create(handlerPath, new PathSet(excludedPaths)), excludedPaths);\n    }","commit_id":"08ef39d8ea3d1d16166c43e87020832bc24cd5ef","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Undoes the last change.<p>\n     */\n    public void undo() {\n\n        if (!isDirty()) {\n            return;\n        }\n\n        // pre-state\n        if (m_undone.isEmpty()) {\n            m_handler.onFirstUndo();\n        }\n\n        // undo\n        I_CmsSitemapChange change = m_changes.remove(m_changes.size() - 1);\n        m_undone.add(change);\n        // refresh view\n        if (m_handler != null) {\n            m_handler.onChange(change);\n        }\n\n        // post-state\n        if (!isDirty()) {\n            m_handler.onLastUndo();\n            internalReset(false);\n        }\n    }","id":31691,"modified_method":"/**\n     * Undoes the last change.<p>\n     */\n    public void undo() {\n\n        if (!isDirty()) {\n            return;\n        }\n\n        // pre-state\n        if (m_undone.isEmpty()) {\n            m_handler.onFirstUndo();\n        }\n\n        // undo\n        I_CmsSitemapChange change = m_changes.remove(m_changes.size() - 1);\n        m_undone.add(change);\n\n        // update data\n        I_CmsSitemapChange revertChange = change.revert();\n        update(revertChange);\n\n        // refresh view\n        m_handler.onChange(revertChange);\n\n        // post-state\n        if (!isDirty()) {\n            m_handler.onLastUndo();\n            internalReset(false);\n        }\n    }","commit_id":"39984f391efe21e35d2f78f30cc013db46739fe8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a change to the queue.<p>\n     * \n     * @param oldEntry the old entry\n     * @param newEntry the new entry\n     * @param changeType the change type\n     * @param position the new position between its siblings, only used when moving\n     * @param redo if redoing a change\n     */\n    private void addChange(I_CmsSitemapChange change, boolean redo) {\n\n        // state\n        if (!isDirty()) {\n            startEdit();\n        }\n\n        if (!redo) {\n            // after a new change no changes can be redone\n            m_undone.clear();\n        }\n\n        // add it\n        m_changes.add(change);\n\n        // update data\n        if (change instanceof CmsSitemapChangeDelete) {\n            CmsSitemapChangeDelete changeDelete = (CmsSitemapChangeDelete)change;\n            CmsClientSitemapEntry deleteParent = getEntry(CmsResource.getParentFolder(changeDelete.getEntry().getSitePath()));\n            deleteParent.removeChild(changeDelete.getEntry().getPosition());\n        } else if (change instanceof CmsSitemapChangeEdit) {\n            CmsSitemapChangeEdit changeEdit = (CmsSitemapChangeEdit)change;\n            CmsClientSitemapEntry editEntry = getEntry(changeEdit.getOldEntry().getSitePath());\n            editEntry.setTitle(changeEdit.getNewEntry().getTitle());\n            editEntry.setVfsPath(changeEdit.getNewEntry().getVfsPath());\n            editEntry.setProperties(changeEdit.getNewEntry().getProperties());\n        } else if (change instanceof CmsSitemapChangeMove) {\n            CmsSitemapChangeMove changeMove = (CmsSitemapChangeMove)change;\n            CmsClientSitemapEntry sourceParent = getEntry(CmsResource.getParentFolder(changeMove.getSourcePath()));\n            CmsClientSitemapEntry moved = sourceParent.removeChild(changeMove.getSourcePosition());\n            CmsClientSitemapEntry destParent = getEntry(CmsResource.getParentFolder(changeMove.getDestinationPath()));\n            destParent.insertChild(moved, changeMove.getDestinationPosition());\n        } else if (change instanceof CmsSitemapChangeNew) {\n            CmsSitemapChangeNew changeNew = (CmsSitemapChangeNew)change;\n            CmsClientSitemapEntry newParent = getEntry(CmsResource.getParentFolder(changeNew.getEntry().getSitePath()));\n            newParent.addChild(changeNew.getEntry());\n        }\n\n        // refresh view\n        if (m_handler != null) {\n            m_handler.onChange(change);\n        }\n    }","id":31692,"modified_method":"/**\n     * Adds a change to the queue.<p>\n     * \n     * @param oldEntry the old entry\n     * @param newEntry the new entry\n     * @param changeType the change type\n     * @param position the new position between its siblings, only used when moving\n     * @param redo if redoing a change\n     */\n    private void addChange(I_CmsSitemapChange change, boolean redo) {\n\n        // state\n        if (!isDirty()) {\n            startEdit();\n        }\n\n        if (!redo) {\n            // after a new change no changes can be redone\n            m_undone.clear();\n            m_handler.onClearUndo();\n        }\n\n        // add it\n        m_changes.add(change);\n\n        // update data\n        update(change);\n\n        // refresh view\n        m_handler.onChange(change);\n    }","commit_id":"39984f391efe21e35d2f78f30cc013db46739fe8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Will be triggered when something has changed.<p>\n     * \n     * @param change the specific change\n     */\n    public void onChange(I_CmsSitemapChange change) {\n\n        m_toolbar.getRedoButton().setEnabled(false);\n\n        if (change instanceof CmsSitemapChangeDelete) {\n            CmsSitemapChangeDelete changeDelete = (CmsSitemapChangeDelete)change;\n            CmsTreeItem deleteParent = getTreeItem(CmsResource.getParentFolder(changeDelete.getEntry().getSitePath()));\n            deleteParent.removeChild(changeDelete.getEntry().getName());\n        } else if (change instanceof CmsSitemapChangeEdit) {\n            CmsSitemapChangeEdit changeEdit = (CmsSitemapChangeEdit)change;\n            CmsSitemapTreeItem editEntry = (CmsSitemapTreeItem)getTreeItem(changeEdit.getOldEntry().getSitePath());\n            editEntry.updateEntry(changeEdit.getNewEntry());\n        } else if (change instanceof CmsSitemapChangeMove) {\n            CmsSitemapChangeMove changeMove = (CmsSitemapChangeMove)change;\n            CmsTreeItem sourceParent = getTreeItem(CmsResource.getParentFolder(changeMove.getSourcePath()));\n            CmsTreeItem moved = sourceParent.getChild(changeMove.getSourcePosition());\n            sourceParent.removeChild(changeMove.getSourcePosition());\n            CmsTreeItem destParent = getTreeItem(CmsResource.getParentFolder(changeMove.getDestinationPath()));\n            destParent.insertChild(moved, changeMove.getDestinationPosition());\n        } else if (change instanceof CmsSitemapChangeNew) {\n            CmsSitemapChangeNew changeNew = (CmsSitemapChangeNew)change;\n            CmsTreeItem newParent = getTreeItem(CmsResource.getParentFolder(changeNew.getEntry().getSitePath()));\n            CmsSitemapTreeItem newChild = m_factory.create(changeNew.getEntry());\n            if (changeNew.getEntry().getPosition() != -1) {\n                newParent.insertChild(newChild, changeNew.getEntry().getPosition());\n            } else {\n                newParent.addChild(newChild);\n            }\n        }\n    }","id":31693,"modified_method":"/**\n     * Will be triggered when something has changed.<p>\n     * \n     * @param change the specific change\n     */\n    public void onChange(I_CmsSitemapChange change) {\n\n        if (change instanceof CmsSitemapChangeDelete) {\n            CmsSitemapChangeDelete changeDelete = (CmsSitemapChangeDelete)change;\n            CmsTreeItem deleteParent = getTreeItem(CmsResource.getParentFolder(changeDelete.getEntry().getSitePath()));\n            deleteParent.removeChild(changeDelete.getEntry().getName());\n        } else if (change instanceof CmsSitemapChangeEdit) {\n            CmsSitemapChangeEdit changeEdit = (CmsSitemapChangeEdit)change;\n            CmsSitemapTreeItem editEntry = (CmsSitemapTreeItem)getTreeItem(changeEdit.getOldEntry().getSitePath());\n            editEntry.updateEntry(changeEdit.getNewEntry());\n        } else if (change instanceof CmsSitemapChangeMove) {\n            CmsSitemapChangeMove changeMove = (CmsSitemapChangeMove)change;\n            CmsTreeItem sourceParent = getTreeItem(CmsResource.getParentFolder(changeMove.getSourcePath()));\n            CmsTreeItem moved = sourceParent.getChild(changeMove.getSourcePosition());\n            sourceParent.removeChild(changeMove.getSourcePosition());\n            CmsTreeItem destParent = getTreeItem(CmsResource.getParentFolder(changeMove.getDestinationPath()));\n            destParent.insertChild(moved, changeMove.getDestinationPosition());\n        } else if (change instanceof CmsSitemapChangeNew) {\n            CmsSitemapChangeNew changeNew = (CmsSitemapChangeNew)change;\n            CmsTreeItem newParent = getTreeItem(CmsResource.getParentFolder(changeNew.getEntry().getSitePath()));\n            CmsSitemapTreeItem newChild = m_factory.create(changeNew.getEntry());\n            if (changeNew.getEntry().getPosition() != -1) {\n                newParent.insertChild(newChild, changeNew.getEntry().getPosition());\n            } else {\n                newParent.addChild(newChild);\n            }\n        }\n    }","commit_id":"39984f391efe21e35d2f78f30cc013db46739fe8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n        public FileWatcher watch(Iterable<? extends File> roots, FileWatcherListener listener) {\n            return new FileWatcher() {\n                @Override\n                public void stop() {\n\n                }\n            };\n        }","id":31694,"modified_method":"@Override\n        public FileWatcher watch(Iterable<? extends File> roots, FileWatcherListener listener) {\n            return new FileWatcher() {\n                @Override\n                public void stop() {\n\n                }\n\n                @Override\n                public boolean isRunning() {\n                    return false;\n                }\n            };\n        }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public FileWatcherEventResult onChange(FileWatcherEvent event) {\n            if(event.getFile() == null || fileCollection.contains(event.getFile())) {\n                listener.triggered(new DefaultTriggerDetails(TriggerDetails.Type.REBUILD, \"file change\"));\n                return FileWatcherEventResults.getContinueResult();\n                // TODO: stop watcher and restart for each new build\n                //return FileWatcherEventResults.getTerminateResult();\n            } else {\n                return FileWatcherEventResults.getContinueResult();\n            }\n        }","id":31695,"modified_method":"@Override\n        public void onChange(FileWatcher fileWatcher, FileWatcherEvent event) {\n            // TODO: stop watcher and restart for each new build\n            if (event.getFile() == null || fileCollection.contains(event.getFile())) {\n                listener.triggered(new DefaultTriggerDetails(TriggerDetails.Type.REBUILD, \"file change\"));\n            }\n        }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"FileWatchStrategy(TriggerListener listener, FileWatcherFactory fileWatcherFactory) {\n        this.listener = listener;\n        DirectoryFileTree directoryFileTree = new DirectoryFileTree(new File(\".\"));\n        directoryFileTree.getPatterns().exclude(\"build/**/*\", \".gradle/**/*\");\n        FileCollectionInternal fileCollection = new FileTreeAdapter(directoryFileTree);\n\n        this.fileWatcher = fileWatcherFactory.watch(fileCollection.getFileSystemRoots(), new FileChangeCallback(listener, fileCollection));\n    }","id":31696,"modified_method":"FileWatchStrategy(TriggerListener listener, FileWatcherFactory fileWatcherFactory) {\n        DirectoryFileTree directoryFileTree = new DirectoryFileTree(new File(\".\"));\n        directoryFileTree.getPatterns().exclude(\"build/**/*\", \".gradle/**/*\");\n        FileCollectionInternal fileCollection = new FileTreeAdapter(directoryFileTree);\n\n        fileWatcherFactory.watch(fileCollection.getFileSystemRoots(), new FileChangeCallback(listener, fileCollection));\n    }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public synchronized void stop() {\n        if (runningFlag.compareAndSet(true, false)) {\n            try {\n                watchService.close();\n            } catch (IOException e) {\n                // ignore exception in shutdown\n            }\n            try {\n                stopLatch.await(STOP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                // ignore exception in shutdown\n            }\n        }\n    }","id":31697,"modified_method":"@Override\n    public synchronized void stop() {\n        if (runningFlag.compareAndSet(true, false)) {\n            try {\n                watchService.close();\n            } catch (IOException e) {\n                // ignore exception in shutdown\n            }\n        }\n    }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"private void deliverEvent(FileWatcherEvent event) {\n        handleNewDirectory(event);\n        FileWatcherEventResult result = listener.onChange(event);\n        if (result instanceof TerminateFileWatcherEventResult) {\n            stopRunning();\n            Runnable terminateAction = ((TerminateFileWatcherEventResult) result).getOnTerminateAction();\n            if (terminateAction != null) {\n                terminateAction.run();\n            }\n        }\n    }","id":31698,"modified_method":"private void deliverEvent(FileWatcherEvent event) {\n        handleNewDirectory(event);\n        listener.onChange(this, event);\n    }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"public void run() {\n        runningFlag.compareAndSet(false, true);\n        try {\n            try {\n                pumpEvents();\n            } catch (InterruptedException e) {\n                // ignore exception in shutdown\n            }\n        } finally {\n            stopRunning();\n        }\n    }","id":31699,"modified_method":"public void run() {\n        runningFlag.set(true);\n        try {\n            try {\n                pumpEvents();\n            } catch (InterruptedException e) {\n                // ignore exception in shutdown\n            }\n        } finally {\n            stop();\n        }\n    }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean isRunning() {\n        return runningFlag.get() && !Thread.currentThread().isInterrupted();\n    }","id":31700,"modified_method":"@Override\n    public boolean isRunning() {\n        return runningFlag.get() && !Thread.currentThread().isInterrupted();\n    }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"private void deliverEvents(List<FileWatcherEvent> events) {\n        for (FileWatcherEvent event : events) {\n            deliverEvent(event);\n        }\n    }","id":31701,"modified_method":"private void deliverEvents(List<FileWatcherEvent> events) {\n        for (FileWatcherEvent event : events) {\n            while (isRunning()) {\n                deliverEvent(event);\n            }\n        }\n    }","commit_id":"64944a5313e1191933018c1693f1ba5d1d667dbd","url":"https://github.com/gradle/gradle"},{"original_method":"public void publish() {\n        RepositoryManager outputRepository = CeylonUtils.repoManager()\n                .outRepo(this.out)\n                .logger(log)\n                .user(user)\n                .password(pass)\n                .buildOutputManager();\n\n        ArtifactContext context = new ArtifactContext(module.getName(), module.getVersion(), ArtifactContext.JAR);\n        context.setForceOperation(true);\n        ArtifactContext descriptorContext = null;\n        if (descriptor != null) {\n            if (descriptor.toLowerCase().endsWith(\".xml\")) {\n                descriptorContext = new ArtifactContext(module.getName(), module.getVersion(), ArtifactContext.MODULE_XML);\n            } else if (descriptor.toLowerCase().endsWith(\".properties\")) {\n                descriptorContext = new ArtifactContext(module.getName(), module.getVersion(), ArtifactContext.MODULE_PROPERTIES);\n            }\n            descriptorContext.setForceOperation(true);\n        }\n        try{\n            outputRepository.putArtifact(context, new File(jarFile));\n            String sha1 = ShaSigner.sha1(jarFile, log);\n            if(sha1 != null){\n                File shaFile = ShaSigner.writeSha1(sha1, log);\n                if(shaFile != null){\n                    try{\n                        ArtifactContext sha1Context = context.getSha1Context();\n                        outputRepository.putArtifact(sha1Context, shaFile);\n                    }finally{\n                        shaFile.delete();\n                    }\n                }\n            }\n            \n            if (descriptorContext != null) {\n                outputRepository.putArtifact(descriptorContext, new File(descriptor));\n            }\n        }catch(CMRException x){\n            throw new ImportJarException(\"error.failedWriteArtifact\", new Object[]{context, x.getLocalizedMessage()}, x);\n        }catch(Exception x){\n            // FIXME: remove when the whole CMR is using CMRException\n            throw new ImportJarException(\"error.failedWriteArtifact\", new Object[]{context, x.getLocalizedMessage()}, x);\n        }\n    }","id":31702,"modified_method":"public void publish() {\n        RepositoryManager outputRepository = CeylonUtils.repoManager()\n                .cwd(cwd)\n                .outRepo(this.out)\n                .logger(log)\n                .user(user)\n                .password(pass)\n                .buildOutputManager();\n\n        ArtifactContext context = new ArtifactContext(module.getName(), module.getVersion(), ArtifactContext.JAR);\n        context.setForceOperation(true);\n        ArtifactContext descriptorContext = null;\n        if (descriptor != null) {\n            if (descriptor.toLowerCase().endsWith(\".xml\")) {\n                descriptorContext = new ArtifactContext(module.getName(), module.getVersion(), ArtifactContext.MODULE_XML);\n            } else if (descriptor.toLowerCase().endsWith(\".properties\")) {\n                descriptorContext = new ArtifactContext(module.getName(), module.getVersion(), ArtifactContext.MODULE_PROPERTIES);\n            }\n            descriptorContext.setForceOperation(true);\n        }\n        try{\n            outputRepository.putArtifact(context, new File(jarFile));\n            String sha1 = ShaSigner.sha1(jarFile, log);\n            if(sha1 != null){\n                File shaFile = ShaSigner.writeSha1(sha1, log);\n                if(shaFile != null){\n                    try{\n                        ArtifactContext sha1Context = context.getSha1Context();\n                        outputRepository.putArtifact(sha1Context, shaFile);\n                    }finally{\n                        shaFile.delete();\n                    }\n                }\n            }\n            \n            if (descriptorContext != null) {\n                outputRepository.putArtifact(descriptorContext, new File(descriptor));\n            }\n        }catch(CMRException x){\n            throw new ImportJarException(\"error.failedWriteArtifact\", new Object[]{context, x.getLocalizedMessage()}, x);\n        }catch(Exception x){\n            // FIXME: remove when the whole CMR is using CMRException\n            throw new ImportJarException(\"error.failedWriteArtifact\", new Object[]{context, x.getLocalizedMessage()}, x);\n        }\n    }","commit_id":"08007e3a576f46e8d8dbf2ef4deb625df4d3e4d6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public RepositoryManager getRepositoryManager() {\n        // caching\n        if(repoManager != null)\n            return repoManager;\n        // lazy loading\n\n        // any user defined repos\n        List<String> userRepos = new LinkedList<String>();\n        userRepos.addAll(options.getMulti(OptionName.CEYLONREPO));\n        String systemRepo = getSystemRepoOption();\n        String cacheRepo = getCacheRepoOption();\n        String outRepo = getOutputRepoOption();\n        \n        repoManager = CeylonUtils.repoManager()\n                .cwd(new File(getCurrentWorkingDir()))\n                .systemRepo(systemRepo)\n                .cacheRepo(cacheRepo)\n                .noDefaultRepos(getNoDefaultRepos())\n                .userRepos(userRepos)\n                .outRepo(outRepo)\n                .offline(getOfflineOption())\n                .logger(getLogger())\n                .buildManager();\n        \n        return repoManager;\n    }","id":31703,"modified_method":"public RepositoryManager getRepositoryManager() {\n        // caching\n        if(repoManager != null)\n            return repoManager;\n        // lazy loading\n\n        // any user defined repos\n        List<String> userRepos = new LinkedList<String>();\n        userRepos.addAll(options.getMulti(OptionName.CEYLONREPO));\n        String systemRepo = getSystemRepoOption();\n        String cacheRepo = getCacheRepoOption();\n        String outRepo = getOutputRepoOption();\n        \n        repoManager = CeylonUtils.repoManager()\n                .cwd(getCurrentWorkingDir())\n                .systemRepo(systemRepo)\n                .cacheRepo(cacheRepo)\n                .noDefaultRepos(getNoDefaultRepos())\n                .userRepos(userRepos)\n                .outRepo(outRepo)\n                .offline(getOfflineOption())\n                .logger(getLogger())\n                .buildManager();\n        \n        return repoManager;\n    }","commit_id":"08007e3a576f46e8d8dbf2ef4deb625df4d3e4d6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public RepositoryManager getOutputRepositoryManager() {\n        // caching\n        if(outputRepoManager != null)\n            return outputRepoManager;\n        // lazy loading\n\n        // any user defined repos\n        String outRepo = getOutputRepoOption();\n        \n        // username and password for WebDAV\n        String user = options.get(OptionName.CEYLONUSER);\n        String password = options.get(OptionName.CEYLONPASS);\n        \n        outputRepoManager = CeylonUtils.repoManager()\n                .cwd(new File(getCurrentWorkingDir()))\n                .outRepo(outRepo)\n                .logger(getLogger())\n                .user(user)\n                .password(password)\n                .buildOutputManager();\n        \n        return outputRepoManager;\n    }","id":31704,"modified_method":"public RepositoryManager getOutputRepositoryManager() {\n        // caching\n        if(outputRepoManager != null)\n            return outputRepoManager;\n        // lazy loading\n\n        // any user defined repos\n        String outRepo = getOutputRepoOption();\n        \n        // username and password for WebDAV\n        String user = options.get(OptionName.CEYLONUSER);\n        String password = options.get(OptionName.CEYLONPASS);\n        \n        outputRepoManager = CeylonUtils.repoManager()\n                .cwd(getCurrentWorkingDir())\n                .outRepo(outRepo)\n                .logger(getLogger())\n                .user(user)\n                .password(password)\n                .buildOutputManager();\n        \n        return outputRepoManager;\n    }","commit_id":"08007e3a576f46e8d8dbf2ef4deb625df4d3e4d6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected String getCurrentWorkingDir() {\n        return \".\";\n    }","id":31705,"modified_method":"protected String getCurrentWorkingDir() {\n        return options.get(OptionName.CEYLONCWD);\n    }","commit_id":"08007e3a576f46e8d8dbf2ef4deb625df4d3e4d6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static void main(String[] args) throws IOException {\n        String destDir = null;\n        List<String> sourceDirs = new LinkedList<String>();\n        boolean includeNonShared = false;\n        boolean includeSourceCode = false;\n        List<String> modules = new LinkedList<String>();\n        List<String> repositories = new LinkedList<String>();\n        String systemRepo = null;\n        String cacheRepo = null;\n        boolean noDefRepos = false;\n        String user = null, pass = null;\n        \n        for (int i = 0; i < args.length; i++) {\n            String arg = args[i];\n            int argsLeft = args.length - 1 - i;\n            if (\"-h\".equals(arg)\n                    || \"-help\".equals(arg)\n                    || \"--help\".equals(arg)) {\n                printUsage(SC_OK, systemRepo, cacheRepo, noDefRepos, repositories, destDir);\n            } else if (\"-v\".equals(arg)\n                        || \"-version\".equals(arg)\n                        || \"--version\".equals(arg)) {\n                printVersion();\n            } else if (\"-d\".equals(arg)) {\n                System.err.println(CeylondMessages.msg(\"error.optionDnotSupported\"));\n                exit(SC_ARGS);\n            } else if (\"-out\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                destDir = args[++i];\n            } else if (\"-src\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                sourceDirs.addAll(readPath(args[++i]));\n            } else if (\"-rep\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                repositories.add(args[++i]);\n            } else if (\"-sysrep\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                systemRepo = args[++i];\n            } else if (\"-cacherep\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                systemRepo = args[++i];\n            } else if (\"-nodefreps\".equals(arg)) {\n                noDefRepos = true;\n            } else if (\"-non-shared\".equals(arg)) {\n                includeNonShared = true;\n            } else if (\"-source-code\".equals(arg)) {\n                includeSourceCode = true;\n            } else if (\"-user\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                user = args[++i];\n            } else if (\"-pass\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                pass = args[++i];\n            } else if (arg.startsWith(\"-\")) {\n                System.err.println(CeylondMessages.msg(\"error.optionUnknown\", arg));\n                exit(SC_ARGS);\n            } else {\n                modules.add(arg);\n            }\n            \n        }\n        \n        if(modules.isEmpty()){\n            System.err.println(CeylondMessages.msg(\"error.noModulesSpecified\"));\n            printUsage(SC_ARGS, systemRepo, cacheRepo, noDefRepos, repositories, destDir);\n        }\n        if (destDir == null) {\n            destDir = \"modules\";\n        }\n\n        List<File> sourceFolders = new LinkedList<File>();\n        if (sourceDirs.isEmpty()) {\n            File src = new File(\"source\");\n            if(src.isDirectory())\n                sourceFolders.add(src);\n        }else{\n            for(String srcDir : sourceDirs){\n                File src = new File(srcDir);\n                if (!src.isDirectory()) {\n                    System.err.println(CeylondMessages.msg(\"error.noSuchSourceDirectory\", srcDir));\n                    exit(SC_ARGS);\n                }\n                sourceFolders.add(src);\n            }\n        }\n\n        try{\n            CeylonDocTool ceylonDocTool = new CeylonDocTool();\n            ceylonDocTool.setSourceFolders(sourceFolders);\n            ceylonDocTool.setRepositoryAsStrings(repositories);\n            ceylonDocTool.setModuleSpecs(modules);\n            ceylonDocTool.setHaltOnError(false);\n            ceylonDocTool.setOutputRepository(destDir, user, pass);\n            ceylonDocTool.setIncludeNonShared(includeNonShared);\n            ceylonDocTool.setIncludeSourceCode(includeSourceCode);\n            ceylonDocTool.init();\n            ceylonDocTool.makeDoc();\n        }catch(CeylondException x){\n            System.err.println(CeylondMessages.msg(\"error\", x.getLocalizedMessage()));\n            // no need to print the stack trace\n            exit(SC_ERROR);\n        }catch(Exception x){\n            System.err.println(CeylondMessages.msg(\"error\", x.getLocalizedMessage()));\n            x.printStackTrace();\n            exit(SC_ERROR);\n        }\n    }","id":31706,"modified_method":"public static void main(String[] args) throws IOException {\n        String destDir = null;\n        List<String> sourceDirs = new LinkedList<String>();\n        boolean includeNonShared = false;\n        boolean includeSourceCode = false;\n        List<String> modules = new LinkedList<String>();\n        List<String> repositories = new LinkedList<String>();\n        File cwd = new File(\".\");\n        String systemRepo = null;\n        String cacheRepo = null;\n        boolean noDefRepos = false;\n        String user = null, pass = null;\n        \n        for (int i = 0; i < args.length; i++) {\n            String arg = args[i];\n            int argsLeft = args.length - 1 - i;\n            if (\"-h\".equals(arg)\n                    || \"-help\".equals(arg)\n                    || \"--help\".equals(arg)) {\n                printUsage(SC_OK, cwd, systemRepo, cacheRepo, noDefRepos, repositories, destDir);\n            } else if (\"-v\".equals(arg)\n                        || \"-version\".equals(arg)\n                        || \"--version\".equals(arg)) {\n                printVersion();\n            } else if (\"-d\".equals(arg)) {\n                System.err.println(CeylondMessages.msg(\"error.optionDnotSupported\"));\n                exit(SC_ARGS);\n            } else if (\"-cwd\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                cwd = new File(args[++i]);\n            } else if (\"-out\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                destDir = args[++i];\n            } else if (\"-src\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                sourceDirs.addAll(readPath(args[++i]));\n            } else if (\"-rep\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                repositories.add(args[++i]);\n            } else if (\"-sysrep\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                systemRepo = args[++i];\n            } else if (\"-cacherep\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                systemRepo = args[++i];\n            } else if (\"-nodefreps\".equals(arg)) {\n                noDefRepos = true;\n            } else if (\"-non-shared\".equals(arg)) {\n                includeNonShared = true;\n            } else if (\"-source-code\".equals(arg)) {\n                includeSourceCode = true;\n            } else if (\"-user\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                user = args[++i];\n            } else if (\"-pass\".equals(arg)) {\n                if (argsLeft <= 0) {\n                    optionMissingArgument(arg);\n                }\n                pass = args[++i];\n            } else if (arg.startsWith(\"-\")) {\n                System.err.println(CeylondMessages.msg(\"error.optionUnknown\", arg));\n                exit(SC_ARGS);\n            } else {\n                modules.add(arg);\n            }\n            \n        }\n        \n        if(modules.isEmpty()){\n            System.err.println(CeylondMessages.msg(\"error.noModulesSpecified\"));\n            printUsage(SC_ARGS, cwd, systemRepo, cacheRepo, noDefRepos, repositories, destDir);\n        }\n        if (destDir == null) {\n            destDir = \"modules\";\n        }\n\n        List<File> sourceFolders = new LinkedList<File>();\n        if (sourceDirs.isEmpty()) {\n            File src = new File(\"source\");\n            if(src.isDirectory())\n                sourceFolders.add(src);\n        }else{\n            for(String srcDir : sourceDirs){\n                File src = new File(srcDir);\n                if (!src.isDirectory()) {\n                    System.err.println(CeylondMessages.msg(\"error.noSuchSourceDirectory\", srcDir));\n                    exit(SC_ARGS);\n                }\n                sourceFolders.add(src);\n            }\n        }\n\n        try{\n            CeylonDocTool ceylonDocTool = new CeylonDocTool();\n            ceylonDocTool.setSourceFolders(sourceFolders);\n            ceylonDocTool.setRepositoryAsStrings(repositories);\n            ceylonDocTool.setModuleSpecs(modules);\n            ceylonDocTool.setHaltOnError(false);\n            ceylonDocTool.setOutputRepository(destDir, user, pass);\n            ceylonDocTool.setIncludeNonShared(includeNonShared);\n            ceylonDocTool.setIncludeSourceCode(includeSourceCode);\n            ceylonDocTool.init();\n            ceylonDocTool.makeDoc();\n        }catch(CeylondException x){\n            System.err.println(CeylondMessages.msg(\"error\", x.getLocalizedMessage()));\n            // no need to print the stack trace\n            exit(SC_ERROR);\n        }catch(Exception x){\n            System.err.println(CeylondMessages.msg(\"error\", x.getLocalizedMessage()));\n            x.printStackTrace();\n            exit(SC_ERROR);\n        }\n    }","commit_id":"08007e3a576f46e8d8dbf2ef4deb625df4d3e4d6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private static void printUsage(int statusCode, String systemRepo, String cacheRepo, boolean noDefRepos, List<String> userRepos, String outputRepo) {\n        List<String> defaultRepositories = addDefaultRepositories(systemRepo, cacheRepo, noDefRepos, userRepos, null);\n        System.err.print(CeylondMessages.msg(\"info.usage1\"));\n        for(String repo : defaultRepositories) {\n            System.err.println(\"                        \"+repo);\n        }\n        System.err.print(CeylondMessages.msg(\"info.usage2\"));\n        exit(statusCode);\n    }","id":31707,"modified_method":"private static void printUsage(int statusCode, File cwd, String systemRepo, String cacheRepo, boolean noDefRepos, List<String> userRepos, String outputRepo) {\n        List<String> defaultRepositories = addDefaultRepositories(cwd, systemRepo, cacheRepo, noDefRepos, userRepos, null);\n        System.err.print(CeylondMessages.msg(\"info.usage1\"));\n        for(String repo : defaultRepositories) {\n            System.err.println(\"                        \"+repo);\n        }\n        System.err.print(CeylondMessages.msg(\"info.usage2\"));\n        exit(statusCode);\n    }","commit_id":"08007e3a576f46e8d8dbf2ef4deb625df4d3e4d6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private static List<String> addDefaultRepositories(String systemRepo, String cacheRepo, boolean noDefRepos, List<String> userRepos, String outputRepo){\n        RepositoryManagerBuilder builder = CeylonUtils.repoManager()\n                .systemRepo(systemRepo)\n                .cacheRepo(cacheRepo)\n                .noDefaultRepos(noDefRepos)\n                .userRepos(userRepos)\n                .outRepo(outputRepo)\n                .buildManagerBuilder();\n        return builder.getRepositoriesDisplayString();\n    }","id":31708,"modified_method":"private static List<String> addDefaultRepositories(File cwd, String systemRepo, String cacheRepo, boolean noDefRepos, List<String> userRepos, String outputRepo){\n        RepositoryManagerBuilder builder = CeylonUtils.repoManager()\n                .cwd(cwd)\n                .systemRepo(systemRepo)\n                .cacheRepo(cacheRepo)\n                .noDefaultRepos(noDefRepos)\n                .userRepos(userRepos)\n                .outRepo(outputRepo)\n                .buildManagerBuilder();\n        return builder.getRepositoriesDisplayString();\n    }","commit_id":"08007e3a576f46e8d8dbf2ef4deb625df4d3e4d6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public RepositoryManager getOutputRepositoryManager() {\n        // caching\n        if(outputRepoManager != null)\n            return outputRepoManager;\n        // lazy loading\n\n        // any user defined repos\n        String outRepo = getOutputRepoOption();\n        \n        // username and password for WebDAV\n        String user = options.get(OptionName.CEYLONUSER);\n        String password = options.get(OptionName.CEYLONPASS);\n        \n        outputRepoManager = CeylonUtils.repoManager()\n                .outRepo(outRepo)\n                .logger(getLogger())\n                .user(user)\n                .password(password)\n                .buildOutputManager();\n        \n        return outputRepoManager;\n    }","id":31709,"modified_method":"public RepositoryManager getOutputRepositoryManager() {\n        // caching\n        if(outputRepoManager != null)\n            return outputRepoManager;\n        // lazy loading\n\n        // any user defined repos\n        String outRepo = getOutputRepoOption();\n        \n        // username and password for WebDAV\n        String user = options.get(OptionName.CEYLONUSER);\n        String password = options.get(OptionName.CEYLONPASS);\n        \n        outputRepoManager = CeylonUtils.repoManager()\n                .cwd(new File(getCurrentWorkingDir()))\n                .outRepo(outRepo)\n                .logger(getLogger())\n                .user(user)\n                .password(password)\n                .buildOutputManager();\n        \n        return outputRepoManager;\n    }","commit_id":"11e27ea377b75cf5c77912163173a821d3db06c8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public RepositoryManager getRepositoryManager() {\n        // caching\n        if(repoManager != null)\n            return repoManager;\n        // lazy loading\n\n        // any user defined repos\n        List<String> userRepos = new LinkedList<String>();\n        userRepos.addAll(options.getMulti(OptionName.CEYLONREPO));\n        String systemRepo = getSystemRepoOption();\n        String outRepo = getOutputRepoOption();\n        \n        repoManager = CeylonUtils.repoManager()\n                .systemRepo(systemRepo)\n                .userRepos(userRepos)\n                .outRepo(outRepo)\n                .logger(getLogger())\n                .buildManager();\n        \n        return repoManager;\n    }","id":31710,"modified_method":"public RepositoryManager getRepositoryManager() {\n        // caching\n        if(repoManager != null)\n            return repoManager;\n        // lazy loading\n\n        // any user defined repos\n        List<String> userRepos = new LinkedList<String>();\n        userRepos.addAll(options.getMulti(OptionName.CEYLONREPO));\n        String systemRepo = getSystemRepoOption();\n        String outRepo = getOutputRepoOption();\n        \n        repoManager = CeylonUtils.repoManager()\n                .cwd(new File(getCurrentWorkingDir()))\n                .systemRepo(systemRepo)\n                .userRepos(userRepos)\n                .outRepo(outRepo)\n                .logger(getLogger())\n                .buildManager();\n        \n        return repoManager;\n    }","commit_id":"11e27ea377b75cf5c77912163173a821d3db06c8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public synchronized void undeploy() throws ExecutionException, InterruptedException {\n        DeploymentPlanBuilder builder = manager.newDeploymentPlan();\n        for (AbstractDeployment deployment : deployments) {\n            builder = deployment.removeDeployment(builder);\n        }\n        DeploymentPlan plan = builder.build();\n        if (plan.getDeploymentActions().size() > 0) {\n            manager.execute(builder.build()).get();\n        }\n    }","id":31711,"modified_method":"public synchronized void undeploy() throws ExecutionException, InterruptedException, TimeoutException {\n        DeploymentPlanBuilder builder = manager.newDeploymentPlan();\n        for (AbstractDeployment deployment : deployments) {\n            builder = deployment.removeDeployment(builder);\n        }\n        DeploymentPlan plan = builder.build();\n        if (plan.getDeploymentActions().size() > 0) {\n            manager.execute(builder.build()).get(timeout, TimeUnit.MILLISECONDS);\n        }\n    }","commit_id":"bff83eb155666a57225888e582b8ad6af7bc8b99","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void deploy()  throws DuplicateDeploymentNameException, IOException, ExecutionException, InterruptedException  {\n        DeploymentPlanBuilder builder = manager.newDeploymentPlan();\n        for (AbstractDeployment deployment : deployments) {\n            builder = deployment.addDeployment(manager, builder);\n        }\n        try {\n            manager.execute(builder.build()).get();\n        } finally {\n            for (AbstractDeployment deployment : deployments) {\n                deployment.deployed = true;\n            }\n        }\n    }","id":31712,"modified_method":"public synchronized void deploy()  throws DuplicateDeploymentNameException, IOException, ExecutionException, InterruptedException, TimeoutException  {\n        DeploymentPlanBuilder builder = manager.newDeploymentPlan().withRollback();\n        for (AbstractDeployment deployment : deployments) {\n            builder = deployment.addDeployment(manager, builder);\n        }\n\n        try {\n            manager.execute(builder.build()).get(timeout, TimeUnit.MILLISECONDS);\n        } finally {\n            markDeploymentsDeployed();\n        }\n    }","commit_id":"bff83eb155666a57225888e582b8ad6af7bc8b99","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void undeploy(Context context, Archive<?> archive) throws DeploymentException {\n        String runtimeName = registry.remove(archive);\n        if (runtimeName != null) {\n            try {\n                DeploymentPlanBuilder builder = deploymentManager.newDeploymentPlan();\n                DeploymentPlan plan = builder.undeploy(runtimeName).remove(runtimeName).build();\n                Future<ServerDeploymentPlanResult> future = deploymentManager.execute(plan);\n                future.get();\n            } catch (Exception ex) {\n                log.warning(\"Cannot undeploy: \" + runtimeName + \":\" + ex.getMessage());\n            }\n        }\n    }","id":31713,"modified_method":"@Override\n    public void undeploy(Context context, Archive<?> archive) throws DeploymentException {\n        String runtimeName = registry.remove(archive);\n        if (runtimeName != null) {\n            try {\n                DeploymentPlanBuilder builder = deploymentManager.newDeploymentPlan().withRollback();\n                DeploymentPlan plan = builder.undeploy(runtimeName).remove(runtimeName).build();\n                Future<ServerDeploymentPlanResult> future = deploymentManager.execute(plan);\n                future.get();\n            } catch (Exception ex) {\n                log.warning(\"Cannot undeploy: \" + runtimeName + \":\" + ex.getMessage());\n            }\n        }\n    }","commit_id":"5431043cc0a7d9f1e6b18bdd6a001233d0c64822","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ContainerMethodExecutor deploy(Context context, Archive<?> archive) throws DeploymentException {\n        try {\n            InputStream input = archive.as(ZipExporter.class).exportZip();\n            DeploymentPlanBuilder builder = deploymentManager.newDeploymentPlan();\n            builder = builder.add(archive.getName(), input).andDeploy();\n            DeploymentPlan plan = builder.build();\n            DeploymentAction deployAction = builder.getLastAction();\n            executeDeploymentPlan(plan, deployAction,archive);\n\n            return getContainerMethodExecutor(context);\n        } catch (Exception e) {\n            throw new DeploymentException(\"Could not deploy to container\", e);\n        }\n    }","id":31714,"modified_method":"@Override\n    public ContainerMethodExecutor deploy(Context context, Archive<?> archive) throws DeploymentException {\n        try {\n            InputStream input = archive.as(ZipExporter.class).exportZip();\n            DeploymentPlanBuilder builder = deploymentManager.newDeploymentPlan().withRollback();\n            builder = builder.add(archive.getName(), input).andDeploy();\n            DeploymentPlan plan = builder.build();\n            DeploymentAction deployAction = builder.getLastAction();\n            executeDeploymentPlan(plan, deployAction,archive);\n\n            return getContainerMethodExecutor(context);\n        } catch (Exception e) {\n            throw new DeploymentException(\"Could not deploy to container\", e);\n        }\n    }","commit_id":"5431043cc0a7d9f1e6b18bdd6a001233d0c64822","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeploymentStreamApi() throws Exception {\n        final JavaArchive archive = ShrinkWrapUtils.createJavaArchive(\"servermodule/test-deployment.sar\", Simple.class.getPackage());\n        final ServerDeploymentManager manager = ServerDeploymentManager.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n\n        testDeployments(new DeploymentExecutor() {\n\n            @Override\n            public void initialDeploy() {\n                manager.execute(manager.newDeploymentPlan().add(\"test-deployment.sar\", archive.as(ZipExporter.class).exportZip()).deploy(\"test-deployment.sar\").build());\n            }\n\n            @Override\n            public void fullReplace() {\n                manager.execute(manager.newDeploymentPlan().replace(\"test-deployment.sar\", archive.as(ZipExporter.class).exportZip()).build());\n            }\n\n            @Override\n            public void undeploy() {\n                manager.execute(manager.newDeploymentPlan().undeploy(\"test-deployment.sar\").remove(\"test-deployment.sar\").build());\n            }\n        });\n    }","id":31715,"modified_method":"@Test\n    public void testDeploymentStreamApi() throws Exception {\n        final JavaArchive archive = ShrinkWrapUtils.createJavaArchive(\"servermodule/test-deployment.sar\", Simple.class.getPackage());\n        final ServerDeploymentManager manager = ServerDeploymentManager.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n\n        testDeployments(new DeploymentExecutor() {\n\n            @Override\n            public void initialDeploy() {\n                manager.execute(manager.newDeploymentPlan().withRollback().add(\"test-deployment.sar\", archive.as(ZipExporter.class).exportZip()).deploy(\"test-deployment.sar\").build());\n            }\n\n            @Override\n            public void fullReplace() {\n                manager.execute(manager.newDeploymentPlan().withRollback().replace(\"test-deployment.sar\", archive.as(ZipExporter.class).exportZip()).build());\n            }\n\n            @Override\n            public void undeploy() {\n                manager.execute(manager.newDeploymentPlan().withRollback().undeploy(\"test-deployment.sar\").remove(\"test-deployment.sar\").build());\n            }\n        });\n    }","commit_id":"5431043cc0a7d9f1e6b18bdd6a001233d0c64822","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeploymentFileApi() throws Exception {\n        final JavaArchive archive = ShrinkWrapUtils.createJavaArchive(\"servermodule/test-deployment.sar\", Simple.class.getPackage());\n        final ServerDeploymentManager manager = ServerDeploymentManager.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n        final File dir = new File(\"target/archives\");\n        dir.mkdirs();\n        final File file = new File(dir, \"test-deployment.sar\");\n        archive.as(ZipExporter.class).exportZip(file, true);\n\n        testDeployments(new DeploymentExecutor() {\n\n            @Override\n            public void initialDeploy() throws IOException{\n                manager.execute(manager.newDeploymentPlan().add(\"test-deployment.sar\", file).deploy(\"test-deployment.sar\").build());\n            }\n\n            @Override\n            public void fullReplace() throws IOException {\n                manager.execute(manager.newDeploymentPlan().replace(\"test-deployment.sar\", file).build());\n            }\n\n            @Override\n            public void undeploy() {\n                manager.execute(manager.newDeploymentPlan().undeploy(\"test-deployment.sar\").remove(\"test-deployment.sar\").build());\n            }\n        });\n    }","id":31716,"modified_method":"@Test\n    public void testDeploymentFileApi() throws Exception {\n        final JavaArchive archive = ShrinkWrapUtils.createJavaArchive(\"servermodule/test-deployment.sar\", Simple.class.getPackage());\n        final ServerDeploymentManager manager = ServerDeploymentManager.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n        final File dir = new File(\"target/archives\");\n        dir.mkdirs();\n        final File file = new File(dir, \"test-deployment.sar\");\n        archive.as(ZipExporter.class).exportZip(file, true);\n\n        testDeployments(new DeploymentExecutor() {\n\n            @Override\n            public void initialDeploy() throws IOException{\n                manager.execute(manager.newDeploymentPlan().withRollback().add(\"test-deployment.sar\", file).deploy(\"test-deployment.sar\").build());\n            }\n\n            @Override\n            public void fullReplace() throws IOException {\n                manager.execute(manager.newDeploymentPlan().withRollback().replace(\"test-deployment.sar\", file).build());\n            }\n\n            @Override\n            public void undeploy() {\n                manager.execute(manager.newDeploymentPlan().withRollback().undeploy(\"test-deployment.sar\").remove(\"test-deployment.sar\").build());\n            }\n        });\n    }","commit_id":"5431043cc0a7d9f1e6b18bdd6a001233d0c64822","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final URL archiveURL) throws Exception {\n        final DeploymentPlanBuilder builder = deploymentManager.newDeploymentPlan().add(archiveURL).andDeploy();\n        final DeploymentPlan plan = builder.build();\n        final DeploymentAction deployAction = builder.getLastAction();\n        final String uniqueId = deployAction.getDeploymentUnitUniqueName();\n        try {\n            executeDeploymentPlan(plan, deployAction);\n        } finally {\n            url2Id.put(archiveURL, uniqueId);\n        }\n    }","id":31717,"modified_method":"@Override\n    public void deploy(final URL archiveURL) throws Exception {\n        final DeploymentPlanBuilder builder = deploymentManager.newDeploymentPlan().withRollback().add(archiveURL).andDeploy();\n        final DeploymentPlan plan = builder.build();\n        final DeploymentAction deployAction = builder.getLastAction();\n        final String uniqueId = deployAction.getDeploymentUnitUniqueName();\n        try {\n            executeDeploymentPlan(plan, deployAction);\n        } finally {\n            url2Id.put(archiveURL, uniqueId);\n        }\n    }","commit_id":"64493833398dd2975b92e31ff0ed44cbf8e4a020","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void exceptionCaught(MsnMessenger msnMessenger, Throwable throwable)\n        {\n            if(throwable instanceof IncorrectPasswordException)\n                fireRegistrationStateChanged(\n                    getRegistrationState(),\n                    RegistrationState.UNREGISTERED,\n                    RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED,\n                    \"Incorrect Password\");\n            else\n            {\n                logger.error(\"Error in Msn lib \", throwable);\n\n                fireRegistrationStateChanged(\n                    getRegistrationState(),\n                    RegistrationState.UNREGISTERED,\n                    RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n            }\n        }","id":31718,"modified_method":"public void exceptionCaught(MsnMessenger msnMessenger, Throwable throwable)\n        {\n            if(throwable instanceof IncorrectPasswordException)\n                fireRegistrationStateChanged(\n                    getRegistrationState(),\n                    RegistrationState.UNREGISTERED,\n                    RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED,\n                    \"Incorrect Password\");\n            else\n            {\n                logger.error(\"Error in Msn lib \", throwable);\n\n                if(isRegistered())\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.UNREGISTERED,\n                        RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n            }\n        }","commit_id":"f77e2321017c6af9ce8690ea6e52989e84a7136d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a RegistrationStateChange event corresponding to the specified\n     * old and new states and notifies all currently registered listeners.\n     *\n     * @param oldState the state that the provider had before the change\n     * occurred\n     * @param newState the state that the provider is currently in.\n     * @param reasonCode a value corresponding to one of the REASON_XXX fields\n     * of the RegistrationStateChangeEvent class, indicating the reason for\n     * this state transition.\n     * @param reason a String further explaining the reason code or null if\n     * no such explanation is necessary.\n     */\n    void fireRegistrationStateChanged( RegistrationState oldState,\n                                               RegistrationState newState,\n                                               int               reasonCode,\n                                               String            reason)\n    {\n        RegistrationStateChangeEvent event =\n            new RegistrationStateChangeEvent(\n                            this, oldState, newState, reasonCode, reason);\n\n        logger.debug(\"Dispatching \" + event + \" to \"\n                     + registrationListeners.size()+ \" listeners.\");\n\n        Iterator listeners = null;\n        synchronized (registrationListeners)\n        {\n            listeners = new ArrayList(registrationListeners).iterator();\n        }\n\n        while (listeners.hasNext())\n        {\n            RegistrationStateChangeListener listener\n                = (RegistrationStateChangeListener) listeners.next();\n\n            listener.registrationStateChanged(event);\n        }\n\n        logger.trace(\"Done.\");\n    }","id":31719,"modified_method":"/**\n     * Creates a RegistrationStateChange event corresponding to the specified\n     * old and new states and notifies all currently registered listeners.\n     *\n     * @param oldState the state that the provider had before the change\n     * occurred\n     * @param newState the state that the provider is currently in.\n     * @param reasonCode a value corresponding to one of the REASON_XXX fields\n     * of the RegistrationStateChangeEvent class, indicating the reason for\n     * this state transition.\n     * @param reason a String further explaining the reason code or null if\n     * no such explanation is necessary.\n     */\n    void fireRegistrationStateChanged( RegistrationState oldState,\n                                               RegistrationState newState,\n                                               int               reasonCode,\n                                               String            reason)\n    {\n        RegistrationStateChangeEvent event =\n            new RegistrationStateChangeEvent(\n                            this, oldState, newState, reasonCode, reason);\n\n        logger.debug(\"Dispatching \" + event + \" to \"\n                     + registrationListeners.size()+ \" listeners.\");\n\n        if(newState.equals(RegistrationState.UNREGISTERED))\n            messenger = null;\n\n        Iterator listeners = null;\n        synchronized (registrationListeners)\n        {\n            listeners = new ArrayList(registrationListeners).iterator();\n        }\n\n        while (listeners.hasNext())\n        {\n            RegistrationStateChangeListener listener\n                = (RegistrationStateChangeListener) listeners.next();\n\n            listener.registrationStateChanged(event);\n        }\n\n        logger.trace(\"Done.\");\n    }","commit_id":"f77e2321017c6af9ce8690ea6e52989e84a7136d","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void logout(MsnMessenger msnMessenger)\n        {\n            logger.trace(\"logout\");\n            fireRegistrationStateChanged(\n                getRegistrationState(),\n                RegistrationState.UNREGISTERED,\n                RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n\n        }","id":31720,"modified_method":"public void logout(MsnMessenger msnMessenger)\n        {\n            logger.trace(\"logout\");\n\n            if(isRegistered())\n                fireRegistrationStateChanged(\n                    getRegistrationState(),\n                    RegistrationState.UNREGISTERED,\n                    RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n\n        }","commit_id":"f77e2321017c6af9ce8690ea6e52989e84a7136d","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void logout(MsnMessenger msnMessenger)\n        {\n            logger.trace(\"logout\");\n\n            if(isRegistered())\n                fireRegistrationStateChanged(\n                    getRegistrationState(),\n                    RegistrationState.UNREGISTERED,\n                    RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n\n        }","id":31721,"modified_method":"public void logout(MsnMessenger msnMessenger)\n        {\n            logger.trace(\"logout\");\n\n//            if(isRegistered())\n//                fireRegistrationStateChanged(\n//                    getRegistrationState(),\n//                    RegistrationState.UNREGISTERED,\n//                    RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n\n        }","commit_id":"f93f2f8e6dc049f780e414bc0a7429f75825821e","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void exceptionCaught(MsnMessenger msnMessenger, Throwable throwable)\n        {\n            if(throwable instanceof IncorrectPasswordException)\n                fireRegistrationStateChanged(\n                    getRegistrationState(),\n                    RegistrationState.UNREGISTERED,\n                    RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED,\n                    \"Incorrect Password\");\n            else\n            {\n                logger.error(\"Error in Msn lib \", throwable);\n\n                if(isRegistered())\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.UNREGISTERED,\n                        RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n            }\n        }","id":31722,"modified_method":"public void exceptionCaught(MsnMessenger msnMessenger, Throwable throwable)\n        {\n            if(throwable instanceof IncorrectPasswordException)\n                fireRegistrationStateChanged(\n                    getRegistrationState(),\n                    RegistrationState.UNREGISTERED,\n                    RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED,\n                    \"Incorrect Password\");\n            else\n            {\n                if(throwable instanceof MsnProtocolException)\n                {\n                    MsnProtocolException exception =\n                        (MsnProtocolException)throwable;\n\n\n                    logger.error(\"Error in Msn lib \", exception);\n\n                    switch(exception.getErrorCode())\n                    {\n                        case 500:\n                        case 540:\n                        case 601:\n                            if(isRegistered())\n                            {\n                                unregister(false);\n                                fireRegistrationStateChanged(\n                                    getRegistrationState(),\n                                    RegistrationState.UNREGISTERED,\n                                    RegistrationStateChangeEvent.\n                                    REASON_INTERNAL_ERROR, null);\n                            }\n                            break;\n                        case 911:\n                            if(isRegistered())\n                            {\n                                unregister(false);\n                                fireRegistrationStateChanged(\n                                    getRegistrationState(),\n                                    RegistrationState.UNREGISTERED,\n                                    RegistrationStateChangeEvent.\n                                    REASON_AUTHENTICATION_FAILED, null);\n                            }\n                            break;\n                    }\n\n                    return;\n                }\n\n                logger.error(\"Error in Msn lib \", throwable);\n\n                if(isRegistered())\n                {\n                    unregister(false);\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.UNREGISTERED,\n                        RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n                }\n            }\n        }","commit_id":"f93f2f8e6dc049f780e414bc0a7429f75825821e","url":"https://github.com/jitsi/jitsi"},{"original_method":"public DocumentWindowImpl(@NotNull DocumentEx delegate,\n                        boolean oneLine,\n                        @NotNull List<String> prefixes,\n                        @NotNull List<String> suffixes,\n                        @NotNull List<TextRange> ranges) {\n    myDelegate = delegate;\n    myOneLine = oneLine;\n    myPrefixes = prefixes.toArray(new String[prefixes.size()]);\n    mySuffixes = suffixes.toArray(new String[suffixes.size()]);\n    myRelevantRangesInHostDocument = new RangeMarker[ranges.size()];\n    assert myPrefixes.length == mySuffixes.length : prefixes + \" \" + suffixes + \" \" + ranges;\n    assert myPrefixes.length == myRelevantRangesInHostDocument.length : prefixes + \" \" + suffixes + \" \" + ranges;\n    for (int i = 0; i < ranges.size(); i++) {\n      TextRange range = ranges.get(i);\n      RangeMarker rangeMarker = delegate.createRangeMarker(range);\n      rangeMarker.setGreedyToLeft(true);\n      rangeMarker.setGreedyToRight(true);\n      myRelevantRangesInHostDocument[i] = rangeMarker;\n    }\n    myPrefixLineCount = Math.max(1, countLineSeparators(myPrefixes[0]));\n    mySuffixLineCount = Math.max(1, countLineSeparators(mySuffixes[mySuffixes.length-1]));\n  }","id":31723,"modified_method":"public DocumentWindowImpl(@NotNull DocumentEx delegate,\n                        boolean oneLine,\n                        @NotNull List<String> prefixes,\n                        @NotNull List<String> suffixes,\n                        @NotNull List<TextRange> ranges) {\n    myDelegate = delegate;\n    myOneLine = oneLine;\n    myPrefixes = prefixes.toArray(new String[prefixes.size()]);\n    mySuffixes = suffixes.toArray(new String[suffixes.size()]);\n    myRelevantRangesInHostDocument = new RangeMarker[ranges.size()];\n    assert myPrefixes.length == mySuffixes.length : prefixes + \" \" + suffixes + \" \" + ranges;\n    assert myPrefixes.length == myRelevantRangesInHostDocument.length : prefixes + \" \" + suffixes + \" \" + ranges;\n    for (int i = 0; i < ranges.size(); i++) {\n      TextRange range = ranges.get(i);\n      RangeMarker rangeMarker = delegate.createRangeMarker(range);\n      rangeMarker.setGreedyToLeft(true);\n      rangeMarker.setGreedyToRight(true);\n      myRelevantRangesInHostDocument[i] = rangeMarker;\n    }\n    myPrefixLineCount = Math.max(1, 1 + StringUtil.countNewLines(myPrefixes[0]));\n    mySuffixLineCount = Math.max(1, 1 + StringUtil.countNewLines(mySuffixes[mySuffixes.length - 1]));\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getLineCount() {\n    return countLineSeparators(getText());\n  }","id":31724,"modified_method":"public int getLineCount() {\n    return 1 + StringUtil.countNewLines(getText());\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public TextRange intersectWithEditable(@NotNull TextRange rangeToEdit) {\n    int offset = 0;\n    int startOffset = -1;\n    int endOffset = -1;\n    for (int i = 0; i < myRelevantRangesInHostDocument.length; i++) {\n      RangeMarker hostRange = myRelevantRangesInHostDocument[i];\n      offset += myPrefixes[i].length();\n      int length = hostRange.getEndOffset() - hostRange.getStartOffset();\n      TextRange intersection = new TextRange(offset, offset + length).intersection(rangeToEdit);\n      if (intersection != null) {\n        if (startOffset == -1) {\n          startOffset = intersection.getStartOffset();\n        }\n        endOffset = intersection.getEndOffset();\n      }\n      offset += length;\n      offset += mySuffixes[i].length();\n    }\n    if (startOffset == -1) return null;\n    return new TextRange(startOffset, endOffset);\n  }","id":31725,"modified_method":"@Nullable\n  public TextRange intersectWithEditable(@NotNull TextRange rangeToEdit) {\n    int offset = 0;\n    int startOffset = -1;\n    int endOffset = -1;\n    for (int i = 0; i < myRelevantRangesInHostDocument.length; i++) {\n      RangeMarker hostRange = myRelevantRangesInHostDocument[i];\n      offset += myPrefixes[i].length();\n      int length = hostRange.getEndOffset() - hostRange.getStartOffset();\n      TextRange intersection = new ProperTextRange(offset, offset + length).intersection(rangeToEdit);\n      if (intersection != null) {\n        if (startOffset == -1) {\n          startOffset = intersection.getStartOffset();\n        }\n        endOffset = intersection.getEndOffset();\n      }\n      offset += length;\n      offset += mySuffixes[i].length();\n    }\n    if (startOffset == -1) return null;\n    return new ProperTextRange(startOffset, endOffset);\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RangeMarker createGuardedBlock(final int startOffset, final int endOffset) {\n    TextRange hostRange = injectedToHost(new TextRange(startOffset, endOffset));\n    return myDelegate.createGuardedBlock(hostRange.getStartOffset(), hostRange.getEndOffset());\n  }","id":31726,"modified_method":"public RangeMarker createGuardedBlock(final int startOffset, final int endOffset) {\n    TextRange hostRange = injectedToHost(new ProperTextRange(startOffset, endOffset));\n    return myDelegate.createGuardedBlock(hostRange.getStartOffset(), hostRange.getEndOffset());\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RangeMarker createRangeMarker(final int startOffset, final int endOffset) {\n    assert startOffset <= endOffset;\n    TextRange hostRange = injectedToHost(new TextRange(startOffset, endOffset));\n    RangeMarker hostMarker = myDelegate.createRangeMarker(hostRange);\n    return new RangeMarkerWindow(this, (RangeMarkerEx)hostMarker);\n  }","id":31727,"modified_method":"public RangeMarker createRangeMarker(final int startOffset, final int endOffset) {\n    assert startOffset <= endOffset;\n    TextRange hostRange = injectedToHost(new ProperTextRange(startOffset, endOffset));\n    RangeMarker hostMarker = myDelegate.createRangeMarker(hostRange);\n    return new RangeMarkerWindow(this, (RangeMarkerEx)hostMarker);\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RangeMarker createRangeMarker(final int startOffset, final int endOffset, final boolean surviveOnExternalChange) {\n    if (!surviveOnExternalChange) {\n      return createRangeMarker(startOffset, endOffset);\n    }\n    TextRange hostRange = injectedToHost(new TextRange(startOffset, endOffset));\n    //todo persistent?\n    return myDelegate.createRangeMarker(hostRange.getStartOffset(), hostRange.getEndOffset(), surviveOnExternalChange);\n  }","id":31728,"modified_method":"public RangeMarker createRangeMarker(final int startOffset, final int endOffset, final boolean surviveOnExternalChange) {\n    if (!surviveOnExternalChange) {\n      return createRangeMarker(startOffset, endOffset);\n    }\n    TextRange hostRange = injectedToHost(new ProperTextRange(startOffset, endOffset));\n    //todo persistent?\n    return myDelegate.createRangeMarker(hostRange.getStartOffset(), hostRange.getEndOffset(), surviveOnExternalChange);\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean containsRange(int start, int end) {\n    if (end - start > myRelevantRangesInHostDocument[0].getEndOffset() - myRelevantRangesInHostDocument[0].getStartOffset()) return false;\n    for (RangeMarker hostRange : myRelevantRangesInHostDocument) {\n      if (InjectedLanguageUtil.toTextRange(hostRange).contains(new TextRange(start, end))) return true;\n    }\n    return false;\n  }","id":31729,"modified_method":"public boolean containsRange(int start, int end) {\n    if (end - start > myRelevantRangesInHostDocument[0].getEndOffset() - myRelevantRangesInHostDocument[0].getStartOffset()) return false;\n    for (RangeMarker hostRange : myRelevantRangesInHostDocument) {\n      if (InjectedLanguageUtil.toTextRange(hostRange).contains(new ProperTextRange(start, end))) return true;\n    }\n    return false;\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TextRange injectedToHost(TextRange injected) {\n    return new TextRange(injectedToHost(injected.getStartOffset()), injectedToHost(injected.getEndOffset(), false));\n  }","id":31730,"modified_method":"public TextRange injectedToHost(TextRange injected) {\n    return new ProperTextRange(injectedToHost(injected.getStartOffset()), injectedToHost(injected.getEndOffset(), false));\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RangeMarker getRangeGuard(final int startOffset, final int endOffset) {\n    TextRange hostRange = injectedToHost(new TextRange(startOffset, endOffset));\n\n    return myDelegate.getRangeGuard(hostRange.getStartOffset(), hostRange.getEndOffset());\n  }","id":31731,"modified_method":"public RangeMarker getRangeGuard(final int startOffset, final int endOffset) {\n    TextRange hostRange = injectedToHost(new ProperTextRange(startOffset, endOffset));\n\n    return myDelegate.getRangeGuard(hostRange.getStartOffset(), hostRange.getEndOffset());\n  }","commit_id":"0ed0dc2d272cd56768973632b135eff753460d54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected MachineProvisioningLocation<T> firstSubLoc() {\n        return (MachineProvisioningLocation<T>) Iterables.get(getRequiredConfig(SUB_LOCATIONS), 0);\n    }","id":31732,"modified_method":"@SuppressWarnings(\"unchecked\")\n    protected MachineProvisioningLocation<T> firstSubLoc() {\n        return (MachineProvisioningLocation<T>) Iterables.get(getSubLocations(), 0);\n    }","commit_id":"df6f3a3fe1755a79b37a3c576a9d285ff827d272","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void release(T machine) {\n        MachineProvisioningLocation<T> subLoc = firstSubLoc();\n        subLoc.release(machine);\n    }","id":31733,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public void release(T machine) {\n        ((MachineProvisioningLocation<T>)machine.getParent()).release(machine);\n    }","commit_id":"df6f3a3fe1755a79b37a3c576a9d285ff827d272","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void init() {\n        super.init();\n        List<MachineProvisioningLocation<?>> subLocs = getRequiredConfig(SUB_LOCATIONS);\n        checkState(subLocs.size() >= 1, \"sub-locations must not be empty\");\n        AvailabilityZoneExtension azExtension = new AvailabilityZoneExtensionImpl(getManagementContext(), subLocs);\n        addExtension(AvailabilityZoneExtension.class, azExtension);\n    }","id":31734,"modified_method":"@Override\n    public void init() {\n        super.init();\n        List<MachineProvisioningLocation<?>> subLocs = getSubLocations();\n        checkState(subLocs.size() >= 1, \"sub-locations must not be empty\");\n        AvailabilityZoneExtension azExtension = new AvailabilityZoneExtensionImpl(getManagementContext(), subLocs);\n        addExtension(AvailabilityZoneExtension.class, azExtension);\n    }","commit_id":"df6f3a3fe1755a79b37a3c576a9d285ff827d272","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** finds (creates) and returns a {@link MachineLocation}; \n     * currently this only looks at the first sub-location, though that behaviour may change without notice.\n     * (if you want striping across locations, see notes in {@link AvailabilityZoneExtension}.) */\n    // TODO Could have multiLoc.obtain delegate to loc2 if loc1 has no capacity\n    @Override\n    public T obtain(Map<?, ?> flags) throws NoMachinesAvailableException {\n        return firstSubLoc().obtain(flags);\n    }","id":31735,"modified_method":"/** finds (creates) and returns a {@link MachineLocation}; \n     * this always tries the first sub-location, moving on the second and subsequent if the first throws {@link NoMachinesAvailableException}.\n     * (if you want striping across locations, see notes in {@link AvailabilityZoneExtension}.) */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T obtain(Map<?, ?> flags) throws NoMachinesAvailableException {\n        List<MachineProvisioningLocation<?>> sublocsList = getSubLocations();\n        Iterator<MachineProvisioningLocation<?>> sublocs = sublocsList.iterator();\n        List<NoMachinesAvailableException> errors = MutableList.of();\n        while (sublocs.hasNext()) {\n            try {\n                return (T) sublocs.next().obtain(flags);\n            } catch (NoMachinesAvailableException e) {\n                errors.add(e);\n            }\n        }\n        Exception wrapped;\n        String msg;\n        if (errors.size()>1) {\n            wrapped = new CompoundRuntimeException(errors.size()+\" sublocation exceptions, including: \"+\n                Exceptions.collapseText(errors.get(0)), errors);\n            msg = Exceptions.collapseText(wrapped);\n        } else if (errors.size()==1) {\n            wrapped = errors.get(0);\n            msg = wrapped.getMessage();\n            if (Strings.isBlank(msg)) msg = wrapped.toString();\n        } else {\n            msg = \"no sub-locations set for this multi-location\";\n            wrapped = null;\n        }\n        throw new NoMachinesAvailableException(\"No machines available in any of the \"+sublocsList.size()+\" location\"+Strings.s(sublocsList.size())+\n            \" configured here: \"+msg, wrapped);\n    }","commit_id":"df6f3a3fe1755a79b37a3c576a9d285ff827d272","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public Location newLocationFromString(Map locationFlags, String spec, brooklyn.location.LocationRegistry registry) {\n        // FIXME pass all flags into the location\n        \n        Map globalProperties = registry.getProperties();\n        Matcher matcher = PATTERN.matcher(spec);\n        if (!matcher.matches()) {\n            throw new IllegalArgumentException(\"Invalid location '\" + spec + \"'; must specify something like multi(targets=named:foo)\");\n        }\n        \n        String namedLocation = (String) locationFlags.get(\"named\");\n        String args = matcher.group(2);\n        Map<String,?> locationArgs = KeyValueParser.parseMap(args);\n\n        Map<String, Object> filteredProperties = new LocationPropertiesFromBrooklynProperties().getLocationProperties(null, namedLocation, globalProperties);\n        MutableMap<String, Object> flags = MutableMap.<String, Object>builder()\n                .putAll(filteredProperties)\n                .putAll(locationFlags)\n                .removeAll(\"named\")\n                .putAll(locationArgs).build();\n        \n        if (locationArgs.get(\"targets\") == null) {\n            throw new IllegalArgumentException(\"target must be specified in single-machine spec\");\n        }\n        String targetSpecs = locationArgs.get(\"targets\").toString();\n        locationArgs.remove(\"targets\");\n        \n        List<Location> targets = Lists.newArrayList();\n        for (String targetSpec : JavaStringEscapes.unwrapJsonishListIfPossible(targetSpecs)) {\n            targets.add(managementContext.getLocationRegistry().resolve(targetSpec));\n        }\n        \n        return managementContext.getLocationManager().createLocation(LocationSpec.create(MultiLocation.class)\n                .configure(flags)\n                .configure(\"subLocations\", targets)\n                .configure(LocationConfigUtils.finalAndOriginalSpecs(spec, locationFlags, globalProperties, namedLocation)));\n    }","id":31736,"modified_method":"@Override\n    public Location newLocationFromString(Map locationFlags, String spec, brooklyn.location.LocationRegistry registry) {\n        // FIXME pass all flags into the location\n        \n        Map globalProperties = registry.getProperties();\n        Map<String,?> locationArgs;\n        if (spec.equalsIgnoreCase(MULTI)) {\n            locationArgs = MutableMap.copyOf(locationFlags);\n        } else {\n            Matcher matcher = PATTERN.matcher(spec);\n            if (!matcher.matches()) {\n                throw new IllegalArgumentException(\"Invalid location '\" + spec + \"'; must specify something like multi(targets=named:foo)\");\n            }\n            String args = matcher.group(2);\n            // TODO we are ignoring locationFlags after this (apart from named), looking only at these args\n            locationArgs = KeyValueParser.parseMap(args);\n        }\n        String namedLocation = (String) locationFlags.get(\"named\");\n\n        Map<String, Object> filteredProperties = new LocationPropertiesFromBrooklynProperties().getLocationProperties(null, namedLocation, globalProperties);\n        MutableMap<String, Object> flags = MutableMap.<String, Object>builder()\n                .putAll(filteredProperties)\n                .putAll(locationFlags)\n                .removeAll(\"named\")\n                .putAll(locationArgs).build();\n        \n        if (locationArgs.get(\"targets\") == null) {\n            throw new IllegalArgumentException(\"target must be specified in single-machine spec\");\n        }\n        \n        // TODO do we need to pass location flags etc into the children to ensure they are inherited?\n        List<Location> targets = Lists.newArrayList();\n        Object targetSpecs = locationArgs.remove(\"targets\");\n        if (targetSpecs instanceof String) {\n            for (String targetSpec : JavaStringEscapes.unwrapJsonishListIfPossible((String)targetSpecs)) {\n                targets.add(managementContext.getLocationRegistry().resolve(targetSpec));\n            }\n        } else if (targetSpecs instanceof Iterable) {\n            for (Object targetSpec: (Iterable<?>)targetSpecs) {\n                if (targetSpec instanceof String) {\n                    targets.add(managementContext.getLocationRegistry().resolve((String)targetSpec));\n                } else {\n                    Set<?> keys = ((Map<?,?>)targetSpec).keySet();\n                    if (keys.size()!=1) \n                        throw new IllegalArgumentException(\"targets supplied to MultiLocation must be a list of single-entry maps (got map of size \"+keys.size()+\": \"+targetSpec+\")\");\n                    Object key = keys.iterator().next();\n                    Object flagsS = ((Map<?,?>)targetSpec).get(key);\n                    targets.add(managementContext.getLocationRegistry().resolve((String)key, (Map<?,?>)flagsS));\n                }\n            }\n        } else throw new IllegalArgumentException(\"targets must be supplied to MultiLocation, either as string spec or list of single-entry maps each being a location spec\");\n        \n        return managementContext.getLocationManager().createLocation(LocationSpec.create(MultiLocation.class)\n                .configure(flags)\n                .configure(\"subLocations\", targets)\n                .configure(LocationConfigUtils.finalAndOriginalSpecs(spec, locationFlags, globalProperties, namedLocation)));\n    }","commit_id":"df6f3a3fe1755a79b37a3c576a9d285ff827d272","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected ConfigBag extractConfig(Map<?,?> locationFlags, String spec, brooklyn.location.LocationRegistry registry) {\n        ConfigBag config = super.extractConfig(locationFlags, spec, registry);\n\n        Object hosts = config.getStringKey(\"hosts\");\n        config.remove(\"hosts\");\n        String user = (String)config.getStringKey(\"user\");\n        \n        List<String> hostAddresses;\n        \n        if (hosts instanceof String) {\n            if (((String) hosts).isEmpty()) {\n                hostAddresses = ImmutableList.of();\n            } else {\n                hostAddresses = WildcardGlobs.getGlobsAfterBraceExpansion(\"{\"+hosts+\"}\",\n                        true /* numeric */, /* no quote support though */ PhraseTreatment.NOT_A_SPECIAL_CHAR, PhraseTreatment.NOT_A_SPECIAL_CHAR);\n            }\n        } else if (hosts instanceof Iterable) {\n            hostAddresses = ImmutableList.copyOf((Iterable<String>)hosts);\n        } else {\n            throw new IllegalArgumentException(\"Invalid location '\"+spec+\"'; at least one host must be defined\");\n        }\n        if (hostAddresses.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid location '\"+spec+\"'; at least one host must be defined\");\n        }\n        \n        List<SshMachineLocation> machines = Lists.newArrayList();\n        for (String host : hostAddresses) {\n            String userHere = user;\n            String hostHere = host;\n            if (host.contains(\"@\")) {\n                userHere = host.substring(0, host.indexOf(\"@\"));\n                hostHere = host.substring(host.indexOf(\"@\")+1);\n            }\n            try {\n                InetAddress.getByName(hostHere.trim());\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\"Invalid host '\"+hostHere+\"' specified in '\"+spec+\"': \"+e);\n            }\n            LocationSpec<SshMachineLocation> locationSpec = LocationSpec.create(SshMachineLocation.class)\n                    .configure(\"address\", hostHere.trim())\n                    .configureIfNotNull(LocalLocationManager.CREATE_UNMANAGED, config.get(LocalLocationManager.CREATE_UNMANAGED));\n            if (JavaGroovyEquivalents.groovyTruth(userHere)) {\n                locationSpec.configure(\"user\", userHere.trim());\n            }\n            SshMachineLocation machine = managementContext.getLocationManager().createLocation(locationSpec);\n            machines.add(machine);\n        }\n        \n        config.putStringKey(\"machines\", machines);\n\n        return config;\n    }","id":31737,"modified_method":"@Override\n    protected ConfigBag extractConfig(Map<?,?> locationFlags, String spec, brooklyn.location.LocationRegistry registry) {\n        ConfigBag config = super.extractConfig(locationFlags, spec, registry);\n\n        Object hosts = config.getStringKey(\"hosts\");\n        config.remove(\"hosts\");\n        String user = (String)config.getStringKey(\"user\");\n        Class<? extends MachineLocation> locationClass = OS_TO_MACHINE_LOCATION_TYPE.get(config.get(OS_FAMILY));\n        \n        List<String> hostAddresses;\n        \n        if (hosts instanceof String) {\n            if (((String) hosts).isEmpty()) {\n                hostAddresses = ImmutableList.of();\n            } else {\n                hostAddresses = WildcardGlobs.getGlobsAfterBraceExpansion(\"{\"+hosts+\"}\",\n                        true /* numeric */, /* no quote support though */ PhraseTreatment.NOT_A_SPECIAL_CHAR, PhraseTreatment.NOT_A_SPECIAL_CHAR);\n            }\n        } else if (hosts instanceof Iterable) {\n            hostAddresses = ImmutableList.copyOf((Iterable<String>)hosts);\n        } else {\n            throw new IllegalArgumentException(\"Invalid location '\"+spec+\"'; at least one host must be defined\");\n        }\n        if (hostAddresses.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid location '\"+spec+\"'; at least one host must be defined\");\n        }\n        \n        List<MachineLocation> machines = Lists.newArrayList();\n        for (String host : hostAddresses) {\n            String userHere = user;\n            String hostHere = host;\n            if (host.contains(\"@\")) {\n                userHere = host.substring(0, host.indexOf(\"@\"));\n                hostHere = host.substring(host.indexOf(\"@\")+1);\n            }\n            try {\n                InetAddress.getByName(hostHere.trim());\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\"Invalid host '\"+hostHere+\"' specified in '\"+spec+\"': \"+e);\n            }\n            LocationSpec<? extends MachineLocation> locationSpec = LocationSpec.create(locationClass)\n                    .configure(\"address\", hostHere.trim())\n                    .configureIfNotNull(LocalLocationManager.CREATE_UNMANAGED, config.get(LocalLocationManager.CREATE_UNMANAGED));\n            if (JavaGroovyEquivalents.groovyTruth(userHere)) {\n                locationSpec.configure(\"user\", userHere.trim());\n            }\n            MachineLocation machine = managementContext.getLocationManager().createLocation(locationSpec);\n            machines.add(machine);\n        }\n        \n        config.putStringKey(\"machines\", machines);\n\n        return config;\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testNamedByonLocation() throws Exception {\n        brooklynProperties.put(\"brooklyn.location.named.mynamed\", \"byon(hosts=\\\"1.1.1.1\\\")\");\n        \n        FixedListMachineProvisioningLocation<SshMachineLocation> loc = resolve(\"named:mynamed\");\n        assertEquals(loc.obtain().getAddress(), InetAddress.getByName(\"1.1.1.1\"));\n    }","id":31738,"modified_method":"@Test\n    public void testNamedByonLocation() throws Exception {\n        brooklynProperties.put(\"brooklyn.location.named.mynamed\", \"byon(hosts=\\\"1.1.1.1\\\")\");\n        \n        FixedListMachineProvisioningLocation<MachineLocation> loc = resolve(\"named:mynamed\");\n        assertEquals(loc.obtain().getAddress(), InetAddress.getByName(\"1.1.1.1\"));\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private FixedListMachineProvisioningLocation<SshMachineLocation> resolve(String val) {\n        return (FixedListMachineProvisioningLocation<SshMachineLocation>) managementContext.getLocationRegistry().resolve(val);\n    }","id":31739,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private FixedListMachineProvisioningLocation<MachineLocation> resolve(String val) {\n        return (FixedListMachineProvisioningLocation<MachineLocation>) managementContext.getLocationRegistry().resolve(val);\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testResolvesLocalTempDir() throws Exception {\n        String localTempDir = Os.mergePaths(Os.tmp(), \"testResolvesUsernameAtHost\");\n        brooklynProperties.put(\"brooklyn.location.byon.localTempDir\", localTempDir);\n\n        FixedListMachineProvisioningLocation<SshMachineLocation> byon = resolve(\"byon(hosts=\\\"1.1.1.1\\\")\");\n        SshMachineLocation machine = byon.obtain();\n        assertEquals(machine.getConfig(SshMachineLocation.LOCAL_TEMP_DIR), localTempDir);\n    }","id":31740,"modified_method":"@Test\n    public void testResolvesLocalTempDir() throws Exception {\n        String localTempDir = Os.mergePaths(Os.tmp(), \"testResolvesUsernameAtHost\");\n        brooklynProperties.put(\"brooklyn.location.byon.localTempDir\", localTempDir);\n\n        FixedListMachineProvisioningLocation<MachineLocation> byon = resolve(\"byon(hosts=\\\"1.1.1.1\\\",osFamily=\\\"windows\\\")\");\n        MachineLocation machine = byon.obtain();\n        assertEquals(machine.getConfig(SshMachineLocation.LOCAL_TEMP_DIR), localTempDir);\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testResolvesUserArg2() throws Exception {\n        String spec = \"byon(hosts=\\\"1.1.1.1\\\",user=bob)\";\n        FixedListMachineProvisioningLocation<SshMachineLocation> ll = resolve(spec);\n        SshMachineLocation l = ll.obtain();\n        Assert.assertEquals(\"bob\", l.getUser());\n    }","id":31741,"modified_method":"@Test\n    public void testResolvesUserArg2() throws Exception {\n        String spec = \"byon(hosts=\\\"1.1.1.1\\\",user=bob)\";\n        FixedListMachineProvisioningLocation<MachineLocation> ll = resolve(spec);\n        SshMachineLocation l = (SshMachineLocation)ll.obtain();\n        Assert.assertEquals(\"bob\", l.getUser());\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private FixedListMachineProvisioningLocation<SshMachineLocation> resolve(String val, Map<?, ?> locationFlags) {\n        return (FixedListMachineProvisioningLocation<SshMachineLocation>) managementContext.getLocationRegistry().resolve(val, locationFlags);\n    }","id":31742,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private FixedListMachineProvisioningLocation<MachineLocation> resolve(String val, Map<?, ?> locationFlags) {\n        return (FixedListMachineProvisioningLocation<MachineLocation>) managementContext.getLocationRegistry().resolve(val, locationFlags);\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testEmptySpec() throws Exception {\n        String spec = \"byon\";\n        Map<String, ?> flags = ImmutableMap.of(\n                \"hosts\", ImmutableList.of(\"1.1.1.1\", \"2.2.2.22\"),\n                \"name\", \"foo\",\n                \"user\", \"myuser\"\n        );\n        MachineProvisioningLocation<SshMachineLocation> provisioner = resolve(spec, flags);\n        SshMachineLocation location1 = provisioner.obtain(ImmutableMap.of());\n        Assert.assertEquals(\"myuser\", location1.getUser());\n        Assert.assertEquals(\"1.1.1.1\", location1.getAddress().getHostAddress());\n    }","id":31743,"modified_method":"@Test\n    public void testEmptySpec() throws Exception {\n        String spec = \"byon\";\n        Map<String, ?> flags = ImmutableMap.of(\n                \"hosts\", ImmutableList.of(\"1.1.1.1\", \"2.2.2.22\"),\n                \"name\", \"foo\",\n                \"user\", \"myuser\"\n        );\n        MachineProvisioningLocation<MachineLocation> provisioner = resolve(spec, flags);\n        SshMachineLocation location1 = (SshMachineLocation)provisioner.obtain(ImmutableMap.of());\n        Assert.assertEquals(\"myuser\", location1.getUser());\n        Assert.assertEquals(\"1.1.1.1\", location1.getAddress().getHostAddress());\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testPropertiesInSpec() throws Exception {\n        FixedListMachineProvisioningLocation<SshMachineLocation> loc = resolve(\"byon(privateKeyFile=myprivatekeyfile,hosts=\\\"1.1.1.1\\\")\");\n        SshMachineLocation machine = loc.obtain();\n        \n        assertEquals(machine.config().getBag().getStringKey(\"privateKeyFile\"), \"myprivatekeyfile\");\n        assertEquals(machine.getAddress(), Networking.getInetAddressWithFixedName(\"1.1.1.1\"));\n    }","id":31744,"modified_method":"@Test\n    public void testPropertiesInSpec() throws Exception {\n        FixedListMachineProvisioningLocation<MachineLocation> loc = resolve(\"byon(privateKeyFile=myprivatekeyfile,hosts=\\\"1.1.1.1\\\")\");\n        SshMachineLocation machine = (SshMachineLocation)loc.obtain();\n        \n        assertEquals(machine.config().getBag().getStringKey(\"privateKeyFile\"), \"myprivatekeyfile\");\n        assertEquals(machine.getAddress(), Networking.getInetAddressWithFixedName(\"1.1.1.1\"));\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testMachinesObtainedInOrder() throws Exception {\n        List<String> ips = ImmutableList.of(\"1.1.1.1\", \"1.1.1.6\", \"1.1.1.3\", \"1.1.1.4\", \"1.1.1.5\");\n        String spec = \"byon(hosts=\\\"\"+Joiner.on(\",\").join(ips)+\"\\\")\";\n        \n        MachineProvisioningLocation<SshMachineLocation> ll = resolve(spec);\n\n        for (String expected : ips) {\n            SshMachineLocation obtained = ll.obtain(ImmutableMap.of());\n            assertEquals(obtained.getAddress().getHostAddress(), expected);\n        }\n    }","id":31745,"modified_method":"@Test\n    public void testMachinesObtainedInOrder() throws Exception {\n        List<String> ips = ImmutableList.of(\"1.1.1.1\", \"1.1.1.6\", \"1.1.1.3\", \"1.1.1.4\", \"1.1.1.5\");\n        String spec = \"byon(hosts=\\\"\"+Joiner.on(\",\").join(ips)+\"\\\")\";\n        \n        MachineProvisioningLocation<MachineLocation> ll = resolve(spec);\n\n        for (String expected : ips) {\n            MachineLocation obtained = ll.obtain(ImmutableMap.of());\n            assertEquals(obtained.getAddress().getHostAddress(), expected);\n        }\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups=\"Integration\")\n    public void testNiceError() throws Exception {\n        Asserts.assertFailsWith(new Runnable() {\n            @Override public void run() {\n                FixedListMachineProvisioningLocation<SshMachineLocation> x = \n                        resolve(\"byon(hosts=\\\"1.1.1.{1,2}}\\\")\");\n                log.error(\"got \"+x+\" but should have failed (your DNS is giving an IP for hostname '1.1.1.1}' (with the extra '}')\");\n            }\n        }, new Predicate<Throwable>() {\n            @Override\n            public boolean apply(@Nullable Throwable input) {\n                String s = input.toString();\n                // words\n                if (!s.contains(\"Invalid host\")) return false;\n                // problematic entry\n                if (!s.contains(\"1.1.1.1}\")) return false;\n                // original spec\n                if (!s.contains(\"1.1.1.{1,2}}\")) return false;\n                return true;\n            }\n        });\n    }","id":31746,"modified_method":"@Test(groups=\"Integration\")\n    public void testNiceError() throws Exception {\n        Asserts.assertFailsWith(new Runnable() {\n            @Override public void run() {\n                FixedListMachineProvisioningLocation<MachineLocation> x =\n                        resolve(\"byon(hosts=\\\"1.1.1.{1,2}}\\\")\");\n                log.error(\"got \"+x+\" but should have failed (your DNS is giving an IP for hostname '1.1.1.1}' (with the extra '}')\");\n            }\n        }, new Predicate<Throwable>() {\n            @Override\n            public boolean apply(@Nullable Throwable input) {\n                String s = input.toString();\n                // words\n                if (!s.contains(\"Invalid host\")) return false;\n                // problematic entry\n                if (!s.contains(\"1.1.1.1}\")) return false;\n                // original spec\n                if (!s.contains(\"1.1.1.{1,2}}\")) return false;\n                return true;\n            }\n        });\n    }","commit_id":"1fa596902d3cd70f3e58dc558a07d90dca837bfe","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Should the index be auto created?\n     */\n    public boolean shouldAutoCreate(String index, ClusterState state) {\n        if (!needToCheck) {\n            return false;\n        }\n        boolean exists = resolver.hasIndexOrAlias(index, state);\n        if (exists) {\n            return false;\n        }\n        if (globallyDisabled || dynamicMappingDisabled) {\n            return false;\n        }\n        // matches not set, default value of \"true\"\n        if (matches == null) {\n            return true;\n        }\n        for (int i = 0; i < matches.length; i++) {\n            char c = matches[i].charAt(0);\n            if (c == '-') {\n                if (Regex.simpleMatch(matches2[i], index)) {\n                    return false;\n                }\n            } else if (c == '+') {\n                if (Regex.simpleMatch(matches2[i], index)) {\n                    return true;\n                }\n            } else {\n                if (Regex.simpleMatch(matches[i], index)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":31747,"modified_method":"/**\n     * Should the index be auto created?\n     */\n    public boolean shouldAutoCreate(String index, ClusterState state) {\n        if (autoCreate.autoCreateIndex == false) {\n            return false;\n        }\n        if (dynamicMappingDisabled) {\n            return false;\n        }\n        if (resolver.hasIndexOrAlias(index, state)) {\n            return false;\n        }\n        // matches not set, default value of \"true\"\n        if (autoCreate.expressions.isEmpty()) {\n            return true;\n        }\n        for (Tuple<String, Boolean> expression : autoCreate.expressions) {\n            String indexExpression = expression.v1();\n            boolean include = expression.v2();\n            if (Regex.simpleMatch(indexExpression, index)) {\n                return include;\n            }\n        }\n        return false;\n    }","commit_id":"a029c0ae62fee67fd41e6122f26c0afc2edd787e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public AutoCreate(String value) {\n            boolean autoCreateIndex;\n            String[] indices = null;\n            try {\n                autoCreateIndex = Booleans.parseBooleanExact(value);\n            } catch (IllegalArgumentException ex) {\n                try {\n                    indices = Strings.commaDelimitedListToStringArray(value);\n                    for (String string : indices) {\n                        if (string == null || string.length() == 0) {\n                            throw new IllegalArgumentException(\"Can't parse [\" + value + \"] for setting [action.auto_create_index] must be either [true, false, or a comma seperated list of index patterns]\");\n                        }\n                    }\n                    autoCreateIndex = true;\n                } catch (IllegalArgumentException ex1) {\n                    ex1.addSuppressed(ex);\n                    throw ex1;\n                }\n            }\n            this.indices = indices;\n            this.autoCreateIndex = autoCreateIndex;\n        }","id":31748,"modified_method":"private AutoCreate(String value) {\n            boolean autoCreateIndex;\n            List<Tuple<String, Boolean>> expressions = new ArrayList<>();\n            try {\n                autoCreateIndex = Booleans.parseBooleanExact(value);\n            } catch (IllegalArgumentException ex) {\n                try {\n                    String[] patterns = Strings.commaDelimitedListToStringArray(value);\n                    for (String pattern : patterns) {\n                        if (pattern == null || pattern.length() == 0) {\n                            throw new IllegalArgumentException(\"Can't parse [\" + value + \"] for setting [action.auto_create_index] must be either [true, false, or a comma separated list of index patterns]\");\n                        }\n                        Tuple<String, Boolean> expression;\n                        if (pattern.startsWith(\"-\")) {\n                            if (pattern.length() == 1) {\n                                throw new IllegalArgumentException(\"Can't parse [\" + value + \"] for setting [action.auto_create_index] must contain an index name after [-]\");\n                            }\n                            expression = new Tuple<>(pattern.substring(1), false);\n                        } else if(pattern.startsWith(\"+\")) {\n                            if (pattern.length() == 1) {\n                                throw new IllegalArgumentException(\"Can't parse [\" + value + \"] for setting [action.auto_create_index] must contain an index name after [+]\");\n                            }\n                            expression = new Tuple<>(pattern.substring(1), true);\n                        } else {\n                            expression = new Tuple<>(pattern, true);\n                        }\n                        expressions.add(expression);\n                    }\n                    autoCreateIndex = true;\n                } catch (IllegalArgumentException ex1) {\n                    ex1.addSuppressed(ex);\n                    throw ex1;\n                }\n            }\n            this.expressions = expressions;\n            this.autoCreateIndex = autoCreateIndex;\n        }","commit_id":"a029c0ae62fee67fd41e6122f26c0afc2edd787e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public AutoCreateIndex(Settings settings, IndexNameExpressionResolver resolver) {\n        this.resolver = resolver;\n        dynamicMappingDisabled = !MapperService.INDEX_MAPPER_DYNAMIC_SETTING.get(settings);\n        final AutoCreate autoCreate = AUTO_CREATE_INDEX_SETTING.get(settings);\n        if (autoCreate.autoCreateIndex) {\n            needToCheck = true;\n            globallyDisabled = false;\n            matches = autoCreate.indices;\n            if (matches != null) {\n                matches2 = new String[matches.length];\n                for (int i = 0; i < matches.length; i++) {\n                    matches2[i] = matches[i].substring(1);\n                }\n            } else {\n                matches2 = null;\n            }\n        } else {\n            needToCheck = false;\n            globallyDisabled = true;\n            matches = null;\n            matches2 = null;\n        }\n    }","id":31749,"modified_method":"@Inject\n    public AutoCreateIndex(Settings settings, IndexNameExpressionResolver resolver) {\n        this.resolver = resolver;\n        dynamicMappingDisabled = !MapperService.INDEX_MAPPER_DYNAMIC_SETTING.get(settings);\n        this.autoCreate = AUTO_CREATE_INDEX_SETTING.get(settings);\n    }","commit_id":"a029c0ae62fee67fd41e6122f26c0afc2edd787e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Do we really need to check if an index should be auto created?\n     */\n    public boolean needToCheck() {\n        return this.needToCheck;\n    }","id":31750,"modified_method":"/**\n     * Do we really need to check if an index should be auto created?\n     */\n    public boolean needToCheck() {\n        return this.autoCreate.autoCreateIndex;\n    }","commit_id":"a029c0ae62fee67fd41e6122f26c0afc2edd787e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testParseFailed() {\n        try {\n            new AutoCreateIndex(Settings.builder().put(\"action.auto_create_index\", \",,,\").build(), new IndexNameExpressionResolver(Settings.EMPTY));\n        }catch (IllegalArgumentException ex) {\n            assertEquals(\"Can't parse [,,,] for setting [action.auto_create_index] must be either [true, false, or a comma seperated list of index patterns]\", ex.getMessage());\n        }\n\n    }","id":31751,"modified_method":"public void testParseFailed() {\n        try {\n            new AutoCreateIndex(Settings.builder().put(\"action.auto_create_index\", \",,,\").build(), new IndexNameExpressionResolver(Settings.EMPTY));\n            fail(\"initialization should have failed\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"Can't parse [,,,] for setting [action.auto_create_index] must be either [true, false, or a comma separated list of index patterns]\", ex.getMessage());\n        }\n    }","commit_id":"a029c0ae62fee67fd41e6122f26c0afc2edd787e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ClusterState buildClusterState(String... indices) {\n        MetaData.Builder metaData = MetaData.builder();\n        for (String index : indices) {\n            metaData.put(IndexMetaData.builder(index).settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1));\n        }\n        return ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).build();\n    }","id":31752,"modified_method":"private static ClusterState buildClusterState(String... indices) {\n        MetaData.Builder metaData = MetaData.builder();\n        for (String index : indices) {\n            metaData.put(IndexMetaData.builder(index).settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1));\n        }\n        return ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).build();\n    }","commit_id":"a029c0ae62fee67fd41e6122f26c0afc2edd787e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public boolean match(DiscoveryNode node) {\n        if (filters.isEmpty()) {\n            return true;\n        }\n        for (Map.Entry<String, String[]> entry : filters.entrySet()) {\n            String attr = entry.getKey();\n            String[] values = entry.getValue();\n            if (\"_ip\".equals(attr)) {\n                if (!(node.address() instanceof InetSocketTransportAddress)) {\n                    return false;\n                }\n                InetSocketTransportAddress inetAddress = (InetSocketTransportAddress) node.address();\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (\"_host\".equals(attr)) {\n                if (!(node.address() instanceof InetSocketTransportAddress)) {\n                    return false;\n                }\n                InetSocketTransportAddress inetAddress = (InetSocketTransportAddress) node.address();\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, inetAddress.address().getHostName())) {\n                        return true;\n                    }\n                    if (Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (\"_id\".equals(attr)) {\n                for (String value : values) {\n                    if (node.id().equals(value)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (\"_name\".equals(attr) || \"name\".equals(attr)) {\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, node.name())) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                String nodeAttributeValue = node.attributes().get(attr);\n                if (nodeAttributeValue == null) {\n                    return false;\n                }\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, nodeAttributeValue)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        return true;\n    }","id":31753,"modified_method":"public boolean match(DiscoveryNode node) {\n        for (Map.Entry<String, String[]> entry : filters.entrySet()) {\n            String attr = entry.getKey();\n            String[] values = entry.getValue();\n            if (\"_ip\".equals(attr)) {\n                if (!(node.address() instanceof InetSocketTransportAddress)) {\n                    if (opType == OpType.AND) {\n                        return false;\n                    } else {\n                        continue;\n                    }\n                }\n                InetSocketTransportAddress inetAddress = (InetSocketTransportAddress) node.address();\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {\n                        if (opType == OpType.OR) {\n                            return true;\n                        }\n                    } else {\n                        if (opType == OpType.AND) {\n                            return false;\n                        }\n                    }\n                }\n            } else if (\"_host\".equals(attr)) {\n                if (!(node.address() instanceof InetSocketTransportAddress)) {\n                    if (opType == OpType.AND) {\n                        return false;\n                    } else {\n                        continue;\n                    }\n                }\n                InetSocketTransportAddress inetAddress = (InetSocketTransportAddress) node.address();\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, inetAddress.address().getHostName())) {\n                        if (opType == OpType.OR) {\n                            return true;\n                        }\n                    } else {\n                        if (opType == OpType.AND) {\n                            return false;\n                        }\n                    }\n                    if (Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {\n                        if (opType == OpType.OR) {\n                            return true;\n                        }\n                    } else {\n                        if (opType == OpType.AND) {\n                            return false;\n                        }\n                    }\n                }\n            } else if (\"_id\".equals(attr)) {\n                for (String value : values) {\n                    if (node.id().equals(value)) {\n                        if (opType == OpType.OR) {\n                            return true;\n                        }\n                    } else {\n                        if (opType == OpType.AND) {\n                            return false;\n                        }\n                    }\n                }\n            } else if (\"_name\".equals(attr) || \"name\".equals(attr)) {\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, node.name())) {\n                        if (opType == OpType.OR) {\n                            return true;\n                        }\n                    } else {\n                        if (opType == OpType.AND) {\n                            return false;\n                        }\n                    }\n                }\n            } else {\n                String nodeAttributeValue = node.attributes().get(attr);\n                if (nodeAttributeValue == null) {\n                    if (opType == OpType.AND) {\n                        return false;\n                    } else {\n                        continue;\n                    }\n                }\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, nodeAttributeValue)) {\n                        if (opType == OpType.OR) {\n                            return true;\n                        }\n                    } else {\n                        if (opType == OpType.AND) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        if (opType == OpType.OR) {\n            return false;\n        } else {\n            return true;\n        }\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static DiscoveryNodeFilters buildFromKeyValue(Map<String, String> filters) {\n        Map<String, String[]> bFilters = new HashMap<String, String[]>();\n        for (Map.Entry<String, String> entry : filters.entrySet()) {\n            String[] values = Strings.splitStringByCommaToArray(entry.getValue());\n            if (values.length > 0) {\n                bFilters.put(entry.getKey(), values);\n            }\n        }\n        if (bFilters.isEmpty()) {\n            return NO_FILTERS;\n        }\n        return new DiscoveryNodeFilters(bFilters);\n    }","id":31754,"modified_method":"public static DiscoveryNodeFilters buildFromKeyValue(OpType opType, Map<String, String> filters) {\n        Map<String, String[]> bFilters = new HashMap<String, String[]>();\n        for (Map.Entry<String, String> entry : filters.entrySet()) {\n            String[] values = Strings.splitStringByCommaToArray(entry.getValue());\n            if (values.length > 0) {\n                bFilters.put(entry.getKey(), values);\n            }\n        }\n        if (bFilters.isEmpty()) {\n            return null;\n        }\n        return new DiscoveryNodeFilters(opType, bFilters);\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static DiscoveryNodeFilters buildFromSettings(String prefix, Settings settings) {\n        return buildFromKeyValue(settings.getByPrefix(prefix).getAsMap());\n    }","id":31755,"modified_method":"public static DiscoveryNodeFilters buildFromSettings(OpType opType, String prefix, Settings settings) {\n        return buildFromKeyValue(opType, settings.getByPrefix(prefix).getAsMap());\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"DiscoveryNodeFilters(Map<String, String[]> filters) {\n        this.filters = filters;\n    }","id":31756,"modified_method":"DiscoveryNodeFilters(OpType opType, Map<String, String[]> filters) {\n        this.opType = opType;\n        this.filters = filters;\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void nameMatch() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"xxx.name\", \"name1\")\n                .build();\n        DiscoveryNodeFilters filters = DiscoveryNodeFilters.buildFromSettings(\"xxx.\", settings);\n\n        DiscoveryNode node = new DiscoveryNode(\"name1\", \"id1\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(true));\n\n        node = new DiscoveryNode(\"name2\", \"id2\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(false));\n    }","id":31757,"modified_method":"@Test\n    public void nameMatch() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"xxx.name\", \"name1\")\n                .build();\n        DiscoveryNodeFilters filters = DiscoveryNodeFilters.buildFromSettings(OR, \"xxx.\", settings);\n\n        DiscoveryNode node = new DiscoveryNode(\"name1\", \"id1\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(true));\n\n        node = new DiscoveryNode(\"name2\", \"id2\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(false));\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void idMatch() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"xxx._id\", \"id1\")\n                .build();\n        DiscoveryNodeFilters filters = DiscoveryNodeFilters.buildFromSettings(\"xxx.\", settings);\n\n        DiscoveryNode node = new DiscoveryNode(\"name1\", \"id1\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(true));\n\n        node = new DiscoveryNode(\"name2\", \"id2\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(false));\n    }","id":31758,"modified_method":"@Test\n    public void idMatch() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"xxx._id\", \"id1\")\n                .build();\n        DiscoveryNodeFilters filters = DiscoveryNodeFilters.buildFromSettings(OR, \"xxx.\", settings);\n\n        DiscoveryNode node = new DiscoveryNode(\"name1\", \"id1\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(true));\n\n        node = new DiscoveryNode(\"name2\", \"id2\", DummyTransportAddress.INSTANCE, ImmutableMap.<String, String>of());\n        assertThat(filters.match(node), equalTo(false));\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public FilterAllocationDecider(Settings settings, NodeSettingsService nodeSettingsService) {\n        super(settings);\n        ImmutableMap<String, String> includeMap = settings.getByPrefix(\"cluster.routing.allocation.include.\").getAsMap();\n        if (includeMap.isEmpty()) {\n            clusterIncludeFilters = null;\n        } else {\n            clusterIncludeFilters = DiscoveryNodeFilters.buildFromKeyValue(includeMap);\n        }\n        ImmutableMap<String, String> excludeMap = settings.getByPrefix(\"cluster.routing.allocation.exclude.\").getAsMap();\n        if (excludeMap.isEmpty()) {\n            clusterExcludeFilters = null;\n        } else {\n            clusterExcludeFilters = DiscoveryNodeFilters.buildFromKeyValue(excludeMap);\n        }\n        nodeSettingsService.addListener(new ApplySettings());\n    }","id":31759,"modified_method":"@Inject\n    public FilterAllocationDecider(Settings settings, NodeSettingsService nodeSettingsService) {\n        super(settings);\n        ImmutableMap<String, String> requireMap = settings.getByPrefix(\"cluster.routing.allocation.require.\").getAsMap();\n        if (requireMap.isEmpty()) {\n            clusterRequireFilters = null;\n        } else {\n            clusterRequireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap);\n        }\n        ImmutableMap<String, String> includeMap = settings.getByPrefix(\"cluster.routing.allocation.include.\").getAsMap();\n        if (includeMap.isEmpty()) {\n            clusterIncludeFilters = null;\n        } else {\n            clusterIncludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap);\n        }\n        ImmutableMap<String, String> excludeMap = settings.getByPrefix(\"cluster.routing.allocation.exclude.\").getAsMap();\n        if (excludeMap.isEmpty()) {\n            clusterExcludeFilters = null;\n        } else {\n            clusterExcludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap);\n        }\n        nodeSettingsService.addListener(new ApplySettings());\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private boolean shouldFilter(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (clusterIncludeFilters != null) {\n            if (!clusterIncludeFilters.match(node.node())) {\n                return true;\n            }\n        }\n        if (clusterExcludeFilters != null) {\n            if (clusterExcludeFilters.match(node.node())) {\n                return true;\n            }\n        }\n\n        IndexMetaData indexMd = allocation.routingNodes().metaData().index(shardRouting.index());\n        if (indexMd.includeFilters() != null) {\n            if (!indexMd.includeFilters().match(node.node())) {\n                return true;\n            }\n        }\n        if (indexMd.excludeFilters() != null) {\n            if (indexMd.excludeFilters().match(node.node())) {\n                return true;\n            }\n        }\n\n        return false;\n    }","id":31760,"modified_method":"private boolean shouldFilter(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (clusterRequireFilters != null) {\n            if (!clusterRequireFilters.match(node.node())) {\n                return true;\n            }\n        }\n        if (clusterIncludeFilters != null) {\n            if (!clusterIncludeFilters.match(node.node())) {\n                return true;\n            }\n        }\n        if (clusterExcludeFilters != null) {\n            if (clusterExcludeFilters.match(node.node())) {\n                return true;\n            }\n        }\n\n        IndexMetaData indexMd = allocation.routingNodes().metaData().index(shardRouting.index());\n        if (indexMd.requireFilters() != null) {\n            if (!indexMd.requireFilters().match(node.node())) {\n                return true;\n            }\n        }\n        if (indexMd.includeFilters() != null) {\n            if (!indexMd.includeFilters().match(node.node())) {\n                return true;\n            }\n        }\n        if (indexMd.excludeFilters() != null) {\n            if (indexMd.excludeFilters().match(node.node())) {\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            ImmutableMap<String, String> includeMap = settings.getByPrefix(\"cluster.routing.allocation.include.\").getAsMap();\n            if (!includeMap.isEmpty()) {\n                clusterIncludeFilters = DiscoveryNodeFilters.buildFromKeyValue(includeMap);\n            }\n            ImmutableMap<String, String> excludeMap = settings.getByPrefix(\"cluster.routing.allocation.exclude.\").getAsMap();\n            if (!excludeMap.isEmpty()) {\n                clusterExcludeFilters = DiscoveryNodeFilters.buildFromKeyValue(excludeMap);\n            }\n        }","id":31761,"modified_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            ImmutableMap<String, String> requireMap = settings.getByPrefix(\"cluster.routing.allocation.require.\").getAsMap();\n            if (!requireMap.isEmpty()) {\n                clusterRequireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap);\n            }\n            ImmutableMap<String, String> includeMap = settings.getByPrefix(\"cluster.routing.allocation.include.\").getAsMap();\n            if (!includeMap.isEmpty()) {\n                clusterIncludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap);\n            }\n            ImmutableMap<String, String> excludeMap = settings.getByPrefix(\"cluster.routing.allocation.exclude.\").getAsMap();\n            if (!excludeMap.isEmpty()) {\n                clusterExcludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap);\n            }\n        }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private IndexMetaData(String index, long version, State state, Settings settings, ImmutableMap<String, MappingMetaData> mappings, ImmutableMap<String, AliasMetaData> aliases, ImmutableMap<String, Custom> customs) {\n        Preconditions.checkArgument(settings.getAsInt(SETTING_NUMBER_OF_SHARDS, -1) != -1, \"must specify numberOfShards for index [\" + index + \"]\");\n        Preconditions.checkArgument(settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, -1) != -1, \"must specify numberOfReplicas for index [\" + index + \"]\");\n        this.index = index;\n        this.version = version;\n        this.state = state;\n        this.settings = settings;\n        this.mappings = mappings;\n        this.customs = customs;\n        this.totalNumberOfShards = numberOfShards() * (numberOfReplicas() + 1);\n\n        this.aliases = aliases;\n\n        ImmutableMap<String, String> includeMap = settings.getByPrefix(\"index.routing.allocation.include.\").getAsMap();\n        if (includeMap.isEmpty()) {\n            includeFilters = null;\n        } else {\n            includeFilters = DiscoveryNodeFilters.buildFromKeyValue(includeMap);\n        }\n        ImmutableMap<String, String> excludeMap = settings.getByPrefix(\"index.routing.allocation.exclude.\").getAsMap();\n        if (excludeMap.isEmpty()) {\n            excludeFilters = null;\n        } else {\n            excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(excludeMap);\n        }\n    }","id":31762,"modified_method":"private IndexMetaData(String index, long version, State state, Settings settings, ImmutableMap<String, MappingMetaData> mappings, ImmutableMap<String, AliasMetaData> aliases, ImmutableMap<String, Custom> customs) {\n        Preconditions.checkArgument(settings.getAsInt(SETTING_NUMBER_OF_SHARDS, -1) != -1, \"must specify numberOfShards for index [\" + index + \"]\");\n        Preconditions.checkArgument(settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, -1) != -1, \"must specify numberOfReplicas for index [\" + index + \"]\");\n        this.index = index;\n        this.version = version;\n        this.state = state;\n        this.settings = settings;\n        this.mappings = mappings;\n        this.customs = customs;\n        this.totalNumberOfShards = numberOfShards() * (numberOfReplicas() + 1);\n\n        this.aliases = aliases;\n\n        ImmutableMap<String, String> requireMap = settings.getByPrefix(\"index.routing.allocation.require.\").getAsMap();\n        if (requireMap.isEmpty()) {\n            requireFilters = null;\n        } else {\n            requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap);\n        }\n        ImmutableMap<String, String> includeMap = settings.getByPrefix(\"index.routing.allocation.include.\").getAsMap();\n        if (includeMap.isEmpty()) {\n            includeFilters = null;\n        } else {\n            includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap);\n        }\n        ImmutableMap<String, String> excludeMap = settings.getByPrefix(\"index.routing.allocation.exclude.\").getAsMap();\n        if (excludeMap.isEmpty()) {\n            excludeFilters = null;\n        } else {\n            excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap);\n        }\n    }","commit_id":"d1281d283beb85f10dd376292925d78dd83626a0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public boolean match(DiscoveryNode node) {\n        if (filters.isEmpty()) {\n            return true;\n        }\n        for (Map.Entry<String, String[]> entry : filters.entrySet()) {\n            String attr = entry.getKey();\n            String[] values = entry.getValue();\n            if (\"_ip\".equals(attr)) {\n                if (!(node.address() instanceof InetSocketTransportAddress)) {\n                    return false;\n                }\n                InetSocketTransportAddress inetAddress = (InetSocketTransportAddress) node.address();\n                for (String value : values) {\n                    if (!Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {\n                        return false;\n                    }\n                }\n            } else {\n                String nodeAttributeValue = node.attributes().get(attr);\n                if (nodeAttributeValue == null) {\n                    return false;\n                }\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, nodeAttributeValue)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        return true;\n    }","id":31763,"modified_method":"public boolean match(DiscoveryNode node) {\n        if (filters.isEmpty()) {\n            return true;\n        }\n        for (Map.Entry<String, String[]> entry : filters.entrySet()) {\n            String attr = entry.getKey();\n            String[] values = entry.getValue();\n            if (\"_ip\".equals(attr)) {\n                if (!(node.address() instanceof InetSocketTransportAddress)) {\n                    return false;\n                }\n                InetSocketTransportAddress inetAddress = (InetSocketTransportAddress) node.address();\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (\"_id\".equals(attr)) {\n                for (String value : values) {\n                    if (node.id().equals(value)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (\"_name\".equals(attr)) {\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, node.name())) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                String nodeAttributeValue = node.attributes().get(attr);\n                if (nodeAttributeValue == null) {\n                    return false;\n                }\n                for (String value : values) {\n                    if (Regex.simpleMatch(value, nodeAttributeValue)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"9ff4a95ee4ce3982508965f780afb4343053ae1a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override protected ClusterUpdateSettingsResponse masterOperation(final ClusterUpdateSettingsRequest request, ClusterState state) throws ElasticSearchException {\n        final AtomicReference<Throwable> failureRef = new AtomicReference<Throwable>();\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        clusterService.submitStateUpdateTask(\"cluster_update_settings\", new ClusterStateUpdateTask() {\n            @Override public ClusterState execute(ClusterState currentState) {\n                try {\n                    boolean changed = false;\n                    ImmutableSettings.Builder transientSettings = ImmutableSettings.settingsBuilder();\n                    transientSettings.put(currentState.metaData().transientSettings());\n                    for (Map.Entry<String, String> entry : request.transientSettings().getAsMap().entrySet()) {\n                        if (MetaData.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            transientSettings.put(entry.getKey(), entry.getValue());\n                            changed = true;\n                        } else {\n                            logger.warn(\"ignoring transient setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    ImmutableSettings.Builder persistentSettings = ImmutableSettings.settingsBuilder();\n                    persistentSettings.put(currentState.metaData().persistentSettings());\n                    for (Map.Entry<String, String> entry : request.persistentSettings().getAsMap().entrySet()) {\n                        if (MetaData.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            changed = true;\n                            persistentSettings.put(entry.getKey(), entry.getValue());\n                        } else {\n                            logger.warn(\"ignoring persistent setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    if (!changed) {\n                        return currentState;\n                    }\n\n                    MetaData.Builder metaData = MetaData.builder().metaData(currentState.metaData())\n                            .persistentSettings(persistentSettings.build())\n                            .transientSettings(transientSettings.build());\n\n\n                    ClusterState updatedState = ClusterState.builder().state(currentState).metaData(metaData).build();\n\n                    // now, reroute in case things change that require it (like number of replicas)\n                    RoutingAllocation.Result routingResult = allocationService.reroute(updatedState);\n                    updatedState = newClusterStateBuilder().state(updatedState).routingResult(routingResult).build();\n\n                    return updatedState;\n                } finally {\n                    latch.countDown();\n                }\n            }\n        });\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            failureRef.set(e);\n        }\n\n        if (failureRef.get() != null) {\n            if (failureRef.get() instanceof ElasticSearchException) {\n                throw (ElasticSearchException) failureRef.get();\n            } else {\n                throw new ElasticSearchException(failureRef.get().getMessage(), failureRef.get());\n            }\n        }\n\n        return new ClusterUpdateSettingsResponse();\n    }","id":31764,"modified_method":"@Override protected ClusterUpdateSettingsResponse masterOperation(final ClusterUpdateSettingsRequest request, ClusterState state) throws ElasticSearchException {\n        final AtomicReference<Throwable> failureRef = new AtomicReference<Throwable>();\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        clusterService.submitStateUpdateTask(\"cluster_update_settings\", new ProcessedClusterStateUpdateTask() {\n            @Override public ClusterState execute(ClusterState currentState) {\n                try {\n                    boolean changed = false;\n                    ImmutableSettings.Builder transientSettings = ImmutableSettings.settingsBuilder();\n                    transientSettings.put(currentState.metaData().transientSettings());\n                    for (Map.Entry<String, String> entry : request.transientSettings().getAsMap().entrySet()) {\n                        if (MetaData.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            transientSettings.put(entry.getKey(), entry.getValue());\n                            changed = true;\n                        } else {\n                            logger.warn(\"ignoring transient setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    ImmutableSettings.Builder persistentSettings = ImmutableSettings.settingsBuilder();\n                    persistentSettings.put(currentState.metaData().persistentSettings());\n                    for (Map.Entry<String, String> entry : request.persistentSettings().getAsMap().entrySet()) {\n                        if (MetaData.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            changed = true;\n                            persistentSettings.put(entry.getKey(), entry.getValue());\n                        } else {\n                            logger.warn(\"ignoring persistent setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    if (!changed) {\n                        return currentState;\n                    }\n\n                    MetaData.Builder metaData = MetaData.builder().metaData(currentState.metaData())\n                            .persistentSettings(persistentSettings.build())\n                            .transientSettings(transientSettings.build());\n\n\n                    return ClusterState.builder().state(currentState).metaData(metaData).build();\n                } catch (Exception e) {\n                    latch.countDown();\n                    logger.warn(\"failed to update cluster settings\", e);\n                    return currentState;\n                } finally {\n                    // we don't release the latch here, only after we rerouted\n                }\n            }\n\n            @Override public void clusterStateProcessed(ClusterState clusterState) {\n                // now, reroute\n                clusterService.submitStateUpdateTask(\"reroute_after_cluster_update_settings\", new ClusterStateUpdateTask() {\n                    @Override public ClusterState execute(ClusterState currentState) {\n                        try {\n                            // now, reroute in case things change that require it (like number of replicas)\n                            RoutingAllocation.Result routingResult = allocationService.reroute(currentState);\n                            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();\n                        } finally {\n                            latch.countDown();\n                        }\n                    }\n                });\n            }\n        });\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            failureRef.set(e);\n        }\n\n        if (failureRef.get() != null) {\n            if (failureRef.get() instanceof ElasticSearchException) {\n                throw (ElasticSearchException) failureRef.get();\n            } else {\n                throw new ElasticSearchException(failureRef.get().getMessage(), failureRef.get());\n            }\n        }\n\n        return new ClusterUpdateSettingsResponse();\n    }","commit_id":"9ff4a95ee4ce3982508965f780afb4343053ae1a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testCaseAlignAfterColon1() throws Throwable {\n    myFixture.configureByText(\n      DartFileType.INSTANCE,\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1<caret>\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n    doTypeAndCheck(\n      ':',\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1:<caret>\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n  }","id":31765,"modified_method":"public void testCaseAlignAfterColon1() throws Throwable {\n    doTypingTest(':',\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1<caret>\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\",\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1:<caret>\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testLBraceInString() {\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = 'xx$<caret>xx'\");\n    doTypeAndCheck('{', \"var a = 'xx${<caret>}xx'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"foo () {var a = 'xx$<caret>xx';\\n}\");\n    doTypeAndCheck('{', \"foo () {var a = 'xx${<caret>}xx';\\n}\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = \\\"$<caret>\\\";\");\n    doTypeAndCheck('{', \"var a = \\\"${<caret>}\\\";\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = r'$<caret>'\");\n    doTypeAndCheck('{', \"var a = r'${<caret>'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '''$<caret>'''\");\n    doTypeAndCheck('{', \"var a = '''${<caret>}'''\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '${}<caret>'\");\n    doTypeAndCheck('{', \"var a = '${}{<caret>'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"<caret>\");\n    doTypeAndCheck('{', \"{<caret>}\");\n  }","id":31766,"modified_method":"public void testLBraceInString() {\n    doTypingTest('{', \"var a = 'xx$<caret>xx'\", \"var a = 'xx${<caret>}xx'\");\n    doTypingTest('{', \"foo () {var a = 'xx$<caret>xx';\\n}\", \"foo () {var a = 'xx${<caret>}xx';\\n}\");\n    doTypingTest('{', \"var a = \\\"$<caret>\\\";\", \"var a = \\\"${<caret>}\\\";\");\n    doTypingTest('{', \"var a = r'$<caret>'\", \"var a = r'${<caret>'\");\n    doTypingTest('{', \"var a = '''$<caret>'''\", \"var a = '''${<caret>}'''\");\n    doTypingTest('{', \"var a = '${}<caret>'\", \"var a = '${}{<caret>'\");\n    doTypingTest('{', \"<caret>\", \"{<caret>}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testEnterAfterCase() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE,\n                              \"void bar() {\\n\" +\n                              \"  switch (1) {\\n\" +\n                              \"    case 1+1: <caret>\\n\" +\n                              \"      a;\\n\" +\n                              \"    case 2:\\n\" +\n                              \"  }\\n\" +\n                              \"}\");\n    doTypeAndCheck('\\n', \"void bar() {\\n\" +\n                         \"  switch (1) {\\n\" +\n                         \"    case 1+1: \\n\" +\n                         \"      <caret>\\n\" +\n                         \"      a;\\n\" +\n                         \"    case 2:\\n\" +\n                         \"  }\\n\" +\n                         \"}\");\n  }","id":31767,"modified_method":"public void testEnterAfterCase() throws Throwable {\n    doTypingTest('\\n',\n                 \"void bar() {\\n\" +\n                 \"  switch (1) {\\n\" +\n                 \"    case 1+1: <caret>\\n\" +\n                 \"      a;\\n\" +\n                 \"    case 2:\\n\" +\n                 \"  }\\n\" +\n                 \"}\",\n                 \"void bar() {\\n\" +\n                 \"  switch (1) {\\n\" +\n                 \"    case 1+1: \\n\" +\n                 \"      <caret>\\n\" +\n                 \"      a;\\n\" +\n                 \"    case 2:\\n\" +\n                 \"  }\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testEnterInMapLiteral() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE, \"var data = {<caret>};\");\n    doTypeAndCheck('\\n', \"var data = {\\n\" +\n                         \"  <caret>\\n\" +\n                         \"};\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var data = {\\n\" +\n                                                     \"  1:1,<caret>\\n\" +\n                                                     \"};\");\n    doTypeAndCheck('\\n', \"var data = {\\n\" +\n                         \"  1:1,\\n\" +\n                         \"  <caret>\\n\" +\n                         \"};\");\n  }","id":31768,"modified_method":"public void testEnterInMapLiteral() throws Throwable {\n    doTypingTest('\\n', \"var data = {<caret>};\", \"var data = {\\n\" +\n                                                \"  <caret>\\n\" +\n                                                \"};\");\n    doTypingTest('\\n',\n                 \"var data = {\\n\" +\n                 \"  1:1,<caret>\\n\" +\n                 \"};\",\n                 \"var data = {\\n\" +\n                 \"  1:1,\\n\" +\n                 \"  <caret>\\n\" +\n                 \"};\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testRBraceInString() {\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = 'xx${<caret>}xx'\");\n    doTypeAndCheck('}', \"var a = 'xx${}<caret>xx'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = 'xx${<caret>xx'\");\n    doTypeAndCheck('}', \"var a = 'xx${}<caret>xx'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = \\\"${1 + 2 <caret>}\\\"\");\n    doTypeAndCheck('}', \"var a = \\\"${1 + 2 }<caret>\\\"\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = r'${<caret>}'\");\n    doTypeAndCheck('}', \"var a = r'${}<caret>}'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '''${<caret>}'''\");\n    doTypeAndCheck('}', \"var a = '''${}<caret>'''\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '${{<caret>}}'\");\n    doTypeAndCheck('}', \"var a = '${{}<caret>}'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '${{a<caret>}'\");\n    doTypeAndCheck('}', \"var a = '${{a}<caret>'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '${{1+1;}<caret>}'\");\n    doTypeAndCheck('}', \"var a = '${{1+1;}}<caret>'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '${{}<caret>'\");\n    doTypeAndCheck('}', \"var a = '${{}}<caret>'\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var a = '${{}}<caret>}'\");\n    doTypeAndCheck('}', \"var a = '${{}}}<caret>}'\");\n  }","id":31769,"modified_method":"public void testRBraceInString() {\n    doTypingTest('}', \"var a = 'xx${<caret>}xx'\", \"var a = 'xx${}<caret>xx'\");\n    doTypingTest('}', \"var a = 'xx${<caret>xx'\", \"var a = 'xx${}<caret>xx'\");\n    doTypingTest('}', \"var a = \\\"${1 + 2 <caret>}\\\"\", \"var a = \\\"${1 + 2 }<caret>\\\"\");\n    doTypingTest('}', \"var a = r'${<caret>}'\", \"var a = r'${}<caret>}'\");\n    doTypingTest('}', \"var a = '''${<caret>}'''\", \"var a = '''${}<caret>'''\");\n    doTypingTest('}', \"var a = '${{<caret>}}'\", \"var a = '${{}<caret>}'\");\n    doTypingTest('}', \"var a = '${{a<caret>}'\", \"var a = '${{a}<caret>'\");\n    doTypingTest('}', \"var a = '${{1+1;}<caret>}'\", \"var a = '${{1+1;}}<caret>'\");\n    doTypingTest('}', \"var a = '${{}<caret>'\", \"var a = '${{}}<caret>'\");\n    doTypingTest('}', \"var a = '${{}}<caret>}'\", \"var a = '${{}}}<caret>}'\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void doTypeAndCheck(char charToType, String expected) {\n    myFixture.type(charToType);\n    myFixture.checkResult(expected);\n  }","id":31770,"modified_method":"private void doTypingTest(final char charToType, final @NotNull String textBefore, final @NotNull String textAfter) {\n    myFixture.configureByText(DartFileType.INSTANCE, textBefore);\n    myFixture.type(charToType);\n    myFixture.checkResult(textAfter);\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testEnterAfterDefault() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE,\n                              \"void bar() {\\n\" +\n                              \"  switch (1) {\\n\" +\n                              \"    case 1:\\n\" +\n                              \"    default:<caret>\\n\" +\n                              \"  }\\n\" +\n                              \"}\");\n    doTypeAndCheck('\\n', \"void bar() {\\n\" +\n                         \"  switch (1) {\\n\" +\n                         \"    case 1:\\n\" +\n                         \"    default:\\n\" +\n                         \"      <caret>\\n\" +\n                         \"  }\\n\" +\n                         \"}\");\n  }","id":31771,"modified_method":"public void testEnterAfterDefault() throws Throwable {\n    doTypingTest('\\n',\n                 \"void bar() {\\n\" +\n                 \"  switch (1) {\\n\" +\n                 \"    case 1:\\n\" +\n                 \"    default:<caret>\\n\" +\n                 \"  }\\n\" +\n                 \"}\",\n                 \"void bar() {\\n\" +\n                 \"  switch (1) {\\n\" +\n                 \"    case 1:\\n\" +\n                 \"    default:\\n\" +\n                 \"      <caret>\\n\" +\n                 \"  }\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testEnterInSwitch() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE,\n                              \"void bar() {\\n\" +\n                              \"  switch (1) {<caret>\\n\" +\n                              \"}\");\n    doTypeAndCheck('\\n', \"void bar() {\\n\" +\n                         \"  switch (1) {\\n\" +\n                         \"    <caret>\\n\" +\n                         \"  }\\n\" +\n                         \"}\");\n  }","id":31772,"modified_method":"public void testEnterInSwitch() throws Throwable {\n    doTypingTest('\\n',\n                 \"void bar() {\\n\" +\n                 \"  switch (1) {<caret>\\n\" +\n                 \"}\",\n                 \"void bar() {\\n\" +\n                 \"  switch (1) {\\n\" +\n                 \"    <caret>\\n\" +\n                 \"  }\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testLt() {\n    myFixture.configureByText(DartFileType.INSTANCE, \"Map<List<caret>>\");\n    doTypeAndCheck('<', \"Map<List<<caret>>>\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"class A<caret>\");\n    doTypeAndCheck('<', \"class A<<caret>>\");\n  }","id":31773,"modified_method":"public void testLt() {\n    doTypingTest('<', \"Map<List<caret>>\", \"Map<List<<caret>>>\");\n    doTypingTest('<', \"class A<caret>\", \"class A<<caret>>\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testQuote9() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE, \"var foo = \\\"<caret>\\\"\");\n    doTypeAndCheck('\\\"', \"var foo = \\\"\\\"<caret>\");\n  }","id":31774,"modified_method":"public void testQuote() throws Throwable {\n    doTypingTest('\\'', \"var foo = <caret>\", \"var foo = '<caret>'\");\n    doTypingTest('\"', \"var foo = <caret>\", \"var foo = \\\"<caret>\\\"\");\n    doTypingTest('\"', \"var foo = '<caret>'\", \"var foo = '\\\"<caret>'\");\n    doTypingTest('\\'', \"var foo = \\\"<caret>\\\"\", \"var foo = \\\"'<caret>\\\"\");\n    doTypingTest('\\'', \"var foo = \\\"bar<caret>\\\"\", \"var foo = \\\"bar'<caret>\\\"\");\n    doTypingTest('\\'', \"import <caret>\", \"import '<caret>'\");\n    doTypingTest('\"', \"import <caret>\", \"import \\\"<caret>\\\"\");\n    doTypingTest('\\'', \"var foo = '<caret>'\", \"var foo = ''<caret>\");\n    doTypingTest('\\\"', \"var foo = \\\"<caret>\\\"\", \"var foo = \\\"\\\"<caret>\");\n    doTypingTest('\\'', \"var foo = 'bar<caret>'\", \"var foo = 'bar'<caret>\");\n    doTypingTest('\\\"', \"var foo = \\\"bar<caret>\\\"\", \"var foo = \\\"bar\\\"<caret>\");\n    doTypingTest('\\'', \"var foo = 'bar' <caret>\", \"var foo = 'bar' '<caret>'\");\n    doTypingTest('\\\"', \"var foo = \\\"\\\" <caret>\", \"var foo = \\\"\\\" \\\"<caret>\\\"\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testGt() {\n    myFixture.configureByText(DartFileType.INSTANCE, \"foo () {Map<List<<caret>>}\");\n    doTypeAndCheck('>', \"foo () {Map<List<><caret>>}\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"Map<List<<caret>>>\");\n    doTypeAndCheck('>', \"Map<List<><caret>>\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"Map<List<><caret>>\");\n    doTypeAndCheck('>', \"Map<List<>><caret>\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"Map<List<><caret>\");\n    doTypeAndCheck('>', \"Map<List<>><caret>\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"Map<List<>><caret>\");\n    doTypeAndCheck('>', \"Map<List<>>><caret>\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"Map<List<A>, B <caret>\");\n    doTypeAndCheck('>', \"Map<List<A>, B ><caret>\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"class A<T, E <caret>\");\n    doTypeAndCheck('>', \"class A<T, E ><caret>\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"class A<T, E <caret>>\");\n    doTypeAndCheck('>', \"class A<T, E ><caret>\");\n  }","id":31775,"modified_method":"public void testGt() {\n    doTypingTest('>', \"foo () {Map<List<<caret>>}\", \"foo () {Map<List<><caret>>}\");\n    doTypingTest('>', \"Map<List<<caret>>>\", \"Map<List<><caret>>\");\n    doTypingTest('>', \"Map<List<><caret>>\", \"Map<List<>><caret>\");\n    doTypingTest('>', \"Map<List<><caret>\", \"Map<List<>><caret>\");\n    doTypingTest('>', \"Map<List<>><caret>\", \"Map<List<>>><caret>\");\n    doTypingTest('>', \"Map<List<A>, B <caret>\", \"Map<List<A>, B ><caret>\");\n    doTypingTest('>', \"class A<T, E <caret>\", \"class A<T, E ><caret>\");\n    doTypingTest('>', \"class A<T, E <caret>>\", \"class A<T, E ><caret>\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void doBackspaceTest(String expected) {\n    myFixture.performEditorAction(IdeActions.ACTION_EDITOR_BACKSPACE);\n    myFixture.checkResult(expected);\n  }","id":31776,"modified_method":"private void doBackspaceTest(final @NotNull String textBefore, final @NotNull String textAfter) {\n    myFixture.configureByText(DartFileType.INSTANCE, textBefore);\n    myFixture.performEditorAction(IdeActions.ACTION_EDITOR_BACKSPACE);\n    myFixture.checkResult(textAfter);\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testBackspace2() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE, \"var foo = \\\"<caret>\\\"\");\n    doBackspaceTest(\"var foo = <caret>\");\n  }","id":31777,"modified_method":"public void testBackspace() throws Throwable {\n    doBackspaceTest(\"var foo = \\\"<caret> \\\"\", \"var foo = <caret> \\\"\");\n    doBackspaceTest(\"var foo = \\\"<caret>\\\"\", \"var foo = <caret>\");\n    doBackspaceTest(\"var foo = '<caret>a'\", \"var foo = <caret>a'\");\n    doBackspaceTest(\"import '<caret>'\", \"import <caret>\");\n    doBackspaceTest(\"var foo = \\\"\\\"<caret>\", \"var foo = \\\"<caret>\");\n    doBackspaceTest(\"var foo = \\\" '<caret>' \\\"\", \"var foo = \\\" <caret>' \\\"\");\n    doBackspaceTest(\"var foo = '\\\"<caret>\\\"'\", \"var foo = '<caret>\\\"'\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testDefaultAlignAfterColon() throws Throwable {\n    myFixture.configureByText(\n      DartFileType.INSTANCE,\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1:\\n\" +\n      \"    default<caret>\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n    doTypeAndCheck(\n      ':',\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1:\\n\" +\n      \"      default:<caret>\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n  }","id":31778,"modified_method":"public void testDefaultAlignAfterColon() throws Throwable {\n    doTypingTest(':',\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1:\\n\" +\n                 \"    default<caret>\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\",\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1:\\n\" +\n                 \"      default:<caret>\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testCaseStringAlignAfterColon() throws Throwable {\n    myFixture.configureByText(\n      DartFileType.INSTANCE,\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1:\\n\" +\n      \"    case '<caret>'\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n    doTypeAndCheck(\n      ':',\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1:\\n\" +\n      \"    case ':<caret>'\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n  }","id":31779,"modified_method":"public void testCaseStringAlignAfterColon() throws Throwable {\n    doTypingTest(':',\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1:\\n\" +\n                 \"    case '<caret>'\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\",\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1:\\n\" +\n                 \"    case ':<caret>'\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testEnterInListLiteral() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE, \"var data = [<caret>\\n\" +\n                                                     \"];\");\n    doTypeAndCheck('\\n', \"var data = [\\n\" +\n                         \"  <caret>\\n\" +\n                         \"];\");\n    myFixture.configureByText(DartFileType.INSTANCE, \"var data = [\\n\" +\n                                                     \"  1,<caret>\\n\" +\n                                                     \"];\");\n    doTypeAndCheck('\\n', \"var data = [\\n\" +\n                         \"  1,\\n\" +\n                         \"  <caret>\\n\" +\n                         \"];\");\n  }","id":31780,"modified_method":"public void testEnterInListLiteral() throws Throwable {\n    doTypingTest('\\n',\n                 \"var data = [<caret>\\n\" +\n                 \"];\",\n                 \"var data = [\\n\" +\n                 \"  <caret>\\n\" +\n                 \"];\");\n    doTypingTest('\\n',\n                 \"var data = [\\n\" +\n                 \"  1,<caret>\\n\" +\n                 \"];\",\n                 \"var data = [\\n\" +\n                 \"  1,\\n\" +\n                 \"  <caret>\\n\" +\n                 \"];\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testWEB_8315() throws Throwable {\n    myFixture.configureByText(DartFileType.INSTANCE, \"class X {\\n\" +\n                                                     \"  num x;<caret>\\n\" +\n                                                     \"}\");\n    doTypeAndCheck('\\n', \"class X {\\n\" +\n                         \"  num x;\\n\" +\n                         \"  <caret>\\n\" +\n                         \"}\");\n  }","id":31781,"modified_method":"public void testWEB_8315() throws Throwable {\n    doTypingTest('\\n',\n                 \"class X {\\n\" +\n                 \"  num x;<caret>\\n\" +\n                 \"}\",\n                 \"class X {\\n\" +\n                 \"  num x;\\n\" +\n                 \"  <caret>\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testEnterAfterBreakInCase() throws Throwable {\n    final String textBefore = \"void bar() {\\n\" +\n                              \"  switch (1) {\\n\" +\n                              \"    case 1:\\n\" +\n                              \"      break;<caret>\\n\" +\n                              \"  }\\n\" +\n                              \"}\";\n    final String textAfter = \"void bar() {\\n\" +\n                             \"  switch (1) {\\n\" +\n                             \"    case 1:\\n\" +\n                             \"      break;\\n\" +\n                             \"    <caret>\\n\" +\n                             \"  }\\n\" +\n                             \"}\";\n\n    myFixture.configureByText(DartFileType.INSTANCE, textBefore);\n    doTypeAndCheck('\\n', textAfter);\n\n    myFixture.configureByText(DartFileType.INSTANCE, StringUtil.replace(textBefore, \"break;\", \"continue;\"));\n    doTypeAndCheck('\\n', StringUtil.replace(textAfter, \"break;\", \"continue;\"));\n\n    myFixture.configureByText(DartFileType.INSTANCE, StringUtil.replace(textBefore, \"break;\", \"return 1+1;\"));\n    doTypeAndCheck('\\n', StringUtil.replace(textAfter, \"break;\", \"return 1+1;\"));\n\n    myFixture.configureByText(DartFileType.INSTANCE, StringUtil.replace(textBefore, \"break;\", \"throw '';\"));\n    doTypeAndCheck('\\n', StringUtil.replace(textAfter, \"break;\", \"throw '';\"));\n\n    myFixture.configureByText(DartFileType.INSTANCE, StringUtil.replace(textBefore, \"break;\", \"foo;\"));\n    doTypeAndCheck('\\n', StringUtil.replace(textAfter, \"break;\\n    <caret>\", \"foo;\\n      <caret>\"));\n  }","id":31782,"modified_method":"public void testEnterAfterBreakInCase() throws Throwable {\n    final String textBefore = \"void bar() {\\n\" +\n                              \"  switch (1) {\\n\" +\n                              \"    case 1:\\n\" +\n                              \"      break;<caret>\\n\" +\n                              \"  }\\n\" +\n                              \"}\";\n    final String textAfter = \"void bar() {\\n\" +\n                             \"  switch (1) {\\n\" +\n                             \"    case 1:\\n\" +\n                             \"      break;\\n\" +\n                             \"    <caret>\\n\" +\n                             \"  }\\n\" +\n                             \"}\";\n\n    doTypingTest('\\n', textBefore, textAfter);\n    doTypingTest('\\n', StringUtil.replace(textBefore, \"break;\", \"continue;\"), StringUtil.replace(textAfter, \"break;\", \"continue;\"));\n    doTypingTest('\\n', StringUtil.replace(textBefore, \"break;\", \"return 1+1;\"), StringUtil.replace(textAfter, \"break;\", \"return 1+1;\"));\n    doTypingTest('\\n', StringUtil.replace(textBefore, \"break;\", \"throw '';\"), StringUtil.replace(textAfter, \"break;\", \"throw '';\"));\n    doTypingTest('\\n', StringUtil.replace(textBefore, \"break;\", \"foo;\"),\n                 StringUtil.replace(textAfter, \"break;\\n    <caret>\", \"foo;\\n      <caret>\"));\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testCaseAlignAfterColon2() throws Throwable {\n    myFixture.configureByText(\n      DartFileType.INSTANCE,\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1:\\n\" +\n      \"    case 2<caret>\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n    doTypeAndCheck(\n      ':',\n      \"class X {\\n\" +\n      \"  void doit(x) {\\n\" +\n      \"    switch (x) {\\n\" +\n      \"      case 1:\\n\" +\n      \"      case 2:<caret>\\n\" +\n      \"    }\\n\" +\n      \"  }\\n\" +\n      \"}\");\n  }","id":31783,"modified_method":"public void testCaseAlignAfterColon2() throws Throwable {\n    doTypingTest(':',\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1:\\n\" +\n                 \"    case 2<caret>\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\",\n                 \"class X {\\n\" +\n                 \"  void doit(x) {\\n\" +\n                 \"    switch (x) {\\n\" +\n                 \"      case 1:\\n\" +\n                 \"      case 2:<caret>\\n\" +\n                 \"    }\\n\" +\n                 \"  }\\n\" +\n                 \"}\");\n  }","commit_id":"28c2b97acf47e4d4f75225b89db0af42866d3e91","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     *  Read the info block of an existing database.\n     */\n    private BlockFile initExisting(RAIFile raf) throws IOException {\n        long start = _context.clock().now();\n        try {\n            BlockFile bf = new BlockFile(raf, false);\n            // TODO all in one skiplist or separate?\n            SkipList hdr = bf.getIndex(INFO_SKIPLIST, _stringSerializer, _infoSerializer);\n            if (hdr == null)\n                throw new IOException(\"No db header\");\n            Properties info = (Properties) hdr.get(PROP_INFO);\n            if (info == null)\n                throw new IOException(\"No header info\");\n\n            String list = info.getProperty(PROP_LISTS);\n            if (list == null)\n                throw new IOException(\"No lists\");\n            long createdOn = 0;\n            String created = info.getProperty(PROP_CREATED);\n            if (created != null) {\n                try {\n                    createdOn = Long.parseLong(created);\n                } catch (NumberFormatException nfe) {}\n            }\n\n            String version = info.getProperty(PROP_VERSION);\n            if (version == null)\n                throw new IOException(\"No version\");\n            if (VersionComparator.comp(version, VERSION) > 0)\n                throw new IOException(\"Database version is \" + version +\n                                      \" but this implementation only supports versions 1-\" + VERSION +\n                                      \" Did you downgrade I2P??\");\n            _version = version;\n            if (VersionComparator.comp(version, \"4\") >= 0)\n                _destSerializer = _destSerializerV4;\n            _needsUpgrade = needsUpgrade(bf);\n            if (_needsUpgrade) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Upgrading database from version \" + _version + \" to \" + VERSION +\n                              \", created \" + (new Date(createdOn)).toString() +\n                              \" containing lists: \" + list);\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Found database version \" + _version +\n                              \" created \" + (new Date(createdOn)).toString() +\n                              \" containing lists: \" + list);\n            }\n\n            List<String> skiplists = getFilenames(list);\n            if (skiplists.isEmpty())\n                skiplists.add(FALLBACK_LIST);\n            _lists.addAll(skiplists);\n\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"DB init took \" + DataHelper.formatDuration(_context.clock().now() - start));\n            return bf;\n        } catch (RuntimeException e) {\n            _log.error(\"Failed to initialize database\", e);\n            throw new IOException(e.toString());\n        }\n    }","id":31784,"modified_method":"/**\n     *  Read the info block of an existing database.\n     */\n    private BlockFile initExisting(RAIFile raf) throws IOException {\n        long start = _context.clock().now();\n        try {\n            BlockFile bf = new BlockFile(raf, false);\n            // TODO all in one skiplist or separate?\n            SkipList<String, Properties> hdr = bf.getIndex(INFO_SKIPLIST, _stringSerializer, _infoSerializer);\n            if (hdr == null)\n                throw new IOException(\"No db header\");\n            Properties info = hdr.get(PROP_INFO);\n            if (info == null)\n                throw new IOException(\"No header info\");\n\n            String list = info.getProperty(PROP_LISTS);\n            if (list == null)\n                throw new IOException(\"No lists\");\n            long createdOn = 0;\n            String created = info.getProperty(PROP_CREATED);\n            if (created != null) {\n                try {\n                    createdOn = Long.parseLong(created);\n                } catch (NumberFormatException nfe) {}\n            }\n\n            String version = info.getProperty(PROP_VERSION);\n            if (version == null)\n                throw new IOException(\"No version\");\n            if (VersionComparator.comp(version, VERSION) > 0)\n                throw new IOException(\"Database version is \" + version +\n                                      \" but this implementation only supports versions 1-\" + VERSION +\n                                      \" Did you downgrade I2P??\");\n            _version = version;\n            if (VersionComparator.comp(version, \"4\") >= 0)\n                _destSerializer = _destSerializerV4;\n            _needsUpgrade = needsUpgrade(bf);\n            if (_needsUpgrade) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Upgrading database from version \" + _version + \" to \" + VERSION +\n                              \", created \" + (new Date(createdOn)).toString() +\n                              \" containing lists: \" + list);\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Found database version \" + _version +\n                              \" created \" + (new Date(createdOn)).toString() +\n                              \" containing lists: \" + list);\n            }\n\n            List<String> skiplists = getFilenames(list);\n            if (skiplists.isEmpty())\n                skiplists.add(FALLBACK_LIST);\n            _lists.addAll(skiplists);\n\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"DB init took \" + DataHelper.formatDuration(_context.clock().now() - start));\n            return bf;\n        } catch (RuntimeException e) {\n            _log.error(\"Failed to initialize database\", e);\n            throw new IOException(e.toString());\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Save new version number in blockfile after upgrade.\n     *  Blockfile must be writable, of course.\n     *  Side effect: sets _version field\n     *\n     *  Caller must synchronize\n     *  @since 0.9.26 pulled out of upgrade()\n     */\n    private void setVersion(String version) throws IOException {\n        SkipList hdr = _bf.getIndex(INFO_SKIPLIST, _stringSerializer, _infoSerializer);\n        if (hdr == null)\n            throw new IOException(\"No db header\");\n        Properties info = (Properties) hdr.get(PROP_INFO);\n        if (info == null)\n            throw new IOException(\"No header info\");\n        info.setProperty(PROP_VERSION, version);\n        info.setProperty(PROP_UPGRADED, Long.toString(_context.clock().now()));\n        hdr.put(PROP_INFO, info);\n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"Upgraded database from version \" + _version + \" to version \" + version);\n        _version = version;\n    }","id":31785,"modified_method":"/**\n     *  Save new version number in blockfile after upgrade.\n     *  Blockfile must be writable, of course.\n     *  Side effect: sets _version field\n     *\n     *  Caller must synchronize\n     *  @since 0.9.26 pulled out of upgrade()\n     */\n    private void setVersion(String version) throws IOException {\n        SkipList<String, Properties> hdr = _bf.getIndex(INFO_SKIPLIST, _stringSerializer, _infoSerializer);\n        if (hdr == null)\n            throw new IOException(\"No db header\");\n        Properties info = hdr.get(PROP_INFO);\n        if (info == null)\n            throw new IOException(\"No header info\");\n        info.setProperty(PROP_VERSION, version);\n        info.setProperty(PROP_UPGRADED, Long.toString(_context.clock().now()));\n        hdr.put(PROP_INFO, info);\n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"Upgraded database from version \" + _version + \" to version \" + version);\n        _version = version;\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * @param options If non-null and contains the key \"list\", remove\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     */\n    @Override\n    public boolean remove(String hostname, Properties options) {\n        if (_readOnly) {\n            _log.error(\"Remove entry failed, read-only hosts database\");\n            return false;\n        }\n        String key = hostname.toLowerCase(Locale.US);\n        String listname = FALLBACK_LIST;\n        if (options != null) {\n            String list = options.getProperty(\"list\");\n            if (list != null) {\n                listname = list;\n            }\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return false;\n            try {\n                SkipList sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null)\n                    return false;\n                Object removed = removeEntry(sl, key);\n                boolean rv = removed != null;\n                if (rv) {\n                    removeCache(hostname);\n                    try {\n                        removeReverseEntry(key, ((DestEntry)removed).dest);\n                    } catch (ClassCastException cce) {\n                        _log.error(\"DB reverse remove error\", cce);\n                    }\n                    for (NamingServiceListener nsl : _listeners) { \n                        nsl.entryRemoved(this, key);\n                    }\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB remove error\", ioe);\n                return false;\n            } catch (RuntimeException re) {\n                _log.error(\"DB remove error\", re);\n                return false;\n            }\n        }\n    }","id":31786,"modified_method":"/**\n     * @param options If non-null and contains the key \"list\", remove\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     */\n    @Override\n    public boolean remove(String hostname, Properties options) {\n        if (_readOnly) {\n            _log.error(\"Remove entry failed, read-only hosts database\");\n            return false;\n        }\n        String key = hostname.toLowerCase(Locale.US);\n        String listname = FALLBACK_LIST;\n        if (options != null) {\n            String list = options.getProperty(\"list\");\n            if (list != null) {\n                listname = list;\n            }\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return false;\n            try {\n                SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null)\n                    return false;\n                Object removed = removeEntry(sl, key);\n                boolean rv = removed != null;\n                if (rv) {\n                    removeCache(hostname);\n                    try {\n                        removeReverseEntry(key, ((DestEntry)removed).dest);\n                    } catch (ClassCastException cce) {\n                        _log.error(\"DB reverse remove error\", cce);\n                    }\n                    for (NamingServiceListener nsl : _listeners) { \n                        nsl.entryRemoved(this, key);\n                    }\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB remove error\", ioe);\n                return false;\n            } catch (RuntimeException re) {\n                _log.error(\"DB remove error\", re);\n                return false;\n            }\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * @param options If non-null and contains the key \"list\", get\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     *                Key \"skip\": skip that many entries\n     *                Key \"limit\": max number to return\n     *                Key \"search\": return only those matching substring\n     *                Key \"startsWith\": return only those starting with\n     *                                  (\"[0-9]\" allowed)\n     *                Key \"beginWith\": start here in the iteration\n     *                Don't use both startsWith and beginWith.\n     *                Search, startsWith, and beginWith values must be lower case.\n     *  @since 0.9.20\n     */\n    @Override\n    public Set<String> getNames(Properties options) {\n        String listname = FALLBACK_LIST;\n        String search = null;\n        String startsWith = null;\n        String beginWith = null;\n        int limit = Integer.MAX_VALUE;\n        int skip = 0;\n        if (options != null) {\n            String ln = options.getProperty(\"list\");\n            if (ln != null)\n                listname = ln;\n            search = options.getProperty(\"search\");\n            startsWith = options.getProperty(\"startsWith\");\n            beginWith = options.getProperty(\"beginWith\");\n            if (beginWith == null && startsWith != null) {\n                if (startsWith.equals(\"[0-9]\"))\n                    beginWith = \"0\";\n                else\n                    beginWith = startsWith;\n            }\n            String lim = options.getProperty(\"limit\");\n            try {\n                limit = Integer.parseInt(lim);\n            } catch (NumberFormatException nfe) {}\n            String sk = options.getProperty(\"skip\");\n            try {\n                skip = Integer.parseInt(sk);\n            } catch (NumberFormatException nfe) {}\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return Collections.emptySet();\n            try {\n                SkipList sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No skiplist found for lookup in \" + listname);\n                    return Collections.emptySet();\n                }\n                SkipIterator iter;\n                if (beginWith != null)\n                    iter = sl.find(beginWith);\n                else\n                    iter = sl.iterator();\n                Set<String> rv = new HashSet<String>();\n                for (int i = 0; i < skip && iter.hasNext(); i++) {\n                    iter.next();\n                }\n                for (int i = 0; i < limit && iter.hasNext(); ) {\n                    String key = (String) iter.nextKey();\n                    if (startsWith != null) {\n                        if (startsWith.equals(\"[0-9]\")) {\n                            if (key.charAt(0) > '9')\n                                break;\n                        } else if (!key.startsWith(startsWith)) {\n                            break;\n                        }\n                    }\n                    if (search != null && key.indexOf(search) < 0)\n                        continue;\n                    rv.add(key);\n                    i++;\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB lookup error\", ioe);\n                return Collections.emptySet();\n            } catch (RuntimeException re) {\n                _log.error(\"DB lookup error\", re);\n                return Collections.emptySet();\n            }\n        }\n    }","id":31787,"modified_method":"/**\n     * @param options If non-null and contains the key \"list\", get\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     *                Key \"skip\": skip that many entries\n     *                Key \"limit\": max number to return\n     *                Key \"search\": return only those matching substring\n     *                Key \"startsWith\": return only those starting with\n     *                                  (\"[0-9]\" allowed)\n     *                Key \"beginWith\": start here in the iteration\n     *                Don't use both startsWith and beginWith.\n     *                Search, startsWith, and beginWith values must be lower case.\n     *  @since 0.9.20\n     */\n    @Override\n    public Set<String> getNames(Properties options) {\n        String listname = FALLBACK_LIST;\n        String search = null;\n        String startsWith = null;\n        String beginWith = null;\n        int limit = Integer.MAX_VALUE;\n        int skip = 0;\n        if (options != null) {\n            String ln = options.getProperty(\"list\");\n            if (ln != null)\n                listname = ln;\n            search = options.getProperty(\"search\");\n            startsWith = options.getProperty(\"startsWith\");\n            beginWith = options.getProperty(\"beginWith\");\n            if (beginWith == null && startsWith != null) {\n                if (startsWith.equals(\"[0-9]\"))\n                    beginWith = \"0\";\n                else\n                    beginWith = startsWith;\n            }\n            String lim = options.getProperty(\"limit\");\n            try {\n                limit = Integer.parseInt(lim);\n            } catch (NumberFormatException nfe) {}\n            String sk = options.getProperty(\"skip\");\n            try {\n                skip = Integer.parseInt(sk);\n            } catch (NumberFormatException nfe) {}\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return Collections.emptySet();\n            try {\n                SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No skiplist found for lookup in \" + listname);\n                    return Collections.emptySet();\n                }\n                SkipIterator<String, DestEntry> iter;\n                if (beginWith != null)\n                    iter = sl.find(beginWith);\n                else\n                    iter = sl.iterator();\n                Set<String> rv = new HashSet<String>();\n                for (int i = 0; i < skip && iter.hasNext(); i++) {\n                    iter.next();\n                }\n                for (int i = 0; i < limit && iter.hasNext(); ) {\n                    String key = iter.nextKey();\n                    if (startsWith != null) {\n                        if (startsWith.equals(\"[0-9]\")) {\n                            if (key.charAt(0) > '9')\n                                break;\n                        } else if (!key.startsWith(startsWith)) {\n                            break;\n                        }\n                    }\n                    if (search != null && key.indexOf(search) < 0)\n                        continue;\n                    rv.add(key);\n                    i++;\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB lookup error\", ioe);\n                return Collections.emptySet();\n            } catch (RuntimeException re) {\n                _log.error(\"DB lookup error\", re);\n                return Collections.emptySet();\n            }\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Caller must synchronize\n     *  @param source may be null\n     */\n    private void addEntry(BlockFile bf, String listname, String key, Destination dest, String source) throws IOException {\n        try {\n            // catch IOE and delete index??\n            SkipList sl = bf.getIndex(listname, _stringSerializer, _destSerializer);\n            if (sl == null) {\n                //_log.info(\"Making new skiplist \" + listname);\n                sl = bf.makeIndex(listname, _stringSerializer, _destSerializer);\n            }\n            Properties props = new Properties();\n            props.setProperty(PROP_ADDED, Long.toString(_context.clock().now()));\n            if (source != null)\n                props.setProperty(PROP_SOURCE, source);\n            addEntry(sl, key, dest, props);\n        } catch (IOException ioe) {\n            _log.error(\"DB add error\", ioe);\n            // delete index??\n            throw ioe;\n        } catch (RuntimeException e) {\n            _log.error(\"DB add error\", e);\n            throw new IOException(e.toString());\n        }\n    }","id":31788,"modified_method":"/**\n     *  Caller must synchronize\n     *  @param source may be null\n     */\n    private void addEntry(BlockFile bf, String listname, String key, Destination dest, String source) throws IOException {\n        try {\n            // catch IOE and delete index??\n            SkipList<String, DestEntry> sl = bf.getIndex(listname, _stringSerializer, _destSerializer);\n            if (sl == null) {\n                //_log.info(\"Making new skiplist \" + listname);\n                sl = bf.makeIndex(listname, _stringSerializer, _destSerializer);\n            }\n            Properties props = new Properties();\n            props.setProperty(PROP_ADDED, Long.toString(_context.clock().now()));\n            if (source != null)\n                props.setProperty(PROP_SOURCE, source);\n            addEntry(sl, key, dest, props);\n        } catch (IOException ioe) {\n            _log.error(\"DB add error\", ioe);\n            // delete index??\n            throw ioe;\n        } catch (RuntimeException e) {\n            _log.error(\"DB add error\", e);\n            throw new IOException(e.toString());\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Create a new database and initialize it from the local files\n     *  privatehosts.txt, userhosts.txt, and hosts.txt,\n     *  creating a skiplist in the database for each.\n     */\n    private BlockFile initNew(RAIFile f) throws IOException {\n        long start = _context.clock().now();\n        _version = VERSION;\n        _destSerializer = _destSerializerV4;\n        try {\n            BlockFile rv = new BlockFile(f, true);\n            SkipList hdr = rv.makeIndex(INFO_SKIPLIST, _stringSerializer, _infoSerializer);\n            Properties info = new Properties();\n            info.setProperty(PROP_VERSION, VERSION);\n            info.setProperty(PROP_CREATED, Long.toString(_context.clock().now()));\n            String list = _context.getProperty(HostsTxtNamingService.PROP_HOSTS_FILE,\n                                               HostsTxtNamingService.DEFAULT_HOSTS_FILE);\n            info.setProperty(PROP_LISTS, list);\n            hdr.put(PROP_INFO, info);\n            rv.makeIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n\n            int total = 0;\n            for (String hostsfile : getFilenames(list)) {\n                File file = new File(_context.getRouterDir(), hostsfile);\n                if ((!file.exists()) || !(file.canRead()))\n                    continue;\n                int count = 0;\n                BufferedReader in = null;\n                String sourceMsg = \"Imported from \" + hostsfile + \" file\";\n                try {\n                    in = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"), 16*1024);\n                    String line = null;\n                    while ( (line = in.readLine()) != null) {\n                        if (line.startsWith(\"#\"))\n                            continue;\n                        int split = line.indexOf('=');\n                        if (split <= 0)\n                            continue;\n                        String key = line.substring(0, split).toLowerCase(Locale.US);\n                        if (line.indexOf('#') > 0)  { // trim off any end of line comment\n                            line = line.substring(0, line.indexOf('#')).trim();\n                            if (line.length() < split + 1)\n                                continue;\n                        }\n                        String b64 = line.substring(split+1).trim();\n                        Destination d = lookupBase64(b64);\n                        if (d != null) {\n                            addEntry(rv, hostsfile, key, d, sourceMsg);\n                            addReverseEntry(rv, key, d, _log);\n                            count++;\n                        } else {\n                            _log.logAlways(Log.WARN, \"Unable to import entry for \" + key +\n                                                     \" from file \" + file + \" - bad Base 64: \" + b64);\n                        }\n                    }\n                } catch (IOException ioe) {\n                    _log.error(\"Failed to read hosts from \" + file, ioe);\n                } finally {\n                    if (in != null) try { in.close(); } catch (IOException ioe) {}\n                }\n                total += count;\n                _log.logAlways(Log.INFO, \"Migrating \" + count + \" hosts from \" + file + \" to new hosts database\");\n                _lists.add(hostsfile);\n            }\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"DB init took \" + DataHelper.formatDuration(_context.clock().now() - start));\n            if (total <= 0)\n                _log.logAlways(Log.WARN, \"No hosts.txt files found, Initialized hosts database with zero entries\");\n            return rv;\n        } catch (RuntimeException e) {\n            _log.error(\"Failed to initialize database\", e);\n            throw new IOException(e.toString());\n        }\n    }","id":31789,"modified_method":"/**\n     *  Create a new database and initialize it from the local files\n     *  privatehosts.txt, userhosts.txt, and hosts.txt,\n     *  creating a skiplist in the database for each.\n     */\n    private BlockFile initNew(RAIFile f) throws IOException {\n        long start = _context.clock().now();\n        _version = VERSION;\n        _destSerializer = _destSerializerV4;\n        try {\n            BlockFile rv = new BlockFile(f, true);\n            SkipList<String, Properties> hdr = rv.makeIndex(INFO_SKIPLIST, _stringSerializer, _infoSerializer);\n            Properties info = new Properties();\n            info.setProperty(PROP_VERSION, VERSION);\n            info.setProperty(PROP_CREATED, Long.toString(_context.clock().now()));\n            String list = _context.getProperty(HostsTxtNamingService.PROP_HOSTS_FILE,\n                                               HostsTxtNamingService.DEFAULT_HOSTS_FILE);\n            info.setProperty(PROP_LISTS, list);\n            hdr.put(PROP_INFO, info);\n            rv.makeIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n\n            int total = 0;\n            for (String hostsfile : getFilenames(list)) {\n                File file = new File(_context.getRouterDir(), hostsfile);\n                if ((!file.exists()) || !(file.canRead()))\n                    continue;\n                int count = 0;\n                BufferedReader in = null;\n                String sourceMsg = \"Imported from \" + hostsfile + \" file\";\n                try {\n                    in = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"), 16*1024);\n                    String line = null;\n                    while ( (line = in.readLine()) != null) {\n                        if (line.startsWith(\"#\"))\n                            continue;\n                        int split = line.indexOf('=');\n                        if (split <= 0)\n                            continue;\n                        String key = line.substring(0, split).toLowerCase(Locale.US);\n                        if (line.indexOf('#') > 0)  { // trim off any end of line comment\n                            line = line.substring(0, line.indexOf('#')).trim();\n                            if (line.length() < split + 1)\n                                continue;\n                        }\n                        String b64 = line.substring(split+1).trim();\n                        Destination d = lookupBase64(b64);\n                        if (d != null) {\n                            addEntry(rv, hostsfile, key, d, sourceMsg);\n                            addReverseEntry(rv, key, d, _log);\n                            count++;\n                        } else {\n                            _log.logAlways(Log.WARN, \"Unable to import entry for \" + key +\n                                                     \" from file \" + file + \" - bad Base 64: \" + b64);\n                        }\n                    }\n                } catch (IOException ioe) {\n                    _log.error(\"Failed to read hosts from \" + file, ioe);\n                } finally {\n                    if (in != null) try { in.close(); } catch (IOException ioe) {}\n                }\n                total += count;\n                _log.logAlways(Log.INFO, \"Migrating \" + count + \" hosts from \" + file + \" to new hosts database\");\n                _lists.add(hostsfile);\n            }\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"DB init took \" + DataHelper.formatDuration(_context.clock().now() - start));\n            if (total <= 0)\n                _log.logAlways(Log.WARN, \"No hosts.txt files found, Initialized hosts database with zero entries\");\n            return rv;\n        } catch (RuntimeException e) {\n            _log.error(\"Failed to initialize database\", e);\n            throw new IOException(e.toString());\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * @param options If non-null and contains the key \"list\", get\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     *                Key \"skip\": skip that many entries\n     *                Key \"limit\": max number to return\n     *                Key \"search\": return only those matching substring\n     *                Key \"startsWith\": return only those starting with\n     *                                  (\"[0-9]\" allowed)\n     *                Key \"beginWith\": start here in the iteration\n     *                Don't use both startsWith and beginWith.\n     *                Search, startsWith, and beginWith values must be lower case.\n     */\n    @Override\n    public Map<String, Destination> getEntries(Properties options) {\n        String listname = FALLBACK_LIST;\n        String search = null;\n        String startsWith = null;\n        String beginWith = null;\n        int limit = Integer.MAX_VALUE;\n        int skip = 0;\n        if (options != null) {\n            String ln = options.getProperty(\"list\");\n            if (ln != null)\n                listname = ln;\n            search = options.getProperty(\"search\");\n            startsWith = options.getProperty(\"startsWith\");\n            beginWith = options.getProperty(\"beginWith\");\n            if (beginWith == null && startsWith != null) {\n                if (startsWith.equals(\"[0-9]\"))\n                    beginWith = \"0\";\n                else\n                    beginWith = startsWith;\n            }\n            String lim = options.getProperty(\"limit\");\n            try {\n                limit = Integer.parseInt(lim);\n            } catch (NumberFormatException nfe) {}\n            String sk = options.getProperty(\"skip\");\n            try {\n                skip = Integer.parseInt(sk);\n            } catch (NumberFormatException nfe) {}\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Searching \" + listname + \" beginning with \" + beginWith +\n                       \" starting with \" + startsWith + \" search string \" + search +\n                       \" limit=\" + limit + \" skip=\" + skip);\n        synchronized(_bf) {\n            if (_isClosed)\n                return Collections.emptyMap();\n            try {\n                SkipList sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No skiplist found for lookup in \" + listname);\n                    return Collections.emptyMap();\n                }\n                SkipIterator iter;\n                if (beginWith != null)\n                    iter = sl.find(beginWith);\n                else\n                    iter = sl.iterator();\n                Map<String, Destination> rv = new TreeMap<String, Destination>();\n                for (int i = 0; i < skip && iter.hasNext(); i++) {\n                    // don't bother validating here\n                    iter.next();\n                }\n                for (int i = 0; i < limit && iter.hasNext(); ) {\n                    String key = (String) iter.nextKey();\n                    if (startsWith != null) {\n                        if (startsWith.equals(\"[0-9]\")) {\n                            if (key.charAt(0) > '9')\n                                break;\n                        } else if (!key.startsWith(startsWith)) {\n                            break;\n                        }\n                    }\n                    DestEntry de = (DestEntry) iter.next();\n                    if (!validate(key, de, listname))\n                        continue;\n                    if (search != null && key.indexOf(search) < 0)\n                        continue;\n                    rv.put(key, de.dest);\n                    i++;\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB lookup error\", ioe);\n                return Collections.emptyMap();\n            } catch (RuntimeException re) {\n                _log.error(\"DB lookup error\", re);\n                return Collections.emptyMap();\n            } finally {\n                deleteInvalid();\n            }\n        }\n    }","id":31790,"modified_method":"/**\n     * @param options If non-null and contains the key \"list\", get\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     *                Key \"skip\": skip that many entries\n     *                Key \"limit\": max number to return\n     *                Key \"search\": return only those matching substring\n     *                Key \"startsWith\": return only those starting with\n     *                                  (\"[0-9]\" allowed)\n     *                Key \"beginWith\": start here in the iteration\n     *                Don't use both startsWith and beginWith.\n     *                Search, startsWith, and beginWith values must be lower case.\n     */\n    @Override\n    public Map<String, Destination> getEntries(Properties options) {\n        String listname = FALLBACK_LIST;\n        String search = null;\n        String startsWith = null;\n        String beginWith = null;\n        int limit = Integer.MAX_VALUE;\n        int skip = 0;\n        if (options != null) {\n            String ln = options.getProperty(\"list\");\n            if (ln != null)\n                listname = ln;\n            search = options.getProperty(\"search\");\n            startsWith = options.getProperty(\"startsWith\");\n            beginWith = options.getProperty(\"beginWith\");\n            if (beginWith == null && startsWith != null) {\n                if (startsWith.equals(\"[0-9]\"))\n                    beginWith = \"0\";\n                else\n                    beginWith = startsWith;\n            }\n            String lim = options.getProperty(\"limit\");\n            try {\n                limit = Integer.parseInt(lim);\n            } catch (NumberFormatException nfe) {}\n            String sk = options.getProperty(\"skip\");\n            try {\n                skip = Integer.parseInt(sk);\n            } catch (NumberFormatException nfe) {}\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Searching \" + listname + \" beginning with \" + beginWith +\n                       \" starting with \" + startsWith + \" search string \" + search +\n                       \" limit=\" + limit + \" skip=\" + skip);\n        synchronized(_bf) {\n            if (_isClosed)\n                return Collections.emptyMap();\n            try {\n                SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No skiplist found for lookup in \" + listname);\n                    return Collections.emptyMap();\n                }\n                SkipIterator<String, DestEntry> iter;\n                if (beginWith != null)\n                    iter = sl.find(beginWith);\n                else\n                    iter = sl.iterator();\n                Map<String, Destination> rv = new TreeMap<String, Destination>();\n                for (int i = 0; i < skip && iter.hasNext(); i++) {\n                    // don't bother validating here\n                    iter.next();\n                }\n                for (int i = 0; i < limit && iter.hasNext(); ) {\n                    String key = iter.nextKey();\n                    if (startsWith != null) {\n                        if (startsWith.equals(\"[0-9]\")) {\n                            if (key.charAt(0) > '9')\n                                break;\n                        } else if (!key.startsWith(startsWith)) {\n                            break;\n                        }\n                    }\n                    DestEntry de = iter.next();\n                    if (!validate(key, de, listname))\n                        continue;\n                    if (search != null && key.indexOf(search) < 0)\n                        continue;\n                    rv.put(key, de.dest);\n                    i++;\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB lookup error\", ioe);\n                return Collections.emptyMap();\n            } catch (RuntimeException re) {\n                _log.error(\"DB lookup error\", re);\n                return Collections.emptyMap();\n            } finally {\n                deleteInvalid();\n            }\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Caller must synchronize.\n     *  Fails without exception on error (logs only)\n     *  @since 0.8.9\n     */\n    private void removeReverseEntry(String key, Destination dest) {\n        //_log.info(\"Remove reverse \" + key);\n        try {\n            SkipList rev = _bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n            if (rev == null)\n                return;\n            Integer idx = getReverseKey(dest);\n            Properties props = (Properties) rev.get(idx);\n            if (props == null || props.remove(key) == null)\n                return;\n            if (props.isEmpty())\n                rev.remove(idx);\n            else\n                rev.put(idx, props);\n        } catch (IOException ioe) {\n            _log.error(\"DB remove reverse error\", ioe);\n        } catch (RuntimeException e) {\n            _log.error(\"DB remove reverse error\", e);\n        }\n    }","id":31791,"modified_method":"/**\n     *  Caller must synchronize.\n     *  Fails without exception on error (logs only)\n     *  @since 0.8.9\n     */\n    private void removeReverseEntry(String key, Destination dest) {\n        //_log.info(\"Remove reverse \" + key);\n        try {\n            SkipList<Integer, Properties> rev = _bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n            if (rev == null)\n                return;\n            Integer idx = getReverseKey(dest);\n            Properties props = rev.get(idx);\n            if (props == null || props.remove(key) == null)\n                return;\n            if (props.isEmpty())\n                rev.remove(idx);\n            else\n                rev.put(idx, props);\n        } catch (IOException ioe) {\n            _log.error(\"DB remove reverse error\", ioe);\n        } catch (RuntimeException e) {\n            _log.error(\"DB remove reverse error\", e);\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Caller must synchronize.\n     *  Fails without exception on error (logs only).\n     *  Returns without logging if no reverse skiplist (version 1).\n     *\n     *  We store one or more hostnames for a given hash.\n     *  The skiplist key is a signed Integer, the first 4 bytes of the dest hash.\n     *  For convenience (since we have a serializer already) we use\n     *  a Properties as the value, with a null string as the value for each hostname property.\n     *  We could in the future use the property value for something.\n     *  @since 0.8.9\n     */\n    private static void addReverseEntry(BlockFile bf, String key, Destination dest, Log log) {\n        //log.info(\"Add reverse \" + key);\n        try {\n            SkipList rev = bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n            if (rev == null)\n                return;\n            Integer idx = getReverseKey(dest);\n            Properties props = (Properties) rev.get(idx);\n            if (props != null) {\n                if (props.getProperty(key) != null)\n                    return;\n            } else {\n                props = new Properties();\n            }\n            props.put(key, \"\");\n            rev.put(idx, props);\n        } catch (IOException ioe) {\n            log.error(\"DB add reverse error\", ioe);\n        } catch (RuntimeException e) {\n            log.error(\"DB add reverse error\", e);\n        }\n    }","id":31792,"modified_method":"/**\n     *  Caller must synchronize.\n     *  Fails without exception on error (logs only).\n     *  Returns without logging if no reverse skiplist (version 1).\n     *\n     *  We store one or more hostnames for a given hash.\n     *  The skiplist key is a signed Integer, the first 4 bytes of the dest hash.\n     *  For convenience (since we have a serializer already) we use\n     *  a Properties as the value, with a null string as the value for each hostname property.\n     *  We could in the future use the property value for something.\n     *  @since 0.8.9\n     */\n    private static void addReverseEntry(BlockFile bf, String key, Destination dest, Log log) {\n        //log.info(\"Add reverse \" + key);\n        try {\n            SkipList<Integer, Properties> rev = bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n            if (rev == null)\n                return;\n            Integer idx = getReverseKey(dest);\n            Properties props = rev.get(idx);\n            if (props != null) {\n                if (props.getProperty(key) != null)\n                    return;\n            } else {\n                props = new Properties();\n            }\n            props.put(key, \"\");\n            rev.put(idx, props);\n        } catch (IOException ioe) {\n            log.error(\"DB add reverse error\", ioe);\n        } catch (RuntimeException e) {\n            log.error(\"DB add reverse error\", e);\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** returns null on error */\n        public Object construct(byte[] b) {\n            Properties rv = new Properties();\n            try {\n                DataHelper.fromProperties(b, 0, rv);\n            } catch (DataFormatException dfe) {\n                logError(\"DB Read Fail\", dfe);\n                return null;\n            }\n            return rv;\n        }","id":31793,"modified_method":"/** returns null on error */\n        public Properties construct(byte[] b) {\n            Properties rv = new Properties();\n            try {\n                DataHelper.fromProperties(b, 0, rv);\n            } catch (DataFormatException dfe) {\n                logError(\"DB Read Fail\", dfe);\n                return null;\n            }\n            return rv;\n        }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Caller must synchronize\n     *  @return entry or null, or throws ioe\n     */\n    private DestEntry getEntry(String listname, String key) throws IOException {\n        try {\n            SkipList sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n            if (sl == null)\n                return null;\n            DestEntry rv = (DestEntry) sl.get(key);\n            return rv;\n        } catch (IOException ioe) {\n            _log.error(\"DB Lookup error\", ioe);\n            // delete index??\n            throw ioe;\n        } catch (RuntimeException e) {\n            _log.error(\"DB Lookup error\", e);\n            throw new IOException(e.toString());\n        }\n    }","id":31794,"modified_method":"/**\n     *  Caller must synchronize\n     *  @return entry or null, or throws ioe\n     */\n    private DestEntry getEntry(String listname, String key) throws IOException {\n        try {\n            SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n            if (sl == null)\n                return null;\n            DestEntry rv = sl.get(key);\n            return rv;\n        } catch (IOException ioe) {\n            _log.error(\"DB Lookup error\", ioe);\n            // delete index??\n            throw ioe;\n        } catch (RuntimeException e) {\n            _log.error(\"DB Lookup error\", e);\n            throw new IOException(e.toString());\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private boolean put(String hostname, Destination d, Properties options, boolean checkExisting) {\n        if (_readOnly) {\n            _log.error(\"Add entry failed, read-only hosts database\");\n            return false;\n        }\n        String key = hostname.toLowerCase(Locale.US);\n        synchronized(_negativeCache) {\n            _negativeCache.remove(key);\n        }\n        String listname = FALLBACK_LIST;\n        Properties props = new Properties();\n        props.setProperty(PROP_ADDED, Long.toString(_context.clock().now()));\n        if (options != null) {\n            props.putAll(options);\n            String list = options.getProperty(\"list\");\n            if (list != null) {\n                listname = list;\n                props.remove(\"list\");\n            }\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return false;\n            try {\n                SkipList sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null)\n                    sl = _bf.makeIndex(listname, _stringSerializer, _destSerializer);\n                boolean changed =  (checkExisting || !_listeners.isEmpty()) && sl.get(key) != null;\n                if (changed && checkExisting)\n                        return false;\n                addEntry(sl, key, d, props);\n                if (changed) {\n                    removeCache(hostname);\n                    // removeReverseEntry(key, oldDest) ???\n                }\n                addReverseEntry(key, d);\n                for (NamingServiceListener nsl : _listeners) { \n                    if (changed)\n                        nsl.entryChanged(this, hostname, d, options);\n                    else\n                        nsl.entryAdded(this, hostname, d, options);\n                }\n                return true;\n            } catch (IOException ioe) {\n                _log.error(\"DB add error\", ioe);\n                return false;\n            } catch (RuntimeException re) {\n                _log.error(\"DB add error\", re);\n                return false;\n            }\n        }\n    }","id":31795,"modified_method":"private boolean put(String hostname, Destination d, Properties options, boolean checkExisting) {\n        if (_readOnly) {\n            _log.error(\"Add entry failed, read-only hosts database\");\n            return false;\n        }\n        String key = hostname.toLowerCase(Locale.US);\n        synchronized(_negativeCache) {\n            _negativeCache.remove(key);\n        }\n        String listname = FALLBACK_LIST;\n        Properties props = new Properties();\n        props.setProperty(PROP_ADDED, Long.toString(_context.clock().now()));\n        if (options != null) {\n            props.putAll(options);\n            String list = options.getProperty(\"list\");\n            if (list != null) {\n                listname = list;\n                props.remove(\"list\");\n            }\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return false;\n            try {\n                SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null)\n                    sl = _bf.makeIndex(listname, _stringSerializer, _destSerializer);\n                boolean changed =  (checkExisting || !_listeners.isEmpty()) && sl.get(key) != null;\n                if (changed && checkExisting)\n                        return false;\n                addEntry(sl, key, d, props);\n                if (changed) {\n                    removeCache(hostname);\n                    // removeReverseEntry(key, oldDest) ???\n                }\n                addReverseEntry(key, d);\n                for (NamingServiceListener nsl : _listeners) { \n                    if (changed)\n                        nsl.entryChanged(this, hostname, d, options);\n                    else\n                        nsl.entryAdded(this, hostname, d, options);\n                }\n                return true;\n            } catch (IOException ioe) {\n                _log.error(\"DB add error\", ioe);\n                return false;\n            } catch (RuntimeException re) {\n                _log.error(\"DB add error\", re);\n                return false;\n            }\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Caller must synchronize\n     *  @param props may be null\n     *  @throws RuntimeException\n     */\n    private static void addEntry(SkipList sl, String key, Destination dest, Properties props) {\n        DestEntry de = new DestEntry();\n        de.dest = dest;\n        de.props = props;\n        sl.put(key, de);\n    }","id":31796,"modified_method":"/**\n     *  Caller must synchronize\n     *  @param props may be null\n     *  @throws RuntimeException\n     */\n    private static void addEntry(SkipList<String, DestEntry> sl, String key, Destination dest, Properties props) {\n        DestEntry de = new DestEntry();\n        de.dest = dest;\n        de.props = props;\n        sl.put(key, de);\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Caller must synchronize\n     *  @return removed object or null\n     *  @throws RuntimeException\n     */\n    private static Object removeEntry(SkipList sl, String key) {\n        return sl.remove(key);\n    }","id":31797,"modified_method":"/**\n     *  Caller must synchronize\n     *  @return removed object or null\n     *  @throws RuntimeException\n     */\n    private static Object removeEntry(SkipList<String, ?> sl, String key) {\n        return sl.remove(key);\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Blockfile must be writable of course.\n     *\n     *  Version 1->2: Add reverse skiplist and populate\n     *  Version 2->3: Re-populate reverse skiplist as version 2 didn't keep it updated\n     *                after the upgrade. No change to format.\n     *  Version 3->4: Change format to support multiple destinations per hostname\n     *\n     *  @return true if upgraded successfully\n     *  @since 0.8.9\n     */\n    private boolean upgrade() {\n        try {\n            // version 1 -> version 2\n            // Add reverse skiplist\n            if (VersionComparator.comp(_version, \"2\") < 0) {\n                SkipList rev = _bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n                if (rev == null) {\n                    rev = _bf.makeIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Created reverse index\");\n                }\n                setVersion(\"2\");\n            }\n\n            // version 2 -> version 3\n            // no change in format, just regenerate skiplist\n            if (VersionComparator.comp(_version, \"3\") < 0) {\n                Map<String, Destination> entries = getEntries();\n                int i = 0;\n                for (Map.Entry<String, Destination> entry : entries.entrySet()) {\n                     addReverseEntry(entry.getKey(), entry.getValue());\n                     i++;\n                }\n                // i may be greater than skiplist keys if there are dups\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Updated reverse index with \" + i + \" entries\");\n                setVersion(\"3\");\n            }\n\n            // version 3 -> version 4\n            // support multiple destinations per hostname\n            if (VersionComparator.comp(_version, \"4\") < 0) {\n                for (String list : _lists) { \n                    try {\n                        if (_log.shouldWarn())\n                            _log.warn(\"Upgrading \" + list + \" from database version 3 to 4\");\n                        _bf.reformatIndex(list, _stringSerializer, _destSerializerV1,\n                                          _stringSerializer, _destSerializerV4);\n                    } catch (IOException ioe) {\n                        _log.error(\"Failed upgrade of list \" + list + \" to version 4\", ioe);\n                    }\n                }\n                _destSerializer = _destSerializerV4;\n                setVersion(\"4\");\n            }\n\n            return true;\n        } catch (IOException ioe) {\n            _log.error(\"Error upgrading DB\", ioe);\n        } catch (RuntimeException e) {\n            _log.error(\"Error upgrading DB\", e);\n        }\n        return false;\n    }","id":31798,"modified_method":"/**\n     *  Blockfile must be writable of course.\n     *\n     *  Version 1->2: Add reverse skiplist and populate\n     *  Version 2->3: Re-populate reverse skiplist as version 2 didn't keep it updated\n     *                after the upgrade. No change to format.\n     *  Version 3->4: Change format to support multiple destinations per hostname\n     *\n     *  @return true if upgraded successfully\n     *  @since 0.8.9\n     */\n    private boolean upgrade() {\n        try {\n            // version 1 -> version 2\n            // Add reverse skiplist\n            if (VersionComparator.comp(_version, \"2\") < 0) {\n                SkipList<Integer, Properties> rev = _bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n                if (rev == null) {\n                    rev = _bf.makeIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Created reverse index\");\n                }\n                setVersion(\"2\");\n            }\n\n            // version 2 -> version 3\n            // no change in format, just regenerate skiplist\n            if (VersionComparator.comp(_version, \"3\") < 0) {\n                Map<String, Destination> entries = getEntries();\n                int i = 0;\n                for (Map.Entry<String, Destination> entry : entries.entrySet()) {\n                     addReverseEntry(entry.getKey(), entry.getValue());\n                     i++;\n                }\n                // i may be greater than skiplist keys if there are dups\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Updated reverse index with \" + i + \" entries\");\n                setVersion(\"3\");\n            }\n\n            // version 3 -> version 4\n            // support multiple destinations per hostname\n            if (VersionComparator.comp(_version, \"4\") < 0) {\n                for (String list : _lists) { \n                    try {\n                        if (_log.shouldWarn())\n                            _log.warn(\"Upgrading \" + list + \" from database version 3 to 4\");\n                        _bf.reformatIndex(list, _stringSerializer, _destSerializerV1,\n                                          _stringSerializer, _destSerializerV4);\n                    } catch (IOException ioe) {\n                        _log.error(\"Failed upgrade of list \" + list + \" to version 4\", ioe);\n                    }\n                }\n                _destSerializer = _destSerializerV4;\n                setVersion(\"4\");\n            }\n\n            return true;\n        } catch (IOException ioe) {\n            _log.error(\"Error upgrading DB\", ioe);\n        } catch (RuntimeException e) {\n            _log.error(\"Error upgrading DB\", e);\n        }\n        return false;\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * @param options If non-null and contains the key \"list\", get\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     *                Key \"skip\": skip that many entries\n     *                Key \"limit\": max number to return\n     *                Key \"search\": return only those matching substring\n     *                Key \"startsWith\": return only those starting with\n     *                                  (\"[0-9]\" allowed)\n     *                Key \"beginWith\": start here in the iteration\n     *                Don't use both startsWith and beginWith.\n     *                Search, startsWith, and beginWith values must be lower case.\n     *  @since 0.9.20\n     */\n    @Override\n    public Map<String, String> getBase64Entries(Properties options) {\n        String listname = FALLBACK_LIST;\n        String search = null;\n        String startsWith = null;\n        String beginWith = null;\n        int limit = Integer.MAX_VALUE;\n        int skip = 0;\n        if (options != null) {\n            String ln = options.getProperty(\"list\");\n            if (ln != null)\n                listname = ln;\n            search = options.getProperty(\"search\");\n            startsWith = options.getProperty(\"startsWith\");\n            beginWith = options.getProperty(\"beginWith\");\n            if (beginWith == null && startsWith != null) {\n                if (startsWith.equals(\"[0-9]\"))\n                    beginWith = \"0\";\n                else\n                    beginWith = startsWith;\n            }\n            String lim = options.getProperty(\"limit\");\n            try {\n                limit = Integer.parseInt(lim);\n            } catch (NumberFormatException nfe) {}\n            String sk = options.getProperty(\"skip\");\n            try {\n                skip = Integer.parseInt(sk);\n            } catch (NumberFormatException nfe) {}\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return Collections.emptyMap();\n            try {\n                SkipList sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No skiplist found for lookup in \" + listname);\n                    return Collections.emptyMap();\n                }\n                SkipIterator iter;\n                if (beginWith != null)\n                    iter = sl.find(beginWith);\n                else\n                    iter = sl.iterator();\n                Map<String, String> rv = new TreeMap<String, String>();\n                for (int i = 0; i < skip && iter.hasNext(); i++) {\n                    // don't bother validating here\n                    iter.next();\n                }\n                for (int i = 0; i < limit && iter.hasNext(); ) {\n                    String key = (String) iter.nextKey();\n                    if (startsWith != null) {\n                        if (startsWith.equals(\"[0-9]\")) {\n                            if (key.charAt(0) > '9')\n                                break;\n                        } else if (!key.startsWith(startsWith)) {\n                            break;\n                        }\n                    }\n                    DestEntry de = (DestEntry) iter.next();\n                    if (!validate(key, de, listname))\n                        continue;\n                    if (search != null && key.indexOf(search) < 0)\n                        continue;\n                    rv.put(key, de.dest.toBase64());\n                    i++;\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB lookup error\", ioe);\n                return Collections.emptyMap();\n            } catch (RuntimeException re) {\n                _log.error(\"DB lookup error\", re);\n                return Collections.emptyMap();\n            } finally {\n                deleteInvalid();\n            }\n        }\n    }","id":31799,"modified_method":"/**\n     * @param options If non-null and contains the key \"list\", get\n     *                from that list (default \"hosts.txt\", NOT all lists)\n     *                Key \"skip\": skip that many entries\n     *                Key \"limit\": max number to return\n     *                Key \"search\": return only those matching substring\n     *                Key \"startsWith\": return only those starting with\n     *                                  (\"[0-9]\" allowed)\n     *                Key \"beginWith\": start here in the iteration\n     *                Don't use both startsWith and beginWith.\n     *                Search, startsWith, and beginWith values must be lower case.\n     *  @since 0.9.20\n     */\n    @Override\n    public Map<String, String> getBase64Entries(Properties options) {\n        String listname = FALLBACK_LIST;\n        String search = null;\n        String startsWith = null;\n        String beginWith = null;\n        int limit = Integer.MAX_VALUE;\n        int skip = 0;\n        if (options != null) {\n            String ln = options.getProperty(\"list\");\n            if (ln != null)\n                listname = ln;\n            search = options.getProperty(\"search\");\n            startsWith = options.getProperty(\"startsWith\");\n            beginWith = options.getProperty(\"beginWith\");\n            if (beginWith == null && startsWith != null) {\n                if (startsWith.equals(\"[0-9]\"))\n                    beginWith = \"0\";\n                else\n                    beginWith = startsWith;\n            }\n            String lim = options.getProperty(\"limit\");\n            try {\n                limit = Integer.parseInt(lim);\n            } catch (NumberFormatException nfe) {}\n            String sk = options.getProperty(\"skip\");\n            try {\n                skip = Integer.parseInt(sk);\n            } catch (NumberFormatException nfe) {}\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return Collections.emptyMap();\n            try {\n                SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"No skiplist found for lookup in \" + listname);\n                    return Collections.emptyMap();\n                }\n                SkipIterator<String, DestEntry> iter;\n                if (beginWith != null)\n                    iter = sl.find(beginWith);\n                else\n                    iter = sl.iterator();\n                Map<String, String> rv = new TreeMap<String, String>();\n                for (int i = 0; i < skip && iter.hasNext(); i++) {\n                    // don't bother validating here\n                    iter.next();\n                }\n                for (int i = 0; i < limit && iter.hasNext(); ) {\n                    String key = iter.nextKey();\n                    if (startsWith != null) {\n                        if (startsWith.equals(\"[0-9]\")) {\n                            if (key.charAt(0) > '9')\n                                break;\n                        } else if (!key.startsWith(startsWith)) {\n                            break;\n                        }\n                    }\n                    DestEntry de = iter.next();\n                    if (!validate(key, de, listname))\n                        continue;\n                    if (search != null && key.indexOf(search) < 0)\n                        continue;\n                    rv.put(key, de.dest.toBase64());\n                    i++;\n                }\n                return rv;\n            } catch (IOException ioe) {\n                _log.error(\"DB lookup error\", ioe);\n                return Collections.emptyMap();\n            } catch (RuntimeException re) {\n                _log.error(\"DB lookup error\", re);\n                return Collections.emptyMap();\n            } finally {\n                deleteInvalid();\n            }\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Remove and log all invalid entries queued by validate()\n     *  while scanning in lookup() or getEntries().\n     *  We delete in the order detected, as an error may be corrupting later entries in the skiplist.\n     *  Caller must sync!\n     */\n    private void deleteInvalid() {\n        if (_invalid.isEmpty())\n            return;\n        _log.error(\"Removing \" + _invalid.size() + \" corrupt entries from database\");\n        for (InvalidEntry ie : _invalid) {\n            String key = ie.key;\n            String list = ie.list;\n            try {\n                SkipList sl = _bf.getIndex(list, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    _log.error(\"No list found to remove corrupt \\\"\" + key + \"\\\" from database \" + list);\n                    continue;\n                }\n                // this will often return null since it was corrupt\n                boolean success = removeEntry(sl, key) != null;\n                if (success)\n                    _log.error(\"Removed corrupt \\\"\" + key + \"\\\" from database \" + list);\n                else\n                    _log.error(\"May have Failed to remove corrupt \\\"\" + key + \"\\\" from database \" + list);\n            } catch (RuntimeException re) {\n                _log.error(\"Error while removing corrupt \\\"\" + key + \"\\\" from database \" + list, re);\n            } catch (IOException ioe) {\n                _log.error(\"Error while removing corrput \\\"\" + key + \"\\\" from database \" + list, ioe);\n            }\n        }\n        _invalid.clear();\n    }","id":31800,"modified_method":"/**\n     *  Remove and log all invalid entries queued by validate()\n     *  while scanning in lookup() or getEntries().\n     *  We delete in the order detected, as an error may be corrupting later entries in the skiplist.\n     *  Caller must sync!\n     */\n    private void deleteInvalid() {\n        if (_invalid.isEmpty())\n            return;\n        _log.error(\"Removing \" + _invalid.size() + \" corrupt entries from database\");\n        for (InvalidEntry ie : _invalid) {\n            String key = ie.key;\n            String list = ie.list;\n            try {\n                SkipList<String, DestEntry> sl = _bf.getIndex(list, _stringSerializer, _destSerializer);\n                if (sl == null) {\n                    _log.error(\"No list found to remove corrupt \\\"\" + key + \"\\\" from database \" + list);\n                    continue;\n                }\n                // this will often return null since it was corrupt\n                boolean success = removeEntry(sl, key) != null;\n                if (success)\n                    _log.error(\"Removed corrupt \\\"\" + key + \"\\\" from database \" + list);\n                else\n                    _log.error(\"May have Failed to remove corrupt \\\"\" + key + \"\\\" from database \" + list);\n            } catch (RuntimeException re) {\n                _log.error(\"Error while removing corrupt \\\"\" + key + \"\\\" from database \" + list, re);\n            } catch (IOException ioe) {\n                _log.error(\"Error while removing corrput \\\"\" + key + \"\\\" from database \" + list, ioe);\n            }\n        }\n        _invalid.clear();\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * @param options If non-null and contains the key \"list\", return the\n     *                size of that list (default \"hosts.txt\", NOT all lists)\n     */\n    @Override\n    public int size(Properties options) {\n        String listname = FALLBACK_LIST;\n        if (options != null) {\n            String list = options.getProperty(\"list\");\n            if (list != null) {\n                listname = list;\n            }\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return 0;\n            try {\n                SkipList sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null)\n                    return 0;\n                return sl.size();\n            } catch (IOException ioe) {\n                _log.error(\"DB size error\", ioe);\n                return 0;\n            } catch (RuntimeException re) {\n                _log.error(\"DB size error\", re);\n                return 0;\n            }\n        }\n    }","id":31801,"modified_method":"/**\n     * @param options If non-null and contains the key \"list\", return the\n     *                size of that list (default \"hosts.txt\", NOT all lists)\n     */\n    @Override\n    public int size(Properties options) {\n        String listname = FALLBACK_LIST;\n        if (options != null) {\n            String list = options.getProperty(\"list\");\n            if (list != null) {\n                listname = list;\n            }\n        }\n        synchronized(_bf) {\n            if (_isClosed)\n                return 0;\n            try {\n                SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\n                if (sl == null)\n                    return 0;\n                return sl.size();\n            } catch (IOException ioe) {\n                _log.error(\"DB size error\", ioe);\n                return 0;\n            } catch (RuntimeException re) {\n                _log.error(\"DB size error\", re);\n                return 0;\n            }\n        }\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Caller must synchronize.\n     *  Returns null without exception on error (logs only).\n     *  Returns without logging if no reverse skiplist (version 1).\n     *\n     *  @return the first one found if more than one\n     *  @since 0.8.9\n     */\n    private String getReverseEntry(Hash hash) {\n        try {\n            SkipList rev = _bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n            if (rev == null)\n                return null;\n            Integer idx = getReverseKey(hash);\n            //_log.info(\"Get reverse \" + idx + ' ' + hash);\n            Properties props = (Properties) rev.get(idx);\n            if (props == null)\n                return null;\n            for (Object okey : props.keySet()) {\n                String key = (String) okey;\n                // now do the forward lookup to verify (using the cache)\n                Destination d = lookup(key);\n                if (d != null && d.calculateHash().equals(hash))\n                    return key;\n            }\n        } catch (IOException ioe) {\n            _log.error(\"DB get reverse error\", ioe);\n        } catch (RuntimeException e) {\n            _log.error(\"DB get reverse error\", e);\n        }\n        return null;\n    }","id":31802,"modified_method":"/**\n     *  Caller must synchronize.\n     *  Returns null without exception on error (logs only).\n     *  Returns without logging if no reverse skiplist (version 1).\n     *\n     *  @return the first one found if more than one\n     *  @since 0.8.9\n     */\n    private String getReverseEntry(Hash hash) {\n        try {\n            SkipList<Integer, Properties> rev = _bf.getIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\n            if (rev == null)\n                return null;\n            Integer idx = getReverseKey(hash);\n            //_log.info(\"Get reverse \" + idx + ' ' + hash);\n            Properties props = rev.get(idx);\n            if (props == null)\n                return null;\n            for (Object okey : props.keySet()) {\n                String key = (String) okey;\n                // now do the forward lookup to verify (using the cache)\n                Destination d = lookup(key);\n                if (d != null && d.calculateHash().equals(hash))\n                    return key;\n            }\n        } catch (IOException ioe) {\n            _log.error(\"DB get reverse error\", ioe);\n        } catch (RuntimeException e) {\n            _log.error(\"DB get reverse error\", e);\n        }\n        return null;\n    }","commit_id":"0d19fe44c2386fd87d3b27b0a0645b81653b2837","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public FilePatternPackageSet(@NonNls String modulePattern,\n                               @NonNls String filePattern) {\n    myPathPattern = filePattern;\n    myModulePatternText = modulePattern;\n    if (modulePattern == null || modulePattern.isEmpty()) {\n      myModulePattern = null;\n    }\n    else {\n      if (modulePattern.startsWith(\"group:\")) {\n        int idx = modulePattern.indexOf(':', 6);\n        if (idx == -1) idx = modulePattern.length();\n        myModuleGroupPattern = Pattern.compile(StringUtil.replace(modulePattern.substring(6, idx), \"*\", \".*\"));\n        if (idx < modulePattern.length() - 1) {\n          myModulePattern = Pattern.compile(StringUtil.replace(modulePattern.substring(idx + 1), \"*\", \".*\"));\n        }\n      } else {\n        myModulePattern = Pattern.compile(StringUtil.replace(modulePattern, \"*\", \".*\"));\n      }\n    }\n    myFilePattern = filePattern != null ? Pattern.compile(convertToRegexp(filePattern, '/')) : null;\n  }","id":31803,"modified_method":"public FilePatternPackageSet(@NonNls String modulePattern,\n                               @NonNls String filePattern) {\n    myPathPattern = filePattern;\n    myModulePatternText = modulePattern;\n    if (modulePattern == null || modulePattern.isEmpty()) {\n      myModulePattern = null;\n    }\n    else {\n      if (modulePattern.startsWith(\"group:\")) {\n        int idx = modulePattern.indexOf(':', 6);\n        if (idx == -1) idx = modulePattern.length();\n        myModuleGroupPattern = Pattern.compile(StringUtil.escapeToRegexp(modulePattern.substring(6, idx)));\n        if (idx < modulePattern.length() - 1) {\n          myModulePattern = Pattern.compile(StringUtil.escapeToRegexp(modulePattern.substring(idx + 1)));\n        }\n      } else {\n        myModulePattern = Pattern.compile(StringUtil.escapeToRegexp(modulePattern));\n      }\n    }\n    myFilePattern = filePattern != null ? Pattern.compile(convertToRegexp(filePattern, '/')) : null;\n  }","commit_id":"a755c8491b5823f11fdfa66f76334bf64283b097","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private String parseModulePattern() throws ParsingException {\n      if (myLexer.getTokenType() != ScopeTokenTypes.LBRACKET) return null;\n      myLexer.advance();\n      StringBuffer pattern = new StringBuffer();\n      while (true) {\n        if (myLexer.getTokenType() == ScopeTokenTypes.RBRACKET ||\n            myLexer.getTokenType() == null) {\n          myLexer.advance();\n          break;\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.ASTERISK) {\n          pattern.append(\"*\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.IDENTIFIER ||\n                   myLexer.getTokenType() == TokenType.WHITE_SPACE ||\n                   myLexer.getTokenType() == ScopeTokenTypes.INTEGER_LITERAL ) {\n          pattern.append(getTokenText());\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.DOT) {\n          pattern.append(\".\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.MINUS) {\n          pattern.append(\"-\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.TILDE) {\n          pattern.append(\"~\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.SHARP) {\n          pattern.append(\"#\");\n        }\n        else if (myLexer.getTokenType() == ScopeTokenTypes.COLON) {\n          pattern.append(\":\");\n        } else {\n          error(AnalysisScopeBundle.message(\"error.packageset.token.expectations\", getTokenText()));\n          break;\n        }\n        myLexer.advance();\n      }\n      if (pattern.length() == 0) {\n        error(AnalysisScopeBundle.message(\"error.packageset.pattern.expectations\"));\n      }\n      return pattern.toString();\n    }","id":31804,"modified_method":"@Nullable\n    private String parseModulePattern() throws ParsingException {\n      if (myLexer.getTokenType() != ScopeTokenTypes.LBRACKET) return null;\n      myLexer.advance();\n      StringBuffer pattern = new StringBuffer();\n      while (true) {\n        if (myLexer.getTokenType() == ScopeTokenTypes.RBRACKET ||\n            myLexer.getTokenType() == null) {\n          myLexer.advance();\n          break;\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.ASTERISK) {\n          pattern.append(\"*\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.IDENTIFIER ||\n                   myLexer.getTokenType() == TokenType.WHITE_SPACE ||\n                   myLexer.getTokenType() == ScopeTokenTypes.INTEGER_LITERAL ) {\n          pattern.append(getTokenText());\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.DOT) {\n          pattern.append(\".\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.MINUS) {\n          pattern.append(\"-\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.TILDE) {\n          pattern.append(\"~\");\n        } else if (myLexer.getTokenType() == ScopeTokenTypes.SHARP) {\n          pattern.append(\"#\");\n        }\n        else if (myLexer.getTokenType() == ScopeTokenTypes.COLON) {\n          pattern.append(\":\");\n        } else {\n          pattern.append(getTokenText());\n        }\n        myLexer.advance();\n      }\n      if (pattern.length() == 0) {\n        error(AnalysisScopeBundle.message(\"error.packageset.pattern.expectations\"));\n      }\n      return pattern.toString();\n    }","commit_id":"a755c8491b5823f11fdfa66f76334bf64283b097","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int getElementCode(ElementType value) {\r\n        switch (value) {\r\n            case TYPE:\r\n                return AnnotationNode.TYPE_TARGET;\r\n            case CONSTRUCTOR:\r\n                return AnnotationNode.CONSTRUCTOR_TARGET;\r\n            case METHOD:\r\n                return AnnotationNode.METHOD_TARGET;\r\n            case FIELD:\r\n                return AnnotationNode.FIELD_TARGET;\r\n            case PARAMETER:\r\n                return AnnotationNode.PARAMETER_TARGET;\r\n            case LOCAL_VARIABLE:\r\n                return AnnotationNode.LOCAL_VARIABLE_TARGET;\r\n            case ANNOTATION_TYPE:\r\n                return AnnotationNode.ANNOTATION_TARGET;\r\n            case PACKAGE:\r\n                return AnnotationNode.PACKAGE_TARGET;\r\n            default:\r\n                throw new GroovyBugError(\"unsupported Target \" + value);\r\n        }\r\n    }","id":31805,"modified_method":"private static int getElementCode(ElementType value) {\r\n        switch (value) {\r\n            case TYPE:\r\n                return AnnotationNode.TYPE_TARGET;\r\n            case CONSTRUCTOR:\r\n                return AnnotationNode.CONSTRUCTOR_TARGET;\r\n            case METHOD:\r\n                return AnnotationNode.METHOD_TARGET;\r\n            case FIELD:\r\n                return AnnotationNode.FIELD_TARGET;\r\n            case PARAMETER:\r\n                return AnnotationNode.PARAMETER_TARGET;\r\n            case LOCAL_VARIABLE:\r\n                return AnnotationNode.LOCAL_VARIABLE_TARGET;\r\n            case ANNOTATION_TYPE:\r\n                return AnnotationNode.ANNOTATION_TARGET;\r\n            case PACKAGE:\r\n                return AnnotationNode.PACKAGE_TARGET;\r\n        }\r\n        if (\"MODULE\".equals(value.name())) {\r\n            return AnnotationNode.TYPE_TARGET;\r\n        } else {\r\n            throw new GroovyBugError(\"unsupported Target \" + value);\r\n        }\r\n    }","commit_id":"9efebf1738805eb2c5a42bace2eaa571e2499db2","url":"https://github.com/apache/groovy"},{"original_method":"private String[] makeParameters(List<String> files, GroovyClassLoader parentClassLoader) {\n        Map options = config.getJointCompilationOptions();\n        LinkedList<String> paras = new LinkedList<String>();\n\n        File target = config.getTargetDirectory();\n        if (target == null) target = new File(\".\");\n\n        // defaults\n        paras.add(\"-d\");\n        paras.add(target.getAbsolutePath());\n        paras.add(\"-sourcepath\");\n        paras.add(((File) options.get(\"stubDir\")).getAbsolutePath());\n\n        // add flags\n        String[] flags = (String[]) options.get(\"flags\");\n        if (flags != null) {\n            for (String flag : flags) {\n                paras.add('-' + flag);\n            }\n        }\n\n        boolean hadClasspath = false;\n        // add namedValues\n        String[] namedValues = (String[]) options.get(\"namedValues\");\n        if (namedValues != null) {\n            for (int i = 0; i < namedValues.length; i += 2) {\n                String name = namedValues[i];\n                if (name.equals(\"classpath\")) hadClasspath = true;\n                paras.add('-' + name);\n                paras.add(namedValues[i + 1]);\n            }\n        }\n\n        // append classpath if not already defined\n        if (!hadClasspath) {\n            // add all classpaths that compilation unit sees\n            StringBuilder resultPath = new StringBuilder(DefaultGroovyMethods.join((Iterable)config.getClasspath(), File.pathSeparator));\n            ClassLoader cl = parentClassLoader;\n            while (cl != null) {\n                if (cl instanceof URLClassLoader) {\n                    for (URL u : ((URLClassLoader) cl).getURLs()) {\n                        try {\n                            resultPath.append(File.pathSeparator);\n                            resultPath.append(new File(u.toURI()).getPath());\n                        } catch (URISyntaxException e) {\n                            // ignore it\n                        }\n                    }\n                }\n                cl = cl.getParent();\n            }\n\n            paras.add(\"-classpath\");\n            paras.add(resultPath.toString());\n        }\n\n        // files to compile\n        paras.addAll(files);\n\n        return paras.toArray(new String[paras.size()]);\n    }","id":31806,"modified_method":"private String[] makeParameters(List<String> files, GroovyClassLoader parentClassLoader) {\n        Map options = config.getJointCompilationOptions();\n        LinkedList<String> paras = new LinkedList<String>();\n\n        File target = config.getTargetDirectory();\n        if (target == null) target = new File(\".\");\n\n        // defaults\n        paras.add(\"-d\");\n        paras.add(target.getAbsolutePath());\n        paras.add(\"-sourcepath\");\n        paras.add(((File) options.get(\"stubDir\")).getAbsolutePath());\n\n        // add flags\n        String[] flags = (String[]) options.get(\"flags\");\n        if (flags != null) {\n            for (String flag : flags) {\n                paras.add('-' + flag);\n            }\n        }\n\n        boolean hadClasspath = false;\n        // add namedValues\n        String[] namedValues = (String[]) options.get(\"namedValues\");\n        if (namedValues != null) {\n            for (int i = 0; i < namedValues.length; i += 2) {\n                String name = namedValues[i];\n                if (name.equals(\"classpath\")) hadClasspath = true;\n                paras.add('-' + name);\n                paras.add(namedValues[i + 1]);\n            }\n        }\n\n        // append classpath if not already defined\n        if (!hadClasspath) {\n            // add all classpaths that compilation unit sees\n            List<String> paths = new ArrayList<String>(config.getClasspath());\n            ClassLoader cl = parentClassLoader;\n            while (cl != null) {\n                if (cl instanceof URLClassLoader) {\n                    for (URL u : ((URLClassLoader) cl).getURLs()) {\n                        try {\n                            paths.add(new File(u.toURI()).getPath());\n                        } catch (URISyntaxException e) {\n                            // ignore it\n                        }\n                    }\n                }\n                cl = cl.getParent();\n            }\n\n            try {\n                CodeSource codeSource =AccessController.doPrivileged(new PrivilegedAction<CodeSource>() {\n                    @Override\n                    public CodeSource run() {\n                        return GroovyObject.class.getProtectionDomain().getCodeSource();\n                    }\n                });\n                if (codeSource != null) {\n                    paths.add(new File(codeSource.getLocation().toURI()).getPath());\n                }\n            } catch (URISyntaxException e) {\n                // ignore it\n            }\n\n            StringBuilder resultPath = new StringBuilder(DefaultGroovyMethods.join((Iterable) paths, File.pathSeparator));\n            paras.add(\"-classpath\");\n            paras.add(resultPath.toString());\n        }\n\n        // files to compile\n        paras.addAll(files);\n\n        return paras.toArray(new String[paras.size()]);\n    }","commit_id":"9efebf1738805eb2c5a42bace2eaa571e2499db2","url":"https://github.com/apache/groovy"},{"original_method":"public DefaultPlayRunSpec(FileCollection classpath, File projectPath, BaseForkOptions forkOptions, int httpPort) {\n        this.classpath = Sets.newHashSet(classpath);\n        this.projectPath = projectPath;\n        this.forkOptions = forkOptions;\n        this.httpPort = httpPort;\n    }","id":31807,"modified_method":"public DefaultPlayRunSpec(FileCollection classpath, File applicationJar, File assetsJar, File projectPath, BaseForkOptions forkOptions, int httpPort) {\n        this.classpath = Sets.newHashSet(classpath);\n        this.applicationJar = applicationJar;\n        this.assetsJar = assetsJar;\n        this.projectPath = projectPath;\n        this.forkOptions = forkOptions;\n        this.httpPort = httpPort;\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"public Object getBuildLink(ClassLoader classLoader, final File projectPath, final Iterable<File> classpath) throws ClassNotFoundException {\n        reloadWithClasspath(classpath);\n        return Proxy.newProxyInstance(classLoader, new Class<?>[]{getBuildLinkClass(classLoader)}, new InvocationHandler() {\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                if (method.getName().equals(\"projectPath\")) {\n                    return projectPath;\n                } else if (method.getName().equals(\"reload\")) {\n                    Object result = reloadObject.getAndSet(null);\n                    if (result == null) {\n                        return null;\n                    } else if (result instanceof DefaultClassPath) {\n                        DefaultClassPath projectClasspath = (DefaultClassPath) result;\n                        return new URLClassLoader(projectClasspath.getAsURLs().toArray(new URL[]{}), Thread.currentThread().getContextClassLoader());\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                } else if (method.getName().equals(\"settings\")) {\n                    return new HashMap<String, String>();\n                }\n                //TODO: all methods\n                return null;\n            }\n        });\n    }","id":31808,"modified_method":"public Object getBuildLink(final ClassLoader classLoader, final File projectPath, final File applicationJar, final File assetsJar) throws ClassNotFoundException {\n        forceReloadNextTime();\n        return Proxy.newProxyInstance(classLoader, new Class<?>[]{getBuildLinkClass(classLoader)}, new InvocationHandler() {\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                if (method.getName().equals(\"projectPath\")) {\n                    return projectPath;\n                } else if (method.getName().equals(\"reload\")) {\n                    Object result = reloadObject.getAndSet(null);\n                    if (result == null) {\n                        return null;\n                    } else if (result == Boolean.TRUE) {\n                        return new URLClassLoader(new URL[]{applicationJar.toURI().toURL(), assetsJar.toURI().toURL()}, classLoader);\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                } else if (method.getName().equals(\"settings\")) {\n                    return new HashMap<String, String>();\n                }\n                //TODO: all methods\n                return null;\n            }\n        });\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"public void start(PlayRunSpec spec) {\n        if (stopped.get()) {\n            logger.info(\"Starting Play deployment handle for \" + id);\n            runnerToken = runner.start(spec);\n            stopped.set(false);\n        } else {\n            runnerToken.rebuildSuccess(spec.getClasspath());\n        }\n    }","id":31809,"modified_method":"public void start(PlayRunSpec spec) {\n        if (stopped.get()) {\n            logger.info(\"Starting Play deployment handle for \" + id);\n            runnerToken = runner.start(spec);\n            stopped.set(false);\n        } else {\n            runnerToken.rebuildSuccess();\n        }\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"private static WorkerProcess createWorkerProcess(File workingDir, Factory<WorkerProcessBuilder> workerFactory, PlayRunSpec spec, VersionedPlayRunAdapter adapter) {\n        WorkerProcessBuilder builder = workerFactory.create();\n        builder.setBaseName(\"Gradle Play Worker\");\n        builder.applicationClasspath(spec.getClasspath());\n        builder.sharedPackages(\"org.gradle.play.internal.run\", \"play.core\", \"play.core.server\", \"play.docs\", \"scala\");\n        JavaExecHandleBuilder javaCommand = builder.getJavaCommand();\n        javaCommand.setWorkingDir(workingDir);\n        javaCommand.setMinHeapSize(spec.getForkOptions().getMemoryInitialSize());\n        javaCommand.setMaxHeapSize(spec.getForkOptions().getMemoryMaximumSize());\n        return builder.worker(new PlayWorkerServer(spec, adapter)).build();\n    }","id":31810,"modified_method":"private static WorkerProcess createWorkerProcess(File workingDir, Factory<WorkerProcessBuilder> workerFactory, PlayRunSpec spec, VersionedPlayRunAdapter adapter) {\n        WorkerProcessBuilder builder = workerFactory.create();\n        builder.setBaseName(\"Gradle Play Worker\");\n        builder.sharedPackages(\"org.gradle.play.internal.run\");\n        JavaExecHandleBuilder javaCommand = builder.getJavaCommand();\n        javaCommand.setWorkingDir(workingDir);\n        javaCommand.setMinHeapSize(spec.getForkOptions().getMemoryInitialSize());\n        javaCommand.setMaxHeapSize(spec.getForkOptions().getMemoryMaximumSize());\n        return builder.worker(new PlayWorkerServer(spec, adapter)).build();\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"public void rebuildSuccess(Iterable<File> classpath) {\n        workerServer.rebuildSuccess(classpath);\n    }","id":31811,"modified_method":"public void rebuildSuccess() {\n        workerServer.rebuildSuccess();\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"@TaskAction\n    public void run() {\n        PlayApplicationDeploymentHandle deploymentHandle = deploymentRegistry.get(PlayApplicationDeploymentHandle.class, deploymentId);\n        if (deploymentHandle == null) {\n            throw new GradleException(\"There are no deployment handles registered with id '\".concat(deploymentId).concat(\"'\"));\n        }\n\n        ProgressLoggerFactory progressLoggerFactory = getServices().get(ProgressLoggerFactory.class);\n        ProgressLogger progressLogger = progressLoggerFactory.newOperation(PlayRun.class)\n                .start(\"Start Play server\", \"Starting Play\");\n\n        int httpPort = getHttpPort();\n        FileCollection applicationJars = new SimpleFileCollection(applicationJar, assetsJar);\n        applicationJars = applicationJars.plus(runtimeClasspath);\n        PlayRunSpec spec = new DefaultPlayRunSpec(applicationJars, getProject().getProjectDir(), getForkOptions(), httpPort);\n\n        try {\n            deploymentHandle.start(spec);\n            progressLogger.completed();\n            progressLogger = progressLoggerFactory.newOperation(PlayRun.class)\n                    .start(String.format(\"Run Play App at http://localhost:%d/\", httpPort),\n                            String.format(\"Running at http://localhost:%d/\", httpPort));\n            if (!getProject().getGradle().getStartParameter().isContinuous()) {\n                waitForCtrlD();\n            }\n        } finally {\n            progressLogger.completed();\n        }\n    }","id":31812,"modified_method":"@TaskAction\n    public void run() {\n        PlayApplicationDeploymentHandle deploymentHandle = deploymentRegistry.get(PlayApplicationDeploymentHandle.class, deploymentId);\n        if (deploymentHandle == null) {\n            throw new GradleException(\"There are no deployment handles registered with id '\".concat(deploymentId).concat(\"'\"));\n        }\n\n        ProgressLoggerFactory progressLoggerFactory = getServices().get(ProgressLoggerFactory.class);\n        ProgressLogger progressLogger = progressLoggerFactory.newOperation(PlayRun.class)\n                .start(\"Start Play server\", \"Starting Play\");\n\n        int httpPort = getHttpPort();\n        PlayRunSpec spec = new DefaultPlayRunSpec(runtimeClasspath, applicationJar, assetsJar, getProject().getProjectDir(), getForkOptions(), httpPort);\n\n        try {\n            deploymentHandle.start(spec);\n            progressLogger.completed();\n            progressLogger = progressLoggerFactory.newOperation(PlayRun.class)\n                    .start(String.format(\"Run Play App at http://localhost:%d/\", httpPort),\n                            String.format(\"Running at http://localhost:%d/\", httpPort));\n            if (!getProject().getGradle().getStartParameter().isContinuous()) {\n                waitForCtrlD();\n            }\n        } finally {\n            progressLogger.completed();\n        }\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"private void run() {\n        try {\n            ClassLoader classLoader = getClass().getClassLoader();\n            ClassLoader docsClassLoader = getClass().getClassLoader();\n\n            Object buildDocHandler = spec.getBuildDocHandler(docsClassLoader, runSpec.getClasspath());\n            ScalaMethod runMethod = spec.getNettyServerDevHttpMethod(classLoader, docsClassLoader);\n            Object buildLink = spec.getBuildLink(classLoader, runSpec.getProjectPath(), runSpec.getClasspath());\n            runMethod.invoke(buildLink, buildDocHandler, runSpec.getHttpPort());\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","id":31813,"modified_method":"private void run() {\n        final Thread thread = Thread.currentThread();\n        final ClassLoader previousContextClassLoader = thread.getContextClassLoader();\n        final ClassLoader classLoader = new URLClassLoader(new DefaultClassPath(runSpec.getClasspath()).getAsURLArray());\n        thread.setContextClassLoader(classLoader);\n        try {\n            ClassLoader docsClassLoader = classLoader;\n\n            Object buildDocHandler = spec.getBuildDocHandler(docsClassLoader, runSpec.getClasspath());\n            ScalaMethod runMethod = spec.getNettyServerDevHttpMethod(classLoader, docsClassLoader);\n\n            Object buildLink = spec.getBuildLink(classLoader, runSpec.getProjectPath(), runSpec.getApplicationJar(), runSpec.getAssetsJar());\n            runMethod.invoke(buildLink, buildDocHandler, runSpec.getHttpPort());\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } finally {\n            thread.setContextClassLoader(previousContextClassLoader);\n        }\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void rebuildSuccess(Iterable<File> classpath) {\n        spec.reloadWithClasspath(classpath);\n    }","id":31814,"modified_method":"@Override\n    public void rebuildSuccess() {\n        spec.forceReloadNextTime();\n    }","commit_id":"6dea8dd9b0b4e1e11df4d59fb30770947dc78ef0","url":"https://github.com/gradle/gradle"},{"original_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        jointCompilationOptions.put(\"stubDir\", spec.getGroovyCompileOptions().getStubDir());\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        // Necessary for Groovy compilation to pick up output of regular and joint Java compilation,\n        // and for joint Java compilation to pick up the output of regular Java compilation.\n        // Assumes that output of regular Java compilation (which is not under this task's control) also goes\n        // into spec.getDestinationDir(). We could configure this on source set level, but then spec.getDestinationDir()\n        // would end up on the compile class path of every compile task for that source set, which may not be desirable.\n        spec.setClasspath(Iterables.concat(spec.getClasspath(), Collections.singleton(spec.getDestinationDir())));\n\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(null, null);\n        for (File file : spec.getClasspath()) {\n            compileClasspathClassLoader.addClasspath(file.getPath());\n        }\n\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(GroovyClassLoader.class.getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoader.allowPackage(\"groovy\");\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        final GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compileClasspathClassLoader) {\n            @Override\n            public GroovyClassLoader getTransformLoader() {\n                return astTransformClassLoader;\n            }\n        };\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new org.codehaus.groovy.tools.javac.JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n                        spec.getCompileOptions().getCompilerArgs().add(\"-sourcepath\");\n                        spec.getCompileOptions().getCompilerArgs().add(((File) config.getJointCompilationOptions().get(\"stubDir\")).getAbsolutePath());\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            System.err.println(e.getMessage());\n            throw new CompilationFailedException();\n        }\n\n        return new SimpleWorkResult(true);\n    }","id":31815,"modified_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        jointCompilationOptions.put(\"stubDir\", spec.getGroovyCompileOptions().getStubDir());\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        // Necessary for Groovy compilation to pick up output of regular and joint Java compilation,\n        // and for joint Java compilation to pick up the output of regular Java compilation.\n        // Assumes that output of regular Java compilation (which is not under this task's control) also goes\n        // into spec.getDestinationDir(). We could configure this on source set level, but then spec.getDestinationDir()\n        // would end up on the compile class path of every compile task for that source set, which may not be desirable.\n        spec.setClasspath(Iterables.concat(spec.getClasspath(), Collections.singleton(spec.getDestinationDir())));\n\n        URLClassLoader classPathLoader = new TransformingClassLoader(new DefaultClassPath(spec.getClasspath()));\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(classPathLoader, null);\n\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(GroovyClassLoader.class.getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoader.allowPackage(\"groovy\");\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        final GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compileClasspathClassLoader) {\n            @Override\n            public GroovyClassLoader getTransformLoader() {\n                return astTransformClassLoader;\n            }\n        };\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new org.codehaus.groovy.tools.javac.JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n                        spec.getCompileOptions().getCompilerArgs().add(\"-sourcepath\");\n                        spec.getCompileOptions().getCompilerArgs().add(((File) config.getJointCompilationOptions().get(\"stubDir\")).getAbsolutePath());\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            System.err.println(e.getMessage());\n            throw new CompilationFailedException();\n        }\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"9c895f92477edc704b770db5b0946a0996d20b37","url":"https://github.com/gradle/gradle"},{"original_method":"public void testMethodCall() throws Exception {\n        runTest(\"ClosureMethodTest.groovy\");\n        runTest(\"tree/VerboseTreeTest.groovy\");\n        runTest(\"tree/NestedClosureBugTest.groovy\");\n        runTest(\"tree/SmallTreeTest.groovy\");\n        runTest(\"LittleClosureTest.groovy\");\n        //runTest(\"JointJava.java\", \"JointGroovy.groovy\");\n    }","id":31816,"modified_method":"public void testMethodCall() throws Exception {\n        runTest(\"ClosureMethodTest.groovy\");\n        runTest(\"tree/VerboseTreeTest.groovy\");\n        runTest(\"tree/NestedClosureBugTest.groovy\");\n        runTest(\"tree/SmallTreeTest.groovy\");\n        runTest(\"LittleClosureTest.groovy\");\n        runTest(\"JointJava.java\", \"JointGroovy.groovy\");\n    }","commit_id":"896bf926a12b7652828b0ef7fb8f8974bc128116","url":"https://github.com/apache/groovy"},{"original_method":"public void compile(List files, CompilationUnit cu) {\n        String[] javacParameters = makeParameters(files);\n        StringWriter javacOutput=null;\n        int javacReturnValue = 0;\n        try {\n            Class javac = findJavac(cu);\n            Method method=null;\n            try {\n                method = javac.getMethod(\"compile\", new Class[]{String[].class, PrintWriter.class});\n                javacOutput = new StringWriter();\n                PrintWriter writer = new PrintWriter(javacOutput);\n                Object ret = method.invoke(null, new Object[]{javacParameters,writer});\n                javacReturnValue = ((Integer) ret).intValue();\n            } catch (NoSuchMethodException e) {}\n            if (method==null) {\n                method = javac.getMethod(\"compile\", new Class[]{String[].class});\n                Object ret = method.invoke(null, new Object[]{javacParameters});\n                javacReturnValue = ((Integer) ret).intValue();\n            }\n            cu.getConfiguration().getOutput();\n        } catch (InvocationTargetException ite) {\n            cu.getErrorCollector().addFatalError(new ExceptionMessage((Exception) ite.getCause(), true, cu));\n        } catch (Exception e) {\n            cu.getErrorCollector().addFatalError(new ExceptionMessage(e, true, cu));\n        }\n        if (javacReturnValue!=0) {\n            switch (javacReturnValue) {\n                case 1: addJavacError(\"Compile error during compilation with javac.\",cu,javacOutput); break;\n                case 2: addJavacError(\"Invalid commandline usage for javac.\",cu,javacOutput); break;\n                case 3: addJavacError(\"System error during compilation with javac.\",cu,javacOutput); break;\n                case 4: addJavacError(\"Abnormal termination of javac.\",cu,javacOutput); break;\n                default: addJavacError(\"unexpected return value by javac.\",cu,javacOutput); break;\n            }\n        }        \n    }","id":31817,"modified_method":"public void compile(List files, CompilationUnit cu) {\n        String[] javacParameters = makeParameters(files, cu.getClassLoader());\n        StringWriter javacOutput=null;\n        int javacReturnValue = 0;\n        try {\n            Class javac = findJavac(cu);\n            Method method=null;\n            try {\n                method = javac.getMethod(\"compile\", new Class[]{String[].class, PrintWriter.class});\n                javacOutput = new StringWriter();\n                PrintWriter writer = new PrintWriter(javacOutput);\n                Object ret = method.invoke(null, new Object[]{javacParameters,writer});\n                javacReturnValue = ((Integer) ret).intValue();\n            } catch (NoSuchMethodException e) {}\n            if (method==null) {\n                method = javac.getMethod(\"compile\", new Class[]{String[].class});\n                Object ret = method.invoke(null, new Object[]{javacParameters});\n                javacReturnValue = ((Integer) ret).intValue();\n            }\n            cu.getConfiguration().getOutput();\n        } catch (InvocationTargetException ite) {\n            cu.getErrorCollector().addFatalError(new ExceptionMessage((Exception) ite.getCause(), true, cu));\n        } catch (Exception e) {\n            cu.getErrorCollector().addFatalError(new ExceptionMessage(e, true, cu));\n        }\n        if (javacReturnValue!=0) {\n            switch (javacReturnValue) {\n                case 1: addJavacError(\"Compile error during compilation with javac.\",cu,javacOutput); break;\n                case 2: addJavacError(\"Invalid commandline usage for javac.\",cu,javacOutput); break;\n                case 3: addJavacError(\"System error during compilation with javac.\",cu,javacOutput); break;\n                case 4: addJavacError(\"Abnormal termination of javac.\",cu,javacOutput); break;\n                default: addJavacError(\"unexpected return value by javac.\",cu,javacOutput); break;\n            }\n        }        \n    }","commit_id":"896bf926a12b7652828b0ef7fb8f8974bc128116","url":"https://github.com/apache/groovy"},{"original_method":"private String[] makeParameters(List files) {\n        Map options = config.getJointCompilationOptions();\n        LinkedList paras = new LinkedList();\n\n        File target = config.getTargetDirectory();\n        if (target == null) target = new File(\".\");\n\n        // defaults\n        paras.add(\"-d\");\n        paras.add(target.getAbsolutePath());\n        paras.add(\"-sourcepath\");\n        paras.add(((File) options.get(\"stubDir\")).getAbsolutePath());\n        \n        // add flags\n        String[] flags = (String[]) options.get(\"flags\");\n        if (flags != null) {\n            for (int i = 0; i < flags.length; i++) {\n                paras.add('-' + flags[i]);\n            }\n        }\n\n        boolean hadClasspath=false;\n        // add namedValues\n        String[] namedValues = (String[]) options.get(\"namedValues\");\n        if (namedValues != null) {\n            for (int i = 0; i < namedValues.length; i += 2) {\n                String name = namedValues[i];\n                if (name.equals(\"classpath\")) hadClasspath = true;\n                paras.add('-' + name);\n                paras.add(namedValues[i + 1]);\n            }\n        }\n        \n        // append classpath if not already defined\n        if (!hadClasspath) {\n            paras.add(\"-classpath\");\n            List classpath = config.getClasspath();\n            String resultPath = DefaultGroovyMethods.join(classpath, File.pathSeparator);\n            paras.add(resultPath);\n        }\n        \n        // files to compile\n        paras.addAll(files);\n\n        return (String[]) paras.toArray(new String[paras.size()]);\n    }","id":31818,"modified_method":"private String[] makeParameters(List files, GroovyClassLoader parentClassLoader) {\n        Map options = config.getJointCompilationOptions();\n        LinkedList paras = new LinkedList();\n\n        File target = config.getTargetDirectory();\n        if (target == null) target = new File(\".\");\n\n        // defaults\n        paras.add(\"-d\");\n        paras.add(target.getAbsolutePath());\n        paras.add(\"-sourcepath\");\n        paras.add(((File) options.get(\"stubDir\")).getAbsolutePath());\n        \n        // add flags\n        String[] flags = (String[]) options.get(\"flags\");\n        if (flags != null) {\n            for (int i = 0; i < flags.length; i++) {\n                paras.add('-' + flags[i]);\n            }\n        }\n\n        boolean hadClasspath=false;\n        // add namedValues\n        String[] namedValues = (String[]) options.get(\"namedValues\");\n        if (namedValues != null) {\n            for (int i = 0; i < namedValues.length; i += 2) {\n                String name = namedValues[i];\n                if (name.equals(\"classpath\")) hadClasspath = true;\n                paras.add('-' + name);\n                paras.add(namedValues[i + 1]);\n            }\n        }\n        \n        // append classpath if not already defined\n        if (!hadClasspath) {\n            // add all classpaths that compilation unit sees\n            StringBuffer resultPath = new StringBuffer(DefaultGroovyMethods.join(config.getClasspath(), File.pathSeparator));\n            ClassLoader cl = parentClassLoader;\n            while (cl != null) {\n                if (cl instanceof URLClassLoader) {\n                    for (URL u : ((URLClassLoader)cl).getURLs()) {\n                        try {\n                            resultPath.append(File.pathSeparator);\n                            resultPath.append(new File(u.toURI()).getPath());\n                        } catch (URISyntaxException e) {\n                            // ignore it\n                        }\n                    }\n                }\n                cl = cl.getParent();\n            }\n\n            paras.add(\"-classpath\");\n            paras.add(resultPath.toString());\n        }\n        \n        // files to compile\n        paras.addAll(files);\n\n        return (String[]) paras.toArray(new String[paras.size()]);\n    }","commit_id":"896bf926a12b7652828b0ef7fb8f8974bc128116","url":"https://github.com/apache/groovy"},{"original_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        ClassLoader apiCompilerClassLoader = this.getClass().getClassLoader();\n        MemoryLeakPrevention prevention = new MemoryLeakPrevention(\n            \"API Groovy Compiler\",\n            apiCompilerClassLoader,\n            null);\n        prevention.prepare();\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        canonicalizeValues(spec.getGroovyCompileOptions().getOptimizationOptions());\n        if (spec.getGroovyCompileOptions().getConfigurationScript() != null) {\n            applyConfigurationScript(spec.getGroovyCompileOptions().getConfigurationScript(), configuration);\n        }\n        try {\n            configuration.setOptimizationOptions(spec.getGroovyCompileOptions().getOptimizationOptions());\n        } catch (NoSuchMethodError ignored) { /* method was only introduced in Groovy 1.8 */ }\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        final File stubDir = spec.getGroovyCompileOptions().getStubDir();\n        stubDir.mkdirs();\n        jointCompilationOptions.put(\"stubDir\", stubDir);\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        ClassLoader classPathLoader;\n        VersionNumber version = parseGroovyVersion();\n        if (version.compareTo(VersionNumber.parse(\"2.0\")) < 0) {\n            // using a transforming classloader is only required for older buggy Groovy versions\n            classPathLoader = new GroovyCompileTransformingClassLoader(getExtClassLoader(), new DefaultClassPath(spec.getClasspath()));\n        } else {\n            classPathLoader = new DefaultClassLoaderFactory().createIsolatedClassLoader(\n                Iterables.transform(spec.getClasspath(), new Function<File, URI>() {\n                    @Override\n                    public URI apply(File input) {\n                        return input.toURI();\n                    }\n                }));\n        }\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(classPathLoader, null);\n\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(GroovyClassLoader.class.getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoader.allowPackage(\"groovy\");\n        // Disallow classes from Groovy Jar that reference external classes. Such classes must be loaded from astTransformClassLoader,\n        // or a NoClassDefFoundError will occur. Essentially this is drawing a line between the Groovy compiler and the Groovy\n        // library, albeit only for selected classes that run a high risk of being statically referenced from a transform.\n        groovyCompilerClassLoader.disallowClass(\"groovy.util.GroovyTestCase\");\n        groovyCompilerClassLoader.disallowPackage(\"groovy.servlet\");\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        final GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n        MemoryLeakPrevention groovyCompilerLeakPrevention = new MemoryLeakPrevention(\n            \"Groovy compile classpath classloader\", compileClasspathClassLoader, null\n        );\n        MemoryLeakPrevention astxformsLeakPrevention = new MemoryLeakPrevention(\n            \"Groovy AST xforms classloader\", astTransformClassLoader, null\n        );\n        groovyCompilerLeakPrevention.prepare();\n        astxformsLeakPrevention.prepare();\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compileClasspathClassLoader) {\n            @Override\n            public GroovyClassLoader getTransformLoader() {\n                return astTransformClassLoader;\n            }\n        };\n\n        final boolean shouldProcessAnnotations = shouldProcessAnnotations(astTransformClassLoader, spec);\n        if (shouldProcessAnnotations) {\n            // If an annotation processor is detected, we need to force Java stub generation, so the we can process annotations on Groovy classes\n            // We are forcing stub generation by tricking the groovy compiler into thinking there are java files to compile.\n            // All java files are just passed to the compile method of the JavaCompiler and aren't processed internally by the Groovy Compiler.\n            // Since we're maintaining our own list of Java files independent what's passed by the Groovy compiler, adding a non-existant java file\n            // to the sources won't cause any issues.\n            unit.addSources(new File[]{new File(\"ForceStubGeneration.java\")});\n        }\n\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        if (shouldProcessAnnotations) {\n                            // In order for the Groovy stubs to have annotation processors invoked against them, they must be compiled as source.\n                            // Classes compiled as a result of being on the -sourcepath do not have the annotation processor run against them\n                            spec.setSource(spec.getSource().plus(new SimpleFileCollection(stubDir).getAsFileTree()));\n                        } else {\n                            // When annotation processing isn't required, it's better to add the Groovy stubs as part of the source path.\n                            // This allows compilations to complete faster, because only the Groovy stubs that are needed by the java source are compiled.\n                            FileCollection sourcepath = new SimpleFileCollection(stubDir);\n                            if (spec.getCompileOptions().getSourcepath() != null) {\n                                sourcepath = spec.getCompileOptions().getSourcepath().plus(sourcepath);\n                            }\n                            spec.getCompileOptions().setSourcepath(sourcepath);\n                        }\n\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            System.err.println(e.getMessage());\n            throw new CompilationFailedException();\n        } finally {\n            prevention.dispose(getExtClassLoader(), astTransformClassLoader, compileClasspathClassLoader);\n            groovyCompilerLeakPrevention.dispose(getExtClassLoader(), apiCompilerClassLoader, astTransformClassLoader);\n            astxformsLeakPrevention.dispose(getExtClassLoader(), apiCompilerClassLoader, compileClasspathClassLoader);\n        }\n\n        return new SimpleWorkResult(true);\n    }","id":31819,"modified_method":"public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        GroovySystemLoaderFactory groovySystemLoaderFactory = new GroovySystemLoaderFactory();\n        ClassLoader compilerClassLoader = this.getClass().getClassLoader();\n        GroovySystemLoader compilerGroovyLoader = groovySystemLoaderFactory.forClassLoader(compilerClassLoader);\n\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        canonicalizeValues(spec.getGroovyCompileOptions().getOptimizationOptions());\n        if (spec.getGroovyCompileOptions().getConfigurationScript() != null) {\n            applyConfigurationScript(spec.getGroovyCompileOptions().getConfigurationScript(), configuration);\n        }\n        try {\n            configuration.setOptimizationOptions(spec.getGroovyCompileOptions().getOptimizationOptions());\n        } catch (NoSuchMethodError ignored) { /* method was only introduced in Groovy 1.8 */ }\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        final File stubDir = spec.getGroovyCompileOptions().getStubDir();\n        stubDir.mkdirs();\n        jointCompilationOptions.put(\"stubDir\", stubDir);\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        ClassLoader classPathLoader;\n        VersionNumber version = parseGroovyVersion();\n        if (version.compareTo(VersionNumber.parse(\"2.0\")) < 0) {\n            // using a transforming classloader is only required for older buggy Groovy versions\n            classPathLoader = new GroovyCompileTransformingClassLoader(getExtClassLoader(), new DefaultClassPath(spec.getClasspath()));\n        } else {\n            classPathLoader = new DefaultClassLoaderFactory().createIsolatedClassLoader(new DefaultClassPath(spec.getClasspath()));\n        }\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(classPathLoader, null);\n        GroovySystemLoader compileClasspathLoader = groovySystemLoaderFactory.forClassLoader(classPathLoader);\n\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(GroovyClassLoader.class.getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoader.allowPackage(\"groovy\");\n        // Disallow classes from Groovy Jar that reference external classes. Such classes must be loaded from astTransformClassLoader,\n        // or a NoClassDefFoundError will occur. Essentially this is drawing a line between the Groovy compiler and the Groovy\n        // library, albeit only for selected classes that run a high risk of being statically referenced from a transform.\n        groovyCompilerClassLoader.disallowClass(\"groovy.util.GroovyTestCase\");\n        groovyCompilerClassLoader.disallowPackage(\"groovy.servlet\");\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        final GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compileClasspathClassLoader) {\n            @Override\n            public GroovyClassLoader getTransformLoader() {\n                return astTransformClassLoader;\n            }\n        };\n\n        final boolean shouldProcessAnnotations = shouldProcessAnnotations(astTransformClassLoader, spec);\n        if (shouldProcessAnnotations) {\n            // If an annotation processor is detected, we need to force Java stub generation, so the we can process annotations on Groovy classes\n            // We are forcing stub generation by tricking the groovy compiler into thinking there are java files to compile.\n            // All java files are just passed to the compile method of the JavaCompiler and aren't processed internally by the Groovy Compiler.\n            // Since we're maintaining our own list of Java files independent what's passed by the Groovy compiler, adding a non-existant java file\n            // to the sources won't cause any issues.\n            unit.addSources(new File[]{new File(\"ForceStubGeneration.java\")});\n        }\n\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        if (shouldProcessAnnotations) {\n                            // In order for the Groovy stubs to have annotation processors invoked against them, they must be compiled as source.\n                            // Classes compiled as a result of being on the -sourcepath do not have the annotation processor run against them\n                            spec.setSource(spec.getSource().plus(new SimpleFileCollection(stubDir).getAsFileTree()));\n                        } else {\n                            // When annotation processing isn't required, it's better to add the Groovy stubs as part of the source path.\n                            // This allows compilations to complete faster, because only the Groovy stubs that are needed by the java source are compiled.\n                            FileCollection sourcepath = new SimpleFileCollection(stubDir);\n                            if (spec.getCompileOptions().getSourcepath() != null) {\n                                sourcepath = spec.getCompileOptions().getSourcepath().plus(sourcepath);\n                            }\n                            spec.getCompileOptions().setSourcepath(sourcepath);\n                        }\n\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return file.getName().endsWith(\".java\");\n                            }\n                        }));\n\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            System.err.println(e.getMessage());\n            throw new CompilationFailedException();\n        } finally {\n            // Remove compile and AST types from the Groovy loader\n            compilerGroovyLoader.discardTypesFrom(classPathLoader);\n            compilerGroovyLoader.discardTypesFrom(astTransformClassLoader);\n            //Discard the compile loader\n            compileClasspathLoader.shutdown();\n        }\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"076ca70adfae52286e01041510e5eb34609a7106","url":"https://github.com/gradle/gradle"},{"original_method":"public GroovySystemLoader forClassLoader(ClassLoader classLoader) {\n        if (!HAS_CLASS_VALUE) {\n            return NOT_BROKEN;\n        }\n        try {\n            Class<?> groovySystem = null;\n            try {\n                groovySystem = classLoader.loadClass(\"groovy.lang.GroovySystem\");\n            } catch (ClassNotFoundException e) {\n                // Not a Groovy implementation, or not an implementation that we need to deal with\n                return NOT_BROKEN;\n            }\n            if (groovySystem.getClassLoader() != classLoader) {\n                // Groovy implementation visible from somewhere else\n                return NOT_BROKEN;\n            }\n\n            String versionString;\n            try {\n                Method getVersion = groovySystem.getDeclaredMethod(\"getVersion\");\n                versionString = (String) getVersion.invoke(null);\n            } catch (NoSuchMethodException ex) {\n                return NOT_BROKEN;\n            }\n            VersionNumber groovyVersion = VersionNumber.parse(versionString);\n            boolean isFaultyGroovy = groovyVersion.getMajor() == 2 && groovyVersion.getMinor() == 4 && groovyVersion.getMicro() < 5;\n            return isFaultyGroovy ? new LeakyOnJava7GroovySystemLoader(classLoader) : NOT_BROKEN;\n        } catch (Exception e) {\n            throw new GradleException(\"Could not inspect the Groovy system for ClassLoader \" + classLoader, e);\n        }\n    }","id":31820,"modified_method":"public GroovySystemLoader forClassLoader(ClassLoader classLoader) {\n        if (!HAS_CLASS_VALUE) {\n            return NOT_BROKEN;\n        }\n        try {\n            Class<?> groovySystem;\n            try {\n                groovySystem = classLoader.loadClass(\"groovy.lang.GroovySystem\");\n            } catch (ClassNotFoundException e) {\n                // Not a Groovy implementation, or not an implementation that we need to deal with\n                return NOT_BROKEN;\n            }\n            if (groovySystem.getClassLoader() != classLoader) {\n                // Groovy implementation visible from somewhere else\n                return NOT_BROKEN;\n            }\n\n            String versionString;\n            try {\n                Method getVersion = groovySystem.getDeclaredMethod(\"getVersion\");\n                versionString = (String) getVersion.invoke(null);\n            } catch (NoSuchMethodException ex) {\n                return NOT_BROKEN;\n            }\n            VersionNumber groovyVersion = VersionNumber.parse(versionString);\n            boolean isFaultyGroovy = groovyVersion.getMajor() == 2 && groovyVersion.getMinor() == 4 && groovyVersion.getMicro() < 5;\n            return isFaultyGroovy ? new LeakyOnJava7GroovySystemLoader(classLoader) : NOT_BROKEN;\n        } catch (Exception e) {\n            throw new GradleException(\"Could not inspect the Groovy system for ClassLoader \" + classLoader, e);\n        }\n    }","commit_id":"076ca70adfae52286e01041510e5eb34609a7106","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultClassPath(List<File> files) {\n        this.files = files;\n    }","id":31821,"modified_method":"public DefaultClassPath(Iterable<File> files) {\n        this.files = GUtil.toList(files);\n    }","commit_id":"a37042315a09865e2d5752d17069a5ada46540ff","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<File> findClassPath(String name) {\n        if (name.equals(\"GRADLE_RUNTIME\")) {\n            Set<File> classpath = new LinkedHashSet<File>();\n            for (Module module : moduleRegistry.getModule(\"gradle-launcher\").getAllRequiredModules()) {\n                classpath.addAll(module.getClasspath());\n            }\n            return classpath;\n        }\n        if (name.equals(\"GRADLE_CORE\")) {\n            return moduleRegistry.getModule(\"gradle-core\").getImplementationClasspath();\n        }\n        if (name.equals(\"COMMONS_CLI\")) {\n            return moduleRegistry.getExternalModule(\"commons-cli\").getClasspath();\n        }\n        if (name.equals(\"ANT\")) {\n            Set<File> classpath = new LinkedHashSet<File>();\n            classpath.addAll(moduleRegistry.getExternalModule(\"ant\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"ant-launcher\").getClasspath());\n            return classpath;\n        }\n        if (name.equals(\"GROOVY\")) {\n            return moduleRegistry.getExternalModule(\"groovy-all\").getClasspath();\n        }\n\n        return null;\n    }","id":31822,"modified_method":"public ClassPath findClassPath(String name) {\n        if (name.equals(\"GRADLE_RUNTIME\")) {\n            Set<File> classpath = new LinkedHashSet<File>();\n            for (Module module : moduleRegistry.getModule(\"gradle-launcher\").getAllRequiredModules()) {\n                classpath.addAll(module.getClasspath());\n            }\n            return new DefaultClassPath(classpath);\n        }\n        if (name.equals(\"GRADLE_CORE\")) {\n            return new DefaultClassPath(moduleRegistry.getModule(\"gradle-core\").getImplementationClasspath());\n        }\n        if (name.equals(\"COMMONS_CLI\")) {\n            return new DefaultClassPath(moduleRegistry.getExternalModule(\"commons-cli\").getClasspath());\n        }\n        if (name.equals(\"ANT\")) {\n            Set<File> classpath = new LinkedHashSet<File>();\n            classpath.addAll(moduleRegistry.getExternalModule(\"ant\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"ant-launcher\").getClasspath());\n            return new DefaultClassPath(classpath);\n        }\n        if (name.equals(\"GROOVY\")) {\n            return new DefaultClassPath(moduleRegistry.getExternalModule(\"groovy-all\").getClasspath());\n        }\n\n        return null;\n    }","commit_id":"a37042315a09865e2d5752d17069a5ada46540ff","url":"https://github.com/gradle/gradle"},{"original_method":"public ClassPath getClassPath(String name) {\n        List<File> files = getClassPathFiles(name);\n        return new DefaultClassPath(files);\n    }","id":31823,"modified_method":"public ClassPath getClassPath(String name) {\n        for (ClassPathProvider provider : providers) {\n            ClassPath classpath = provider.findClassPath(name);\n            if (classpath != null) {\n                return classpath;\n            }\n        }\n        throw new IllegalArgumentException(String.format(\"unknown classpath '%s' requested.\", name));\n    }","commit_id":"a37042315a09865e2d5752d17069a5ada46540ff","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<File> findClassPath(String name) {\r\n        if (name.equals(GRADLE_API.name())) {\r\n            Set<File> classpath = new LinkedHashSet<File>();\r\n            Module core = moduleRegistry.getModule(\"gradle-core\");\r\n            for (Module module : core.getAllRequiredModules()) {\r\n                classpath.addAll(module.getClasspath());\r\n            }\r\n            classpath.addAll(moduleRegistry.getModule(\"gradle-core-impl\").getClasspath());\r\n            try {\r\n                classpath.addAll(moduleRegistry.getModule(\"gradle-tooling-api\").getImplementationClasspath());\r\n            } catch (UnknownModuleException e) {\r\n                // Ignore\r\n            }\r\n            for (Module pluginModule : pluginModuleRegistry.getPluginModules()) {\r\n                classpath.addAll(pluginModule.getClasspath());\r\n            }\r\n            return classpath;\r\n        }\r\n        if (name.equals(LOCAL_GROOVY.name())) {\r\n            return moduleRegistry.getExternalModule(\"groovy-all\").getClasspath();\r\n        }\r\n\r\n        return null;\r\n    }","id":31824,"modified_method":"public ClassPath findClassPath(String name) {\n        if (name.equals(GRADLE_API.name())) {\n            Set<File> classpath = new LinkedHashSet<File>();\n            Module core = moduleRegistry.getModule(\"gradle-core\");\n            for (Module module : core.getAllRequiredModules()) {\n                classpath.addAll(module.getClasspath());\n            }\n            classpath.addAll(moduleRegistry.getModule(\"gradle-core-impl\").getClasspath());\n            try {\n                classpath.addAll(moduleRegistry.getModule(\"gradle-tooling-api\").getImplementationClasspath());\n            } catch (UnknownModuleException e) {\n                // Ignore\n            }\n            for (Module pluginModule : pluginModuleRegistry.getPluginModules()) {\n                classpath.addAll(pluginModule.getClasspath());\n            }\n            return new DefaultClassPath(classpath);\n        }\n        if (name.equals(LOCAL_GROOVY.name())) {\n            return new DefaultClassPath(moduleRegistry.getExternalModule(\"groovy-all\").getClasspath());\n        }\n\n        return null;\n    }","commit_id":"a37042315a09865e2d5752d17069a5ada46540ff","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<File> findClassPath(String name) {\n        if (name.equals(\"GRADLE_PLUGINS\")) {\n            Set<File> classpath = new LinkedHashSet<File>();\n            for (Module pluginModule : pluginModuleRegistry.getPluginModules()) {\n                classpath.addAll(pluginModule.getClasspath());\n            }\n            return classpath;\n        }\n        if (name.equals(\"GRADLE_CORE_IMPL\")) {\n            return moduleRegistry.getModule(\"gradle-core-impl\").getClasspath();\n        }\n\n        return null;\n    }","id":31825,"modified_method":"public ClassPath findClassPath(String name) {\n        if (name.equals(\"GRADLE_PLUGINS\")) {\n            Set<File> classpath = new LinkedHashSet<File>();\n            for (Module pluginModule : pluginModuleRegistry.getPluginModules()) {\n                classpath.addAll(pluginModule.getClasspath());\n            }\n            return new DefaultClassPath(classpath);\n        }\n        if (name.equals(\"GRADLE_CORE_IMPL\")) {\n            return new DefaultClassPath(moduleRegistry.getModule(\"gradle-core-impl\").getClasspath());\n        }\n\n        return null;\n    }","commit_id":"a37042315a09865e2d5752d17069a5ada46540ff","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<File> findClassPath(String name) {\n        if (name.equals(\"WORKER_PROCESS\")) {\n            // TODO - split out a logging project and use its classpath, instead of hardcoding logging dependencies here\n            Set<File> classpath = new LinkedHashSet<File>();\n            classpath.addAll(moduleRegistry.getModule(\"gradle-base-services\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getModule(\"gradle-core\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getModule(\"gradle-cli\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getModule(\"gradle-native\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"slf4j-api\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"logback-classic\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"logback-core\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"jul-to-slf4j\").getClasspath());\n            return classpath;\n        }\n        if (name.equals(\"WORKER_MAIN\")) {\n            synchronized (lock) {\n                if (workerClassPath == null) {\n                    PersistentCache cache = cacheRepository.cache(\"workerMain\").withInitializer(new CacheInitializer()).open();\n                    workerClassPath = Collections.singleton(classesDir(cache));\n                }\n                return workerClassPath;\n            }\n        }\n\n        return null;\n    }","id":31826,"modified_method":"public ClassPath findClassPath(String name) {\n        if (name.equals(\"WORKER_PROCESS\")) {\n            // TODO - split out a logging project and use its classpath, instead of hardcoding logging dependencies here\n            Set<File> classpath = new LinkedHashSet<File>();\n            classpath.addAll(moduleRegistry.getModule(\"gradle-base-services\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getModule(\"gradle-core\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getModule(\"gradle-cli\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getModule(\"gradle-native\").getImplementationClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"slf4j-api\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"logback-classic\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"logback-core\").getClasspath());\n            classpath.addAll(moduleRegistry.getExternalModule(\"jul-to-slf4j\").getClasspath());\n            return new DefaultClassPath(classpath);\n        }\n        if (name.equals(\"WORKER_MAIN\")) {\n            synchronized (lock) {\n                if (workerClassPath == null) {\n                    PersistentCache cache = cacheRepository.cache(\"workerMain\").withInitializer(new CacheInitializer()).open();\n                    workerClassPath = new DefaultClassPath(Collections.singleton(classesDir(cache)));\n                }\n                return workerClassPath;\n            }\n        }\n\n        return null;\n    }","commit_id":"a37042315a09865e2d5752d17069a5ada46540ff","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean lockUID(long uid, boolean ssk, boolean insert, boolean offerReply, boolean local, boolean realTimeFlag, UIDTag tag) {\n\t\t// If these are switched around, we must remember to remove from both.\n\t\tif(offerReply) {\n\t\t\t// local irrelevant for OfferReplyTag's.\n\t\t\tHashMap<Long,OfferReplyTag> map = getOfferTracker(ssk, realTimeFlag);\n\t\t\tinnerLock(map, null, (OfferReplyTag)tag, uid, ssk, insert, offerReply, false);\n\t\t} else if(insert) {\n\t\t\tHashMap<Long,InsertTag> overallMap = getInsertTracker(ssk, false, realTimeFlag);\n\t\t\tHashMap<Long,InsertTag> localMap = local ? getInsertTracker(ssk, local, realTimeFlag) : null;\n\t\t\tinnerLock(overallMap, localMap, (InsertTag)tag, uid, ssk, insert, offerReply, local);\n\t\t} else {\n\t\t\tHashMap<Long,RequestTag> overallMap = getRequestTracker(ssk,false, realTimeFlag);\n\t\t\tHashMap<Long,RequestTag> localMap = local ? getRequestTracker(ssk,local, realTimeFlag) : null;\n\t\t\tinnerLock(overallMap, localMap, (RequestTag)tag, uid, ssk, insert, offerReply, local);\n\t\t}\n\t\treturn true;\n\t}","id":31827,"modified_method":"public boolean lockUID(long uid, boolean ssk, boolean insert, boolean offerReply, boolean local, boolean realTimeFlag, UIDTag tag) {\n\t\t// If these are switched around, we must remember to remove from both.\n\t\tif(offerReply) {\n\t\t\t// local irrelevant for OfferReplyTag's.\n\t\t\tHashMap<Long,OfferReplyTag> map = getOfferTracker(ssk, realTimeFlag);\n\t\t\treturn innerLock(map, null, (OfferReplyTag)tag, uid, ssk, insert, offerReply, false);\n\t\t} else if(insert) {\n\t\t\tHashMap<Long,InsertTag> overallMap = getInsertTracker(ssk, false, realTimeFlag);\n\t\t\tHashMap<Long,InsertTag> localMap = local ? getInsertTracker(ssk, local, realTimeFlag) : null;\n\t\t\treturn innerLock(overallMap, localMap, (InsertTag)tag, uid, ssk, insert, offerReply, local);\n\t\t} else {\n\t\t\tHashMap<Long,RequestTag> overallMap = getRequestTracker(ssk,false, realTimeFlag);\n\t\t\tHashMap<Long,RequestTag> localMap = local ? getRequestTracker(ssk,local, realTimeFlag) : null;\n\t\t\treturn innerLock(overallMap, localMap, (RequestTag)tag, uid, ssk, insert, offerReply, local);\n\t\t}\n\t}","commit_id":"62e38a6c6477aeb5ff61cc650b4b0f2983b97263","url":"https://github.com/freenet/fred"},{"original_method":"private<T extends UIDTag> void innerLock(HashMap<Long, T> overallMap, HashMap<Long, T> localMap, T tag, Long uid, boolean ssk, boolean insert, boolean offerReply, boolean local) {\n\t\tsynchronized(overallMap) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Locking \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+overallMap.size(), new Exception(\"debug\"));\n\t\t\tif(overallMap.containsKey(uid)) {\n\t\t\t\tif(overallMap.get(uid) == tag) {\n\t\t\t\t\tLogger.error(this, \"Tag already registered: \"+tag, new Exception(\"debug\"));\n\t\t\t\t} else {\n\t\t\t\t\tLogger.error(this, \"Already have UID in specific map (\"+ssk+\",\"+insert+\",\"+offerReply+\",\"+local+\"): trying to register \"+tag+\" but already have \"+overallMap.get(uid), new Exception(\"debug\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\toverallMap.put(uid, tag);\n\t\t\tif(logMINOR) Logger.minor(this, \"Locked \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+overallMap.size());\n\t\t\tif(local) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Locking (local) \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+localMap.size(), new Exception(\"debug\"));\n\t\t\t\tif(localMap.containsKey(uid)) {\n\t\t\t\t\tif(localMap.get(uid) == tag) {\n\t\t\t\t\t\tLogger.error(this, \"Tag already registered (local): \"+tag, new Exception(\"debug\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Already have UID in specific map (local) (\"+ssk+\",\"+insert+\",\"+offerReply+\",\"+local+\"): trying to register \"+tag+\" but already have \"+localMap.get(uid), new Exception(\"debug\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocalMap.put(uid, tag);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Locked (local) \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+localMap.size());\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","id":31828,"modified_method":"private<T extends UIDTag> boolean innerLock(HashMap<Long, T> overallMap, HashMap<Long, T> localMap, T tag, Long uid, boolean ssk, boolean insert, boolean offerReply, boolean local) {\n\t\tsynchronized(overallMap) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Locking \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+overallMap.size(), new Exception(\"debug\"));\n\t\t\tif(overallMap.containsKey(uid)) {\n\t\t\t\tif(overallMap.get(uid) == tag) {\n\t\t\t\t\tLogger.error(this, \"Tag already registered: \"+tag, new Exception(\"debug\"));\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\toverallMap.put(uid, tag);\n\t\t\tif(logMINOR) Logger.minor(this, \"Locked \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+overallMap.size());\n\t\t\tif(local) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Locking (local) \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+localMap.size(), new Exception(\"debug\"));\n\t\t\t\tif(localMap.containsKey(uid)) {\n\t\t\t\t\tif(localMap.get(uid) == tag) {\n\t\t\t\t\t\tLogger.error(this, \"Tag already registered (local): \"+tag, new Exception(\"debug\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocalMap.put(uid, tag);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Locked (local) \"+uid+\" ssk=\"+ssk+\" insert=\"+insert+\" offerReply=\"+offerReply+\" local=\"+local+\" size=\"+localMap.size());\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"62e38a6c6477aeb5ff61cc650b4b0f2983b97263","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Here we make sure we have received data, so that the header has been for\n     * sure written to the output stream already.\n     */\n    @Override\n    public synchronized void write(byte[] bytes, int offset, int length)\n            throws IOException {\n        if (length > 0) {\n            prepareForOutput();\n            super.write(bytes, offset, length);\n        }\n    }","id":31829,"modified_method":"@Override\n    public synchronized void write(byte[] bytes, int offset, int length)\n            throws IOException {\n        if (length > 0) {\n            flushLastByte();\n            if (length > 1) {\n                super.write(bytes, offset, length - 1);\n            }\n            rememberLastByte(bytes[offset + length - 1]);\n        }\n    }","commit_id":"d802bcd4a7435c2f1a25f18cc1f28a1a5d15b576","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public synchronized void write(int i) throws IOException {\n        prepareForOutput();\n        super.write(i);\n    }","id":31830,"modified_method":"@Override\n    public synchronized void write(int i) throws IOException {\n        flushLastByte();\n        rememberLastByte((byte) (i & 0xFF));\n    }","commit_id":"d802bcd4a7435c2f1a25f18cc1f28a1a5d15b576","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public synchronized void flush() throws IOException {\n        if (!hasData) {\n            return; // do not allow the gzip header to be flushed on its own\n        }\n\n        // trick the deflater to flush\n        /**\n         * Now this is tricky: We force the Deflater to flush its data by\n         * switching compression level. As yet, a perplexingly simple workaround\n         * for\n         * http://developer.java.sun.com/developer/bugParade/bugs/4255743.html\n         */\n        if (!def.finished()) {\n            def.setInput(EMPTYBYTEARRAY, 0, 0);\n\n            def.setLevel(Deflater.NO_COMPRESSION);\n            deflate();\n\n            // Cannot reenable compression now. Must wait for data.\n            needReenableCompression = true;\n\n            out.flush();\n        }\n\n        hasData = false; // no more data to flush\n    }","id":31831,"modified_method":"@Override\n    public synchronized void flush() throws IOException {\n        if (hasLastByte) {\n            // - do not allow the gzip header to be flushed on its own\n            // - do not do anything if there is no data to send\n\n            // trick the deflater to flush\n            /**\n             * Now this is tricky: We force the Deflater to flush its data by\n             * switching compression level. As yet, a perplexingly simple workaround\n             * for\n             * http://developer.java.sun.com/developer/bugParade/bugs/4255743.html\n             */\n            if (!def.finished()) {\n                def.setLevel(Deflater.NO_COMPRESSION);\n                flushLastByte();\n                def.setLevel(Deflater.DEFAULT_COMPRESSION);\n            }\n        }\n        out.flush();\n    }","commit_id":"d802bcd4a7435c2f1a25f18cc1f28a1a5d15b576","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\r\n    public void testBug52121() throws Exception {\r\n\r\n        ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();\r\n        ByteArrayOutputStream sink = new ByteArrayOutputStream();\r\n\r\n        OutputStream output = new FlushableGZIPOutputStream(byteOutStream);\r\n\r\n        File sourcesDir = new File(\"test/org/apache/coyote/http11/filters/\");\r\n        InputStream input;\r\n\r\n        input = new FileInputStream(new File(sourcesDir, \"bug52121-part1\"));\r\n        try {\r\n            IOTools.flow(input, output);\r\n        } finally {\r\n            input.close();\r\n        }\r\n        output.flush();\r\n\r\n        input = new FileInputStream(new File(sourcesDir, \"bug52121-part2\"));\r\n        try {\r\n            IOTools.flow(input, output);\r\n        } finally {\r\n            input.close();\r\n        }\r\n        output.flush();\r\n\r\n        // Using \"data\" may trigger a JVM crash\r\n        // output.write(\"data\".getBytes());\r\n        output.write(\"data2\".getBytes());\r\n        output.flush();\r\n\r\n        output.close();\r\n\r\n        ByteArrayInputStream byteInStream =\r\n                new ByteArrayInputStream(byteOutStream.toByteArray());\r\n\r\n        GZIPInputStream inflaterStream = new GZIPInputStream(byteInStream);\r\n        IOTools.flow(inflaterStream, sink);\r\n    }","id":31832,"modified_method":"@Test\r\n    public void testBug52121() throws Exception {\r\n\r\n        ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();\r\n        OutputStream output = new FlushableGZIPOutputStream(byteOutStream);\r\n\r\n        File sourcesDir = new File(\"test/org/apache/coyote/http11/filters/\");\r\n        List<byte[]> parts = new ArrayList<byte[]>();\r\n        byte[] part;\r\n\r\n        part = loadFile(new File(sourcesDir, \"bug52121-part1\"));\r\n        parts.add(part);\r\n        flowBytes(part, output);\r\n        output.flush();\r\n\r\n        part = loadFile(new File(sourcesDir, \"bug52121-part2\"));\r\n        parts.add(part);\r\n        flowBytes(part, output);\r\n        output.flush();\r\n\r\n        part = \"data2\".getBytes(\"ASCII\");\r\n        parts.add(part);\r\n        output.write(part);\r\n        output.flush();\r\n\r\n        output.close();\r\n\r\n        ByteArrayInputStream byteInStream =\r\n                new ByteArrayInputStream(byteOutStream.toByteArray());\r\n\r\n        GZIPInputStream inflaterStream = new GZIPInputStream(byteInStream);\r\n        ByteArrayOutputStream sink = new ByteArrayOutputStream();\r\n        try {\r\n            IOTools.flow(inflaterStream, sink);\r\n        } finally {\r\n            sink.close();\r\n        }\r\n\r\n        byte[] decompressedBytes = sink.toByteArray();\r\n        int originalLength = 0;\r\n        for (byte[] bytes : parts) {\r\n            assertArrayEquals(bytes, Arrays.copyOfRange(decompressedBytes,\r\n                    originalLength, originalLength + bytes.length));\r\n            originalLength += bytes.length;\r\n        }\r\n        assertEquals(originalLength, decompressedBytes.length);\r\n    }","commit_id":"d802bcd4a7435c2f1a25f18cc1f28a1a5d15b576","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\r\n    public void testBug52121() throws Exception {\r\n\r\n        ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();\r\n        ByteArrayOutputStream sink = new ByteArrayOutputStream();\r\n\r\n        OutputStream output = new FlushableGZIPOutputStream(byteOutStream);\r\n\r\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n\r\n        InputStream input = cl.getResourceAsStream(\r\n                \"org/apache/coyote/http11/filters/bug52121-part1\");\r\n        IOTools.flow(input, output);\r\n        input.close();\r\n        output.flush();\r\n\r\n        input = cl.getResourceAsStream(\r\n                \"org/apache/coyote/http11/filters/bug52121-part2\");\r\n        IOTools.flow(input, output);\r\n        input.close();\r\n        output.flush();\r\n\r\n        output.close();\r\n\r\n        ByteArrayInputStream byteInStream =\r\n                new ByteArrayInputStream(byteOutStream.toByteArray());\r\n\r\n        GZIPInputStream inflaterStream = new GZIPInputStream(byteInStream);\r\n        IOTools.flow(inflaterStream, sink);\r\n    }","id":31833,"modified_method":"@Test\r\n    public void testBug52121() throws Exception {\r\n\r\n        ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();\r\n        ByteArrayOutputStream sink = new ByteArrayOutputStream();\r\n\r\n        OutputStream output = new FlushableGZIPOutputStream(byteOutStream);\r\n\r\n        File sourcesDir = new File(\"test/org/apache/coyote/http11/filters/\");\r\n        InputStream input;\r\n\r\n        input = new FileInputStream(new File(sourcesDir, \"bug52121-part1\"));\r\n        try {\r\n            IOTools.flow(input, output);\r\n        } finally {\r\n            input.close();\r\n        }\r\n        output.flush();\r\n\r\n        input = new FileInputStream(new File(sourcesDir, \"bug52121-part2\"));\r\n        try {\r\n            IOTools.flow(input, output);\r\n        } finally {\r\n            input.close();\r\n        }\r\n        output.flush();\r\n\r\n        output.close();\r\n\r\n        ByteArrayInputStream byteInStream =\r\n                new ByteArrayInputStream(byteOutStream.toByteArray());\r\n\r\n        GZIPInputStream inflaterStream = new GZIPInputStream(byteInStream);\r\n        IOTools.flow(inflaterStream, sink);\r\n    }","commit_id":"d8bd1ef2fa173aeaa22dabff13960f5cd674c1bc","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n         * Extracts requested resource from web app archive to context work\n         * directory to enable CGI script to be executed.\n         */\n        protected void expandCGIScript() {\n            StringBuilder srcPath = new StringBuilder();\n            StringBuilder destPath = new StringBuilder();\n            InputStream is = null;\n\n            // paths depend on mapping\n            if (cgiPathPrefix == null ) {\n                srcPath.append(pathInfo);\n                is = context.getResourceAsStream(srcPath.toString());\n                destPath.append(tmpDir);\n                destPath.append(pathInfo);\n            } else {\n                // essentially same search algorithm as findCGI()\n                srcPath.append(cgiPathPrefix);\n                StringTokenizer pathWalker =\n                        new StringTokenizer (pathInfo, \"/\");\n                // start with first element\n                while (pathWalker.hasMoreElements() && (is == null)) {\n                    srcPath.append(\"/\");\n                    srcPath.append(pathWalker.nextElement());\n                    is = context.getResourceAsStream(srcPath.toString());\n                }\n                destPath.append(tmpDir);\n                destPath.append(\"/\");\n                destPath.append(srcPath);\n            }\n\n            if (is == null) {\n                // didn't find anything, give up now\n                if (debug >= 2) {\n                    log(\"expandCGIScript: source '\" + srcPath + \"' not found\");\n                }\n                 return;\n            }\n\n            File f = new File(destPath.toString());\n            if (f.exists()) {\n                // Don't need to expand if it already exists\n                return;\n            }\n\n            // create directories\n            String dirPath = destPath.toString().substring(\n                    0,destPath.toString().lastIndexOf(\"/\"));\n            File dir = new File(dirPath);\n            if (!dir.mkdirs() && !dir.isDirectory()) {\n                if (debug >= 2) {\n                    log(\"expandCGIScript: failed to create directories for '\" +\n                            dir.getAbsolutePath() + \"'\");\n                }\n                return;\n            }\n\n            try {\n                synchronized (expandFileLock) {\n                    // make sure file doesn't exist\n                    if (f.exists()) {\n                        return;\n                    }\n\n                    // create file\n                    if (!f.createNewFile()) {\n                        return;\n                    }\n                    FileOutputStream fos = new FileOutputStream(f);\n\n                    // copy data\n                    IOTools.flow(is, fos);\n                    is.close();\n                    fos.close();\n                    if (debug >= 2) {\n                        log(\"expandCGIScript: expanded '\" + srcPath + \"' to '\" + destPath + \"'\");\n                    }\n                }\n            } catch (IOException ioe) {\n                // delete in case file is corrupted\n                if (f.exists()) {\n                    if (!f.delete() && debug >= 2) {\n                        log(\"expandCGIScript: failed to delete '\" +\n                                f.getAbsolutePath() + \"'\");\n                    }\n                }\n            }\n        }","id":31834,"modified_method":"/**\n         * Extracts requested resource from web app archive to context work\n         * directory to enable CGI script to be executed.\n         */\n        protected void expandCGIScript() {\n            StringBuilder srcPath = new StringBuilder();\n            StringBuilder destPath = new StringBuilder();\n            InputStream is = null;\n\n            // paths depend on mapping\n            if (cgiPathPrefix == null ) {\n                srcPath.append(pathInfo);\n                is = context.getResourceAsStream(srcPath.toString());\n                destPath.append(tmpDir);\n                destPath.append(pathInfo);\n            } else {\n                // essentially same search algorithm as findCGI()\n                srcPath.append(cgiPathPrefix);\n                StringTokenizer pathWalker =\n                        new StringTokenizer (pathInfo, \"/\");\n                // start with first element\n                while (pathWalker.hasMoreElements() && (is == null)) {\n                    srcPath.append(\"/\");\n                    srcPath.append(pathWalker.nextElement());\n                    is = context.getResourceAsStream(srcPath.toString());\n                }\n                destPath.append(tmpDir);\n                destPath.append(\"/\");\n                destPath.append(srcPath);\n            }\n\n            if (is == null) {\n                // didn't find anything, give up now\n                if (debug >= 2) {\n                    log(\"expandCGIScript: source '\" + srcPath + \"' not found\");\n                }\n                 return;\n            }\n\n            File f = new File(destPath.toString());\n            if (f.exists()) {\n                try {\n                    is.close();\n                } catch (IOException ignore) {\n                }\n                // Don't need to expand if it already exists\n                return;\n            }\n\n            // create directories\n            String dirPath = destPath.toString().substring(\n                    0,destPath.toString().lastIndexOf(\"/\"));\n            File dir = new File(dirPath);\n            if (!dir.mkdirs() && !dir.isDirectory()) {\n                if (debug >= 2) {\n                    log(\"expandCGIScript: failed to create directories for '\" +\n                            dir.getAbsolutePath() + \"'\");\n                }\n                return;\n            }\n\n            try {\n                synchronized (expandFileLock) {\n                    // make sure file doesn't exist\n                    if (f.exists()) {\n                        return;\n                    }\n\n                    // create file\n                    if (!f.createNewFile()) {\n                        return;\n                    }\n                    FileOutputStream fos = new FileOutputStream(f);\n\n                    try {\n                        // copy data\n                        IOTools.flow(is, fos);\n                    } finally {\n                        try {\n                            is.close();\n                        } catch (IOException ignore) {\n                        }\n                        fos.close();\n                    }\n                    if (debug >= 2) {\n                        log(\"expandCGIScript: expanded '\" + srcPath + \"' to '\" + destPath + \"'\");\n                    }\n                }\n            } catch (IOException ioe) {\n                // delete in case file is corrupted\n                if (f.exists()) {\n                    if (!f.delete() && debug >= 2) {\n                        log(\"expandCGIScript: failed to delete '\" +\n                                f.getAbsolutePath() + \"'\");\n                    }\n                }\n            }\n        }","commit_id":"934feb204487f6dfc89f7d2da6b25fa825b962ba","url":"https://github.com/apache/tomcat"},{"original_method":"protected WSSecUsernameToken addUsernameToken(UsernameToken token) {\n        AssertionInfo info = null;\n        Collection<AssertionInfo> ais = aim.getAssertionInfo(token.getName());\n        for (AssertionInfo ai : ais) {\n            if (ai.getAssertion() == token) {\n                info = ai;\n                if (!isRequestor()) {\n                    info.setAsserted(true);\n                    return null;\n                }\n            }\n        }\n        \n        String userName = (String)message.getContextualProperty(SecurityConstants.USERNAME);\n        if (!StringUtils.isEmpty(userName)) {\n            // If NoPassword property is set we don't need to set the password\n            if (token.isNoPassword()) {\n                WSSecUsernameToken utBuilder = new WSSecUsernameToken(wssConfig);\n                utBuilder.setUserInfo(userName, null);\n                utBuilder.setPasswordType(null);\n                info.setAsserted(true);\n                return utBuilder;\n            }\n            \n            String password = (String)message.getContextualProperty(SecurityConstants.PASSWORD);\n            if (StringUtils.isEmpty(password)) {\n                password = getPassword(userName, token, WSPasswordCallback.USERNAME_TOKEN);\n            }\n            \n            if (!StringUtils.isEmpty(password)) {\n                //If the password is available then build the token\n                WSSecUsernameToken utBuilder = new WSSecUsernameToken(wssConfig);\n                if (token.isHashPassword()) {\n                    utBuilder.setPasswordType(WSConstants.PASSWORD_DIGEST);  \n                } else {\n                    utBuilder.setPasswordType(WSConstants.PASSWORD_TEXT);\n                }\n                \n                utBuilder.setUserInfo(userName, password);\n                info.setAsserted(true);\n                return utBuilder;\n            } else {\n                policyNotAsserted(token, \"No username available\");\n            }\n        } else {\n            policyNotAsserted(token, \"No username available\");\n        }\n        return null;\n    }","id":31835,"modified_method":"protected WSSecUsernameToken addUsernameToken(UsernameToken token) {\n        AssertionInfo info = null;\n        Collection<AssertionInfo> ais = aim.getAssertionInfo(token.getName());\n        for (AssertionInfo ai : ais) {\n            if (ai.getAssertion() == token) {\n                info = ai;\n                if (!isRequestor()) {\n                    info.setAsserted(true);\n                    return null;\n                }\n            }\n        }\n        \n        String userName = (String)message.getContextualProperty(SecurityConstants.USERNAME);\n        if (!StringUtils.isEmpty(userName)) {\n            WSSecUsernameToken utBuilder = new WSSecUsernameToken(wssConfig);\n            // If NoPassword property is set we don't need to set the password\n            if (token.isNoPassword()) {\n                utBuilder.setUserInfo(userName, null);\n                utBuilder.setPasswordType(null);\n            } else {\n                String password = (String)message.getContextualProperty(SecurityConstants.PASSWORD);\n                if (StringUtils.isEmpty(password)) {\n                    password = getPassword(userName, token, WSPasswordCallback.USERNAME_TOKEN);\n                }\n            \n                if (!StringUtils.isEmpty(password)) {\n                    // If the password is available then build the token\n                    if (token.isHashPassword()) {\n                        utBuilder.setPasswordType(WSConstants.PASSWORD_DIGEST);  \n                    } else {\n                        utBuilder.setPasswordType(WSConstants.PASSWORD_TEXT);\n                    }\n                    utBuilder.setUserInfo(userName, password);\n                } else {\n                    policyNotAsserted(token, \"No password available\");\n                    return null;\n                }\n            }\n            \n            if (token.isRequireCreated() && !token.isHashPassword()) {\n                utBuilder.addCreated();\n            }\n            if (token.isRequireNonce() && !token.isHashPassword()) {\n                utBuilder.addNonce();\n            }\n            \n            info.setAsserted(true);\n            return utBuilder;\n        } else {\n            policyNotAsserted(token, \"No username available\");\n            return null;\n        }\n    }","commit_id":"a0b2f45c966b688edb63e5967ee19f462077ca17","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        AssertionInfoMap aim = msg.get(AssertionInfoMap.class);\n        Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        Boolean hasDerivedKeys = null;\n        boolean hasEndorsement = false;\n        Protections prots = Protections.NONE;\n        \n        //\n        // Prefetch all signature results\n        //\n        List<WSSecurityEngineResult> signedResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.SIGN, signedResults);\n\n        for (WSSecurityEngineResult wser : results) {\n            Integer actInt = (Integer)wser.get(WSSecurityEngineResult.TAG_ACTION);\n            switch (actInt.intValue()) {   \n            case WSConstants.SIGN:\n                if (hasDerivedKeys == null) {\n                    hasDerivedKeys = Boolean.FALSE;\n                }\n                List<WSDataRef> sl = CastUtils.cast((List<?>)wser\n                                                       .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                if (sl != null) {\n                    if (sl.size() == 1\n                        && sl.get(0).getName().equals(new QName(WSConstants.SIG_NS, WSConstants.SIG_LN))) {\n                        //endorsing the signature\n                        hasEndorsement = true;\n                        break;\n                    }\n                    for (WSDataRef r : sl) {\n                        signed.add(r);\n                    }\n                    prots = addSign(prots);\n                }\n                break;\n            case WSConstants.ENCR:\n                if (hasDerivedKeys == null) {\n                    hasDerivedKeys = Boolean.FALSE;\n                }\n                List<WSDataRef> el = CastUtils.cast((List<?>)wser\n                                                       .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                if (el != null) {\n                    for (WSDataRef r : el) {\n                        encrypted.add(r);\n                    }\n                    prots = addEncrypt(prots);\n                }\n                break;\n            case WSConstants.UT:\n                Collection<AssertionInfo> ais = aim.get(SP12Constants.USERNAME_TOKEN);\n                if (ais != null) {\n                    for (AssertionInfo ai : ais) {\n                        ai.setAsserted(true);\n                    }\n                    \n                    if (utWithCallbacks) {\n                        WSUsernameTokenPrincipal princ \n                            = (WSUsernameTokenPrincipal)wser.get(WSSecurityEngineResult.TAG_PRINCIPAL);\n                        for (AssertionInfo ai : ais) {\n                            UsernameToken tok = (UsernameToken)ai.getAssertion();\n                            if (tok.isHashPassword() != princ.isPasswordDigest()) {\n                                ai.setNotAsserted(\"Password hashing policy not enforced\");\n                            }\n                        }\n                    }\n                }\n                break;\n            case WSConstants.ST_SIGNED:\n            case WSConstants.ST_UNSIGNED:\n                SamlTokenPolicyValidator validator = \n                    new SamlTokenPolicyValidator(soapBody, signedResults, msg);\n                validator.validatePolicy(aim, wser);\n                break;\n            case WSConstants.TS:\n                assertPolicy(aim, SP12Constants.INCLUDE_TIMESTAMP);\n                break;\n            case WSConstants.DKT:\n                hasDerivedKeys = Boolean.TRUE;\n                break;\n            case WSConstants.SC:\n                assertPolicy(aim, SP12Constants.WSS11);\n                break;\n            default:\n                //System.out.println(actInt);\n                //anything else to process?  Maybe check tokens for BKT requirements?\n            }                        \n        }\n        \n        CryptoCoverageUtil.reconcileEncryptedSignedRefs(signed, encrypted);\n        \n        //\n        // SIGNED_PARTS and ENCRYPTED_PARTS only apply to non-Transport bindings\n        //\n        if (!isTransportBinding(aim)) {\n            assertTokens(\n                aim, SP12Constants.SIGNED_PARTS, signed, msg, soapHeader, soapBody, CoverageType.SIGNED\n            );\n            assertTokens(\n                aim, SP12Constants.ENCRYPTED_PARTS, encrypted, msg, soapHeader, soapBody, \n                CoverageType.ENCRYPTED\n            );\n        }\n        Element soapEnvelope = soapHeader.getOwnerDocument().getDocumentElement();\n        assertXPathTokens(aim, SP12Constants.SIGNED_ELEMENTS, signed, msg, soapEnvelope,\n                CoverageType.SIGNED, CoverageScope.ELEMENT);\n        assertXPathTokens(aim, SP12Constants.ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.ELEMENT);\n        assertXPathTokens(aim, SP12Constants.CONTENT_ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.CONTENT);\n        \n        assertHeadersExists(aim, msg, soapHeader);\n        \n        assertAsymetricBinding(aim, msg, prots, hasDerivedKeys);\n        assertSymetricBinding(aim, msg, prots, hasDerivedKeys);\n        assertTransportBinding(aim);\n        \n        //REVISIT - probably can verify some of these like if UT is encrypted and/or signed, etc...\n        assertPolicy(aim, SP12Constants.SIGNED_SUPPORTING_TOKENS);\n        assertPolicy(aim, SP12Constants.SIGNED_ENCRYPTED_SUPPORTING_TOKENS);\n        assertPolicy(aim, SP12Constants.SUPPORTING_TOKENS);\n        assertPolicy(aim, SP12Constants.ENCRYPTED_SUPPORTING_TOKENS);\n        if (hasEndorsement || isRequestor(msg)) {\n            assertPolicy(aim, SP12Constants.SIGNED_ENDORSING_SUPPORTING_TOKENS);\n            assertPolicy(aim, SP12Constants.ENDORSING_ENCRYPTED_SUPPORTING_TOKENS);\n            assertPolicy(aim, SP12Constants.SIGNED_ENDORSING_ENCRYPTED_SUPPORTING_TOKENS);\n        }\n        if (isRequestor(msg)) {\n            assertPolicy(aim, SP12Constants.ENDORSING_SUPPORTING_TOKENS);\n        } else {\n            // TODO need to revisit all of the other endorsed policies\n            EndorsingTokenPolicyValidator endorsingValidator = \n                new EndorsingTokenPolicyValidator(signedResults, msg);\n            endorsingValidator.validatePolicy(aim);\n        }\n        super.doResults(msg, actor, soapHeader, soapBody, results, utWithCallbacks);\n    }","id":31836,"modified_method":"@Override\n    protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        AssertionInfoMap aim = msg.get(AssertionInfoMap.class);\n        Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        Boolean hasDerivedKeys = null;\n        boolean hasEndorsement = false;\n        Protections prots = Protections.NONE;\n        \n        //\n        // Prefetch all signature results\n        //\n        List<WSSecurityEngineResult> signedResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.SIGN, signedResults);\n\n        for (WSSecurityEngineResult wser : results) {\n            Integer actInt = (Integer)wser.get(WSSecurityEngineResult.TAG_ACTION);\n            switch (actInt.intValue()) {   \n            case WSConstants.SIGN:\n                if (hasDerivedKeys == null) {\n                    hasDerivedKeys = Boolean.FALSE;\n                }\n                List<WSDataRef> sl = CastUtils.cast((List<?>)wser\n                                                       .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                if (sl != null) {\n                    if (sl.size() == 1\n                        && sl.get(0).getName().equals(new QName(WSConstants.SIG_NS, WSConstants.SIG_LN))) {\n                        //endorsing the signature\n                        hasEndorsement = true;\n                        break;\n                    }\n                    for (WSDataRef r : sl) {\n                        signed.add(r);\n                    }\n                    prots = addSign(prots);\n                }\n                break;\n            case WSConstants.ENCR:\n                if (hasDerivedKeys == null) {\n                    hasDerivedKeys = Boolean.FALSE;\n                }\n                List<WSDataRef> el = CastUtils.cast((List<?>)wser\n                                                       .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                if (el != null) {\n                    for (WSDataRef r : el) {\n                        encrypted.add(r);\n                    }\n                    prots = addEncrypt(prots);\n                }\n                break;\n            case WSConstants.UT:\n            case WSConstants.UT_NOPASSWORD:\n                if (utWithCallbacks) {\n                    UsernameTokenPolicyValidator utValidator = \n                        new UsernameTokenPolicyValidator(msg);\n                    utValidator.validatePolicy(aim, wser);\n                } else {\n                    Collection<AssertionInfo> ais = aim.get(SP12Constants.USERNAME_TOKEN);\n                    if (ais != null) {\n                        for (AssertionInfo ai : ais) {\n                            ai.setAsserted(true);\n                        }\n                    }\n                }\n                break;\n            case WSConstants.ST_SIGNED:\n            case WSConstants.ST_UNSIGNED:\n                SamlTokenPolicyValidator validator = \n                    new SamlTokenPolicyValidator(soapBody, signedResults, msg);\n                validator.validatePolicy(aim, wser);\n                break;\n            case WSConstants.TS:\n                assertPolicy(aim, SP12Constants.INCLUDE_TIMESTAMP);\n                break;\n            case WSConstants.DKT:\n                hasDerivedKeys = Boolean.TRUE;\n                break;\n            case WSConstants.SC:\n                assertPolicy(aim, SP12Constants.WSS11);\n                break;\n            default:\n                //System.out.println(actInt);\n                //anything else to process?  Maybe check tokens for BKT requirements?\n            }                        \n        }\n        \n        CryptoCoverageUtil.reconcileEncryptedSignedRefs(signed, encrypted);\n        \n        //\n        // SIGNED_PARTS and ENCRYPTED_PARTS only apply to non-Transport bindings\n        //\n        if (!isTransportBinding(aim)) {\n            assertTokens(\n                aim, SP12Constants.SIGNED_PARTS, signed, msg, soapHeader, soapBody, CoverageType.SIGNED\n            );\n            assertTokens(\n                aim, SP12Constants.ENCRYPTED_PARTS, encrypted, msg, soapHeader, soapBody, \n                CoverageType.ENCRYPTED\n            );\n        }\n        Element soapEnvelope = soapHeader.getOwnerDocument().getDocumentElement();\n        assertXPathTokens(aim, SP12Constants.SIGNED_ELEMENTS, signed, msg, soapEnvelope,\n                CoverageType.SIGNED, CoverageScope.ELEMENT);\n        assertXPathTokens(aim, SP12Constants.ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.ELEMENT);\n        assertXPathTokens(aim, SP12Constants.CONTENT_ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.CONTENT);\n        \n        assertHeadersExists(aim, msg, soapHeader);\n        \n        assertAsymetricBinding(aim, msg, prots, hasDerivedKeys);\n        assertSymetricBinding(aim, msg, prots, hasDerivedKeys);\n        assertTransportBinding(aim);\n        \n        //REVISIT - probably can verify some of these like if UT is encrypted and/or signed, etc...\n        assertPolicy(aim, SP12Constants.SIGNED_SUPPORTING_TOKENS);\n        assertPolicy(aim, SP12Constants.SIGNED_ENCRYPTED_SUPPORTING_TOKENS);\n        assertPolicy(aim, SP12Constants.SUPPORTING_TOKENS);\n        assertPolicy(aim, SP12Constants.ENCRYPTED_SUPPORTING_TOKENS);\n        if (hasEndorsement || isRequestor(msg)) {\n            assertPolicy(aim, SP12Constants.SIGNED_ENDORSING_SUPPORTING_TOKENS);\n            assertPolicy(aim, SP12Constants.ENDORSING_ENCRYPTED_SUPPORTING_TOKENS);\n            assertPolicy(aim, SP12Constants.SIGNED_ENDORSING_ENCRYPTED_SUPPORTING_TOKENS);\n        }\n        if (isRequestor(msg)) {\n            assertPolicy(aim, SP12Constants.ENDORSING_SUPPORTING_TOKENS);\n        } else {\n            // TODO need to revisit all of the other endorsed policies\n            EndorsingTokenPolicyValidator endorsingValidator = \n                new EndorsingTokenPolicyValidator(signedResults, msg);\n            endorsingValidator.validatePolicy(aim);\n        }\n        super.doResults(msg, actor, soapHeader, soapBody, results, utWithCallbacks);\n    }","commit_id":"a0b2f45c966b688edb63e5967ee19f462077ca17","url":"https://github.com/apache/cxf"},{"original_method":"public Assertion build(Element element, AssertionBuilderFactory factory) {\n        \n        SPConstants consts = SP11Constants.SP_NS.equals(element.getNamespaceURI())\n            ? SP11Constants.INSTANCE : SP12Constants.INSTANCE;\n\n        UsernameToken usernameToken = new UsernameToken(consts);\n        usernameToken.setOptional(PolicyConstants.isOptional(element));\n        usernameToken.setIgnorable(PolicyConstants.isIgnorable(element));\n\n        String attribute = element.getAttributeNS(element.getNamespaceURI(), SPConstants.ATTR_INCLUDE_TOKEN);\n        if (attribute != null) {\n            usernameToken.setInclusion(consts.getInclusionFromAttributeValue(attribute));\n        }\n\n        Element polEl = PolicyConstants.findPolicyElement(element);\n        if (polEl != null) {\n            NodeList children = polEl.getChildNodes();\n            if (children != null) {\n                for (int i = 0; i < children.getLength(); i++) {\n                    Node child = children.item(i);\n                    if (child instanceof Element) {\n                        child = (Element)child;\n                        QName qname = new QName(child.getNamespaceURI(), child.getLocalName());\n                        if (SPConstants.USERNAME_TOKEN10.equals(qname.getLocalPart())) {\n                            usernameToken.setUseUTProfile10(true);\n                        } else if (SPConstants.USERNAME_TOKEN11.equals(qname.getLocalPart())) {\n                            usernameToken.setUseUTProfile11(true);\n                        } else if (SP12Constants.NO_PASSWORD.equals(qname)) {\n                            usernameToken.setNoPassword(true);\n                        } else if (SP12Constants.HASH_PASSWORD.equals(qname)) {\n                            usernameToken.setHashPassword(true);\n                        } else if (SP12Constants.REQUIRE_DERIVED_KEYS.equals(qname)) {\n                            usernameToken.setDerivedKeys(true);\n                        } else if (SP12Constants.REQUIRE_EXPLICIT_DERIVED_KEYS.equals(qname)) {\n                            usernameToken.setExplicitDerivedKeys(true);\n                        } else if (SP12Constants.REQUIRE_IMPLIED_DERIVED_KEYS.equals(qname)) {\n                            usernameToken.setImpliedDerivedKeys(true);\n                        }\n                    }\n                }\n            }\n        }\n        return usernameToken;\n    }","id":31837,"modified_method":"public Assertion build(Element element, AssertionBuilderFactory factory) {\n        \n        SPConstants consts = SP11Constants.SP_NS.equals(element.getNamespaceURI())\n            ? SP11Constants.INSTANCE : SP12Constants.INSTANCE;\n\n        UsernameToken usernameToken = new UsernameToken(consts);\n        usernameToken.setOptional(PolicyConstants.isOptional(element));\n        usernameToken.setIgnorable(PolicyConstants.isIgnorable(element));\n\n        String attribute = element.getAttributeNS(element.getNamespaceURI(), SPConstants.ATTR_INCLUDE_TOKEN);\n        if (attribute != null) {\n            usernameToken.setInclusion(consts.getInclusionFromAttributeValue(attribute));\n        }\n\n        Element polEl = PolicyConstants.findPolicyElement(element);\n        if (polEl != null) {\n            NodeList children = polEl.getChildNodes();\n            if (children != null) {\n                for (int i = 0; i < children.getLength(); i++) {\n                    Node child = children.item(i);\n                    if (child instanceof Element) {\n                        child = (Element)child;\n                        QName qname = new QName(child.getNamespaceURI(), child.getLocalName());\n                        if (SPConstants.USERNAME_TOKEN10.equals(qname.getLocalPart())) {\n                            usernameToken.setUseUTProfile10(true);\n                        } else if (SPConstants.USERNAME_TOKEN11.equals(qname.getLocalPart())) {\n                            usernameToken.setUseUTProfile11(true);\n                        } else if (SP12Constants.NO_PASSWORD.equals(qname)) {\n                            usernameToken.setNoPassword(true);\n                        } else if (SP12Constants.HASH_PASSWORD.equals(qname)) {\n                            usernameToken.setHashPassword(true);\n                        } else if (SP12Constants.REQUIRE_DERIVED_KEYS.equals(qname)) {\n                            usernameToken.setDerivedKeys(true);\n                        } else if (SP12Constants.REQUIRE_EXPLICIT_DERIVED_KEYS.equals(qname)) {\n                            usernameToken.setExplicitDerivedKeys(true);\n                        } else if (SP12Constants.REQUIRE_IMPLIED_DERIVED_KEYS.equals(qname)) {\n                            usernameToken.setImpliedDerivedKeys(true);\n                        } else if (SP13Constants.USERNAME_TOKEN_CREATED.equals(qname)) {\n                            usernameToken.setRequireCreated(true);\n                        } else if (SP13Constants.USERNAME_TOKEN_NONCE.equals(qname)) {\n                            usernameToken.setRequireNonce(true);\n                        }\n                    }\n                }\n            }\n        }\n        return usernameToken;\n    }","commit_id":"a0b2f45c966b688edb63e5967ee19f462077ca17","url":"https://github.com/apache/cxf"},{"original_method":"private ClientTokenContext initializeClientTokenContext(ClientAccessToken at, \n                                                            MultivaluedMap<String, String> params) {\n        ClientTokenContext tokenContext = createTokenContext(at);\n        ((ClientTokenContextImpl)tokenContext).setToken(at);\n        if (clientStateManager != null) {\n            MultivaluedMap<String, String> state = clientStateManager.fromRedirectState(mc, params);\n            ((ClientTokenContextImpl)tokenContext).setState(state);\n        }\n        \n        return tokenContext;\n        \n    }","id":31838,"modified_method":"protected ClientTokenContext initializeClientTokenContext(ContainerRequestContext rc, \n                                                              ClientAccessToken at, \n                                                            MultivaluedMap<String, String> params) {\n        ClientTokenContext tokenContext = createTokenContext(rc, at);\n        ((ClientTokenContextImpl)tokenContext).setToken(at);\n        if (clientStateManager != null) {\n            MultivaluedMap<String, String> state = clientStateManager.fromRedirectState(mc, params);\n            ((ClientTokenContextImpl)tokenContext).setState(state);\n        }\n        \n        return tokenContext;\n        \n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"protected ClientTokenContext createTokenContext(ClientAccessToken at) {\n        return new ClientTokenContextImpl();\n    }","id":31839,"modified_method":"protected ClientTokenContext createTokenContext(ContainerRequestContext rc, ClientAccessToken at) {\n        return new ClientTokenContextImpl();\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void filter(ContainerRequestContext rc) throws IOException {\n        SecurityContext sc = rc.getSecurityContext();\n        if (sc == null || sc.getUserPrincipal() == null) {\n            throw ExceptionUtils.toNotAuthorizedException(null, null);\n        }\n        UriInfo ui = rc.getUriInfo();\n        String absoluteRequestUri = ui.getAbsolutePath().toString();\n        \n        boolean sameUriRedirect = false;\n        if (completeUri == null) {\n            String referer = rc.getHeaderString(\"Referer\");\n            if (referer != null && referer.startsWith(authorizationServiceUri)) {\n                completeUri = absoluteRequestUri;\n                sameUriRedirect = true;\n            }\n        }\n        \n        if (!sameUriRedirect && absoluteRequestUri.endsWith(startUri)) {\n            ClientTokenContext request = getClientTokenContext();\n            if (request != null) {\n                setClientCodeRequest(request);\n                if (completeUri != null) {\n                    rc.setRequestUri(URI.create(completeUri));\n                }\n                return;\n            }\n            Response codeResponse = createCodeResponse(rc, sc, ui);\n            rc.abortWith(codeResponse);\n        } else if (absoluteRequestUri.endsWith(completeUri)) {\n            processCodeResponse(rc, sc, ui);\n        }\n    }","id":31840,"modified_method":"@Override\n    public void filter(ContainerRequestContext rc) throws IOException {\n        checkSecurityContextStart(rc.getSecurityContext());\n        UriInfo ui = rc.getUriInfo();\n        String absoluteRequestUri = ui.getAbsolutePath().toString();\n        \n        boolean sameUriRedirect = false;\n        if (completeUri == null) {\n            String referer = rc.getHeaderString(\"Referer\");\n            if (referer != null && referer.startsWith(authorizationServiceUri)) {\n                completeUri = absoluteRequestUri;\n                sameUriRedirect = true;\n            }\n        }\n        \n        if (!sameUriRedirect && absoluteRequestUri.endsWith(startUri)) {\n            ClientTokenContext request = getClientTokenContext(rc);\n            if (request != null) {\n                setClientCodeRequest(request);\n                if (completeUri != null) {\n                    rc.setRequestUri(URI.create(completeUri));\n                }\n                return;\n            }\n            Response codeResponse = createCodeResponse(rc,  ui);\n            rc.abortWith(codeResponse);\n        } else if (absoluteRequestUri.endsWith(completeUri)) {\n            processCodeResponse(rc, ui);\n            checkSecurityContextEnd(rc.getSecurityContext());\n        }\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"private ClientTokenContext getClientTokenContext() {\n        ClientTokenContext ctx = null;\n        if (clientTokenContextManager != null) {\n            ctx = clientTokenContextManager.getClientTokenContext(mc);\n            if (ctx != null) {\n                ClientAccessToken newAt = refreshAccessTokenIfExpired(ctx.getToken());\n                if (newAt != null) {\n                    clientTokenContextManager.removeClientTokenContext(mc, ctx);\n                    ClientTokenContext newCtx = initializeClientTokenContext(newAt, ctx.getState());            \n                    clientTokenContextManager.setClientTokenContext(mc, newCtx);\n                    ctx = newCtx;\n                }\n            }\n        }\n        return ctx;\n    }","id":31841,"modified_method":"protected ClientTokenContext getClientTokenContext(ContainerRequestContext rc) {\n        ClientTokenContext ctx = null;\n        if (clientTokenContextManager != null) {\n            ctx = clientTokenContextManager.getClientTokenContext(mc);\n            if (ctx != null) {\n                ClientAccessToken newAt = refreshAccessTokenIfExpired(ctx.getToken());\n                if (newAt != null) {\n                    clientTokenContextManager.removeClientTokenContext(mc, ctx);\n                    ClientTokenContext newCtx = initializeClientTokenContext(rc, newAt, ctx.getState());            \n                    clientTokenContextManager.setClientTokenContext(mc, newCtx);\n                    ctx = newCtx;\n                }\n            }\n        }\n        return ctx;\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"public void setScopeString(String scopesString) {\n        this.scopes = scopesString;\n    }","id":31842,"modified_method":"public void setScopes(String scopes) {\n        this.scopes = scopes;\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"private Response createCodeResponse(ContainerRequestContext rc, SecurityContext sc, UriInfo ui) {\n        MultivaluedMap<String, String> redirectState = createRedirectState(rc, sc, ui);\n        String redirectScope = redirectState.getFirst(OAuthConstants.SCOPE);\n        String theScope = redirectScope != null ? redirectScope : scopes;\n        URI uri = OAuthClientUtils.getAuthorizationURI(authorizationServiceUri, \n                                             consumer.getKey(), \n                                             getAbsoluteRedirectUri(ui).toString(), \n                                             redirectState.getFirst(OAuthConstants.STATE), \n                                             theScope);\n        return Response.seeOther(uri).build();\n    }","id":31843,"modified_method":"private Response createCodeResponse(ContainerRequestContext rc, UriInfo ui) {\n        MultivaluedMap<String, String> redirectState = createRedirectState(rc, ui);\n        String theState = redirectState != null ? redirectState.getFirst(OAuthConstants.SCOPE) : null;\n        String redirectScope = redirectState != null ? redirectState.getFirst(OAuthConstants.SCOPE) : null;\n        String theScope = redirectScope != null ? redirectScope : scopes;\n        URI uri = OAuthClientUtils.getAuthorizationURI(authorizationServiceUri, \n                                             consumer.getKey(), \n                                             getAbsoluteRedirectUri(ui).toString(), \n                                             theState, \n                                             theScope);\n        return Response.seeOther(uri).build();\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"private MultivaluedMap<String, String> createRedirectState(ContainerRequestContext rc, SecurityContext sc, \n                                                               UriInfo ui) {\n        if (clientStateManager == null) {\n            return null;\n        }\n        return clientStateManager.toRedirectState(mc, toRequestState(rc, ui));\n    }","id":31844,"modified_method":"private MultivaluedMap<String, String> createRedirectState(ContainerRequestContext rc, UriInfo ui) {\n        if (clientStateManager == null) {\n            return null;\n        }\n        return clientStateManager.toRedirectState(mc, toRequestState(rc, ui));\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"public void setAccessTokenService(WebClient accessTokenService) {\n        this.accessTokenService = accessTokenService;\n    }","id":31845,"modified_method":"public void setAccessTokenServiceClient(WebClient accessTokenServiceClient) {\n        this.accessTokenServiceClient = accessTokenServiceClient;\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"private ClientAccessToken refreshAccessTokenIfExpired(ClientAccessToken at) {\n        if (at.getRefreshToken() != null\n            && ((expiryThreshold > 0 && OAuthUtils.isExpired(at.getIssuedAt(), at.getExpiresIn() - expiryThreshold))\n            || OAuthUtils.isExpired(at.getIssuedAt(), at.getExpiresIn()))) {\n            return OAuthClientUtils.refreshAccessToken(accessTokenService, consumer, at);\n        }\n        return null;\n    }","id":31846,"modified_method":"private ClientAccessToken refreshAccessTokenIfExpired(ClientAccessToken at) {\n        if (at.getRefreshToken() != null\n            && ((expiryThreshold > 0 && OAuthUtils.isExpired(at.getIssuedAt(), at.getExpiresIn() - expiryThreshold))\n            || OAuthUtils.isExpired(at.getIssuedAt(), at.getExpiresIn()))) {\n            return OAuthClientUtils.refreshAccessToken(accessTokenServiceClient, consumer, at);\n        }\n        return null;\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"private URI getAbsoluteRedirectUri(UriInfo ui) {\n        if (completeUri != null) {\n            return completeUri.startsWith(\"http\") ? URI.create(completeUri) \n                : ui.getBaseUriBuilder().path(completeUri).build();\n        } else {\n            return ui.getAbsolutePath();\n        }\n    }","id":31847,"modified_method":"private URI getAbsoluteRedirectUri(UriInfo ui) {\n        if (redirectUri != null) {\n            return URI.create(redirectUri);\n        } else if (completeUri != null) {\n            return completeUri.startsWith(\"http\") ? URI.create(completeUri) \n                : ui.getBaseUriBuilder().path(completeUri).build();\n        } else {\n            return ui.getAbsolutePath();\n        }\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"public void setScopeList(List<String> list) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : list) {\n            if (sb.length() > 0) {\n                sb.append(\" \");\n            }\n            sb.append(s);\n        }\n        setScopeString(sb.toString());\n    }","id":31848,"modified_method":"public void setScopeList(List<String> list) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : list) {\n            if (sb.length() > 0) {\n                sb.append(\" \");\n            }\n            sb.append(s);\n        }\n        setScopes(sb.toString());\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"protected void processCodeResponse(ContainerRequestContext rc, SecurityContext sc, UriInfo ui) {\n        MultivaluedMap<String, String> params = toRequestState(rc, ui);\n        String codeParam = params.getFirst(OAuthConstants.AUTHORIZATION_CODE_VALUE);\n        ClientAccessToken at = null;\n        if (codeParam != null) {\n            AccessTokenGrant grant = new AuthorizationCodeGrant(codeParam, getAbsoluteRedirectUri(ui));\n            at = OAuthClientUtils.getAccessToken(accessTokenService, consumer, grant);\n        }\n        ClientTokenContext tokenContext = initializeClientTokenContext(at, params);\n        if (at != null && clientTokenContextManager != null) {\n            clientTokenContextManager.setClientTokenContext(mc, tokenContext);\n        }\n        setClientCodeRequest(tokenContext);\n    }","id":31849,"modified_method":"protected void processCodeResponse(ContainerRequestContext rc, UriInfo ui) {\n        MultivaluedMap<String, String> params = toRequestState(rc, ui);\n        String codeParam = params.getFirst(OAuthConstants.AUTHORIZATION_CODE_VALUE);\n        ClientAccessToken at = null;\n        if (codeParam != null) {\n            AccessTokenGrant grant = new AuthorizationCodeGrant(codeParam, getAbsoluteRedirectUri(ui));\n            at = OAuthClientUtils.getAccessToken(accessTokenServiceClient, consumer, grant);\n        }\n        ClientTokenContext tokenContext = initializeClientTokenContext(rc, at, params);\n        if (at != null && clientTokenContextManager != null) {\n            clientTokenContextManager.setClientTokenContext(mc, tokenContext);\n        }\n        setClientCodeRequest(tokenContext);\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected ClientTokenContext createTokenContext(ClientAccessToken at) {\n        OidcClientTokenContextImpl ctx = new OidcClientTokenContextImpl();\n        if (at != null) {\n            ctx.setIdToken(userInfoClient.getIdToken(at, getConsumer().getKey()));\n            ctx.setUserInfo(userInfoClient.getUserInfo(at, ctx.getIdToken()));\n        }\n        return ctx;\n    }","id":31850,"modified_method":"@Override\n    protected ClientTokenContext createTokenContext(ContainerRequestContext rc, ClientAccessToken at) {\n        OidcClientTokenContextImpl ctx = new OidcClientTokenContextImpl();\n        if (at != null) {\n            ctx.setIdToken(userInfoClient.getIdToken(at, getConsumer().getKey()));\n            if (userInfoRequired) {\n                ctx.setUserInfo(userInfoClient.getUserInfo(at, ctx.getIdToken()));\n            }\n            rc.setSecurityContext(new OidcSecurityContext(ctx));\n        }\n        \n        return ctx;\n    }","commit_id":"6909358dee4beaa00b493b728dd7689331173d2a","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create a table from TableConfig configuration.\n     *\n     * @param doc currently edited document.\n     * @param config table configuration (row number, etc).\n     * @return the newly created table.\n     */\n    public Element createTable(Document doc, TableConfig config) \n    {\n        Element table = doc.xCreateElement(TableUtils.TABLE_NODENAME);       \n        Element tbody = doc.xCreateElement(TableUtils.TBODY_NODENAME);\n        Element row;\n        Element cell;\n                        \n        table.appendChild(tbody);        \n\n        // Set table border\n        // table.setBorder(config.getBorderSize());\n        \n        // Create a table with rows and columns according to the configuration\n        for (int i = 0; i < config.getRowNumber(); i++) {\n            row = doc.xCreateElement(TableUtils.ROW_NODENAME);            \n            tbody.appendChild(row);                 \n            for (int j = 0; j < config.getColNumber(); j++) {\n                if (i == 0 && config.hasHeader()) {\n                    cell = doc.xCreateElement(TableUtils.COL_HNODENAME);\n                } else {\n                    cell = doc.xCreateElement(TableUtils.COL_NODENAME);                    \n                }                \n                cell.setInnerHTML(TableUtils.CELL_DEFAULTHTML);            \n                row.appendChild(cell);                \n            }\n        }\n        \n        return table;\n    }","id":31851,"modified_method":"/**\n     * Create a table from TableConfig configuration.\n     * <p>\n     * We create the table using innerHTML instead of creating each DOM node in order to improve the speed. In most of\n     * the browsers setting the innerHTML is faster than creating the DOM nodes and appending them.\n     * \n     * @param doc currently edited document.\n     * @param config table configuration (row number, etc).\n     * @return the newly created table.\n     */\n    public Element createTable(Document doc, TableConfig config)\n    {\n        StringBuffer table = new StringBuffer(\"<table>\");\n\n        StringBuffer row = new StringBuffer(\"<tr>\");\n        for (int i = 0; i < config.getColNumber(); i++) {\n            row.append(\"<td>\");\n            // The default cell content depends on the browser. In Firefox the best option is to use a BR. Firefox\n            // itself uses BRs in order to allow the user to place the caret inside empty block elements. In Internet\n            // Explorer the best option is to set the inner HTML of each cell to the empty string, after creation. For\n            // now lets keep the non-breaking space. At some point we should have browser specific implementations for\n            // FF and IE. Each will overwrite this method and add specific initialization.\n            row.append(TableUtils.CELL_DEFAULTHTML);\n            row.append(\"<\/td>\");\n        }\n        row.append(\"<\/tr>\");\n\n        if (config.hasHeader()) {\n            table.append(\"<thead>\");\n            if (config.getRowNumber() > 0) {\n                table.append(row.toString().replace(\"td\", \"th\"));\n            }\n            table.append(\"<\/thead>\");\n        }\n\n        table.append(\"<tbody>\");\n        for (int i = config.hasHeader() ? 1 : 0; i < config.getRowNumber(); i++) {\n            table.append(row.toString());\n        }\n        table.append(\"<\/tbody><\/table>\");\n\n        Element container = doc.xCreateDivElement().cast();\n        container.setInnerHTML(table.toString());\n        Element tableElement = (Element) container.getFirstChild();\n        container.removeChild(tableElement);\n        return tableElement;\n    }","commit_id":"a10904d71c30a400a048212f74ddee541ade8468","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Insert a HTML table in the editor.\n     * \n     * @param rta WYSIWYG RichTextArea\n     * @param config creation parameters.\n     */\n    public void insertTable(RichTextArea rta, TableConfig config)\n    {\n        Range range = TableUtils.getInstance().getRange(rta.getDocument());\n        Selection selection = rta.getDocument().getSelection();\n        Node start = range.getStartContainer();\n        int offset = range.getStartOffset();\n        Node flowContainer = DOMUtils.getInstance().getNearestFlowContainer(start);\n        Element table = createTable(rta.getDocument(), config);\n        Node nodeToSelect;\n\n        // Leave the rest of the ranges intact.\n        selection.removeAllRanges();\n\n        // Delete the contents of the first range. The table will be inserted in place of the deleted text.\n        range.deleteContents();\n\n        // Insert the table in the DOM.\n        if (flowContainer == start) {\n            DOMUtils.getInstance().insertAt(flowContainer, table, offset);\n        } else {\n            DOMUtils.getInstance().splitNode(flowContainer, start, offset);\n            DOMUtils.getInstance().insertAfter(table, DOMUtils.getInstance().getChild(flowContainer, start));\n        }\n        \n        // Find the first table cell to put the caret within.\n        if (config.hasHeader()) {            \n            nodeToSelect = DOMUtils.getInstance().getFirstDescendant(table, TableUtils.COL_HNODENAME);\n        } else {\n            nodeToSelect = DOMUtils.getInstance().getFirstDescendant(table, TableUtils.COL_NODENAME);\n        }\n        \n        range.selectNodeContents(nodeToSelect);\n        range.collapse(false);\n        selection.addRange(range);                \n    }","id":31852,"modified_method":"/**\n     * Insert a HTML table in the editor.\n     * \n     * @param rta WYSIWYG RichTextArea\n     * @param config creation parameters.\n     */\n    public void insertTable(RichTextArea rta, TableConfig config)\n    {\n        Selection selection = rta.getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n\n        // Leave the rest of the ranges intact.\n        selection.removeAllRanges();\n\n        // Delete the contents of the first range. The horizontal rule will be inserted in place of the deleted text.\n        range.deleteContents();\n\n        // Split the DOM tree up to the nearest flow container and insert the table.\n        Node start = range.getStartContainer();\n        int offset = range.getStartOffset();\n        Node flowContainer = DOMUtils.getInstance().getNearestFlowContainer(start);\n        if (flowContainer == null) {\n            return;\n        }\n        Element table = createTable(rta.getDocument(), config);\n        if (flowContainer == start) {\n            DOMUtils.getInstance().insertAt(flowContainer, table, offset);\n        } else {\n            DOMUtils.getInstance().splitNode(flowContainer, start, offset);\n            DOMUtils.getInstance().insertAfter(table, DOMUtils.getInstance().getChild(flowContainer, start));\n        }\n\n        // Place the caret at the beginning of the first cell.\n        range.selectNodeContents(DOMUtils.getInstance().getFirstDescendant(table,\n            config.hasHeader() ? TableUtils.COL_HNODENAME : TableUtils.COL_NODENAME));\n        range.collapse(false);\n        selection.addRange(range);\n    }","commit_id":"a10904d71c30a400a048212f74ddee541ade8468","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Overwrites the default rich text area behavior when the Enter key is being pressed.\n     */\n    protected void onEnter()\n    {\n        Selection selection = getTextArea().getDocument().getSelection();\n        if (selection.getRangeCount() == 0) {\n            return;\n        }\n        Range range = selection.getRangeAt(0);\n        Node ancestor = DOMUtils.getInstance().getNearestBlockContainer((range.getStartContainer()));\n        String tagName = ancestor.getNodeName().toLowerCase();\n        if (LI.equals(tagName)) {\n            // Leave the default behavior for now.\n        } else if (TD.equals(tagName) || TH.equals(tagName)) {\n            onEnterTableCell(ancestor);\n        } else {\n            onEnterParagraph(ancestor);\n        }\n    }","id":31853,"modified_method":"/**\n     * Overwrites the default rich text area behavior when the Enter key is being pressed.\n     */\n    protected void onEnter()\n    {\n        Selection selection = getTextArea().getDocument().getSelection();\n        if (selection.getRangeCount() == 0) {\n            return;\n        } else if (!selection.isCollapsed()) {\n            // Selection + Enter = Selection + Delete + Enter\n            // NOTE: We cannot use Range#deleteContents because it may lead to DTD-invalid HTML. That's because it\n            // operates on any DOM tree without taking care of the underlying XML syntax, (X)HTML in our case. Let's use\n            // the Delete command instead which is HTML-aware.\n            getTextArea().getCommandManager().execute(Command.DELETE);\n        }\n\n        // At this point the selection should be collapsed.\n        Range range = selection.getRangeAt(0);\n        Node ancestor = domUtils.getNearestBlockContainer((range.getStartContainer()));\n        String tagName = ancestor.getNodeName().toLowerCase();\n        if (LI.equals(tagName)) {\n            // Leave the default behavior for now.\n        } else if (TD.equals(tagName) || TH.equals(tagName)) {\n            onEnterTableCell(ancestor);\n        } else {\n            onEnterParagraph(ancestor);\n        }\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Behaves as if the caret is inside a paragraph. Precisely:\n     * <ul>\n     * <li>1 return key generates a line break (BR)<\/li>\n     * <li>2 consecutive return keys generate a paragraph<\/li>\n     * <li>3 or more consecutive return keys generate div's with class <em>wikimodel-emptyline<\/em> (their purpose is to\n     * separate block level elements).<\/li>\n     * <\/ul>\n     * \n     * @param container The block level element containing the start of the first range.\n     */\n    protected void onEnterParagraph(Node container)\n    {\n        // Cancel the event to prevent its default behavior.\n        getTextArea().getCurrentEvent().xPreventDefault();\n\n        Selection selection = getTextArea().getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n\n        // If range ends with a BR tag then we must not delete it.\n        if (!range.isCollapsed()) {\n            Node leaf = DOMUtils.getInstance().getLastLeaf(range);\n            if (BR.equalsIgnoreCase(leaf.getNodeName())) {\n                range.setEndBefore(leaf);\n            }\n        }\n        // Delete the text from the first range and leave the text of the other ranges untouched.\n        range.deleteContents();\n\n        if (isAtStart(container, range)) {\n            onEnterParagraphThrice(container, range);\n        } else if (isAfterBR(container, range)) {\n            onEnterParagraphTwice(container, range);\n        } else {\n            onEnterParagraphOnce(container, range);\n        }\n\n        range.collapse(true);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }","id":31854,"modified_method":"/**\n     * Behaves as if the caret is inside a paragraph. Precisely:\n     * <ul>\n     * <li>1 return key generates a line break (BR)<\/li>\n     * <li>2 consecutive return keys generate a paragraph<\/li>\n     * <li>3 or more consecutive return keys generate div's with class <em>wikimodel-emptyline<\/em> (their purpose is to\n     * separate block level elements).<\/li>\n     * <\/ul>\n     * \n     * @param container The block level element containing the start of the first range.\n     */\n    protected void onEnterParagraph(Node container)\n    {\n        // Cancel the event to prevent its default behavior.\n        getTextArea().getCurrentEvent().xPreventDefault();\n\n        Selection selection = getTextArea().getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n\n        if (isAtStart(container, range)) {\n            onEnterParagraphThrice(container, range);\n        } else if (isAfterBR(container, range)) {\n            onEnterParagraphTwice(container, range);\n        } else {\n            onEnterParagraphOnce(container, range);\n        }\n\n        range.collapse(true);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tab key has been pressed inside a table cell.\n     * \n     * @param cell The table cell in which the tab key has been pressed.\n     */\n    protected void onTabInTableCell(TableCellElement cell)\n    {\n        Node nextCell = getTextArea().getCurrentEvent().getShiftKey() ? cell.getPreviousCell() : cell.getNextCell();\n        if (nextCell != null) {\n            Selection selection = getTextArea().getDocument().getSelection();\n            Range range = selection.getRangeAt(0);\n\n            // Place the caret at the beginning of the next cell.\n            Node leaf = DOMUtils.getInstance().getFirstLeaf(nextCell);\n            if (leaf == nextCell || leaf.getNodeType() == Node.TEXT_NODE) {\n                range.setStart(leaf, 0);\n            } else {\n                range.setStartBefore(leaf);\n            }\n\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n    }","id":31855,"modified_method":"/**\n     * Tab key has been pressed inside a table cell.\n     * \n     * @param cell The table cell in which the tab key has been pressed.\n     */\n    protected void onTabInTableCell(TableCellElement cell)\n    {\n        Node nextCell = getTextArea().getCurrentEvent().getShiftKey() ? cell.getPreviousCell() : cell.getNextCell();\n        if (nextCell != null) {\n            Selection selection = getTextArea().getDocument().getSelection();\n            Range range = selection.getRangeAt(0);\n\n            // Place the caret at the beginning of the next cell.\n            Node leaf = domUtils.getFirstLeaf(nextCell);\n            if (leaf == nextCell || leaf.getNodeType() == Node.TEXT_NODE) {\n                range.setStart(leaf, 0);\n            } else {\n                range.setStartBefore(leaf);\n            }\n\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Handles the case when Enter is pressed inside a table cell.\n     * \n     * @param cell The table cell where the Enter has been pressed.\n     */\n    protected void onEnterTableCell(Node cell)\n    {\n        // Cancel the event to prevent its default behavior.\n        getTextArea().getCurrentEvent().xPreventDefault();\n\n        Selection selection = getTextArea().getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n\n        // If range ends with a BR tag then we must not delete it.\n        if (!range.isCollapsed()) {\n            Node leaf = DOMUtils.getInstance().getLastLeaf(range);\n            if (BR.equalsIgnoreCase(leaf.getNodeName())) {\n                range.setEndBefore(leaf);\n            }\n        }\n        // Delete the text from the first range and leave the text of the other ranges untouched.\n        range.deleteContents();\n\n        onEnterParagraphOnce(cell, range);\n\n        range.collapse(true);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }","id":31856,"modified_method":"/**\n     * Handles the case when Enter is pressed inside a table cell.\n     * \n     * @param cell The table cell where the Enter has been pressed.\n     */\n    protected void onEnterTableCell(Node cell)\n    {\n        // Cancel the event to prevent its default behavior.\n        getTextArea().getCurrentEvent().xPreventDefault();\n\n        Selection selection = getTextArea().getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n\n        onEnterParagraphOnce(cell, range);\n\n        range.collapse(true);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param container A block level element containing the start of the given range.\n     * @param range A DOM range.\n     * @return true if the start of the given range is immediately after a BR element.\n     */\n    protected boolean isAfterBR(Node container, Range range)\n    {\n        Node leaf;\n        if (range.getStartOffset() > 0) {\n            if (range.getStartContainer().getNodeType() == Node.ELEMENT_NODE) {\n                leaf = range.getStartContainer().getChildNodes().getItem(range.getStartOffset() - 1);\n                leaf = DOMUtils.getInstance().getLastLeaf(leaf);\n            } else {\n                // We are in the middle of the text.\n                return false;\n            }\n        } else {\n            leaf = DOMUtils.getInstance().getPreviousLeaf(range.getStartContainer());\n        }\n        // We have to additionally test if the found BR is in the given container.\n        return isBR(leaf) && container == DOMUtils.getInstance().getNearestBlockContainer(leaf);\n    }","id":31857,"modified_method":"/**\n     * @param container A block level element containing the start of the given range.\n     * @param range A DOM range.\n     * @return true if the start of the given range is immediately after a BR element.\n     */\n    protected boolean isAfterBR(Node container, Range range)\n    {\n        Node leaf;\n        if (range.getStartOffset() > 0) {\n            if (range.getStartContainer().getNodeType() == Node.ELEMENT_NODE) {\n                leaf = range.getStartContainer().getChildNodes().getItem(range.getStartOffset() - 1);\n                leaf = domUtils.getLastLeaf(leaf);\n            } else {\n                // We are in the middle of the text.\n                return false;\n            }\n        } else {\n            leaf = domUtils.getPreviousLeaf(range.getStartContainer());\n        }\n        // We have to additionally test if the found BR is in the given container.\n        return isBR(leaf) && container == domUtils.getNearestBlockContainer(leaf);\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param container A block level element containing the start of the given range.\n     * @param range A DOM range.\n     * @return true if the start of the given range is at the beginning of its block level container.\n     */\n    protected boolean isAtStart(Node container, Range range)\n    {\n        if (!container.hasChildNodes()) {\n            return true;\n        }\n        if (range.getStartOffset() > 0) {\n            return false;\n        }\n        return DOMUtils.getInstance().getFirstLeaf(container) == DOMUtils.getInstance().getFirstLeaf(\n            range.getStartContainer());\n    }","id":31858,"modified_method":"/**\n     * @param container A block level element containing the start of the given range.\n     * @param range A DOM range.\n     * @return true if the start of the given range is at the beginning of its block level container.\n     */\n    protected boolean isAtStart(Node container, Range range)\n    {\n        if (!container.hasChildNodes()) {\n            return true;\n        }\n        if (range.getStartOffset() > 0) {\n            return false;\n        }\n        return domUtils.getFirstLeaf(container) == domUtils.getFirstLeaf(range.getStartContainer());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Enter has been pressed thrice inside a block level element. We must be at the beginning of the given block so we\n     * insert an empty line before it. In other words we move the block one line below.\n     * \n     * @param container The block level element.\n     * @param range The caret.\n     */\n    protected void onEnterParagraphThrice(Node container, Range range)\n    {\n        Document document = getTextArea().getDocument();\n        // Create a new paragraph.\n        Element paragraph = document.xCreatePElement().cast();\n\n        if (DOMUtils.getInstance().isFlowContainer(container)) {\n            // We are at the beginning of a flow container. Since it can contain block elements we insert the paragraph\n            // before its first child.\n            DOMUtils.getInstance().insertAt(container, paragraph, 0);\n            // We place the caret after the inserted paragraph.\n            range.setStartAfter(paragraph);\n        } else {\n            // Insert the paragraph before the container.\n            container.getParentNode().insertBefore(paragraph, container);\n        }\n    }","id":31859,"modified_method":"/**\n     * Enter has been pressed thrice inside a block level element. We must be at the beginning of the given block so we\n     * insert an empty line before it. In other words we move the block one line below.\n     * \n     * @param container The block level element.\n     * @param range The caret.\n     */\n    protected void onEnterParagraphThrice(Node container, Range range)\n    {\n        Document document = getTextArea().getDocument();\n        // Create a new paragraph.\n        Element paragraph = document.xCreatePElement().cast();\n\n        if (domUtils.isFlowContainer(container)) {\n            // We are at the beginning of a flow container. Since it can contain block elements we insert the paragraph\n            // before its first child.\n            domUtils.insertAt(container, paragraph, 0);\n            // We place the caret after the inserted paragraph.\n            range.setStartAfter(paragraph);\n        } else {\n            // Insert the paragraph before the container.\n            container.getParentNode().insertBefore(paragraph, container);\n        }\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Enter has been pressed twice inside a block level element.\n     * \n     * @param container The block level element containing the start of the given range.\n     * @param range The caret.\n     */\n    protected void onEnterParagraphTwice(Node container, Range range)\n    {\n        Node br;\n        // Find the BR.\n        if (range.getStartOffset() > 0) {\n            if (range.getStartContainer().getNodeType() == Node.ELEMENT_NODE) {\n                br = range.getStartContainer().getChildNodes().getItem(range.getStartOffset() - 1);\n                br = DOMUtils.getInstance().getLastLeaf(br);\n            } else {\n                return;\n            }\n        } else {\n            br = DOMUtils.getInstance().getPreviousLeaf(range.getStartContainer());\n        }\n\n        // Create a new paragraph.\n        Node paragraph = getTextArea().getDocument().xCreatePElement();\n\n        // Split the container after the found BR.\n        if (DOMUtils.getInstance().isFlowContainer(container)) {\n            Node child = DOMUtils.getInstance().getChild(container, br);\n            if (child != br) {\n                DOMUtils.getInstance()\n                    .splitNode(container, br.getParentNode(), DOMUtils.getInstance().getNodeIndex(br));\n            }\n            // Insert the created paragraph before the split.\n            DOMUtils.getInstance().insertAfter(paragraph, child);\n            // Move all the in-line nodes after the split in the created paragraph.\n            child = paragraph.getNextSibling();\n            while (child != null && DOMUtils.getInstance().isInline(child)) {\n                paragraph.appendChild(child);\n                child = paragraph.getNextSibling();\n            }\n        } else {\n            DOMUtils.getInstance().splitNode(container.getParentNode(), br.getParentNode(),\n                DOMUtils.getInstance().getNodeIndex(br));\n            paragraph.appendChild(Element.as(container.getNextSibling()).extractContents());\n            container.getParentNode().replaceChild(paragraph, container.getNextSibling());\n        }\n        br.getParentNode().removeChild(br);\n\n        // Place the caret inside the created paragraph, at the beginning.\n        Node start = DOMUtils.getInstance().getFirstLeaf(paragraph);\n        if (start == paragraph) {\n            start = getTextArea().getDocument().createTextNode(\"\");\n            paragraph.appendChild(start);\n        }\n        if (start.getNodeType() == Node.ELEMENT_NODE) {\n            range.setStartBefore(start);\n        } else {\n            range.setStart(start, 0);\n        }\n    }","id":31860,"modified_method":"/**\n     * Enter has been pressed twice inside a block level element.\n     * \n     * @param container The block level element containing the start of the given range.\n     * @param range The caret.\n     */\n    protected void onEnterParagraphTwice(Node container, Range range)\n    {\n        Node br;\n        // Find the BR.\n        if (range.getStartOffset() > 0) {\n            if (range.getStartContainer().getNodeType() == Node.ELEMENT_NODE) {\n                br = range.getStartContainer().getChildNodes().getItem(range.getStartOffset() - 1);\n                br = domUtils.getLastLeaf(br);\n            } else {\n                return;\n            }\n        } else {\n            br = domUtils.getPreviousLeaf(range.getStartContainer());\n        }\n\n        // Create a new paragraph.\n        Node paragraph = getTextArea().getDocument().xCreatePElement();\n\n        // Split the container after the found BR.\n        if (domUtils.isFlowContainer(container)) {\n            Node child = domUtils.getChild(container, br);\n            if (child != br) {\n                domUtils.splitNode(container, br.getParentNode(), domUtils.getNodeIndex(br));\n            }\n            // Insert the created paragraph before the split.\n            domUtils.insertAfter(paragraph, child);\n            // Move all the in-line nodes after the split in the created paragraph.\n            child = paragraph.getNextSibling();\n            while (child != null && domUtils.isInline(child)) {\n                paragraph.appendChild(child);\n                child = paragraph.getNextSibling();\n            }\n        } else {\n            domUtils.splitNode(container.getParentNode(), br.getParentNode(), domUtils.getNodeIndex(br));\n            paragraph.appendChild(Element.as(container.getNextSibling()).extractContents());\n            container.getParentNode().replaceChild(paragraph, container.getNextSibling());\n        }\n        br.getParentNode().removeChild(br);\n\n        // Place the caret inside the created paragraph, at the beginning.\n        Node start = domUtils.getFirstLeaf(paragraph);\n        if (start == paragraph) {\n            start = getTextArea().getDocument().createTextNode(\"\");\n            paragraph.appendChild(start);\n        }\n        if (start.getNodeType() == Node.ELEMENT_NODE) {\n            range.setStartBefore(start);\n        } else {\n            range.setStart(start, 0);\n        }\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Enter has been pressed once inside a block level element.\n     * \n     * @param container The block level element.\n     * @param range The caret.\n     */\n    protected void onEnterParagraphOnce(Node container, Range range)\n    {\n        // Insert the BR.\n        Node br = getTextArea().getDocument().xCreateBRElement();\n        switch (range.getStartContainer().getNodeType()) {\n            case DOMUtils.CDATA_NODE:\n            case DOMUtils.COMMENT_NODE:\n                DOMUtils.getInstance().insertAfter(br, range.getStartContainer());\n                break;\n            case Node.TEXT_NODE:\n                Node refNode = DOMUtils.getInstance().splitNode(range.getStartContainer(), range.getStartOffset());\n                refNode.getParentNode().insertBefore(br, refNode);\n                break;\n            case Node.ELEMENT_NODE:\n                DOMUtils.getInstance().insertAt(range.getStartContainer(), br, range.getStartOffset());\n                break;\n            default:\n                break;\n        }\n\n        // Place the caret after the inserted BR.\n        Node start = br.getNextSibling();\n        if (start == null || start.getNodeType() != Node.TEXT_NODE) {\n            start = getTextArea().getDocument().createTextNode(\"\");\n            DOMUtils.getInstance().insertAfter(start, br);\n        }\n        range.setStart(start, 0);\n    }","id":31861,"modified_method":"/**\n     * Enter has been pressed once inside a block level element.\n     * \n     * @param container The block level element.\n     * @param range The caret.\n     */\n    protected void onEnterParagraphOnce(Node container, Range range)\n    {\n        // Insert the BR.\n        Node br = getTextArea().getDocument().xCreateBRElement();\n        switch (range.getStartContainer().getNodeType()) {\n            case DOMUtils.CDATA_NODE:\n            case DOMUtils.COMMENT_NODE:\n                domUtils.insertAfter(br, range.getStartContainer());\n                break;\n            case Node.TEXT_NODE:\n                Node refNode = domUtils.splitNode(range.getStartContainer(), range.getStartOffset());\n                refNode.getParentNode().insertBefore(br, refNode);\n                break;\n            case Node.ELEMENT_NODE:\n                domUtils.insertAt(range.getStartContainer(), br, range.getStartOffset());\n                break;\n            default:\n                break;\n        }\n\n        // Place the caret after the inserted BR.\n        Node start = br.getNextSibling();\n        if (start == null || start.getNodeType() != Node.TEXT_NODE) {\n            start = getTextArea().getDocument().createTextNode(\"\");\n            domUtils.insertAfter(start, br);\n        }\n        range.setStart(start, 0);\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#splitNode(Node, Node, int)}.\n     */\n    public void testSplitNodeUpwards()\n    {\n        container.setInnerHTML(\"u<del>v<strong><ins><!--x-->y<\/ins>z<\/strong><em>a<\/em><\/del>b\");\n        Node rightNode =\n            DOMUtils.getInstance().splitNode(container,\n                container.getChildNodes().getItem(1).getChildNodes().getItem(1).getFirstChild(), 1);\n        assertEquals(\"<ins>y<\/ins>\", Element.as(rightNode).getString().toLowerCase());\n        assertEquals(\"u<del>v<strong><ins><!--x--><\/ins><\/strong><\/del>\"\n            + \"<del><strong><ins>y<\/ins>z<\/strong><em>a<\/em><\/del>b\", container.getInnerHTML().toLowerCase());\n    }","id":31862,"modified_method":"/**\n     * Unit test for {@link DOMUtils#splitNode(Node, Node, int)}.\n     */\n    public void testSplitNodeUpwards()\n    {\n        container.setInnerHTML(\"u<del>v<strong><ins><!--x-->y<\/ins>z<\/strong><em>a<\/em><\/del>b\");\n        Node rightNode =\n            domUtils.splitNode(container, container.getChildNodes().getItem(1).getChildNodes().getItem(1)\n                .getFirstChild(), 1);\n        assertEquals(\"<ins>y<\/ins>\", Element.as(rightNode).getString().toLowerCase());\n        assertEquals(\"u<del>v<strong><ins><!--x--><\/ins><\/strong><\/del>\"\n            + \"<del><strong><ins>y<\/ins>z<\/strong><em>a<\/em><\/del>b\", container.getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getChild(Node, Node)}.\n     */\n    public void testGetChild()\n    {\n        container.setInnerHTML(\"%<strong>@<em>^<\/em><\/strong>\");\n        assertEquals(container.getFirstChild(), DOMUtils.getInstance().getChild(container, container.getFirstChild()));\n        assertEquals(container.getLastChild(), DOMUtils.getInstance().getChild(container,\n            container.getLastChild().getLastChild().getFirstChild()));\n    }","id":31863,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getChild(Node, Node)}.\n     */\n    public void testGetChild()\n    {\n        container.setInnerHTML(\"%<strong>@<em>^<\/em><\/strong>\");\n        assertEquals(container.getFirstChild(), domUtils.getChild(container, container.getFirstChild()));\n        assertEquals(container.getLastChild(), domUtils.getChild(container, container.getLastChild().getLastChild()\n            .getFirstChild()));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getNormalizedChildCount(Node)}.\n     */\n    public void testGetNormalizedChildCount()\n    {\n        assertEquals(0, DOMUtils.getInstance().getNormalizedChildCount(container));\n\n        container.appendChild(Document.get().createTextNode(\"\"));\n        assertEquals(0, DOMUtils.getInstance().getNormalizedChildCount(container));\n\n        container.getFirstChild().setNodeValue(\"double\");\n        assertEquals(1, DOMUtils.getInstance().getNormalizedChildCount(container));\n\n        container.appendChild(Document.get().createSpanElement());\n        assertEquals(2, DOMUtils.getInstance().getNormalizedChildCount(container));\n\n        Element.as(container.getLastChild()).setAttribute(Element.META_DATA_ATTR, \"\");\n        assertEquals(1, DOMUtils.getInstance().getNormalizedChildCount(container));\n\n        container.getFirstChild().setNodeValue(\"\");\n        assertEquals(0, DOMUtils.getInstance().getNormalizedChildCount(container));\n    }","id":31864,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getNormalizedChildCount(Node)}.\n     */\n    public void testGetNormalizedChildCount()\n    {\n        assertEquals(0, domUtils.getNormalizedChildCount(container));\n\n        container.appendChild(Document.get().createTextNode(\"\"));\n        assertEquals(0, domUtils.getNormalizedChildCount(container));\n\n        container.getFirstChild().setNodeValue(\"double\");\n        assertEquals(1, domUtils.getNormalizedChildCount(container));\n\n        container.appendChild(Document.get().createSpanElement());\n        assertEquals(2, domUtils.getNormalizedChildCount(container));\n\n        Element.as(container.getLastChild()).setAttribute(Element.META_DATA_ATTR, \"\");\n        assertEquals(1, domUtils.getNormalizedChildCount(container));\n\n        container.getFirstChild().setNodeValue(\"\");\n        assertEquals(0, domUtils.getNormalizedChildCount(container));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#insertAt(Node, Node, int)}.\n     */\n    public void testInsertAt()\n    {\n        container.xSetInnerHTML(\"<!--x-->y<em>z<\/em>\");\n\n        Text text = container.getOwnerDocument().createTextNode(\":\").cast();\n        DOMUtils.getInstance().insertAt(container, text, container.getChildNodes().getLength());\n        assertEquals(\"<!--x-->y<em>z<\/em>:\", container.getInnerHTML().toLowerCase());\n\n        text = container.getOwnerDocument().createTextNode(\"{\").cast();\n        DOMUtils.getInstance().insertAt(container, text, 0);\n        assertEquals(\"{<!--x-->y<em>z<\/em>:\", container.getInnerHTML().toLowerCase());\n\n        text = container.getOwnerDocument().createTextNode(\"}\").cast();\n        DOMUtils.getInstance().insertAt(container, text, 2);\n        assertEquals(\"{<!--x-->}y<em>z<\/em>:\", container.getInnerHTML().toLowerCase());\n    }","id":31865,"modified_method":"/**\n     * Unit test for {@link DOMUtils#insertAt(Node, Node, int)}.\n     */\n    public void testInsertAt()\n    {\n        container.xSetInnerHTML(\"<!--x-->y<em>z<\/em>\");\n\n        Text text = container.getOwnerDocument().createTextNode(\":\").cast();\n        domUtils.insertAt(container, text, container.getChildNodes().getLength());\n        assertEquals(\"<!--x-->y<em>z<\/em>:\", container.getInnerHTML().toLowerCase());\n\n        text = container.getOwnerDocument().createTextNode(\"{\").cast();\n        domUtils.insertAt(container, text, 0);\n        assertEquals(\"{<!--x-->y<em>z<\/em>:\", container.getInnerHTML().toLowerCase());\n\n        text = container.getOwnerDocument().createTextNode(\"}\").cast();\n        domUtils.insertAt(container, text, 2);\n        assertEquals(\"{<!--x-->}y<em>z<\/em>:\", container.getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#deleteNodeContents(Node, int, boolean)}.\n     */\n    public void testDeleteNodeContentsLeftRight()\n    {\n        container.setInnerHTML(\"foo<del><\/del>bar\");\n        DOMUtils.getInstance().deleteNodeContents(container.getFirstChild(), 2, true);\n        assertEquals(\"o<del><\/del>bar\", container.getInnerHTML().toLowerCase());\n        DOMUtils.getInstance().deleteNodeContents(container.getLastChild(), 0, false);\n        assertEquals(\"o<del><\/del>\", container.getInnerHTML().toLowerCase());\n\n        container.setInnerHTML(\"<ins>1<\/ins><!--2-->3\");\n        DOMUtils.getInstance().deleteNodeContents(container, 1, true);\n        assertEquals(\"<!--2-->3\", container.getInnerHTML());\n        DOMUtils.getInstance().deleteNodeContents(container, 1, false);\n        assertEquals(\"<!--2-->\", container.getInnerHTML());\n    }","id":31866,"modified_method":"/**\n     * Unit test for {@link DOMUtils#deleteNodeContents(Node, int, boolean)}.\n     */\n    public void testDeleteNodeContentsLeftRight()\n    {\n        container.setInnerHTML(\"foo<del><\/del>bar\");\n        domUtils.deleteNodeContents(container.getFirstChild(), 2, true);\n        assertEquals(\"o<del><\/del>bar\", container.getInnerHTML().toLowerCase());\n        domUtils.deleteNodeContents(container.getLastChild(), 0, false);\n        assertEquals(\"o<del><\/del>\", container.getInnerHTML().toLowerCase());\n\n        container.setInnerHTML(\"<ins>1<\/ins><!--2-->3\");\n        domUtils.deleteNodeContents(container, 1, true);\n        assertEquals(\"<!--2-->3\", container.getInnerHTML());\n        domUtils.deleteNodeContents(container, 1, false);\n        assertEquals(\"<!--2-->\", container.getInnerHTML());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getFarthestInlineAncestor(Node)}.\n     */\n    public void testGetFarthestInlineAncestor()\n    {\n        container.xSetInnerHTML(\"#<em>$<\/em>#\");\n\n        assertEquals(container.getChildNodes().getItem(1), DOMUtils.getInstance().getFarthestInlineAncestor(\n            container.getChildNodes().getItem(1).getFirstChild()));\n        assertEquals(container.getChildNodes().getItem(1), DOMUtils.getInstance().getFarthestInlineAncestor(\n            container.getChildNodes().getItem(1)));\n        assertNull(DOMUtils.getInstance().getFarthestInlineAncestor(container));\n    }","id":31867,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getFarthestInlineAncestor(Node)}.\n     */\n    public void testGetFarthestInlineAncestor()\n    {\n        container.xSetInnerHTML(\"#<em>$<\/em>#\");\n\n        assertEquals(container.getChildNodes().getItem(1), domUtils.getFarthestInlineAncestor(container.getChildNodes()\n            .getItem(1).getFirstChild()));\n        assertEquals(container.getChildNodes().getItem(1), domUtils.getFarthestInlineAncestor(container.getChildNodes()\n            .getItem(1)));\n        assertNull(domUtils.getFarthestInlineAncestor(container));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#detach(Node)}.\n     */\n    public void testDetach()\n    {\n        container.setInnerHTML(\"1<span>2<\/span>3\");\n        Node node = container.getChildNodes().getItem(1);\n        DOMUtils.getInstance().detach(node);\n        assertEquals(\"13\", container.getInnerHTML());\n        // IE fails because orphan nodes that have been created with the innerHTML property are attached to a document\n        // fragment.\n        assertNull(node.getParentNode());\n        // The following shoudn't fail.\n        DOMUtils.getInstance().detach(node);\n    }","id":31868,"modified_method":"/**\n     * Unit test for {@link DOMUtils#detach(Node)}.\n     */\n    public void testDetach()\n    {\n        container.setInnerHTML(\"1<span>2<\/span>3\");\n        Node node = container.getChildNodes().getItem(1);\n        domUtils.detach(node);\n        assertEquals(\"13\", container.getInnerHTML());\n        // IE fails because orphan nodes that have been created with the innerHTML property are attached to a document\n        // fragment.\n        assertNull(node.getParentNode());\n        // The following shoudn't fail.\n        domUtils.detach(node);\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getNearestCommonAncestor(Node, Node)}.\n     */\n    public void testGetNearestCommonAncestor()\n    {\n        container.setInnerHTML(\"<em>x<\/em>y<del>z<\/del>\");\n        assertEquals(container, DOMUtils.getInstance().getNearestCommonAncestor(\n            container.getFirstChild().getFirstChild(), container.getLastChild().getFirstChild()));\n    }","id":31869,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getNearestCommonAncestor(Node, Node)}.\n     */\n    public void testGetNearestCommonAncestor()\n    {\n        container.setInnerHTML(\"<em>x<\/em>y<del>z<\/del>\");\n        assertEquals(container, domUtils.getNearestCommonAncestor(container.getFirstChild().getFirstChild(), container\n            .getLastChild().getFirstChild()));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#cloneNode(Node, Node, int, boolean)}.\n     */\n    public void testCloneNodeUpwards()\n    {\n        container.setInnerHTML(\"<em><ins>abc<del>d<\/del><\/ins><\/em>e\");\n\n        Element clone =\n            DOMUtils.getInstance().cloneNode(container.getParentNode(),\n                container.getFirstChild().getFirstChild().getFirstChild(), 2, false).cast();\n        assertEquals(\"<em><ins>c<del>d<\/del><\/ins><\/em>e\", clone.getInnerHTML().toLowerCase());\n\n        clone =\n            DOMUtils.getInstance().cloneNode(container.getParentNode(), container.getFirstChild().getFirstChild(), 1,\n                true).cast();\n        assertEquals(\"<em><ins>abc<\/ins><\/em>\", clone.getInnerHTML().toLowerCase());\n    }","id":31870,"modified_method":"/**\n     * Unit test for {@link DOMUtils#cloneNode(Node, Node, int, boolean)}.\n     */\n    public void testCloneNodeUpwards()\n    {\n        container.setInnerHTML(\"<em><ins>abc<del>d<\/del><\/ins><\/em>e\");\n\n        Element clone =\n            domUtils.cloneNode(container.getParentNode(), container.getFirstChild().getFirstChild().getFirstChild(), 2,\n                false).cast();\n        assertEquals(\"<em><ins>c<del>d<\/del><\/ins><\/em>e\", clone.getInnerHTML().toLowerCase());\n\n        clone =\n            domUtils.cloneNode(container.getParentNode(), container.getFirstChild().getFirstChild(), 1, true).cast();\n        assertEquals(\"<em><ins>abc<\/ins><\/em>\", clone.getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#cloneNode(Node, int, int)}.\n     */\n    public void testCloneNodeBetweenOffsets()\n    {\n        container.setInnerHTML(\"toucan<span><em>+<\/em><ins>-<\/ins><\/span>\");\n        assertEquals(\"an\", DOMUtils.getInstance().cloneNode(container.getFirstChild(), 4, 6).getNodeValue());\n        assertEquals(\"\", DOMUtils.getInstance().cloneNode(container.getFirstChild(), 0, 0).getNodeValue());\n\n        Element clone = DOMUtils.getInstance().cloneNode(container.getLastChild(), 1, 2).cast();\n        assertEquals(\"<ins>-<\/ins>\", clone.getInnerHTML().toLowerCase());\n\n        clone = DOMUtils.getInstance().cloneNode(container.getLastChild(), 0, 0).cast();\n        assertEquals(\"<span><\/span>\", clone.getString().toLowerCase());\n    }","id":31871,"modified_method":"/**\n     * Unit test for {@link DOMUtils#cloneNode(Node, int, int)}.\n     */\n    public void testCloneNodeBetweenOffsets()\n    {\n        container.setInnerHTML(\"toucan<span><em>+<\/em><ins>-<\/ins><\/span>\");\n        assertEquals(\"an\", domUtils.cloneNode(container.getFirstChild(), 4, 6).getNodeValue());\n        assertEquals(\"\", domUtils.cloneNode(container.getFirstChild(), 0, 0).getNodeValue());\n\n        Element clone = domUtils.cloneNode(container.getLastChild(), 1, 2).cast();\n        assertEquals(\"<ins>-<\/ins>\", clone.getInnerHTML().toLowerCase());\n\n        clone = domUtils.cloneNode(container.getLastChild(), 0, 0).cast();\n        assertEquals(\"<span><\/span>\", clone.getString().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getTextRange(Range)}.\n     */\n    public void testGetTextRange()\n    {\n        container.setInnerHTML(\"x<a href=\\\"http://www.xwiki.org\\\"><strong>a<\/strong>b<em>cd<\/em><\/a>y\");\n\n        Range range = ((Document) container.getOwnerDocument()).createRange();\n        range.setStart(container, 1);\n        range.setEnd(container, 2);\n\n        Range textRange = DOMUtils.getInstance().getTextRange(range);\n\n        assertEquals(range.toString(), textRange.toString());\n\n        assertEquals(Node.TEXT_NODE, textRange.getStartContainer().getNodeType());\n        assertEquals(Node.TEXT_NODE, textRange.getEndContainer().getNodeType());\n\n        assertEquals(0, textRange.getStartOffset());\n        assertEquals(2, textRange.getEndOffset());\n    }","id":31872,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getTextRange(Range)}.\n     */\n    public void testGetTextRange()\n    {\n        container.setInnerHTML(\"x<a href=\\\"http://www.xwiki.org\\\"><strong>a<\/strong>b<em>cd<\/em><\/a>y\");\n\n        Range range = ((Document) container.getOwnerDocument()).createRange();\n        range.setStart(container, 1);\n        range.setEnd(container, 2);\n\n        Range textRange = domUtils.getTextRange(range);\n\n        assertEquals(range.toString(), textRange.toString());\n\n        assertEquals(Node.TEXT_NODE, textRange.getStartContainer().getNodeType());\n        assertEquals(Node.TEXT_NODE, textRange.getEndContainer().getNodeType());\n\n        assertEquals(0, textRange.getStartOffset());\n        assertEquals(2, textRange.getEndOffset());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getNormalizedNodeIndex(Node)}.\n     */\n    public void testGetNormalizedNodeIndex()\n    {\n        container.appendChild(Document.get().createTextNode(\"void\"));\n        assertEquals(0, DOMUtils.getInstance().getNormalizedNodeIndex(container.getFirstChild()));\n\n        container.getFirstChild().setNodeValue(\"\");\n        assertEquals(0, DOMUtils.getInstance().getNormalizedNodeIndex(container.getFirstChild()));\n\n        container.appendChild(Document.get().createSpanElement());\n        assertEquals(0, DOMUtils.getInstance().getNormalizedNodeIndex(container.getLastChild()));\n\n        container.getFirstChild().setNodeValue(\"null\");\n        assertEquals(1, DOMUtils.getInstance().getNormalizedNodeIndex(container.getLastChild()));\n\n        container.appendChild(Document.get().createTextNode(\"int\"));\n        assertEquals(2, DOMUtils.getInstance().getNormalizedNodeIndex(container.getLastChild()));\n\n        Element.as(container.getChildNodes().getItem(1)).setAttribute(Element.META_DATA_ATTR, \"\");\n        assertEquals(0, DOMUtils.getInstance().getNormalizedNodeIndex(container.getLastChild()));\n    }","id":31873,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getNormalizedNodeIndex(Node)}.\n     */\n    public void testGetNormalizedNodeIndex()\n    {\n        container.appendChild(Document.get().createTextNode(\"void\"));\n        assertEquals(0, domUtils.getNormalizedNodeIndex(container.getFirstChild()));\n\n        container.getFirstChild().setNodeValue(\"\");\n        assertEquals(0, domUtils.getNormalizedNodeIndex(container.getFirstChild()));\n\n        container.appendChild(Document.get().createSpanElement());\n        assertEquals(0, domUtils.getNormalizedNodeIndex(container.getLastChild()));\n\n        container.getFirstChild().setNodeValue(\"null\");\n        assertEquals(1, domUtils.getNormalizedNodeIndex(container.getLastChild()));\n\n        container.appendChild(Document.get().createTextNode(\"int\"));\n        assertEquals(2, domUtils.getNormalizedNodeIndex(container.getLastChild()));\n\n        Element.as(container.getChildNodes().getItem(1)).setAttribute(Element.META_DATA_ATTR, \"\");\n        assertEquals(0, domUtils.getNormalizedNodeIndex(container.getLastChild()));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getNearestFlowContainer(Node)}.\n     */\n    public void testGetNearestFlowContainer()\n    {\n        container.setInnerHTML(\"x<del>y<\/del>z\");\n        assertEquals(container, DOMUtils.getInstance().getNearestFlowContainer(\n            container.getChildNodes().getItem(1).getFirstChild()));\n    }","id":31874,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getNearestFlowContainer(Node)}.\n     */\n    public void testGetNearestFlowContainer()\n    {\n        container.setInnerHTML(\"x<del>y<\/del>z\");\n        assertEquals(container, domUtils.getNearestFlowContainer(container.getChildNodes().getItem(1).getFirstChild()));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#deleteNodeContents(Node, int, int)}.\n     */\n    public void testDeleteNodeContentsBetweenOffsets()\n    {\n        container.setInnerHTML(\"foo\");\n        DOMUtils.getInstance().deleteNodeContents(container.getFirstChild(), 1, 2);\n        assertEquals(\"fo\", container.getInnerHTML());\n\n        container.setInnerHTML(\"<em>1<\/em>2<!--3-->\");\n        DOMUtils.getInstance().deleteNodeContents(container, 1, 2);\n        assertEquals(\"<em>1<\/em><!--3-->\", container.getInnerHTML().toLowerCase());\n    }","id":31875,"modified_method":"/**\n     * Unit test for {@link DOMUtils#deleteNodeContents(Node, int, int)}.\n     */\n    public void testDeleteNodeContentsBetweenOffsets()\n    {\n        container.setInnerHTML(\"foo\");\n        domUtils.deleteNodeContents(container.getFirstChild(), 1, 2);\n        assertEquals(\"fo\", container.getInnerHTML());\n\n        container.setInnerHTML(\"<em>1<\/em>2<!--3-->\");\n        domUtils.deleteNodeContents(container, 1, 2);\n        assertEquals(\"<em>1<\/em><!--3-->\", container.getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#splitNode(Node, int)}.\n     */\n    public void testSplitNodeAtOffset()\n    {\n        container.setInnerHTML(\"xwiki\");\n        Node rightNode = DOMUtils.getInstance().splitNode(container.getFirstChild(), 3);\n        assertEquals(container.getLastChild(), rightNode);\n        assertEquals(2, container.getChildNodes().getLength());\n        assertEquals(\"xwi\", container.getFirstChild().getNodeValue());\n        assertEquals(\"ki\", container.getLastChild().getNodeValue());\n\n        container.setInnerHTML(\"q<span><!--x--><em>w<\/em>e<\/span>rty\");\n        rightNode = DOMUtils.getInstance().splitNode(container.getChildNodes().getItem(1), 0);\n        assertEquals(\"<span><!--x--><em>w<\/em>e<\/span>\", Element.as(rightNode).getString().toLowerCase());\n        assertEquals(\"q<span><\/span><span><!--x--><em>w<\/em>e<\/span>rty\", container.getInnerHTML().toLowerCase());\n    }","id":31876,"modified_method":"/**\n     * Unit test for {@link DOMUtils#splitNode(Node, int)}.\n     */\n    public void testSplitNodeAtOffset()\n    {\n        container.setInnerHTML(\"xwiki\");\n        Node rightNode = domUtils.splitNode(container.getFirstChild(), 3);\n        assertEquals(container.getLastChild(), rightNode);\n        assertEquals(2, container.getChildNodes().getLength());\n        assertEquals(\"xwi\", container.getFirstChild().getNodeValue());\n        assertEquals(\"ki\", container.getLastChild().getNodeValue());\n\n        container.setInnerHTML(\"q<span><!--x--><em>w<\/em>e<\/span>rty\");\n        rightNode = domUtils.splitNode(container.getChildNodes().getItem(1), 0);\n        assertEquals(\"<span><!--x--><em>w<\/em>e<\/span>\", Element.as(rightNode).getString().toLowerCase());\n        assertEquals(\"q<span><\/span><span><!--x--><em>w<\/em>e<\/span>rty\", container.getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getAncestors(Node)}.\n     */\n    public void testGetAncestors()\n    {\n        container.setInnerHTML(\"<em>x<\/em>\");\n        List<Node> ancestors = new ArrayList<Node>();\n        ancestors.add(container.getFirstChild().getFirstChild());\n        ancestors.add(container.getFirstChild());\n        ancestors.add(container);\n        ancestors.add(container.getOwnerDocument().getBody());\n        ancestors.add(((Document) container.getOwnerDocument()).getDocumentElement());\n        ancestors.add(container.getOwnerDocument());\n        assertEquals(ancestors, DOMUtils.getInstance().getAncestors(ancestors.get(0)));\n    }","id":31877,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getAncestors(Node)}.\n     */\n    public void testGetAncestors()\n    {\n        container.setInnerHTML(\"<em>x<\/em>\");\n        List<Node> ancestors = new ArrayList<Node>();\n        ancestors.add(container.getFirstChild().getFirstChild());\n        ancestors.add(container.getFirstChild());\n        ancestors.add(container);\n        ancestors.add(container.getOwnerDocument().getBody());\n        ancestors.add(((Document) container.getOwnerDocument()).getDocumentElement());\n        ancestors.add(container.getOwnerDocument());\n        assertEquals(ancestors, domUtils.getAncestors(ancestors.get(0)));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Test the first descendant search function, on a wikilink-like HTML structure.\n     * \n     * @see DOMUtils#getFirstDescendant(Node, String)\n     */\n    public void testGetFirstDescendant()\n    {\n        container.setInnerHTML(\"<div>my<!--startwikilink:Reference--><span class=\\\"wikilink\\\">\"\n            + \"<a>x<span>wiki<\/span><\/a><\/span><!--stopwikilink-->rules<\/div>\");\n        Node wrappingSpan = container.getFirstChild().getChildNodes().getItem(2);\n        Node anchor = wrappingSpan.getFirstChild();\n        Node preambleText = container.getFirstChild().getFirstChild();\n        String anchorTagName = anchor.getNodeName();\n\n        // check anchor shows up as descendant of startContainer\n        assertSame(\"Anchor does not show up as descendant of startContainer\", anchor, DOMUtils.getInstance()\n            .getFirstDescendant(container.getFirstChild(), anchorTagName));\n        // check anchor shows up as descendant of itself\n        assertSame(\"Anchor does not show up as descendant of itself\", anchor, DOMUtils.getInstance()\n            .getFirstDescendant(anchor, anchorTagName));\n        // check there is no descendant of type bold in the wrapping span\n        assertNull(\"There is a descendant of type bold in the wrapping span\", DOMUtils.getInstance()\n            .getFirstDescendant(wrappingSpan, \"strong\"));\n        // check the first span descendant stops at the wrapping span\n        assertSame(\"The first span descendant does not stop at the wrapping span\", wrappingSpan, DOMUtils.getInstance()\n            .getFirstDescendant(container, wrappingSpan.getNodeName()));\n        // check there is no anchor descendant of a text\n        assertNull(\"There is an anchor descendant of a text\", DOMUtils.getInstance().getFirstDescendant(preambleText,\n            anchorTagName));\n    }","id":31878,"modified_method":"/**\n     * Test the first descendant search function, on a wikilink-like HTML structure.\n     * \n     * @see DOMUtils#getFirstDescendant(Node, String)\n     */\n    public void testGetFirstDescendant()\n    {\n        container.setInnerHTML(\"<div>my<!--startwikilink:Reference--><span class=\\\"wikilink\\\">\"\n            + \"<a>x<span>wiki<\/span><\/a><\/span><!--stopwikilink-->rules<\/div>\");\n        Node wrappingSpan = container.getFirstChild().getChildNodes().getItem(2);\n        Node anchor = wrappingSpan.getFirstChild();\n        Node preambleText = container.getFirstChild().getFirstChild();\n        String anchorTagName = anchor.getNodeName();\n\n        // check anchor shows up as descendant of startContainer\n        assertSame(\"Anchor does not show up as descendant of startContainer\", anchor, domUtils.getFirstDescendant(\n            container.getFirstChild(), anchorTagName));\n        // check anchor shows up as descendant of itself\n        assertSame(\"Anchor does not show up as descendant of itself\", anchor, domUtils.getFirstDescendant(anchor,\n            anchorTagName));\n        // check there is no descendant of type bold in the wrapping span\n        assertNull(\"There is a descendant of type bold in the wrapping span\", domUtils.getFirstDescendant(wrappingSpan,\n            \"strong\"));\n        // check the first span descendant stops at the wrapping span\n        assertSame(\"The first span descendant does not stop at the wrapping span\", wrappingSpan, domUtils\n            .getFirstDescendant(container, wrappingSpan.getNodeName()));\n        // check there is no anchor descendant of a text\n        assertNull(\"There is an anchor descendant of a text\", domUtils.getFirstDescendant(preambleText, anchorTagName));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#isFlowContainer(Node)}.\n     */\n    public void testIsFlowContainer()\n    {\n        container.setInnerHTML(\"<ul><li>foo<\/li><\/ul>\");\n        assertTrue(DOMUtils.getInstance().isFlowContainer(container));\n        assertFalse(DOMUtils.getInstance().isFlowContainer(container.getFirstChild()));\n        assertTrue(DOMUtils.getInstance().isFlowContainer(container.getFirstChild().getFirstChild()));\n        assertFalse(DOMUtils.getInstance().isFlowContainer(container.getFirstChild().getFirstChild().getFirstChild()));\n    }","id":31879,"modified_method":"/**\n     * Unit test for {@link DOMUtils#isFlowContainer(Node)}.\n     */\n    public void testIsFlowContainer()\n    {\n        container.setInnerHTML(\"<ul><li>foo<\/li><\/ul>\");\n        assertTrue(domUtils.isFlowContainer(container));\n        assertFalse(domUtils.isFlowContainer(container.getFirstChild()));\n        assertTrue(domUtils.isFlowContainer(container.getFirstChild().getFirstChild()));\n        assertFalse(domUtils.isFlowContainer(container.getFirstChild().getFirstChild().getFirstChild()));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getTextRange(Range)} when the input range ends inside a comment node.\n     */\n    public void testGetTextRangeFromARangeEndingInAComment()\n    {\n        container.setInnerHTML(\"a<!--xy-->\");\n\n        Range range = ((Document) container.getOwnerDocument()).createRange();\n        range.setStart(container.getFirstChild(), container.getFirstChild().getNodeValue().length());\n        range.setEnd(container.getLastChild(), container.getLastChild().getNodeValue().length());\n\n        Range textRange = DOMUtils.getInstance().getTextRange(range);\n\n        assertEquals(range.toString(), textRange.toString());\n        assertEquals(Node.TEXT_NODE, textRange.getStartContainer().getNodeType());\n        assertEquals(textRange.getStartContainer(), textRange.getEndContainer());\n        assertEquals(1, textRange.getStartOffset());\n        assertEquals(1, textRange.getEndOffset());\n    }","id":31880,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getTextRange(Range)} when the input range ends inside a comment node.\n     */\n    public void testGetTextRangeFromARangeEndingInAComment()\n    {\n        container.setInnerHTML(\"a<!--xy-->\");\n\n        Range range = ((Document) container.getOwnerDocument()).createRange();\n        range.setStart(container.getFirstChild(), container.getFirstChild().getNodeValue().length());\n        range.setEnd(container.getLastChild(), container.getLastChild().getNodeValue().length());\n\n        Range textRange = domUtils.getTextRange(range);\n\n        assertEquals(range.toString(), textRange.toString());\n        assertEquals(Node.TEXT_NODE, textRange.getStartContainer().getNodeType());\n        assertEquals(textRange.getStartContainer(), textRange.getEndContainer());\n        assertEquals(1, textRange.getStartOffset());\n        assertEquals(1, textRange.getEndOffset());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#cloneNode(Node, int, boolean)}.\n     */\n    public void testCloneNodeLeftRight()\n    {\n        container.setInnerHTML(\"abc\");\n        assertEquals(\"ab\", DOMUtils.getInstance().cloneNode(container.getFirstChild(), 2, true).getNodeValue());\n        assertEquals(\"c\", DOMUtils.getInstance().cloneNode(container.getFirstChild(), 2, false).getNodeValue());\n\n        container.setInnerHTML(\"a<!--x--><em>b<\/em>\");\n\n        assertEquals(\"a<!--x-->\", ((Element) DOMUtils.getInstance().cloneNode(container, 2, true)).getInnerHTML()\n            .toLowerCase());\n        assertEquals(\"<em>b<\/em>\", ((Element) DOMUtils.getInstance().cloneNode(container, 2, false)).getInnerHTML()\n            .toLowerCase());\n    }","id":31881,"modified_method":"/**\n     * Unit test for {@link DOMUtils#cloneNode(Node, int, boolean)}.\n     */\n    public void testCloneNodeLeftRight()\n    {\n        container.setInnerHTML(\"abc\");\n        assertEquals(\"ab\", domUtils.cloneNode(container.getFirstChild(), 2, true).getNodeValue());\n        assertEquals(\"c\", domUtils.cloneNode(container.getFirstChild(), 2, false).getNodeValue());\n\n        container.setInnerHTML(\"a<!--x--><em>b<\/em>\");\n\n        assertEquals(\"a<!--x-->\", ((Element) domUtils.cloneNode(container, 2, true)).getInnerHTML().toLowerCase());\n        assertEquals(\"<em>b<\/em>\", ((Element) domUtils.cloneNode(container, 2, false)).getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#deleteSiblings(Node, boolean)}.\n     */\n    public void testDeleteSiblings()\n    {\n        container.setInnerHTML(\"1<strong>2<\/strong><!--3-->\");\n        DOMUtils.getInstance().deleteSiblings(container.getFirstChild(), true);\n        assertEquals(3, container.getChildNodes().getLength());\n        DOMUtils.getInstance().deleteSiblings(container.getFirstChild(), false);\n        assertEquals(\"1\", container.getInnerHTML());\n    }","id":31882,"modified_method":"/**\n     * Unit test for {@link DOMUtils#deleteSiblings(Node, boolean)}.\n     */\n    public void testDeleteSiblings()\n    {\n        container.setInnerHTML(\"1<strong>2<\/strong><!--3-->\");\n        domUtils.deleteSiblings(container.getFirstChild(), true);\n        assertEquals(3, container.getChildNodes().getLength());\n        domUtils.deleteSiblings(container.getFirstChild(), false);\n        assertEquals(\"1\", container.getInnerHTML());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getFirstLeaf(Range)} and {@link DOMUtils#getLastLeaf(Range)}.\n     */\n    public void testGetRangeFirstAndLastLeaf()\n    {\n        container.xSetInnerHTML(\"ab<em>c<\/em><del><strong>d<\/strong><\/del><ins>e<\/ins>f\");\n        Range range = ((Document) container.getOwnerDocument()).createRange();\n\n        range.setStart(container.getFirstChild(), 1);\n        range.collapse(true);\n        assertEquals(container.getFirstChild(), DOMUtils.getInstance().getFirstLeaf(range));\n        assertEquals(container.getFirstChild(), DOMUtils.getInstance().getLastLeaf(range));\n\n        range.setEnd(container.getFirstChild(), 2);\n        assertEquals(container.getFirstChild(), DOMUtils.getInstance().getFirstLeaf(range));\n        assertEquals(container.getFirstChild(), DOMUtils.getInstance().getLastLeaf(range));\n\n        range.setEnd(container.getLastChild(), 1);\n        assertEquals(container.getFirstChild(), DOMUtils.getInstance().getFirstLeaf(range));\n        assertEquals(container.getLastChild(), DOMUtils.getInstance().getLastLeaf(range));\n\n        range.setStart(container.getChildNodes().getItem(1), 1);\n        range.setEnd(container.getChildNodes().getItem(3), 0);\n        assertEquals(container.getChildNodes().getItem(2).getFirstChild().getFirstChild(), DOMUtils.getInstance()\n            .getFirstLeaf(range));\n        assertEquals(container.getChildNodes().getItem(2).getFirstChild().getFirstChild(), DOMUtils.getInstance()\n            .getLastLeaf(range));\n\n        range.collapse(true);\n        assertNull(DOMUtils.getInstance().getFirstLeaf(range));\n        assertNull(DOMUtils.getInstance().getLastLeaf(range));\n    }","id":31883,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getFirstLeaf(Range)} and {@link DOMUtils#getLastLeaf(Range)}.\n     */\n    public void testGetRangeFirstAndLastLeaf()\n    {\n        container.xSetInnerHTML(\"ab<em>c<\/em><del><strong>d<\/strong><\/del><ins>e<\/ins>f\");\n        Range range = ((Document) container.getOwnerDocument()).createRange();\n\n        range.setStart(container.getFirstChild(), 1);\n        range.collapse(true);\n        assertEquals(container.getFirstChild(), domUtils.getFirstLeaf(range));\n        assertEquals(container.getFirstChild(), domUtils.getLastLeaf(range));\n\n        range.setEnd(container.getFirstChild(), 2);\n        assertEquals(container.getFirstChild(), domUtils.getFirstLeaf(range));\n        assertEquals(container.getFirstChild(), domUtils.getLastLeaf(range));\n\n        range.setEnd(container.getLastChild(), 1);\n        assertEquals(container.getFirstChild(), domUtils.getFirstLeaf(range));\n        assertEquals(container.getLastChild(), domUtils.getLastLeaf(range));\n\n        range.setStart(container.getChildNodes().getItem(1), 1);\n        range.setEnd(container.getChildNodes().getItem(3), 0);\n        Node lastLeaf = domUtils.getLastLeaf(range);\n        assertEquals(lastLeaf, domUtils.getFirstLeaf(range));\n        assertEquals(container.getChildNodes().getItem(2).getFirstChild().getFirstChild(), lastLeaf);\n\n        range.collapse(true);\n        assertNull(domUtils.getFirstLeaf(range));\n        assertNull(domUtils.getLastLeaf(range));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#getLength(Node)}.\n     */\n    public void testGetLength()\n    {\n        container.setInnerHTML(\"xwiki<strong><\/strong><ins>x<del>y<\/del>z<\/ins>\");\n        assertEquals(5, DOMUtils.getInstance().getLength(container.getFirstChild()));\n        assertEquals(0, DOMUtils.getInstance().getLength(container.getChildNodes().getItem(1)));\n        assertEquals(3, DOMUtils.getInstance().getLength(container.getLastChild()));\n    }","id":31884,"modified_method":"/**\n     * Unit test for {@link DOMUtils#getLength(Node)}.\n     */\n    public void testGetLength()\n    {\n        container.setInnerHTML(\"xwiki<strong><\/strong><ins>x<del>y<\/del>z<\/ins>\");\n        assertEquals(5, domUtils.getLength(container.getFirstChild()));\n        assertEquals(0, domUtils.getLength(container.getChildNodes().getItem(1)));\n        assertEquals(3, domUtils.getLength(container.getLastChild()));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Test the first ancestor search, on a wikilink-like HTML structure.\n     * \n     * @see DOMUtils#getFirstAncestor(Node, String)\n     */\n    public void testGetFirstAncestor()\n    {\n        container.setInnerHTML(\"<div>our<!--startwikilink:Reference--><span class=\\\"wikilink\\\">\"\n            + \"<a>x<strong>wiki<\/strong><\/a><\/span><!--stopwikilink-->rox<\/div>\");\n        Node wrappingSpan = container.getFirstChild().getChildNodes().getItem(2);\n        Node anchor = wrappingSpan.getFirstChild();\n        Node boldWiki = anchor.getChildNodes().getItem(1);\n        Node labelBoldWiki = boldWiki.getFirstChild();\n        String anchorTagName = anchor.getNodeName();\n\n        // check if there is a first ancestor of type a for the bold inside the anchor\n        assertSame(\"There isn't an anchor ancestor for the bold inside the anchor\", anchor, DOMUtils.getInstance()\n            .getFirstAncestor(boldWiki, anchorTagName));\n        // check if there is a first ancestor of type a for the text inside bold in the anchor\n        assertSame(\"There isn't an anchor ancestor for the text in the bold inside the anchor\", anchor, DOMUtils\n            .getInstance().getFirstAncestor(labelBoldWiki, anchorTagName));\n        // check there is no a ancestor of the wikilink span\n        assertNull(\"There is an anchor ancestor for the wikilink span\", DOMUtils.getInstance().getFirstAncestor(\n            wrappingSpan, anchorTagName));\n        // check a finds itself as ancestor\n        assertSame(\"The anchor is not an anhor ancestor of itself\", anchor, DOMUtils.getInstance().getFirstAncestor(\n            anchor, anchorTagName));\n        // check div ancestor search stops at startContainer\n        assertSame(\"Div ancestor search for the anchor does not stop at first div\", container.getFirstChild(), DOMUtils\n            .getInstance().getFirstAncestor(anchor, container.getTagName()));\n    }","id":31885,"modified_method":"/**\n     * Test the first ancestor search, on a wikilink-like HTML structure.\n     * \n     * @see DOMUtils#getFirstAncestor(Node, String)\n     */\n    public void testGetFirstAncestor()\n    {\n        container.setInnerHTML(\"<div>our<!--startwikilink:Reference--><span class=\\\"wikilink\\\">\"\n            + \"<a>x<strong>wiki<\/strong><\/a><\/span><!--stopwikilink-->rox<\/div>\");\n        Node wrappingSpan = container.getFirstChild().getChildNodes().getItem(2);\n        Node anchor = wrappingSpan.getFirstChild();\n        Node boldWiki = anchor.getChildNodes().getItem(1);\n        Node labelBoldWiki = boldWiki.getFirstChild();\n        String anchorTagName = anchor.getNodeName();\n\n        // check if there is a first ancestor of type a for the bold inside the anchor\n        assertSame(\"There isn't an anchor ancestor for the bold inside the anchor\", anchor, domUtils.getFirstAncestor(\n            boldWiki, anchorTagName));\n        // check if there is a first ancestor of type a for the text inside bold in the anchor\n        assertSame(\"There isn't an anchor ancestor for the text in the bold inside the anchor\", anchor, DOMUtils\n            .getInstance().getFirstAncestor(labelBoldWiki, anchorTagName));\n        // check there is no a ancestor of the wikilink span\n        assertNull(\"There is an anchor ancestor for the wikilink span\", domUtils.getFirstAncestor(wrappingSpan,\n            anchorTagName));\n        // check a finds itself as ancestor\n        assertSame(\"The anchor is not an anhor ancestor of itself\", anchor, domUtils.getFirstAncestor(anchor,\n            anchorTagName));\n        // check div ancestor search stops at startContainer\n        assertSame(\"Div ancestor search for the anchor does not stop at first div\", container.getFirstChild(), DOMUtils\n            .getInstance().getFirstAncestor(anchor, container.getTagName()));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#deleteNodeContents(Node, Node, int, boolean)}.\n     */\n    public void testDeleteNodeContentsUpwards()\n    {\n        container.setInnerHTML(\"<span>x<em>y<!--z--><del>wiki<\/del><\/em><\/span>\");\n        DOMUtils.getInstance().deleteNodeContents(container,\n            container.getFirstChild().getChildNodes().getItem(1).getChildNodes().getItem(2).getFirstChild(), 2, true);\n        assertEquals(\"<span><em><del>ki<\/del><\/em><\/span>\", container.getInnerHTML().toLowerCase());\n\n        container.setInnerHTML(\"<span><em><del>wiki<\/del><!--z-->y<\/em>x<\/span>\");\n        DOMUtils.getInstance().deleteNodeContents(container,\n            container.getFirstChild().getFirstChild().getFirstChild().getFirstChild(), 1, false);\n        assertEquals(\"<span><em><del>w<\/del><\/em><\/span>\", container.getInnerHTML().toLowerCase());\n    }","id":31886,"modified_method":"/**\n     * Unit test for {@link DOMUtils#deleteNodeContents(Node, Node, int, boolean)}.\n     */\n    public void testDeleteNodeContentsUpwards()\n    {\n        container.setInnerHTML(\"<span>x<em>y<!--z--><del>wiki<\/del><\/em><\/span>\");\n        domUtils.deleteNodeContents(container, container.getFirstChild().getChildNodes().getItem(1).getChildNodes()\n            .getItem(2).getFirstChild(), 2, true);\n        assertEquals(\"<span><em><del>ki<\/del><\/em><\/span>\", container.getInnerHTML().toLowerCase());\n\n        container.setInnerHTML(\"<span><em><del>wiki<\/del><!--z-->y<\/em>x<\/span>\");\n        domUtils.deleteNodeContents(container, container.getFirstChild().getFirstChild().getFirstChild()\n            .getFirstChild(), 1, false);\n        assertEquals(\"<span><em><del>w<\/del><\/em><\/span>\", container.getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#isSerializable(Node)}.\n     */\n    public void testIsSerializable()\n    {\n        Text text = Document.get().createTextNode(\"1983\").cast();\n        assertTrue(DOMUtils.getInstance().isSerializable(text));\n\n        text.setData(\"\");\n        assertFalse(DOMUtils.getInstance().isSerializable(text));\n\n        Element element = Document.get().createSpanElement().cast();\n        assertTrue(DOMUtils.getInstance().isSerializable(element));\n\n        element.setAttribute(Element.META_DATA_ATTR, \"\");\n        assertFalse(DOMUtils.getInstance().isSerializable(element));\n\n        Node comment = ((Document) Document.get()).createComment(\"\");\n        assertTrue(DOMUtils.getInstance().isSerializable(comment));\n    }","id":31887,"modified_method":"/**\n     * Unit test for {@link DOMUtils#isSerializable(Node)}.\n     */\n    public void testIsSerializable()\n    {\n        Text text = Document.get().createTextNode(\"1983\").cast();\n        assertTrue(domUtils.isSerializable(text));\n\n        text.setData(\"\");\n        assertFalse(domUtils.isSerializable(text));\n\n        Element element = Document.get().createSpanElement().cast();\n        assertTrue(domUtils.isSerializable(element));\n\n        element.setAttribute(Element.META_DATA_ATTR, \"\");\n        assertFalse(domUtils.isSerializable(element));\n\n        Node comment = ((Document) Document.get()).createComment(\"\");\n        assertTrue(domUtils.isSerializable(comment));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link DOMUtils#cloneNodeContents(Node, int, int)}.\n     */\n    public void testCloneNodeContents()\n    {\n        container.setInnerHTML(\"xwiki<span><em>$<\/em><ins>#<\/ins><\/span>\");\n\n        DocumentFragment contents = DOMUtils.getInstance().cloneNodeContents(container.getFirstChild(), 0, 2);\n        assertEquals(1, contents.getChildNodes().getLength());\n        assertEquals(\"xw\", contents.getInnerHTML());\n\n        contents = DOMUtils.getInstance().cloneNodeContents(container.getFirstChild(), 5, 5);\n        assertEquals(0, contents.getChildNodes().getLength());\n\n        contents = DOMUtils.getInstance().cloneNodeContents(container.getLastChild(), 0, 2);\n        assertEquals(2, contents.getChildNodes().getLength());\n        assertEquals(\"<em>$<\/em><ins>#<\/ins>\", contents.getInnerHTML().toLowerCase());\n    }","id":31888,"modified_method":"/**\n     * Unit test for {@link DOMUtils#cloneNodeContents(Node, int, int)}.\n     */\n    public void testCloneNodeContents()\n    {\n        container.setInnerHTML(\"xwiki<span><em>$<\/em><ins>#<\/ins><\/span>\");\n\n        DocumentFragment contents = domUtils.cloneNodeContents(container.getFirstChild(), 0, 2);\n        assertEquals(1, contents.getChildNodes().getLength());\n        assertEquals(\"xw\", contents.getInnerHTML());\n\n        contents = domUtils.cloneNodeContents(container.getFirstChild(), 5, 5);\n        assertEquals(0, contents.getChildNodes().getLength());\n\n        contents = domUtils.cloneNodeContents(container.getLastChild(), 0, 2);\n        assertEquals(2, contents.getChildNodes().getLength());\n        assertEquals(\"<em>$<\/em><ins>#<\/ins>\", contents.getInnerHTML().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractWysiwygClientTest#gwtSetUp()\n     */\n    protected void gwtSetUp() throws Exception\n    {\n        super.gwtSetUp();\n\n        container = ((Document) Document.get()).xCreateDivElement().cast();\n        Document.get().getBody().appendChild(container);\n    }","id":31889,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractWysiwygClientTest#gwtSetUp()\n     */\n    protected void gwtSetUp() throws Exception\n    {\n        super.gwtSetUp();\n\n        if (domUtils == null) {\n            domUtils = DOMUtils.getInstance();\n        }\n\n        container = ((Document) Document.get()).xCreateDivElement().cast();\n        Document.get().getBody().appendChild(container);\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractExecutable#execute(RichTextArea, String)\n     */\n    public boolean execute(RichTextArea rta, String param)\n    {\n        Selection selection = rta.getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n\n        // Leave the rest of the ranges intact.\n        selection.removeAllRanges();\n\n        // Delete the contents of the first range. The horizontal rule will be inserted in place of the deleted text.\n        range.deleteContents();\n\n        // Split the DOM tree up to the nearest flow container, insert a horizontal rule and place the caret after the\n        // inserted horizontal rule.\n        Node start = range.getStartContainer();\n        int offset = range.getStartOffset();\n        Node flowContainer = DOMUtils.getInstance().getNearestFlowContainer(start);\n        if (flowContainer == null) {\n            return false;\n        }\n        Node hr = rta.getDocument().xCreateHRElement();\n        if (flowContainer == start) {\n            DOMUtils.getInstance().insertAt(flowContainer, hr, offset);\n            range.setEndAfter(hr);\n        } else {\n            Node startNextLevelSibling = DOMUtils.getInstance().splitNode(flowContainer, start, offset);\n            DOMUtils.getInstance().insertAfter(hr, DOMUtils.getInstance().getChild(flowContainer, start));\n            // We need to update the range after inserting the horizontal rule because otherwise the caret might jump\n            // before it (this happens in IE for instance).\n            range.setEnd(startNextLevelSibling, 0);\n        }\n        range.collapse(false);\n        selection.addRange(range);\n\n        return true;\n    }","id":31890,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractExecutable#execute(RichTextArea, String)\n     */\n    public boolean execute(RichTextArea rta, String param)\n    {\n        Selection selection = rta.getDocument().getSelection();\n        if (!selection.isCollapsed()) {\n            // Delete the selected contents. The horizontal rule will be inserted in place of the deleted text.\n            // NOTE: We cannot use Range#deleteContents because it may lead to DTD-invalid HTML. That's because it\n            // operates on any DOM tree without taking care of the underlying XML syntax, (X)HTML in our case. Let's use\n            // the Delete command instead which is HTML-aware. Moreover, others could listen to this command and adjust\n            // the DOM before we insert the HR.\n            rta.getCommandManager().execute(Command.DELETE);\n        }\n\n        // At this point the selection should be collapsed.\n        // Split the DOM tree up to the nearest flow container, insert a horizontal rule and place the caret after the\n        // inserted horizontal rule.\n        Range range = selection.getRangeAt(0);\n        Node start = range.getStartContainer();\n        int offset = range.getStartOffset();\n        Node flowContainer = domUtils.getNearestFlowContainer(start);\n        if (flowContainer == null) {\n            return false;\n        }\n        Node hr = rta.getDocument().xCreateHRElement();\n        if (flowContainer == start) {\n            domUtils.insertAt(flowContainer, hr, offset);\n            range.setEndAfter(hr);\n        } else {\n            Node startNextLevelSibling = domUtils.splitNode(flowContainer, start, offset);\n            domUtils.insertAfter(hr, domUtils.getChild(flowContainer, start));\n            // We need to update the range after inserting the horizontal rule because otherwise the caret might jump\n            // before it (this happens in IE for instance).\n            range.setEnd(startNextLevelSibling, 0);\n        }\n        range.collapse(false);\n        selection.removeAllRanges();\n        selection.addRange(range);\n\n        return true;\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link InsertHRExecutable#execute(com.xpn.xwiki.wysiwyg.client.widget.rta.RichTextArea, String)}\n     * when there is text selected.\n     */\n    private void doTestReplaceSelection()\n    {\n        rta.setHTML(\"<ul><li>a<em>bc<\/em>d<del>ef<\/del>g<\/li><\/ul>\");\n\n        Range range = rta.getDocument().createRange();\n        range.setStart(getBody().getFirstChild().getFirstChild().getChildNodes().getItem(1).getFirstChild(), 1);\n        range.setEnd(getBody().getFirstChild().getFirstChild().getChildNodes().getItem(3).getFirstChild(), 1);\n        select(range);\n\n        assertEquals(\"cde\", rta.getDocument().getSelection().toString());\n        assertTrue(executable.execute(rta, null));\n        assertEquals(\"<ul><li>a<em>b<\/em><hr><del>f<\/del>g<\/li><\/ul>\", clean(rta.getHTML()));\n        assertTrue(rta.getDocument().getSelection().isCollapsed());\n        assertEquals(3, rta.getDocument().getSelection().getRangeAt(0).getStartOffset());\n        assertEquals(getBody().getFirstChild().getFirstChild(), rta.getDocument().getSelection().getRangeAt(0)\n            .getStartContainer());\n    }","id":31891,"modified_method":"/**\n     * Unit test for {@link InsertHRExecutable#execute(com.xpn.xwiki.wysiwyg.client.widget.rta.RichTextArea, String)}\n     * when there is text selected.\n     */\n    private void doTestReplaceSelection()\n    {\n        rta.setHTML(\"<ul><li>a<em>bc<\/em>d<del>ef<\/del>g<\/li><\/ul>\");\n\n        Range range = rta.getDocument().createRange();\n        range.setStart(getBody().getFirstChild().getFirstChild().getChildNodes().getItem(1).getFirstChild(), 1);\n        range.setEnd(getBody().getFirstChild().getFirstChild().getChildNodes().getItem(3).getFirstChild(), 1);\n        select(range);\n\n        assertEquals(\"cde\", rta.getDocument().getSelection().toString());\n        assertTrue(executable.execute(rta, null));\n        assertEquals(\"<ul><li>a<em>b<\/em><hr><em><\/em><del>f<\/del>g<\/li><\/ul>\", removeNonBreakingSpaces(clean(rta\n            .getHTML())));\n\n        range = rta.getDocument().getSelection().getRangeAt(0);\n        assertTrue(range.isCollapsed());\n        assertEquals(\"<em><\/em>\", ((Element) range.getStartContainer().getParentNode()).getString().toLowerCase());\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link InsertHRExecutable#execute(com.xpn.xwiki.wysiwyg.client.widget.rta.RichTextArea, String)}\n     * when the selection wraps an element's inner text.\n     */\n    private void doTestReplaceElementText()\n    {\n        rta.setHTML(\"a<strong>b<\/strong>c\");\n\n        Range range = rta.getDocument().getSelection().getRangeAt(0);\n        range.setEnd(getBody().getChildNodes().getItem(1).getFirstChild(), 1);\n        range.setStart(getBody().getChildNodes().getItem(1).getFirstChild(), 0);\n        select(range);\n\n        assertEquals(\"b\", rta.getDocument().getSelection().toString());\n        assertTrue(executable.execute(rta, null));\n        assertEquals(\"a<strong><\/strong><hr><strong><\/strong>c\", clean(rta.getHTML()));\n    }","id":31892,"modified_method":"/**\n     * Unit test for {@link InsertHRExecutable#execute(com.xpn.xwiki.wysiwyg.client.widget.rta.RichTextArea, String)}\n     * when the selection wraps an element's inner text.\n     */\n    private void doTestReplaceElementText()\n    {\n        rta.setHTML(\"a<strong>b<\/strong>c\");\n\n        Range range = rta.getDocument().getSelection().getRangeAt(0);\n        range.setEnd(getBody().getChildNodes().getItem(1).getFirstChild(), 1);\n        range.setStart(getBody().getChildNodes().getItem(1).getFirstChild(), 0);\n        select(range);\n\n        assertEquals(\"b\", rta.getDocument().getSelection().toString());\n        assertTrue(executable.execute(rta, null));\n        assertEquals(\"a<strong><\/strong><hr><strong><\/strong>c\", removeNonBreakingSpaces(clean(rta.getHTML())));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unit test for {@link InsertHRExecutable#execute(com.xpn.xwiki.wysiwyg.client.widget.rta.RichTextArea, String)}\n     * when there is no text selected.\n     */\n    private void doTestInsertAtCaret()\n    {\n        rta.setHTML(\"a<p>b<ins><!--x-->cd<\/ins><\/p>e\");\n\n        Range range = rta.getDocument().createRange();\n        range.setStart(getBody().getChildNodes().getItem(1).getChildNodes().getItem(1).getLastChild(), 1);\n        range.collapse(true);\n        select(range);\n\n        assertTrue(executable.execute(rta, null));\n        assertEquals(\"a<p>b<ins><!--x-->c<\/ins><\/p><hr><p><ins>d<\/ins><\/p>e\", clean(rta.getHTML()));\n    }","id":31893,"modified_method":"/**\n     * Unit test for {@link InsertHRExecutable#execute(com.xpn.xwiki.wysiwyg.client.widget.rta.RichTextArea, String)}\n     * when there is no text selected.\n     */\n    private void doTestInsertAtCaret()\n    {\n        rta.setHTML(\"a<p>b<ins><!--x-->cd<\/ins><\/p>e\");\n\n        Range range = rta.getDocument().createRange();\n        range.setStart(getBody().getChildNodes().getItem(1).getChildNodes().getItem(1).getLastChild(), 1);\n        range.collapse(true);\n        select(range);\n\n        assertTrue(executable.execute(rta, null));\n        assertEquals(\"a<p>b<ins><!--x-->c<\/ins><\/p><hr><p><ins>d<\/ins><\/p>e\", removeNonBreakingSpaces(clean(rta\n            .getHTML())));\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractExecutable#execute(RichTextArea, String)\n     */\n    public boolean execute(RichTextArea rta, String param)\n    {\n        Element container = rta.getDocument().xCreateDivElement().cast();\n        container.xSetInnerHTML(param);\n\n        Selection selection = rta.getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n        range.deleteContents();\n        range.insertNode(container.extractContents());\n        selection.removeAllRanges();\n        selection.addRange(range);\n\n        return true;\n    }","id":31894,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractExecutable#execute(RichTextArea, String)\n     */\n    public boolean execute(RichTextArea rta, String param)\n    {\n        Element container = rta.getDocument().xCreateDivElement().cast();\n        container.xSetInnerHTML(param);\n\n        Selection selection = rta.getDocument().getSelection();\n        if (!selection.isCollapsed()) {\n            // Delete the selected contents. The given HTML fragment will be inserted in place of the deleted text.\n            // NOTE: We cannot use Range#deleteContents because it may lead to DTD-invalid HTML. That's because it\n            // operates on any DOM tree without taking care of the underlying XML syntax, (X)HTML in our case. Let's use\n            // the Delete command instead which is HTML-aware. Moreover, others could listen to this command and adjust\n            // the DOM before we insert the HTML.\n            rta.getCommandManager().execute(Command.DELETE);\n        }\n        // At this point the selection should be collapsed.\n        Range range = selection.getRangeAt(0);\n        range.insertNode(container.extractContents());\n        selection.removeAllRanges();\n        selection.addRange(range);\n\n        return true;\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Insert a HTML table in the editor.\n     * \n     * @param rta WYSIWYG RichTextArea\n     * @param config creation parameters.\n     */\n    public void insertTable(RichTextArea rta, TableConfig config)\n    {\n        Selection selection = rta.getDocument().getSelection();\n        Range range = selection.getRangeAt(0);\n\n        // Leave the rest of the ranges intact.\n        selection.removeAllRanges();\n\n        // Delete the contents of the first range. The horizontal rule will be inserted in place of the deleted text.\n        range.deleteContents();\n\n        // Split the DOM tree up to the nearest flow container and insert the table.\n        Node start = range.getStartContainer();\n        int offset = range.getStartOffset();\n        Node flowContainer = DOMUtils.getInstance().getNearestFlowContainer(start);\n        if (flowContainer == null) {\n            return;\n        }\n        Element table = createTable(rta.getDocument(), config);\n        if (flowContainer == start) {\n            DOMUtils.getInstance().insertAt(flowContainer, table, offset);\n        } else {\n            DOMUtils.getInstance().splitNode(flowContainer, start, offset);\n            DOMUtils.getInstance().insertAfter(table, DOMUtils.getInstance().getChild(flowContainer, start));\n        }\n\n        // Place the caret at the beginning of the first cell.\n        range.selectNodeContents(DOMUtils.getInstance().getFirstDescendant(table,\n            config.hasHeader() ? TableUtils.COL_HNODENAME : TableUtils.COL_NODENAME));\n        range.collapse(false);\n        selection.addRange(range);\n    }","id":31895,"modified_method":"/**\n     * Insert a HTML table in the editor.\n     * \n     * @param rta WYSIWYG RichTextArea\n     * @param config creation parameters.\n     */\n    public void insertTable(RichTextArea rta, TableConfig config)\n    {\n        Selection selection = rta.getDocument().getSelection();\n        if (!selection.isCollapsed()) {\n            // Delete the selected contents. The table will be inserted in place of the deleted text.\n            // NOTE: We cannot use Range#deleteContents because it may lead to DTD-invalid HTML. That's because it\n            // operates on any DOM tree without taking care of the underlying XML syntax, (X)HTML in our case. Let's use\n            // the Delete command instead which is HTML-aware. Moreover, others could listen to this command and adjust\n            // the DOM before we insert the table.\n            rta.getCommandManager().execute(Command.DELETE);\n        }\n\n        // At this point the selection should be collapsed.\n        // Split the DOM tree up to the nearest flow container and insert the table.\n        Range range = selection.getRangeAt(0);\n        Node start = range.getStartContainer();\n        int offset = range.getStartOffset();\n        Node flowContainer = DOMUtils.getInstance().getNearestFlowContainer(start);\n        if (flowContainer == null) {\n            return;\n        }\n        Element table = createTable(rta.getDocument(), config);\n        if (flowContainer == start) {\n            DOMUtils.getInstance().insertAt(flowContainer, table, offset);\n        } else {\n            DOMUtils.getInstance().splitNode(flowContainer, start, offset);\n            DOMUtils.getInstance().insertAfter(table, DOMUtils.getInstance().getChild(flowContainer, start));\n        }\n\n        // Place the caret at the beginning of the first cell.\n        range.selectNodeContents(DOMUtils.getInstance().getFirstDescendant(table,\n            config.hasHeader() ? TableUtils.COL_HNODENAME : TableUtils.COL_NODENAME));\n        range.collapse(false);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }","commit_id":"0751a67e15947cb6a8252e7d680d71b29e090796","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void runCommand(final String[] command, final String[] args) throws CLIException, InterruptedException {\n\n\t\tfinal File directory = new File(Environment.getHomeDirectory(), \"/bin\").getAbsoluteFile();\n\n\t\t// gs-agent.sh/bat need full path\n\t\tcommand[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();\n\n\t\tfinal List<String> commandLine = new ArrayList<String>();\n\t\tcommandLine.addAll(Arrays.asList(command));\n\t\tcommandLine.addAll(Arrays.asList(args));\n\n\t\tfinal String commandString = StringUtils.collectionToDelimitedString(commandLine, \" \");\n\t\tfinal File filename = createScript(commandString);\n\t\tfinal ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);\n\n\t\tString gsaJavaOptions = \"-Xmx\" + GSA_MEMORY_IN_MB + \"m\";\n\t\tif (autoShutdown) {\n\t\t\tgsaJavaOptions += \" \" + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;\n\t\t}\n\t\tString lusJavaOptions = \"-Xmx\" + LUS_MEMORY_IN_MB + \"m\" + \" -D\" + LUS_PORT_CONTEXT_PROPERTY + \"=\" + lusPort;\n\t\tString gsmJavaOptions = \"-Xmx\" + GSM_MEMORY_IN_MB + \"m\" + \" -D\" + LUS_PORT_CONTEXT_PROPERTY + \"=\" + lusPort;\n\t\tString esmJavaOptions = \"-Xmx\" + ESM_MEMORY_IN_MB + \"m\";\n\t\tString gscJavaOptions = \"\";\n\n\t\tfinal Map<String, String> environment = pb.environment();\n\t\tif (lookupGroups != null) {\n\t\t\tenvironment.put(\"LOOKUPGROUPS\", lookupGroups);\n\t\t}\n\n\t\tif (lookupLocators != null) {\n\t\t\tenvironment.put(\"LOOKUPLOCATORS\", lookupLocators);\n\t\t\tfinal String disableMulticast = \"-Dcom.gs.multicast.enabled=false\";\n\t\t\tgsaJavaOptions += \" \" + disableMulticast;\n\t\t\tlusJavaOptions += \" \" + disableMulticast;\n\t\t\tgsmJavaOptions += \" \" + disableMulticast;\n\t\t\tesmJavaOptions += \" \" + disableMulticast;\n\t\t\tgscJavaOptions += disableMulticast;\n\t\t}\n\n\t\tif (nicAddress != null) {\n\t\t\tenvironment.put(\"NIC_ADDR\", nicAddress);\n\t\t}\n\n\t\tif (zone != null) {\n\t\t\tgsaJavaOptions += \" -Dcom.gs.zones=\" + zone;\n\t\t}\n\n\t\tenvironment.put(\"GSA_JAVA_OPTIONS\", gsaJavaOptions);\n\t\tenvironment.put(\"LUS_JAVA_OPTIONS\", lusJavaOptions);\n\t\tenvironment.put(\"GSM_JAVA_OPTIONS\", gsmJavaOptions);\n\t\tenvironment.put(\"ESM_JAVA_OPTIONS\", esmJavaOptions);\n\t\tenvironment.put(\"GSC_JAVA_OPTIONS\", gscJavaOptions);\n\n\t\t// start process\n\t\t// there is no need to redirect output, since the process suppresses\n\t\t// output\n\t\ttry {\n\t\t\tlogger.fine(\"Executing command: \" + commandString);\n\t\t\tProcess proc = pb.start();\n\t\t\tThread.sleep(MIN_PROC_ERROR_TIME);\n\t\t\ttry{\n\t\t\t\t// The assumption is that if the script contains errors, \n\t\t\t\t// the processBuilder will finish by the end of the above sleep period.\n\t\t\t\tif (proc.exitValue() != 0){\n\t\t\t\t\tString errorMessage = \"Error while starting agent. \" +\n\t\t\t\t\t\t\t\t\t\"Please make sure that another agent is not already running. \";\n\t\t\t\t\tif (verbose){\n\t\t\t\t\t\terrorMessage = errorMessage.concat(\"Command executed: \" + commandString);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new CLIException(errorMessage);\n\t\t\t\t}\n\t\t\t// ProcessBuilder is still running. We assume the agent script is running fine.\n\t\t\t}catch (IllegalThreadStateException e){\n\t\t\t\tlogger.fine(\"agent is starting...\");\n\t\t\t}\n\t\t} catch (final IOException e) {\n\t\t\tthrow new CLIException(\"Error while starting agent\", e);\n\t\t}\n\t}","id":31896,"modified_method":"private void runCommand(final String[] command, final String[] args) throws CLIException, InterruptedException {\n\n\t\tfinal File directory = new File(Environment.getHomeDirectory(), \"/bin\").getAbsoluteFile();\n\n\t\t// gs-agent.sh/bat need full path\n\t\tcommand[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();\n\n\t\tfinal List<String> commandLine = new ArrayList<String>();\n\t\tcommandLine.addAll(Arrays.asList(command));\n\t\tcommandLine.addAll(Arrays.asList(args));\n\n\t\tfinal String commandString = StringUtils.collectionToDelimitedString(commandLine, \" \");\n\t\tfinal File filename = createScript(commandString);\n\t\tfinal ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);\n\n\t\tString gsaJavaOptions = \"-Xmx\" + GSA_MEMORY_IN_MB + \"m\";\n\t\tif (autoShutdown) {\n\t\t\tgsaJavaOptions += \" \" + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;\n\t\t}\n\t\tString lusJavaOptions = \"-Xmx\" + LUS_MEMORY_IN_MB + \"m\" + \" -D\" + LUS_PORT_CONTEXT_PROPERTY + \"=\" + lusPort;\n\t\tString gsmJavaOptions = \"-Xmx\" + GSM_MEMORY_IN_MB + \"m\" + \" -D\" + LUS_PORT_CONTEXT_PROPERTY + \"=\" + lusPort;\n\t\tString esmJavaOptions = \"-Xmx\" + ESM_MEMORY_IN_MB + \"m\";\n\t\tString gscJavaOptions = \"\";\n\n\t\tfinal Map<String, String> environment = pb.environment();\n\t\tif (lookupGroups != null) {\n\t\t\tenvironment.put(\"LOOKUPGROUPS\", lookupGroups);\n\t\t}\n\n\t\tif (lookupLocators != null) {\n\t\t\tenvironment.put(\"LOOKUPLOCATORS\", lookupLocators);\n\t\t\tfinal String disableMulticast = \"-Dcom.gs.multicast.enabled=false\";\n\t\t\tgsaJavaOptions += \" \" + disableMulticast;\n\t\t\tlusJavaOptions += \" \" + disableMulticast;\n\t\t\tgsmJavaOptions += \" \" + disableMulticast;\n\t\t\tesmJavaOptions += \" \" + disableMulticast;\n\t\t\tgscJavaOptions += disableMulticast;\n\t\t}\n\n\t\tif (nicAddress != null) {\n\t\t\tenvironment.put(\"NIC_ADDR\", nicAddress);\n\t\t}\n\n\t\tif (zone != null) {\n\t\t\tgsaJavaOptions += \" -Dcom.gs.zones=\" + zone;\n\t\t}\n\n\t\tenvironment.put(\"GSA_JAVA_OPTIONS\", gsaJavaOptions);\n\t\tenvironment.put(\"LUS_JAVA_OPTIONS\", lusJavaOptions);\n\t\tenvironment.put(\"GSM_JAVA_OPTIONS\", gsmJavaOptions);\n\t\tenvironment.put(\"ESM_JAVA_OPTIONS\", esmJavaOptions);\n\t\tenvironment.put(\"GSC_JAVA_OPTIONS\", gscJavaOptions);\n\n\t\t// start process\n\t\t// there is no need to redirect output, since the process suppresses\n\t\t// output\n\t\ttry {\n\t\t\tlogger.fine(\"Executing command: \" + commandString);\n\t\t\tfinal Process proc = pb.start();\n\t\t\tThread.sleep(MIN_PROC_ERROR_TIME);\n\t\t\ttry {\n\t\t\t\t// The assumption is that if the script contains errors,\n\t\t\t\t// the processBuilder will finish by the end of the above sleep period.\n\t\t\t\tif (proc.exitValue() != 0) {\n\t\t\t\t\tString errorMessage = \"Error while starting agent. \"\n\t\t\t\t\t\t\t+ \"Please make sure that another agent is not already running. \";\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\terrorMessage = errorMessage.concat(\"Command executed: \" + commandString);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new CLIException(errorMessage);\n\t\t\t\t}\n\t\t\t\t// ProcessBuilder is still running. We assume the agent script is running fine.\n\t\t\t} catch (final IllegalThreadStateException e) {\n\t\t\t\tlogger.fine(\"agent is starting...\");\n\t\t\t}\n\t\t} catch (final IOException e) {\n\t\t\tthrow new CLIException(\"Error while starting agent\", e);\n\t\t}\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Shuts down the local agent, management processes (GSM, ESM, LUS) and GSC. Waits until shutdown is\n\t * complete or until the timeout is reached. Active services are forced to shut down.\n\t * \n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t */\n\tpublic void shutdownManagementOnLocalhostAndWait(final int timeout, final TimeUnit timeunit) throws CLIException,\n\t\t\tInterruptedException, TimeoutException {\n\n\t\tsetDefaultNicAddress();\n\n\t\tshutdownAgentOnLocalhostAndWaitInternal(true, true, timeout, timeunit);\n\t}","id":31897,"modified_method":"/**\n\t * Shuts down the local agent, management processes (GSM, ESM, LUS) and GSC. Waits until shutdown is\n\t * complete or until the timeout is reached. Active services are forced to shut down.\n\t * \n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @return tear-down result, as a value of {@link TeardownCloudResults}\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t */\n\tpublic TeardownCloudResults shutdownManagementOnLocalhostAndWait(final int timeout, final TimeUnit timeunit) throws CLIException,\n\t\t\tInterruptedException, TimeoutException {\n\n\t\tsetDefaultNicAddress();\n\n\t\treturn shutdownAgentOnLocalhostAndWaitInternal(true, true, timeout, timeunit);\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Shuts down the local agent, if exists, and waits until shutdown is complete or until the timeout is\n\t * reached.\n\t * \n\t * @param allowManagement\n\t *            Allow the agent to shut down even the management processes (GSM, ESM, LUS) it started are\n\t *            still active\n\t * @param allowContainers\n\t *            Allow the agent to shut down even the GSC still runs active services\n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent, or the management/services components still\n\t *             require it\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t */\n\tpublic void shutdownAgentOnLocalhostAndWaitInternal(final boolean allowManagement, final boolean allowContainers,\n\t\t\tfinal long timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {\n\n\t\tfinal long end = System.currentTimeMillis() + timeunit.toMillis(timeout);\n\t\tfinal ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();\n\t\tconnectionLogs.supressConnectionErrors();\n\t\tadminFacade.disconnect();\n\t\tfinal Admin admin = createAdmin();\n\t\tGridServiceAgent agent = null;\n\t\ttry {\n\t\t\tsetLookupDefaults(admin);\n\t\t\ttry {\n\t\t\t\tagent = waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n\t\t\t} catch (final TimeoutException e) {\n\t\t\t\t// continue\n\t\t\t}\n\n\t\t\tif (agent == null) {\n\t\t\t\tlogger.info(\"Agent not running on local machine\");\n\t\t\t} else {\n\t\t\t\t// If the agent we attempt to shutdown is of a GSC that has active services, allowContainers\n\t\t\t\t// must be true or an exception will be thrown.\n\t\t\t\tif (!allowContainers) {\n\t\t\t\t\tfor (final ProcessingUnit pu : admin.getProcessingUnits()) {\n\t\t\t\t\t\tfor (final ProcessingUnitInstance instance : pu) {\n\t\t\t\t\t\t\tif (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {\n\t\t\t\t\t\t\t\tthrow new CLIException(\"Cannot shutdown agent since \" + pu.getName()\n\t\t\t\t\t\t\t\t\t\t+ \" service is still running on this machine. Use -force flag.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the agent we attempt to shutdown is a GSM, ESM or LUS, allowManagement must be true or\n\t\t\t\t// an exception will be thrown.\n\t\t\t\tif (!allowManagement) {\n\t\t\t\t\tfinal String message = \"Cannot shutdown agent since management processes running on this machine. \"\n\t\t\t\t\t\t\t+ \"Use the shutdown-management command instead.\";\n\n\t\t\t\t\tfor (final GridServiceManager gsm : admin.getGridServiceManagers()) {\n\t\t\t\t\t\tif (agent.equals(gsm.getGridServiceAgent())) {\n\t\t\t\t\t\t\tthrow new CLIException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (final ElasticServiceManager esm : admin.getElasticServiceManagers()) {\n\t\t\t\t\t\tif (agent.equals(esm.getGridServiceAgent())) {\n\t\t\t\t\t\t\tthrow new CLIException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (final LookupService lus : admin.getLookupServices()) {\n\t\t\t\t\t\tif (agent.equals(lus.getGridServiceAgent())) {\n\t\t\t\t\t\t\tthrow new CLIException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Close admin before shutting down the agent to avoid false warning messages the admin will\n\t\t\t\t// create if it concurrently monitor things that are shutting down.\n\t\t\t\tadmin.close();\n\t\t\t\tshutdownAgentAndWait(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t} finally {\n\t\t\t// close in case of exception, admin support double close if already closed\n\t\t\tadmin.close();\n\t\t\tif (agent != null) {\n\t\t\t\t// admin.close() command does not verify that all of the internal lookup threads are actually\n\t\t\t\t// terminated\n\t\t\t\t// therefore we need to suppress connection warnings a little while longer\n\t\t\t\tThread.sleep(WAIT_AFTER_ADMIN_CLOSED_MILLIS);\n\t\t\t}\n\t\t\tconnectionLogs.restoreConnectionErrors();\n\t\t}\n\t}","id":31898,"modified_method":"/**\n\t * Shuts down the local agent, if exists, and waits until shutdown is complete or until the timeout is\n\t * reached.\n\t * \n\t * @param allowManagement\n\t *            Allow the agent to shut down even the management processes (GSM, ESM, LUS) it started are\n\t *            still active\n\t * @param allowContainers\n\t *            Allow the agent to shut down even the GSC still runs active services\n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @return tear-down result, as a value of {@link TeardownCloudResults}\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent, or the management/services components still\n\t *             require it\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t */\n\tpublic TeardownCloudResults shutdownAgentOnLocalhostAndWaitInternal(final boolean allowManagement,\n\t\t\tfinal boolean allowContainers, final long timeout, final TimeUnit timeunit) throws CLIException,\n\t\t\tInterruptedException, TimeoutException {\n\n\t\tTeardownCloudResults teardownResult = null;\n\t\tfinal long end = System.currentTimeMillis() + timeunit.toMillis(timeout);\n\t\tfinal ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();\n\t\tconnectionLogs.supressConnectionErrors();\n\t\tadminFacade.disconnect();\n\t\tfinal Admin admin = createAdmin();\n\t\tGridServiceAgent agent = null;\n\t\ttry {\n\t\t\tsetLookupDefaults(admin);\n\t\t\ttry {\n\t\t\t\tagent = waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n\t\t\t} catch (final TimeoutException e) {\n\t\t\t\t// continue\n\t\t\t}\n\n\t\t\tif (agent == null) {\n\t\t\t\tlogger.info(\"Agent not running on local machine\");\n\t\t\t\tteardownResult = TeardownCloudResults.AGENT_NOT_FOUND_ON_LOCAL_MACHINE;\n\t\t\t} else {\n\t\t\t\t// If the agent we attempt to shutdown is of a GSC that has active services, allowContainers\n\t\t\t\t// must be true or an exception will be thrown.\n\t\t\t\tif (!allowContainers) {\n\t\t\t\t\tfor (final ProcessingUnit pu : admin.getProcessingUnits()) {\n\t\t\t\t\t\tfor (final ProcessingUnitInstance instance : pu) {\n\t\t\t\t\t\t\tif (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {\n\t\t\t\t\t\t\t\tthrow new CLIException(\"Cannot shutdown agent since \" + pu.getName()\n\t\t\t\t\t\t\t\t\t\t+ \" service is still running on this machine. Use -force flag.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the agent we attempt to shutdown is a GSM, ESM or LUS, allowManagement must be true or\n\t\t\t\t// an exception will be thrown.\n\t\t\t\tif (!allowManagement) {\n\t\t\t\t\tfinal String message = \"Cannot shutdown agent since management processes running on this machine. \"\n\t\t\t\t\t\t\t+ \"Use the shutdown-management command instead.\";\n\n\t\t\t\t\tfor (final GridServiceManager gsm : admin.getGridServiceManagers()) {\n\t\t\t\t\t\tif (agent.equals(gsm.getGridServiceAgent())) {\n\t\t\t\t\t\t\tthrow new CLIException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (final ElasticServiceManager esm : admin.getElasticServiceManagers()) {\n\t\t\t\t\t\tif (agent.equals(esm.getGridServiceAgent())) {\n\t\t\t\t\t\t\tthrow new CLIException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (final LookupService lus : admin.getLookupServices()) {\n\t\t\t\t\t\tif (agent.equals(lus.getGridServiceAgent())) {\n\t\t\t\t\t\t\tthrow new CLIException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Close admin before shutting down the agent to avoid false warning messages the admin will\n\t\t\t\t// create if it concurrently monitor things that are shutting down.\n\t\t\t\tadmin.close();\n\t\t\t\tshutdownAgentAndWait(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);\n\t\t\t\tteardownResult = TeardownCloudResults.COMPLETED_SUCCESSFULLY;\n\t\t\t}\n\t\t} finally {\n\t\t\t// close in case of exception, admin support double close if already closed\n\t\t\tadmin.close();\n\t\t\tif (agent != null) {\n\t\t\t\t// admin.close() command does not verify that all of the internal lookup threads are actually\n\t\t\t\t// terminated\n\t\t\t\t// therefore we need to suppress connection warnings a little while longer\n\t\t\t\tThread.sleep(WAIT_AFTER_ADMIN_CLOSED_MILLIS);\n\t\t\t}\n\t\t\tconnectionLogs.restoreConnectionErrors();\n\t\t}\n\n\t\treturn teardownResult;\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Shuts down the local cloud, and waits until shutdown is complete or until the timeout is reached.\n\t * \n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent\n\t */\n\tpublic void teardownLocalCloudOnLocalhostAndWait(final long timeout, final TimeUnit timeunit)\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\n\n\t\tsetDefaultNicAddress();\n\n\t\tsetDefaultLocalcloudLookup();\n\n\t\tshutdownAgentOnLocalhostAndWaitInternal(true, true, timeout, timeunit);\n\t}","id":31899,"modified_method":"/**\n\t * Shuts down the local cloud, and waits until shutdown is complete or until the timeout is reached.\n\t * \n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @return tear-down result, as a value of {@link TeardownCloudResults}\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent\n\t */\n\tpublic TeardownCloudResults teardownLocalCloudOnLocalhostAndWait(final long timeout, final TimeUnit timeunit)\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\n\n\t\tsetDefaultNicAddress();\n\n\t\tsetDefaultLocalcloudLookup();\n\n\t\treturn shutdownAgentOnLocalhostAndWaitInternal(true, true, timeout, timeunit);\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Shuts down the local agent, if exists, and waits until shutdown is complete or until the timeout is\n\t * reached. If management processes (GSM, ESM, LUS) are still active, the agent is not shutdown and a\n\t * CLIException is thrown.\n\t * \n\t * @param force\n\t *            Force the agent to shut down even if the GSC still runs active services\n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t */\n\tpublic void shutdownAgentOnLocalhostAndWait(final boolean force, final int timeout, final TimeUnit timeunit)\n\t\t\tthrows CLIException, InterruptedException, TimeoutException {\n\n\t\tsetDefaultNicAddress();\n\n\t\tshutdownAgentOnLocalhostAndWaitInternal(false, force, timeout, timeunit);\n\t}","id":31900,"modified_method":"/**\n\t * Shuts down the local agent, if exists, and waits until shutdown is complete or until the timeout is\n\t * reached. If management processes (GSM, ESM, LUS) are still active, the agent is not shutdown and a\n\t * CLIException is thrown.\n\t * \n\t * @param force\n\t *            Force the agent to shut down even if the GSC still runs active services\n\t * @param timeout\n\t *            number of {@link TimeUnit}s to wait\n\t * @param timeunit\n\t *            the {@link TimeUnit} to use, to calculate the timeout\n\t * @return tear-down result, as a value of {@link TeardownCloudResults}\n\t * @throws CLIException\n\t *             Reporting a failure to shutdown the agent\n\t * @throws InterruptedException\n\t *             Reporting the thread was interrupted while waiting\n\t * @throws TimeoutException\n\t *             Reporting the timeout was reached\n\t */\n\tpublic TeardownCloudResults shutdownAgentOnLocalhostAndWait(final boolean force, final int timeout, final TimeUnit timeunit)\n\t\t\tthrows CLIException, InterruptedException, TimeoutException {\n\n\t\tsetDefaultNicAddress();\n\n\t\treturn shutdownAgentOnLocalhostAndWaitInternal(false, force, timeout, timeunit);\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\n\t\tinstaller.setVerbose(verbose);\n\t\tinstaller.setLookupGroups(lookupGroups);\n\t\tinstaller.setLookupLocators(lookupLocators);\n\t\tinstaller.setNicAddress(nicAddress);\n\t\tinstaller.setProgressInSeconds(10);\n\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\n\n\t\tinstaller.shutdownAgentOnLocalhostAndWait(force, timeoutInMinutes, TimeUnit.MINUTES);\n\t\treturn \"Completed agent shutdown.\";\n\t}","id":31901,"modified_method":"/**\n\t * Shuts down the local agent, if exists, and waits until shutdown is complete or until the timeout is\n\t * reached. If management processes (GSM, ESM, LUS) are still active, the agent is not shutdown and a\n\t * CLIException is thrown.\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\n\t\tinstaller.setVerbose(verbose);\n\t\tinstaller.setLookupGroups(lookupGroups);\n\t\tinstaller.setLookupLocators(lookupLocators);\n\t\tinstaller.setNicAddress(nicAddress);\n\t\tinstaller.setProgressInSeconds(10);\n\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\n\n\t\tTeardownCloudResults result = installer.shutdownAgentOnLocalhostAndWait(force, timeoutInMinutes, TimeUnit.MINUTES);\n\t\treturn result.getDescription();\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\n\t\tinstaller.setVerbose(verbose);\n\t\tinstaller.setLookupGroups(lookupGroups);\n\t\tinstaller.setLookupLocators(lookupLocators);\n\t\tinstaller.setNicAddress(nicAddress);\n\t\tinstaller.setProgressInSeconds(10);\n\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\n\n\t\tinstaller.shutdownManagementOnLocalhostAndWait(timeoutInMinutes, TimeUnit.MINUTES);\n\t\treturn \"Completed management shutdown.\";\n\t}","id":31902,"modified_method":"/**\n\t * Shuts down the local agent, management processes (GSM, ESM, LUS) and GSC. Waits until shutdown is\n\t * complete or until the timeout is reached. Active services are forced to shut down.\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\n\t\tinstaller.setVerbose(verbose);\n\t\tinstaller.setLookupGroups(lookupGroups);\n\t\tinstaller.setLookupLocators(lookupLocators);\n\t\tinstaller.setNicAddress(nicAddress);\n\t\tinstaller.setProgressInSeconds(10);\n\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\n\n\t\tTeardownCloudResults result = installer.shutdownManagementOnLocalhostAndWait(timeoutInMinutes, TimeUnit.MINUTES);\n\t\treturn result.getDescription();\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\n\t\tinstaller.setVerbose(verbose);\n\t\tinstaller.setLookupGroups(lookupGroups);\n\t\tinstaller.setNicAddress(nicAddress);\n\t\tinstaller.setProgressInSeconds(10);\n\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\n\n\t\tinstaller.teardownLocalCloudOnLocalhostAndWait(timeoutInMinutes, TimeUnit.MINUTES);\n\t\treturn \"Completed local-cloud teardown\";\n\t}","id":31903,"modified_method":"/**\n\t * Shuts down the local cloud, and waits until shutdown is complete or until the timeout is reached.\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\n\t\tinstaller.setVerbose(verbose);\n\t\tinstaller.setLookupGroups(lookupGroups);\n\t\tinstaller.setNicAddress(nicAddress);\n\t\tinstaller.setProgressInSeconds(10);\n\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\n\n\t\tTeardownCloudResults result = installer.teardownLocalCloudOnLocalhostAndWait(timeoutInMinutes, TimeUnit.MINUTES);\n\t\treturn result.getDescription();\n\t}","commit_id":"7a8bc7535080a91ae9da885b3012d15749a9fc5b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@NotNull\n    @Override\n    public List<ReceiverDescriptor> getVariantsForReceiver(@NotNull ReceiverDescriptor receiverDescriptor) {\n        return AutoCastUtils.getAutoCastVariants(bindingContext, dataFlowInfo, receiverDescriptor);\n    }","id":31904,"modified_method":"@NotNull\n    @Override\n    public List<ReceiverDescriptor> getVariantsForReceiver(@NotNull ReceiverDescriptor receiverDescriptor) {\n        List<ReceiverDescriptor> variants = Lists.newArrayList(AutoCastUtils.getAutoCastVariants(bindingContext, dataFlowInfo, receiverDescriptor));\n        variants.add(receiverDescriptor);\n        return variants;\n    }","commit_id":"8a93421ecbe35887c7c001e1dd1759c0e1d014b5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static List<ReceiverDescriptor> getAutoCastVariants(@NotNull final BindingContext bindingContext, @NotNull final DataFlowInfo dataFlowInfo, @NotNull ReceiverDescriptor receiverToCast) {\n        return receiverToCast.accept(new ReceiverDescriptorVisitor<List<ReceiverDescriptor>, Object>() {\n            @Override\n            public List<ReceiverDescriptor> visitNoReceiver(ReceiverDescriptor noReceiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitTransientReceiver(TransientReceiver receiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitExtensionReceiver(ExtensionReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitClassReceiver(ClassReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitExpressionReceiver(ExpressionReceiver receiver, Object data) {\n//                JetExpression expression = receiver.getExpression();\n//                VariableDescriptor variableDescriptor = DataFlowValueFactory.getVariableDescriptorFromSimpleName(bindingContext, expression);\n//                if (variableDescriptor != null) {\n//                    List<ReceiverDescriptor> result = Lists.newArrayList();\n//                    for (JetType possibleType : dataFlowInfo.getPossibleTypesForVariable(variableDescriptor)) {\n//                        result.add(new AutoCastReceiver(receiver, possibleType, DataFlowValueFactory.isStableVariable(variableDescriptor)));\n//                    }\n//                    return result;\n//                }\n//                else if (expression instanceof JetThisExpression) {\n//                    return castThis(dataFlowInfo, receiver);\n//                }\n                DataFlowValue dataFlowValue = DataFlowValueFactory.INSTANCE.createDataFlowValue(receiver.getExpression(),receiver.getType(), bindingContext);\n                List<ReceiverDescriptor> result = Lists.newArrayList();\n                for (JetType possibleType : dataFlowInfo.getPossibleTypes(dataFlowValue)) {\n                    result.add(new AutoCastReceiver(receiver, possibleType, dataFlowValue.isStableIdentifier()));\n                }\n                return result;\n            }\n        }, null);\n    }","id":31905,"modified_method":"/**\n     * @return variants @param receiverToCast may be cast to according to @param dataFlowInfo, @param receiverToCast itself is NOT included\n     */\n    public static List<ReceiverDescriptor> getAutoCastVariants(@NotNull final BindingContext bindingContext, @NotNull final DataFlowInfo dataFlowInfo, @NotNull ReceiverDescriptor receiverToCast) {\n        return receiverToCast.accept(new ReceiverDescriptorVisitor<List<ReceiverDescriptor>, Object>() {\n            @Override\n            public List<ReceiverDescriptor> visitNoReceiver(ReceiverDescriptor noReceiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitTransientReceiver(TransientReceiver receiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitExtensionReceiver(ExtensionReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitClassReceiver(ClassReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<ReceiverDescriptor> visitExpressionReceiver(ExpressionReceiver receiver, Object data) {\n//                JetExpression expression = receiver.getExpression();\n//                VariableDescriptor variableDescriptor = DataFlowValueFactory.getVariableDescriptorFromSimpleName(bindingContext, expression);\n//                if (variableDescriptor != null) {\n//                    List<ReceiverDescriptor> result = Lists.newArrayList();\n//                    for (JetType possibleType : dataFlowInfo.getPossibleTypesForVariable(variableDescriptor)) {\n//                        result.add(new AutoCastReceiver(receiver, possibleType, DataFlowValueFactory.isStableVariable(variableDescriptor)));\n//                    }\n//                    return result;\n//                }\n//                else if (expression instanceof JetThisExpression) {\n//                    return castThis(dataFlowInfo, receiver);\n//                }\n                DataFlowValue dataFlowValue = DataFlowValueFactory.INSTANCE.createDataFlowValue(receiver.getExpression(),receiver.getType(), bindingContext);\n                List<ReceiverDescriptor> result = Lists.newArrayList();\n                for (JetType possibleType : dataFlowInfo.getPossibleTypes(dataFlowValue)) {\n                    result.add(new AutoCastReceiver(receiver, possibleType, dataFlowValue.isStableIdentifier()));\n                }\n                return result;\n            }\n        }, null);\n    }","commit_id":"8a93421ecbe35887c7c001e1dd1759c0e1d014b5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public DataFlowInfo disequate(@NotNull DataFlowValue a, @NotNull DataFlowValue b) {\n        Map<DataFlowValue, Nullability> builder = Maps.newHashMap(nullabilityInfo);\n        Nullability nullabilityOfA = getNullability(a);\n        Nullability nullabilityOfB = getNullability(b);\n\n        boolean changed = false;\n        changed |= putNullability(builder, a, nullabilityOfA.refine(nullabilityOfB.invert()));\n        changed |= putNullability(builder, b, nullabilityOfA.refine(nullabilityOfA.invert()));\n        return changed ? new DataFlowInfo(ImmutableMap.copyOf(builder), typeInfo) : this;\n    }","id":31906,"modified_method":"@NotNull\n    public DataFlowInfo disequate(@NotNull DataFlowValue a, @NotNull DataFlowValue b) {\n        Map<DataFlowValue, Nullability> builder = Maps.newHashMap(nullabilityInfo);\n        Nullability nullabilityOfA = getNullability(a);\n        Nullability nullabilityOfB = getNullability(b);\n\n        boolean changed = false;\n        changed |= putNullability(builder, a, nullabilityOfA.refine(nullabilityOfB.invert()));\n        changed |= putNullability(builder, b, nullabilityOfB.refine(nullabilityOfA.invert()));\n        return changed ? new DataFlowInfo(ImmutableMap.copyOf(builder), typeInfo) : this;\n    }","commit_id":"8a93421ecbe35887c7c001e1dd1759c0e1d014b5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public List<ResolutionTask<D>> computePrioritizedTasks(@NotNull JetScope scope, @NotNull Call call, @NotNull String name, @NotNull BindingContext bindingContext, @NotNull DataFlowInfo dataFlowInfo) {\n        List<ResolutionTask<D>> result = Lists.newArrayList();\n\n        ReceiverDescriptor explicitReceiver = call.getExplicitReceiver();\n        if (explicitReceiver.exists() && explicitReceiver.getType() instanceof NamespaceType) {\n            scope = explicitReceiver.getType().getMemberScope();\n            explicitReceiver = NO_RECEIVER;\n        }\n        doComputeTasks(scope, explicitReceiver, call, name, result, AutoCastService.NO_AUTO_CASTS);\n\n        List<ReceiverDescriptor> receivers;\n        if (explicitReceiver.exists()) {\n            receivers = Collections.singletonList(explicitReceiver);\n        }\n        else {\n            receivers = Lists.newArrayList();\n            scope.getImplicitReceiversHierarchy(receivers);\n        }\n        for (ReceiverDescriptor receiverToCast : receivers) {\n            assert receiverToCast.exists();\n            doComputeTasks(scope, receiverToCast, call, name, result, new AutoCastServiceImpl(dataFlowInfo, bindingContext));\n        }\n        return result;\n    }","id":31907,"modified_method":"public List<ResolutionTask<D>> computePrioritizedTasks(@NotNull JetScope scope, @NotNull Call call, @NotNull String name, @NotNull BindingContext bindingContext, @NotNull DataFlowInfo dataFlowInfo) {\n        List<ResolutionTask<D>> result = Lists.newArrayList();\n\n        ReceiverDescriptor explicitReceiver = call.getExplicitReceiver();\n        if (explicitReceiver.exists() && explicitReceiver.getType() instanceof NamespaceType) {\n            scope = explicitReceiver.getType().getMemberScope();\n            explicitReceiver = NO_RECEIVER;\n        }\n        doComputeTasks(scope, explicitReceiver, call, name, result, new AutoCastServiceImpl(dataFlowInfo, bindingContext));\n\n        return result;\n    }","commit_id":"8a93421ecbe35887c7c001e1dd1759c0e1d014b5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static List<? extends ReceiverDescriptor> getAutocastVariants(@NotNull final BindingContext bindingContext, @NotNull final DataFlowInfo dataFlowInfo, @NotNull ReceiverDescriptor receiverToCast) {\n        return receiverToCast.accept(new ReceiverDescriptorVisitor<List<? extends ReceiverDescriptor>, Object>() {\n            @Override\n            public List<? extends ReceiverDescriptor> visitNoReceiver(ReceiverDescriptor noReceiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitTransientReceiver(TransientReceiver receiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitExtensionReceiver(ExtensionReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitClassReceiver(ClassReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitExpressionReceiver(ExpressionReceiver receiver, Object data) {\n                JetExpression expression = receiver.getExpression();\n                VariableDescriptor variableDescriptor = getVariableDescriptorFromSimpleName(bindingContext, expression);\n                if (variableDescriptor != null && isAutocastable(variableDescriptor)) {\n                    List<ReceiverDescriptor> result = Lists.newArrayList();\n                    for (JetType possibleType : dataFlowInfo.getPossibleTypesForVariable(variableDescriptor)) {\n                        result.add(new AutoCastReceiver(receiver, possibleType));\n                    }\n                    return result;\n                }\n                else if (expression instanceof JetThisExpression) {\n                    return castThis(dataFlowInfo, receiver);\n                }\n                return Collections.emptyList();\n            }\n        }, null);\n    }","id":31908,"modified_method":"public static List<? extends ReceiverDescriptor> getAutoCastVariants(@NotNull final BindingContext bindingContext, @NotNull final DataFlowInfo dataFlowInfo, @NotNull ReceiverDescriptor receiverToCast) {\n        return receiverToCast.accept(new ReceiverDescriptorVisitor<List<? extends ReceiverDescriptor>, Object>() {\n            @Override\n            public List<? extends ReceiverDescriptor> visitNoReceiver(ReceiverDescriptor noReceiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitTransientReceiver(TransientReceiver receiver, Object data) {\n                return Collections.emptyList();\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitExtensionReceiver(ExtensionReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitClassReceiver(ClassReceiver receiver, Object data) {\n                return castThis(dataFlowInfo, receiver);\n            }\n\n            @Override\n            public List<? extends ReceiverDescriptor> visitExpressionReceiver(ExpressionReceiver receiver, Object data) {\n                JetExpression expression = receiver.getExpression();\n                VariableDescriptor variableDescriptor = getVariableDescriptorFromSimpleName(bindingContext, expression);\n                if (variableDescriptor != null && isAutocastable(variableDescriptor)) {\n                    List<ReceiverDescriptor> result = Lists.newArrayList();\n                    for (JetType possibleType : dataFlowInfo.getPossibleTypesForVariable(variableDescriptor)) {\n                        result.add(new AutoCastReceiver(receiver, possibleType));\n                    }\n                    return result;\n                }\n                else if (expression instanceof JetThisExpression) {\n                    return castThis(dataFlowInfo, receiver);\n                }\n                return Collections.emptyList();\n            }\n        }, null);\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private List<FunctionDescriptor> findCandidatesByExactSignature(JetScope scope, ReceiverDescriptor receiver, String name, List<JetType> parameterTypes) {\n        List<FunctionDescriptor> result = Lists.newArrayList();\n        if (receiver.exists()) {\n            Set<FunctionDescriptor> extensionFunctionDescriptors = scope.getFunctions(name);\n            List<FunctionDescriptor> nonlocal = Lists.newArrayList();\n            List<FunctionDescriptor> local = Lists.newArrayList();\n            TaskPrioritizer.splitLexicallyLocalDescriptors(extensionFunctionDescriptors, scope.getContainingDeclaration(), local, nonlocal);\n\n\n            if (findExtensionFunctions(local, receiver, parameterTypes, result)) {\n                return result;\n            }\n\n            Set<FunctionDescriptor> functionDescriptors = receiver.getType().getMemberScope().getFunctions(name);\n            if (lookupExactSignature(functionDescriptors, parameterTypes, result)) {\n                return result;\n\n            }\n            findExtensionFunctions(nonlocal, receiver, parameterTypes, result);\n            return result;\n        }\n        else {\n            lookupExactSignature(scope.getFunctions(name), parameterTypes, result);\n            return result;\n        }\n    }","id":31909,"modified_method":"private List<ResolvedCall<FunctionDescriptor>> findCandidatesByExactSignature(JetScope scope, ReceiverDescriptor receiver, String name, List<JetType> parameterTypes) {\n        List<ResolvedCall<FunctionDescriptor>> result = Lists.newArrayList();\n        if (receiver.exists()) {\n            Collection<ResolvedCall<FunctionDescriptor>> extensionFunctionDescriptors = ResolvedCall.convertCollection(scope.getFunctions(name));\n            List<ResolvedCall<FunctionDescriptor>> nonlocal = Lists.newArrayList();\n            List<ResolvedCall<FunctionDescriptor>> local = Lists.newArrayList();\n            TaskPrioritizer.splitLexicallyLocalDescriptors(extensionFunctionDescriptors, scope.getContainingDeclaration(), local, nonlocal);\n\n\n            if (findExtensionFunctions(local, receiver, parameterTypes, result)) {\n                return result;\n            }\n\n            Collection<ResolvedCall<FunctionDescriptor>> functionDescriptors = ResolvedCall.convertCollection(receiver.getType().getMemberScope().getFunctions(name));\n            if (lookupExactSignature(functionDescriptors, parameterTypes, result)) {\n                return result;\n\n            }\n            findExtensionFunctions(nonlocal, receiver, parameterTypes, result);\n            return result;\n        }\n        else {\n            lookupExactSignature(ResolvedCall.convertCollection(scope.getFunctions(name)), parameterTypes, result);\n            return result;\n        }\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public OverloadResolutionResults<FunctionDescriptor> resolveExactSignature(@NotNull JetScope scope, @NotNull ReceiverDescriptor receiver, @NotNull String name, @NotNull List<JetType> parameterTypes) {\n        List<FunctionDescriptor> result = findCandidatesByExactSignature(scope, receiver, name, parameterTypes);\n\n        BindingTraceContext trace = new BindingTraceContext();\n        TemporaryBindingTrace temporaryBindingTrace = TemporaryBindingTrace.create(trace);\n        Set<ResolvedCall<FunctionDescriptor>> candidates = Sets.newLinkedHashSet();\n        for (FunctionDescriptor functionDescriptor : result) {\n            ResolvedCall<FunctionDescriptor> resolvedCall = ResolvedCall.create(functionDescriptor);\n            candidates.add(resolvedCall.setResultingDescriptor(functionDescriptor));\n            resolvedCall.setTrace(temporaryBindingTrace);\n        }\n        return computeResultAndReportErrors(trace, TracingStrategy.EMPTY, candidates, Collections.<ResolvedCall<FunctionDescriptor>>emptySet(), Collections.<ResolvedCall<FunctionDescriptor>>emptySet());\n    }","id":31910,"modified_method":"@NotNull\n    public OverloadResolutionResults<FunctionDescriptor> resolveExactSignature(@NotNull JetScope scope, @NotNull ReceiverDescriptor receiver, @NotNull String name, @NotNull List<JetType> parameterTypes) {\n        List<ResolvedCall<FunctionDescriptor>> result = findCandidatesByExactSignature(scope, receiver, name, parameterTypes);\n\n        BindingTraceContext trace = new BindingTraceContext();\n        TemporaryBindingTrace temporaryBindingTrace = TemporaryBindingTrace.create(trace);\n        Set<ResolvedCall<FunctionDescriptor>> candidates = Sets.newLinkedHashSet();\n        for (ResolvedCall<FunctionDescriptor> call : result) {\n            call.setTrace(temporaryBindingTrace);\n            candidates.add(call);\n        }\n        return computeResultAndReportErrors(trace, TracingStrategy.EMPTY, candidates, Collections.<ResolvedCall<FunctionDescriptor>>emptySet(), Collections.<ResolvedCall<FunctionDescriptor>>emptySet());\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor> boolean checkReceiverAbsence(ResolutionTask<D> task, TracingStrategy tracing, D candidate, TemporaryBindingTrace temporaryTrace) {\n        ReceiverDescriptor receiver = task.getReceiver();\n        ReceiverDescriptor candidateReceiver = candidate.getReceiver();\n        if (receiver.exists()) {\n            if (!candidateReceiver.exists()) {\n                tracing.noReceiverAllowed(temporaryTrace);\n                return false;\n            }\n        }\n        else if (candidateReceiver.exists()) {\n            tracing.missingReceiver(temporaryTrace, candidateReceiver);\n            return false;\n        }\n        return true;\n    }","id":31911,"modified_method":"private <D extends CallableDescriptor> boolean checkReceiverAbsence(ResolvedCall<D> resolvedCall, TracingStrategy tracing, D candidate, TemporaryBindingTrace temporaryTrace) {\n        ReceiverDescriptor receiver = resolvedCall.getReceiverParameter();\n        ReceiverDescriptor candidateReceiver = candidate.getReceiver();\n        if (receiver.exists()) {\n            if (!candidateReceiver.exists()) {\n                tracing.noReceiverAllowed(temporaryTrace);\n                return false;\n            }\n        }\n        else if (candidateReceiver.exists()) {\n            tracing.missingReceiver(temporaryTrace, candidateReceiver);\n            return false;\n        }\n        return true;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor> boolean checkReceiver(ResolutionTask<D> task, TracingStrategy tracing, D candidate, TemporaryBindingTrace temporaryTrace) {\n        if (!checkReceiverAbsence(task, tracing, candidate, temporaryTrace)) return false;\n        ReceiverDescriptor receiver = task.getReceiver();\n        ReceiverDescriptor candidateReceiver = candidate.getReceiver();\n        if (receiver.exists()\n                && candidateReceiver.exists()\n                && !semanticServices.getTypeChecker().isSubtypeOf(receiver.getType(), candidateReceiver.getType())) {\n            tracing.missingReceiver(temporaryTrace, candidateReceiver);\n            return false;\n        }\n        return true;\n    }","id":31912,"modified_method":"private <D extends CallableDescriptor> boolean checkReceiver(ResolvedCall<D> resolvedCall, TracingStrategy tracing, D candidate, TemporaryBindingTrace temporaryTrace) {\n        if (!checkReceiverAbsence(resolvedCall, tracing, candidate, temporaryTrace)) return false;\n        ReceiverDescriptor receiver = resolvedCall.getReceiverParameter();\n        ReceiverDescriptor candidateReceiver = candidate.getReceiver();\n        if (receiver.exists()\n                && candidateReceiver.exists()\n                && !semanticServices.getTypeChecker().isSubtypeOf(receiver.getType(), candidateReceiver.getType())) {\n            tracing.missingReceiver(temporaryTrace, candidateReceiver);\n            return false;\n        }\n        return true;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean findExtensionFunctions(Collection<FunctionDescriptor> candidates, ReceiverDescriptor receiver, List<JetType> parameterTypes, List<FunctionDescriptor> result) {\n        boolean found = false;\n        for (FunctionDescriptor functionDescriptor : candidates) {\n            ReceiverDescriptor functionReceiver = functionDescriptor.getReceiver();\n            if (!functionReceiver.exists()) continue;\n            if (!functionDescriptor.getTypeParameters().isEmpty()) continue;\n            if (!semanticServices.getTypeChecker().isSubtypeOf(receiver.getType(), functionReceiver.getType())) continue;\n            if (!checkValueParameters(functionDescriptor, parameterTypes))continue;\n            result.add(functionDescriptor);\n            found = true;\n        }\n        return found;\n    }","id":31913,"modified_method":"private boolean findExtensionFunctions(Collection<ResolvedCall<FunctionDescriptor>> candidates, ReceiverDescriptor receiver, List<JetType> parameterTypes, List<ResolvedCall<FunctionDescriptor>> result) {\n        boolean found = false;\n        for (ResolvedCall<FunctionDescriptor> resolvedCall : candidates) {\n            FunctionDescriptor functionDescriptor = resolvedCall.getResultingDescriptor();\n            ReceiverDescriptor functionReceiver = functionDescriptor.getReceiver();\n            if (!functionReceiver.exists()) continue;\n            if (!functionDescriptor.getTypeParameters().isEmpty()) continue;\n            if (!semanticServices.getTypeChecker().isSubtypeOf(receiver.getType(), functionReceiver.getType())) continue;\n            if (!checkValueParameters(functionDescriptor, parameterTypes))continue;\n            result.add(resolvedCall);\n            found = true;\n        }\n        return found;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean lookupExactSignature(Set<FunctionDescriptor> candidates, List<JetType> parameterTypes, List<FunctionDescriptor> result) {\n        boolean found = false;\n        for (FunctionDescriptor functionDescriptor : candidates) {\n            if (functionDescriptor.getReceiver().exists()) continue;\n            if (!functionDescriptor.getTypeParameters().isEmpty()) continue;\n            if (!checkValueParameters(functionDescriptor, parameterTypes)) continue;\n            result.add(functionDescriptor);\n            found = true;\n        }\n        return found;\n    }","id":31914,"modified_method":"private boolean lookupExactSignature(Collection<ResolvedCall<FunctionDescriptor>> candidates, List<JetType> parameterTypes, List<ResolvedCall<FunctionDescriptor>> result) {\n        boolean found = false;\n        for (ResolvedCall<FunctionDescriptor> resolvedCall : candidates) {\n            FunctionDescriptor functionDescriptor = resolvedCall.getResultingDescriptor();\n            if (functionDescriptor.getReceiver().exists()) continue;\n            if (!functionDescriptor.getTypeParameters().isEmpty()) continue;\n            if (!checkValueParameters(functionDescriptor, parameterTypes)) continue;\n            result.add(resolvedCall);\n            found = true;\n        }\n        return found;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private <D extends CallableDescriptor> OverloadResolutionResults<D> performResolution(@NotNull BindingTrace trace, @NotNull JetScope scope, @NotNull JetType expectedType, @NotNull ResolutionTask<D> task, @NotNull TracingStrategy tracing) {\n        Set<ResolvedCall<D>> successfulCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCall<D>> failedCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCall<D>> dirtyCandidates = Sets.newLinkedHashSet();\n\n        for (ResolvedCall<D> candidateCall : task.getCandidates()) {\n            D candidate = candidateCall.getCandidateDescriptor();\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            candidateCall.setTrace(temporaryTrace);\n\n            tracing.bindReference(temporaryTrace, task.getReceiver(), candidate);\n            \n            if (ErrorUtils.isError(candidate)) {\n                successfulCandidates.add(candidateCall.setResultingDescriptor(candidate));\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getTypeArguments(), task.getValueArguments(), task.getFunctionLiteralArguments());\n                continue;\n            }\n\n\n            Map<ValueArgument, ValueParameterDescriptor> argumentsToParameters = Maps.newHashMap();\n            boolean error = ValueArgumentsToParametersMapper.mapValueArgumentsToParameters(task, tracing, candidate, temporaryTrace, argumentsToParameters);\n\n            if (error) {\n                failedCandidates.add(candidateCall);\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getTypeArguments(), task.getValueArguments(), task.getFunctionLiteralArguments());\n                continue;\n            }\n\n            Ref<Boolean> dirty = new Ref<Boolean>(false);\n            if (task.getTypeArguments().isEmpty()) {\n                if (candidate.getTypeParameters().isEmpty()) {\n                    if (checkValueArgumentTypes(scope, temporaryTrace, argumentsToParameters, dirty, Functions.<ValueParameterDescriptor>identity())\n                            && checkReceiver(task, tracing, candidate, temporaryTrace)) {\n                        successfulCandidates.add(candidateCall.setResultingDescriptor(candidate));\n                    }\n                    else {\n                        failedCandidates.add(candidateCall);\n                    }\n                }\n                else {\n                    // Type argument inference\n\n                    ConstraintSystem constraintSystem = new ConstraintSystem();\n                    for (TypeParameterDescriptor typeParameterDescriptor : candidate.getTypeParameters()) {\n                        constraintSystem.registerTypeVariable(typeParameterDescriptor, Variance.INVARIANT); // TODO\n                    }\n\n                    for (Map.Entry<ValueArgument, ValueParameterDescriptor> entry : argumentsToParameters.entrySet()) {\n                        ValueArgument valueArgument = entry.getKey();\n                        ValueParameterDescriptor valueParameterDescriptor = entry.getValue();\n\n                        JetExpression expression = valueArgument.getArgumentExpression();\n                        // TODO : more attempts, with different expected types\n                        JetTypeInferrer.Services temporaryServices = typeInferrer.getServices(temporaryTrace);\n                        JetType type = temporaryServices.getType(scope, expression, NO_EXPECTED_TYPE);\n                        if (type != null) {\n                            constraintSystem.addSubtypingConstraint(type, valueParameterDescriptor.getOutType());\n                        }\n                        else {\n                            dirty.set(true);\n                        }\n                    }\n\n                    checkReceiverAbsence(task, tracing, candidate, temporaryTrace);\n                    // Error is already reported if something is missing\n                    ReceiverDescriptor receiver = task.getReceiver();\n                    ReceiverDescriptor candidateReceiver = candidate.getReceiver();\n                    if (receiver.exists() && candidateReceiver.exists()) {\n                        constraintSystem.addSubtypingConstraint(receiver.getType(), candidateReceiver.getType());\n                    }\n\n                    if (expectedType != NO_EXPECTED_TYPE) {\n                        constraintSystem.addSubtypingConstraint(candidate.getReturnType(), expectedType);\n                    }\n\n                    ConstraintSystem.Solution solution = constraintSystem.solve();\n//                    solutions.put(candidate, solution);\n                    if (solution.isSuccessful()) {\n                        D substitute = (D) candidate.substitute(solution.getSubstitutor());\n                        assert substitute != null;\n                        successfulCandidates.add(candidateCall.setResultingDescriptor(substitute));\n                    }\n                    else {\n                        tracing.typeInferenceFailed(temporaryTrace);\n                        failedCandidates.add(candidateCall);\n                    }\n                }\n            }\n            else {\n                // Explicit type arguments passed\n\n                final List<JetTypeProjection> jetTypeArguments = task.getTypeArguments();\n\n                for (JetTypeProjection typeArgument : jetTypeArguments) {\n                    if (typeArgument.getProjectionKind() != JetProjectionKind.NONE) {\n//                        temporaryTrace.getErrorHandler().genericError(typeArgument.getNode(), \"Projections are not allowed on type parameters for methods\"); // TODO : better positioning\n                        temporaryTrace.report(PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT.on(typeArgument));\n                    }\n                }\n\n                int expectedTypeArgumentCount = candidate.getTypeParameters().size();\n                if (expectedTypeArgumentCount == jetTypeArguments.size()) {\n                    List<JetType> typeArguments = new ArrayList<JetType>();\n                    for (JetTypeProjection projection : jetTypeArguments) {\n                        // TODO : check that there's no projection\n                        JetTypeReference typeReference = projection.getTypeReference();\n                        if (typeReference != null) {\n                            typeArguments.add(new TypeResolver(semanticServices, temporaryTrace, true).resolveType(scope, typeReference));\n                        }\n                    }\n\n                    checkGenericBoundsInAFunctionCall(jetTypeArguments, typeArguments, candidate, temporaryTrace);\n\n                    Map<TypeConstructor, TypeProjection> substitutionContext = FunctionDescriptorUtil.createSubstitutionContext((FunctionDescriptor) candidate, typeArguments);\n                    D substitutedFunctionDescriptor = (D) candidate.substitute(TypeSubstitutor.create(substitutionContext));\n\n                    Function<ValueParameterDescriptor, ValueParameterDescriptor> mapFunction = createMapFunction(substitutedFunctionDescriptor);\n                    if (checkValueArgumentTypes(scope, temporaryTrace, argumentsToParameters, dirty, mapFunction)\n                            && checkReceiver(task, tracing, substitutedFunctionDescriptor, temporaryTrace)) {\n                        successfulCandidates.add(candidateCall.setResultingDescriptor(substitutedFunctionDescriptor));\n                    }\n                    else {\n                        failedCandidates.add(candidateCall);\n                    }\n                }\n                else {\n                    failedCandidates.add(candidateCall);\n//                    tracing.reportWrongTypeArguments(temporaryTrace, \"Number of type arguments does not match \" + DescriptorRenderer.TEXT.render(candidate));\n                    tracing.wrongNumberOfTypeArguments(temporaryTrace, expectedTypeArgumentCount);\n                }\n            }\n            \n            if (dirty.get()) {\n                dirtyCandidates.add(candidateCall);\n            }\n            task.performAdvancedChecks(candidate, temporaryTrace, tracing);\n        }\n\n        OverloadResolutionResults<D> results = computeResultAndReportErrors(trace, tracing, successfulCandidates, failedCandidates, dirtyCandidates);\n        if (!results.singleDescriptor()) {\n            checkTypesWithNoCallee(trace, scope, task.getTypeArguments(), task.getValueArguments(), task.getFunctionLiteralArguments());\n        }\n        return results;\n    }","id":31915,"modified_method":"@NotNull\n    private <D extends CallableDescriptor> OverloadResolutionResults<D> performResolution(@NotNull BindingTrace trace, @NotNull JetScope scope, @NotNull JetType expectedType, @NotNull ResolutionTask<D> task, @NotNull TracingStrategy tracing) {\n        Set<ResolvedCall<D>> successfulCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCall<D>> failedCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCall<D>> dirtyCandidates = Sets.newLinkedHashSet();\n\n        for (ResolvedCall<D> candidateCall : task.getCandidates()) {\n            D candidate = candidateCall.getCandidateDescriptor();\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            candidateCall.setTrace(temporaryTrace);\n\n            tracing.bindReference(temporaryTrace, candidateCall);\n            \n            if (ErrorUtils.isError(candidate)) {\n                successfulCandidates.add(candidateCall.setResultingDescriptor(candidate));\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getTypeArguments(), task.getValueArguments(), task.getFunctionLiteralArguments());\n                continue;\n            }\n\n\n            Map<ValueArgument, ValueParameterDescriptor> argumentsToParameters = Maps.newHashMap();\n            boolean error = ValueArgumentsToParametersMapper.mapValueArgumentsToParameters(task, tracing, candidate, temporaryTrace, argumentsToParameters);\n\n            if (error) {\n                failedCandidates.add(candidateCall);\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getTypeArguments(), task.getValueArguments(), task.getFunctionLiteralArguments());\n                continue;\n            }\n\n            Ref<Boolean> dirty = new Ref<Boolean>(false);\n            if (task.getTypeArguments().isEmpty()) {\n                if (candidate.getTypeParameters().isEmpty()) {\n                    if (checkValueArgumentTypes(scope, temporaryTrace, argumentsToParameters, dirty, Functions.<ValueParameterDescriptor>identity())\n                            && checkReceiver(candidateCall, tracing, candidate, temporaryTrace)) {\n                        successfulCandidates.add(candidateCall.setResultingDescriptor(candidate));\n                    }\n                    else {\n                        failedCandidates.add(candidateCall);\n                    }\n                }\n                else {\n                    // Type argument inference\n\n                    ConstraintSystem constraintSystem = new ConstraintSystem();\n                    for (TypeParameterDescriptor typeParameterDescriptor : candidate.getTypeParameters()) {\n                        constraintSystem.registerTypeVariable(typeParameterDescriptor, Variance.INVARIANT); // TODO\n                    }\n\n                    for (Map.Entry<ValueArgument, ValueParameterDescriptor> entry : argumentsToParameters.entrySet()) {\n                        ValueArgument valueArgument = entry.getKey();\n                        ValueParameterDescriptor valueParameterDescriptor = entry.getValue();\n\n                        JetExpression expression = valueArgument.getArgumentExpression();\n                        // TODO : more attempts, with different expected types\n                        JetTypeInferrer.Services temporaryServices = typeInferrer.getServices(temporaryTrace);\n                        JetType type = temporaryServices.getType(scope, expression, NO_EXPECTED_TYPE);\n                        if (type != null) {\n                            constraintSystem.addSubtypingConstraint(type, valueParameterDescriptor.getOutType());\n                        }\n                        else {\n                            dirty.set(true);\n                        }\n                    }\n\n                    checkReceiverAbsence(candidateCall, tracing, candidate, temporaryTrace);\n                    // Error is already reported if something is missing\n                    ReceiverDescriptor receiverParameter = candidateCall.getReceiverParameter();\n                    ReceiverDescriptor candidateReceiver = candidate.getReceiver();\n                    if (receiverParameter.exists() && candidateReceiver.exists()) {\n                        constraintSystem.addSubtypingConstraint(receiverParameter.getType(), candidateReceiver.getType());\n                    }\n\n                    if (expectedType != NO_EXPECTED_TYPE) {\n                        constraintSystem.addSubtypingConstraint(candidate.getReturnType(), expectedType);\n                    }\n\n                    ConstraintSystem.Solution solution = constraintSystem.solve();\n//                    solutions.put(candidate, solution);\n                    if (solution.isSuccessful()) {\n                        D substitute = (D) candidate.substitute(solution.getSubstitutor());\n                        assert substitute != null;\n                        successfulCandidates.add(candidateCall.setResultingDescriptor(substitute));\n                    }\n                    else {\n                        tracing.typeInferenceFailed(temporaryTrace);\n                        failedCandidates.add(candidateCall);\n                    }\n                }\n            }\n            else {\n                // Explicit type arguments passed\n\n                final List<JetTypeProjection> jetTypeArguments = task.getTypeArguments();\n\n                for (JetTypeProjection typeArgument : jetTypeArguments) {\n                    if (typeArgument.getProjectionKind() != JetProjectionKind.NONE) {\n//                        temporaryTrace.getErrorHandler().genericError(typeArgument.getNode(), \"Projections are not allowed on type parameters for methods\"); // TODO : better positioning\n                        temporaryTrace.report(PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT.on(typeArgument));\n                    }\n                }\n\n                int expectedTypeArgumentCount = candidate.getTypeParameters().size();\n                if (expectedTypeArgumentCount == jetTypeArguments.size()) {\n                    List<JetType> typeArguments = new ArrayList<JetType>();\n                    for (JetTypeProjection projection : jetTypeArguments) {\n                        // TODO : check that there's no projection\n                        JetTypeReference typeReference = projection.getTypeReference();\n                        if (typeReference != null) {\n                            typeArguments.add(new TypeResolver(semanticServices, temporaryTrace, true).resolveType(scope, typeReference));\n                        }\n                    }\n\n                    checkGenericBoundsInAFunctionCall(jetTypeArguments, typeArguments, candidate, temporaryTrace);\n\n                    Map<TypeConstructor, TypeProjection> substitutionContext = FunctionDescriptorUtil.createSubstitutionContext((FunctionDescriptor) candidate, typeArguments);\n                    D substitutedFunctionDescriptor = (D) candidate.substitute(TypeSubstitutor.create(substitutionContext));\n\n                    Function<ValueParameterDescriptor, ValueParameterDescriptor> mapFunction = createMapFunction(substitutedFunctionDescriptor);\n                    if (checkValueArgumentTypes(scope, temporaryTrace, argumentsToParameters, dirty, mapFunction)\n                            && checkReceiver(candidateCall, tracing, substitutedFunctionDescriptor, temporaryTrace)) {\n                        successfulCandidates.add(candidateCall.setResultingDescriptor(substitutedFunctionDescriptor));\n                    }\n                    else {\n                        failedCandidates.add(candidateCall);\n                    }\n                }\n                else {\n                    failedCandidates.add(candidateCall);\n//                    tracing.reportWrongTypeArguments(temporaryTrace, \"Number of type arguments does not match \" + DescriptorRenderer.TEXT.render(candidate));\n                    tracing.wrongNumberOfTypeArguments(temporaryTrace, expectedTypeArgumentCount);\n                }\n            }\n            \n            if (dirty.get()) {\n                dirtyCandidates.add(candidateCall);\n            }\n            task.performAdvancedChecks(candidate, temporaryTrace, tracing);\n\n            recordAutoCastIfNecessary(candidateCall.getReceiverParameter(), candidateCall.getTrace());\n            recordAutoCastIfNecessary(candidateCall.getThisObject(), candidateCall.getTrace());\n        }\n\n        OverloadResolutionResults<D> results = computeResultAndReportErrors(trace, tracing, successfulCandidates, failedCandidates, dirtyCandidates);\n        if (!results.singleDescriptor()) {\n            checkTypesWithNoCallee(trace, scope, task.getTypeArguments(), task.getValueArguments(), task.getFunctionLiteralArguments());\n        }\n        return results;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public FunctionDescriptor resolveSimpleCallToFunctionDescriptor(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull ReceiverDescriptor receiver,\n            @NotNull final JetCallElement call,\n            @NotNull JetType expectedType\n    ) {\n        List<ResolutionTask<FunctionDescriptor>> prioritizedTasks;\n        \n        JetExpression calleeExpression = call.getCalleeExpression();\n        final JetReferenceExpression functionReference;\n        if (calleeExpression instanceof JetSimpleNameExpression) {\n            JetSimpleNameExpression expression = (JetSimpleNameExpression) calleeExpression;\n            functionReference = expression;\n\n            String name = expression.getReferencedName();\n            if (name == null) return checkArgumentTypesAndFail(trace, scope, call);\n\n            prioritizedTasks = TaskPrioritizers.FUNCTION_TASK_PRIORITIZER.computePrioritizedTasks(scope, receiver, call, name, trace.getBindingContext(), dataFlowInfo);\n            ResolutionTask.DescriptorCheckStrategy abstractConstructorCheck = new ResolutionTask.DescriptorCheckStrategy() {\n                @Override\n                public <D extends CallableDescriptor> boolean performAdvancedChecks(D descriptor, BindingTrace trace, TracingStrategy tracing) {\n                    if (descriptor instanceof ConstructorDescriptor) {\n                        Modality modality = ((ConstructorDescriptor) descriptor).getContainingDeclaration().getModality();\n                        if (modality == Modality.ABSTRACT) {\n//                            tracing.reportOverallResolutionError(trace, \"Can not create an instance of an abstract class\");\n                            tracing.instantiationOfAbstractClass(trace);\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            };\n            for (ResolutionTask task : prioritizedTasks) {\n                task.setCheckingStrategy(abstractConstructorCheck);\n            }\n        }\n        else {\n            JetValueArgumentList valueArgumentList = call.getValueArgumentList();\n            ASTNode reportAbsenceOn = valueArgumentList == null ? call.getNode() : valueArgumentList.getNode();\n            if (calleeExpression instanceof JetConstructorCalleeExpression) {\n                assert !receiver.exists();\n\n                prioritizedTasks = Lists.newArrayList();\n\n                JetConstructorCalleeExpression expression = (JetConstructorCalleeExpression) calleeExpression;\n                functionReference = expression.getConstructorReferenceExpression();\n                if (functionReference == null) {\n                    return checkArgumentTypesAndFail(trace, scope, call); // No type there\n                }\n                JetTypeReference typeReference = expression.getTypeReference();\n                assert typeReference != null;\n                JetType constructedType = new TypeResolver(semanticServices, trace, true).resolveType(scope, typeReference);\n                DeclarationDescriptor declarationDescriptor = constructedType.getConstructor().getDeclarationDescriptor();\n                if (declarationDescriptor instanceof ClassDescriptor) {\n                    ClassDescriptor classDescriptor = (ClassDescriptor) declarationDescriptor;\n                    Set<FunctionDescriptor> constructors = classDescriptor.getConstructors();\n                    if (constructors.isEmpty()) {\n//                        trace.getErrorHandler().genericError(reportAbsenceOn, \"This class does not have a constructor\");\n                        trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                        return checkArgumentTypesAndFail(trace, scope, call);\n                    }\n                    prioritizedTasks.add(new ResolutionTask<FunctionDescriptor>(ResolvedCall.convertCollection(constructors), NO_RECEIVER, call));\n                }\n                else {\n//                    trace.getErrorHandler().genericError(calleeExpression.getNode(), \"Not a class\");\n                    trace.report(NOT_A_CLASS.on(calleeExpression));\n                    return checkArgumentTypesAndFail(trace, scope, call);\n                }\n            }\n            else if (calleeExpression instanceof JetThisReferenceExpression) {\n                functionReference = (JetThisReferenceExpression) calleeExpression;\n                DeclarationDescriptor containingDeclaration = scope.getContainingDeclaration();\n                assert containingDeclaration instanceof ClassDescriptor;\n                ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n\n                Set<FunctionDescriptor> constructors = classDescriptor.getConstructors();\n                if (constructors.isEmpty()) {\n//                    trace.getErrorHandler().genericError(reportAbsenceOn, \"This class does not have a constructor\");\n                    trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                    return checkArgumentTypesAndFail(trace, scope, call);\n                }\n                prioritizedTasks = Collections.singletonList(new ResolutionTask<FunctionDescriptor>(ResolvedCall.convertCollection(constructors), NO_RECEIVER, call));\n            }\n            else {\n                throw new UnsupportedOperationException(\"Type argument inference not implemented for \" + call.getText());\n            }\n        }\n\n        return resolveCallToDescriptor(trace, scope, call, call.getNode(), expectedType, prioritizedTasks, functionReference);\n    }","id":31916,"modified_method":"@Nullable\n    public FunctionDescriptor resolveSimpleCallToFunctionDescriptor(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull ReceiverDescriptor receiver,\n            @NotNull final JetCallElement call,\n            @NotNull JetType expectedType\n    ) {\n        List<ResolutionTask<FunctionDescriptor>> prioritizedTasks;\n        \n        JetExpression calleeExpression = call.getCalleeExpression();\n        final JetReferenceExpression functionReference;\n        if (calleeExpression instanceof JetSimpleNameExpression) {\n            JetSimpleNameExpression expression = (JetSimpleNameExpression) calleeExpression;\n            functionReference = expression;\n\n            String name = expression.getReferencedName();\n            if (name == null) return checkArgumentTypesAndFail(trace, scope, call);\n\n            prioritizedTasks = TaskPrioritizers.FUNCTION_TASK_PRIORITIZER.computePrioritizedTasks(scope, receiver, call, name, trace.getBindingContext(), dataFlowInfo);\n            ResolutionTask.DescriptorCheckStrategy abstractConstructorCheck = new ResolutionTask.DescriptorCheckStrategy() {\n                @Override\n                public <D extends CallableDescriptor> boolean performAdvancedChecks(D descriptor, BindingTrace trace, TracingStrategy tracing) {\n                    if (descriptor instanceof ConstructorDescriptor) {\n                        Modality modality = ((ConstructorDescriptor) descriptor).getContainingDeclaration().getModality();\n                        if (modality == Modality.ABSTRACT) {\n//                            tracing.reportOverallResolutionError(trace, \"Can not create an instance of an abstract class\");\n                            tracing.instantiationOfAbstractClass(trace);\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            };\n            for (ResolutionTask task : prioritizedTasks) {\n                task.setCheckingStrategy(abstractConstructorCheck);\n            }\n        }\n        else {\n            JetValueArgumentList valueArgumentList = call.getValueArgumentList();\n            ASTNode reportAbsenceOn = valueArgumentList == null ? call.getNode() : valueArgumentList.getNode();\n            if (calleeExpression instanceof JetConstructorCalleeExpression) {\n                assert !receiver.exists();\n\n                prioritizedTasks = Lists.newArrayList();\n\n                JetConstructorCalleeExpression expression = (JetConstructorCalleeExpression) calleeExpression;\n                functionReference = expression.getConstructorReferenceExpression();\n                if (functionReference == null) {\n                    return checkArgumentTypesAndFail(trace, scope, call); // No type there\n                }\n                JetTypeReference typeReference = expression.getTypeReference();\n                assert typeReference != null;\n                JetType constructedType = new TypeResolver(semanticServices, trace, true).resolveType(scope, typeReference);\n                DeclarationDescriptor declarationDescriptor = constructedType.getConstructor().getDeclarationDescriptor();\n                if (declarationDescriptor instanceof ClassDescriptor) {\n                    ClassDescriptor classDescriptor = (ClassDescriptor) declarationDescriptor;\n                    Set<FunctionDescriptor> constructors = classDescriptor.getConstructors();\n                    if (constructors.isEmpty()) {\n//                        trace.getErrorHandler().genericError(reportAbsenceOn, \"This class does not have a constructor\");\n                        trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                        return checkArgumentTypesAndFail(trace, scope, call);\n                    }\n                    prioritizedTasks.add(new ResolutionTask<FunctionDescriptor>(ResolvedCall.convertCollection(constructors), call, DataFlowInfo.getEmpty()));\n                }\n                else {\n//                    trace.getErrorHandler().genericError(calleeExpression.getNode(), \"Not a class\");\n                    trace.report(NOT_A_CLASS.on(calleeExpression));\n                    return checkArgumentTypesAndFail(trace, scope, call);\n                }\n            }\n            else if (calleeExpression instanceof JetThisReferenceExpression) {\n                functionReference = (JetThisReferenceExpression) calleeExpression;\n                DeclarationDescriptor containingDeclaration = scope.getContainingDeclaration();\n                assert containingDeclaration instanceof ClassDescriptor;\n                ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n\n                Set<FunctionDescriptor> constructors = classDescriptor.getConstructors();\n                if (constructors.isEmpty()) {\n//                    trace.getErrorHandler().genericError(reportAbsenceOn, \"This class does not have a constructor\");\n                    trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                    return checkArgumentTypesAndFail(trace, scope, call);\n                }\n                prioritizedTasks = Collections.singletonList(new ResolutionTask<FunctionDescriptor>(ResolvedCall.convertCollection(constructors), call, DataFlowInfo.getEmpty()));\n            }\n            else {\n                throw new UnsupportedOperationException(\"Type argument inference not implemented for \" + call.getText());\n            }\n        }\n\n        return resolveCallToDescriptor(trace, scope, call, call.getNode(), expectedType, prioritizedTasks, functionReference);\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private <D extends CallableDescriptor> ResolvedCall<D> doResolveCall(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull final Call call,\n            @NotNull final ASTNode callNode,\n            @NotNull JetType expectedType,\n            @NotNull final List<ResolutionTask<D>> prioritizedTasks, // high to low priority\n            @NotNull final JetReferenceExpression reference) {\n        TemporaryBindingTrace traceForFirstNonemptyCandidateSet = null;\n        OverloadResolutionResults<D> resultsForFirstNonemptyCandidateSet = null;\n        TracingStrategy tracing = new TracingStrategy() {\n            @Override\n            public void bindReference(@NotNull BindingTrace trace, @NotNull ReceiverDescriptor receiver, @NotNull CallableDescriptor descriptor) {\n                trace.record(REFERENCE_TARGET, reference, descriptor);\n                trace.record(RECEIVER, reference, receiver);\n                if (receiver instanceof AutoCastReceiver) {\n                    AutoCastReceiver autoCastReceiver = (AutoCastReceiver) receiver;\n                    ReceiverDescriptor original = autoCastReceiver.getOriginal();\n                    if (original instanceof ExpressionReceiver) {\n                        ExpressionReceiver expressionReceiver = (ExpressionReceiver) original;\n                        trace.record(AUTOCAST, expressionReceiver.getExpression(), autoCastReceiver.getType());\n                    }\n                }\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void recordAmbiguity(BindingTrace trace, Collection<ResolvedCall<D>> candidates) {\n                trace.record(AMBIGUOUS_REFERENCE_TARGET, reference, candidates);\n            }\n\n            @Override\n            public void unresolvedReference(@NotNull BindingTrace trace) {\n                trace.report(UNRESOLVED_REFERENCE.on(reference));\n            }\n\n            @Override\n            public void noValueForParameter(@NotNull BindingTrace trace, @NotNull ValueParameterDescriptor valueParameter) {\n//                ASTNode node;\n//\n//                JetValueArgumentList valueArgumentList = call.getValueArgumentList();\n//                if (valueArgumentList != null) {\n//                    node = valueArgumentList.getNode();\n//                }\n//                else if (!call.getFunctionLiteralArguments().isEmpty()) {\n//                    node = call.getFunctionLiteralArguments().get(0).getNode();\n//                }\n//                else {\n//                    node = callNode;\n//                }\n//                trace.report(NO_VALUE_FOR_PARAMETER.on(node, valueParameter));\n                trace.report(NO_VALUE_FOR_PARAMETER.on(reference, valueParameter));\n            }\n\n            @Override\n            public void missingReceiver(@NotNull BindingTrace trace, @NotNull ReceiverDescriptor expectedReceiver) {\n                trace.report(MISSING_RECEIVER.on(reference, expectedReceiver.getType()));\n            }\n\n            @Override\n            public void noReceiverAllowed(@NotNull BindingTrace trace) {\n                trace.report(NO_RECEIVER_ADMITTED.on(reference));\n            }\n\n            @Override\n            public void wrongNumberOfTypeArguments(@NotNull BindingTrace trace, int expectedTypeArgumentCount) {\n                JetTypeArgumentList typeArgumentList = call.getTypeArgumentList();\n                if (typeArgumentList != null) {\n//                    trace.getErrorHandler().genericError(typeArgumentList.getNode(), message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(typeArgumentList, expectedTypeArgumentCount));\n                }\n                else {\n//                    reportOverallResolutionError(trace, message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reference, expectedTypeArgumentCount));\n                }\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void ambiguity(@NotNull BindingTrace trace, @NotNull Set<ResolvedCall<D>> descriptors) {\n                trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(callNode, descriptors));\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void noneApplicable(@NotNull BindingTrace trace, @NotNull Set<ResolvedCall<D>> descriptors) {\n                trace.report(NONE_APPLICABLE.on(callNode, descriptors));\n            }\n\n            @Override\n            public void instantiationOfAbstractClass(@NotNull BindingTrace trace) {\n                trace.report(CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS.on(callNode));\n            }\n\n            @Override\n            public void typeInferenceFailed(@NotNull BindingTrace trace) {\n                trace.report(TYPE_INFERENCE_FAILED.on(callNode));\n            }\n\n        };\n        for (ResolutionTask<D> task : prioritizedTasks) {\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            OverloadResolutionResults<D> results = performResolution(temporaryTrace, scope, expectedType, task, tracing);\n            if (results.isSuccess()) {\n                temporaryTrace.commit();\n                return results.getResult();\n            }\n            if (traceForFirstNonemptyCandidateSet == null && !task.getCandidates().isEmpty()) {\n                traceForFirstNonemptyCandidateSet = temporaryTrace;\n                resultsForFirstNonemptyCandidateSet = results;\n            }\n        }\n        if (traceForFirstNonemptyCandidateSet != null) {\n            traceForFirstNonemptyCandidateSet.commit();\n            if (resultsForFirstNonemptyCandidateSet.singleDescriptor()) {\n                return resultsForFirstNonemptyCandidateSet.getResult();\n            }\n        }\n        else {\n            trace.report(UNRESOLVED_REFERENCE.on(reference));\n            checkTypesWithNoCallee(trace, scope, call.getTypeArguments(), call.getValueArguments(), call.getFunctionLiteralArguments());\n        }\n        return null;\n    }","id":31917,"modified_method":"@Nullable\n    private <D extends CallableDescriptor> ResolvedCall<D> doResolveCall(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull final Call call,\n            @NotNull final ASTNode callNode,\n            @NotNull JetType expectedType,\n            @NotNull final List<ResolutionTask<D>> prioritizedTasks, // high to low priority\n            @NotNull final JetReferenceExpression reference) {\n        TemporaryBindingTrace traceForFirstNonemptyCandidateSet = null;\n        OverloadResolutionResults<D> resultsForFirstNonemptyCandidateSet = null;\n        TracingStrategy tracing = new TracingStrategy() {\n            @Override\n            public <D extends CallableDescriptor> void bindReference(@NotNull BindingTrace trace, @NotNull ResolvedCall<D> resolvedCall) {\n                D descriptor = resolvedCall.getCandidateDescriptor();\n//                if (descriptor instanceof VariableAsFunctionDescriptor) {\n//                    VariableAsFunctionDescriptor variableAsFunctionDescriptor = (VariableAsFunctionDescriptor) descriptor;\n//                    trace.record(REFERENCE_TARGET, reference, variableAsFunctionDescriptor.getVariableDescriptor());\n//                }\n//                else {\n                    trace.record(REFERENCE_TARGET, reference, descriptor);\n//                }\n                trace.record(RESOLVED_CALL, reference, resolvedCall);\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void recordAmbiguity(BindingTrace trace, Collection<ResolvedCall<D>> candidates) {\n                trace.record(AMBIGUOUS_REFERENCE_TARGET, reference, candidates);\n            }\n\n            @Override\n            public void unresolvedReference(@NotNull BindingTrace trace) {\n                trace.report(UNRESOLVED_REFERENCE.on(reference));\n            }\n\n            @Override\n            public void noValueForParameter(@NotNull BindingTrace trace, @NotNull ValueParameterDescriptor valueParameter) {\n//                ASTNode node;\n//\n//                JetValueArgumentList valueArgumentList = call.getValueArgumentList();\n//                if (valueArgumentList != null) {\n//                    node = valueArgumentList.getNode();\n//                }\n//                else if (!call.getFunctionLiteralArguments().isEmpty()) {\n//                    node = call.getFunctionLiteralArguments().get(0).getNode();\n//                }\n//                else {\n//                    node = callNode;\n//                }\n//                trace.report(NO_VALUE_FOR_PARAMETER.on(node, valueParameter));\n                trace.report(NO_VALUE_FOR_PARAMETER.on(reference, valueParameter));\n            }\n\n            @Override\n            public void missingReceiver(@NotNull BindingTrace trace, @NotNull ReceiverDescriptor expectedReceiver) {\n                trace.report(MISSING_RECEIVER.on(reference, expectedReceiver.getType()));\n            }\n\n            @Override\n            public void noReceiverAllowed(@NotNull BindingTrace trace) {\n                trace.report(NO_RECEIVER_ADMITTED.on(reference));\n            }\n\n            @Override\n            public void wrongNumberOfTypeArguments(@NotNull BindingTrace trace, int expectedTypeArgumentCount) {\n                JetTypeArgumentList typeArgumentList = call.getTypeArgumentList();\n                if (typeArgumentList != null) {\n//                    trace.getErrorHandler().genericError(typeArgumentList.getNode(), message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(typeArgumentList, expectedTypeArgumentCount));\n                }\n                else {\n//                    reportOverallResolutionError(trace, message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reference, expectedTypeArgumentCount));\n                }\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void ambiguity(@NotNull BindingTrace trace, @NotNull Set<ResolvedCall<D>> descriptors) {\n                trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(callNode, descriptors));\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void noneApplicable(@NotNull BindingTrace trace, @NotNull Set<ResolvedCall<D>> descriptors) {\n                trace.report(NONE_APPLICABLE.on(callNode, descriptors));\n            }\n\n            @Override\n            public void instantiationOfAbstractClass(@NotNull BindingTrace trace) {\n                trace.report(CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS.on(callNode));\n            }\n\n            @Override\n            public void typeInferenceFailed(@NotNull BindingTrace trace) {\n                trace.report(TYPE_INFERENCE_FAILED.on(callNode));\n            }\n\n        };\n        for (ResolutionTask<D> task : prioritizedTasks) {\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            OverloadResolutionResults<D> results = performResolution(temporaryTrace, scope, expectedType, task, tracing);\n            if (results.isSuccess()) {\n                temporaryTrace.commit();\n                return results.getResult();\n            }\n            if (traceForFirstNonemptyCandidateSet == null && !task.getCandidates().isEmpty()) {\n                traceForFirstNonemptyCandidateSet = temporaryTrace;\n                resultsForFirstNonemptyCandidateSet = results;\n            }\n        }\n        if (traceForFirstNonemptyCandidateSet != null) {\n            traceForFirstNonemptyCandidateSet.commit();\n            if (resultsForFirstNonemptyCandidateSet.singleDescriptor()) {\n                return resultsForFirstNonemptyCandidateSet.getResult();\n            }\n        }\n        else {\n            trace.report(UNRESOLVED_REFERENCE.on(reference));\n            checkTypesWithNoCallee(trace, scope, call.getTypeArguments(), call.getValueArguments(), call.getFunctionLiteralArguments());\n        }\n        return null;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ResolutionTask(\n            @NotNull Collection<ResolvedCall<D>> candidates,\n            @NotNull ReceiverDescriptor receiver,\n            @NotNull Call call\n    ) {\n        this(candidates, receiver, call.getTypeArguments(), call.getValueArguments(), call.getFunctionLiteralArguments());\n    }","id":31918,"modified_method":"public ResolutionTask(\n            @NotNull Collection<ResolvedCall<D>> candidates,\n            @NotNull Call call,\n            @NotNull DataFlowInfo dataFlowInfo\n    ) {\n        this(candidates, call.getTypeArguments(), call.getValueArguments(), call.getFunctionLiteralArguments(), dataFlowInfo);\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ResolutionTask(\n            @NotNull Collection<ResolvedCall<D>> candidates,\n            @NotNull ReceiverDescriptor receiver,\n            @NotNull List<JetTypeProjection> typeArguments,\n            @NotNull List<? extends ValueArgument> valueArguments,\n            @NotNull List<JetExpression> functionLiteralArguments) {\n        this.candidates = candidates;\n        this.receiver = receiver;\n        this.typeArguments = typeArguments;\n        this.valueArguments = valueArguments;\n        this.functionLiteralArguments = functionLiteralArguments;\n    }","id":31919,"modified_method":"public ResolutionTask(\n            @NotNull Collection<ResolvedCall<D>> candidates,\n            @NotNull List<JetTypeProjection> typeArguments,\n            @NotNull List<? extends ValueArgument> valueArguments,\n            @NotNull List<JetExpression> functionLiteralArguments,\n            @NotNull DataFlowInfo dataFlowInfo) {\n        this.candidates = candidates;\n        this.typeArguments = typeArguments;\n        this.valueArguments = valueArguments;\n        this.functionLiteralArguments = functionLiteralArguments;\n        this.dataFlowInfo = dataFlowInfo;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    protected abstract ResolutionTask<D> createTask(ReceiverDescriptor receiver, Call call, Collection<ResolvedCall<D>> candidates);","id":31920,"modified_method":"private Collection<ResolvedCall<D>> convertWithImpliedThis(ReceiverDescriptor receiverParameter, Collection<D> descriptors) {\n        Collection<ResolvedCall<D>> result = Lists.newArrayList();\n        for (D extension : descriptors) {\n            ResolvedCall<D> resolvedCall = ResolvedCall.create(extension);\n            resolvedCall.setReceiverParameter(receiverParameter);\n            setImpliedThis(resolvedCall);\n            result.add(resolvedCall);\n        }\n        return result;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public List<ResolutionTask<D>> computePrioritizedTasks(@NotNull JetScope scope, @NotNull ReceiverDescriptor receiver, @NotNull Call call, @NotNull String name, @NotNull BindingContext bindingContext, @NotNull DataFlowInfo dataFlowInfo) {\n        List<ResolutionTask<D>> result = Lists.newArrayList();\n\n        doComputeTasks(scope, receiver, call, name, result);\n\n//        ReceiverDescriptor receiverToCast = receiver.exists() ? receiver : scope.getImplicitReceiver();\n//        if (receiverToCast.exists()) {\n//            for (ReceiverDescriptor castReceiver : AutoCastUtils.getAutocastVariants(bindingContext, dataFlowInfo, receiverToCast)) {\n//                doComputeTasks(scope, castReceiver, call, name, result);\n//            }\n//        }\n        return result;\n    }","id":31921,"modified_method":"public List<ResolutionTask<D>> computePrioritizedTasks(@NotNull JetScope scope, @NotNull ReceiverDescriptor explicitReceiver, @NotNull Call call, @NotNull String name, @NotNull BindingContext bindingContext, @NotNull DataFlowInfo dataFlowInfo) {\n        List<ResolutionTask<D>> result = Lists.newArrayList();\n\n        doComputeTasks(scope, explicitReceiver, call, name, result, DataFlowInfo.getEmpty());\n\n        ReceiverDescriptor receiverToCast = explicitReceiver.exists() ? explicitReceiver : scope.getImplicitReceiver();\n        if (receiverToCast.exists()) {\n            doComputeTasks(scope, receiverToCast, call, name, result, dataFlowInfo);\n        }\n        return result;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void doComputeTasks(JetScope scope, ReceiverDescriptor receiver, Call call, String name, List<ResolutionTask<D>> result) {\n        List<ReceiverDescriptor> implicitReceivers = Lists.newArrayList();\n        scope.getImplicitReceiversHierarchy(implicitReceivers);\n        if (receiver.exists()) {\n            Collection<D> extensionFunctions = getExtensionsByName(scope, name);\n            List<D> nonlocals = Lists.newArrayList();\n            List<D> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(extensionFunctions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            Collection<D> members = getMembersByName(receiver, name);\n\n            addTask(result, receiver, call, locals);\n            addTask(result, NO_RECEIVER, call, members);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                Collection<D> memberExtensions = getExtensionsByName(implicitReceiver.getType().getMemberScope(), name);\n                addTask(result, receiver, call, memberExtensions);\n            }\n\n            addTask(result, receiver, call, nonlocals);\n        }\n        else {\n            Collection<D> functions = getNonExtensionsByName(scope, name);\n\n            List<D> nonlocals = Lists.newArrayList();\n            List<D> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(functions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            addTask(result, receiver, call, locals);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                doComputeTasks(scope, implicitReceiver, call, name, result);\n            }\n\n            addTask(result, receiver, call, nonlocals);\n        }\n    }","id":31922,"modified_method":"private void doComputeTasks(JetScope scope, ReceiverDescriptor explicitReceiver, Call call, String name, List<ResolutionTask<D>> result, @NotNull DataFlowInfo dataFlowInfo) {\n        List<ReceiverDescriptor> implicitReceivers = Lists.newArrayList();\n        scope.getImplicitReceiversHierarchy(implicitReceivers);\n        if (explicitReceiver.exists()) {\n            Collection<ResolvedCall<D>> extensionFunctions = convertWithImpliedThis(explicitReceiver, getExtensionsByName(scope, name));\n            List<ResolvedCall<D>> nonlocals = Lists.newArrayList();\n            List<ResolvedCall<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(extensionFunctions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            // AutoCastUtils.getAutoCastVariants(bindingContext, dataFlowInfo, receiverToCast)\n            Collection<D> members = getMembersByName(explicitReceiver.getType(), name);\n\n            addTask(result, call, locals, dataFlowInfo);\n            addTask(result, call, convertWithReceivers(members, explicitReceiver, NO_RECEIVER), dataFlowInfo);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                Collection<D> memberExtensions = getExtensionsByName(implicitReceiver.getType().getMemberScope(), name);\n                addTask(result, call, convertWithReceivers(memberExtensions, implicitReceiver, explicitReceiver), dataFlowInfo);\n            }\n\n            addTask(result, call, nonlocals, dataFlowInfo);\n        }\n        else {\n            Collection<ResolvedCall<D>> functions = convertWithImpliedThis(explicitReceiver, getNonExtensionsByName(scope, name));\n\n            List<ResolvedCall<D>> nonlocals = Lists.newArrayList();\n            List<ResolvedCall<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(functions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            addTask(result, call, locals, dataFlowInfo);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                doComputeTasks(scope, implicitReceiver, call, name, result, dataFlowInfo);\n            }\n\n            addTask(result, call, nonlocals, dataFlowInfo);\n        }\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    protected abstract Collection<D> getMembersByName(@NotNull ReceiverDescriptor receiver, String name);","id":31923,"modified_method":"@NotNull\n    protected abstract Collection<D> getMembersByName(@NotNull JetType receiver, String name);","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * The primary case for local extensions is the following:\n     *\n     * I had a locally declared extension function or a local variable of function type called foo\n     * And I called it on my x\n     * Now, someone added function foo() to the class of x\n     * My code should not change\n     *\n     * thus\n     *\n     * local extension prevail over members (and members prevail over all non-local extensions)\n     */\n    public static boolean isLocal(DeclarationDescriptor containerOfTheCurrentLocality, DeclarationDescriptor candidate) {\n        if (candidate instanceof ValueParameterDescriptor) {\n            return true;\n        }\n        DeclarationDescriptor parent = candidate.getContainingDeclaration();\n        if (!(parent instanceof FunctionDescriptor)) {\n            return false;\n        }\n        FunctionDescriptor functionDescriptor = (FunctionDescriptor) parent;\n        DeclarationDescriptor current = containerOfTheCurrentLocality;\n        while (current != null) {\n            if (current == functionDescriptor) {\n                return true;\n            }\n            current = current.getContainingDeclaration();\n        }\n        return false;\n    }","id":31924,"modified_method":"/**\n     * The primary case for local extensions is the following:\n     *\n     * I had a locally declared extension function or a local variable of function type called foo\n     * And I called it on my x\n     * Now, someone added function foo() to the class of x\n     * My code should not change\n     *\n     * thus\n     *\n     * local extension prevail over members (and members prevail over all non-local extensions)\n     */\n    private static boolean isLocal(DeclarationDescriptor containerOfTheCurrentLocality, DeclarationDescriptor candidate) {\n        if (candidate instanceof ValueParameterDescriptor) {\n            return true;\n        }\n        DeclarationDescriptor parent = candidate.getContainingDeclaration();\n        if (!(parent instanceof FunctionDescriptor)) {\n            return false;\n        }\n        FunctionDescriptor functionDescriptor = (FunctionDescriptor) parent;\n        DeclarationDescriptor current = containerOfTheCurrentLocality;\n        while (current != null) {\n            if (current == functionDescriptor) {\n                return true;\n            }\n            current = current.getContainingDeclaration();\n        }\n        return false;\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static <T extends DeclarationDescriptor> void splitLexicallyLocalDescriptors(\n            Collection<? extends T> allDescriptors, DeclarationDescriptor containerOfTheCurrentLocality, List<? super T> local, List<? super T> nonlocal) {\n\n        for (T descriptor : allDescriptors) {\n            if (isLocal(containerOfTheCurrentLocality, descriptor)) {\n                local.add(descriptor);\n            }\n            else {\n                nonlocal.add(descriptor);\n            }\n        }\n    }","id":31925,"modified_method":"public static <D extends CallableDescriptor> void splitLexicallyLocalDescriptors(\n            Collection<ResolvedCall<D>> allDescriptors, DeclarationDescriptor containerOfTheCurrentLocality, Collection<ResolvedCall<D>> local, Collection<ResolvedCall<D>> nonlocal) {\n\n        for (ResolvedCall<D> resolvedCall : allDescriptors) {\n            if (isLocal(containerOfTheCurrentLocality, resolvedCall.getCandidateDescriptor())) {\n                local.add(resolvedCall);\n            }\n            else {\n                nonlocal.add(resolvedCall);\n            }\n        }\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void addTask(@NotNull List<ResolutionTask<D>> result, @NotNull ReceiverDescriptor receiver, @NotNull Call call, @NotNull Collection<D> candidateDescriptors) {\n        if (candidateDescriptors.isEmpty()) return;\n        result.add(createTask(receiver, call, ResolvedCall.convertCollection(candidateDescriptors)));\n    }","id":31926,"modified_method":"private void addTask(@NotNull List<ResolutionTask<D>> result, @NotNull Call call, @NotNull Collection<ResolvedCall<D>> candidates, @NotNull DataFlowInfo dataFlowInfo) {\n        if (candidates.isEmpty()) return;\n        result.add(new ResolutionTask<D>(candidates, call, dataFlowInfo));\n    }","commit_id":"114763b0b2abeac6a783f4440ceef0ca38bed041","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static <D extends CallableDescriptor> List<ResolutionTask<D>> computePrioritizedTasks(@NotNull BasicResolutionContext context, @NotNull String name,\n                                                           @NotNull JetReferenceExpression functionReference, @NotNull List<MemberPrioritizer<D>> memberPrioritizers) {\n        ReceiverDescriptor explicitReceiver = context.call.getExplicitReceiver();\n        final JetScope scope;\n        if (explicitReceiver.exists() && explicitReceiver.getType() instanceof NamespaceType) {\n            // Receiver is a namespace\n            scope = explicitReceiver.getType().getMemberScope();\n            explicitReceiver = NO_RECEIVER;\n        }\n        else {\n            scope = context.scope;\n        }\n        final Predicate<ResolutionCandidate<D>> visibleStrategy = new Predicate<ResolutionCandidate<D>>() {\n            @Override\n            public boolean apply(@Nullable ResolutionCandidate<D> call) {\n                if (call == null) return false;\n                D candidateDescriptor = call.getDescriptor();\n                if (ErrorUtils.isError(candidateDescriptor)) return true;\n                return Visibilities.isVisible(candidateDescriptor, scope.getContainingDeclaration());\n            }\n        };\n\n        ResolutionTaskHolder<D> result = new ResolutionTaskHolder<D>(functionReference, context, visibleStrategy );\n        doComputeTasks(scope, explicitReceiver, name, result, context, memberPrioritizers);\n\n        return result.getTasks();\n    }","id":31927,"modified_method":"@NotNull\n    public static <D extends CallableDescriptor, F extends D> List<ResolutionTask<D, F>> computePrioritizedTasks(@NotNull BasicResolutionContext context, @NotNull String name,\n                                                           @NotNull JetReferenceExpression functionReference, @NotNull List<CallableDescriptorCollector<? extends D>> callableDescriptorCollectors) {\n        ReceiverDescriptor explicitReceiver = context.call.getExplicitReceiver();\n        final JetScope scope;\n        if (explicitReceiver.exists() && explicitReceiver.getType() instanceof NamespaceType) {\n            // Receiver is a namespace\n            scope = explicitReceiver.getType().getMemberScope();\n            explicitReceiver = NO_RECEIVER;\n        }\n        else {\n            scope = context.scope;\n        }\n        final Predicate<ResolutionCandidate<D>> visibleStrategy = new Predicate<ResolutionCandidate<D>>() {\n            @Override\n            public boolean apply(@Nullable ResolutionCandidate<D> call) {\n                if (call == null) return false;\n                D candidateDescriptor = call.getDescriptor();\n                if (ErrorUtils.isError(candidateDescriptor)) return true;\n                return Visibilities.isVisible(candidateDescriptor, scope.getContainingDeclaration());\n            }\n        };\n\n        ResolutionTaskHolder<D, F> result = new ResolutionTaskHolder<D, F>(functionReference, context, visibleStrategy );\n        for (CallableDescriptorCollector<? extends D> callableDescriptorCollector : callableDescriptorCollectors) {\n            doComputeTasks(scope, explicitReceiver, name, result, context, callableDescriptorCollector);\n        }\n        return result.getTasks();\n    }","commit_id":"2fa8fd50fcc5d88601d225fcce27bbacab464228","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static <D extends CallableDescriptor> Collection<ResolutionCandidate<D>> convertWithReceivers(Collection<D> descriptors, Iterable<ReceiverDescriptor> thisObjects, Iterable<ReceiverDescriptor> receiverParameters) {\n        Collection<ResolutionCandidate<D>> result = Lists.newArrayList();\n        convertWithReceivers(descriptors, thisObjects, receiverParameters, result);\n        return result;\n    }","id":31928,"modified_method":"private static <D extends CallableDescriptor> Collection<ResolutionCandidate<D>> convertWithReceivers(Collection<? extends D> descriptors, Iterable<ReceiverDescriptor> thisObjects, Iterable<ReceiverDescriptor> receiverParameters) {\n        Collection<ResolutionCandidate<D>> result = Lists.newArrayList();\n        convertWithReceivers(descriptors, thisObjects, receiverParameters, result);\n        return result;\n    }","commit_id":"2fa8fd50fcc5d88601d225fcce27bbacab464228","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static <D extends CallableDescriptor> void doComputeTasks(@NotNull JetScope scope, @NotNull ReceiverDescriptor receiver,\n            @NotNull String name, @NotNull ResolutionTaskHolder<D> result,\n            @NotNull BasicResolutionContext context, @NotNull List<MemberPrioritizer<D>> memberPrioritizers) {\n        MemberPrioritizer<D> memberPrioritizer = memberPrioritizers.get(0);\n        AutoCastServiceImpl autoCastService = new AutoCastServiceImpl(context.dataFlowInfo, context.trace.getBindingContext());\n        List<ReceiverDescriptor> implicitReceivers = Lists.newArrayList();\n        scope.getImplicitReceiversHierarchy(implicitReceivers);\n        if (receiver.exists()) {\n            List<ReceiverDescriptor> variantsForExplicitReceiver = autoCastService.getVariantsForReceiver(receiver);\n\n            Collection<ResolutionCandidate<D>> extensionFunctions = convertWithImpliedThis(scope, variantsForExplicitReceiver, memberPrioritizer.getExtensionsByName(scope, name));\n            List<ResolutionCandidate<D>> nonlocals = Lists.newArrayList();\n            List<ResolutionCandidate<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(extensionFunctions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            Collection<ResolutionCandidate<D>> members = Lists.newArrayList();\n            for (ReceiverDescriptor variant : variantsForExplicitReceiver) {\n                Collection<D> membersForThisVariant = memberPrioritizer.getMembersByName(variant.getType(), name);\n                convertWithReceivers(membersForThisVariant, Collections.singletonList(variant), Collections.singletonList(NO_RECEIVER), members);\n            }\n\n            result.addLocalExtensions(locals);\n            result.addMembers(members);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                Collection<D> memberExtensions = memberPrioritizer.getExtensionsByName(implicitReceiver.getType().getMemberScope(), name);\n                List<ReceiverDescriptor> variantsForImplicitReceiver = autoCastService.getVariantsForReceiver(implicitReceiver);\n                result.addNonLocalExtensions(convertWithReceivers(memberExtensions, variantsForImplicitReceiver, variantsForExplicitReceiver));\n            }\n\n            result.addNonLocalExtensions(nonlocals);\n        }\n        else {\n            Collection<ResolutionCandidate<D>> functions = convertWithImpliedThis(scope, Collections.singletonList(receiver), memberPrioritizer.getNonExtensionsByName(scope, name));\n\n            List<ResolutionCandidate<D>> nonlocals = Lists.newArrayList();\n            List<ResolutionCandidate<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(functions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            result.addLocalExtensions(locals);\n            result.addNonLocalExtensions(nonlocals);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                doComputeTasks(scope, implicitReceiver, name, result, context, memberPrioritizers);\n            }\n        }\n    }","id":31929,"modified_method":"private static <D extends CallableDescriptor, F extends D> void doComputeTasks(@NotNull JetScope scope, @NotNull ReceiverDescriptor receiver,\n            @NotNull String name, @NotNull ResolutionTaskHolder<D, F> result,\n            @NotNull BasicResolutionContext context, @NotNull CallableDescriptorCollector<? extends D> callableDescriptorCollector) {\n        AutoCastServiceImpl autoCastService = new AutoCastServiceImpl(context.dataFlowInfo, context.trace.getBindingContext());\n        List<ReceiverDescriptor> implicitReceivers = Lists.newArrayList();\n        scope.getImplicitReceiversHierarchy(implicitReceivers);\n        if (context.call.getThisObject().exists()) {\n            implicitReceivers.add(context.call.getThisObject());\n        }\n        if (receiver.exists()) {\n            List<ReceiverDescriptor> variantsForExplicitReceiver = autoCastService.getVariantsForReceiver(receiver);\n\n            Collection<ResolutionCandidate<D>> extensionFunctions = convertWithImpliedThis(scope, variantsForExplicitReceiver, callableDescriptorCollector.getNonMembersByName(scope, name));\n            List<ResolutionCandidate<D>> nonlocals = Lists.newArrayList();\n            List<ResolutionCandidate<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(extensionFunctions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            Collection<ResolutionCandidate<D>> members = Lists.newArrayList();\n            for (ReceiverDescriptor variant : variantsForExplicitReceiver) {\n                Collection<? extends D> membersForThisVariant = callableDescriptorCollector.getMembersByName(variant.getType(), name);\n                convertWithReceivers(membersForThisVariant, Collections.singletonList(variant), Collections.singletonList(NO_RECEIVER), members);\n            }\n\n            result.addLocalExtensions(locals);\n            result.addMembers(members);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                Collection<? extends D> memberExtensions = callableDescriptorCollector.getNonMembersByName(\n                        implicitReceiver.getType().getMemberScope(), name);\n                List<ReceiverDescriptor> variantsForImplicitReceiver = autoCastService.getVariantsForReceiver(implicitReceiver);\n                result.addNonLocalExtensions(convertWithReceivers(memberExtensions, variantsForImplicitReceiver, variantsForExplicitReceiver));\n            }\n\n            result.addNonLocalExtensions(nonlocals);\n        }\n        else {\n            Collection<ResolutionCandidate<D>> functions = convertWithImpliedThis(scope, Collections.singletonList(receiver), callableDescriptorCollector\n                    .getNonExtensionsByName(scope, name));\n\n            List<ResolutionCandidate<D>> nonlocals = Lists.newArrayList();\n            List<ResolutionCandidate<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(functions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            result.addLocalExtensions(locals);\n            result.addNonLocalExtensions(nonlocals);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                doComputeTasks(scope, implicitReceiver, name, result, context, callableDescriptorCollector);\n            }\n        }\n    }","commit_id":"2fa8fd50fcc5d88601d225fcce27bbacab464228","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static <D extends CallableDescriptor> void convertWithReceivers(Collection<D> descriptors, Iterable<ReceiverDescriptor> thisObjects, Iterable<ReceiverDescriptor> receiverParameters, Collection<ResolutionCandidate<D>> result) {\n        for (ReceiverDescriptor thisObject : thisObjects) {\n            for (ReceiverDescriptor receiverParameter : receiverParameters) {\n                for (D extension : descriptors) {\n                    ResolutionCandidate<D> resolvedCall = ResolutionCandidate.create(extension);\n                    resolvedCall.setThisObject(thisObject);\n                    resolvedCall.setReceiverArgument(receiverParameter);\n                    result.add(resolvedCall);\n                }\n            }\n        }\n    }","id":31930,"modified_method":"private static <D extends CallableDescriptor> void convertWithReceivers(Collection<? extends D> descriptors, Iterable<ReceiverDescriptor> thisObjects, Iterable<ReceiverDescriptor> receiverParameters, Collection<ResolutionCandidate<D>> result) {\n        for (ReceiverDescriptor thisObject : thisObjects) {\n            for (ReceiverDescriptor receiverParameter : receiverParameters) {\n                for (D extension : descriptors) {\n                    ResolutionCandidate<D> resolvedCall = ResolutionCandidate.create(extension);\n                    resolvedCall.setThisObject(thisObject);\n                    resolvedCall.setReceiverArgument(receiverParameter);\n                    result.add(resolvedCall);\n                }\n            }\n        }\n    }","commit_id":"2fa8fd50fcc5d88601d225fcce27bbacab464228","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void configureGroovydoc(final Project project) {\n        project.getTasks().withType(Groovydoc.class).allTasks(new Action<Groovydoc>() {\n            public void execute(Groovydoc groovydoc) {\n                groovydoc.getConventionMapping().map(\"groovyClasspath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return project.getConfigurations().getByName(GROOVY_CONFIGURATION_NAME).copy().setTransitive(true);\n                    }\n                });\n                groovydoc.getConventionMapping().map(\"defaultSource\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return mainGroovy(convention).getGroovy();\n                    }\n                });\n                groovydoc.getConventionMapping().map(\"destinationDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return new File(java(convention).getDocsDir(), \"groovydoc\");\n                    }\n                });\n                groovydoc.getConventionMapping().map(\"docTitle\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(ReportingBasePluginConvention.class).getApiDocTitle();\n                    }\n                });\n                groovydoc.getConventionMapping().map(\"windowTitle\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(ReportingBasePluginConvention.class).getApiDocTitle();\n                    }\n                });\n            }\n        });\n        project.getTasks().add(GROOVYDOC_TASK_NAME, Groovydoc.class).setDescription(\"Generates the groovydoc for the source code.\");\n    }","id":31931,"modified_method":"private void configureGroovydoc(final Project project) {\n        project.getTasks().withType(Groovydoc.class).allTasks(new Action<Groovydoc>() {\n            public void execute(Groovydoc groovydoc) {\n                groovydoc.getConventionMapping().map(\"defaultSource\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return mainGroovy(convention).getGroovy();\n                    }\n                });\n            }\n        });\n        project.getTasks().add(GROOVYDOC_TASK_NAME, Groovydoc.class).setDescription(\"Generates the groovydoc for the source code.\");\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"public void use(Project project) {\n        JavaPlugin javaPlugin = project.getPlugins().usePlugin(JavaPlugin.class);\n\n        Configuration groovyConfiguration = project.getConfigurations().add(GROOVY_CONFIGURATION_NAME).setVisible(false).setTransitive(false).\n                setDescription(\"The groovy libraries to be used for this Groovy project.\");\n        project.getConfigurations().getByName(COMPILE_CONFIGURATION_NAME).extendsFrom(groovyConfiguration);\n\n        configureCompileDefaults(project);\n        configureSourceSetDefaults(project, javaPlugin);\n\n        configureGroovydoc(project);\n    }","id":31932,"modified_method":"public void use(Project project) {\n        project.getPlugins().usePlugin(GroovyBasePlugin.class);\n        project.getPlugins().usePlugin(JavaPlugin.class);\n\n        project.getConfigurations().getByName(COMPILE_CONFIGURATION_NAME).extendsFrom(\n                project.getConfigurations().getByName(GroovyBasePlugin.GROOVY_CONFIGURATION_NAME)\n        );\n        configureGroovydoc(project);\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureBuild(Project project) {\n        DefaultTask buildTask = project.getTasks().add(BUILD_TASK_NAME, DefaultTask.class);\n        buildTask.setDescription(\"Assembles and tests this project.\");\n        buildTask.dependsOn(BasePlugin.ASSEMBLE_TASK_NAME);\n        buildTask.dependsOn(CHECK_TASK_NAME);\n    }","id":31933,"modified_method":"private void configureBuild(Project project) {\n        addDependsOnTaskInOtherProjects(project.getTasks().getByName(JavaBasePlugin.BUILD_NEEDED_TASK_NAME), \n                true, JavaBasePlugin.BUILD_TASK_NAME, TEST_RUNTIME_CONFIGURATION_NAME);\n        addDependsOnTaskInOtherProjects(project.getTasks().getByName(JavaBasePlugin.BUILD_DEPENDENTS_TASK_NAME),\n                false, JavaBasePlugin.BUILD_TASK_NAME, TEST_RUNTIME_CONFIGURATION_NAME);\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureJavaDoc(final Project project) {\n        project.getTasks().withType(Javadoc.class).allTasks(new Action<Javadoc>() {\n            public void execute(Javadoc javadoc) {\n                javadoc.getConventionMapping().map(\"classpath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        SourceSet mainSourceSet = convention.getPlugin(JavaPluginConvention.class).getSourceSets()\n                                .getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n                        return mainSourceSet.getClasses().plus(mainSourceSet.getCompileClasspath());\n                    }\n                });\n                javadoc.getConventionMapping().map(\"defaultSource\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.MAIN_SOURCE_SET_NAME).getAllJava();\n                    }\n                });\n                javadoc.getConventionMapping().map(\"destinationDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return new File(convention.getPlugin(JavaPluginConvention.class).getDocsDir(), \"javadoc\");\n                    }\n                });\n                javadoc.getConventionMapping().map(\"optionsFile\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return new File(project.getBuildDir(), \"tmp/javadoc.options\");\n                    }\n                });\n                javadoc.getConventionMapping().map(\"title\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(ReportingBasePluginConvention.class).getApiDocTitle();\n                    }\n                });\n                addDependsOnTaskInOtherProjects(javadoc, true, JAVADOC_TASK_NAME, COMPILE_CONFIGURATION_NAME);\n            }\n        });\n        project.getTasks().add(JAVADOC_TASK_NAME, Javadoc.class).setDescription(\n                \"Generates the javadoc for the source code.\");\n    }","id":31934,"modified_method":"private void configureJavaDoc(final Project project) {\n        project.getTasks().withType(Javadoc.class).allTasks(new Action<Javadoc>() {\n            public void execute(Javadoc javadoc) {\n                javadoc.getConventionMapping().map(\"classpath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        SourceSet mainSourceSet = convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n                        return mainSourceSet.getClasses().plus(mainSourceSet.getCompileClasspath());\n                    }\n                });\n                javadoc.getConventionMapping().map(\"defaultSource\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.MAIN_SOURCE_SET_NAME).getAllJava();\n                    }\n                });\n                addDependsOnTaskInOtherProjects(javadoc, true, JAVADOC_TASK_NAME, COMPILE_CONFIGURATION_NAME);\n            }\n        });\n        project.getTasks().add(JAVADOC_TASK_NAME, Javadoc.class).setDescription(\n                \"Generates the javadoc for the source code.\");\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"void configureConfigurations(final Project project) {\n        project.setProperty(\"status\", \"integration\");\n        ConfigurationContainer configurations = project.getConfigurations();\n        Configuration compileConfiguration = configurations.add(COMPILE_CONFIGURATION_NAME).setVisible(false)\n                .setTransitive(false).\n                        setDescription(\"Classpath for compiling the sources.\");\n        Configuration runtimeConfiguration = configurations.add(RUNTIME_CONFIGURATION_NAME).setVisible(false)\n                .extendsFrom(compileConfiguration).\n                        setDescription(\"Classpath for running the compiled sources.\");\n\n        Configuration compileTestsConfiguration = configurations.add(TEST_COMPILE_CONFIGURATION_NAME).setVisible(false)\n                .extendsFrom(compileConfiguration).\n                        setTransitive(false).setDescription(\"Classpath for compiling the test sources.\");\n\n        configurations.add(TEST_RUNTIME_CONFIGURATION_NAME).setVisible(false).extendsFrom(runtimeConfiguration,\n                compileTestsConfiguration).\n                setDescription(\"Classpath for running the test sources.\");\n\n        Configuration archivesConfiguration = configurations.add(Dependency.ARCHIVES_CONFIGURATION).\n                setDescription(\"Configuration for the default artifacts.\");\n\n        configurations.add(Dependency.DEFAULT_CONFIGURATION).extendsFrom(runtimeConfiguration, archivesConfiguration).\n                setDescription(\"Configuration the default artifacts and its dependencies.\");\n    }","id":31935,"modified_method":"void configureConfigurations(final Project project) {\n        ConfigurationContainer configurations = project.getConfigurations();\n        Configuration compileConfiguration = configurations.add(COMPILE_CONFIGURATION_NAME).setVisible(false).setTransitive(false).\n                setDescription(\"Classpath for compiling the sources.\");\n        Configuration runtimeConfiguration = configurations.add(RUNTIME_CONFIGURATION_NAME).setVisible(false).extendsFrom(compileConfiguration).\n                setDescription(\"Classpath for running the compiled sources.\");\n\n        Configuration compileTestsConfiguration = configurations.add(TEST_COMPILE_CONFIGURATION_NAME).setVisible(false).extendsFrom(compileConfiguration).\n                setTransitive(false).setDescription(\"Classpath for compiling the test sources.\");\n\n        configurations.add(TEST_RUNTIME_CONFIGURATION_NAME).setVisible(false).extendsFrom(runtimeConfiguration,\n                compileTestsConfiguration).\n                setDescription(\"Classpath for running the test sources.\");\n\n        Configuration archivesConfiguration = configurations.add(Dependency.ARCHIVES_CONFIGURATION).\n                setDescription(\"Configuration for the default artifacts.\");\n\n        configurations.add(Dependency.DEFAULT_CONFIGURATION).extendsFrom(runtimeConfiguration, archivesConfiguration).\n                setDescription(\"Configuration the default artifacts and its dependencies.\");\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureArchives(final Project project, final JavaPluginConvention pluginConvention) {\n        project.getTasks().withType(Jar.class).allTasks(new Action<Jar>() {\n            public void execute(Jar task) {\n                task.getConventionMapping().map(\"manifest\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return new GradleManifest(pluginConvention.getManifest().getManifest());\n                    }\n                });\n                task.getMetaInf().from(new Callable() {\n                    public Object call() throws Exception {\n                        return pluginConvention.getMetaInf();\n                    }\n                });\n            }\n        });\n\n        Task checkTask = project.getTasks().add(CHECK_TASK_NAME);\n        checkTask.setDescription(\"Runs all checks.\");\n        checkTask.dependsOn(TEST_TASK_NAME);\n\n        Jar jar = project.getTasks().add(JAR_TASK_NAME, Jar.class);\n        jar.setDescription(\"Generates a jar archive with all the compiled classes.\");\n        jar.from(pluginConvention.getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME).getClasses());\n        project.getConfigurations().getByName(Dependency.ARCHIVES_CONFIGURATION).addArtifact(new ArchivePublishArtifact(\n                jar));\n    }","id":31936,"modified_method":"private void configureArchives(final Project project, final JavaPluginConvention pluginConvention) {\n        project.getTasks().getByName(JavaBasePlugin.CHECK_TASK_NAME).dependsOn(TEST_TASK_NAME);\n\n        Jar jar = project.getTasks().add(JAR_TASK_NAME, Jar.class);\n        jar.setDescription(\"Generates a jar archive with all the compiled classes.\");\n        jar.from(pluginConvention.getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME).getClasses());\n        project.getConfigurations().getByName(Dependency.ARCHIVES_CONFIGURATION).addArtifact(new ArchivePublishArtifact(\n                jar));\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"public void use(Project project) {\n        project.getPlugins().usePlugin(BasePlugin.class);\n        project.getPlugins().usePlugin(ReportingBasePlugin.class);\n\n        JavaPluginConvention javaConvention = new JavaPluginConvention(project);\n        project.getConvention().getPlugins().put(\"java\", javaConvention);\n        project.getConvention().getPlugins().put(\"embeddedJavaProject\", new EmbeddableJavaProjectImpl(javaConvention));\n\n        configureConfigurations(project);\n        configureCompileDefaults(project, javaConvention);\n        configureSourceSetDefaults(javaConvention);\n\n        configureSourceSets(javaConvention);\n\n        configureJavaDoc(project);\n        configureTest(project);\n        configureArchives(project, javaConvention);\n        configureBuild(project);\n        configureBuildNeeded(project);\n        configureBuildDependents(project);\n    }","id":31937,"modified_method":"public void use(Project project) {\n        project.getPlugins().usePlugin(JavaBasePlugin.class);\n\n        JavaPluginConvention javaConvention = (JavaPluginConvention) project.getConvention().getPlugins().get(\"java\");\n\n        configureConfigurations(project);\n        configureSourceSetDefaults(javaConvention);\n\n        configureSourceSets(javaConvention);\n\n        configureJavaDoc(project);\n        configureTest(project);\n        configureArchives(project, javaConvention);\n        configureBuild(project);\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureSourceSetDefaults(final JavaPluginConvention pluginConvention) {\n        pluginConvention.getSourceSets().allObjects(new Action<SourceSet>() {\n            public void execute(final SourceSet sourceSet) {\n                final Project project = pluginConvention.getProject();\n                ConventionMapping conventionMapping = ((IConventionAware) sourceSet).getConventionMapping();\n\n                conventionMapping.map(\"classesDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        String classesDirName = String.format(\"classes/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n                conventionMapping.map(\"compileClasspath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return project.getConfigurations().getByName(COMPILE_CONFIGURATION_NAME);\n                    }\n                });\n                conventionMapping.map(\"runtimeClasspath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getClasses().plus(project.getConfigurations().getByName(\n                                RUNTIME_CONFIGURATION_NAME));\n                    }\n                });\n                sourceSet.getJava().srcDir(String.format(\"src/%s/java\", sourceSet.getName()));\n                sourceSet.getResources().srcDir(String.format(\"src/%s/resources\", sourceSet.getName()));\n\n                Copy processResources = project.getTasks().add(sourceSet.getProcessResourcesTaskName(), Copy.class);\n                processResources.setDescription(String.format(\"Processes the %s.\", sourceSet.getResources()));\n                conventionMapping = processResources.getConventionMapping();\n                conventionMapping.map(\"defaultSource\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getResources();\n                    }\n                });\n                conventionMapping.map(\"destinationDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getClassesDir();\n                    }\n                });\n\n                String compileTaskName = sourceSet.getCompileTaskName(\"java\");\n                Compile compileJava = project.getTasks().add(compileTaskName, Compile.class);\n                configureForSourceSet(sourceSet, compileJava);\n\n                Task classes = project.getTasks().add(sourceSet.getClassesTaskName());\n                classes.dependsOn(sourceSet.getProcessResourcesTaskName(), compileTaskName);\n                classes.setDescription(String.format(\"Assembles the %s classes.\", sourceSet.getName()));\n\n                sourceSet.compiledBy(sourceSet.getClassesTaskName());\n            }\n        });\n    }","id":31938,"modified_method":"private void configureSourceSetDefaults(final JavaPluginConvention pluginConvention) {\n        pluginConvention.getSourceSets().allObjects(new Action<SourceSet>() {\n            public void execute(final SourceSet sourceSet) {\n                final Project project = pluginConvention.getProject();\n                ConventionMapping conventionMapping = ((IConventionAware) sourceSet).getConventionMapping();\n\n                conventionMapping.map(\"compileClasspath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return project.getConfigurations().getByName(COMPILE_CONFIGURATION_NAME);\n                    }\n                });\n                conventionMapping.map(\"runtimeClasspath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getClasses().plus(project.getConfigurations().getByName(\n                                RUNTIME_CONFIGURATION_NAME));\n                    }\n                });\n            }\n        });\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureTest(final Project project) {\n        project.getTasks().withType(AbstractTestTask.class).allTasks(new Action<AbstractTestTask>() {\n            public void execute(AbstractTestTask test) {\n                test.getConventionMapping().map(GUtil.map(\"testClassesDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.TEST_SOURCE_SET_NAME).getClassesDir();\n                    }\n                }, \"classpath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.TEST_SOURCE_SET_NAME).getRuntimeClasspath();\n                    }\n                }, \"testResultsDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getTestResultsDir();\n                    }\n                }, \"testReportDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getTestReportDir();\n                    }\n                }, \"testSrcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        Set<File> srcDirs = convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.TEST_SOURCE_SET_NAME).getJava().getSrcDirs();\n                        return new ArrayList<File>(srcDirs);\n                    }\n                }));\n            }\n        });\n        project.getTasks().withType(Test.class).allTasks(new Action<Test>() {\n            public void execute(Test test) {\n                test.workingDir(project.getProjectDir());\n            }\n        });\n        project.getTasks().add(TEST_TASK_NAME, Test.class).setDescription(\"Runs the unit tests.\");\n    }","id":31939,"modified_method":"private void configureTest(final Project project) {\n        project.getTasks().withType(AbstractTestTask.class).allTasks(new Action<AbstractTestTask>() {\n            public void execute(AbstractTestTask test) {\n                test.getConventionMapping().map(GUtil.map(\"testClassesDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.TEST_SOURCE_SET_NAME).getClassesDir();\n                    }\n                }, \"classpath\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.TEST_SOURCE_SET_NAME).getRuntimeClasspath();\n                    }\n                }, \"testSrcDirs\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        Set<File> srcDirs = convention.getPlugin(JavaPluginConvention.class).getSourceSets().getByName(\n                                SourceSet.TEST_SOURCE_SET_NAME).getJava().getSrcDirs();\n                        return new ArrayList<File>(srcDirs);\n                    }\n                }));\n            }\n        });\n        project.getTasks().add(TEST_TASK_NAME, Test.class).setDescription(\"Runs the unit tests.\");\n    }","commit_id":"2b1fb951036271ee4aca9903a812e0637f03b301","url":"https://github.com/gradle/gradle"},{"original_method":"private SetMultimap<String, TaskSelectionResult> select(String name, ProjectInternal project, Iterable<Project> additionalProjects) {\n        SetMultimap<String, TaskSelectionResult> selected = LinkedHashMultimap.create();\n        Task task = project.getTasks().findByName(name);\n        if (task != null) {\n            selected.put(task.getName(), new SimpleTaskSelectionResult(task));\n        } else {\n            task = project.getImplicitTasks().findByName(name);\n            if (task != null) {\n                selected.put(task.getName(), new SimpleTaskSelectionResult(task));\n            }\n        }\n        for (Project additionalProject : additionalProjects) {\n            task = additionalProject.getTasks().findByName(name);\n            if (task != null) {\n                selected.put(task.getName(), new SimpleTaskSelectionResult(task));\n            }\n        }\n        if (!selected.isEmpty()) {\n            return selected;\n        }\n\n        for (Task t : project.getTasks()) {\n            selected.put(t.getName(), new SimpleTaskSelectionResult(t));\n        }\n        for (Task t : project.getImplicitTasks()) {\n            if (!selected.containsKey(t.getName())) {\n                selected.put(t.getName(), new SimpleTaskSelectionResult(t));\n            }\n        }\n        Map<String, Runnable> placeholderActions = project.getTasks().getPlaceholderActions();\n        for (Map.Entry<String, Runnable> placeholderAction : placeholderActions.entrySet()) {\n            selected.put(placeholderAction.getKey(), new PlaceholderTaskSelectionResult(project.getTasks(), placeholderAction.getKey(), placeholderAction.getValue()));\n\n        }\n        for (Project additionalProject : additionalProjects) {\n            for (Task t : additionalProject.getTasks()) {\n                selected.put(t.getName(), new SimpleTaskSelectionResult(t));\n            }\n\n            final ProjectInternal additionalProjectInternal = (ProjectInternal) additionalProject;\n            placeholderActions = additionalProjectInternal.getTasks().getPlaceholderActions();\n            for (Map.Entry<String, Runnable> placeholderAction : placeholderActions.entrySet()) {\n                selected.put(placeholderAction.getKey(), new PlaceholderTaskSelectionResult(additionalProjectInternal.getTasks(), placeholderAction.getKey(), placeholderAction.getValue()));\n\n            }\n        }\n\n        return selected;\n    }","id":31940,"modified_method":"private SetMultimap<String, TaskSelectionResult> select(String name, ProjectInternal project, Iterable<Project> additionalProjects) {\n        SetMultimap<String, TaskSelectionResult> selected = LinkedHashMultimap.create();\n        Task task = project.getTasks().findByName(name);\n        if (task != null) {\n            selected.put(task.getName(), new LazyTaskSelectionResult(task.getName(), project.getTasks()));\n        } else {\n            task = project.getImplicitTasks().findByName(name);\n            if (task != null) {\n                selected.put(task.getName(), new LazyTaskSelectionResult(task.getName(), project.getImplicitTasks()));\n            }\n        }\n        for (Project additionalProject : additionalProjects) {\n            task = additionalProject.getTasks().findByName(name);\n            if (task != null) {\n                selected.put(task.getName(), new LazyTaskSelectionResult(task.getName(), additionalProject.getTasks()));\n            }\n        }\n        if (!selected.isEmpty()) {\n            return selected;\n        }\n\n        for (String taskName : project.getTasks().getNames()) {\n            selected.put(taskName, new LazyTaskSelectionResult(taskName, project.getTasks()));\n        }\n        for (String taskName : project.getImplicitTasks().getNames()) {\n            if (!selected.containsKey(taskName)) {\n                selected.put(taskName, new LazyTaskSelectionResult(taskName, project.getImplicitTasks()));\n            }\n        }\n\n        for (Project additionalProject : additionalProjects) {\n            for (String taskName : additionalProject.getTasks().getNames()) {\n                selected.put(taskName, new LazyTaskSelectionResult(taskName, additionalProject.getTasks()));\n            }\n        }\n\n        return selected;\n    }","commit_id":"26d07a9361bcf7a7b76b2e5947ba7f46e1ba34b1","url":"https://github.com/gradle/gradle"},{"original_method":"private Multimap<String, TaskSelectionResult> tasks(Iterable<Task> tasks) {\n        Multimap<String, TaskSelectionResult> map = LinkedHashMultimap.create();\n        for (final Task task : tasks) {\n            map.put(task.getName(), new TaskNameResolver.SimpleTaskSelectionResult(task));\n        }\n        return map;\n    }","id":31941,"modified_method":"private Multimap<String, TaskSelectionResult> tasks(Iterable<Task> tasks) {\n        Multimap<String, TaskSelectionResult> map = LinkedHashMultimap.create();\n        for (final Task task : tasks) {\n            map.put(task.getName(), new SimpleTaskSelectionResult(task));\n        }\n        return map;\n    }","commit_id":"26d07a9361bcf7a7b76b2e5947ba7f46e1ba34b1","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  public Object buildAll(String modelName, Project project) {\n    final ScalaPlugin scalaPlugin = project.getPlugins().findPlugin(ScalaPlugin.class);\n    if (scalaPlugin == null) return null;\n\n    final ScalaModelImpl scalaModel = new ScalaModelImpl();\n\n    for (Task task : project.getTasks()) {\n      if (task instanceof ScalaCompile && COMPILE_SCALA_TASK.equals(task.getName())) {\n        ScalaCompile scalaCompile = (ScalaCompile)task;\n        scalaModel.setScalaClasspath(scalaCompile.getScalaClasspath().getFiles());\n        scalaModel.setZincClasspath(scalaCompile.getZincClasspath().getFiles());\n        scalaModel.setScalaCompileOptions(create(scalaCompile.getScalaCompileOptions()));\n        scalaModel.setTargetCompatibility(scalaCompile.getTargetCompatibility());\n        scalaModel.setSourceCompatibility(scalaCompile.getSourceCompatibility());\n        break;\n      }\n    }\n\n    return scalaModel;\n  }","id":31942,"modified_method":"@Override\n  public Object buildAll(String modelName, Project project) {\n    final ScalaPlugin scalaPlugin = project.getPlugins().findPlugin(ScalaPlugin.class);\n\n    ScalaModel scalaModel = null;\n    if (scalaPlugin != null) {\n      Task scalaTask = project.getTasks().getByName(COMPILE_SCALA_TASK);\n      scalaModel = createModel(scalaTask);\n    }\n    else {\n      Iterator<ScalaCompile> it = project.getTasks().withType(ScalaCompile.class).iterator();\n      if (it.hasNext()) {\n        scalaModel = createModel(it.next());\n      }\n    }\n\n    return scalaModel;\n  }","commit_id":"c58a9f876ed725bfe55c5365c11145b1b0e42d6c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * TODO: DOCUMENT Bootstrap.java\n   */\n  @SuppressWarnings( \"deprecation\" )\n  public static void initBootstrappers( ) {\n    for ( Bootstrapper bootstrap : BootstrapperDiscovery.getBootstrappers( ) ) {//these have all been checked at discovery time\n      com.eucalyptus.bootstrap.Component comp;\n      String bc = bootstrap.getClass( ).getCanonicalName( );\n      Bootstrap.Stage stage = bootstrap.getBootstrapStage( );\n      comp = bootstrap.getProvides( );\n      Component component = Components.lookup( comp.name( ) );\n      if ( Components.delegate.any.equals( comp ) ) {\n        for( Component c : Components.list( ) ) {\n          if ( !bootstrap.checkLocal( ) ) {\n            EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", component.getName( ),\n                              \"Component.\" + component.getName( ) + \".isLocal\", component.isLocal( ).toString( ) ).info( );\n          } else if ( !bootstrap.checkRemote( ) ) {\n            EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", component.getName( ),\n                              \"Component.\" + component.getName( ) + \".isLocal\", component.isLocal( ).toString( ) ).info( );\n          } else {\n            c.getBootstrapper( ).addBootstrapper( bootstrap );\n          }\n        }\n      } else if ( Components.delegate.bootstrap.equals( comp ) ) {\n        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_ADDED, stage.name( ), bc, \"component=\" + component.getName( ) ).info( );\n        if ( !bootstrap.checkLocal( ) ) {\n          EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", component.getName( ),\n                            \"Component.\" + component.getName( ) + \".isLocal\", component.isLocal( ).toString( ) ).info( );\n        } else if ( !bootstrap.checkRemote( ) ) {\n          EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", component.getName( ),\n                            \"Component.\" + component.getName( ) + \".isLocal\", component.isLocal( ).toString( ) ).info( );\n        } else {\n          stage.addBootstrapper( bootstrap );\n        }\n      } else {\n        Components.lookup( comp ).getBootstrapper( ).addBootstrapper( bootstrap );\n      } \n    }\n  }","id":31943,"modified_method":"/**\n   * TODO: DOCUMENT Bootstrap.java\n   */\n  @SuppressWarnings( \"deprecation\" )\n  public static void initBootstrappers( ) {\n    for ( Bootstrapper bootstrap : BootstrapperDiscovery.getBootstrappers( ) ) {//these have all been checked at discovery time\n      com.eucalyptus.bootstrap.Component comp;\n      String bc = bootstrap.getClass( ).getCanonicalName( );\n      Bootstrap.Stage stage = bootstrap.getBootstrapStage( );\n      comp = bootstrap.getProvides( );\n      if ( Components.delegate.any.equals( comp ) ) {\n        for( Component c : Components.list( ) ) {\n          if ( !bootstrap.checkLocal( ) ) {\n            EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", bootstrap.getDependsLocal( ).toString( ) ).info( );\n          } else if ( !bootstrap.checkRemote( ) ) {\n            EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", bootstrap.getDependsRemote( ).toString( ) ).info( );\n          } else {\n            EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_ADDED, stage.name( ), bc, \"component=\" + c.getName( ) ).info( );\n            c.getBootstrapper( ).addBootstrapper( bootstrap );\n          }\n        }\n      } else if ( Components.delegate.bootstrap.equals( comp ) ) {\n        if ( !bootstrap.checkLocal( ) ) {\n          EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", bootstrap.getDependsLocal( ).toString( ) ).info( );\n        } else if ( !bootstrap.checkRemote( ) ) {\n          EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", bootstrap.getDependsRemote( ).toString( ) ).info( );\n        } else {\n          EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_ADDED, stage.name( ), bc, \"component=\" + comp.name( ) ).info( );\n          stage.addBootstrapper( bootstrap );\n        }\n      } else {\n        Components.lookup( comp ).getBootstrapper( ).addBootstrapper( bootstrap );\n      } \n    }\n  }","commit_id":"33a74852c104502ce1e430ad671eb92ecf2ff78c","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * TODO: DOCUMENT Bootstrap.java\n   */\n  @SuppressWarnings( \"deprecation\" )\n  public static void initBootstrappers( ) {\n    for( com.eucalyptus.bootstrap.Component comp : com.eucalyptus.bootstrap.Component.values( ) ) {\n      if( !Components.contains( comp ) && !comp.any.equals( comp ) ) {\n        try {\n          Components.create( comp.name( ), null );\n        } catch ( ServiceRegistrationException ex ) {\n          LOG.error( ex , ex );\n        }\n      }\n    }\n    for ( Bootstrapper bootstrap : BootstrapperDiscovery.getBootstrappers( ) ) {//these have all been checked at discovery time\n      com.eucalyptus.bootstrap.Component comp;\n      String bc = bootstrap.getClass( ).getCanonicalName( );\n      Bootstrap.Stage stage = bootstrap.getBootstrapStage( );\n      comp = bootstrap.getProvides( );\n      if ( Components.delegate.any.equals( comp ) ) {\n        for( Component c : Components.list( ) ) {\n          c.getBootstrapper( ).addBootstrapper( bootstrap );\n        }\n      } else if ( Components.delegate.bootstrap.equals( comp ) ) {\n        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_ADDED, stage.name( ), bc, \"component=\" + comp.name( ) ).info( );\n        stage.addBootstrapper( bootstrap );\n      } else if ( !comp.isCloudLocal( ) && !comp.isEnabled( ) && Components.contains( comp ) ) { //report skipping a bootstrapper for an enabled component\n        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"Provides\", comp.name( ),\n                          \"Component.\" + comp.name( ) + \".isEnabled\", comp.isEnabled( ).toString( ) ).info( );\n      } else if ( !bootstrap.checkLocal( ) ) {\n        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", comp.name( ),\n                          \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n      } else if ( !bootstrap.checkRemote( ) ) {\n        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", comp.name( ),\n                          \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n      } else {\n        Components.lookup( comp ).getBootstrapper( ).addBootstrapper( bootstrap );\n      } \n    }\n  }","id":31944,"modified_method":"/**\n   * TODO: DOCUMENT Bootstrap.java\n   */\n  @SuppressWarnings( \"deprecation\" )\n  public static void initBootstrappers( ) {\n    for( com.eucalyptus.bootstrap.Component comp : com.eucalyptus.bootstrap.Component.values( ) ) {\n      if( !Components.contains( comp ) && !comp.any.equals( comp ) ) {\n        try {\n          Components.create( comp.name( ), null );\n        } catch ( ServiceRegistrationException ex ) {\n          LOG.error( ex , ex );\n        }\n      }\n    }\n    for ( Bootstrapper bootstrap : BootstrapperDiscovery.getBootstrappers( ) ) {//these have all been checked at discovery time\n      com.eucalyptus.bootstrap.Component comp;\n      String bc = bootstrap.getClass( ).getCanonicalName( );\n      Bootstrap.Stage stage = bootstrap.getBootstrapStage( );\n      comp = bootstrap.getProvides( );\n      if ( Components.delegate.any.equals( comp ) ) {\n        for( Component c : Components.list( ) ) {\n          if ( !bootstrap.checkLocal( ) ) {\n            EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", comp.name( ),\n                              \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n          } else if ( !bootstrap.checkRemote( ) ) {\n            EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", comp.name( ),\n                              \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n          } else {\n            c.getBootstrapper( ).addBootstrapper( bootstrap );\n          }\n        }\n      } else if ( Components.delegate.bootstrap.equals( comp ) ) {\n        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_ADDED, stage.name( ), bc, \"component=\" + comp.name( ) ).info( );\n        if ( !bootstrap.checkLocal( ) ) {\n          EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", comp.name( ),\n                            \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n        } else if ( !bootstrap.checkRemote( ) ) {\n          EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", comp.name( ),\n                            \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n        } else {\n          stage.addBootstrapper( bootstrap );\n        }\n//      } else if ( !comp.isCloudLocal( ) && !comp.isEnabled( ) && Components.contains( comp ) ) { //report skipping a bootstrapper for an enabled component\n//        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"Provides\", comp.name( ),\n//                          \"Component.\" + comp.name( ) + \".isEnabled\", comp.isEnabled( ).toString( ) ).info( );\n//      } else if ( !bootstrap.checkLocal( ) ) {\n//        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsLocal\", comp.name( ),\n//                          \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n//      } else if ( !bootstrap.checkRemote( ) ) {\n//        EventRecord.here( Bootstrap.class, EventType.BOOTSTRAPPER_SKIPPED, currentStage.name( ), bc, \"DependsRemote\", comp.name( ),\n//                          \"Component.\" + comp.name( ) + \".isLocal\", comp.isLocal( ).toString( ) ).info( );\n      } else {\n        Components.lookup( comp ).getBootstrapper( ).addBootstrapper( bootstrap );\n      } \n    }\n  }","commit_id":"0b4a30a3186db3fc921730aab7b7a2d910693f1c","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"Key getKey(byte [] desiredKeyIdentifier) {\n\t\tKey theKey = _keyMap.get(desiredKeyIdentifier);\n\t\tif (null == theKey) {\n\t\t\ttheKey = _privateKeyMap.get(desiredKeyIdentifier);\n\t\t}\n\t\tif (null == theKey) {\n\t\t\ttheKey = _myKeyMap.get(desiredKeyIdentifier);\n\t\t}\n\t\treturn theKey;\n\t}","id":31945,"modified_method":"Key getKey(byte [] desiredKeyIdentifier) {\n\t\tString desiredKeyIdentifierAsString = new String(desiredKeyIdentifier);\n\t\tKey theKey = _keyMap.get(desiredKeyIdentifierAsString);\n\t\tif (null == theKey) {\n\t\t\ttheKey = _privateKeyMap.get(desiredKeyIdentifierAsString);\n\t\t}\n\t\tif (null == theKey) {\n\t\t\ttheKey = _myKeyMap.get(desiredKeyIdentifierAsString);\n\t\t}\n\t\treturn theKey;\n\t}","commit_id":"aeb948acd73ca34977afc1983dd21d5b8d9c2ecd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"void addMyPrivateKey(byte [] publicKeyIdentifier, PrivateKey pk) {\n\t\t_privateKeyIdentifierMap.put(getKeyIdentifier(pk), publicKeyIdentifier);\n\t\t_myKeyMap.put(publicKeyIdentifier, pk);\n\t}","id":31946,"modified_method":"void addMyPrivateKey(byte [] publicKeyIdentifier, PrivateKey pk) {\n\t\tString publicKeyIdentifierAsString = new String(publicKeyIdentifier);\n\t\tString privateKeyIdentifierAsString = new String(getKeyIdentifier(pk));\n\t\t_privateKeyIdentifierMap.put(privateKeyIdentifierAsString, publicKeyIdentifierAsString);\n\t\t_myKeyMap.put(publicKeyIdentifierAsString, pk);\n\t}","commit_id":"aeb948acd73ca34977afc1983dd21d5b8d9c2ecd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"void addPrivateKey(ContentName keyName, byte [] publicKeyIdentifier, PrivateKey pk) {\n\t\t_privateKeyMap.put(publicKeyIdentifier, pk);\n\t\t_privateKeyIdentifierMap.put(getKeyIdentifier(pk), publicKeyIdentifier);\n\t\tif (null != keyName)\n\t\t\t_keyNameMap.put(publicKeyIdentifier, keyName);\n\t}","id":31947,"modified_method":"void addPrivateKey(ContentName keyName, byte [] publicKeyIdentifier, PrivateKey pk) {\n\t\tString publicKeyIdentifierAsString = new String(publicKeyIdentifier);\n\t\t_privateKeyMap.put(publicKeyIdentifierAsString, pk);\n\t\tString privateKeyIdentifierAsString = new String(getKeyIdentifier(pk));\n\t\t_privateKeyIdentifierMap.put(privateKeyIdentifierAsString, publicKeyIdentifierAsString);\n\t\tif (null != keyName)\n\t\t\t_keyNameMap.put(publicKeyIdentifierAsString, keyName);\n\t}","commit_id":"aeb948acd73ca34977afc1983dd21d5b8d9c2ecd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public boolean containsKey(byte [] keyIdentifier) {\n\t\tif ((_keyMap.containsKey(keyIdentifier)) || (_myKeyMap.containsKey(keyIdentifier)) ||\n\t\t\t\t\t(_privateKeyMap.containsKey(keyIdentifier))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":31948,"modified_method":"public boolean containsKey(byte [] keyIdentifier) {\n\t\tString keyIdentifierAsString = new String(keyIdentifier);\n\t\tif ((_keyMap.containsKey(keyIdentifierAsString)) || (_myKeyMap.containsKey(keyIdentifierAsString)) ||\n\t\t\t\t\t(_privateKeyMap.containsKey(keyIdentifierAsString))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"aeb948acd73ca34977afc1983dd21d5b8d9c2ecd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public ContentName getKeyName(byte [] keyIdentifier) {\n\t\treturn _keyNameMap.get(keyIdentifier);\n\t}","id":31949,"modified_method":"public ContentName getKeyName(byte [] keyIdentifier) {\n\t\tString keyIdentifierAsString = new String(keyIdentifier);\n\t\treturn _keyNameMap.get(keyIdentifierAsString);\n\t}","commit_id":"aeb948acd73ca34977afc1983dd21d5b8d9c2ecd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void addKey(ContentName name, Key key) {\n\t\tbyte [] id = getKeyIdentifier(key);\n\t\t_keyMap.put(id, key);\n\t\t_keyNameMap.put(id, name);\n\t}","id":31950,"modified_method":"public void addKey(ContentName name, Key key) {\n\t\tString id = new String(getKeyIdentifier(key));\n\t\t_keyMap.put(id, key);\n\t\t_keyNameMap.put(id, name);\n\t}","commit_id":"aeb948acd73ca34977afc1983dd21d5b8d9c2ecd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"PrivateKey getPrivateKey(byte [] desiredPublicKeyIdentifier) {\n\t\tPrivateKey key = _myKeyMap.get(desiredPublicKeyIdentifier);\n\t\tif (null == key) {\n\t\t\t_privateKeyMap.get(desiredPublicKeyIdentifier);\n\t\t}\n\t\treturn key;\n\t}","id":31951,"modified_method":"PrivateKey getPrivateKey(byte [] desiredPublicKeyIdentifier) {\n\t\tString desiredPublicKeyIdentifierAsString = new String(desiredPublicKeyIdentifier);\n\t\tPrivateKey key = _myKeyMap.get(desiredPublicKeyIdentifierAsString);\n\t\tif (null == key) {\n\t\t\t_privateKeyMap.get(desiredPublicKeyIdentifierAsString);\n\t\t}\n\t\treturn key;\n\t}","commit_id":"aeb948acd73ca34977afc1983dd21d5b8d9c2ecd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@SuppressWarnings(\"StringConcatenationInsideStringBufferAppend\")\n  @NotNull\n  private static String makeDescription(@NotNull Collection<VcsRootError> unregisteredRoots,\n                                        @NotNull Collection<VcsRootError> invalidRoots) {\n    Function<VcsRootError, String> rootToDisplayableString = new Function<VcsRootError, String>() {\n      @Override\n      public String fun(VcsRootError rootError) {\n        if (rootError.getMapping().equals(VcsDirectoryMapping.PROJECT_CONSTANT)) {\n          return StringUtil.escapeXml(rootError.getMapping());\n        }\n        return FileUtil.toSystemDependentName(rootError.getMapping());\n      }\n    };\n\n    StringBuilder description = new StringBuilder();\n    if (!invalidRoots.isEmpty()) {\n      if (invalidRoots.size() == 1) {\n        VcsRootError rootError = invalidRoots.iterator().next();\n        description\n          .append(\"The directory \" + rootToDisplayableString.fun(rootError) + \" is registered as a \" + rootError.getVcsKey() + \" root, \" +\n                  \"but no \" + rootError.getVcsKey() + \" repositories were found there.\");\n      }\n      else {\n        description.append(\"The following directories are registered as Vcs roots, but they are not: <br/>\" +\n                           StringUtil.join(invalidRoots, rootToDisplayableString, \", \"));\n      }\n      description.append(\"<br/>\");\n    }\n\n    if (!unregisteredRoots.isEmpty()) {\n      if (unregisteredRoots.size() == 1) {\n        VcsRootError unregisteredRoot = unregisteredRoots.iterator().next();\n        description\n          .append(\"The directory \" + rootToDisplayableString.fun(unregisteredRoot) + \" is under \" + unregisteredRoot.getVcsKey() + \", \" +\n                  \"but is not registered in the Settings.\");\n      }\n      else {\n        description.append(\"The following directories are roots of Vcs repositories, but they are not registered in the Settings: <br/>\" +\n                           StringUtil.join(unregisteredRoots, rootToDisplayableString, \", \"));\n      }\n      description.append(\"<br/>\");\n    }\n\n    description.append(\"<a href='configure'>Configure<\/a>&nbsp;&nbsp;<a href='ignore'>Ignore VCS root errors<\/a>\");\n\n    return description.toString();\n  }","id":31952,"modified_method":"@SuppressWarnings(\"StringConcatenationInsideStringBufferAppend\")\n  @NotNull\n  private static String makeDescription(@NotNull Collection<VcsRootError> unregisteredRoots,\n                                        @NotNull Collection<VcsRootError> invalidRoots) {\n    Function<VcsRootError, String> rootToDisplayableString = new Function<VcsRootError, String>() {\n      @Override\n      public String fun(VcsRootError rootError) {\n        if (rootError.getMapping().equals(VcsDirectoryMapping.PROJECT_CONSTANT)) {\n          return StringUtil.escapeXml(rootError.getMapping());\n        }\n        return FileUtil.toSystemDependentName(rootError.getMapping());\n      }\n    };\n\n    StringBuilder description = new StringBuilder();\n    if (!invalidRoots.isEmpty()) {\n      if (invalidRoots.size() == 1) {\n        VcsRootError rootError = invalidRoots.iterator().next();\n        description\n          .append(\"The directory \" +\n                  rootToDisplayableString.fun(rootError) +\n                  \" is registered as a \" +\n                  rootError.getVcsKey().getName() +\n                  \" root, \" +\n                  \"but no \" +\n                  rootError.getVcsKey().getName() +\n                  \" repositories were found there.\");\n      }\n      else {\n        description.append(\"The following directories are registered as Vcs roots, but they are not: <br/>\" +\n                           StringUtil.join(invalidRoots, rootToDisplayableString, \", \"));\n      }\n      description.append(\"<br/>\");\n    }\n\n    if (!unregisteredRoots.isEmpty()) {\n      if (unregisteredRoots.size() == 1) {\n        VcsRootError unregisteredRoot = unregisteredRoots.iterator().next();\n        description\n          .append(\"The directory \" +\n                  rootToDisplayableString.fun(unregisteredRoot) +\n                  \" is under \" +\n                  unregisteredRoot.getVcsKey().getName() +\n                  \", \" +\n                  \"but is not registered in the Settings.\");\n      }\n      else {\n        description.append(\"The following directories are roots of Vcs repositories, but they are not registered in the Settings: <br/>\" +\n                           StringUtil.join(unregisteredRoots, rootToDisplayableString, \", \"));\n      }\n      description.append(\"<br/>\");\n    }\n\n    description.append(\"<a href='configure'>Configure<\/a>&nbsp;&nbsp;<a href='ignore'>Ignore VCS root errors<\/a>\");\n\n    return description.toString();\n  }","commit_id":"f1d78bd50e26e89e50d44772af0174eac4f991fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Group( double ds[] ) { _ds = ds; _hash=hash(); }","id":31953,"modified_method":"public Group( double ds[] ) { _ds = ds; _hash=hash(); }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private int[] nextModel( int[] hidx ) {\n      // Find the next parm to flip\n      int i;\n      for( i=0; i<hidx.length; i++ )\n        if( hidx[i]<_hyperSearch[i].length )\n          break;\n      if( i==hidx.length ) return null; // All done, report null\n      // Flip indices\n      for( int j=0; j<i; j++ ) hidx[j]=0;\n      hidx[i]++;\n      return hidx;\n    }","id":31954,"modified_method":"private int[] nextModel( int[] hidx ) {\n      // Find the next parm to flip\n      int i;\n      for( i=0; i<hidx.length; i++ )\n        if( hidx[i]+1 < _hyperSearch[i].length )\n          break;\n      if( i==hidx.length ) return null; // All done, report null\n      // Flip indices\n      for( int j=0; j<i; j++ ) hidx[j]=0;\n      hidx[i]++;\n      return hidx;\n    }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** @param hypers A set of hyper parameter values\n   *  @return A model run with these parameters, typically built on demand and\n   *  not cached - expected to be an expensive operation.  If the model in question\n   *  is \"in progress\", a 2nd build will NOT be kicked off.  This is a blocking call. */\n  public Model buildModel( double[] hypers ) {\n    Job<Model> jm = startBuildModel(hypers);\n    return jm==null ? model(hypers) : jm.get();\n  }","id":31955,"modified_method":"/** @param hypers A set of hyper parameter values\n   *  @return A model run with these parameters, typically built on demand and\n   *  not cached - expected to be an expensive operation.  If the model in question\n   *  is \"in progress\", a 2nd build will NOT be kicked off.  This is a blocking call. */\n  public Model buildModel( double[] hypers ) {\n    Model m = model(hypers);\n    if( m != null ) return m;\n    m = (Model)(startBuildModel(hypers).get());\n    _cache.put(new Group(hypers.clone()),m);\n    return m;\n  }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** @param hypers A set of hyper parameter values\n   *  @return A model run with these parameters, or null if the model does not exist. */\n  public Model model( double[] hypers ) { \n    throw H2O.unimpl(); \n  }","id":31956,"modified_method":"/** @param hypers A set of hyper parameter values\n   *  @return A model run with these parameters, or null if the model does not exist. */\n  public Model model( double[] hypers ) { return _cache.get(new Group(hypers)); }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected Futures remove_impl( Futures fs ) { throw H2O.unimpl(); }","id":31957,"modified_method":"@Override protected Futures remove_impl( Futures fs ) {\n    for( Model m : _cache.values() )\n      m.remove(fs);\n    _cache.clear();\n    return fs;\n  }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"void gridSearch() {\n      double[] hypers = new double[nHyperParms()];\n      for( int[] hidx = new int[nHyperParms()]; hidx != null; hidx = nextModel(hidx) ) {\n       if( !isRunning() ) { cancel(); return; }\n       buildModel(hypers(hidx,hypers));\n      }\n      done();\n    }","id":31958,"modified_method":"private void gridSearch() {\n      double[] hypers = new double[nHyperParms()];\n      for( int[] hidx = new int[nHyperParms()]; hidx != null; hidx = nextModel(hidx) ) {\n        if( !isRunning() ) { cancel(); return; }\n        buildModel(hypers(hidx,hypers));\n      }\n      done();\n    }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** @param hypers A set of hyper parameter values\n   *  @return A Future of a model run with these parameters, typically built on\n   *  demand and not cached - expected to be an expensive operation.  If the\n   *  model in question is \"in progress\", a 2nd build will NOT be kicked off.\n   *  This is a non-blocking call. */\n  public Job<Model> startBuildModel( double[] hypers ) {\n    if( model(hypers) != null ) return null; // Model already built\n    throw H2O.unimpl(); \n  }","id":31959,"modified_method":"/** @param hypers A set of hyper parameter values\n   *  @return A Future of a model run with these parameters, typically built on\n   *  demand and not cached - expected to be an expensive operation.  If the\n   *  model in question is \"in progress\", a 2nd build will NOT be kicked off.\n   *  This is a non-blocking call. */\n  public ModelBuilder startBuildModel( double[] hypers ) {\n    if( model(hypers) != null ) return null;\n    ModelBuilder mb = getBuilder(hypers);\n    mb.trainModel();\n    return mb;\n  }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"GridSearch( Key gkey, double[][] hyperSearch ) {\n      super(Key.make(\"GridSearch_\"+modelName()+Key.rand()), gkey, modelName()+\" Grid Search\");\n      _hyperSearch = hyperSearch;\n    }","id":31960,"modified_method":"GridSearch( Key gkey, double[][] hyperSearch ) {\n      super(Key.make(\"GridSearch_\"+modelName()+Key.rand()), gkey, modelName()+\" Grid Search\");\n      _hyperSearch = hyperSearch;\n      // Replace null hyperparameters with the model default\n      for( int i=0; i<_hyperSearch.length; i++ )\n        if( _hyperSearch[i] == null )\n          _hyperSearch[i] = new double[]{hyperDefault(i)};\n      // Count of models in this search\n      int work = 1;\n      for( double hparms[] : _hyperSearch )\n        work *= hparms.length;\n      _total_models = work;\n\n      // Check all parameter combos for validity\n      double[] hypers = new double[nHyperParms()];\n      for( int[] hidx = new int[nHyperParms()]; hidx != null; hidx = nextModel(hidx) ) {\n        ModelBuilder mb = getBuilder(hypers(hidx,hypers));\n        mb.init(false);\n        if( mb.error_count() > 0 ) \n          throw new IllegalArgumentException(mb.validationErrors());\n      }\n    }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"GridSearch start() {\n      // Replace null hyperparameters with the model default\n      for( int i=0; i<_hyperSearch.length; i++ )\n        if( _hyperSearch[i] == null )\n          _hyperSearch[i] = new double[]{hyperDefault(i)};\n      // Work is 1 for every model to be built\n      long work = 1;\n      for( double hparms[] : _hyperSearch )\n        work *= hparms.length;\n      start(new H2OCountedCompleter() { @Override public void compute2() { gridSearch(); tryComplete(); } },work);\n      return this;\n    }","id":31961,"modified_method":"GridSearch start() {\n      start(new H2OCountedCompleter() { @Override public void compute2() { gridSearch(); tryComplete(); } },_total_models);\n      return this;\n    }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected String modelName() { return MODEL_NAME; }","id":31962,"modified_method":"/** @return Model name */\n  @Override protected String modelName() { return MODEL_NAME; }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test @Ignore public void testIrisGrid() {\n    KMeansGrid kmg = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"smalldata/iris/iris_wheader.csv\");\n\n      // Get the Grid for this modeling class and frame\n      kmg = KMeansGrid.get(fr);\n\n      // 4-dimensioanl hyperparameter search\n      assert kmg.nHyperParms()==4;\n\n      // Search over this range of K's\n      assert kmg.hyperName(0).equals(\"k\");\n      double[] ks = new double[]{0,1,2,3,4,5,6}; // Note that k==0 is illegal, and k==1 is trivial\n\n      // Search over this range of the standardize flag\n      assert kmg.hyperName(1).equals(\"standardize\");\n      double[] stds = null;     // null means: take the default, no search\n\n      // Search over this range of the init enum\n      assert kmg.hyperName(2).equals(\"init\");\n      double[] inits = new double[]{KMeans.Initialization.Random.ordinal(),1,2}; // Random, PlusPlus,Furthest, not User\n\n      // Search over this range of the init enum\n      assert kmg.hyperName(3).equals(\"seed\");\n      double[] seeds = new double[]{0,1,123456789,987654321};\n\n      // Fire off a grid search\n      Job<Grid> jg = kmg.startGridSearch(new double[][]{ks,stds,inits,seeds});\n      Grid g2 = jg.get();\n      assert g2==kmg;\n\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( kmg != null ) kmg.remove();\n    }\n  }","id":31963,"modified_method":"@Test @Ignore public void testIrisGrid() {\n    KMeansGrid kmg = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"smalldata/iris/iris_wheader.csv\");\n\n      // Get the Grid for this modeling class and frame\n      kmg = KMeansGrid.get(fr);\n\n      // 4-dimensioanl hyperparameter search\n      assert kmg.nHyperParms()==4;\n\n      // Search over this range of K's\n      assert kmg.hyperName(0).equals(\"k\");\n      double[] ks = new double[]{1,2,3,4,5,6}; // Note that k==0 is illegal, and k==1 is trivial\n\n      // Search over this range of the standardize flag\n      assert kmg.hyperName(1).equals(\"standardize\");\n      double[] stds = null;     // null means: take the default, no search\n\n      // Search over this range of the init enum\n      assert kmg.hyperName(2).equals(\"init\");\n      double[] inits = new double[]{KMeans.Initialization.Random.ordinal(),1,2}; // Random, PlusPlus,Furthest, not User\n\n      // Search over this range of the init enum\n      assert kmg.hyperName(3).equals(\"seed\");\n      double[] seeds = new double[]{0,1,123456789,987654321};\n\n      // Fire off a grid search\n      Grid.GridSearch gs = kmg.startGridSearch(new double[][]{ks,stds,inits,seeds});\n      Grid g2 = (Grid)gs.get();\n      assert g2==kmg;\n\n      // Print out the models from this grid search\n      Model[] ms = gs.models();\n      String[][] sss = gs.toStrings();\n      for( int i=0; i<ms.length; i++ ) {\n        KMeansModel kmm = (KMeansModel)ms[i];\n        for( int j=0; j<sss[i].length; j++ )\n          System.out.print(sss[i][j]+\" \");\n        System.out.println(kmm._output._avg_within_ss);\n      }\n\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( kmg != null ) kmg.remove();\n    }\n  }","commit_id":"01461e1268cbe52f5d0e0f8ce740200dd1d82ec5","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected BooleanFilter doGetPermissionFilter_6(\n\t\t\tlong companyId, long[] groupIds, long userId, String className,\n\t\t\tBooleanFilter booleanFilter, Set<Group> groups, Set<Role> roles,\n\t\t\tSet<UserGroupRole> userGroupRoles,\n\t\t\tMap<Long, List<Role>> groupIdsToRoles)\n\t\tthrows Exception {\n\n\t\tBooleanFilter permissionBooleanFilter = new BooleanFilter();\n\n\t\tif (userId > 0) {\n\t\t\tpermissionBooleanFilter.addTerm(Field.USER_ID, userId);\n\t\t}\n\n\t\tTermsFilter groupsTermsFilter = new TermsFilter(Field.GROUP_ID);\n\t\tTermsFilter groupRolesTermsFilter = new TermsFilter(\n\t\t\tField.GROUP_ROLE_ID);\n\t\tTermsFilter rolesTermsFilter = new TermsFilter(Field.ROLE_ID);\n\n\t\tfor (Role role : roles) {\n\t\t\tString roleName = role.getName();\n\n\t\t\tif (roleName.equals(RoleConstants.ADMINISTRATOR)) {\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tif (ResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_COMPANY,\n\t\t\t\t\tString.valueOf(companyId), role.getRoleId(),\n\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tif ((role.getType() == RoleConstants.TYPE_REGULAR) &&\n\t\t\t\tResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\tcompanyId, className,\n\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\trole.getRoleId(), ActionKeys.VIEW)) {\n\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tfor (Group group : groups) {\n\t\t\t\tif (ResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\tString.valueOf(group.getGroupId()), role.getRoleId(),\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\tgroupsTermsFilter.addValue(\n\t\t\t\t\t\tString.valueOf(group.getGroupId()));\n\t\t\t\t}\n\n\t\t\t\tif ((role.getType() != RoleConstants.TYPE_REGULAR) &&\n\t\t\t\t\tResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className,\n\t\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\t\trole.getRoleId(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tList<Role> groupRoles = groupIdsToRoles.get(\n\t\t\t\t\t\tgroup.getGroupId());\n\n\t\t\t\t\tif (groupRoles.contains(role)) {\n\t\t\t\t\t\tgroupsTermsFilter.addValue(\n\t\t\t\t\t\t\tString.valueOf(group.getGroupId()));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (group.isSite() &&\n\t\t\t\t\t!roleName.equals(RoleConstants.SITE_MEMBER) &&\n\t\t\t\t\t(role.getType() == RoleConstants.TYPE_SITE)) {\n\n\t\t\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\t\t\tgroup.getGroupId() + StringPool.DASH +\n\t\t\t\t\t\t\trole.getRoleId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ArrayUtil.isNotEmpty(groupIds)) {\n\t\t\t\tfor (long groupId : groupIds) {\n\t\t\t\t\tif (ResourcePermissionLocalServiceUtil.\n\t\t\t\t\t\t\thasResourcePermission(\n\t\t\t\t\t\t\t\tcompanyId, className,\n\t\t\t\t\t\t\t\tResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\t\t\tString.valueOf(groupId), role.getRoleId(),\n\t\t\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trolesTermsFilter.addValue(String.valueOf(role.getRoleId()));\n\t\t}\n\n\t\tfor (Group group : groups) {\n\t\t\taddRequiredMemberRole(group, groupRolesTermsFilter);\n\t\t}\n\n\t\tfor (UserGroupRole userGroupRole : userGroupRoles) {\n\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\tuserGroupRole.getGroupId() + StringPool.DASH +\n\t\t\t\t\tuserGroupRole.getRoleId());\n\t\t}\n\n\t\tif (!groupsTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupsTermsFilter);\n\t\t}\n\n\t\tif (!groupRolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupRolesTermsFilter);\n\t\t}\n\n\t\tif (!rolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(rolesTermsFilter);\n\t\t}\n\n\t\tif (!permissionBooleanFilter.hasClauses()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tBooleanFilter fullBooleanFilter = new BooleanFilter();\n\n\t\tif ((booleanFilter != null) && booleanFilter.hasClauses()) {\n\t\t\tfullBooleanFilter.add(booleanFilter, BooleanClauseOccur.MUST);\n\t\t}\n\n\t\tfullBooleanFilter.add(permissionBooleanFilter, BooleanClauseOccur.MUST);\n\n\t\treturn fullBooleanFilter;\n\t}","id":31964,"modified_method":"protected BooleanFilter doGetPermissionFilter_6(\n\t\t\tlong companyId, long[] groupIds, long userId, String className,\n\t\t\tBooleanFilter booleanFilter, Set<Group> groups, Set<Role> roles,\n\t\t\tSet<UserGroupRole> userGroupRoles,\n\t\t\tMap<Long, List<Role>> groupIdsToRoles,\n\t\t\tAdvancedPermissionChecker advancedPermissionChecker)\n\t\tthrows Exception {\n\n\t\tBooleanFilter permissionBooleanFilter = new BooleanFilter();\n\n\t\tif (userId > 0) {\n\t\t\tpermissionBooleanFilter.addTerm(Field.USER_ID, userId);\n\t\t}\n\n\t\tTermsFilter groupsTermsFilter = new TermsFilter(Field.GROUP_ID);\n\t\tTermsFilter groupRolesTermsFilter = new TermsFilter(\n\t\t\tField.GROUP_ROLE_ID);\n\t\tTermsFilter rolesTermsFilter = new TermsFilter(Field.ROLE_ID);\n\n\t\tfor (Role role : roles) {\n\t\t\tString roleName = role.getName();\n\n\t\t\tif (roleName.equals(RoleConstants.ADMINISTRATOR)) {\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tif (ResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_COMPANY,\n\t\t\t\t\tString.valueOf(companyId), role.getRoleId(),\n\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tif ((role.getType() == RoleConstants.TYPE_REGULAR) &&\n\t\t\t\tResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\tcompanyId, className,\n\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\trole.getRoleId(), ActionKeys.VIEW)) {\n\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tfor (Group group : groups) {\n\t\t\t\tif (advancedPermissionChecker.isGroupAdmin(\n\t\t\t\t\t\tgroup.getGroupId()) ||\n\t\t\t\t\tResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\tString.valueOf(group.getGroupId()), role.getRoleId(),\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\tgroupsTermsFilter.addValue(\n\t\t\t\t\t\tString.valueOf(group.getGroupId()));\n\t\t\t\t}\n\n\t\t\t\tif ((role.getType() != RoleConstants.TYPE_REGULAR) &&\n\t\t\t\t\tResourcePermissionLocalServiceUtil.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className,\n\t\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\t\trole.getRoleId(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tList<Role> groupRoles = groupIdsToRoles.get(\n\t\t\t\t\t\tgroup.getGroupId());\n\n\t\t\t\t\tif (groupRoles.contains(role)) {\n\t\t\t\t\t\tgroupsTermsFilter.addValue(\n\t\t\t\t\t\t\tString.valueOf(group.getGroupId()));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (group.isSite() &&\n\t\t\t\t\t!roleName.equals(RoleConstants.SITE_MEMBER) &&\n\t\t\t\t\t(role.getType() == RoleConstants.TYPE_SITE)) {\n\n\t\t\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\t\t\tgroup.getGroupId() + StringPool.DASH +\n\t\t\t\t\t\t\trole.getRoleId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ArrayUtil.isNotEmpty(groupIds)) {\n\t\t\t\tfor (long groupId : groupIds) {\n\t\t\t\t\tif (ResourcePermissionLocalServiceUtil.\n\t\t\t\t\t\t\thasResourcePermission(\n\t\t\t\t\t\t\t\tcompanyId, className,\n\t\t\t\t\t\t\t\tResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\t\t\tString.valueOf(groupId), role.getRoleId(),\n\t\t\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trolesTermsFilter.addValue(String.valueOf(role.getRoleId()));\n\t\t}\n\n\t\tfor (Group group : groups) {\n\t\t\taddRequiredMemberRole(group, groupRolesTermsFilter);\n\t\t}\n\n\t\tfor (UserGroupRole userGroupRole : userGroupRoles) {\n\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\tuserGroupRole.getGroupId() + StringPool.DASH +\n\t\t\t\t\tuserGroupRole.getRoleId());\n\t\t}\n\n\t\tif (!groupsTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupsTermsFilter);\n\t\t}\n\n\t\tif (!groupRolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupRolesTermsFilter);\n\t\t}\n\n\t\tif (!rolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(rolesTermsFilter);\n\t\t}\n\n\t\tif (!permissionBooleanFilter.hasClauses()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tBooleanFilter fullBooleanFilter = new BooleanFilter();\n\n\t\tif ((booleanFilter != null) && booleanFilter.hasClauses()) {\n\t\t\tfullBooleanFilter.add(booleanFilter, BooleanClauseOccur.MUST);\n\t\t}\n\n\t\tfullBooleanFilter.add(permissionBooleanFilter, BooleanClauseOccur.MUST);\n\n\t\treturn fullBooleanFilter;\n\t}","commit_id":"3426c4a6d6b9bf4fc0c7076b2c0f06715d29e476","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected BooleanFilter doGetPermissionBooleanFilter(\n\t\t\tlong companyId, long[] groupIds, long userId, String className,\n\t\t\tBooleanFilter booleanFilter, SearchContext searchContext)\n\t\tthrows Exception {\n\n\t\tIndexer<?> indexer = IndexerRegistryUtil.getIndexer(className);\n\n\t\tif (!indexer.isPermissionAware()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\tAdvancedPermissionChecker advancedPermissionChecker = null;\n\n\t\tif ((permissionChecker != null) &&\n\t\t\t(permissionChecker instanceof AdvancedPermissionChecker)) {\n\n\t\t\tadvancedPermissionChecker =\n\t\t\t\t(AdvancedPermissionChecker)permissionChecker;\n\t\t}\n\n\t\tif (advancedPermissionChecker == null) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tPermissionCheckerBag permissionCheckerBag = getPermissionCheckerBag(\n\t\t\tadvancedPermissionChecker, userId);\n\n\t\tif (permissionCheckerBag == null) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tSet<Group> groups = new LinkedHashSet<>();\n\t\tSet<Role> roles = new LinkedHashSet<>();\n\t\tSet<UserGroupRole> userGroupRoles = new LinkedHashSet<>();\n\t\tMap<Long, List<Role>> groupIdsToRoles = new HashMap<>();\n\n\t\tpopulate(\n\t\t\tcompanyId, groupIds, userId, advancedPermissionChecker,\n\t\t\tpermissionCheckerBag, groups, roles, userGroupRoles,\n\t\t\tgroupIdsToRoles);\n\n\t\treturn doGetPermissionFilter_6(\n\t\t\tcompanyId, groupIds, userId, className, booleanFilter, groups,\n\t\t\troles, userGroupRoles, groupIdsToRoles);\n\t}","id":31965,"modified_method":"protected BooleanFilter doGetPermissionBooleanFilter(\n\t\t\tlong companyId, long[] groupIds, long userId, String className,\n\t\t\tBooleanFilter booleanFilter, SearchContext searchContext)\n\t\tthrows Exception {\n\n\t\tIndexer<?> indexer = IndexerRegistryUtil.getIndexer(className);\n\n\t\tif (!indexer.isPermissionAware()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\tAdvancedPermissionChecker advancedPermissionChecker = null;\n\n\t\tif ((permissionChecker != null) &&\n\t\t\t(permissionChecker instanceof AdvancedPermissionChecker)) {\n\n\t\t\tadvancedPermissionChecker =\n\t\t\t\t(AdvancedPermissionChecker)permissionChecker;\n\t\t}\n\n\t\tif (advancedPermissionChecker == null) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tPermissionCheckerBag permissionCheckerBag = getPermissionCheckerBag(\n\t\t\tadvancedPermissionChecker, userId);\n\n\t\tif (permissionCheckerBag == null) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tSet<Group> groups = new LinkedHashSet<>();\n\t\tSet<Role> roles = new LinkedHashSet<>();\n\t\tSet<UserGroupRole> userGroupRoles = new LinkedHashSet<>();\n\t\tMap<Long, List<Role>> groupIdsToRoles = new HashMap<>();\n\n\t\tpopulate(\n\t\t\tcompanyId, groupIds, userId, advancedPermissionChecker,\n\t\t\tpermissionCheckerBag, groups, roles, userGroupRoles,\n\t\t\tgroupIdsToRoles);\n\n\t\treturn doGetPermissionFilter_6(\n\t\t\tcompanyId, groupIds, userId, className, booleanFilter, groups,\n\t\t\troles, userGroupRoles, groupIdsToRoles, advancedPermissionChecker);\n\t}","commit_id":"3426c4a6d6b9bf4fc0c7076b2c0f06715d29e476","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected BooleanFilter doGetPermissionFilter_6(\n\t\t\tlong companyId, long[] groupIds, long userId,\n\t\t\tPermissionChecker permissionChecker, String className,\n\t\t\tBooleanFilter booleanFilter, Set<Role> roles,\n\t\t\tMap<Long, List<Role>> groupIdsToRoles)\n\t\tthrows Exception {\n\n\t\tBooleanFilter permissionBooleanFilter = new BooleanFilter();\n\n\t\tif (userId > 0) {\n\t\t\tpermissionBooleanFilter.addTerm(Field.USER_ID, userId);\n\t\t}\n\n\t\tTermsFilter groupsTermsFilter = new TermsFilter(Field.GROUP_ID);\n\t\tTermsFilter groupRolesTermsFilter = new TermsFilter(\n\t\t\tField.GROUP_ROLE_ID);\n\t\tTermsFilter rolesTermsFilter = new TermsFilter(Field.ROLE_ID);\n\n\t\tList<Long> roleIds = new ArrayList<>(roles.size());\n\t\tList<Long> regularRoleIds = new ArrayList<>();\n\n\t\tfor (Role role : roles) {\n\t\t\troleIds.add(role.getRoleId());\n\n\t\t\tif (role.getType() == RoleConstants.TYPE_REGULAR) {\n\t\t\t\tregularRoleIds.add(role.getRoleId());\n\t\t\t}\n\n\t\t\trolesTermsFilter.addValue(String.valueOf(role.getRoleId()));\n\t\t}\n\n\t\tlong[] roleIdsArray = ArrayUtil.toLongArray(roleIds);\n\n\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_COMPANY,\n\t\t\t\tString.valueOf(companyId), roleIdsArray, ActionKeys.VIEW)) {\n\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\tArrayUtil.toLongArray(regularRoleIds), ActionKeys.VIEW)) {\n\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tfor (Map.Entry<Long, List<Role>> entry : groupIdsToRoles.entrySet()) {\n\t\t\tlong groupId = entry.getKey();\n\t\t\tList<Role> groupRoles = entry.getValue();\n\n\t\t\tif (permissionChecker.isGroupAdmin(groupId) ||\n\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\tString.valueOf(groupId), roleIdsArray,\n\t\t\t\t\tActionKeys.VIEW) ||\n\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className,\n\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\tListUtil.toLongArray(groupRoles, Role.ROLE_ID_ACCESSOR),\n\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t}\n\n\t\t\tfor (Role groupRole : groupRoles) {\n\t\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\t\tgroupId + StringPool.DASH + groupRole.getRoleId());\n\t\t\t}\n\t\t}\n\n\t\tif (ArrayUtil.isNotEmpty(groupIds)) {\n\t\t\tfor (long groupId : groupIds) {\n\t\t\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\tString.valueOf(groupId), roleIdsArray,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!groupsTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupsTermsFilter);\n\t\t}\n\n\t\tif (!groupRolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupRolesTermsFilter);\n\t\t}\n\n\t\tif (!rolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(rolesTermsFilter);\n\t\t}\n\n\t\tif (!permissionBooleanFilter.hasClauses()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tBooleanFilter fullBooleanFilter = new BooleanFilter();\n\n\t\tif ((booleanFilter != null) && booleanFilter.hasClauses()) {\n\t\t\tfullBooleanFilter.add(booleanFilter, BooleanClauseOccur.MUST);\n\t\t}\n\n\t\tfullBooleanFilter.add(permissionBooleanFilter, BooleanClauseOccur.MUST);\n\n\t\treturn fullBooleanFilter;\n\t}","id":31966,"modified_method":"protected BooleanFilter doGetPermissionFilter_6(\n\t\t\tlong companyId, long[] groupIds, long userId,\n\t\t\tPermissionChecker permissionChecker, String className,\n\t\t\tBooleanFilter booleanFilter, Set<Role> roles,\n\t\t\tMap<Long, List<Role>> groupIdsToRoles)\n\t\tthrows Exception {\n\n\t\tBooleanFilter permissionBooleanFilter = new BooleanFilter();\n\n\t\tif (userId > 0) {\n\t\t\tpermissionBooleanFilter.addTerm(Field.USER_ID, userId);\n\t\t}\n\n\t\tTermsFilter groupsTermsFilter = new TermsFilter(Field.GROUP_ID);\n\t\tTermsFilter groupRolesTermsFilter = new TermsFilter(\n\t\t\tField.GROUP_ROLE_ID);\n\t\tTermsFilter rolesTermsFilter = new TermsFilter(Field.ROLE_ID);\n\n\t\tList<Long> roleIds = new ArrayList<>(roles.size());\n\t\tList<Long> regularRoleIds = new ArrayList<>();\n\n\t\tfor (Role role : roles) {\n\t\t\troleIds.add(role.getRoleId());\n\n\t\t\tif (role.getType() == RoleConstants.TYPE_REGULAR) {\n\t\t\t\tregularRoleIds.add(role.getRoleId());\n\t\t\t}\n\n\t\t\trolesTermsFilter.addValue(String.valueOf(role.getRoleId()));\n\t\t}\n\n\t\tlong[] roleIdsArray = ArrayUtil.toLongArray(roleIds);\n\n\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_COMPANY,\n\t\t\t\tString.valueOf(companyId), roleIdsArray, ActionKeys.VIEW)) {\n\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\tArrayUtil.toLongArray(regularRoleIds), ActionKeys.VIEW)) {\n\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tfor (Map.Entry<Long, List<Role>> entry : groupIdsToRoles.entrySet()) {\n\t\t\tlong groupId = entry.getKey();\n\t\t\tList<Role> groupRoles = entry.getValue();\n\n\t\t\tif (permissionChecker.isGroupAdmin(groupId) ||\n\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\tString.valueOf(groupId), roleIdsArray,\n\t\t\t\t\tActionKeys.VIEW) ||\n\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className,\n\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\tListUtil.toLongArray(groupRoles, Role.ROLE_ID_ACCESSOR),\n\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t}\n\n\t\t\tfor (Role groupRole : groupRoles) {\n\t\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\t\tgroupId + StringPool.DASH + groupRole.getRoleId());\n\t\t\t}\n\t\t}\n\n\t\tif (ArrayUtil.isNotEmpty(groupIds)) {\n\t\t\tSet<Long> userGroupIds = groupIdsToRoles.keySet();\n\n\t\t\tfor (long groupId : groupIds) {\n\t\t\t\tif (!userGroupIds.contains(groupId) &&\n\t\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\tString.valueOf(groupId), roleIdsArray,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!groupsTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupsTermsFilter);\n\t\t}\n\n\t\tif (!groupRolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupRolesTermsFilter);\n\t\t}\n\n\t\tif (!rolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(rolesTermsFilter);\n\t\t}\n\n\t\tif (!permissionBooleanFilter.hasClauses()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tBooleanFilter fullBooleanFilter = new BooleanFilter();\n\n\t\tif ((booleanFilter != null) && booleanFilter.hasClauses()) {\n\t\t\tfullBooleanFilter.add(booleanFilter, BooleanClauseOccur.MUST);\n\t\t}\n\n\t\tfullBooleanFilter.add(permissionBooleanFilter, BooleanClauseOccur.MUST);\n\n\t\treturn fullBooleanFilter;\n\t}","commit_id":"ed16666faccde888081a64cbf37573c8ad14f950","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void populate(\n\t\t\tlong companyId, long userId, PermissionChecker permissionChecker,\n\t\t\tSet<Group> groups, Set<Role> roles,\n\t\t\tMap<Long, List<Role>> groupIdsToRoles)\n\t\tthrows Exception {\n\n\t\tUserBag userBag = permissionChecker.getUserBag();\n\n\t\tif (permissionChecker.isSignedIn()) {\n\t\t\troles.addAll(userBag.getRoles());\n\n\t\t\troles.add(\n\t\t\t\t_roleLocalService.getRole(companyId, RoleConstants.GUEST));\n\t\t}\n\t\telse {\n\t\t\tGroup guestGroup = _groupLocalService.getGroup(\n\t\t\t\tcompanyId, GroupConstants.GUEST);\n\n\t\t\troles.addAll(\n\t\t\t\t_roleLocalService.getUserRelatedRoles(\n\t\t\t\t\tuserId, Collections.singletonList(guestGroup)));\n\t\t}\n\n\t\tgroups.addAll(userBag.getGroups());\n\n\t\tRole organizationUserRole = _roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.ORGANIZATION_USER);\n\t\tRole siteMemberRole = _roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.SITE_MEMBER);\n\n\t\tfor (Group group : groups) {\n\t\t\tlong[] roleIds = permissionChecker.getRoleIds(\n\t\t\t\tuserId, group.getGroupId());\n\n\t\t\tList<Role> groupRoles = _roleLocalService.getRoles(roleIds);\n\n\t\t\troles.addAll(groupRoles);\n\n\t\t\tIterator<Role> iterator = groupRoles.iterator();\n\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tRole groupRole = iterator.next();\n\n\t\t\t\tif ((groupRole.getType() != RoleConstants.TYPE_ORGANIZATION) &&\n\t\t\t\t\t(groupRole.getType() != RoleConstants.TYPE_SITE)) {\n\n\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (group.isOrganization() &&\n\t\t\t\t!groupRoles.contains(organizationUserRole)) {\n\n\t\t\t\tgroupRoles.add(organizationUserRole);\n\t\t\t}\n\n\t\t\tif (group.isSite() && !groupRoles.contains(siteMemberRole)) {\n\t\t\t\tgroupRoles.add(siteMemberRole);\n\t\t\t}\n\n\t\t\tgroupIdsToRoles.put(group.getGroupId(), groupRoles);\n\t\t}\n\t}","id":31967,"modified_method":"protected void populate(\n\t\t\tlong companyId, long userId, PermissionChecker permissionChecker,\n\t\t\tSet<Role> roles, Map<Long, List<Role>> groupIdsToRoles)\n\t\tthrows Exception {\n\n\t\tUserBag userBag = permissionChecker.getUserBag();\n\n\t\tif (permissionChecker.isSignedIn()) {\n\t\t\troles.addAll(userBag.getRoles());\n\n\t\t\troles.add(\n\t\t\t\t_roleLocalService.getRole(companyId, RoleConstants.GUEST));\n\t\t}\n\t\telse {\n\t\t\tGroup guestGroup = _groupLocalService.getGroup(\n\t\t\t\tcompanyId, GroupConstants.GUEST);\n\n\t\t\troles.addAll(\n\t\t\t\t_roleLocalService.getUserRelatedRoles(\n\t\t\t\t\tuserId, Collections.singletonList(guestGroup)));\n\t\t}\n\n\t\tRole organizationUserRole = _roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.ORGANIZATION_USER);\n\t\tRole siteMemberRole = _roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.SITE_MEMBER);\n\n\t\tfor (Group group : userBag.getGroups()) {\n\t\t\tlong[] roleIds = permissionChecker.getRoleIds(\n\t\t\t\tuserId, group.getGroupId());\n\n\t\t\tList<Role> groupRoles = _roleLocalService.getRoles(roleIds);\n\n\t\t\troles.addAll(groupRoles);\n\n\t\t\tIterator<Role> iterator = groupRoles.iterator();\n\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tRole groupRole = iterator.next();\n\n\t\t\t\tif ((groupRole.getType() != RoleConstants.TYPE_ORGANIZATION) &&\n\t\t\t\t\t(groupRole.getType() != RoleConstants.TYPE_SITE)) {\n\n\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (group.isOrganization() &&\n\t\t\t\t!groupRoles.contains(organizationUserRole)) {\n\n\t\t\t\tgroupRoles.add(organizationUserRole);\n\t\t\t}\n\n\t\t\tif (group.isSite() && !groupRoles.contains(siteMemberRole)) {\n\t\t\t\tgroupRoles.add(siteMemberRole);\n\t\t\t}\n\n\t\t\tgroupIdsToRoles.put(group.getGroupId(), groupRoles);\n\t\t}\n\t}","commit_id":"26b87c89837f8e7037ffb77f64685766f3954fad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected BooleanFilter doGetPermissionFilter_6(\n\t\t\tlong companyId, long[] groupIds, long userId,\n\t\t\tPermissionChecker permissionChecker, String className,\n\t\t\tBooleanFilter booleanFilter, Set<Group> groups, Set<Role> roles,\n\t\t\tMap<Long, List<Role>> groupIdsToRoles)\n\t\tthrows Exception {\n\n\t\tBooleanFilter permissionBooleanFilter = new BooleanFilter();\n\n\t\tif (userId > 0) {\n\t\t\tpermissionBooleanFilter.addTerm(Field.USER_ID, userId);\n\t\t}\n\n\t\tTermsFilter groupsTermsFilter = new TermsFilter(Field.GROUP_ID);\n\t\tTermsFilter groupRolesTermsFilter = new TermsFilter(\n\t\t\tField.GROUP_ROLE_ID);\n\t\tTermsFilter rolesTermsFilter = new TermsFilter(Field.ROLE_ID);\n\n\t\tfor (Role role : roles) {\n\t\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_COMPANY,\n\t\t\t\t\tString.valueOf(companyId), role.getRoleId(),\n\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tif ((role.getType() == RoleConstants.TYPE_REGULAR) &&\n\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className,\n\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\trole.getRoleId(), ActionKeys.VIEW)) {\n\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tfor (Group group : groups) {\n\t\t\t\tif (permissionChecker.isGroupAdmin(\n\t\t\t\t\t\tgroup.getGroupId()) ||\n\t\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\tString.valueOf(group.getGroupId()), role.getRoleId(),\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\tgroupsTermsFilter.addValue(\n\t\t\t\t\t\tString.valueOf(group.getGroupId()));\n\t\t\t\t}\n\n\t\t\t\tif ((role.getType() != RoleConstants.TYPE_REGULAR) &&\n\t\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className,\n\t\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\t\trole.getRoleId(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tList<Role> groupRoles = groupIdsToRoles.get(\n\t\t\t\t\t\tgroup.getGroupId());\n\n\t\t\t\t\tif (groupRoles.contains(role)) {\n\t\t\t\t\t\tgroupsTermsFilter.addValue(\n\t\t\t\t\t\t\tString.valueOf(group.getGroupId()));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tList<Role> groupRoles = groupIdsToRoles.get(group.getGroupId());\n\n\t\t\t\tfor (Role groupRole : groupRoles) {\n\t\t\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\t\t\tgroup.getGroupId() + StringPool.DASH +\n\t\t\t\t\t\t\tgroupRole.getRoleId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ArrayUtil.isNotEmpty(groupIds)) {\n\t\t\t\tfor (long groupId : groupIds) {\n\t\t\t\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\t\tString.valueOf(groupId), role.getRoleId(),\n\t\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trolesTermsFilter.addValue(String.valueOf(role.getRoleId()));\n\t\t}\n\n\t\tif (!groupsTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupsTermsFilter);\n\t\t}\n\n\t\tif (!groupRolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupRolesTermsFilter);\n\t\t}\n\n\t\tif (!rolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(rolesTermsFilter);\n\t\t}\n\n\t\tif (!permissionBooleanFilter.hasClauses()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tBooleanFilter fullBooleanFilter = new BooleanFilter();\n\n\t\tif ((booleanFilter != null) && booleanFilter.hasClauses()) {\n\t\t\tfullBooleanFilter.add(booleanFilter, BooleanClauseOccur.MUST);\n\t\t}\n\n\t\tfullBooleanFilter.add(permissionBooleanFilter, BooleanClauseOccur.MUST);\n\n\t\treturn fullBooleanFilter;\n\t}","id":31968,"modified_method":"protected BooleanFilter doGetPermissionFilter_6(\n\t\t\tlong companyId, long[] groupIds, long userId,\n\t\t\tPermissionChecker permissionChecker, String className,\n\t\t\tBooleanFilter booleanFilter, Set<Role> roles,\n\t\t\tMap<Long, List<Role>> groupIdsToRoles)\n\t\tthrows Exception {\n\n\t\tBooleanFilter permissionBooleanFilter = new BooleanFilter();\n\n\t\tif (userId > 0) {\n\t\t\tpermissionBooleanFilter.addTerm(Field.USER_ID, userId);\n\t\t}\n\n\t\tTermsFilter groupsTermsFilter = new TermsFilter(Field.GROUP_ID);\n\t\tTermsFilter groupRolesTermsFilter = new TermsFilter(\n\t\t\tField.GROUP_ROLE_ID);\n\t\tTermsFilter rolesTermsFilter = new TermsFilter(Field.ROLE_ID);\n\n\t\tList<Long> roleIds = new ArrayList<>(roles.size());\n\t\tList<Long> regularRoleIds = new ArrayList<>();\n\n\t\tfor (Role role : roles) {\n\t\t\troleIds.add(role.getRoleId());\n\n\t\t\tif (role.getType() == RoleConstants.TYPE_REGULAR) {\n\t\t\t\tregularRoleIds.add(role.getRoleId());\n\t\t\t}\n\n\t\t\trolesTermsFilter.addValue(String.valueOf(role.getRoleId()));\n\t\t}\n\n\t\tlong[] roleIdsArray = ArrayUtil.toLongArray(roleIds);\n\n\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_COMPANY,\n\t\t\t\tString.valueOf(companyId), roleIdsArray, ActionKeys.VIEW)) {\n\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\tArrayUtil.toLongArray(regularRoleIds), ActionKeys.VIEW)) {\n\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tfor (Map.Entry<Long, List<Role>> entry : groupIdsToRoles.entrySet()) {\n\t\t\tlong groupId = entry.getKey();\n\t\t\tList<Role> groupRoles = entry.getValue();\n\n\t\t\tif (permissionChecker.isGroupAdmin(groupId) ||\n\t\t\t\t_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\tString.valueOf(groupId), roleIdsArray,\n\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t}\n\n\t\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\tcompanyId, className,\n\t\t\t\t\tResourceConstants.SCOPE_GROUP_TEMPLATE,\n\t\t\t\t\tString.valueOf(GroupConstants.DEFAULT_PARENT_GROUP_ID),\n\t\t\t\t\tListUtil.toLongArray(groupRoles, Role.ROLE_ID_ACCESSOR),\n\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t}\n\n\t\t\tfor (Role groupRole : groupRoles) {\n\t\t\t\tgroupRolesTermsFilter.addValue(\n\t\t\t\t\tgroupId + StringPool.DASH + groupRole.getRoleId());\n\t\t\t}\n\t\t}\n\n\t\tif (ArrayUtil.isNotEmpty(groupIds)) {\n\t\t\tfor (long groupId : groupIds) {\n\t\t\t\tif (_resourcePermissionLocalService.hasResourcePermission(\n\t\t\t\t\t\tcompanyId, className, ResourceConstants.SCOPE_GROUP,\n\t\t\t\t\t\tString.valueOf(groupId), roleIdsArray,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\tgroupsTermsFilter.addValue(String.valueOf(groupId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!groupsTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupsTermsFilter);\n\t\t}\n\n\t\tif (!groupRolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(groupRolesTermsFilter);\n\t\t}\n\n\t\tif (!rolesTermsFilter.isEmpty()) {\n\t\t\tpermissionBooleanFilter.add(rolesTermsFilter);\n\t\t}\n\n\t\tif (!permissionBooleanFilter.hasClauses()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tBooleanFilter fullBooleanFilter = new BooleanFilter();\n\n\t\tif ((booleanFilter != null) && booleanFilter.hasClauses()) {\n\t\t\tfullBooleanFilter.add(booleanFilter, BooleanClauseOccur.MUST);\n\t\t}\n\n\t\tfullBooleanFilter.add(permissionBooleanFilter, BooleanClauseOccur.MUST);\n\n\t\treturn fullBooleanFilter;\n\t}","commit_id":"26b87c89837f8e7037ffb77f64685766f3954fad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected BooleanFilter doGetPermissionBooleanFilter(\n\t\t\tlong companyId, long[] groupIds, long userId, String className,\n\t\t\tBooleanFilter booleanFilter, SearchContext searchContext)\n\t\tthrows Exception {\n\n\t\tIndexer<?> indexer = _indexerRegistry.getIndexer(className);\n\n\t\tif (!indexer.isPermissionAware()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\tUser user = permissionChecker.getUser();\n\n\t\tif ((user == null) || (user.getUserId() != userId)) {\n\t\t\tuser = _userLocalService.fetchUser(userId);\n\n\t\t\tif (user == null) {\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tpermissionChecker = PermissionCheckerFactoryUtil.create(user);\n\t\t}\n\n\t\tif (permissionChecker.getUserBag() == null) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tif (permissionChecker.isCompanyAdmin(companyId)) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tSet<Group> groups = new LinkedHashSet<>();\n\t\tSet<Role> roles = new LinkedHashSet<>();\n\t\tMap<Long, List<Role>> groupIdsToRoles = new HashMap<>();\n\n\t\tpopulate(\n\t\t\tcompanyId, userId, permissionChecker, groups, roles,\n\t\t\tgroupIdsToRoles);\n\n\t\treturn doGetPermissionFilter_6(\n\t\t\tcompanyId, groupIds, userId, permissionChecker, className,\n\t\t\tbooleanFilter, groups, roles, groupIdsToRoles);\n\t}","id":31969,"modified_method":"protected BooleanFilter doGetPermissionBooleanFilter(\n\t\t\tlong companyId, long[] groupIds, long userId, String className,\n\t\t\tBooleanFilter booleanFilter, SearchContext searchContext)\n\t\tthrows Exception {\n\n\t\tIndexer<?> indexer = _indexerRegistry.getIndexer(className);\n\n\t\tif (!indexer.isPermissionAware()) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\tUser user = permissionChecker.getUser();\n\n\t\tif ((user == null) || (user.getUserId() != userId)) {\n\t\t\tuser = _userLocalService.fetchUser(userId);\n\n\t\t\tif (user == null) {\n\t\t\t\treturn booleanFilter;\n\t\t\t}\n\n\t\t\tpermissionChecker = PermissionCheckerFactoryUtil.create(user);\n\t\t}\n\n\t\tif (permissionChecker.getUserBag() == null) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tif (permissionChecker.isCompanyAdmin(companyId)) {\n\t\t\treturn booleanFilter;\n\t\t}\n\n\t\tSet<Role> roles = new LinkedHashSet<>();\n\t\tMap<Long, List<Role>> groupIdsToRoles = new HashMap<>();\n\n\t\tpopulate(companyId, userId, permissionChecker, roles, groupIdsToRoles);\n\n\t\treturn doGetPermissionFilter_6(\n\t\t\tcompanyId, groupIds, userId, permissionChecker, className,\n\t\t\tbooleanFilter, roles, groupIdsToRoles);\n\t}","commit_id":"26b87c89837f8e7037ffb77f64685766f3954fad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static H2ONode self(InetAddress local) {\n    assert H2O.H2O_PORT != 0;\n    try {\n      // Figure out which interface matches our IP address\n      List<NetworkInterface> matchingIfs = new ArrayList<>();\n      Enumeration<NetworkInterface> netIfs = NetworkInterface.getNetworkInterfaces();\n      while( netIfs.hasMoreElements() ) {\n        NetworkInterface netIf = netIfs.nextElement();\n        Enumeration<InetAddress> addrs = netIf.getInetAddresses();\n        while( addrs.hasMoreElements() ) {\n          InetAddress addr = addrs.nextElement();\n          if( addr.equals(local) ) {\n            matchingIfs.add(netIf);\n            break;\n          }\n        }\n      }\n      switch( matchingIfs.size() ) {\n      case 0: H2O.CLOUD_MULTICAST_IF = null; break;\n      case 1: H2O.CLOUD_MULTICAST_IF = matchingIfs.get(0); break;\n      default:\n        String msg = \"Found multiple network interfaces for ip address \" + local;\n        for( NetworkInterface ni : matchingIfs ) {\n          msg +=\"\\n\\t\" + ni;\n        }\n        msg +=\"\\nUsing \" + matchingIfs.get(0) + \" for UDP broadcast\";\n        Log.warn(msg);\n        H2O.CLOUD_MULTICAST_IF = matchingIfs.get(0);\n      }\n    } catch( SocketException e ) {\n      throw Log.throwErr(e);\n    }\n\n    // Selected multicast interface must support multicast, and be up and running!\n    try {\n      if( !H2O.CLOUD_MULTICAST_IF.supportsMulticast() ) {\n        Log.info(\"Selected H2O.CLOUD_MULTICAST_IF: \"+H2O.CLOUD_MULTICAST_IF+ \" doesn't support multicast\");\n      }\n      if( !H2O.CLOUD_MULTICAST_IF.isUp() ) {\n        throw new RuntimeException(\"Selected H2O.CLOUD_MULTICAST_IF: \"+H2O.CLOUD_MULTICAST_IF+ \" is not up and running\");\n      }\n    } catch( SocketException e ) {\n      throw Log.throwErr(e);\n    }\n\n    try {\n      assert water.init.NetworkInit.CLOUD_DGRAM == null;\n      water.init.NetworkInit.CLOUD_DGRAM = DatagramChannel.open();\n    } catch( Exception e ) {\n      throw Log.throwErr(e);\n    }\n    return intern(new H2Okey(local,H2O.H2O_PORT));\n  }","id":31970,"modified_method":"public static H2ONode self(InetAddress local) {\n    assert H2O.H2O_PORT != 0;\n    try {\n      // Figure out which interface matches our IP address\n      List<NetworkInterface> matchingIfs = new ArrayList<>();\n      Enumeration<NetworkInterface> netIfs = NetworkInterface.getNetworkInterfaces();\n      while( netIfs.hasMoreElements() ) {\n        NetworkInterface netIf = netIfs.nextElement();\n        Enumeration<InetAddress> addrs = netIf.getInetAddresses();\n        while( addrs.hasMoreElements() ) {\n          InetAddress addr = addrs.nextElement();\n          if( addr.equals(local) ) {\n            matchingIfs.add(netIf);\n            break;\n          }\n        }\n      }\n      switch( matchingIfs.size() ) {\n      case 0: H2O.CLOUD_MULTICAST_IF = null; break;\n      case 1: H2O.CLOUD_MULTICAST_IF = matchingIfs.get(0); break;\n      default:\n        String msg = \"Found multiple network interfaces for ip address \" + local;\n        for( NetworkInterface ni : matchingIfs ) {\n          msg +=\"\\n\\t\" + ni;\n        }\n        msg +=\"\\nUsing \" + matchingIfs.get(0) + \" for UDP broadcast\";\n        Log.warn(msg);\n        H2O.CLOUD_MULTICAST_IF = matchingIfs.get(0);\n      }\n    } catch( SocketException e ) {\n      throw Log.throwErr(e);\n    }\n\n    // Selected multicast interface must support multicast, and be up and running!\n    try {\n      if( H2O.CLOUD_MULTICAST_IF != null && !H2O.CLOUD_MULTICAST_IF.supportsMulticast() ) {\n        Log.info(\"Selected H2O.CLOUD_MULTICAST_IF: \"+H2O.CLOUD_MULTICAST_IF+ \" doesn't support multicast\");\n        H2O.CLOUD_MULTICAST_IF = null;\n      } \n      if( H2O.CLOUD_MULTICAST_IF != null && !H2O.CLOUD_MULTICAST_IF.isUp() ) {\n        throw new RuntimeException(\"Selected H2O.CLOUD_MULTICAST_IF: \"+H2O.CLOUD_MULTICAST_IF+ \" is not up and running\");\n      }\n    } catch( SocketException e ) {\n      throw Log.throwErr(e);\n    }\n\n    try {\n      assert water.init.NetworkInit.CLOUD_DGRAM == null;\n      water.init.NetworkInit.CLOUD_DGRAM = DatagramChannel.open();\n    } catch( Exception e ) {\n      throw Log.throwErr(e);\n    }\n    return intern(new H2Okey(local,H2O.H2O_PORT));\n  }","commit_id":"ce14e521bcf9b2fad1c6d32c5eafd912dd850532","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@SuppressWarnings(\"resource\")\n  @Override public void run() {\n    // No multicast?  Then do not bother with listening for them\n    if( H2O.STATIC_H2OS != null ) return;\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n\n    MulticastSocket sock = null, errsock = null;\n    InetAddress group = null, errgroup = null;\n    boolean saw_error = false;\n\n    // Loop forever accepting Cloud Management requests\n    while( true ) {\n      try {\n        // ---\n        // Cleanup from any prior socket failures.  Rare unless we're really sick.\n        if( errsock != null && errgroup != null ) { // socket error AND group present\n          final InetAddress tmp = errgroup; errgroup = null;\n          errsock.leaveGroup(tmp); // Could throw, but errgroup cleared for next pass\n        }\n        if( errsock != null ) { // One time attempt a socket close\n          final MulticastSocket tmp2 = errsock; errsock = null;\n          tmp2.close();       // Could throw, but errsock cleared for next pass\n        }\n        if( saw_error ) Thread.sleep(1000); // prevent deny-of-service endless socket-creates\n        saw_error = false;\n\n        // ---\n        // Actually do the common-case setup of Inet multicast group\n        if( group == null ) group = H2O.CLOUD_MULTICAST_GROUP;\n        // More common-case setup of a MultiCast socket\n        if( sock == null ) {\n          sock = new MulticastSocket(H2O.CLOUD_MULTICAST_PORT);\n          if( H2O.CLOUD_MULTICAST_IF != null )\n            sock.setNetworkInterface(H2O.CLOUD_MULTICAST_IF);\n          sock.joinGroup(group);\n        }\n\n        // Receive a packet & handle it\n        byte[] buf = new byte[AutoBuffer.MTU];\n        DatagramPacket pack = new DatagramPacket(buf,buf.length);\n        sock.receive(pack);\n        UDPReceiverThread.basic_packet_handling(new AutoBuffer(pack));\n      } catch( SocketException e ) {\n        Log.err(\"Trying Multicast Interface, Group, Port - \"+\n          H2O.CLOUD_MULTICAST_IF+\" \"+H2O.CLOUD_MULTICAST_GROUP+\":\"+H2O.CLOUD_MULTICAST_PORT, e);\n        throw new RuntimeException(e);\n      } catch( Exception e ) {\n        Log.err(\"Trying Multicast Interface, Group, Port - \"+\n          H2O.CLOUD_MULTICAST_IF+\" \"+H2O.CLOUD_MULTICAST_GROUP+\":\"+H2O.CLOUD_MULTICAST_PORT, e);\n        // On any error from anybody, close all sockets & re-open\n        saw_error = true;\n        errsock  = sock ;  sock  = null; // Signal error recovery on the next loop\n        errgroup = group;  group = null;\n      }\n    }\n  }","id":31971,"modified_method":"@SuppressWarnings(\"resource\")\n  @Override public void run() {\n    // No multicast?  Then do not bother with listening for them\n    if( H2O.STATIC_H2OS != null ) return;\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n\n    MulticastSocket sock = null, errsock = null;\n    InetAddress group = null, errgroup = null;\n    boolean saw_error = false;\n\n    // Loop forever accepting Cloud Management requests\n    while( true ) {\n      try {\n        // ---\n        // Cleanup from any prior socket failures.  Rare unless we're really sick.\n        if( errsock != null && errgroup != null ) { // socket error AND group present\n          final InetAddress tmp = errgroup; errgroup = null;\n          errsock.leaveGroup(tmp); // Could throw, but errgroup cleared for next pass\n        }\n        if( errsock != null ) { // One time attempt a socket close\n          final MulticastSocket tmp2 = errsock; errsock = null;\n          tmp2.close();       // Could throw, but errsock cleared for next pass\n        }\n        if( saw_error ) Thread.sleep(1000); // prevent deny-of-service endless socket-creates\n        saw_error = false;\n\n        // ---\n        // Actually do the common-case setup of Inet multicast group\n        if( group == null ) group = H2O.CLOUD_MULTICAST_GROUP;\n        // More common-case setup of a MultiCast socket\n        if( sock == null ) {\n          sock = new MulticastSocket(H2O.CLOUD_MULTICAST_PORT);\n          if( H2O.CLOUD_MULTICAST_IF != null ) {\n            try { \n              sock.setNetworkInterface(H2O.CLOUD_MULTICAST_IF);\n            } catch( SocketException e ) {\n              Log.err(\"Exception calling setNetworkInterface, Multicast Interface, Group, Port - \"+\n                      H2O.CLOUD_MULTICAST_IF+\" \"+H2O.CLOUD_MULTICAST_GROUP+\":\"+H2O.CLOUD_MULTICAST_PORT, e);\n              throw e;\n            }\n          }\n          sock.joinGroup(group);\n        }\n\n        // Receive a packet & handle it\n        byte[] buf = new byte[AutoBuffer.MTU];\n        DatagramPacket pack = new DatagramPacket(buf,buf.length);\n        sock.receive(pack);\n        UDPReceiverThread.basic_packet_handling(new AutoBuffer(pack));\n      } catch( SocketException e ) {\n        // This rethrow will not be caught and thus kills the multi-cast thread.\n        Log.err(\"Turning off multicast, which will disable further cloud building\");\n        throw new RuntimeException(e);\n      } catch( Exception e ) {\n        Log.err(\"Exception on Multicast Interface, Group, Port - \"+\n          H2O.CLOUD_MULTICAST_IF+\" \"+H2O.CLOUD_MULTICAST_GROUP+\":\"+H2O.CLOUD_MULTICAST_PORT, e);\n        // On any error from anybody, close all sockets & re-open\n        saw_error = true;\n        errsock  = sock ;  sock  = null; // Signal error recovery on the next loop\n        errgroup = group;  group = null;\n      }\n    }\n  }","commit_id":"ce14e521bcf9b2fad1c6d32c5eafd912dd850532","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    public String fetchFlatfile() throws Exception {\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile called\\n\");\n      MapperToDriverMessage msg = new MapperToDriverMessage();\n      msg.setMessageFetchFlatfile(_embeddedWebServerIp, _embeddedWebServerPort);\n      Socket s = new Socket(_driverCallbackIp, _driverCallbackPort);\n      msg.write(s);\n      DriverToMapperMessage msg2 = new DriverToMapperMessage();\n      msg2.read(s);\n      if (msg2.getType() != DriverToMapperMessage.TYPE_FETCH_FLATFILE_RESPONSE) {\n        Log.err(\"DriverToMapperMessage type unrecognized\");\n        throw new Exception (\"DriverToMapperMessage type unrecognized\");\n      }\n      s.close();\n      String flatfile = msg2.getFlatfile();\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile returned\\n\");\n      System.out.println(\"------------------------------------------------------------\");\n      System.out.println(flatfile);\n      System.out.println(\"------------------------------------------------------------\");\n      return flatfile;\n    }","id":31972,"modified_method":"@Override\n    public String fetchFlatfile() throws Exception {\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile called\\n\");\n      MapperToDriverMessage msg = new MapperToDriverMessage();\n      msg.setMessageFetchFlatfile(_embeddedWebServerIp, _embeddedWebServerPort);\n      Socket s = new Socket(_driverCallbackIp, _driverCallbackPort);\n      msg.write(s);\n      DriverToMapperMessage msg2 = new DriverToMapperMessage();\n      msg2.read(s);\n      char type = msg2.getType();\n      if (type != DriverToMapperMessage.TYPE_FETCH_FLATFILE_RESPONSE) {\n        int typeAsInt = (int)type & 0xff;\n        String str = new String(\"DriverToMapperMessage type unrecognized (\" + typeAsInt + \")\");\n        Log.err(str);\n        throw new Exception (str);\n      }\n      s.close();\n      String flatfile = msg2.getFlatfile();\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile returned\\n\");\n      System.out.println(\"------------------------------------------------------------\");\n      System.out.println(flatfile);\n      System.out.println(\"------------------------------------------------------------\");\n      return flatfile;\n    }","commit_id":"ef249becdc78394e1a4a6ea05735e80bae8f6477","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n    public String fetchFlatfile() throws Exception {\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile called\\n\");\n      MapperToDriverMessage msg = new MapperToDriverMessage();\n      msg.setMessageFetchFlatfile(_embeddedWebServerIp, _embeddedWebServerPort);\n      Socket s = new Socket(_driverCallbackIp, _driverCallbackPort);\n      msg.write(s);\n      DriverToMapperMessage msg2 = new DriverToMapperMessage();\n      msg2.read(s);\n      if (msg2.getType() != DriverToMapperMessage.TYPE_FETCH_FLATFILE_RESPONSE) {\n        Log.err(\"DriverToMapperMessage type unrecognized\");\n        throw new Exception (\"DriverToMapperMessage type unrecognized\");\n      }\n      s.close();\n      String flatfile = msg2.getFlatfile();\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile returned\\n\");\n      System.out.println(\"------------------------------------------------------------\");\n      System.out.println(flatfile);\n      System.out.println(\"------------------------------------------------------------\");\n      return flatfile;\n    }","id":31973,"modified_method":"@Override\n    public String fetchFlatfile() throws Exception {\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile called\\n\");\n      MapperToDriverMessage msg = new MapperToDriverMessage();\n      msg.setMessageFetchFlatfile(_embeddedWebServerIp, _embeddedWebServerPort);\n      Socket s = new Socket(_driverCallbackIp, _driverCallbackPort);\n      msg.write(s);\n      DriverToMapperMessage msg2 = new DriverToMapperMessage();\n      msg2.read(s);\n      char type = msg2.getType();\n      if (type != DriverToMapperMessage.TYPE_FETCH_FLATFILE_RESPONSE) {\n        int typeAsInt = (int)type & 0xff;\n        String str = new String(\"DriverToMapperMessage type unrecognized (\" + typeAsInt + \")\");\n        Log.err(str);\n        throw new Exception (str);\n      }\n      s.close();\n      String flatfile = msg2.getFlatfile();\n      System.out.printf(\"EmbeddedH2OConfig: fetchFlatfile returned\\n\");\n      System.out.println(\"------------------------------------------------------------\");\n      System.out.println(flatfile);\n      System.out.println(\"------------------------------------------------------------\");\n      return flatfile;\n    }","commit_id":"e2d84ff776cf5cb706a1c91b60a3deebd9af5f95","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n  public FindUsagesHandler createFindUsagesHandler(@NotNull PsiElement element, boolean forHighlightUsages) {\n    return new PyClassFindUsagesHandler((PyClass) element);\n  }","id":31974,"modified_method":"@Override\n  public FindUsagesHandler createFindUsagesHandler(@NotNull PsiElement element, boolean forHighlightUsages) {\n    if (element instanceof PyClass) {\n      return new PyClassFindUsagesHandler((PyClass)element);\n    }\n    return new PyLocalFindUsagesHandler(element);\n  }","commit_id":"efd9e36800507bfba571fc26f03c6cfd8c875ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean canFindUsages(@NotNull PsiElement element) {\n    return element instanceof PyClass;\n  }","id":31975,"modified_method":"@Override\n  public boolean canFindUsages(@NotNull PsiElement element) {\n    return element instanceof PyClass || isLocal(element);\n  }","commit_id":"efd9e36800507bfba571fc26f03c6cfd8c875ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isSoft() {\n    return false;\n  }","id":31976,"modified_method":"public boolean isSoft() {\n    return myElement instanceof PyTargetExpression;\n  }","commit_id":"efd9e36800507bfba571fc26f03c6cfd8c875ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isRedefiningAssignment() {\n    PyFunction containingFunction = PsiTreeUtil.getParentOfType(this, PyFunction.class);\n    final PyRedefinitionVisitor visitor = new PyRedefinitionVisitor();\n    if (containingFunction != null) {\n      containingFunction.acceptChildren(visitor);\n    }\n    return visitor.myResult != null;\n  }","id":31977,"modified_method":"public boolean isRedefiningAssignment() {\n    PsiElement redefinitionScope = getRedefinitionScope();\n    if (redefinitionScope != null) {\n      final PyRedefinitionVisitor visitor = new PyRedefinitionVisitor();\n      redefinitionScope.acceptChildren(visitor);\n      return visitor.myResult != null;\n    }\n    return false;\n  }","commit_id":"efd9e36800507bfba571fc26f03c6cfd8c875ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> getProblemsMap(final DomElement domElement) {\n    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> map = myCachedChildrenErrors.get(domElement);\n    if (map != null) {\n      return map;\n    }\n\n    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> problems = new ConcurrentHashMap<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>>();\n    mergeMaps(problems, myCachedErrors.get(domElement));\n    domElement.acceptChildren(new DomElementVisitor() {\n      public void visitDomElement(DomElement element) {\n        mergeMaps(problems, getProblemsMap(element));\n      }\n    });\n    myCachedChildrenErrors.put(domElement, problems);\n    return problems;\n  }","id":31978,"modified_method":"@NotNull\n  private Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> getProblemsMap(final DomElement domElement) {\n    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> map = myCachedChildrenErrors.get(domElement);\n    if (map != null) {\n      return map;\n    }\n\n    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> problems = new ConcurrentHashMap<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>>();\n    mergeMaps(problems, myCachedErrors.get(domElement));\n    if (domElement.getXmlElement() != null) {\n      domElement.acceptChildren(new DomElementVisitor() {\n        public void visitDomElement(DomElement element) {\n          mergeMaps(problems, getProblemsMap(element));\n        }\n      });\n    }\n    myCachedChildrenErrors.put(domElement, problems);\n    return problems;\n  }","commit_id":"132049538676396a71510d6584fd3b0c32244186","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProblemDescriptor[] checkField(@NotNull PsiField field, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    final PsiExpression initializer = field.getInitializer();\n    if (initializer != null) {\n      return getDescriptions(initializer, manager, isOnTheFly);\n    }\n    return null;\n  }","id":31979,"modified_method":"public ProblemDescriptor[] checkField(@NotNull PsiField field, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    final PsiExpression initializer = field.getInitializer();\n    if (initializer != null) {\n      return getDescriptions(initializer, manager, isOnTheFly);\n    }\n    if (field instanceof PsiEnumConstant) {\n      return getDescriptions(field, manager, isOnTheFly);\n    }\n    return null;\n  }","commit_id":"cb603588ff4c126e279a894e8f17ef9c83ab03d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processCall(PsiCallExpression expression){\n      PsiExpressionList argumentList = expression.getArgumentList();\n      if (argumentList == null) return;\n      PsiExpression[] args = argumentList.getExpressions();\n      PsiMethod oldMethod = expression.resolveMethod();\n      if (oldMethod == null) return;\n      PsiParameter[] parameters = oldMethod.getParameterList().getParameters();\n\n      try {\n        for (int i = 0; i < args.length; i++) {\n          final PsiExpression arg = deparenthesizeExpression(args[i]);\n          if (arg instanceof PsiTypeCastExpression) {\n            PsiTypeCastExpression cast = (PsiTypeCastExpression)arg;\n            if (i == args.length - 1 && args.length == parameters.length && parameters[i].isVarArgs()) {\n              //do not mark cast to resolve ambiguity for calling varargs method with inexact argument\n              continue;\n            }\n            PsiCallExpression newCall = (PsiCallExpression) expression.copy();\n            final PsiExpressionList argList = newCall.getArgumentList();\n            LOG.assertTrue(argList != null);\n            PsiExpression[] newArgs = argList.getExpressions();\n            PsiTypeCastExpression castExpression = (PsiTypeCastExpression) deparenthesizeExpression(newArgs[i]);\n            PsiExpression castOperand = castExpression.getOperand();\n            if (castOperand == null) return;\n            castExpression.replace(castOperand);\n            final JavaResolveResult newResult = newCall.resolveMethodGenerics();\n            if (oldMethod.equals(newResult.getElement()) && newResult.isValidResult() &&\n                Comparing.equal(newCall.getType(), expression.getType())) {\n              addToResults(cast);\n            }\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        return;\n      }\n\n      for (PsiExpression arg : args) {\n        if (arg instanceof PsiTypeCastExpression) {\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          if (castOperand != null) {\n            castOperand.accept(this);\n          }\n        }\n        else {\n          arg.accept(this);\n        }\n      }\n    }","id":31980,"modified_method":"private void processCall(PsiCall expression){\n      PsiExpressionList argumentList = expression.getArgumentList();\n      if (argumentList == null) return;\n      PsiExpression[] args = argumentList.getExpressions();\n      PsiMethod oldMethod = expression.resolveMethod();\n      if (oldMethod == null) return;\n      PsiParameter[] parameters = oldMethod.getParameterList().getParameters();\n\n      try {\n        for (int i = 0; i < args.length; i++) {\n          final PsiExpression arg = deparenthesizeExpression(args[i]);\n          if (arg instanceof PsiTypeCastExpression) {\n            PsiTypeCastExpression cast = (PsiTypeCastExpression)arg;\n            if (i == args.length - 1 && args.length == parameters.length && parameters[i].isVarArgs()) {\n              //do not mark cast to resolve ambiguity for calling varargs method with inexact argument\n              continue;\n            }\n            PsiCall newCall = (PsiCall) expression.copy();\n            final PsiExpressionList argList = newCall.getArgumentList();\n            LOG.assertTrue(argList != null);\n            PsiExpression[] newArgs = argList.getExpressions();\n            PsiTypeCastExpression castExpression = (PsiTypeCastExpression) deparenthesizeExpression(newArgs[i]);\n            PsiExpression castOperand = castExpression.getOperand();\n            if (castOperand == null) return;\n            castExpression.replace(castOperand);\n            if (newCall instanceof PsiEnumConstant) {\n              // do this manually, because PsiEnumConstantImpl.resolveMethodGenerics() will assert (no containing class for the copy)\n              final PsiEnumConstant enumConstant = (PsiEnumConstant)expression;\n              PsiClass containingClass = enumConstant.getContainingClass();\n              final JavaPsiFacade facade = JavaPsiFacade.getInstance(enumConstant.getProject());\n              final PsiClassType type = facade.getElementFactory().createType(containingClass);\n              final JavaResolveResult newResult = facade.getResolveHelper().resolveConstructor(type, newCall.getArgumentList(), enumConstant);\n              if (oldMethod.equals(newResult.getElement()) && newResult.isValidResult()) {\n                addToResults(cast);\n              }\n            } else {\n              final JavaResolveResult newResult = newCall.resolveMethodGenerics();\n              if (oldMethod.equals(newResult.getElement()) && newResult.isValidResult() &&\n                Comparing.equal(((PsiCallExpression)newCall).getType(), ((PsiCallExpression)expression).getType())) {\n                addToResults(cast);\n              }\n            }\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        return;\n      }\n\n      for (PsiExpression arg : args) {\n        if (arg instanceof PsiTypeCastExpression) {\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          if (castOperand != null) {\n            castOperand.accept(this);\n          }\n        }\n        else {\n          arg.accept(this);\n        }\n      }\n    }","commit_id":"cb603588ff4c126e279a894e8f17ef9c83ab03d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static List<PsiTypeCastExpression> getRedundantCastsInside(PsiElement where) {\n    MyCollectingVisitor visitor = new MyCollectingVisitor();\n    where.acceptChildren(visitor);\n    return new ArrayList<PsiTypeCastExpression>(visitor.myFoundCasts);\n  }","id":31981,"modified_method":"@NotNull\n  public static List<PsiTypeCastExpression> getRedundantCastsInside(PsiElement where) {\n    MyCollectingVisitor visitor = new MyCollectingVisitor();\n    if (where instanceof PsiEnumConstant) {\n      where.accept(visitor);\n    } else {\n      where.acceptChildren(visitor);\n    }\n    return new ArrayList<PsiTypeCastExpression>(visitor.myFoundCasts);\n  }","commit_id":"cb603588ff4c126e279a894e8f17ef9c83ab03d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Search for all wiki macros in the current wiki.\n     * \n     * @param xcontext the current request context\n     * @return a list of documents containing wiki macros,\n     *         each item as a List of 3 strings: space name, document name, last author of the document\n     * @throws Exception if the database search fails\n     */\n    private List<Object[]> getWikiMacroDocumentData(XWikiContext xcontext) throws Exception\n    {\n        final QueryManager qm = xcontext.getWiki().getStore().getQueryManager();\n        final List<XWikiDocument> macroDocs =\n            qm.getNamedQuery(\"getWikiMacroDocuments\").bindValue(0, WIKI_MACRO_CLASS).execute();\n        final List<Object[]> out = new ArrayList<Object[]>(macroDocs.size());\n        for (final XWikiDocument doc : macroDocs) {\n            out.add(new Object[] { doc.getSpace(), doc.getName(), doc.getAuthor() });\n        }\n        return out;\n    }","id":31982,"modified_method":"/**\n     * Search for all wiki macros in the current wiki.\n     * \n     * @param xcontext the current request context\n     * @return a list of documents containing wiki macros,\n     *         each item as a List of 3 strings: space name, document name, last author of the document\n     * @throws Exception if the database search fails\n     */\n    private List<Object[]> getWikiMacroDocumentData(XWikiContext xcontext) throws Exception\n    {\n        final QueryManager qm = xcontext.getWiki().getStore().getQueryManager();\n        final Query q = qm.getNamedQuery(\"getWikiMacroDocuments\").bindValue(\"classname\", WIKI_MACRO_CLASS);\n        return (List<Object[]>) (List) q.execute();\n    }","commit_id":"85d29e191c9d561258a3dd95aaad843124f72d3a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Query setLimit(int limit) {\n        return query.setLimit(limit);\n    }","id":31983,"modified_method":"@Override\n    public Query setLimit(int limit) {\n        query.setLimit(limit);\n        return this;\n    }","commit_id":"57cf39f102c6ee555659e75e1f1720c034aa5e48","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Query setOffset(int offset) {\n        return query.setOffset(offset);\n    }","id":31984,"modified_method":"@Override\n    public Query setOffset(int offset) {\n        query.setOffset(offset);\n        return this;\n    }","commit_id":"57cf39f102c6ee555659e75e1f1720c034aa5e48","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Query setWiki(String wiki) {\n        return query.setWiki(wiki);\n    }","id":31985,"modified_method":"@Override\n    public Query setWiki(String wiki) {\n        query.setWiki(wiki);\n        return this;\n    }","commit_id":"57cf39f102c6ee555659e75e1f1720c034aa5e48","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Query setFilter(QueryFilter filter) {\n        return query.setFilter(filter);\n    }","id":31986,"modified_method":"@Override\n    public Query setFilter(QueryFilter filter) {\n        query.setFilter(filter);\n        return this;\n    }","commit_id":"57cf39f102c6ee555659e75e1f1720c034aa5e48","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Query bindValue(String var, Object val) {\n        return query.bindValue(var, val);\n    }","id":31987,"modified_method":"@Override\n    public Query bindValue(String var, Object val) {\n        query.bindValue(var, val);\n        return this;\n    }","commit_id":"57cf39f102c6ee555659e75e1f1720c034aa5e48","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Query bindValue(int index, Object val) {\n        return query.bindValue(index, val);\n    }","id":31988,"modified_method":"@Override\n    public Query bindValue(int index, Object val) {\n        query.bindValue(index, val);\n        return this;\n    }","commit_id":"57cf39f102c6ee555659e75e1f1720c034aa5e48","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Query bindValues(List<Object> values) {\n        return query.bindValues(values);\n    }","id":31989,"modified_method":"@Override\n    public Query bindValues(List<Object> values) {\n        query.bindValues(values);\n        return this;\n    }","commit_id":"57cf39f102c6ee555659e75e1f1720c034aa5e48","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for all wiki macros in the current wiki.\n     * \n     * @param xcontext the current request context\n     * @return a list of documents containing wiki macros,\n     *         each item as a List of 3 strings: space name, document name, last author of the document\n     * @throws Exception if the database search fails\n     */\n    private List<Object[]> getWikiMacroDocumentData(XWikiContext xcontext) throws Exception\n    {\n        final QueryManager qm = xcontext.getWiki().getStore().getQueryManager();\n        final List<XWikiDocument> macroDocs =\n            qm.getNamedQuery(\"getWikiMacroDocuments\").bindValue(0, WIKI_MACRO_CLASS).execute();\n        final List<Object[]> out = new ArrayList<Object[]>(macroDocs.size());\n        for (final XWikiDocument doc : macroDocs) {\n            out.add(new Object[] { doc.getSpace(), doc.getName(), doc.getAuthor() });\n        }\n        return out;\n    }","id":31990,"modified_method":"/**\n     * Search for all wiki macros in the current wiki.\n     * \n     * @param xcontext the current request context\n     * @return a list of documents containing wiki macros,\n     *         each item as a List of 3 strings: space name, document name, last author of the document\n     * @throws Exception if the database search fails\n     */\n    private List<Object[]> getWikiMacroDocumentData(XWikiContext xcontext) throws Exception\n    {\n        final QueryManager qm = xcontext.getWiki().getStore().getQueryManager();\n        final Query q = qm.getNamedQuery(\"getWikiMacroDocuments\").bindValue(\"classname\", WIKI_MACRO_CLASS);\n        return (List<Object[]>) (List) q.execute();\n    }","commit_id":"f28b76095e23cce61261bdc1226b29557d6d816b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected GradleExecution usingBuildFile(File file) {\n        StartParameter parameter = startParameter();\n        parameter.setBuildFile(file);\n        return new GradleExecution(parameter);\n    }","id":31991,"modified_method":"protected GradleExecuter usingBuildFile(File file) {\n        StartParameter parameter = startParameter();\n        parameter.setBuildFile(file);\n        return new InProcessGradleExecuter(parameter);\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"protected StartParameter startParameter() {\n        StartParameter parameter = new StartParameter();\n        parameter.setGradleHomeDir(testFile(\"gradle-home\").asFile());\n\n        testFile(\"gradle-home/gradle-imports\").writelns(\n                \"import org.gradle.api.*\",\n                \"import static org.junit.Assert.*\",\n                \"import static org.hamcrest.Matchers.*\");\n\n        testFile(\"gradle-home/plugin.properties\").writelns(\n                \"groovy=org.gradle.api.plugins.GroovyPlugin\"\n        );\n\n        parameter.setGradleUserHomeDir(testFile(\"user-home\").asFile());\n\n        parameter.setSearchUpwards(false);\n        parameter.setCacheUsage(CacheUsage.ON);\n        parameter.setCurrentDir(getTestDir());\n\n        return parameter;\n    }","id":31992,"modified_method":"private StartParameter startParameter() {\n        StartParameter parameter = new StartParameter();\n        parameter.setGradleHomeDir(testFile(\"gradle-home\").asFile());\n\n        testFile(\"gradle-home/gradle-imports\").writelns(\"import org.gradle.api.*\", \"import static org.junit.Assert.*\",\n                \"import static org.hamcrest.Matchers.*\");\n\n        testFile(\"gradle-home/plugin.properties\").writelns(\"groovy=org.gradle.api.plugins.GroovyPlugin\");\n\n        parameter.setGradleUserHomeDir(testFile(\"user-home\").asFile());\n\n        parameter.setSearchUpwards(false);\n        parameter.setCacheUsage(CacheUsage.ON);\n        parameter.setCurrentDir(getTestDir());\n\n        return parameter;\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"protected GradleExecution usingProjectDir(TestFile projectDir) {\n        return usingProjectDir(projectDir.asFile());\n    }","id":31993,"modified_method":"protected GradleExecuter usingProjectDir(TestFile projectDir) {\n        return usingProjectDir(projectDir.asFile());\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"protected GradleExecution usingProjectDir(File projectDir) {\n        StartParameter parameter = startParameter();\n        parameter.setProjectDir(projectDir);\n        return new GradleExecution(parameter);\n    }","id":31994,"modified_method":"protected GradleExecuter usingProjectDir(File projectDir) {\n        StartParameter parameter = startParameter();\n        parameter.setProjectDir(projectDir);\n        return new InProcessGradleExecuter(parameter);\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"protected GradleExecution usingBuildFile(TestFile file) {\n        return usingBuildFile(file.asFile());\n    }","id":31995,"modified_method":"protected GradleExecuter usingBuildFile(TestFile file) {\n        return usingBuildFile(file.asFile());\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"protected GradleExecution inTestDirectory() {\n        return inDirectory(testDir);\n    }","id":31996,"modified_method":"protected GradleExecuter inTestDirectory() {\n        return inDirectory(testDir);\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"protected GradleExecution usingBuildScript(String script) {\n        StartParameter parameter = startParameter();\n        parameter.useEmbeddedBuildFile(script);\n        return new GradleExecution(parameter);\n    }","id":31997,"modified_method":"protected GradleExecuter usingBuildScript(String script) {\n        StartParameter parameter = startParameter();\n        parameter.useEmbeddedBuildFile(script);\n        return new InProcessGradleExecuter(parameter);\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"protected GradleExecution inDirectory(File file) {\n        StartParameter parameter = startParameter();\n        parameter.setCurrentDir(file);\n        return new GradleExecution(parameter);\n    }","id":31998,"modified_method":"protected GradleExecuter inDirectory(File directory) {\n        StartParameter parameter = startParameter();\n        return new InProcessGradleExecuter(parameter).inDirectory(directory);\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void reportsTaskActionExecutionFailsFromJavaWithRuntimeException() {\n        File buildFile = getTestBuildFile(\"task-action-execution-failure.gradle\");\n\n        GradleExecutionFailure failure = usingBuildFile(buildFile).runTasksAndExpectFailure(\"brokenJavaTask\");\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasContext(\"Execution failed for task ':brokenJavaTask'\");\n        failure.assertHasDescription(\"broken action\");\n    }","id":31999,"modified_method":"@Test\n    public void reportsTaskActionExecutionFailsFromJavaWithRuntimeException() {\n        File buildFile = getTestBuildFile(\"task-action-execution-failure.gradle\");\n\n        ExecutionFailure failure = usingBuildFile(buildFile).withTasks(\"brokenJavaTask\").runWithFailure();\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasContext(\"Execution failed for task ':brokenJavaTask'\");\n        failure.assertHasDescription(\"broken action\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"}]