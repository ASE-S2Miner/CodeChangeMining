[{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if (stratifiedContexts.size() == 0) // size 0 means that call was made by someone else and we have no data here\n            return null;\n\n        final AlignmentContext context = AlignmentContextUtils.joinContexts(stratifiedContexts.values());\n\n        final int contextWingSize = Math.min((ref.getWindow().size() - 1) / 2, MIN_CONTEXT_WING_SIZE);\n        final int contextSize = contextWingSize * 2 + 1;\n\n        final int locus = ref.getLocus().getStart() + (ref.getLocus().getStop() - ref.getLocus().getStart()) / 2;\n\n        // Compute all haplotypes consistent with the current read pileup\n        ReadBackedPileup pileup = null;\n        if (context.hasExtendedEventPileup())\n            pileup = context.getExtendedEventPileup();\n        else if (context.hasBasePileup())\n            pileup = context.getBasePileup();\n\n        if (pileup == null)\n            return null;\n\n        final List<Haplotype> haplotypes = computeHaplotypes(pileup, contextSize, locus, vc);\n\n        final MathUtils.RunningAverage scoreRA = new MathUtils.RunningAverage();\n        if (haplotypes != null) {\n            for (final Genotype genotype : vc.getGenotypes()) {\n                final AlignmentContext thisContext = stratifiedContexts.get(genotype.getSampleName());\n                if (thisContext != null) {\n                    final ReadBackedPileup thisPileup;\n                    if (thisContext.hasExtendedEventPileup())\n                        thisPileup = thisContext.getExtendedEventPileup();\n                    else if (thisContext.hasBasePileup())\n                        thisPileup = thisContext.getBasePileup();\n                    else\n                        thisPileup = null;\n\n                    if (thisPileup != null) {\n                        if (vc.isSNP())\n                            scoreRA.add(scoreReadsAgainstHaplotypes(haplotypes, thisPileup, contextSize, locus)); // Taking the simple average of all sample's score since the score can be negative and the RMS doesn't make sense\n                        else if (vc.isIndel() || vc.isMixed()) {\n                            Double d = scoreIndelsAgainstHaplotypes(thisPileup);\n                            if (d == null)\n                                return null;\n                            scoreRA.add(d); // Taking the simple average of all sample's score since the score can be negative and the RMS doesn't make sense\n                        } else\n                            return null;\n                    }\n                }\n            }\n        }\n\n        // annotate the score in the info field\n        final Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", scoreRA.mean()));\n        return map;\n    }","id":11000,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if (stratifiedContexts.size() == 0) // size 0 means that call was made by someone else and we have no data here\n            return null;\n\n        if (!vc.isSNP() && !vc.isIndel() && !vc.isMixed())\n            return null;\n\n        final AlignmentContext context = AlignmentContextUtils.joinContexts(stratifiedContexts.values());\n\n        final int contextWingSize = Math.min((ref.getWindow().size() - 1) / 2, MIN_CONTEXT_WING_SIZE);\n        final int contextSize = contextWingSize * 2 + 1;\n\n        final int locus = ref.getLocus().getStart() + (ref.getLocus().getStop() - ref.getLocus().getStart()) / 2;\n\n        if ( !context.hasBasePileup() )\n            return null;\n\n        final ReadBackedPileup pileup = context.getBasePileup();\n\n        // Compute all haplotypes consistent with the current read pileup\n        final List<Haplotype> haplotypes = computeHaplotypes(pileup, contextSize, locus, vc);\n\n        final MathUtils.RunningAverage scoreRA = new MathUtils.RunningAverage();\n        if (haplotypes != null) {\n            for (final Genotype genotype : vc.getGenotypes()) {\n                final AlignmentContext thisContext = stratifiedContexts.get(genotype.getSampleName());\n                if (thisContext != null && thisContext.hasBasePileup()) {\n                    final ReadBackedPileup thisPileup = thisContext.getBasePileup();\n                    if (vc.isSNP())\n                        scoreRA.add(scoreReadsAgainstHaplotypes(haplotypes, thisPileup, contextSize, locus)); // Taking the simple average of all sample's score since the score can be negative and the RMS doesn't make sense\n                    else if (vc.isIndel() || vc.isMixed()) {\n                        Double d = scoreIndelsAgainstHaplotypes(thisPileup);\n                        if (d == null)\n                            return null;\n                        scoreRA.add(d); // Taking the simple average of all sample's score since the score can be negative and the RMS doesn't make sense\n                    }\n                }\n            }\n        }\n\n        // annotate the score in the info field\n        final Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", scoreRA.mean()));\n        return map;\n    }","commit_id":"44ac49aa346d6757b41fe99d40930dd271df7fcd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if (stratifiedContexts.size() == 0)\n            return null;\n\n        final GenotypesContext genotypes = vc.getGenotypes();\n        if (genotypes == null || genotypes.size() == 0)\n            return null;\n\n\n        final ArrayList<Double> refQuals = new ArrayList<Double>();\n        final ArrayList<Double> altQuals = new ArrayList<Double>();\n\n        if ( vc.isSNP() ) {\n            final List<Byte> altAlleles = new ArrayList<Byte>();\n            for ( final Allele a : vc.getAlternateAlleles() )\n                altAlleles.add(a.getBases()[0]);\n\n            for ( final Genotype genotype : genotypes.iterateInSampleNameOrder() ) {\n                final AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n                if ( context == null )\n                    continue;\n\n                fillQualsFromPileup(ref.getBase(), altAlleles, context.getBasePileup(), refQuals, altQuals);\n            }\n        } else if ( vc.isIndel() || vc.isMixed() ) {\n\n            for (final Genotype genotype : genotypes.iterateInSampleNameOrder()) {\n                final AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n                if (context == null) {\n                    continue;\n                }\n\n                ReadBackedPileup pileup = null;\n                if (context.hasExtendedEventPileup())\n                    pileup = context.getExtendedEventPileup();\n                else if (context.hasBasePileup())\n                    pileup = context.getBasePileup();\n\n                if (pileup == null)\n                    continue;\n\n                if (IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap() == null ||\n                        IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap().size() == 0)\n                    return null;\n\n                fillIndelQualsFromPileup(pileup, refQuals, altQuals);\n            }\n        } else\n            return null;\n\n        final MannWhitneyU mannWhitneyU = new MannWhitneyU();\n        for (final Double qual : altQuals) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET1);\n        }\n        for (final Double qual : refQuals) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET2);\n        }\n\n        if (DEBUG) {\n            System.out.format(\"%s, REF QUALS:\", this.getClass().getName());\n            for (final Double qual : refQuals)\n                System.out.format(\"%4.1f \", qual);\n            System.out.println();\n            System.out.format(\"%s, ALT QUALS:\", this.getClass().getName());\n            for (final Double qual : altQuals)\n                System.out.format(\"%4.1f \", qual);\n            System.out.println();\n\n        }\n        // we are testing that set1 (the alt bases) have lower quality scores than set2 (the ref bases)\n        final Pair<Double, Double> testResults = mannWhitneyU.runOneSidedTest(MannWhitneyU.USet.SET1);\n\n        final Map<String, Object> map = new HashMap<String, Object>();\n        if (!Double.isNaN(testResults.first))\n            map.put(getKeyNames().get(0), String.format(\"%.3f\", testResults.first));\n        return map;\n\n    }","id":11001,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if (stratifiedContexts.size() == 0)\n            return null;\n\n        final GenotypesContext genotypes = vc.getGenotypes();\n        if (genotypes == null || genotypes.size() == 0)\n            return null;\n\n\n        final ArrayList<Double> refQuals = new ArrayList<Double>();\n        final ArrayList<Double> altQuals = new ArrayList<Double>();\n\n        if ( vc.isSNP() ) {\n            final List<Byte> altAlleles = new ArrayList<Byte>();\n            for ( final Allele a : vc.getAlternateAlleles() )\n                altAlleles.add(a.getBases()[0]);\n\n            for ( final Genotype genotype : genotypes.iterateInSampleNameOrder() ) {\n                final AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n                if ( context == null )\n                    continue;\n\n                fillQualsFromPileup(ref.getBase(), altAlleles, context.getBasePileup(), refQuals, altQuals);\n            }\n        } else if ( vc.isIndel() || vc.isMixed() ) {\n\n            for (final Genotype genotype : genotypes.iterateInSampleNameOrder()) {\n                final AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n                if (context == null) {\n                    continue;\n                }\n\n                if (!context.hasBasePileup())\n                    continue;\n\n                final ReadBackedPileup pileup = context.getBasePileup();\n                if (pileup == null)\n                    continue;\n\n                if (IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap() == null ||\n                        IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap().size() == 0)\n                    return null;\n\n                fillIndelQualsFromPileup(pileup, refQuals, altQuals);\n            }\n        } else\n            return null;\n\n        final MannWhitneyU mannWhitneyU = new MannWhitneyU();\n        for (final Double qual : altQuals) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET1);\n        }\n        for (final Double qual : refQuals) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET2);\n        }\n\n        if (DEBUG) {\n            System.out.format(\"%s, REF QUALS:\", this.getClass().getName());\n            for (final Double qual : refQuals)\n                System.out.format(\"%4.1f \", qual);\n            System.out.println();\n            System.out.format(\"%s, ALT QUALS:\", this.getClass().getName());\n            for (final Double qual : altQuals)\n                System.out.format(\"%4.1f \", qual);\n            System.out.println();\n\n        }\n        // we are testing that set1 (the alt bases) have lower quality scores than set2 (the ref bases)\n        final Pair<Double, Double> testResults = mannWhitneyU.runOneSidedTest(MannWhitneyU.USet.SET1);\n\n        final Map<String, Object> map = new HashMap<String, Object>();\n        if (!Double.isNaN(testResults.first))\n            map.put(getKeyNames().get(0), String.format(\"%.3f\", testResults.first));\n        return map;\n\n    }","commit_id":"44ac49aa346d6757b41fe99d40930dd271df7fcd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Prepare the output file and the list of available features.\n     */\n    public void initialize() {\n\n        if ( LIST )\n            listAnnotationsAndExit();\n\n        // get the list of all sample names from the variant VCF input rod, if applicable\n        List<String> rodName = Arrays.asList(variantCollection.variants.getName());\n        Set<String> samples = SampleUtils.getUniqueSamplesFromRods(getToolkit(), rodName);\n\n        if ( USE_ALL_ANNOTATIONS )\n            engine = new VariantAnnotatorEngine(annotationsToExclude, this, getToolkit());\n        else\n            engine = new VariantAnnotatorEngine(annotationGroupsToUse, annotationsToUse, annotationsToExclude, this, getToolkit());\n        engine.initializeExpressions(expressionsToUse);\n        engine.setRequireStrictAlleleMatch(requireStrictAlleleMatch);\n\n        // setup the header fields\n        // note that if any of the definitions conflict with our new ones, then we want to overwrite the old ones\n        Set<VCFHeaderLine> hInfo = new HashSet<VCFHeaderLine>();\n        hInfo.addAll(engine.getVCFAnnotationDescriptions());\n        for ( VCFHeaderLine line : VCFUtils.getHeaderFields(getToolkit(), Arrays.asList(variantCollection.variants.getName())) ) {\n            if ( isUniqueHeaderLine(line, hInfo) )\n                hInfo.add(line);\n        }\n        // for the expressions, pull the info header line from the header of the resource rod\n        for ( VariantAnnotatorEngine.VAExpression expression : engine.getRequestedExpressions() ) {\n            // special case the ID field\n            if ( expression.fieldName.equals(\"ID\") ) {\n                hInfo.add(new VCFInfoHeaderLine(expression.fullName, 1, VCFHeaderLineType.String, \"ID field transferred from external VCF resource\"));\n                continue;\n            }\n            VCFInfoHeaderLine targetHeaderLine = null;\n            for ( VCFHeaderLine line : VCFUtils.getHeaderFields(getToolkit(), Arrays.asList(expression.binding.getName())) ) {\n                if ( line instanceof VCFInfoHeaderLine ) {\n                    VCFInfoHeaderLine infoline = (VCFInfoHeaderLine)line;\n                    if ( infoline.getID().equals(expression.fieldName) ) {\n                        targetHeaderLine = infoline;\n                        break;\n                    }\n                }\n            }\n\n            if ( targetHeaderLine != null ) {\n                if ( targetHeaderLine.getCountType() == VCFHeaderLineCount.INTEGER )\n                    hInfo.add(new VCFInfoHeaderLine(expression.fullName, targetHeaderLine.getCount(), targetHeaderLine.getType(), targetHeaderLine.getDescription()));\n                else\n                    hInfo.add(new VCFInfoHeaderLine(expression.fullName, targetHeaderLine.getCountType(), targetHeaderLine.getType(), targetHeaderLine.getDescription()));\n            } else {\n                hInfo.add(new VCFInfoHeaderLine(expression.fullName, VCFHeaderLineCount.UNBOUNDED, VCFHeaderLineType.String, \"Value transferred from another external VCF resource\"));\n            }\n        }\n\n        engine.invokeAnnotationInitializationMethods(hInfo);\n\n        VCFHeader vcfHeader = new VCFHeader(hInfo, samples);\n        vcfWriter.writeHeader(vcfHeader);\n\n        if ( indelsOnly ) {\n            indelBufferContext = null;\n        }\n    }","id":11002,"modified_method":"/**\n     * Prepare the output file and the list of available features.\n     */\n    public void initialize() {\n\n        if ( LIST )\n            listAnnotationsAndExit();\n\n        // get the list of all sample names from the variant VCF input rod, if applicable\n        List<String> rodName = Arrays.asList(variantCollection.variants.getName());\n        Set<String> samples = SampleUtils.getUniqueSamplesFromRods(getToolkit(), rodName);\n\n        if ( USE_ALL_ANNOTATIONS )\n            engine = new VariantAnnotatorEngine(annotationsToExclude, this, getToolkit());\n        else\n            engine = new VariantAnnotatorEngine(annotationGroupsToUse, annotationsToUse, annotationsToExclude, this, getToolkit());\n        engine.initializeExpressions(expressionsToUse);\n        engine.setRequireStrictAlleleMatch(requireStrictAlleleMatch);\n\n        // setup the header fields\n        // note that if any of the definitions conflict with our new ones, then we want to overwrite the old ones\n        Set<VCFHeaderLine> hInfo = new HashSet<VCFHeaderLine>();\n        hInfo.addAll(engine.getVCFAnnotationDescriptions());\n        for ( VCFHeaderLine line : VCFUtils.getHeaderFields(getToolkit(), Arrays.asList(variantCollection.variants.getName())) ) {\n            if ( isUniqueHeaderLine(line, hInfo) )\n                hInfo.add(line);\n        }\n        // for the expressions, pull the info header line from the header of the resource rod\n        for ( VariantAnnotatorEngine.VAExpression expression : engine.getRequestedExpressions() ) {\n            // special case the ID field\n            if ( expression.fieldName.equals(\"ID\") ) {\n                hInfo.add(new VCFInfoHeaderLine(expression.fullName, 1, VCFHeaderLineType.String, \"ID field transferred from external VCF resource\"));\n                continue;\n            }\n            VCFInfoHeaderLine targetHeaderLine = null;\n            for ( VCFHeaderLine line : VCFUtils.getHeaderFields(getToolkit(), Arrays.asList(expression.binding.getName())) ) {\n                if ( line instanceof VCFInfoHeaderLine ) {\n                    VCFInfoHeaderLine infoline = (VCFInfoHeaderLine)line;\n                    if ( infoline.getID().equals(expression.fieldName) ) {\n                        targetHeaderLine = infoline;\n                        break;\n                    }\n                }\n            }\n\n            if ( targetHeaderLine != null ) {\n                if ( targetHeaderLine.getCountType() == VCFHeaderLineCount.INTEGER )\n                    hInfo.add(new VCFInfoHeaderLine(expression.fullName, targetHeaderLine.getCount(), targetHeaderLine.getType(), targetHeaderLine.getDescription()));\n                else\n                    hInfo.add(new VCFInfoHeaderLine(expression.fullName, targetHeaderLine.getCountType(), targetHeaderLine.getType(), targetHeaderLine.getDescription()));\n            } else {\n                hInfo.add(new VCFInfoHeaderLine(expression.fullName, VCFHeaderLineCount.UNBOUNDED, VCFHeaderLineType.String, \"Value transferred from another external VCF resource\"));\n            }\n        }\n\n        engine.invokeAnnotationInitializationMethods(hInfo);\n\n        VCFHeader vcfHeader = new VCFHeader(hInfo, samples);\n        vcfWriter.writeHeader(vcfHeader);\n    }","commit_id":"44ac49aa346d6757b41fe99d40930dd271df7fcd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For each site of interest, annotate based on the requested annotation types\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      the reference base\n     * @param context  the context for the given locus\n     * @return 1 if the locus was successfully processed, 0 if otherwise\n     */\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null )\n            return 0;\n\n        Collection<VariantContext> VCs = tracker.getValues(variantCollection.variants, context.getLocation());\n        if ( VCs.size() == 0 )\n            return 0;\n\n        Collection<VariantContext> annotatedVCs = VCs;\n\n        // if the reference base is not ambiguous, we can annotate\n        Map<String, AlignmentContext> stratifiedContexts;\n        if ( BaseUtils.simpleBaseToBaseIndex(ref.getBase()) != -1 ) {\n            if ( ! context.hasExtendedEventPileup() ) {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getBasePileup());\n            } else {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getExtendedEventPileup());\n            }\n            if ( stratifiedContexts != null ) {\n                annotatedVCs = new ArrayList<VariantContext>(VCs.size());\n                for ( VariantContext vc : VCs )\n                    annotatedVCs.add(engine.annotateContext(tracker, ref, stratifiedContexts, vc));\n            }\n        }\n\n        if ( ! indelsOnly ) {\n            for ( VariantContext annotatedVC : annotatedVCs )\n                vcfWriter.add(annotatedVC);\n        } else {\n            // check to see if the buffered context is different (in location) this context\n            if ( indelBufferContext != null && ! VariantContextUtils.getLocation(getToolkit().getGenomeLocParser(),indelBufferContext.iterator().next()).equals(VariantContextUtils.getLocation(getToolkit().getGenomeLocParser(),annotatedVCs.iterator().next())) ) {\n                for ( VariantContext annotatedVC : indelBufferContext )\n                    vcfWriter.add(annotatedVC);\n                indelBufferContext = annotatedVCs;\n            } else {\n                indelBufferContext = annotatedVCs;\n            }\n        }\n\n        return 1;\n    }","id":11003,"modified_method":"/**\n     * For each site of interest, annotate based on the requested annotation types\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      the reference base\n     * @param context  the context for the given locus\n     * @return 1 if the locus was successfully processed, 0 if otherwise\n     */\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null )\n            return 0;\n\n        Collection<VariantContext> VCs = tracker.getValues(variantCollection.variants, context.getLocation());\n        if ( VCs.size() == 0 )\n            return 0;\n\n        Collection<VariantContext> annotatedVCs = VCs;\n\n        // if the reference base is not ambiguous, we can annotate\n        Map<String, AlignmentContext> stratifiedContexts;\n        if ( BaseUtils.simpleBaseToBaseIndex(ref.getBase()) != -1 ) {\n            if ( ! context.hasExtendedEventPileup() ) {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getBasePileup());\n            } else {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getExtendedEventPileup());\n            }\n            if ( stratifiedContexts != null ) {\n                annotatedVCs = new ArrayList<VariantContext>(VCs.size());\n                for ( VariantContext vc : VCs )\n                    annotatedVCs.add(engine.annotateContext(tracker, ref, stratifiedContexts, vc));\n            }\n        }\n\n        for ( VariantContext annotatedVC : annotatedVCs )\n            vcfWriter.add(annotatedVC);\n\n        return 1;\n    }","commit_id":"44ac49aa346d6757b41fe99d40930dd271df7fcd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n        \n        if ( !vc.isBiallelic() )\n            return null;\n        final GenotypesContext genotypes = vc.getGenotypes();\n        if ( !vc.hasGenotypes() )\n            return null;\n\n        double ratio = 0.0;\n        double totalWeights = 0.0;\n        for ( Genotype genotype : genotypes ) {\n            // we care only about het calls\n            if ( !genotype.isHet() )\n                continue;\n\n            AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n            if ( context == null )\n                continue;\n\n            if ( vc.isSNP() && context.hasBasePileup() ) {\n                final String bases = new String(context.getBasePileup().getBases());\n                if ( bases.length() == 0 )\n                    return null;\n                char refChr = vc.getReference().toString().charAt(0);\n                char altChr = vc.getAlternateAllele(0).toString().charAt(0);\n\n                int refCount = MathUtils.countOccurrences(refChr, bases);\n                int altCount = MathUtils.countOccurrences(altChr, bases);\n\n                // sanity check\n                if ( refCount + altCount == 0 )\n                    continue;\n\n                // weight the allele balance by genotype quality so that e.g. mis-called homs don't affect the ratio too much\n                ratio += genotype.getLog10PError() * ((double)refCount / (double)(refCount + altCount));\n                totalWeights += genotype.getLog10PError();\n            } else if ( vc.isIndel() && context.hasExtendedEventPileup() ) {\n                final ReadBackedExtendedEventPileup indelPileup = context.getExtendedEventPileup();\n                if ( indelPileup == null ) {\n                    continue;\n                }\n                // todo -- actually care about indel length from the pileup (agnostic at the moment)\n                int refCount = indelPileup.getNumberOfElements();\n                int altCount = vc.isSimpleInsertion() ? indelPileup.getNumberOfInsertions() : indelPileup.getNumberOfDeletions();\n\n                if ( refCount + altCount == 0 ) {\n                    continue;\n                }\n\n                ratio += /* todo -- make not uniform */ 1 * ((double) refCount) / (double) (refCount + altCount);\n                totalWeights += 1;\n            }\n        }\n\n        // make sure we had a het genotype\n        if ( MathUtils.compareDoubles(totalWeights, 0.0) == 0 )\n            return null;\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.3f\", (ratio / totalWeights)));\n        return map;\n    }","id":11004,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n        \n        if ( !vc.isBiallelic() )\n            return null;\n        final GenotypesContext genotypes = vc.getGenotypes();\n        if ( !vc.hasGenotypes() )\n            return null;\n\n        double ratio = 0.0;\n        double totalWeights = 0.0;\n        for ( Genotype genotype : genotypes ) {\n            // we care only about het calls\n            if ( !genotype.isHet() )\n                continue;\n\n            AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n            if ( context == null || !context.hasBasePileup() )\n                continue;\n\n            final ReadBackedPileup pileup = context.getBasePileup();\n            if ( vc.isSNP() ) {\n                final String bases = new String(pileup.getBases());\n                if ( bases.length() == 0 )\n                    return null;\n                final char refChr = vc.getReference().toString().charAt(0);\n                final char altChr = vc.getAlternateAllele(0).toString().charAt(0);\n\n                final int refCount = MathUtils.countOccurrences(refChr, bases);\n                final int altCount = MathUtils.countOccurrences(altChr, bases);\n\n                // sanity check\n                if ( refCount + altCount == 0 )\n                    continue;\n\n                // weight the allele balance by genotype quality so that e.g. mis-called homs don't affect the ratio too much\n                ratio += genotype.getLog10PError() * ((double)refCount / (double)(refCount + altCount));\n                totalWeights += genotype.getLog10PError();\n            }\n            // Allele Balance for indels was not being computed correctly (since there was no allele matching).  Instead of\n            // prolonging the life of imperfect code, I've decided to delete it.  If someone else wants to try again from\n            // scratch, be my guest - but make sure it's done correctly!  [EB]\n        }\n\n        // make sure we had a het genotype\n        if ( MathUtils.compareDoubles(totalWeights, 0.0) == 0 )\n            return null;\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.3f\", (ratio / totalWeights)));\n        return map;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     Allocate and fill a 2x2 strand contingency table.  In the end, it'll look something like this:\n     *             fw      rc\n     *   allele1   #       #\n     *   allele2   #       #\n     * @return a 2x2 contingency table\n     */\n    private static int[][] getIndelContingencyTable(Map<String, AlignmentContext> stratifiedContexts) {\n        final double INDEL_LIKELIHOOD_THRESH = 0.3;\n        final HashMap<PileupElement,LinkedHashMap<Allele,Double>> indelLikelihoodMap = IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap();\n\n        if (indelLikelihoodMap == null)\n            return null;\n        \n        int[][] table = new int[2][2];\n\n        for ( String sample : stratifiedContexts.keySet() ) {\n            final AlignmentContext context = stratifiedContexts.get(sample);\n            if ( context == null ) \n                continue;\n\n            ReadBackedPileup pileup = null;\n             if (context.hasExtendedEventPileup())\n                 pileup = context.getExtendedEventPileup();\n             else if (context.hasBasePileup())\n                 pileup = context.getBasePileup();\n\n             if (pileup == null)\n                 continue;\n\n            for (final PileupElement p: pileup) {\n                if ( p.getRead().isReducedRead() ) // ignore reduced reads\n                    continue;\n                if ( p.getRead().getMappingQuality() < 20)\n                    continue;\n                if (indelLikelihoodMap.containsKey(p)) {\n                    // to classify a pileup element as ref or alt, we look at the likelihood associated with the allele associated to this element.\n                    // A pileup element then has a list of pairs of form (Allele, likelihood of this allele).\n                    // To classify a pileup element as Ref or Alt, we look at the likelihood of corresponding alleles.\n                    // If likelihood of ref allele > highest likelihood of all alt alleles  + epsilon, then this pileup element is \"ref\"\n                    // otherwise  if highest alt allele likelihood is > ref likelihood + epsilon, then this pileup element it \"alt\"\n                    // retrieve likelihood information corresponding to this read\n                    LinkedHashMap<Allele,Double> el = indelLikelihoodMap.get(p);\n                    // by design, first element in LinkedHashMap was ref allele\n                    boolean isFW = !p.getRead().getReadNegativeStrandFlag();\n\n                    double refLikelihood=0.0, altLikelihood=Double.NEGATIVE_INFINITY;\n\n                    for (Allele a : el.keySet()) {\n\n                        if (a.isReference())\n                            refLikelihood =el.get(a);\n                        else {\n                            double like = el.get(a);\n                            if (like >= altLikelihood)\n                                altLikelihood = like;\n                        }\n                    }\n\n                    boolean matchesRef = (refLikelihood > (altLikelihood + INDEL_LIKELIHOOD_THRESH));\n                    boolean matchesAlt = (altLikelihood > (refLikelihood + INDEL_LIKELIHOOD_THRESH));\n                    if ( matchesRef || matchesAlt ) {\n                        int row = matchesRef ? 0 : 1;\n                        int column = isFW ? 0 : 1;\n\n                         table[row][column]++;\n                    }\n\n\n                }\n            }\n        }\n\n        return table;\n    }","id":11005,"modified_method":"/**\n     Allocate and fill a 2x2 strand contingency table.  In the end, it'll look something like this:\n     *             fw      rc\n     *   allele1   #       #\n     *   allele2   #       #\n     * @return a 2x2 contingency table\n     */\n    private static int[][] getIndelContingencyTable(Map<String, AlignmentContext> stratifiedContexts) {\n        final double INDEL_LIKELIHOOD_THRESH = 0.3;\n        final HashMap<PileupElement,LinkedHashMap<Allele,Double>> indelLikelihoodMap = IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap();\n\n        if (indelLikelihoodMap == null)\n            return null;\n        \n        int[][] table = new int[2][2];\n\n        for ( String sample : stratifiedContexts.keySet() ) {\n            final AlignmentContext context = stratifiedContexts.get(sample);\n            if ( context == null || !context.hasBasePileup() )\n                continue;\n\n            final ReadBackedPileup pileup = context.getBasePileup();\n            for ( final PileupElement p : pileup ) {\n                if ( p.getRead().isReducedRead() ) // ignore reduced reads\n                    continue;\n                if ( p.getRead().getMappingQuality() < 20 )\n                    continue;\n                if ( indelLikelihoodMap.containsKey(p) ) {\n                    // to classify a pileup element as ref or alt, we look at the likelihood associated with the allele associated to this element.\n                    // A pileup element then has a list of pairs of form (Allele, likelihood of this allele).\n                    // To classify a pileup element as Ref or Alt, we look at the likelihood of corresponding alleles.\n                    // If likelihood of ref allele > highest likelihood of all alt alleles  + epsilon, then this pileup element is \"ref\"\n                    // otherwise  if highest alt allele likelihood is > ref likelihood + epsilon, then this pileup element it \"alt\"\n                    // retrieve likelihood information corresponding to this read\n                    LinkedHashMap<Allele,Double> el = indelLikelihoodMap.get(p);\n                    // by design, first element in LinkedHashMap was ref allele\n                    boolean isFW = !p.getRead().getReadNegativeStrandFlag();\n\n                    double refLikelihood=0.0, altLikelihood=Double.NEGATIVE_INFINITY;\n\n                    for (Allele a : el.keySet()) {\n\n                        if (a.isReference())\n                            refLikelihood =el.get(a);\n                        else {\n                            double like = el.get(a);\n                            if (like >= altLikelihood)\n                                altLikelihood = like;\n                        }\n                    }\n\n                    boolean matchesRef = (refLikelihood > (altLikelihood + INDEL_LIKELIHOOD_THRESH));\n                    boolean matchesAlt = (altLikelihood > (refLikelihood + INDEL_LIKELIHOOD_THRESH));\n                    if ( matchesRef || matchesAlt ) {\n                        int row = matchesRef ? 0 : 1;\n                        int column = isFW ? 0 : 1;\n\n                         table[row][column]++;\n                    }\n\n\n                }\n            }\n        }\n\n        return table;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int mq0 = 0;\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null) {\n                for (PileupElement p : pileup ) {\n                    if ( p.getMappingQual() == 0 )\n                        mq0++;\n                }\n            }\n        }\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%d\", mq0));\n        return map;\n    }","id":11006,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int mq0 = 0;\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            final AlignmentContext context = sample.getValue();\n            if ( context.hasBasePileup() ) {\n                final ReadBackedPileup pileup = context.getBasePileup();\n                for (PileupElement p : pileup ) {\n                    if ( p.getMappingQual() == 0 )\n                        mq0++;\n                }\n            }\n        }\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%d\", mq0));\n        return map;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker,\n                                        AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext context, VariantContext vc, Genotype g) {\n        if ( g == null || !g.isCalled() )\n            return null;\n\n        int mq0 = 0;\n        ReadBackedPileup pileup = null;\n        if (vc.isIndel() && context.hasExtendedEventPileup())\n            pileup = context.getExtendedEventPileup();\n        else if (context.hasBasePileup())\n            pileup = context.getBasePileup();\n        else return null;\n\n        if (pileup != null) {\n            for (PileupElement p : pileup ) {\n                if ( p.getMappingQual() == 0 )\n                    mq0++;\n            }\n        }\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%d\", mq0));\n        return map;\n    }","id":11007,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker,\n                                        AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext context, VariantContext vc, Genotype g) {\n        if ( g == null || !g.isCalled() )\n            return null;\n\n        int mq0 = 0;\n        if ( context.hasBasePileup() ) {\n            final ReadBackedPileup pileup = context.getBasePileup();\n            for (PileupElement p : pileup ) {\n                if ( p.getMappingQual() == 0 )\n                    mq0++;\n            }\n        }\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%d\", mq0));\n        return map;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int mq0 = 0;\n        int depth = 0;\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            depth += context.size();\n             ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null) {\n                for (PileupElement p : pileup ) {\n                    if ( p.getMappingQual() == 0 )\n                        mq0++;\n                }\n            }\n        }\n        if (depth > 0) {\n            double mq0f = (double)mq0 / (double )depth;\n\n            Map<String, Object> map = new HashMap<String, Object>();\n            map.put(getKeyNames().get(0), String.format(\"%1.4f\", mq0f));\n            return map;\n        }\n        else\n            return null;\n    }","id":11008,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int mq0 = 0;\n        int depth = 0;\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            depth += context.size();\n            if ( context.hasBasePileup() ) {\n                final ReadBackedPileup pileup = context.getBasePileup();\n                for (PileupElement p : pileup ) {\n                    if ( p.getMappingQual() == 0 )\n                        mq0++;\n                }\n            }\n        }\n        if (depth > 0) {\n            double mq0f = (double)mq0 / (double )depth;\n\n            Map<String, Object> map = new HashMap<String, Object>();\n            map.put(getKeyNames().get(0), String.format(\"%1.4f\", mq0f));\n            return map;\n        }\n        else\n            return null;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        final GenotypesContext genotypes = vc.getGenotypes();\n        if ( genotypes == null || genotypes.size() == 0 )\n            return null;\n\n        int depth = 0;\n\n        for ( final Genotype genotype : genotypes ) {\n\n            // we care only about variant calls with likelihoods\n            if ( !genotype.isHet() && !genotype.isHomVar() )\n                continue;\n\n            AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n            if ( context == null )\n                continue;\n\n            depth += context.hasBasePileup() ? context.getBasePileup().depthOfCoverage() : context.getExtendedEventPileup().depthOfCoverage();\n        }\n\n        if ( depth == 0 )\n            return null;\n\n        double QD = -10.0 * vc.getLog10PError() / (double)depth;\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.2f\", QD));\n        return map;\n    }","id":11009,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        final GenotypesContext genotypes = vc.getGenotypes();\n        if ( genotypes == null || genotypes.size() == 0 )\n            return null;\n\n        int depth = 0;\n\n        for ( final Genotype genotype : genotypes ) {\n\n            // we care only about variant calls with likelihoods\n            if ( !genotype.isHet() && !genotype.isHomVar() )\n                continue;\n\n            AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n            if ( context == null )\n                continue;\n\n            depth += context.hasBasePileup() ? context.getBasePileup().depthOfCoverage() : 0;\n        }\n\n        if ( depth == 0 )\n            return null;\n\n        double QD = -10.0 * vc.getLog10PError() / (double)depth;\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.2f\", QD));\n        return map;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int totalSize = 0;\n        for ( AlignmentContext context : stratifiedContexts.values() )\n            totalSize += context.size();\n\n        int[] qualities = new int[totalSize];\n        int index = 0;\n\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null) {\n                for (PileupElement p : pileup ) {\n                    if ( p.getMappingQual() != QualityUtils.MAPPING_QUALITY_UNAVAILABLE )\n                        qualities[index++] = p.getMappingQual();\n                }\n            }\n        }\n\n        double rms = MathUtils.rms(qualities);\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.2f\", rms));\n        return map;\n    }","id":11010,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int totalSize = 0;\n        for ( AlignmentContext context : stratifiedContexts.values() )\n            totalSize += context.size();\n\n        int[] qualities = new int[totalSize];\n        int index = 0;\n\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            if ( context.hasBasePileup() ) {\n                final ReadBackedPileup pileup = context.getBasePileup();\n                for (PileupElement p : pileup ) {\n                    if ( p.getMappingQual() != QualityUtils.MAPPING_QUALITY_UNAVAILABLE )\n                        qualities[index++] = p.getMappingQual();\n                }\n            }\n        }\n\n        double rms = MathUtils.rms(qualities);\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.2f\", rms));\n        return map;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        // not meaningful when we're at an indel location: deletions that start at location N are by definition called at the position  N-1, and at position N-1\n        // there are no informative deletions in the pileup\n        if (!vc.isSNP())\n            return null;\n\n        int deletions = 0;\n        int depth = 0;\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null) {\n                deletions += pileup.getNumberOfDeletions();\n                depth += pileup.getNumberOfElements();\n            }\n        }\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.2f\", depth == 0 ? 0.0 : (double)deletions/(double)depth));\n        return map;\n    }","id":11011,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        // not meaningful when we're at an indel location: deletions that start at location N are by definition called at the position  N-1, and at position N-1\n        // there are no informative deletions in the pileup\n        if (!vc.isSNP())\n            return null;\n\n        int deletions = 0;\n        int depth = 0;\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            if ( context.hasBasePileup() ) {\n                final ReadBackedPileup pileup = context.getBasePileup();\n                deletions += pileup.getNumberOfDeletions();\n                depth += pileup.getNumberOfElements();\n            }\n        }\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.2f\", depth == 0 ? 0.0 : (double)deletions/(double)depth));\n        return map;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int readsIllumina = 0;\n        int readsSolid = 0;\n        int reads454 = 0;\n        int readsOther = 0;\n\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null) {\n                for (PileupElement p : pileup ) {\n                    if(ReadUtils.is454Read(p.getRead()))\n                        reads454++;\n                    else if (ReadUtils.isSOLiDRead(p.getRead()))\n                        readsSolid++;\n                    else if (ReadUtils.isSLXRead(p.getRead()))\n                        readsIllumina++;\n                    else\n                        readsOther++;\n                }\n            }\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(nSLX, String.format(\"%d\", readsIllumina));\n        map.put(n454, String.format(\"%d\", reads454));\n        map.put(nSolid, String.format(\"%d\", readsSolid));\n        map.put(nOther, String.format(\"%d\", readsOther));\n            return map;\n    }","id":11012,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n\n        int readsIllumina = 0;\n        int readsSolid = 0;\n        int reads454 = 0;\n        int readsOther = 0;\n\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            AlignmentContext context = sample.getValue();\n            if ( context.hasBasePileup() ) {\n                final ReadBackedPileup pileup = context.getBasePileup();\n                for ( PileupElement p : pileup ) {\n                    if(ReadUtils.is454Read(p.getRead()))\n                        reads454++;\n                    else if (ReadUtils.isSOLiDRead(p.getRead()))\n                        readsSolid++;\n                    else if (ReadUtils.isSLXRead(p.getRead()))\n                        readsIllumina++;\n                    else\n                        readsOther++;\n                }\n            }\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(nSLX, String.format(\"%d\", readsIllumina));\n        map.put(n454, String.format(\"%d\", reads454));\n        map.put(nSolid, String.format(\"%d\", readsSolid));\n        map.put(nOther, String.format(\"%d\", readsOther));\n            return map;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For each site of interest, annotate based on the requested annotation types\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      the reference base\n     * @param context  the context for the given locus\n     * @return 1 if the locus was successfully processed, 0 if otherwise\n     */\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null )\n            return 0;\n\n        Collection<VariantContext> VCs = tracker.getValues(variantCollection.variants, context.getLocation());\n        if ( VCs.size() == 0 )\n            return 0;\n\n        Collection<VariantContext> annotatedVCs = VCs;\n\n        // if the reference base is not ambiguous, we can annotate\n        Map<String, AlignmentContext> stratifiedContexts;\n        if ( BaseUtils.simpleBaseToBaseIndex(ref.getBase()) != -1 ) {\n            if ( ! context.hasExtendedEventPileup() ) {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getBasePileup());\n            } else {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getExtendedEventPileup());\n            }\n            if ( stratifiedContexts != null ) {\n                annotatedVCs = new ArrayList<VariantContext>(VCs.size());\n                for ( VariantContext vc : VCs )\n                    annotatedVCs.add(engine.annotateContext(tracker, ref, stratifiedContexts, vc));\n            }\n        }\n\n        for ( VariantContext annotatedVC : annotatedVCs )\n            vcfWriter.add(annotatedVC);\n\n        return 1;\n    }","id":11013,"modified_method":"/**\n     * For each site of interest, annotate based on the requested annotation types\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      the reference base\n     * @param context  the context for the given locus\n     * @return 1 if the locus was successfully processed, 0 if otherwise\n     */\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null )\n            return 0;\n\n        Collection<VariantContext> VCs = tracker.getValues(variantCollection.variants, context.getLocation());\n        if ( VCs.size() == 0 )\n            return 0;\n\n        Collection<VariantContext> annotatedVCs = VCs;\n\n        // if the reference base is not ambiguous, we can annotate\n        Map<String, AlignmentContext> stratifiedContexts;\n        if ( BaseUtils.simpleBaseToBaseIndex(ref.getBase()) != -1 ) {\n            if ( context.hasBasePileup() ) {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getBasePileup());\n                annotatedVCs = new ArrayList<VariantContext>(VCs.size());\n                for ( VariantContext vc : VCs )\n                    annotatedVCs.add(engine.annotateContext(tracker, ref, stratifiedContexts, vc));\n            }\n        }\n\n        for ( VariantContext annotatedVC : annotatedVCs )\n            vcfWriter.add(annotatedVC);\n\n        return 1;\n    }","commit_id":"b467cd1daebe5fcb82f43476e393caaf4a1b840d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * If the given resourceType is starting with a \"/\", it will strip out the leading search path from the given resource type.\n     * Otherwise it will just return the given resource type (as this is already relative).\n     * @param resourceType\n     * @return a relative resource type (without the leading search path)\n     * @throws IllegalArgumentException in case the resource type is starting with a \"/\" but not with any of the search paths.\n     */\n    @SuppressWarnings(\"null\")\n\tprotected @Nonnull String getRelativeResourceType(@Nonnull String resourceType) throws IllegalArgumentException {\n        if (resourceType.startsWith(\"/\")) {\n            LOG.debug(\"try to strip the search path from the resource type\");\n            ResourceResolver rr = null;\n            try {\n                rr = rrf.getAdministrativeResourceResolver(null);\n                for (String searchPath : rr.getSearchPath()) {\n                    if (resourceType.startsWith(searchPath)) {\n                        resourceType = resourceType.substring(searchPath.length());\n                        return resourceType;\n                    }\n                }\n                throw new IllegalArgumentException(\"Can only deal with resource types inside the resource resolver's search path (\" + StringUtils.join(rr.getSearchPath()) \n                        + \") but given resource type \" + resourceType + \" is outside!\");\n            } catch (LoginException e) {\n                throw new IllegalStateException(\"Could not login as administrator to figure out search paths\", e);\n            } finally {\n                if (rr != null) {\n                    rr.close();\n                }\n            }\n        }\n        return resourceType;\n        \n    }","id":11014,"modified_method":"/**\n     * If the given resourceType is starting with a \"/\", it will strip out the leading search path from the given resource type.\n     * Otherwise it will just return the given resource type (as this is already relative).\n     * @param resourceType\n     * @return a relative resource type (without the leading search path)\n     * @throws IllegalArgumentException in case the resource type is starting with a \"/\" but not with any of the search paths.\n     */\n    @SuppressWarnings(\"null\")\n    protected @Nonnull String getRelativeResourceType(@Nonnull String resourceType) throws IllegalArgumentException {\n        if (resourceType.startsWith(\"/\")) {\n            LOG.debug(\"try to strip the search path from the resource type\");\n            for (String searchPath : searchPaths) {\n                if (resourceType.startsWith(searchPath)) {\n                    resourceType = resourceType.substring(searchPath.length());\n                    return resourceType;\n                }\n            }\n            throw new IllegalArgumentException(\n                    \"Can only deal with resource types inside the resource resolver's search path (\"\n                            + StringUtils.join(searchPaths.toArray()) + \") but given resource type \" + resourceType\n                            + \" is outside!\");\n        }\n        return resourceType;\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"private void validateValueMap(ValueMap valueMap, String relativePath, Set<ResourceProperty> resourceProperties,\n            ValidationResultImpl result) {\n        if (valueMap == null) {\n            throw new IllegalArgumentException(\"ValueMap may not be null\");\n        }\n        for (ResourceProperty resourceProperty : resourceProperties) {\n        \tPattern pattern = resourceProperty.getNamePattern();\n            if (pattern != null) {\n                boolean foundMatch = false;\n                for (String key : valueMap.keySet()) {\n                    if (pattern.matcher(key).matches()) {\n                        foundMatch = true;\n                        validateValueMap(key, valueMap, relativePath, resourceProperty, result);\n                    }\n                }\n                if (!foundMatch && resourceProperty.isRequired()) {\n                    result.addFailureMessage(relativePath + resourceProperty.getNamePattern(), \"Missing required property.\");\n                }\n            } else {\n                validateValueMap(resourceProperty.getName(), valueMap, relativePath, resourceProperty, result);\n            }\n        }\n    }","id":11015,"modified_method":"private void validateValueMap(ValueMap valueMap, String relativePath, List<ResourceProperty> resourceProperties,\n            ValidationResultImpl result) {\n        if (valueMap == null) {\n            throw new IllegalArgumentException(\"ValueMap may not be null\");\n        }\n        for (ResourceProperty resourceProperty : resourceProperties) {\n        \tPattern pattern = resourceProperty.getNamePattern();\n            if (pattern != null) {\n                boolean foundMatch = false;\n                for (String key : valueMap.keySet()) {\n                    if (pattern.matcher(key).matches()) {\n                        foundMatch = true;\n                        validateValueMap(key, valueMap, relativePath, resourceProperty, result);\n                    }\n                }\n                if (!foundMatch && resourceProperty.isRequired()) {\n                    result.addFailureMessage(relativePath + resourceProperty.getNamePattern(), \"Missing required property.\");\n                }\n            } else {\n                validateValueMap(resourceProperty.getName(), valueMap, relativePath, resourceProperty, result);\n            }\n        }\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@SuppressWarnings(\"unused\")\n\tpublic @CheckForNull ValidationModel getValidationModel(@Nonnull String validatedResourceType, String resourcePath) {\n        // https://bugs.eclipse.org/bugs/show_bug.cgi?id=459256\n    \tif (validatedResourceType == null) {\n            throw new IllegalArgumentException(\"ValidationService.getValidationModel - cannot accept null as resource type. Resource path was: \" + resourcePath);\n        }\n        validatedResourceType = getRelativeResourceType(validatedResourceType);\n        ValidationModel model = null;\n        Trie<ResourceValidationModel> modelsForResourceType = validationModelsCache.get(validatedResourceType);\n        if (modelsForResourceType != null) {\n            model = modelsForResourceType.getElementForLongestMatchingKey(resourcePath).getValue();\n        }\n        if (model == null) {\n            modelsForResourceType = searchAndStoreValidationModel(validatedResourceType);\n            if (modelsForResourceType != null) {\n                model = modelsForResourceType.getElementForLongestMatchingKey(resourcePath).getValue();\n                if (model == null) {\n                    LOG.warn(\"Although model for resource type {} is available, it is not allowed for path {}\", validatedResourceType, resourcePath);\n                }\n            }\n            \n        }\n        return model;\n    }","id":11016,"modified_method":"@SuppressWarnings(\"unused\")\n    public @CheckForNull ValidationModel getValidationModel(@Nonnull String validatedResourceType, String resourcePath) {\n        // https://bugs.eclipse.org/bugs/show_bug.cgi?id=459256\n        if (validatedResourceType == null) {\n            throw new IllegalArgumentException(\"ValidationService.getValidationModel - cannot accept null as resource type. Resource path was: \" + resourcePath);\n        }\n        // convert to relative resource types, see https://issues.apache.org/jira/browse/SLING-4262\n        validatedResourceType = getRelativeResourceType(validatedResourceType);\n        return modelRetriever.getModel(validatedResourceType, resourcePath);\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testGetValidationModel() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\");\n        Resource model1 = null, model2 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n            model2 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel2\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation/1\", \"/apps/validation/2\" }, property);\n\n            // BEST MATCHING PATH = /apps/validation/1; assume the applicable paths contain /apps/validation/2\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            assertThat(vm.getApplicablePaths(), Matchers.hasItemInArray(\"/apps/validation/2\"));\n\n            // BEST MATCHING PATH = /apps/validation; assume the applicable paths contain /apps/validation but not\n            // /apps/validation/1\n            vm = validationService.getValidationModel(\"sling/validation/test\", \"/apps/validation/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            assertThat(vm.getApplicablePaths(), Matchers.hasItemInArray(\"/apps/validation\"));\n            assertThat(vm.getApplicablePaths(), Matchers.not(Matchers.hasItemInArray(\"/apps/validation/1\")));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n            if (model2 != null) {\n                rr.delete(model2);\n            }\n        }\n    }","id":11017,"modified_method":"@Test\n    public void testGetValidationModel() throws Exception {\n\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test()\n    public void testValueMapWithMissingOptionalValue() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.optional = true;\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"\");\n        Resource model1 = null;\n        try {\n            if (rr != null) {\n                model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                        \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n            }\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"field2\", \"1\");\n            ValueMap map = new ValueMapDecorator(hashMap);\n            ValidationResult vr = validationService.validate(map, vm);\n            Assert.assertTrue(vr.isValid());\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11018,"modified_method":"@Test()\n    public void testValueMapWithMissingOptionalValue() throws Exception {\n        modelBuilder.resourceProperty(propertyBuilder.optional().build(\"field1\"));\n        ValidationModel vm = modelBuilder.build(\"sling/validation/test\");\n\n        HashMap<String, Object> hashMap = new HashMap<String, Object>();\n        hashMap.put(\"field2\", \"1\");\n        ValidationResult vr = validationService.validate(new ValueMapDecorator(hashMap), vm);\n        Assert.assertTrue(vr.isValid());\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testResourceWithNestedChildrenAndPatternMatching() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", RegexValidator.REGEX_PARAM\n                + \"=\" + \"\\\\d\");\n        Resource model1 = null;\n        Resource testResource = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n            Resource child = createValidationModelChildResource(model1, \"child1\", \"child.*\", false, new TestProperty(\n                    \"hello\"));\n            createValidationModelChildResource(child, \"grandChild\", \"grandChild.*\", false, new TestProperty(\"hello\"));\n            rr.commit();\n\n            testResource = ResourceUtil.getOrCreateResource(rr, \"/apps/validation/1/resource\",\n                    JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n            ModifiableValueMap mvm = testResource.adaptTo(ModifiableValueMap.class);\n            mvm.put(\"field1\", \"1\");\n\n            Resource childResource = rr.create(testResource, \"child1\", primaryTypeUnstructuredMap);\n\n            mvm = childResource.adaptTo(ModifiableValueMap.class);\n            mvm.put(\"hello\", \"test\");\n\n            Resource resourceChild = rr.create(testResource, \"child2\", primaryTypeUnstructuredMap);\n            mvm = resourceChild.adaptTo(ModifiableValueMap.class);\n            mvm.put(\"hello2\", \"test\");\n\n            Resource resourceGrandChild = rr.create(resourceChild, \"grandChild1\", primaryTypeUnstructuredMap);\n            mvm = resourceGrandChild.adaptTo(ModifiableValueMap.class);\n            mvm.put(\"hello\", \"test\");\n            rr.commit();\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            ValidationResult vr = validationService.validate(testResource, vm);\n            assertFalse(vr.isValid());\n            // check for correct error message\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages.put(\"child2/hello\", Arrays.asList(\"Missing required property.\"));\n            expectedFailureMessages.put(\"child1/grandChild.*\", Arrays.asList(\"Missing required child resource.\"));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n            if (testResource != null) {\n                rr.delete(testResource);\n            }\n        }\n    }","id":11019,"modified_method":"@Test\n    public void testResourceWithNestedChildrenAndPatternMatching() throws Exception {\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"\\\\d\"); // accept any digits\n        ResourceProperty property = propertyBuilder.build(\"field1\");\n\n        ChildResource modelGrandChild = new ChildResourceImpl(\"grandchild\", \"grandchild.*\", true,\n                Collections.singletonList(property), Collections.<ChildResource> emptyList());\n        ChildResource modelChild = new ChildResourceImpl(\"child\", \"child.*\", true, Collections.singletonList(property),\n                Collections.singletonList(modelGrandChild));\n        ChildResource siblingChild = new ChildResourceImpl(\"siblingchild\", \"siblingchild.*\", true,\n                Collections.singletonList(property), Collections.singletonList(modelGrandChild));\n\n        modelBuilder.childResource(modelChild);\n        modelBuilder.childResource(siblingChild);\n        ValidationModel vm = modelBuilder.build(\"sometype\");\n\n        ResourceResolver rr = context.resourceResolver();\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/apps/validation/1/resource\",\n                JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"field1\", \"1\");\n        Resource resourceChild = rr.create(testResource, \"child1\", properties);\n        rr.create(resourceChild, \"grandchild1\", properties);\n        // child2 is lacking its mandatory sub resource\n        rr.create(testResource, \"child2\", properties);\n        rr.create(testResource, \"child3\", null);\n        // siblingchild is not there at all (although mandatory)\n\n        ValidationResult vr = validationService.validate(testResource, vm);\n        Assert.assertFalse(\"resource should have been considered invalid\", vr.isValid());\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"child2/grandchild.*\", Arrays.asList(\"Missing required child resource.\")));\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"child3/grandchild.*\", Arrays.asList(\"Missing required child resource.\")));\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"child3/field1\", Arrays.asList(\"Missing required property.\")));\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"siblingchild.*\", Arrays.asList(\"Missing required child resource.\")));\n        Assert.assertThat(vr.getFailureMessages().keySet(), Matchers.hasSize(4));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test(expected = IllegalArgumentException.class)\n    public void testValidateAllResourceTypesInResourceWithMissingValidationModel() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\");\n        Resource model1 = null;\n        Resource resource = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/content\" }, property);\n            resource = ResourceUtil.getOrCreateResource(rr, \"/content/testpage\", \"sling/validation/test\",\n                    JcrConstants.NT_UNSTRUCTURED, true);\n            ModifiableValueMap values = resource.adaptTo(ModifiableValueMap.class);\n            values.put(\"field2\", \"somvalue\");\n            // this following resource type can not be validated\n            Resource grandChildResource = ResourceUtil.getOrCreateResource(rr, \"/content/testpage/par/testpar\",\n                    \"sling/validation/test20\", JcrConstants.NT_UNSTRUCTURED, true);\n            values = grandChildResource.adaptTo(ModifiableValueMap.class);\n            values.put(\"field2\", \"somvalue\");\n            validationService.validateAllResourceTypesInResource(resource, true,\n                    Collections.singleton(JcrConstants.NT_UNSTRUCTURED));\n        } finally {\n            if (resource != null) {\n                rr.delete(resource);\n            }\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11020,"modified_method":"@Test(expected = IllegalArgumentException.class)\n    public void testValidateAllResourceTypesInResourceWithMissingValidationModel() throws Exception {\n        // set model retriever which never retrieves anything\n        validationService.modelRetriever = new ValidationModelRetriever() {\n            @Override\n            public @CheckForNull ValidationModel getModel(@Nonnull String resourceType, String resourcePath) {\n                return null;\n            }\n        };\n\n        ResourceResolver rr = context.resourceResolver();\n        // resource is having no connected validation model\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\", \"resourcetype1\",\n                JcrConstants.NT_UNSTRUCTURED, true);\n\n        ValidationResult vr = validationService.validateAllResourceTypesInResource(testResource, true,\n                Collections.singleton(JcrConstants.NT_UNSTRUCTURED));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test()\n    public void testValueMapWithWrongDataType() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n        validationService.validators.put(\"org.apache.sling.validation.impl.util.examplevalidators.DateValidator\",\n                new DateValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.util.examplevalidators.DateValidator\");\n        Resource model1 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"field1\", \"1\");\n                \n            ValueMap map = new ValueMapDecorator(hashMap);\n            ValidationResult vr = validationService.validate(map, vm);\n\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages\n                    .put(\"field1\",\n                            Arrays.asList(\"Property was expected to be of type 'class java.util.Date' but cannot be converted to that type.\"));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11021,"modified_method":"@Test()\n    public void testValueMapWithWrongDataType() throws Exception {\n        propertyBuilder.validator(new DateValidator());\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field1\"));\n        ValidationModel vm = modelBuilder.build(\"sling/validation/test\");\n\n        HashMap<String, Object> hashMap = new HashMap<String, Object>();\n        hashMap.put(\"field1\", \"1\");\n        ValidationResult vr = validationService.validate(new ValueMapDecorator(hashMap), vm);\n        Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n        expectedFailureMessages\n                .put(\"field1\",\n                        Arrays.asList(\"Property was expected to be of type 'class java.util.Date' but cannot be converted to that type.\"));\n        Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testResourceWithPropertyPatternMatching() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        final String TEST_REGEX = \"^testvalue.*$\";\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=\" + TEST_REGEX);\n        property.setNameRegex(\"property[1-4]\");\n\n        TestProperty otherProperty = new TestProperty(\"field2\");\n        otherProperty.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=\" + TEST_REGEX);\n        otherProperty.setNameRegex(\"otherproperty[1-4]\");\n        Resource model1 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property, otherProperty);\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"property1\", \"testvalue1\");\n            hashMap.put(\"property2\", \"test1value1\"); // does not match validator pattern\n            hashMap.put(\"property3\", \"testvalue1\");\n            hashMap.put(\"property4\", \"1testvalue1\"); // does not match validator pattern\n            hashMap.put(\"property5\", \"invalid\"); // does not match property name pattern\n            ValueMap map = new ValueMapDecorator(hashMap);\n            ValidationResult vr = validationService.validate(map, vm);\n            assertFalse(vr.isValid());\n            // check for correct error message\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages\n                    .put(\"property2\", Arrays.asList(\"Property does not match the pattern \" + TEST_REGEX));\n            expectedFailureMessages\n                    .put(\"property4\", Arrays.asList(\"Property does not match the pattern \" + TEST_REGEX));\n            expectedFailureMessages.put(\"otherproperty[1-4]\", Arrays.asList(\"Missing required property.\"));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11022,"modified_method":"@Test\n    public void testResourceWithPropertyPatternMatching() throws Exception {\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"\\\\d\"); // accept any digits\n        propertyBuilder.nameRegex(\"field.*\");\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field\"));\n        propertyBuilder.nameRegex(\"otherfield.*\");\n        modelBuilder.resourceProperty(propertyBuilder.build(\"otherfield\"));\n        propertyBuilder.nameRegex(\"optionalfield.*\").optional();\n        modelBuilder.resourceProperty(propertyBuilder.build(\"optionalfield\"));\n        ValidationModel vm = modelBuilder.build(\"type\");\n\n        // create a resource\n        ResourceResolver rr = context.resourceResolver();\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\",\n                JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n        ModifiableValueMap mvm = testResource.adaptTo(ModifiableValueMap.class);\n        mvm.put(\"field1\", \"1\");\n        mvm.put(\"field2\", \"1\");\n        mvm.put(\"field3\", \"abc\"); // does not validate\n        // otherfield.* property is missing\n\n        ValidationResult vr = validationService.validate(testResource, vm);\n        Assert.assertFalse(\"resource should have been considered invalid\", vr.isValid());\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"field3\", Arrays.asList(\"Property does not match the pattern \\\\d\")));\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"otherfield.*\", Arrays.asList(\"Missing required property.\")));\n        Assert.assertThat(vr.getFailureMessages().keySet(), Matchers.hasSize(2));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testValueMapWithCorrectDataType() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty field1 = new TestProperty(\"field1\");\n        field1.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=^\\\\p{L}+$\");\n        TestProperty field2 = new TestProperty(\"field2\");\n        final String TEST_REGEX = \"^test$\";\n        field2.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=\" + TEST_REGEX);\n        Resource model1 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, field1, field2);\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"field1\", \"HelloWorld\");\n            hashMap.put(\"field2\", \"HelloWorld\");\n            ValueMap map = new ValueMapDecorator(hashMap);\n            ValidationResult vr = validationService.validate(map, vm);\n            assertFalse(vr.isValid());\n            // check for correct error message\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages.put(\"field2\", Arrays.asList(\"Property does not match the pattern \" + TEST_REGEX));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11023,"modified_method":"@Test\n    public void testValueMapWithCorrectDataType() throws Exception {\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"abc\");\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field1\"));\n        propertyBuilder = new ResourcePropertyBuilder();\n        final String TEST_REGEX = \"^test$\";\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, TEST_REGEX);\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field2\"));\n        ValidationModel vm = modelBuilder.build(\"sling/validation/test\");\n\n        HashMap<String, Object> hashMap = new HashMap<String, Object>();\n        hashMap.put(\"field1\", \"HelloWorld\");\n        hashMap.put(\"field2\", \"HelloWorld\");\n\n        ValidationResult vr = validationService.validate(new ValueMapDecorator(hashMap), vm);\n\n        Assert.assertFalse(vr.isValid()); // check for correct error message Map<String, List<String>>\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"field2\", Arrays.asList(\"Property does not match the pattern \" + TEST_REGEX)));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test()\n    public void testValidateAllResourceTypesInResourceWithMissingValidatorAndNoEnforcement() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\");\n        Resource model1 = null;\n        Resource resource = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/content\" }, property);\n            resource = ResourceUtil.getOrCreateResource(rr, \"/content/testpage\", \"sling/validation/test\",\n                    JcrConstants.NT_UNSTRUCTURED, true);\n            ModifiableValueMap values = resource.adaptTo(ModifiableValueMap.class);\n            values.put(\"field2\", \"somvalue\");\n            Resource grandChildResource = ResourceUtil.getOrCreateResource(rr, \"/content/testpage/par/testpar\",\n                    \"sling/validation/test2\", JcrConstants.NT_UNSTRUCTURED, true);\n            values = grandChildResource.adaptTo(ModifiableValueMap.class);\n            values.put(\"field2\", \"somvalue\");\n            ValidationResult vr = validationService.validateAllResourceTypesInResource(resource, false,\n                    Collections.singleton(JcrConstants.NT_UNSTRUCTURED));\n            // should not fail \n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages.put(\"field1\", Arrays.asList(\"Missing required property.\"));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (resource != null) {\n                rr.delete(resource);\n            }\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11024,"modified_method":"@Test()\n    public void testValidateAllResourceTypesInResourceWithMissingValidatorAndNoEnforcement() throws Exception {\n        // set model retriever which never retrieves anything\n        validationService.modelRetriever = new ValidationModelRetriever() {\n            @Override\n            public @CheckForNull ValidationModel getModel(@Nonnull String resourceType, String resourcePath) {\n                return null;\n            }\n        };\n\n        ResourceResolver rr = context.resourceResolver();\n        // resource is having no connected validation model\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\", \"resourcetype1\",\n                JcrConstants.NT_UNSTRUCTURED, true);\n\n        ValidationResult vr = validationService.validateAllResourceTypesInResource(testResource, false,\n                Collections.singleton(JcrConstants.NT_UNSTRUCTURED));\n        Assert.assertTrue(vr.isValid());\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void setUp() throws LoginException, PersistenceException, RepositoryException {\n        validationService = new ValidationServiceImpl();\n        validationService.validators = new HashMap<String, Validator<?>>();\n        \n        rrf = MockSling.newResourceResolverFactory(ResourceResolverType.JCR_MOCK);\n        // we must register the Sling namespace manually until https://issues.apache.org/jira/browse/SLING-4773 is solved\n        initializeJcrMock(rrf);\n        prefixBasedResultHandler = new MockQueryResultHandler() {\n            @Override\n            public MockQueryResult executeQuery(MockQuery query) {\n                if (!\"xpath\".equals(query.getLanguage())) {\n                    return null;\n                }\n                String statement = query.getStatement();\n                // query looks like /jcr:root/apps//validation//*[@sling:resourceType=\"sling/validation/model\" and @validatedResourceType=\"<some-resource-type>\"]\n                if (statement.startsWith(\"/jcr:root/\")) {\n                    statement = statement.substring(\"/jcr:root/\".length() - 1);\n                }\n                // extract the prefix from the statement\n                String prefix = Text.getAbsoluteParent(statement, 0);\n                \n                // extract the resource type from the statement\n                Matcher matcher = RESOURCE_TYPE_PATTERN.matcher(statement);\n                if (!matcher.matches()) {\n                    throw new IllegalArgumentException(\"Can only process query statements which contain a validatedResourceType but the statement is: \" + statement);\n                }\n                String resourceType = matcher.group(1);\n                \n                PrefixAndResourceType prefixAndResourceType = new PrefixAndResourceType(prefix, resourceType);\n                if (validatorModelNodesPerPrefixAndResourceType.keySet().contains(prefixAndResourceType)) {\n                    return new MockQueryResult(validatorModelNodesPerPrefixAndResourceType.get(prefixAndResourceType));\n                }\n                return null;\n            }\n        };\n        rr = rrf.getAdministrativeResourceResolver(null);\n        ResourceResolverFactory rrfForQuery = new ResourceResolverFactory() {\n\n            @Override\n            public ResourceResolver getResourceResolver(Map<String, Object> authenticationInfo) throws LoginException {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public ResourceResolver getAdministrativeResourceResolver(Map<String, Object> authenticationInfo)\n                    throws LoginException {\n                // always return a new resource resolver which has the query result handler bound\n                ResourceResolver resourceResolver = rrf.getAdministrativeResourceResolver(null);\n                MockJcr.addQueryResultHandler(resourceResolver.adaptTo(Session.class), prefixBasedResultHandler);\n                return resourceResolver;\n            }\n\n        };\n        validatorModelNodesPerPrefixAndResourceType = new HashMap<PrefixAndResourceType, List<Node>>();\n\n        Whitebox.setInternalState(validationService, \"rrf\", rrfForQuery);\n\n        appsValidatorsRoot = ResourceUtil.getOrCreateResource(rr, APPS + \"/\" + VALIDATION_MODELS_RELATIVE_PATH,\n                (Map<String, Object>) null, \"sling:Folder\", true);\n        libsValidatorsRoot = ResourceUtil.getOrCreateResource(rr, LIBS + \"/\" + VALIDATION_MODELS_RELATIVE_PATH,\n                (Map<String, Object>) null, \"sling:Folder\", true);\n    }","id":11025,"modified_method":"@Before\n    public void setUp() throws LoginException, PersistenceException, RepositoryException {\n        validationService = new ValidationServiceImpl();\n        validationService.searchPaths = Arrays.asList(context.resourceResolver().getSearchPath());\n        modelBuilder = new ValidationModelBuilder();\n        propertyBuilder = new ResourcePropertyBuilder();\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testResourceWithMissingOptionalChildProperty() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", RegexValidator.REGEX_PARAM\n                + \"=\" + \"\\\\d\");\n        Resource model1 = null;\n        Resource testResource = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n\n            createValidationModelChildResource(model1, \"child1\", null, true, new TestProperty(\"hello\"));\n\n            testResource = ResourceUtil.getOrCreateResource(rr, \"/apps/validation/1/resource\",\n                    JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n            ModifiableValueMap mvm = testResource.adaptTo(ModifiableValueMap.class);\n            mvm.put(\"field1\", \"1\");\n\n            rr.create(testResource, \"child2\",primaryTypeUnstructuredMap);\n            rr.commit();\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            ValidationResult vr = validationService.validate(testResource, vm);\n            assertTrue(vr.isValid());\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n            if (testResource != null) {\n                rr.delete(testResource);\n            }\n        }\n    }","id":11026,"modified_method":"@Test\n    public void testResourceWithMissingOptionalChildResource() throws Exception {\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"\\\\d\"); // accept any digits\n        ResourceProperty property = propertyBuilder.build(\"field1\");\n\n        ChildResource child = new ChildResourceImpl(\"child\", null, false, Collections.singletonList(property),\n                Collections.<ChildResource> emptyList());\n        modelBuilder.childResource(child);\n        ValidationModel vm = modelBuilder.build(\"type\");\n\n        // create a resource (lacking the optional \"child\" sub resource)\n        ResourceResolver rr = context.resourceResolver();\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\",\n                JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n\n        ValidationResult vr = validationService.validate(testResource, vm);\n        Assert.assertTrue(vr.isValid());\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testResourceWithMultivalueProperties() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        final String TEST_REGEX = \"^testvalue.*$\";\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=\" + TEST_REGEX);\n        Resource model1 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"field1\", new String[] { \"testvalue1\", \"test2value\", \"testvalue3\" });\n            ValueMap map = new ValueMapDecorator(hashMap);\n            ValidationResult vr = validationService.validate(map, vm);\n            assertFalse(vr.isValid());\n            // check for correct error message\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages\n                    .put(\"field1[1]\", Arrays.asList(\"Property does not match the pattern \" + TEST_REGEX));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11027,"modified_method":"@Test\n    public void testResourceWithMultivalueProperties() throws Exception {\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"\\\\d\"); // accept any digits\n        propertyBuilder.multiple();\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field\"));\n        ValidationModel vm = modelBuilder.build(\"type\");\n\n        ResourceResolver rr = context.resourceResolver();\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\",\n                JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n        ModifiableValueMap mvm = testResource.adaptTo(ModifiableValueMap.class);\n        mvm.put(\"field\", new String[] { \"1\", \"abc\", \"2\" });\n\n        ValidationResult vr = validationService.validate(testResource, vm);\n        Assert.assertFalse(\"resource should have been considered invalid\", vr.isValid());\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"field[1]\", Arrays.asList(\"Property does not match the pattern \\\\d\")));\n        Assert.assertThat(vr.getFailureMessages().keySet(), Matchers.hasSize(1));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test()\n    public void testValueMapWithEmptyOptionalValue() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.optional = true;\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=abc\");\n        Resource model1 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"field1\", \"\");\n            ValueMap map = new ValueMapDecorator(hashMap);\n            ValidationResult vr = validationService.validate(map, vm);\n            Assert.assertFalse(vr.isValid());\n            // check for correct error message\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages.put(\"field1\", Arrays.asList(\"Property does not match the pattern abc\"));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11028,"modified_method":"@Test()\n    public void testValueMapWithEmptyOptionalValue() throws Exception {\n        propertyBuilder.optional();\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"abc\");\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field1\"));\n        ValidationModel vm = modelBuilder.build(\"sling/validation/test\");\n\n        HashMap<String, Object> hashMap = new HashMap<String, Object>();\n        hashMap.put(\"field1\", \"\");\n        ValidationResult vr = validationService.validate(new ValueMapDecorator(hashMap), vm);\n\n        Assert.assertFalse(vr.isValid()); // check for correct error message Map<String, List<String>>\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"field1\", Arrays.asList(\"Property does not match the pattern abc\")));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test()\n    public void testValueMapWithMissingField() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=.*\");\n        TestProperty property2 = new TestProperty(\"field2\");\n        property2.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=.*\");\n        TestProperty property3 = new TestProperty(\"field3\");\n        property3.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=.*\");\n        TestProperty property4 = new TestProperty(\"field4\");\n        property3.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", \"regex=.*\");\n        Resource model1 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property, property2, property3,\n                    property4);\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            \n            // this should not be detected as missing property\n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"field1\", new String[] {});\n            hashMap.put(\"field2\", new String[] { \"null\" });\n            hashMap.put(\"field3\", \"\");\n            \n            ValueMap map = new ValueMapDecorator(hashMap);\n            ValidationResult vr = validationService.validate(map, vm);\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages.put(\"field4\", Arrays.asList(\"Missing required property.\"));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11029,"modified_method":"@Test()\n    public void testValueMapWithMissingField() throws Exception {\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field1\"));\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field2\"));\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field3\"));\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field4\"));\n        ValidationModel vm = modelBuilder.build(\"sling/validation/test\");\n\n        // this should not be detected as missing property\n        HashMap<String, Object> hashMap = new HashMap<String, Object>();\n        hashMap.put(\"field1\", new String[] {});\n        hashMap.put(\"field2\", new String[] { \"null\" });\n        hashMap.put(\"field3\", \"\");\n\n        ValidationResult vr = validationService.validate(new ValueMapDecorator(hashMap), vm);\n        Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n        expectedFailureMessages.put(\"field4\", Arrays.asList(\"Missing required property.\"));\n        Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test()\n    public void testValidateAllResourceTypesInResource() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\");\n        Resource model1 = null;\n        Resource model2 = null;\n        Resource resource = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/content\" }, property);\n            model2 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel2\",\n                    \"sling/validation/test2\", new String[] { \"/content\" }, property);\n            resource = ResourceUtil.getOrCreateResource(rr, \"/content/testpage\", \"sling/validation/test\",\n                    JcrConstants.NT_UNSTRUCTURED, true);\n            ModifiableValueMap values = resource.adaptTo(ModifiableValueMap.class);\n            values.put(\"field2\", \"somvalue\");\n            Resource grandChildResource = ResourceUtil.getOrCreateResource(rr, \"/content/testpage/par/testpar\",\n                    \"sling/validation/test2\", JcrConstants.NT_UNSTRUCTURED, true);\n            values = grandChildResource.adaptTo(ModifiableValueMap.class);\n            values.put(\"field2\", \"somvalue\");\n            ValidationResult vr = validationService.validateAllResourceTypesInResource(resource, true,\n                    Collections.singleton(JcrConstants.NT_UNSTRUCTURED));\n\n            Map<String, List<String>> expectedFailureMessages = new HashMap<String, List<String>>();\n            expectedFailureMessages.put(\"field1\", Arrays.asList(\"Missing required property.\"));\n            expectedFailureMessages.put(\"par/testpar/field1\", Arrays.asList(\"Missing required property.\"));\n            Assert.assertThat(vr.getFailureMessages().entrySet(), Matchers.equalTo(expectedFailureMessages.entrySet()));\n        } finally {\n            if (resource != null) {\n                rr.delete(resource);\n            }\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n            if (model2 != null) {\n                rr.delete(model2);\n            }\n        }\n    }","id":11030,"modified_method":"@Test()\n    public void testValidateAllResourceTypesInResource() throws Exception {\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field1\"));\n        final ValidationModel vm1 = modelBuilder.build(\"resourcetype1\");\n        modelBuilder = new ValidationModelBuilder();\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field2\"));\n        final ValidationModel vm2 = modelBuilder.build(\"resourcetype2\");\n\n        // set model retriever\n        validationService.modelRetriever = new ValidationModelRetriever() {\n\n            @Override\n            public @CheckForNull ValidationModel getModel(@Nonnull String resourceType, String resourcePath) {\n                if (resourceType.equals(\"resourcetype1\")) {\n                    return vm1;\n                } else if (resourceType.equals(\"resourcetype2\")) {\n                    return vm2;\n                } else {\n                    return null;\n                }\n            }\n        };\n\n        ResourceResolver rr = context.resourceResolver();\n        // resource is lacking the required field (is invalid)\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\", \"resourcetype1\",\n                JcrConstants.NT_UNSTRUCTURED, true);\n\n        // child1 is valid\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(JcrResourceConstants.SLING_RESOURCE_TYPE_PROPERTY, \"resourcetype2\");\n        properties.put(\"field2\", \"test\");\n        rr.create(testResource, \"child1\", properties);\n\n        // child2 is invalid\n        properties.clear();\n        properties.put(JcrResourceConstants.SLING_RESOURCE_TYPE_PROPERTY, \"resourcetype2\");\n        rr.create(testResource, \"child2\", properties);\n\n        // child3 has no model (but its resource type is ignored)\n        properties.clear();\n        properties.put(JcrResourceConstants.SLING_RESOURCE_TYPE_PROPERTY, \"resourcetype3\");\n        rr.create(testResource, \"child3\", properties);\n\n        ValidationResult vr = validationService.validateAllResourceTypesInResource(testResource, true,\n                new HashSet<String>(Arrays.asList(JcrConstants.NT_UNSTRUCTURED, \"resourcetype3\")));\n        Assert.assertFalse(\"resource should have been considered invalid\", vr.isValid());\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"field1\", Arrays.asList(\"Missing required property.\")));\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"child2/field2\", Arrays.asList(\"Missing required property.\")));\n        Assert.assertThat(vr.getFailureMessages().keySet(), Matchers.hasSize(2));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testResourceWithNestedChildren() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", RegexValidator.REGEX_PARAM\n                + \"=\" + \"\\\\d\");\n        Resource model1 = null;\n        Resource testResource = null;\n        try {\n            if (rr != null) {\n                model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                        \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n\n                Resource child = createValidationModelChildResource(model1, \"child1\", null, false, new TestProperty(\n                        \"hello\"));\n                createValidationModelChildResource(child, \"grandChild1\", null, false, new TestProperty(\"hello\"));\n\n                testResource = ResourceUtil.getOrCreateResource(rr, \"/apps/validation/1/resource\",\n                        JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n                rr.create(testResource, \"child1\", primaryTypeUnstructuredMap);\n\n                ModifiableValueMap mvm = testResource.adaptTo(ModifiableValueMap.class);\n                mvm.put(\"field1\", \"1\");\n\n                Resource resourceChild = rr.create(testResource, \"child1\", primaryTypeUnstructuredMap);\n                mvm = resourceChild.adaptTo(ModifiableValueMap.class);\n                mvm.put(\"hello\", \"test\");\n\n                Resource resourceGrandChild = rr.create(resourceChild, \"grandChild1\", primaryTypeUnstructuredMap);\n                mvm = resourceGrandChild.adaptTo(ModifiableValueMap.class);\n                mvm.put(\"hello\", \"test\");\n                rr.commit();\n                \n                ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                        \"/apps/validation/1/resource\");\n                assertNotNull(\"Could not get validation model for \", vm);\n                ValidationResult vr = validationService.validate(testResource, vm);\n                assertTrue(vr.isValid());\n            }\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n            if (testResource != null) {\n                rr.delete(testResource);\n            }\n        }\n    }","id":11031,"modified_method":"@Test\n    public void testResourceWithNestedChildren() throws Exception {\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"\\\\d\"); // accept any digits\n        ResourceProperty property = propertyBuilder.build(\"field1\");\n\n        ChildResource modelGrandChild = new ChildResourceImpl(\"grandchild\", null, true,\n                Collections.singletonList(property), Collections.<ChildResource> emptyList());\n        ChildResource modelChild = new ChildResourceImpl(\"child\", null, true, Collections.singletonList(property),\n                Collections.singletonList(modelGrandChild));\n        modelBuilder.childResource(modelChild);\n        ValidationModel vm = modelBuilder.build(\"sometype\");\n\n        // create a resource\n        ResourceResolver rr = context.resourceResolver();\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\",\n                JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"field1\", \"1\");\n        Resource resourceChild = rr.create(testResource, \"child\", properties);\n        rr.create(resourceChild, \"grandchild\", properties);\n\n        ValidationResult vr = validationService.validate(testResource, vm);\n        Assert.assertTrue(vr.isValid());\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testValidateNeverCalledWithNullValues() throws Exception {\n        \n        Validator<String> myValidator = new Validator<String>() {\n            @Override\n            public String validate(@Nonnull String data, @Nonnull ValueMap valueMap, @Nonnull ValueMap arguments)\n                    throws SlingValidationException {\n            \tAssert.assertNotNull(\"data parameter for validate should never be null\", data);\n                Assert.assertNotNull(\"valueMap parameter for validate should never be null\", valueMap);\n                Assert.assertNotNull(\"arguments parameter for validate should never be null\", arguments);\n                return null;\n            }\n            \n        };\n        \n        validationService.validators.put(\"testvalidator\",\n                myValidator);\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"testvalidator\");\n        Resource model1 = null;\n        try {\n            model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                    \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n\n            ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                    \"/apps/validation/1/resource\");\n            Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n            HashMap<String, Object> hashMap = new HashMap<String, Object>();\n            hashMap.put(\"field1\", \"1\");\n            ValueMap map = new ValueMapDecorator(hashMap);\n            validationService.validate(map, vm);\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n        }\n    }","id":11032,"modified_method":"@Test\n    public void testValidateNeverCalledWithNullValues() throws Exception {\n        Validator<String> myValidator = new Validator<String>() {\n            @Override\n            public String validate(@Nonnull String data, @Nonnull ValueMap valueMap, @Nonnull ValueMap arguments)\n                    throws SlingValidationException {\n                Assert.assertNotNull(\"data parameter for validate should never be null\", data);\n                Assert.assertNotNull(\"valueMap parameter for validate should never be null\", valueMap);\n                Assert.assertNotNull(\"arguments parameter for validate should never be null\", arguments);\n                return null;\n            }\n        };\n        propertyBuilder.validator(myValidator);\n        modelBuilder.resourceProperty(propertyBuilder.build(\"field1\"));\n        ValidationModel vm = modelBuilder.build(\"sling/validation/test\");\n\n        HashMap<String, Object> hashMap = new HashMap<String, Object>();\n        hashMap.put(\"field1\", \"1\");\n        ValidationResult vr = validationService.validate(new ValueMapDecorator(hashMap), vm);\n        Assert.assertTrue(vr.isValid());\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testResourceWithMissingChildProperty() throws Exception {\n        validationService.validators.put(\"org.apache.sling.validation.impl.validators.RegexValidator\",\n                new RegexValidator());\n\n        TestProperty property = new TestProperty(\"field1\");\n        property.addValidator(\"org.apache.sling.validation.impl.validators.RegexValidator\", RegexValidator.REGEX_PARAM\n                + \"=\" + \"\\\\d\");\n        Resource model1 = null;\n        Resource testResource = null;\n        try {\n            if (rr != null) {\n                model1 = createValidationModelResource(rr, libsValidatorsRoot.getPath(), \"testValidationModel1\",\n                        \"sling/validation/test\", new String[] { \"/apps/validation\" }, property);\n\n                Resource child = createValidationModelChildResource(model1, \"child1\", null, false, new TestProperty(\n                        \"hello\"));\n                createValidationModelChildResource(child, \"grandChild1\", null, false, new TestProperty(\"hello\"));\n\n                testResource = ResourceUtil.getOrCreateResource(rr, \"/apps/validation/1/resource\",\n                        JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n                ModifiableValueMap mvm = testResource.adaptTo(ModifiableValueMap.class);\n                mvm.put(\"field1\", \"1\");\n\n                Resource resourceChild = rr.create(testResource, \"child1\", primaryTypeUnstructuredMap);\n                mvm = resourceChild.adaptTo(ModifiableValueMap.class);\n                mvm.put(\"hello\", \"1\");\n\n                // /apps/validation/1/resource/child1/grandChild1 will miss its mandatory \"hello\" property\n                Resource resourceGrandChild = rr.create(resourceChild, \"grandChild1\", primaryTypeUnstructuredMap);\n                rr.commit();\n\n                mvm = resourceGrandChild.adaptTo(ModifiableValueMap.class);\n                mvm.put(\"field1\", \"1\");\n                rr.commit();\n                \n                ValidationModel vm = validationService.getValidationModel(\"sling/validation/test\",\n                        \"/apps/validation/1/resource\");\n                Assert.assertNotNull(\"Could not find validation model for 'sling/validation/test'\", vm);\n                \n                ValidationResult vr = validationService.validate(testResource, vm);\n                assertFalse(\"resource should have been considered invalid\", vr.isValid());\n                assertThat(vr.getFailureMessages(), Matchers.hasKey(\"child1/grandChild1/hello\"));\n                assertThat(vr.getFailureMessages().keySet(), Matchers.hasSize(1));\n            }\n        } finally {\n            if (model1 != null) {\n                rr.delete(model1);\n            }\n            if (testResource != null) {\n                rr.delete(testResource);\n            }\n        }\n    }","id":11033,"modified_method":"@Test\n    public void testResourceWithMissingGrandChildProperty() throws Exception {\n        propertyBuilder.validator(new RegexValidator(), RegexValidator.REGEX_PARAM, \"\\\\d\"); // accept any digits\n        ResourceProperty property = propertyBuilder.build(\"field1\");\n        modelBuilder.resourceProperty(property);\n\n        ChildResource modelGrandChild = new ChildResourceImpl(\"grandchild\", null, true,\n                Collections.singletonList(property), Collections.<ChildResource> emptyList());\n        ChildResource modelChild = new ChildResourceImpl(\"child\", null, true, Collections.singletonList(property),\n                Collections.singletonList(modelGrandChild));\n        modelBuilder.childResource(modelChild);\n\n        ValidationModel vm = modelBuilder.build(\"sometype\");\n\n        // create a resource\n        ResourceResolver rr = context.resourceResolver();\n        Resource testResource = ResourceUtil.getOrCreateResource(rr, \"/content/validation/1/resource\",\n                JcrConstants.NT_UNSTRUCTURED, JcrConstants.NT_UNSTRUCTURED, true);\n        ModifiableValueMap mvm = testResource.adaptTo(ModifiableValueMap.class);\n        mvm.put(\"field1\", \"1\");\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"field1\", \"1\");\n        Resource resourceChild = rr.create(testResource, \"child\", properties);\n        // resourceGrandChild is missing the mandatory field1 property\n        rr.create(resourceChild, \"grandchild\", null);\n\n        ValidationResult vr = validationService.validate(testResource, vm);\n        Assert.assertFalse(\"resource should have been considered invalid\", vr.isValid());\n        Assert.assertThat(vr.getFailureMessages(),\n                Matchers.hasEntry(\"child/grandchild/field1\", Arrays.asList(\"Missing required property.\")));\n        Assert.assertThat(vr.getFailureMessages().keySet(), Matchers.hasSize(1));\n    }","commit_id":"639e574cc0d68faeb9269c1b65f3bc7302dbabbf","url":"https://github.com/apache/sling"},{"original_method":"private Collection<OsmPrimitive> getNearestCollectionVirtual(Point p, boolean allSegements) {\n        MapView c = Main.map.mapView;\n        int snapDistance = Main.pref.getInteger(\"mappaint.node.virtual-snap-distance\", 8);\n        snapDistance *= snapDistance;\n        OsmPrimitive osm = c.getNearestNode(p, OsmPrimitive.isSelectablePredicate);\n        virtualWays.clear();\n        virtualNode = null;\n        Node virtualWayNode = null;\n\n        if (osm == null)\n        {\n            Collection<WaySegment> nearestWaySegs = allSegements\n            ? c.getNearestWaySegments(p, OsmPrimitive.isSelectablePredicate)\n                    : Collections.singleton(c.getNearestWaySegment(p, OsmPrimitive.isSelectablePredicate));\n\n            for(WaySegment nearestWS : nearestWaySegs) {\n                if (nearestWS == null) {\n                    continue;\n                }\n\n                osm = nearestWS.way;\n                if(Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) > 0)\n                {\n                    Way w = (Way)osm;\n                    Point p1 = c.getPoint(w.getNode(nearestWS.lowerIndex));\n                    Point p2 = c.getPoint(w.getNode(nearestWS.lowerIndex+1));\n                    if(SimplePaintVisitor.isLargeSegment(p1, p2, Main.pref.getInteger(\"mappaint.node.virtual-space\", 70)))\n                    {\n                        Point pc = new Point((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n                        if (p.distanceSq(pc) < snapDistance)\n                        {\n                            // Check that only segments on top of each other get added to the\n                            // virtual ways list. Otherwise ways that coincidentally have their\n                            // virtual node at the same spot will be joined which is likely unwanted\n                            if(virtualWayNode != null) {\n                                if(  !w.getNode(nearestWS.lowerIndex+1).equals(virtualWayNode)\n                                        && !w.getNode(nearestWS.lowerIndex).equals(virtualWayNode)) {\n                                    continue;\n                                }\n                            } else {\n                                virtualWayNode = w.getNode(nearestWS.lowerIndex+1);\n                            }\n\n                            virtualWays.add(nearestWS);\n                            if(virtualNode == null) {\n                                virtualNode = new Node(Main.map.mapView.getLatLon(pc.x, pc.y));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (osm == null)\n            return Collections.emptySet();\n        return Collections.singleton(osm);\n    }","id":11034,"modified_method":"private Collection<OsmPrimitive> getNearestCollectionVirtual(Point p) {\n        int snapDistance = Main.pref.getInteger(\"mappaint.node.virtual-snap-distance\", 8);\n        int virtualSpace = Main.pref.getInteger(\"mappaint.node.virtual-space\", 70);\n        snapDistance *= snapDistance;\n\n        MapView c = Main.map.mapView;\n        Collection<OsmPrimitive> sel = getCurrentDataSet().getSelected();\n\n        // take nearest node\n        OsmPrimitive osm = c.getNearestNode(p, OsmPrimitive.isSelectablePredicate);\n\n        if (osm != null) {\n            for (Node n : c.getNearestNodes(p, OsmPrimitive.isSelectablePredicate)) {\n                if (sel.contains(n)) {\n                    // take nearest selected node\n                    osm = n;\n                    break;\n                }\n            }\n        } else {\n            Node virtualWayNode = null;\n            Way w = null;\n\n            Collection<WaySegment> virtualWaysInSel = new ArrayList<WaySegment>();\n            Collection<WaySegment> wss = c.getNearestWaySegments(p, OsmPrimitive.isSelectablePredicate);\n            for(WaySegment nearestWS : wss) {\n                if (nearestWS == null) {\n                    continue;\n                }\n\n                w = nearestWS.way;\n                if (osm == null && sel.contains(w)) {\n                    // take nearest selected way\n                    osm = w;\n                }\n\n                if (Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) > 0) {\n                    Point p1 = c.getPoint(w.getNode(nearestWS.lowerIndex));\n                    Point p2 = c.getPoint(w.getNode(nearestWS.lowerIndex+1));\n                    if(SimplePaintVisitor.isLargeSegment(p1, p2, virtualSpace))\n                    {\n                        Point pc = new Point((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n                        if (p.distanceSq(pc) < snapDistance)\n                        {\n                            // Check that only segments on top of each other get added to the\n                            // virtual ways list. Otherwise ways that coincidentally have their\n                            // virtual node at the same spot will be joined which is likely unwanted\n                            if(virtualWayNode != null) {\n                                if(!w.getNode(nearestWS.lowerIndex+1).equals(virtualWayNode)\n                                        && !w.getNode(nearestWS.lowerIndex).equals(virtualWayNode)) {\n                                    continue;\n                                }\n                            } else {\n                                virtualWayNode = w.getNode(nearestWS.lowerIndex+1);\n                            }\n\n                            (!sel.contains(w) ? virtualWays : virtualWaysInSel).add(nearestWS);\n                            if(virtualNode == null) {\n                                virtualNode = new Node(Main.map.mapView.getLatLon(pc.x, pc.y));\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (virtualNode != null) {\n                // insert virtualNode into all segments if nothing was selected,\n                // else only into the (previously) selected segments\n                virtualWays = virtualWaysInSel.isEmpty() ? virtualWays : virtualWaysInSel;\n            }\n\n            if (osm == null && !wss.isEmpty()) {\n                // take nearest way\n                osm = wss.iterator().next().way;\n            }\n        }\n\n        if (osm == null)\n            return Collections.emptySet();\n        return Collections.singleton(osm);\n    }","commit_id":"a55e13c1d42c6de7a313acf44f7c020b3b800bd2","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override public void mousePressed(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n        // request focus in order to enable the expected keyboard shortcuts\n        //\n        Main.map.mapView.requestFocus();\n\n        cancelDrawMode = false;\n        if (! (Boolean)this.getValue(\"active\")) return;\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean alt = (e.getModifiers() & (ActionEvent.ALT_MASK|InputEvent.ALT_GRAPH_MASK)) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        if(shift || ctrl) {\n            cancelDrawMode = true;\n        }\n\n        mouseDownTime = System.currentTimeMillis();\n        didMove = false;\n        initialMoveThresholdExceeded = false;\n\n        Collection<OsmPrimitive> osmColl = getNearestCollectionVirtual(e.getPoint(), alt);\n\n        if (ctrl && shift) {\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                selectPrims(osmColl, true, false, false, false);\n            }\n            mode = Mode.rotate;\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n        } else if (!osmColl.isEmpty()) {\n            // Don't replace the selection now if the user clicked on a\n            // selected object (this would break moving of selected groups).\n            // We'll do that later in mouseReleased if the user didn't try to\n            // move.\n            selectPrims(osmColl,\n                    shift || getCurrentDataSet().getSelected().containsAll(osmColl),\n                    ctrl, false, false);\n            mode = Mode.move;\n        } else {\n            mode = Mode.select;\n            oldCursor = Main.map.mapView.getCursor();\n            selectionManager.register(Main.map.mapView);\n            selectionManager.mousePressed(e);\n        }\n        if(mode != Mode.move || shift || ctrl)\n        {\n            virtualNode = null;\n            virtualWays.clear();\n        }\n\n        updateStatusLine();\n        // Mode.select redraws when selectPrims is called\n        // Mode.move   redraws when mouseDragged is called\n        // Mode.rotate redraws here\n        if(mode == Mode.rotate) {\n            Main.map.mapView.repaint();\n        }\n\n        mousePos = e.getPoint();\n    }","id":11035,"modified_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override public void mousePressed(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        // request focus in order to enable the expected keyboard shortcuts\n        Main.map.mapView.requestFocus();\n\n        cancelDrawMode = false;\n        if (! (Boolean)this.getValue(\"active\")) return;\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        if(shift || ctrl) {\n            cancelDrawMode = true;\n        }\n\n        mouseDownTime = System.currentTimeMillis();\n        didMove = false;\n        initialMoveThresholdExceeded = false;\n\n        Collection<OsmPrimitive> osmColl = getNearestCollectionVirtual(e.getPoint());\n\n        if (ctrl && shift) {\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                selectPrims(osmColl, true, false, false, false);\n            }\n            mode = Mode.rotate;\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n        } else if (!osmColl.isEmpty()) {\n            // Don't replace the selection now if the user clicked on a\n            // selected object (this would break moving of selected groups).\n            // We'll do that later in mouseReleased if the user didn't try to\n            // move.\n            selectPrims(osmColl,\n                    shift || getCurrentDataSet().getSelected().containsAll(osmColl),\n                    ctrl, false, false);\n            mode = Mode.move;\n        } else {\n            mode = Mode.select;\n            oldCursor = Main.map.mapView.getCursor();\n            selectionManager.register(Main.map.mapView);\n            selectionManager.mousePressed(e);\n        }\n\n        if(mode != Mode.move || shift || ctrl) {\n            virtualNode = null;\n            virtualWays.clear();\n        }\n\n        updateStatusLine();\n        // Mode.select redraws when selectPrims is called\n        // Mode.move   redraws when mouseDragged is called\n        // Mode.rotate redraws here\n        if(mode == Mode.rotate) {\n            Main.map.mapView.repaint();\n        }\n\n        mousePos = e.getPoint();\n    }","commit_id":"a55e13c1d42c6de7a313acf44f7c020b3b800bd2","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Restore the old mouse cursor.\n     */\n    @Override public void mouseReleased(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        if (mode == Mode.select) {\n            selectionManager.unregister(Main.map.mapView);\n\n            // Select Draw Tool if no selection has been made\n            if(getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n        restoreCursor();\n\n        if (mode == Mode.move) {\n            boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n            boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n            if (!didMove) {\n                selectPrims(\n                        Main.map.mapView.getNearestCollection(e.getPoint(), OsmPrimitive.isSelectablePredicate),\n                        shift, ctrl, true, false);\n\n                // If the user double-clicked a node, change to draw mode\n                List<OsmPrimitive> sel = new ArrayList<OsmPrimitive>(getCurrentDataSet().getSelected());\n                if(e.getClickCount() >=2 && sel.size() == 1 && sel.get(0) instanceof Node) {\n                    // We need to do it like this as otherwise drawAction will see a double\n                    // click and switch back to SelectMode\n                    Main.worker.execute(new Runnable(){\n                        public void run() {\n                            Main.map.selectDrawTool(true);\n                        }\n                    });\n                    return;\n                }\n            } else {\n                Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n                Collection<OsmPrimitive> s = new TreeSet<OsmPrimitive>();\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20);\n                for (OsmPrimitive osm : selection)\n                {\n                    if(osm instanceof Node) {\n                        s.add(osm);\n                    } else if(osm instanceof Way)\n                    {\n                        s.add(osm);\n                        s.addAll(((Way)osm).getNodes());\n                    }\n                    if(s.size() > max)\n                    {\n                        ExtendedDialog ed = new ExtendedDialog(\n                                Main.parent,\n                                tr(\"Move elements\"),\n                                new String[] {tr(\"Move them\"), tr(\"Undo move\")});\n                        ed.setButtonIcons(new String[] {\"reorder.png\", \"cancel.png\"});\n                        ed.setContent(tr(\"You moved more than {0} elements. \"\n                                + \"Moving a large number of elements is often an error.\\n\"\n                                + \"Really move them?\", max));\n                        ed.setCancelButton(2);\n                        ed.toggleEnable(\"movedManyElements\");\n                        ed.showDialog();\n\n                        if(ed.getValue() != 1)\n                        {\n                            Main.main.undoRedo.undo();\n                        }\n                        break;\n                    }\n                }\n                if (ctrl) {\n                    Collection<Node> affectedNodes = OsmPrimitive.getFilteredSet(selection, Node.class);\n                    Collection<Node> nn = Main.map.mapView.getNearestNodes(e.getPoint(), affectedNodes, OsmPrimitive.isSelectablePredicate);\n                    if (nn != null) {\n                        Node targetNode = nn.iterator().next();\n                        Set<Node> nodesToMerge = new HashSet<Node>(affectedNodes);\n                        nodesToMerge.add(targetNode);\n                        if (!nodesToMerge.isEmpty()) {\n                            Command cmd = MergeNodesAction.mergeNodes(Main.main.getEditLayer(),nodesToMerge, targetNode);\n                            if(cmd != null) {\n                                Main.main.undoRedo.add(cmd);\n                            }\n                        }\n                    }\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","id":11036,"modified_method":"/**\n     * Restore the old mouse cursor.\n     */\n    @Override public void mouseReleased(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        if (mode == Mode.select) {\n            selectionManager.unregister(Main.map.mapView);\n\n            // Select Draw Tool if no selection has been made\n            if(getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n        restoreCursor();\n\n        if (mode == Mode.move) {\n            boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n            boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n            boolean alt = (e.getModifiers() & (ActionEvent.ALT_MASK|InputEvent.ALT_GRAPH_MASK)) != 0\n                            || Main.pref.getBoolean(\"selectaction.cycles.multiple.matches\", false);\n\n            virtualWays.clear();\n            virtualNode = null;\n\n            if (!didMove) {\n                Collection<OsmPrimitive> c = Main.map.mapView.getNearestCollection(e.getPoint(), OsmPrimitive.isSelectablePredicate);\n                if (!c.isEmpty() && alt) {\n                    if (c.iterator().next() instanceof Node) {\n                        // consider all nearest nodes\n                        c = new ArrayList<OsmPrimitive>(Main.map.mapView.getNearestNodes(e.getPoint(), OsmPrimitive.isSelectablePredicate));\n                    } else {\n                        // consider all nearest primitives (should be only ways at this point..)\n                        c = Main.map.mapView.getAllNearest(e.getPoint(), OsmPrimitive.isSelectablePredicate);\n                    }\n                }\n                selectPrims(c, shift, ctrl, true, false);\n\n                // If the user double-clicked a node, change to draw mode\n                c = getCurrentDataSet().getSelected();\n                if(e.getClickCount() >=2 && c.size() == 1 && c.iterator().next() instanceof Node) {\n                    // We need to do it like this as otherwise drawAction will see a double\n                    // click and switch back to SelectMode\n                    Main.worker.execute(new Runnable(){\n                        public void run() {\n                            Main.map.selectDrawTool(true);\n                        }\n                    });\n                    return;\n                }\n            } else {\n                Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n                Collection<OsmPrimitive> s = new TreeSet<OsmPrimitive>();\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20);\n                for (OsmPrimitive osm : selection)\n                {\n                    if(osm instanceof Node) {\n                        s.add(osm);\n                    } else if(osm instanceof Way)\n                    {\n                        s.add(osm);\n                        s.addAll(((Way)osm).getNodes());\n                    }\n                    if(s.size() > max)\n                    {\n                        ExtendedDialog ed = new ExtendedDialog(\n                                Main.parent,\n                                tr(\"Move elements\"),\n                                new String[] {tr(\"Move them\"), tr(\"Undo move\")});\n                        ed.setButtonIcons(new String[] {\"reorder.png\", \"cancel.png\"});\n                        ed.setContent(tr(\"You moved more than {0} elements. \"\n                                + \"Moving a large number of elements is often an error.\\n\"\n                                + \"Really move them?\", max));\n                        ed.setCancelButton(2);\n                        ed.toggleEnable(\"movedManyElements\");\n                        ed.showDialog();\n\n                        if(ed.getValue() != 1)\n                        {\n                            Main.main.undoRedo.undo();\n                        }\n                        break;\n                    }\n                }\n                if (ctrl) {\n                    Collection<Node> affectedNodes = OsmPrimitive.getFilteredSet(selection, Node.class);\n                    Collection<Node> nn = Main.map.mapView.getNearestNodes(e.getPoint(), affectedNodes, OsmPrimitive.isSelectablePredicate);\n                    if (nn != null) {\n                        Node targetNode = nn.iterator().next();\n                        Set<Node> nodesToMerge = new HashSet<Node>(affectedNodes);\n                        nodesToMerge.add(targetNode);\n                        if (!nodesToMerge.isEmpty()) {\n                            Command cmd = MergeNodesAction.mergeNodes(Main.main.getEditLayer(),nodesToMerge, targetNode);\n                            if(cmd != null) {\n                                Main.main.undoRedo.add(cmd);\n                            }\n                        }\n                    }\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","commit_id":"a55e13c1d42c6de7a313acf44f7c020b3b800bd2","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void selectPrims(Collection<OsmPrimitive> selectionList, boolean shift,\n            boolean ctrl, boolean released, boolean area) {\n        DataSet ds = getCurrentDataSet();\n        if ((shift && ctrl) || (ctrl && !released))\n            return; // not allowed together\n\n        if (ctrl) {\n            // Ctrl on an item toggles its selection status,\n            // but Ctrl on an *area* just clears those items\n            // out of the selection.\n            if (area) {\n                ds.clearSelection(selectionList);\n            } else {\n                ds.toggleSelected(selectionList);\n            }\n        } else {\n            // plain clicks with no modifiers\n            if (!shift) {\n                ds.setSelected(selectionList);\n            } else {\n                // add things to an\n                // existing selection.\n                ds.addSelected(selectionList);\n            }\n        }\n    }","id":11037,"modified_method":"public void selectPrims(Collection<OsmPrimitive> selectionList, boolean shift,\n            boolean ctrl, boolean released, boolean area) {\n        DataSet ds = getCurrentDataSet();\n\n        // decides on mousePressed whether\n        //      to cycle on mouseReleased (selList already selected)\n        //      or not                    (selList is a new selection)\n        selMorePrims = (released || area) ? selMorePrims : ds.getSelected().containsAll(selectionList);\n\n        // not allowed together: do not change dataset selection, return early\n        if ((shift && ctrl) || (ctrl && !released) || (!virtualWays.isEmpty()))\n            return;\n\n        // toggle through possible objects on mouse release\n        if (released && !area) {\n            if (selectionList.size() > 1) {\n                Collection<OsmPrimitive> coll = ds.getSelected();\n\n                OsmPrimitive first, foundInDS, node, nxt;\n                first = nxt = selectionList.iterator().next();\n                foundInDS = node = null;\n\n                for (Iterator<OsmPrimitive> i = selectionList.iterator(); i.hasNext(); ) {\n                    if (selMorePrims && shift) {\n                        if (!coll.contains(nxt = i.next())) {\n                            break; // take first primitive not in dsSel or last if all contained\n                        }\n                    } else {\n                        if (coll.contains(nxt = i.next())) {\n                            foundInDS = nxt;\n                            if (selMorePrims || ctrl) {\n                                ds.clearSelection(nxt);\n                                nxt = i.hasNext() ? i.next() : first;\n                            }\n                            break; // take next primitive of selList\n                        } else if (nxt instanceof Node && node == null) {\n                            node = nxt;\n                        }\n                    }\n                }\n\n                if (ctrl) {\n                    if (foundInDS != null) {\n                        // a member of selList was foundInDS\n                        if (!selectionList.contains(selCycleStart)) {\n                            selCycleStart = foundInDS;\n                        }\n                        // check if selCycleStart == prim (equals next(foundInDS))\n                        if (selCycleStart.equals(nxt)) {\n                            ds.addSelected(nxt);   // cycle complete, prim toggled below\n                            selCycleStart = null;  // check: might do w/out ??\n                        }\n                    } else {\n                        // no member of selList was foundInDS (sets were disjunct), setup for new cycle\n                        selCycleStart = nxt = (node != null) ? node : first;\n                    }\n                }\n\n                selectionList = new ArrayList<OsmPrimitive>(1); // do not modify the passed object..\n                selectionList.add(nxt);\n            }\n        }\n\n        if (ctrl) {\n            // Ctrl on an item toggles its selection status,\n            // but Ctrl on an *area* just clears those items\n            // out of the selection.\n            if (area) {\n                ds.clearSelection(selectionList);\n            } else {\n                ds.toggleSelected(selectionList);\n            }\n        } else {\n            // plain clicks with no modifiers\n            if (!shift) {\n                ds.setSelected(selectionList);\n            } else {\n                // add things to an\n                // existing selection.\n                ds.addSelected(selectionList);\n            }\n        }\n    }","commit_id":"a55e13c1d42c6de7a313acf44f7c020b3b800bd2","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override public void mouseDragged(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select) return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay)) return;\n\n        if(mode != Mode.rotate) // button is pressed in rotate mode\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (mousePos == null) {\n            mousePos = e.getPoint();\n            return;\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = mousePos.x - e.getX();\n            int dyp = mousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp*dxp+dyp*dyp);\n            if (dp < initialMoveThreshold) return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth mouseEN = Main.map.mapView.getEastNorth(e.getX(), e.getY());\n        EastNorth mouseStartEN = Main.map.mapView.getEastNorth(mousePos.x, mousePos.y);\n        double dx = mouseEN.east() - mouseStartEN.east();\n        double dy = mouseEN.north() - mouseStartEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex+1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            selectPrims(Collections.singleton((OsmPrimitive)virtualNode), false, false, false, false);\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support moving and rotating, which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // when rotating, having only one node makes no sense - quit silently\n            if (mode == Mode.rotate && affectedNodes.size() < 2)\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n            ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand)c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand)c).getParticipatingPrimitives())) {\n                    ((MoveCommand)c).moveAgain(dx,dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE\n\n                        );\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand)c).getRotatedNodes())) {\n                    ((RotateCommand)c).rotateAgain(mouseStartEN, mouseEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, mouseStartEN, mouseEN));\n                }\n            }\n        }\n\n        Main.map.mapView.repaint();\n        mousePos = e.getPoint();\n\n        didMove = true;\n    }","id":11038,"modified_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override public void mouseDragged(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select) return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay)) return;\n\n        if(mode != Mode.rotate) // button is pressed in rotate mode\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (mousePos == null) {\n            mousePos = e.getPoint();\n            return;\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = mousePos.x - e.getX();\n            int dyp = mousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp*dxp+dyp*dyp);\n            if (dp < initialMoveThreshold) return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth mouseEN = Main.map.mapView.getEastNorth(e.getX(), e.getY());\n        EastNorth mouseStartEN = Main.map.mapView.getEastNorth(mousePos.x, mousePos.y);\n        double dx = mouseEN.east() - mouseStartEN.east();\n        double dy = mouseEN.north() - mouseStartEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex+1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            getCurrentDataSet().setSelected(Collections.singleton((OsmPrimitive)virtualNode));\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support moving and rotating, which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // when rotating, having only one node makes no sense - quit silently\n            if (mode == Mode.rotate && affectedNodes.size() < 2)\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n            ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand)c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand)c).getParticipatingPrimitives())) {\n                    ((MoveCommand)c).moveAgain(dx,dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE\n\n                        );\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand)c).getRotatedNodes())) {\n                    ((RotateCommand)c).rotateAgain(mouseStartEN, mouseEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, mouseStartEN, mouseEN));\n                }\n            }\n        }\n\n        Main.map.mapView.repaint();\n        mousePos = e.getPoint();\n\n        didMove = true;\n    }","commit_id":"a55e13c1d42c6de7a313acf44f7c020b3b800bd2","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override public void mousePressed(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        // request focus in order to enable the expected keyboard shortcuts\n        Main.map.mapView.requestFocus();\n\n        cancelDrawMode = false;\n        if (! (Boolean)this.getValue(\"active\")) return;\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        if(shift || ctrl) {\n            cancelDrawMode = true;\n        }\n\n        mouseDownTime = System.currentTimeMillis();\n        didMove = false;\n        initialMoveThresholdExceeded = false;\n\n        Collection<OsmPrimitive> osmColl = getNearestCollectionVirtual(e.getPoint());\n\n        if (ctrl && shift) {\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                selectPrims(osmColl, true, false, false, false);\n            }\n            mode = Mode.rotate;\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n        } else if (!osmColl.isEmpty()) {\n            // Don't replace the selection now if the user clicked on a\n            // selected object (this would break moving of selected groups).\n            // We'll do that later in mouseReleased if the user didn't try to\n            // move.\n            selectPrims(osmColl,\n                    shift || getCurrentDataSet().getSelected().containsAll(osmColl),\n                    ctrl, false, false);\n            mode = Mode.move;\n        } else {\n            mode = Mode.select;\n            oldCursor = Main.map.mapView.getCursor();\n            selectionManager.register(Main.map.mapView);\n            selectionManager.mousePressed(e);\n        }\n\n        if(mode != Mode.move || shift || ctrl) {\n            virtualNode = null;\n            virtualWays.clear();\n        }\n\n        updateStatusLine();\n        // Mode.select redraws when selectPrims is called\n        // Mode.move   redraws when mouseDragged is called\n        // Mode.rotate redraws here\n        if(mode == Mode.rotate) {\n            Main.map.mapView.repaint();\n        }\n\n        mousePos = e.getPoint();\n    }","id":11039,"modified_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override public void mousePressed(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n        // request focus in order to enable the expected keyboard shortcuts\n        //\n        Main.map.mapView.requestFocus();\n\n        cancelDrawMode = false;\n        if (! (Boolean)this.getValue(\"active\")) return;\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean alt = (e.getModifiers() & (ActionEvent.ALT_MASK|InputEvent.ALT_GRAPH_MASK)) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        if(shift || ctrl) {\n            cancelDrawMode = true;\n        }\n\n        mouseDownTime = System.currentTimeMillis();\n        didMove = false;\n        initialMoveThresholdExceeded = false;\n\n        Collection<OsmPrimitive> osmColl = getNearestCollectionVirtual(e.getPoint(), alt);\n\n        if (ctrl && shift) {\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                selectPrims(osmColl, true, false, false, false);\n            }\n            mode = Mode.rotate;\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n        } else if (!osmColl.isEmpty()) {\n            // Don't replace the selection now if the user clicked on a\n            // selected object (this would break moving of selected groups).\n            // We'll do that later in mouseReleased if the user didn't try to\n            // move.\n            selectPrims(osmColl,\n                    shift || getCurrentDataSet().getSelected().containsAll(osmColl),\n                    ctrl, false, false);\n            mode = Mode.move;\n        } else {\n            mode = Mode.select;\n            oldCursor = Main.map.mapView.getCursor();\n            selectionManager.register(Main.map.mapView);\n            selectionManager.mousePressed(e);\n        }\n        if(mode != Mode.move || shift || ctrl)\n        {\n            virtualNode = null;\n            virtualWays.clear();\n        }\n\n        updateStatusLine();\n        // Mode.select redraws when selectPrims is called\n        // Mode.move   redraws when mouseDragged is called\n        // Mode.rotate redraws here\n        if(mode == Mode.rotate) {\n            Main.map.mapView.repaint();\n        }\n\n        mousePos = e.getPoint();\n    }","commit_id":"31f20bfbdbd5d4c469c2e62476e5f90e1ace8cd1","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void selectPrims(Collection<OsmPrimitive> selectionList, boolean shift,\n            boolean ctrl, boolean released, boolean area) {\n        DataSet ds = getCurrentDataSet();\n\n        // decides on mousePressed whether\n        //      to cycle on mouseReleased (selList already selected)\n        //      or not                    (selList is a new selection)\n        selMorePrims = (released || area) ? selMorePrims : ds.getSelected().containsAll(selectionList);\n\n        // not allowed together: do not change dataset selection, return early\n        if ((shift && ctrl) || (ctrl && !released) || (!virtualWays.isEmpty()))\n            return;\n\n        // toggle through possible objects on mouse release\n        if (released && !area) {\n            if (selectionList.size() > 1) {\n                Collection<OsmPrimitive> coll = ds.getSelected();\n\n                OsmPrimitive first, foundInDS, node, nxt;\n                first = nxt = selectionList.iterator().next();\n                foundInDS = node = null;\n\n                for (Iterator<OsmPrimitive> i = selectionList.iterator(); i.hasNext(); ) {\n                    if (selMorePrims && shift) {\n                        if (!coll.contains(nxt = i.next())) {\n                            break; // take first primitive not in dsSel or last if all contained\n                        }\n                    } else {\n                        if (coll.contains(nxt = i.next())) {\n                            foundInDS = nxt;\n                            if (selMorePrims || ctrl) {\n                                ds.clearSelection(nxt);\n                                nxt = i.hasNext() ? i.next() : first;\n                            }\n                            break; // take next primitive of selList\n                        } else if (nxt instanceof Node && node == null) {\n                            node = nxt;\n                        }\n                    }\n                }\n\n                if (ctrl) {\n                    if (foundInDS != null) {\n                        // a member of selList was foundInDS\n                        if (!selectionList.contains(selCycleStart)) {\n                            selCycleStart = foundInDS;\n                        }\n                        // check if selCycleStart == prim (equals next(foundInDS))\n                        if (selCycleStart.equals(nxt)) {\n                            ds.addSelected(nxt);   // cycle complete, prim toggled below\n                            selCycleStart = null;  // check: might do w/out ??\n                        }\n                    } else {\n                        // no member of selList was foundInDS (sets were disjunct), setup for new cycle\n                        selCycleStart = nxt = (node != null) ? node : first;\n                    }\n                }\n\n                selectionList = new ArrayList<OsmPrimitive>(1); // do not modify the passed object..\n                selectionList.add(nxt);\n            }\n        }\n\n        if (ctrl) {\n            // Ctrl on an item toggles its selection status,\n            // but Ctrl on an *area* just clears those items\n            // out of the selection.\n            if (area) {\n                ds.clearSelection(selectionList);\n            } else {\n                ds.toggleSelected(selectionList);\n            }\n        } else {\n            // plain clicks with no modifiers\n            if (!shift) {\n                ds.setSelected(selectionList);\n            } else {\n                // add things to an\n                // existing selection.\n                ds.addSelected(selectionList);\n            }\n        }\n    }","id":11040,"modified_method":"public void selectPrims(Collection<OsmPrimitive> selectionList, boolean shift,\n            boolean ctrl, boolean released, boolean area) {\n        DataSet ds = getCurrentDataSet();\n        if ((shift && ctrl) || (ctrl && !released))\n            return; // not allowed together\n\n        if (ctrl) {\n            // Ctrl on an item toggles its selection status,\n            // but Ctrl on an *area* just clears those items\n            // out of the selection.\n            if (area) {\n                ds.clearSelection(selectionList);\n            } else {\n                ds.toggleSelected(selectionList);\n            }\n        } else {\n            // plain clicks with no modifiers\n            if (!shift) {\n                ds.setSelected(selectionList);\n            } else {\n                // add things to an\n                // existing selection.\n                ds.addSelected(selectionList);\n            }\n        }\n    }","commit_id":"31f20bfbdbd5d4c469c2e62476e5f90e1ace8cd1","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override public void mouseDragged(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select) return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay)) return;\n\n        if(mode != Mode.rotate) // button is pressed in rotate mode\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (mousePos == null) {\n            mousePos = e.getPoint();\n            return;\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = mousePos.x - e.getX();\n            int dyp = mousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp*dxp+dyp*dyp);\n            if (dp < initialMoveThreshold) return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth mouseEN = Main.map.mapView.getEastNorth(e.getX(), e.getY());\n        EastNorth mouseStartEN = Main.map.mapView.getEastNorth(mousePos.x, mousePos.y);\n        double dx = mouseEN.east() - mouseStartEN.east();\n        double dy = mouseEN.north() - mouseStartEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex+1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            getCurrentDataSet().setSelected(Collections.singleton((OsmPrimitive)virtualNode));\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support moving and rotating, which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // when rotating, having only one node makes no sense - quit silently\n            if (mode == Mode.rotate && affectedNodes.size() < 2)\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n            ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand)c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand)c).getParticipatingPrimitives())) {\n                    ((MoveCommand)c).moveAgain(dx,dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE\n\n                        );\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand)c).getRotatedNodes())) {\n                    ((RotateCommand)c).rotateAgain(mouseStartEN, mouseEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, mouseStartEN, mouseEN));\n                }\n            }\n        }\n\n        Main.map.mapView.repaint();\n        mousePos = e.getPoint();\n\n        didMove = true;\n    }","id":11041,"modified_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override public void mouseDragged(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select) return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay)) return;\n\n        if(mode != Mode.rotate) // button is pressed in rotate mode\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (mousePos == null) {\n            mousePos = e.getPoint();\n            return;\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = mousePos.x - e.getX();\n            int dyp = mousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp*dxp+dyp*dyp);\n            if (dp < initialMoveThreshold) return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth mouseEN = Main.map.mapView.getEastNorth(e.getX(), e.getY());\n        EastNorth mouseStartEN = Main.map.mapView.getEastNorth(mousePos.x, mousePos.y);\n        double dx = mouseEN.east() - mouseStartEN.east();\n        double dy = mouseEN.north() - mouseStartEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex+1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            selectPrims(Collections.singleton((OsmPrimitive)virtualNode), false, false, false, false);\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support moving and rotating, which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // when rotating, having only one node makes no sense - quit silently\n            if (mode == Mode.rotate && affectedNodes.size() < 2)\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n            ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand)c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand)c).getParticipatingPrimitives())) {\n                    ((MoveCommand)c).moveAgain(dx,dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE\n\n                        );\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand)c).getRotatedNodes())) {\n                    ((RotateCommand)c).rotateAgain(mouseStartEN, mouseEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, mouseStartEN, mouseEN));\n                }\n            }\n        }\n\n        Main.map.mapView.repaint();\n        mousePos = e.getPoint();\n\n        didMove = true;\n    }","commit_id":"31f20bfbdbd5d4c469c2e62476e5f90e1ace8cd1","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Restore the old mouse cursor.\n     */\n    @Override public void mouseReleased(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        if (mode == Mode.select) {\n            selectionManager.unregister(Main.map.mapView);\n\n            // Select Draw Tool if no selection has been made\n            if(getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n        restoreCursor();\n\n        if (mode == Mode.move) {\n            boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n            boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n            boolean alt = (e.getModifiers() & (ActionEvent.ALT_MASK|InputEvent.ALT_GRAPH_MASK)) != 0\n                            || Main.pref.getBoolean(\"selectaction.cycles.multiple.matches\", false);\n\n            virtualWays.clear();\n            virtualNode = null;\n\n            if (!didMove) {\n                Collection<OsmPrimitive> c = Main.map.mapView.getNearestCollection(e.getPoint(), OsmPrimitive.isSelectablePredicate);\n                if (!c.isEmpty() && alt) {\n                    if (c.iterator().next() instanceof Node) {\n                        // consider all nearest nodes\n                        c = new ArrayList<OsmPrimitive>(Main.map.mapView.getNearestNodes(e.getPoint(), OsmPrimitive.isSelectablePredicate));\n                    } else {\n                        // consider all nearest primitives (should be only ways at this point..)\n                        c = Main.map.mapView.getAllNearest(e.getPoint(), OsmPrimitive.isSelectablePredicate);\n                    }\n                }\n                selectPrims(c, shift, ctrl, true, false);\n\n                // If the user double-clicked a node, change to draw mode\n                c = getCurrentDataSet().getSelected();\n                if(e.getClickCount() >=2 && c.size() == 1 && c.iterator().next() instanceof Node) {\n                    // We need to do it like this as otherwise drawAction will see a double\n                    // click and switch back to SelectMode\n                    Main.worker.execute(new Runnable(){\n                        public void run() {\n                            Main.map.selectDrawTool(true);\n                        }\n                    });\n                    return;\n                }\n            } else {\n                Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n                Collection<OsmPrimitive> s = new TreeSet<OsmPrimitive>();\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20);\n                for (OsmPrimitive osm : selection)\n                {\n                    if(osm instanceof Node) {\n                        s.add(osm);\n                    } else if(osm instanceof Way)\n                    {\n                        s.add(osm);\n                        s.addAll(((Way)osm).getNodes());\n                    }\n                    if(s.size() > max)\n                    {\n                        ExtendedDialog ed = new ExtendedDialog(\n                                Main.parent,\n                                tr(\"Move elements\"),\n                                new String[] {tr(\"Move them\"), tr(\"Undo move\")});\n                        ed.setButtonIcons(new String[] {\"reorder.png\", \"cancel.png\"});\n                        ed.setContent(tr(\"You moved more than {0} elements. \"\n                                + \"Moving a large number of elements is often an error.\\n\"\n                                + \"Really move them?\", max));\n                        ed.setCancelButton(2);\n                        ed.toggleEnable(\"movedManyElements\");\n                        ed.showDialog();\n\n                        if(ed.getValue() != 1)\n                        {\n                            Main.main.undoRedo.undo();\n                        }\n                        break;\n                    }\n                }\n                if (ctrl) {\n                    Collection<Node> affectedNodes = OsmPrimitive.getFilteredSet(selection, Node.class);\n                    Collection<Node> nn = Main.map.mapView.getNearestNodes(e.getPoint(), affectedNodes, OsmPrimitive.isSelectablePredicate);\n                    if (nn != null) {\n                        Node targetNode = nn.iterator().next();\n                        Set<Node> nodesToMerge = new HashSet<Node>(affectedNodes);\n                        nodesToMerge.add(targetNode);\n                        if (!nodesToMerge.isEmpty()) {\n                            Command cmd = MergeNodesAction.mergeNodes(Main.main.getEditLayer(),nodesToMerge, targetNode);\n                            if(cmd != null) {\n                                Main.main.undoRedo.add(cmd);\n                            }\n                        }\n                    }\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","id":11042,"modified_method":"/**\n     * Restore the old mouse cursor.\n     */\n    @Override public void mouseReleased(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        if (mode == Mode.select) {\n            selectionManager.unregister(Main.map.mapView);\n\n            // Select Draw Tool if no selection has been made\n            if(getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n        restoreCursor();\n\n        if (mode == Mode.move) {\n            boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n            boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n            if (!didMove) {\n                selectPrims(\n                        Main.map.mapView.getNearestCollection(e.getPoint(), OsmPrimitive.isSelectablePredicate),\n                        shift, ctrl, true, false);\n\n                // If the user double-clicked a node, change to draw mode\n                List<OsmPrimitive> sel = new ArrayList<OsmPrimitive>(getCurrentDataSet().getSelected());\n                if(e.getClickCount() >=2 && sel.size() == 1 && sel.get(0) instanceof Node) {\n                    // We need to do it like this as otherwise drawAction will see a double\n                    // click and switch back to SelectMode\n                    Main.worker.execute(new Runnable(){\n                        public void run() {\n                            Main.map.selectDrawTool(true);\n                        }\n                    });\n                    return;\n                }\n            } else {\n                Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n                Collection<OsmPrimitive> s = new TreeSet<OsmPrimitive>();\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20);\n                for (OsmPrimitive osm : selection)\n                {\n                    if(osm instanceof Node) {\n                        s.add(osm);\n                    } else if(osm instanceof Way)\n                    {\n                        s.add(osm);\n                        s.addAll(((Way)osm).getNodes());\n                    }\n                    if(s.size() > max)\n                    {\n                        ExtendedDialog ed = new ExtendedDialog(\n                                Main.parent,\n                                tr(\"Move elements\"),\n                                new String[] {tr(\"Move them\"), tr(\"Undo move\")});\n                        ed.setButtonIcons(new String[] {\"reorder.png\", \"cancel.png\"});\n                        ed.setContent(tr(\"You moved more than {0} elements. \"\n                                + \"Moving a large number of elements is often an error.\\n\"\n                                + \"Really move them?\", max));\n                        ed.setCancelButton(2);\n                        ed.toggleEnable(\"movedManyElements\");\n                        ed.showDialog();\n\n                        if(ed.getValue() != 1)\n                        {\n                            Main.main.undoRedo.undo();\n                        }\n                        break;\n                    }\n                }\n                if (ctrl) {\n                    Collection<Node> affectedNodes = OsmPrimitive.getFilteredSet(selection, Node.class);\n                    Collection<Node> nn = Main.map.mapView.getNearestNodes(e.getPoint(), affectedNodes, OsmPrimitive.isSelectablePredicate);\n                    if (nn != null) {\n                        Node targetNode = nn.iterator().next();\n                        Set<Node> nodesToMerge = new HashSet<Node>(affectedNodes);\n                        nodesToMerge.add(targetNode);\n                        if (!nodesToMerge.isEmpty()) {\n                            Command cmd = MergeNodesAction.mergeNodes(Main.main.getEditLayer(),nodesToMerge, targetNode);\n                            if(cmd != null) {\n                                Main.main.undoRedo.add(cmd);\n                            }\n                        }\n                    }\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","commit_id":"31f20bfbdbd5d4c469c2e62476e5f90e1ace8cd1","url":"https://github.com/openstreetmap/josm"},{"original_method":"private Collection<OsmPrimitive> getNearestCollectionVirtual(Point p) {\n        int snapDistance = Main.pref.getInteger(\"mappaint.node.virtual-snap-distance\", 8);\n        int virtualSpace = Main.pref.getInteger(\"mappaint.node.virtual-space\", 70);\n        snapDistance *= snapDistance;\n\n        MapView c = Main.map.mapView;\n        Collection<OsmPrimitive> sel = getCurrentDataSet().getSelected();\n\n        // take nearest node\n        OsmPrimitive osm = c.getNearestNode(p, OsmPrimitive.isSelectablePredicate);\n\n        if (osm != null) {\n            for (Node n : c.getNearestNodes(p, OsmPrimitive.isSelectablePredicate)) {\n                if (sel.contains(n)) {\n                    // take nearest selected node\n                    osm = n;\n                    break;\n                }\n            }\n        } else {\n            Node virtualWayNode = null;\n            Way w = null;\n\n            Collection<WaySegment> virtualWaysInSel = new ArrayList<WaySegment>();\n            Collection<WaySegment> wss = c.getNearestWaySegments(p, OsmPrimitive.isSelectablePredicate);\n            for(WaySegment nearestWS : wss) {\n                if (nearestWS == null) {\n                    continue;\n                }\n\n                w = nearestWS.way;\n                if (osm == null && sel.contains(w)) {\n                    // take nearest selected way\n                    osm = w;\n                }\n\n                if (Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) > 0) {\n                    Point p1 = c.getPoint(w.getNode(nearestWS.lowerIndex));\n                    Point p2 = c.getPoint(w.getNode(nearestWS.lowerIndex+1));\n                    if(SimplePaintVisitor.isLargeSegment(p1, p2, virtualSpace))\n                    {\n                        Point pc = new Point((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n                        if (p.distanceSq(pc) < snapDistance)\n                        {\n                            // Check that only segments on top of each other get added to the\n                            // virtual ways list. Otherwise ways that coincidentally have their\n                            // virtual node at the same spot will be joined which is likely unwanted\n                            if(virtualWayNode != null) {\n                                if(!w.getNode(nearestWS.lowerIndex+1).equals(virtualWayNode)\n                                        && !w.getNode(nearestWS.lowerIndex).equals(virtualWayNode)) {\n                                    continue;\n                                }\n                            } else {\n                                virtualWayNode = w.getNode(nearestWS.lowerIndex+1);\n                            }\n\n                            (!sel.contains(w) ? virtualWays : virtualWaysInSel).add(nearestWS);\n                            if(virtualNode == null) {\n                                virtualNode = new Node(Main.map.mapView.getLatLon(pc.x, pc.y));\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (virtualNode != null) {\n                // insert virtualNode into all segments if nothing was selected,\n                // else only into the (previously) selected segments\n                virtualWays = virtualWaysInSel.isEmpty() ? virtualWays : virtualWaysInSel;\n            }\n\n            if (osm == null && !wss.isEmpty()) {\n                // take nearest way\n                osm = wss.iterator().next().way;\n            }\n        }\n\n        if (osm == null)\n            return Collections.emptySet();\n        return Collections.singleton(osm);\n    }","id":11043,"modified_method":"private Collection<OsmPrimitive> getNearestCollectionVirtual(Point p, boolean allSegements) {\n        MapView c = Main.map.mapView;\n        int snapDistance = Main.pref.getInteger(\"mappaint.node.virtual-snap-distance\", 8);\n        snapDistance *= snapDistance;\n        OsmPrimitive osm = c.getNearestNode(p, OsmPrimitive.isSelectablePredicate);\n        virtualWays.clear();\n        virtualNode = null;\n        Node virtualWayNode = null;\n\n        if (osm == null)\n        {\n            Collection<WaySegment> nearestWaySegs = allSegements\n            ? c.getNearestWaySegments(p, OsmPrimitive.isSelectablePredicate)\n                    : Collections.singleton(c.getNearestWaySegment(p, OsmPrimitive.isSelectablePredicate));\n\n            for(WaySegment nearestWS : nearestWaySegs) {\n                if (nearestWS == null) {\n                    continue;\n                }\n\n                osm = nearestWS.way;\n                if(Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) > 0)\n                {\n                    Way w = (Way)osm;\n                    Point p1 = c.getPoint(w.getNode(nearestWS.lowerIndex));\n                    Point p2 = c.getPoint(w.getNode(nearestWS.lowerIndex+1));\n                    if(SimplePaintVisitor.isLargeSegment(p1, p2, Main.pref.getInteger(\"mappaint.node.virtual-space\", 70)))\n                    {\n                        Point pc = new Point((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n                        if (p.distanceSq(pc) < snapDistance)\n                        {\n                            // Check that only segments on top of each other get added to the\n                            // virtual ways list. Otherwise ways that coincidentally have their\n                            // virtual node at the same spot will be joined which is likely unwanted\n                            if(virtualWayNode != null) {\n                                if(  !w.getNode(nearestWS.lowerIndex+1).equals(virtualWayNode)\n                                        && !w.getNode(nearestWS.lowerIndex).equals(virtualWayNode)) {\n                                    continue;\n                                }\n                            } else {\n                                virtualWayNode = w.getNode(nearestWS.lowerIndex+1);\n                            }\n\n                            virtualWays.add(nearestWS);\n                            if(virtualNode == null) {\n                                virtualNode = new Node(Main.map.mapView.getLatLon(pc.x, pc.y));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (osm == null)\n            return Collections.emptySet();\n        return Collections.singleton(osm);\n    }","commit_id":"31f20bfbdbd5d4c469c2e62476e5f90e1ace8cd1","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override public void mouseDragged(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select) return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay)) return;\n\n        if(mode != Mode.rotate) // button is pressed in rotate mode\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (mousePos == null) {\n            mousePos = e.getPoint();\n            return;\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = mousePos.x - e.getX();\n            int dyp = mousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp*dxp+dyp*dyp);\n            if (dp < initialMoveThreshold) return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth mouseEN = Main.map.mapView.getEastNorth(e.getX(), e.getY());\n        EastNorth mouseStartEN = Main.map.mapView.getEastNorth(mousePos.x, mousePos.y);\n        double dx = mouseEN.east() - mouseStartEN.east();\n        double dy = mouseEN.north() - mouseStartEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex+1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            selectPrims(Collections.singleton((OsmPrimitive)virtualNode), false, false, false, false);\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support moving and rotating, which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // when rotating, having only one node makes no sense - quit silently\n            if (mode == Mode.rotate && affectedNodes.size() < 2)\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n            ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand)c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand)c).getParticipatingPrimitives())) {\n                    ((MoveCommand)c).moveAgain(dx,dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE\n\n                        );\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand)c).getRotatedNodes())) {\n                    ((RotateCommand)c).rotateAgain(mouseStartEN, mouseEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, mouseStartEN, mouseEN));\n                }\n            }\n        }\n\n        Main.map.mapView.repaint();\n        mousePos = e.getPoint();\n\n        didMove = true;\n    }","id":11044,"modified_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override public void mouseDragged(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select) return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay)) return;\n\n        if(mode != Mode.rotate) // button is pressed in rotate mode\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (mousePos == null) {\n            mousePos = e.getPoint();\n            return;\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = mousePos.x - e.getX();\n            int dyp = mousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp*dxp+dyp*dyp);\n            if (dp < initialMoveThreshold) return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth mouseEN = Main.map.mapView.getEastNorth(e.getX(), e.getY());\n        EastNorth mouseStartEN = Main.map.mapView.getEastNorth(mousePos.x, mousePos.y);\n        double dx = mouseEN.east() - mouseStartEN.east();\n        double dy = mouseEN.north() - mouseStartEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex+1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            getCurrentDataSet().setSelected(Collections.singleton((OsmPrimitive)virtualNode));\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support moving and rotating, which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // when rotating, having only one node makes no sense - quit silently\n            if (mode == Mode.rotate && affectedNodes.size() < 2)\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n            ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand)c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand)c).getParticipatingPrimitives())) {\n                    ((MoveCommand)c).moveAgain(dx,dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE\n\n                        );\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand)c).getRotatedNodes())) {\n                    ((RotateCommand)c).rotateAgain(mouseStartEN, mouseEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, mouseStartEN, mouseEN));\n                }\n            }\n        }\n\n        Main.map.mapView.repaint();\n        mousePos = e.getPoint();\n\n        didMove = true;\n    }","commit_id":"299dd3f4448538a7bf43cd93dbd8c66df6f7f91c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void selectPrims(Collection<OsmPrimitive> selectionList, boolean shift,\n            boolean ctrl, boolean released, boolean area) {\n        DataSet ds = getCurrentDataSet();\n        if ((shift && ctrl) || (ctrl && !released))\n            return; // not allowed together\n\n        if (ctrl) {\n            // Ctrl on an item toggles its selection status,\n            // but Ctrl on an *area* just clears those items\n            // out of the selection.\n            if (area) {\n                ds.clearSelection(selectionList);\n            } else {\n                ds.toggleSelected(selectionList);\n            }\n        } else {\n            // plain clicks with no modifiers\n            if (!shift) {\n                ds.setSelected(selectionList);\n            } else {\n                // add things to an\n                // existing selection.\n                ds.addSelected(selectionList);\n            }\n        }\n    }","id":11045,"modified_method":"public void selectPrims(Collection<OsmPrimitive> selectionList, boolean shift,\n            boolean ctrl, boolean released, boolean area) {\n        DataSet ds = getCurrentDataSet();\n        if ((shift && ctrl) || (ctrl && !released) || (!virtualWays.isEmpty()))\n            return; // not allowed together\n\n        // toggle through possible objects on mouse release\n        if (released && !area) {\n            if (selectionList.size() > 1) {\n                Collection<OsmPrimitive> coll = ds.getSelected();\n\n                OsmPrimitive first, foundInDS, node, nxt;\n                first = nxt = selectionList.iterator().next();\n                foundInDS = node = null;\n\n                for (Iterator<OsmPrimitive> i = selectionList.iterator(); i.hasNext(); ) {\n                    if (selMorePrims && shift) {\n                        if (!coll.contains(nxt = i.next())) {\n                            break; // take first primitive not in dsSel or last if all contained\n                        }\n                    } else {\n                        if (coll.contains(nxt = i.next())) {\n                            foundInDS = nxt;\n                            if (selMorePrims || ctrl) {\n                                ds.clearSelection(nxt);\n                                nxt = i.hasNext() ? i.next() : first;\n                            }\n                            break; // take next primitive of selList\n                        } else if (nxt instanceof Node && node == null) {\n                            node = nxt;\n                        }\n                    }\n                }\n\n                if (ctrl) {\n                    if (foundInDS != null) {\n                        // a member of selList was foundInDS\n                        if (!selectionList.contains(selCycleStart)) {\n                            selCycleStart = foundInDS;\n                        }\n                        // check if selCycleStart == prim (equals next(foundInDS))\n                        if (selCycleStart.equals(nxt)) {\n                            ds.addSelected(nxt);   // cycle complete, prim toggled below\n                            selCycleStart = null;  // check: might do w/out ??\n                        }\n                    } else {\n                        // no member of selList was foundInDS (sets were disjunct), setup for new cycle\n                        selCycleStart = nxt = (node != null) ? node : first;\n                    }\n                }\n\n                selectionList = new ArrayList<OsmPrimitive>(1); // do not modify the passed object..\n                selectionList.add(nxt);\n            }\n        }\n\n        // hard-wiring to false due to performance reasons, should do w/out\n        selMorePrims = (released || area) ? false : ds.getSelected().containsAll(selectionList);\n\n        if (ctrl) {\n            // Ctrl on an item toggles its selection status,\n            // but Ctrl on an *area* just clears those items\n            // out of the selection.\n            if (area) {\n                ds.clearSelection(selectionList);\n            } else {\n                ds.toggleSelected(selectionList);\n            }\n        } else {\n            // plain clicks with no modifiers\n            if (!shift) {\n                ds.setSelected(selectionList);\n            } else {\n                // add things to an\n                // existing selection.\n                ds.addSelected(selectionList);\n            }\n        }\n    }","commit_id":"299dd3f4448538a7bf43cd93dbd8c66df6f7f91c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override public void mousePressed(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n        // request focus in order to enable the expected keyboard shortcuts\n        //\n        Main.map.mapView.requestFocus();\n\n        cancelDrawMode = false;\n        if (! (Boolean)this.getValue(\"active\")) return;\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean alt = (e.getModifiers() & (ActionEvent.ALT_MASK|InputEvent.ALT_GRAPH_MASK)) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        if(shift || ctrl) {\n            cancelDrawMode = true;\n        }\n\n        mouseDownTime = System.currentTimeMillis();\n        didMove = false;\n        initialMoveThresholdExceeded = false;\n\n        Collection<OsmPrimitive> osmColl = getNearestCollectionVirtual(e.getPoint(), alt);\n\n        if (ctrl && shift) {\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                selectPrims(osmColl, true, false, false, false);\n            }\n            mode = Mode.rotate;\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n        } else if (!osmColl.isEmpty()) {\n            // Don't replace the selection now if the user clicked on a\n            // selected object (this would break moving of selected groups).\n            // We'll do that later in mouseReleased if the user didn't try to\n            // move.\n            selectPrims(osmColl,\n                    shift || getCurrentDataSet().getSelected().containsAll(osmColl),\n                    ctrl, false, false);\n            mode = Mode.move;\n        } else {\n            mode = Mode.select;\n            oldCursor = Main.map.mapView.getCursor();\n            selectionManager.register(Main.map.mapView);\n            selectionManager.mousePressed(e);\n        }\n        if(mode != Mode.move || shift || ctrl)\n        {\n            virtualNode = null;\n            virtualWays.clear();\n        }\n\n        updateStatusLine();\n        // Mode.select redraws when selectPrims is called\n        // Mode.move   redraws when mouseDragged is called\n        // Mode.rotate redraws here\n        if(mode == Mode.rotate) {\n            Main.map.mapView.repaint();\n        }\n\n        mousePos = e.getPoint();\n    }","id":11046,"modified_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override public void mousePressed(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        // request focus in order to enable the expected keyboard shortcuts\n        Main.map.mapView.requestFocus();\n\n        cancelDrawMode = false;\n        if (! (Boolean)this.getValue(\"active\")) return;\n        if (e.getButton() != MouseEvent.BUTTON1)\n            return;\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        if(shift || ctrl) {\n            cancelDrawMode = true;\n        }\n\n        mouseDownTime = System.currentTimeMillis();\n        didMove = false;\n        initialMoveThresholdExceeded = false;\n\n        Collection<OsmPrimitive> osmColl = getNearestCollectionVirtual(e.getPoint());\n\n        if (ctrl && shift) {\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                selectPrims(osmColl, true, false, false, false);\n            }\n            mode = Mode.rotate;\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n        } else if (!osmColl.isEmpty()) {\n            // Don't replace the selection now if the user clicked on a\n            // selected object (this would break moving of selected groups).\n            // We'll do that later in mouseReleased if the user didn't try to\n            // move.\n            selectPrims(osmColl,\n                    shift || getCurrentDataSet().getSelected().containsAll(osmColl),\n                    ctrl, false, false);\n            mode = Mode.move;\n        } else {\n            mode = Mode.select;\n            oldCursor = Main.map.mapView.getCursor();\n            selectionManager.register(Main.map.mapView);\n            selectionManager.mousePressed(e);\n        }\n\n        if(mode != Mode.move || shift || ctrl) {\n            virtualNode = null;\n            virtualWays.clear();\n        }\n\n        updateStatusLine();\n        // Mode.select redraws when selectPrims is called\n        // Mode.move   redraws when mouseDragged is called\n        // Mode.rotate redraws here\n        if(mode == Mode.rotate) {\n            Main.map.mapView.repaint();\n        }\n\n        mousePos = e.getPoint();\n    }","commit_id":"299dd3f4448538a7bf43cd93dbd8c66df6f7f91c","url":"https://github.com/openstreetmap/josm"},{"original_method":"private Collection<OsmPrimitive> getNearestCollectionVirtual(Point p, boolean allSegements) {\n        MapView c = Main.map.mapView;\n        int snapDistance = Main.pref.getInteger(\"mappaint.node.virtual-snap-distance\", 8);\n        snapDistance *= snapDistance;\n        OsmPrimitive osm = c.getNearestNode(p, OsmPrimitive.isSelectablePredicate);\n        virtualWays.clear();\n        virtualNode = null;\n        Node virtualWayNode = null;\n\n        if (osm == null)\n        {\n            Collection<WaySegment> nearestWaySegs = allSegements\n            ? c.getNearestWaySegments(p, OsmPrimitive.isSelectablePredicate)\n                    : Collections.singleton(c.getNearestWaySegment(p, OsmPrimitive.isSelectablePredicate));\n\n            for(WaySegment nearestWS : nearestWaySegs) {\n                if (nearestWS == null) {\n                    continue;\n                }\n\n                osm = nearestWS.way;\n                if(Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) > 0)\n                {\n                    Way w = (Way)osm;\n                    Point p1 = c.getPoint(w.getNode(nearestWS.lowerIndex));\n                    Point p2 = c.getPoint(w.getNode(nearestWS.lowerIndex+1));\n                    if(SimplePaintVisitor.isLargeSegment(p1, p2, Main.pref.getInteger(\"mappaint.node.virtual-space\", 70)))\n                    {\n                        Point pc = new Point((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n                        if (p.distanceSq(pc) < snapDistance)\n                        {\n                            // Check that only segments on top of each other get added to the\n                            // virtual ways list. Otherwise ways that coincidentally have their\n                            // virtual node at the same spot will be joined which is likely unwanted\n                            if(virtualWayNode != null) {\n                                if(  !w.getNode(nearestWS.lowerIndex+1).equals(virtualWayNode)\n                                        && !w.getNode(nearestWS.lowerIndex).equals(virtualWayNode)) {\n                                    continue;\n                                }\n                            } else {\n                                virtualWayNode = w.getNode(nearestWS.lowerIndex+1);\n                            }\n\n                            virtualWays.add(nearestWS);\n                            if(virtualNode == null) {\n                                virtualNode = new Node(Main.map.mapView.getLatLon(pc.x, pc.y));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (osm == null)\n            return Collections.emptySet();\n        return Collections.singleton(osm);\n    }","id":11047,"modified_method":"private Collection<OsmPrimitive> getNearestCollectionVirtual(Point p) {\n        int snapDistance = Main.pref.getInteger(\"mappaint.node.virtual-snap-distance\", 8);\n        int virtualSpace = Main.pref.getInteger(\"mappaint.node.virtual-space\", 70);\n        snapDistance *= snapDistance;\n\n        MapView c = Main.map.mapView;\n\n        Collection<OsmPrimitive> sel = getCurrentDataSet().getSelected();\n        OsmPrimitive osm = c.getNearestNode(p, OsmPrimitive.isSelectablePredicate);\n\n        if (osm != null) {\n            for (Node n : c.getNearestNodes(p, OsmPrimitive.isSelectablePredicate)) {\n                if (sel.contains(n)) {\n                    osm = n;\n                }\n            }\n        } else {\n            Node virtualWayNode = null;\n            Way w = null;\n\n            Collection<WaySegment> virtualWaysInSel = new ArrayList<WaySegment>();\n            osm = c.getNearestWay(p, OsmPrimitive.isSelectablePredicate);\n\n            for(WaySegment nearestWS : c.getNearestWaySegments(p, OsmPrimitive.isSelectablePredicate)) {\n                if (nearestWS == null) {\n                    continue;\n                }\n                if (sel.contains(w = nearestWS.way)) {\n                    osm = w;\n                }\n\n                if (Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) > 0) {\n                    Point p1 = c.getPoint(w.getNode(nearestWS.lowerIndex));\n                    Point p2 = c.getPoint(w.getNode(nearestWS.lowerIndex+1));\n                    if(SimplePaintVisitor.isLargeSegment(p1, p2, virtualSpace))\n                    {\n                        Point pc = new Point((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n                        if (p.distanceSq(pc) < snapDistance)\n                        {\n                            // Check that only segments on top of each other get added to the\n                            // virtual ways list. Otherwise ways that coincidentally have their\n                            // virtual node at the same spot will be joined which is likely unwanted\n                            if(virtualWayNode != null) {\n                                if(!w.getNode(nearestWS.lowerIndex+1).equals(virtualWayNode)\n                                        && !w.getNode(nearestWS.lowerIndex).equals(virtualWayNode)) {\n                                    continue;\n                                }\n                            } else {\n                                virtualWayNode = w.getNode(nearestWS.lowerIndex+1);\n                            }\n\n                            (!sel.contains(w) ? virtualWays : virtualWaysInSel).add(nearestWS);\n                            if(virtualNode == null) {\n                                virtualNode = new Node(Main.map.mapView.getLatLon(pc.x, pc.y));\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (virtualNode != null) {\n                virtualWays = virtualWaysInSel.isEmpty() ? virtualWays : virtualWaysInSel;\n                osm = virtualWays.iterator().next().way;\n            }\n        }\n\n        if (osm == null)\n            return Collections.emptySet();\n        return Collections.singleton(osm);\n    }","commit_id":"299dd3f4448538a7bf43cd93dbd8c66df6f7f91c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Restore the old mouse cursor.\n     */\n    @Override public void mouseReleased(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        if (mode == Mode.select) {\n            selectionManager.unregister(Main.map.mapView);\n\n            // Select Draw Tool if no selection has been made\n            if(getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n        restoreCursor();\n\n        if (mode == Mode.move) {\n            boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n            boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n            if (!didMove) {\n                selectPrims(\n                        Main.map.mapView.getNearestCollection(e.getPoint(), OsmPrimitive.isSelectablePredicate),\n                        shift, ctrl, true, false);\n\n                // If the user double-clicked a node, change to draw mode\n                List<OsmPrimitive> sel = new ArrayList<OsmPrimitive>(getCurrentDataSet().getSelected());\n                if(e.getClickCount() >=2 && sel.size() == 1 && sel.get(0) instanceof Node) {\n                    // We need to do it like this as otherwise drawAction will see a double\n                    // click and switch back to SelectMode\n                    Main.worker.execute(new Runnable(){\n                        public void run() {\n                            Main.map.selectDrawTool(true);\n                        }\n                    });\n                    return;\n                }\n            } else {\n                Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n                Collection<OsmPrimitive> s = new TreeSet<OsmPrimitive>();\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20);\n                for (OsmPrimitive osm : selection)\n                {\n                    if(osm instanceof Node) {\n                        s.add(osm);\n                    } else if(osm instanceof Way)\n                    {\n                        s.add(osm);\n                        s.addAll(((Way)osm).getNodes());\n                    }\n                    if(s.size() > max)\n                    {\n                        ExtendedDialog ed = new ExtendedDialog(\n                                Main.parent,\n                                tr(\"Move elements\"),\n                                new String[] {tr(\"Move them\"), tr(\"Undo move\")});\n                        ed.setButtonIcons(new String[] {\"reorder.png\", \"cancel.png\"});\n                        ed.setContent(tr(\"You moved more than {0} elements. \"\n                                + \"Moving a large number of elements is often an error.\\n\"\n                                + \"Really move them?\", max));\n                        ed.setCancelButton(2);\n                        ed.toggleEnable(\"movedManyElements\");\n                        ed.showDialog();\n\n                        if(ed.getValue() != 1)\n                        {\n                            Main.main.undoRedo.undo();\n                        }\n                        break;\n                    }\n                }\n                if (ctrl) {\n                    Collection<Node> affectedNodes = OsmPrimitive.getFilteredSet(selection, Node.class);\n                    Collection<Node> nn = Main.map.mapView.getNearestNodes(e.getPoint(), affectedNodes, OsmPrimitive.isSelectablePredicate);\n                    if (nn != null) {\n                        Node targetNode = nn.iterator().next();\n                        Set<Node> nodesToMerge = new HashSet<Node>(affectedNodes);\n                        nodesToMerge.add(targetNode);\n                        if (!nodesToMerge.isEmpty()) {\n                            Command cmd = MergeNodesAction.mergeNodes(Main.main.getEditLayer(),nodesToMerge, targetNode);\n                            if(cmd != null) {\n                                Main.main.undoRedo.add(cmd);\n                            }\n                        }\n                    }\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","id":11048,"modified_method":"/**\n     * Restore the old mouse cursor.\n     */\n    @Override public void mouseReleased(MouseEvent e) {\n        if(!Main.map.mapView.isActiveLayerVisible())\n            return;\n\n        if (mode == Mode.select) {\n            selectionManager.unregister(Main.map.mapView);\n\n            // Select Draw Tool if no selection has been made\n            if(getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n        restoreCursor();\n\n        if (mode == Mode.move) {\n            boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n            boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n            boolean alt = (e.getModifiers() & (ActionEvent.ALT_MASK|InputEvent.ALT_GRAPH_MASK)) != 0\n                            || Main.pref.getBoolean(\"selectaction.rotates\", false);\n\n            virtualWays.clear();\n            virtualNode = null;\n\n            if (!didMove) {\n                Collection<OsmPrimitive> c = Main.map.mapView.getNearestCollection(e.getPoint(), OsmPrimitive.isSelectablePredicate);\n                if (!c.isEmpty() && alt) {\n                    if (c.iterator().next() instanceof Node) {\n                        // there is at least one node under the cursor:\n                        //   - make sure (first element of new list) equals (result of getNearestCollection)\n                        //   - do not consider ways at all, but all nearest nodes\n                        c = new ArrayList<OsmPrimitive>(Main.map.mapView.getNearestNodes(e.getPoint(), OsmPrimitive.isSelectablePredicate));\n                    } else {\n                        // consider all ways..\n                        c = Main.map.mapView.getAllNearest(e.getPoint(), OsmPrimitive.isSelectablePredicate);\n                    }\n                }\n                selectPrims(c, shift, ctrl, true, false);\n\n                // If the user double-clicked a node, change to draw mode\n                c = getCurrentDataSet().getSelected();\n                if(e.getClickCount() >=2 && c.size() == 1 && c.iterator().next() instanceof Node) {\n                    // We need to do it like this as otherwise drawAction will see a double\n                    // click and switch back to SelectMode\n                    Main.worker.execute(new Runnable(){\n                        public void run() {\n                            Main.map.selectDrawTool(true);\n                        }\n                    });\n                    return;\n                }\n            } else {\n                Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n                Collection<OsmPrimitive> s = new TreeSet<OsmPrimitive>();\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20);\n                for (OsmPrimitive osm : selection)\n                {\n                    if(osm instanceof Node) {\n                        s.add(osm);\n                    } else if(osm instanceof Way)\n                    {\n                        s.add(osm);\n                        s.addAll(((Way)osm).getNodes());\n                    }\n                    if(s.size() > max)\n                    {\n                        ExtendedDialog ed = new ExtendedDialog(\n                                Main.parent,\n                                tr(\"Move elements\"),\n                                new String[] {tr(\"Move them\"), tr(\"Undo move\")});\n                        ed.setButtonIcons(new String[] {\"reorder.png\", \"cancel.png\"});\n                        ed.setContent(tr(\"You moved more than {0} elements. \"\n                                + \"Moving a large number of elements is often an error.\\n\"\n                                + \"Really move them?\", max));\n                        ed.setCancelButton(2);\n                        ed.toggleEnable(\"movedManyElements\");\n                        ed.showDialog();\n\n                        if(ed.getValue() != 1)\n                        {\n                            Main.main.undoRedo.undo();\n                        }\n                        break;\n                    }\n                }\n                if (ctrl) {\n                    Collection<Node> affectedNodes = OsmPrimitive.getFilteredSet(selection, Node.class);\n                    Collection<Node> nn = Main.map.mapView.getNearestNodes(e.getPoint(), affectedNodes, OsmPrimitive.isSelectablePredicate);\n                    if (nn != null) {\n                        Node targetNode = nn.iterator().next();\n                        Set<Node> nodesToMerge = new HashSet<Node>(affectedNodes);\n                        nodesToMerge.add(targetNode);\n                        if (!nodesToMerge.isEmpty()) {\n                            Command cmd = MergeNodesAction.mergeNodes(Main.main.getEditLayer(),nodesToMerge, targetNode);\n                            if(cmd != null) {\n                                Main.main.undoRedo.add(cmd);\n                            }\n                        }\n                    }\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","commit_id":"299dd3f4448538a7bf43cd93dbd8c66df6f7f91c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t* {@inheritDoc}\n     \t*\n     \t* <P>\n     \t* Initialize the service monitor.\n     \t* <\/P>\n     \t* @exception RuntimeException\n     \t*                Thrown if an unrecoverable error occurs that prevents the\n     \t*                plug-in from functioning.\n     \t*/\n    \tpublic void initialize(Map<String, Object> parameters) \n\t{\n\t\ttry\n\t\t{\n\t\t\tAmiPeerFactory.init();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlog().fatal(\"Initalize: Failed to load AMI configuration\", e);\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t\treturn;\n\t}","id":11049,"modified_method":"/**\n\t  * {@inheritDoc}\n\t  *\n\t  * <P>\n\t  * Initialize the service monitor.\n\t  * <\/P>\n\t  * @exception RuntimeException\n\t  *\t\tThrown if an unrecoverable error occurs that prevents the\n\t  *\t\tplug-in from functioning.\n\t  */\n\tpublic void initialize(Map<String, Object> parameters) \n\t{\n\t\ttry\n\t\t{\n\t\t\tAmiPeerFactory.init();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tLOG.error(\"Initalize: Failed to load AMI configuration\", e);\n\t\t\tthrow new UndeclaredThrowableException(e);\n\t\t}\n\t\treturn;\n\t}","commit_id":"2f14074109b7e56cf56ea3e565981048ac746cdc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n        * {@inheritDoc}\n        *\n        * <P>\n        * Run the service monitor and return the poll status\n        * <\/P>\n        */\n\tpublic PollStatus poll(MonitoredService svc, Map<String, Object> parameters)\n\t{\n\t\t//check, if interface type is supported\n\t\tfinal NetworkInterface<InetAddress> iface = svc.getNetInterface();\n        \tif (iface.getType() != NetworkInterface.TYPE_INET) \n\t\t{\n            \t\tthrow new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_INET currently supported\");\n        \t}\n\n\t\t//read configuration parameters\n\t\tString sipPeer = ParameterMap.getKeyedString(parameters, \"sip-peer\", DEFAULT_SIPPEER);\n\t\tif(sipPeer.equals(DEFAULT_SIPPEER))\n\t\t{\n\t\t\tlog().fatal(\"AsteriskMonitor: No sip-peer parameter in poller configuration\");\n\t\t\tthrow new RuntimeException(\"AsteriskMonitor: required parameter 'sip-peer' is not present in supplied properties.\");\n\n\t\t}\n\t\tTimeoutTracker timeoutTracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\t\tAmiPeerFactory amiPeerFactory = AmiPeerFactory.getInstance();\n\t\tAmiAgentConfig amiConfig = amiPeerFactory.getAgentConfig(svc.getAddress());\n\n\t\t//setting up AMI connection\t\n\t\tlog().debug(svc.getSvcName() + \": Creating new AMI-Connection: \" + svc.getIpAddr() + \":\" + amiConfig.getPort() + \", \" + amiConfig.getUsername() + \"/\" + amiConfig.getPassword());\n\t\tManagerConnectionFactory factory = new ManagerConnectionFactory(svc.getIpAddr(), amiConfig.getPort(), amiConfig.getUsername(), amiConfig.getPassword());\n\t\tManagerConnection managerConnection;\n\t\tif(amiConfig.getUseTls())\n\t\t{\n                \tmanagerConnection = factory.createSecureManagerConnection();\n\t\t}\n\t\telse\n\t\t{\n                \tmanagerConnection = factory.createManagerConnection();\n\t\t}\n\t\tmanagerConnection.setSocketTimeout(new Long(timeoutTracker.getTimeoutInMillis()).intValue());\n\n\t\t//start with polling\n\t\twhile(timeoutTracker.shouldRetry())\n\t\t{\n\t\t\ttimeoutTracker.nextAttempt();\n\t\t\tlog().debug(svc.getSvcName() + \": Attempt \" + timeoutTracker.getAttempt());\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlog().debug(svc.getSvcName() + \": AMI login\");\n\t                \tmanagerConnection.login();\n\n\t\t\t\tlog().debug(svc.getSvcName() + \": AMI sendAction SipShowPeer\");\n                \t\tManagerResponse response = managerConnection.sendAction(new SipShowPeerAction(sipPeer));\n\t\t\t\tif(response.getAttribute(\"Status\") == null)\n\t\t\t\t{\n\t\t\t\t\tlog().debug(svc.getSvcName() + \": service status down\");\n\t\t\t\t\treturn PollStatus.decode(\"Down\", \"State of SIP Peer is unknown, because it was not found on the Asterisk server\");\n\n\t\t\t\t}\n\t\t\t\tlog().debug(svc.getSvcName() + \": Response: \" + response.getAttribute(\"Status\"));\n\n\t\t\t\tlog().debug(svc.getSvcName() + \": AMI logoff\");\n\t               \t\tmanagerConnection.logoff();\n\n                \t\tif (response.getAttribute(\"Status\").startsWith(\"OK\"))\n                \t\t{\n\t\t\t\t\tlog().debug(svc.getSvcName() + \": service status up\");\n\t\t\t\t\treturn PollStatus.decode(\"Up\", \"OK\");\n\t                \t}\n        \t        \telse\n                \t\t{\n\t\t\t\t\tlog().debug(svc.getSvcName() + \": service status down\");\n\t\t\t\t\treturn PollStatus.decode(\"Down\", \"State of SIP Peer is \" + response.getAttribute(\"Status\") + \" and not OK\");\n\t                \t}\n\t\t\t}\n\t\t\tcatch(AuthenticationFailedException e)\n\t\t\t{\n\t\t\t\tlog().error(svc.getSvcName() + \": AMI AuthenticationError: \" + e.toString());\n\t\t\t\treturn PollStatus.decode(\"Down\", \"Could not get the state of SIP Peer: AMI AuthenticationError\");\n\t\t\t}\n\t\t\tcatch(TimeoutException e)\n\t\t\t{\n\t\t\t\tlog().debug(svc.getSvcName() + \": TimeOut reached: \" + e.toString());\n\t\t\t}\n\n\t\t\tcatch(SocketTimeoutException e)\n\t\t\t{\n\t\t\t\tlog().debug(svc.getSvcName() + \": TimeOut reached: \" + e.toString());\n\t\t\t}\n\n\t\t\tcatch(Exception e)\n\t\t\t{\t\n\t\t\t\tlog().error(svc.getSvcName() + \": Exception: \" + e.toString());\n\t\t\t\treturn PollStatus.decode(\"Down\", \"Could not get the state of SIP Peer: \" + e.toString());\n\t\t\t}\n\t\t}\n\t\t//If none of the retries worked\n\t\treturn PollStatus.decode(\"Down\", \"Could not get the state of SIP Peer: Timeout exceeded\");\n\t}","id":11050,"modified_method":"/**\n\t  * {@inheritDoc}\n\t  *\n\t  * <P>\n\t  * Run the service monitor and return the poll status\n\t  * <\/P>\n\t  */\n\tpublic PollStatus poll(MonitoredService svc, Map<String, Object> parameters)\n\t{\n\t\t//check, if interface type is supported\n\t\tfinal NetworkInterface<InetAddress> iface = svc.getNetInterface();\n\t\tif (iface.getType() != NetworkInterface.TYPE_INET) \n\t\t{\n\t    \t\tthrow new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_INET currently supported\");\n\t\t}\n\n\t\t//read configuration parameters\n\t\tString sipPeer = ParameterMap.getKeyedString(parameters, \"sip-peer\", DEFAULT_SIPPEER);\n\t\tif(sipPeer.equals(DEFAULT_SIPPEER))\n\t\t{\n\t\t\tLOG.error(\"AsteriskMonitor: No sip-peer parameter in poller configuration\");\n\t\t\tthrow new RuntimeException(\"AsteriskMonitor: required parameter 'sip-peer' is not present in supplied properties.\");\n\n\t\t}\n\t\tTimeoutTracker timeoutTracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\t\tAmiPeerFactory amiPeerFactory = AmiPeerFactory.getInstance();\n\t\tAmiAgentConfig amiConfig = amiPeerFactory.getAgentConfig(svc.getAddress());\n\n\t\t//setting up AMI connection\t\n\t\tLOG.debug(\"{}: Creating new AMI-Connection: {}:{}, {}/{}\", svc.getSvcName(), svc.getIpAddr(), amiConfig.getPort(), amiConfig.getUsername(), amiConfig.getPassword());\n\t\tManagerConnectionFactory factory = new ManagerConnectionFactory(svc.getIpAddr(), amiConfig.getPort(), amiConfig.getUsername(), amiConfig.getPassword());\n\t\tManagerConnection managerConnection;\n\t\tif(amiConfig.getUseTls())\n\t\t{\n\t\t\tmanagerConnection = factory.createSecureManagerConnection();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmanagerConnection = factory.createManagerConnection();\n\t\t}\n\t\tmanagerConnection.setSocketTimeout(new Long(timeoutTracker.getTimeoutInMillis()).intValue());\n\n\t\t//start with polling\n\t\twhile(timeoutTracker.shouldRetry())\n\t\t{\n\t\t\ttimeoutTracker.nextAttempt();\n\t\t\tLOG.debug(\"{}: Attempt {}\", svc.getSvcName(), timeoutTracker.getAttempt());\n\t\t\ttry\n\t\t\t{\n\t\t\t\tLOG.debug(\"{}: AMI login\", svc.getSvcName());\n\t\t\t\tmanagerConnection.login();\n\n\t\t\t\tLOG.debug(\"{}: AMI sendAction SipShowPeer\", svc.getSvcName());\n\t\t\t\tManagerResponse response = managerConnection.sendAction(new SipShowPeerAction(sipPeer));\n\t\t\t\tif(response.getAttribute(\"Status\") == null)\n\t\t\t\t{\n\t\t\t\t\tLOG.debug(\"{}: service status down\", svc.getSvcName());\n\t\t\t\t\treturn PollStatus.decode(\"Down\", \"State of SIP Peer is unknown, because it was not found on the Asterisk server\");\n\n\t\t\t\t}\n\t\t\t\tLOG.debug(\"{}: Response: {}\", svc.getSvcName(), response.getAttribute(\"Status\"));\n\n\t\t\t\tLOG.debug(\"{}: AMI logoff\", svc.getSvcName());\n\t\t\t\tmanagerConnection.logoff();\n\n\t\t\t\tif (response.getAttribute(\"Status\").startsWith(\"OK\"))\n\t\t\t\t{\n\t\t\t\t\tLOG.debug(\"{}: service status up\", svc.getSvcName());\n\t\t\t\t\treturn PollStatus.decode(\"Up\", \"OK\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLOG.debug(\"{}: service status down\", svc.getSvcName());\n\t\t\t\t\treturn PollStatus.decode(\"Down\", \"State of SIP Peer is \" + response.getAttribute(\"Status\") + \" and not OK\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(AuthenticationFailedException e)\n\t\t\t{\n\t\t\t\tLOG.debug(\"{}: AMI AuthenticationError.\", svc.getSvcName(), e);\n\t\t\t\treturn PollStatus.decode(\"Down\", \"Could not get the state of SIP Peer: AMI AuthenticationError\");\n\t\t\t}\n\t\t\tcatch(TimeoutException e)\n\t\t\t{\n\t\t\t\tLOG.debug(\"{}: TimeOut reached.\", svc.getSvcName(), e);\n\t\t\t}\n\t\t\tcatch(SocketTimeoutException e)\n\t\t\t{\n\t\t\t\tLOG.debug(\"{}: TimeOut reached.\", svc.getSvcName(), e);\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\t\n\t\t\t\tLOG.error(\"{}: An Unknown Exception Occurred.\", svc.getSvcName(), e);\n\t\t\t\treturn PollStatus.decode(\"Down\", \"Could not get the state of SIP Peer: \" + e.toString());\n\t\t\t}\n\t\t}\n\t\t//If none of the retries worked\n\t\treturn PollStatus.decode(\"Down\", \"Could not get the state of SIP Peer: Timeout exceeded\");\n\t}","commit_id":"2f14074109b7e56cf56ea3e565981048ac746cdc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Gets a SoapMessage, but with the needed SecurityConstants in the context properties\n     * so that it can be passed to PolicyBasedWSS4JOutInterceptor.\n     *\n     * @see #getSoapMessageForDom(Document, AssertionInfoMap)\n     */\n    protected SoapMessage getOutSoapMessageForDom(Document doc, AssertionInfoMap aim)\n        throws SOAPException {\n        SoapMessage msg = this.getSoapMessageForDom(doc, aim);\n        msg.put(SecurityConstants.SIGNATURE_PROPERTIES, \"outsecurity.properties\");\n        msg.put(SecurityConstants.ENCRYPT_PROPERTIES, \"outsecurity.properties\");\n        msg.put(SecurityConstants.CALLBACK_HANDLER, TestPwdCallback.class.getName());\n        msg.put(SecurityConstants.SIGNATURE_USERNAME, \"myalias\");\n        msg.put(SecurityConstants.ENCRYPT_USERNAME, \"myalias\");\n        \n        msg.getExchange().put(Endpoint.class, new MockEndpoint());\n        msg.getExchange().put(Bus.class, this.bus);\n        msg.put(Message.REQUESTOR_ROLE, true);\n        \n        return msg;\n    }","id":11051,"modified_method":"/**\n     * Gets a SoapMessage, but with the needed SecurityConstants in the context properties\n     * so that it can be passed to PolicyBasedWSS4JOutInterceptor.\n     *\n     * @see #getSoapMessageForDom(Document, AssertionInfoMap)\n     */\n    protected SoapMessage getOutSoapMessageForDom(Document doc, AssertionInfoMap aim)\n        throws SOAPException {\n        SoapMessage msg = this.getSoapMessageForDom(doc, aim);\n        msg.put(SecurityConstants.SIGNATURE_PROPERTIES, \"outsecurity.properties\");\n        msg.put(SecurityConstants.ENCRYPT_PROPERTIES, \"outsecurity.properties\");\n        msg.put(SecurityConstants.CALLBACK_HANDLER, new TestPwdCallback());\n        msg.put(SecurityConstants.SIGNATURE_USERNAME, \"myalias\");\n        msg.put(SecurityConstants.ENCRYPT_USERNAME, \"myalias\");\n        \n        msg.getExchange().put(Endpoint.class, new MockEndpoint());\n        msg.getExchange().put(Bus.class, this.bus);\n        msg.put(Message.REQUESTOR_ROLE, true);\n        \n        return msg;\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Creates a {@link SoapMessage} from the contents of a document.\n     * @param doc the document containing the SOAP content.\n     */\n    protected SoapMessage getSoapMessageForDom(Document doc) throws SOAPException {\n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        // Hack to create the context map\n        MessageImpl message = new MessageImpl();\n        message.getContextualProperty(\"XYZ\");\n        \n        SoapMessage msg = new SoapMessage(message);\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        msg.setContent(SOAPMessage.class, saajMsg);\n        return msg;\n    }","id":11052,"modified_method":"/**\n     * Creates a {@link SoapMessage} from the contents of a document.\n     * @param doc the document containing the SOAP content.\n     */\n    protected SoapMessage getSoapMessageForDom(Document doc) throws SOAPException {\n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        MessageImpl message = new MessageImpl();\n        SoapMessage msg = new SoapMessage(message);\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        msg.setContent(SOAPMessage.class, saajMsg);\n        \n        return msg;\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSaml1SignedSenderVouches() throws Exception {\n        // Create + configure service\n        Service service = createService();\n        \n        WSSSecurityProperties inProperties = new WSSSecurityProperties();\n        Properties cryptoProperties = \n            CryptoFactory.getProperties(\"insecurity.properties\", this.getClass().getClassLoader());\n        inProperties.setSignatureVerificationCryptoProperties(cryptoProperties);\n        WSS4JStaxInInterceptor inhandler = new WSS4JStaxInInterceptor(inProperties);\n        service.getInInterceptors().add(inhandler);\n        \n        // Create + configure client\n        Echo echo = createClientProxy();\n        \n        Client client = ClientProxy.getClient(echo);\n        client.getInInterceptors().add(new LoggingInInterceptor());\n        client.getOutInterceptors().add(new LoggingOutInterceptor());\n        \n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        properties.put(\n            WSHandlerConstants.SAML_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.saml.SAML1CallbackHandler\"\n        );\n        properties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        properties.put(WSHandlerConstants.USER, \"alice\");\n        properties.put(WSHandlerConstants.PW_CALLBACK_REF, new PasswordCallbackHandler());\n        properties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor(properties);\n        client.getOutInterceptors().add(ohandler);\n\n        assertEquals(\"test\", echo.echo(\"test\"));\n    }","id":11053,"modified_method":"@Test\n    public void testSaml1SignedSenderVouches() throws Exception {\n        // Create + configure service\n        Service service = createService();\n        \n        WSSSecurityProperties inProperties = new WSSSecurityProperties();\n        Properties cryptoProperties = \n            CryptoFactory.getProperties(\"insecurity.properties\", this.getClass().getClassLoader());\n        inProperties.setSignatureVerificationCryptoProperties(cryptoProperties);\n        WSS4JStaxInInterceptor inhandler = new WSS4JStaxInInterceptor(inProperties);\n        service.getInInterceptors().add(inhandler);\n        \n        // Create + configure client\n        Echo echo = createClientProxy();\n        \n        Client client = ClientProxy.getClient(echo);\n        client.getInInterceptors().add(new LoggingInInterceptor());\n        client.getOutInterceptors().add(new LoggingOutInterceptor());\n        \n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        properties.put(WSHandlerConstants.SAML_CALLBACK_REF, new SAML1CallbackHandler());\n\n        properties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        properties.put(WSHandlerConstants.USER, \"alice\");\n        properties.put(WSHandlerConstants.PW_CALLBACK_REF, new PasswordCallbackHandler());\n        properties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor(properties);\n        client.getOutInterceptors().add(ohandler);\n\n        assertEquals(\"test\", echo.echo(\"test\"));\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSaml2SignedSenderVouches() throws Exception {\n        // Create + configure service\n        Service service = createService();\n        \n        WSSSecurityProperties inProperties = new WSSSecurityProperties();\n        Properties cryptoProperties = \n            CryptoFactory.getProperties(\"insecurity.properties\", this.getClass().getClassLoader());\n        inProperties.setSignatureVerificationCryptoProperties(cryptoProperties);\n        WSS4JStaxInInterceptor inhandler = new WSS4JStaxInInterceptor(inProperties);\n        service.getInInterceptors().add(inhandler);\n        \n        // Create + configure client\n        Echo echo = createClientProxy();\n        \n        Client client = ClientProxy.getClient(echo);\n        client.getInInterceptors().add(new LoggingInInterceptor());\n        client.getOutInterceptors().add(new LoggingOutInterceptor());\n        \n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        properties.put(\n            WSHandlerConstants.SAML_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.saml.SAML2CallbackHandler\"\n        );\n        properties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        properties.put(WSHandlerConstants.USER, \"alice\");\n        properties.put(WSHandlerConstants.PW_CALLBACK_REF, new PasswordCallbackHandler());\n        properties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor(properties);\n        client.getOutInterceptors().add(ohandler);\n\n        assertEquals(\"test\", echo.echo(\"test\"));\n    }","id":11054,"modified_method":"@Test\n    public void testSaml2SignedSenderVouches() throws Exception {\n        // Create + configure service\n        Service service = createService();\n        \n        WSSSecurityProperties inProperties = new WSSSecurityProperties();\n        Properties cryptoProperties = \n            CryptoFactory.getProperties(\"insecurity.properties\", this.getClass().getClassLoader());\n        inProperties.setSignatureVerificationCryptoProperties(cryptoProperties);\n        WSS4JStaxInInterceptor inhandler = new WSS4JStaxInInterceptor(inProperties);\n        service.getInInterceptors().add(inhandler);\n        \n        // Create + configure client\n        Echo echo = createClientProxy();\n        \n        Client client = ClientProxy.getClient(echo);\n        client.getInInterceptors().add(new LoggingInInterceptor());\n        client.getOutInterceptors().add(new LoggingOutInterceptor());\n        \n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        properties.put(WSHandlerConstants.SAML_CALLBACK_REF, new SAML2CallbackHandler());\n\n        properties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        properties.put(WSHandlerConstants.USER, \"alice\");\n        properties.put(WSHandlerConstants.PW_CALLBACK_REF, new PasswordCallbackHandler());\n        properties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor(properties);\n        client.getOutInterceptors().add(ohandler);\n\n        assertEquals(\"test\", echo.echo(\"test\"));\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This test creates a SAML2 Assertion and sends it in the security header to the provider.\n     */\n    @Test\n    public void testSaml2Token() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        outProperties.put(\n            WSHandlerConstants.SAML_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.saml.SAML2CallbackHandler\"\n        );\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        validator.setRequireSAML1Assertion(false);\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml2:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        inMessageProperties.put(SecurityConstants.VALIDATE_SAML_SUBJECT_CONFIRMATION, \"false\");\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml2() != null);\n        assert !receivedAssertion.isSigned();\n    }","id":11055,"modified_method":"/**\n     * This test creates a SAML2 Assertion and sends it in the security header to the provider.\n     */\n    @Test\n    public void testSaml2Token() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        outProperties.put(WSHandlerConstants.SAML_CALLBACK_REF, new SAML2CallbackHandler());\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        validator.setRequireSAML1Assertion(false);\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml2:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        inMessageProperties.put(SecurityConstants.VALIDATE_SAML_SUBJECT_CONFIRMATION, \"false\");\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml2() != null);\n        assert !receivedAssertion.isSigned();\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"private SecurityContext testSaml1Token(boolean allowUnsignedPrincipal) throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        outProperties.put(\n            WSHandlerConstants.SAML_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.saml.SAML1CallbackHandler\"\n        );\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml1:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        if (allowUnsignedPrincipal) {\n            inMessageProperties.put(SecurityConstants.ENABLE_UNSIGNED_SAML_ASSERTION_PRINCIPAL, \"true\");\n        }\n\n        inMessageProperties.put(SecurityConstants.VALIDATE_SAML_SUBJECT_CONFIRMATION, \"false\");\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml1() != null);\n        assert !receivedAssertion.isSigned();\n        \n        return message.get(SecurityContext.class);\n    }","id":11056,"modified_method":"private SecurityContext testSaml1Token(boolean allowUnsignedPrincipal) throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        outProperties.put(WSHandlerConstants.SAML_CALLBACK_REF, new SAML1CallbackHandler());\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_UNSIGNED);\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml1:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        if (allowUnsignedPrincipal) {\n            inMessageProperties.put(SecurityConstants.ENABLE_UNSIGNED_SAML_ASSERTION_PRINCIPAL, \"true\");\n        }\n\n        inMessageProperties.put(SecurityConstants.VALIDATE_SAML_SUBJECT_CONFIRMATION, \"false\");\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml1() != null);\n        assert !receivedAssertion.isSigned();\n        \n        return message.get(SecurityContext.class);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSaml2TokenSignedSenderVouches() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(\n            WSHandlerConstants.SAML_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.saml.SAML2CallbackHandler\"\n        );\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_UNSIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        validator.setRequireSAML1Assertion(false);\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml2:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        inMessageProperties.put(SecurityConstants.VALIDATE_SAML_SUBJECT_CONFIRMATION, \"false\");\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml2() != null);\n        assert !receivedAssertion.isSigned();\n    }","id":11057,"modified_method":"@Test\n    public void testSaml2TokenSignedSenderVouches() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(WSHandlerConstants.SAML_CALLBACK_REF, new SAML2CallbackHandler());\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_UNSIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        validator.setRequireSAML1Assertion(false);\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml2:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        inMessageProperties.put(SecurityConstants.VALIDATE_SAML_SUBJECT_CONFIRMATION, \"false\");\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml2() != null);\n        assert !receivedAssertion.isSigned();\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This test creates a holder-of-key SAML1 Assertion, and sends it in the security header \n     * to the provider.\n     */\n    @Test\n    public void testSaml1TokenHOK() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        SAML1CallbackHandler callbackHandler = new SAML1CallbackHandler();\n        callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);\n        callbackHandler.setSignAssertion(true);\n        outProperties.put(\n            WSHandlerConstants.SAML_CALLBACK_REF, callbackHandler\n        );\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_SIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml1:Assertion\");\n        \n        try {\n            makeInvocation(outProperties, xpaths, inProperties);\n            fail(\"Failure expected in SAML Validator\");\n        } catch (Fault ex) {\n            // expected\n        }\n        validator.setRequireSenderVouches(false);\n\n        Message message = makeInvocation(outProperties, xpaths, inProperties);\n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_SIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml1() != null);\n        assert receivedAssertion.isSigned();\n        \n        actionResult = handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n        assertTrue(actionResult != null);\n    }","id":11058,"modified_method":"/**\n     * This test creates a holder-of-key SAML1 Assertion, and sends it in the security header \n     * to the provider.\n     */\n    @Test\n    public void testSaml1TokenHOK() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        SAML1CallbackHandler callbackHandler = new SAML1CallbackHandler();\n        callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);\n        callbackHandler.setSignAssertion(true);\n        outProperties.put(WSHandlerConstants.SAML_CALLBACK_REF, callbackHandler);\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_SIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml1:Assertion\");\n        \n        try {\n            makeInvocation(outProperties, xpaths, inProperties, Collections.emptyMap());\n            fail(\"Failure expected in SAML Validator\");\n        } catch (Fault ex) {\n            // expected\n        }\n        validator.setRequireSenderVouches(false);\n\n        Message message = makeInvocation(outProperties, xpaths, inProperties, Collections.emptyMap());\n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_SIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml1() != null);\n        assert receivedAssertion.isSigned();\n        \n        actionResult = handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n        assertTrue(actionResult != null);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSaml1TokenSignedSenderVouches() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(\n            WSHandlerConstants.SAML_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.saml.SAML1CallbackHandler\"\n        );\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_UNSIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml1:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml1() != null);\n        assert !receivedAssertion.isSigned();\n    }","id":11059,"modified_method":"@Test\n    public void testSaml1TokenSignedSenderVouches() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(WSHandlerConstants.SAML_CALLBACK_REF, new SAML1CallbackHandler());\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_UNSIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml1:Assertion\");\n\n        Map<String, String> inMessageProperties = new HashMap<String, String>();\n        Message message = makeInvocation(outProperties, xpaths, inProperties, inMessageProperties);\n        \n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_UNSIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml1() != null);\n        assert !receivedAssertion.isSigned();\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"private SoapMessage makeInvocation(\n        Map<String, Object> outProperties,\n        List<String> xpaths,\n        Map<String, Object> inProperties,\n        Map<String, String> inMessageProperties\n    ) throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        for (String key : outProperties.keySet()) {\n            msg.put(key, outProperties.get(key));\n        }\n\n        handler.handleMessage(msg);\n\n        doc = part;\n\n        for (String xpath : xpaths) {\n            assertValid(xpath, doc);\n        }\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor(inProperties);\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        inmsg.put(SecurityConstants.SAML_ROLE_ATTRIBUTENAME, \"role\");\n        for (String inMessageProperty : inMessageProperties.keySet()) {\n            inmsg.put(inMessageProperty, inMessageProperties.get(inMessageProperty));\n        }\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.handleMessage(inmsg);\n\n        return inmsg;\n    }","id":11060,"modified_method":"private SoapMessage makeInvocation(\n        Map<String, Object> outProperties,\n        List<String> xpaths,\n        Map<String, Object> inProperties,\n        Map<String, String> inMessageProperties\n    ) throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        for (String key : outProperties.keySet()) {\n            msg.put(key, outProperties.get(key));\n        }\n\n        handler.handleMessage(msg);\n\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n\n        for (String xpath : xpaths) {\n            assertValid(xpath, doc);\n        }\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor(inProperties);\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        inmsg.put(SecurityConstants.SAML_ROLE_ATTRIBUTENAME, \"role\");\n        for (String inMessageProperty : inMessageProperties.keySet()) {\n            inmsg.put(inMessageProperty, inMessageProperties.get(inMessageProperty));\n        }\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.handleMessage(inmsg);\n\n        return inmsg;\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This test creates a holder-of-key SAML2 Assertion, and sends it in the security header \n     * to the provider.\n     */\n    @Test\n    public void testSaml2TokenHOK() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        SAML2CallbackHandler callbackHandler = new SAML2CallbackHandler();\n        callbackHandler.setConfirmationMethod(SAML2Constants.CONF_HOLDER_KEY);\n        callbackHandler.setSignAssertion(true);\n        outProperties.put(\n            WSHandlerConstants.SAML_CALLBACK_REF, callbackHandler\n        );\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_SIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml2:Assertion\");\n        \n        try {\n            makeInvocation(outProperties, xpaths, inProperties);\n            fail(\"Failure expected in SAML Validator\");\n        } catch (Fault ex) {\n            // expected\n        }\n        validator.setRequireSenderVouches(false);\n        \n        try {\n            makeInvocation(outProperties, xpaths, inProperties);\n            fail(\"Failure expected in SAML Validator\");\n        } catch (Fault ex) {\n            // expected\n        }\n        validator.setRequireSAML1Assertion(false);\n\n        Message message = makeInvocation(outProperties, xpaths, inProperties);\n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_SIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml2() != null);\n        assert receivedAssertion.isSigned();\n        \n        actionResult = handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n        assertTrue(actionResult != null);\n    }","id":11061,"modified_method":"/**\n     * This test creates a holder-of-key SAML2 Assertion, and sends it in the security header \n     * to the provider.\n     */\n    @Test\n    public void testSaml2TokenHOK() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SAML_TOKEN_SIGNED);\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"password\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        SAML2CallbackHandler callbackHandler = new SAML2CallbackHandler();\n        callbackHandler.setConfirmationMethod(SAML2Constants.CONF_HOLDER_KEY);\n        callbackHandler.setSignAssertion(true);\n        outProperties.put(WSHandlerConstants.SAML_CALLBACK_REF, callbackHandler);\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.SAML_TOKEN_SIGNED + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        CustomSamlValidator validator = new CustomSamlValidator();\n        customMap.put(WSConstants.SAML_TOKEN, validator);\n        customMap.put(WSConstants.SAML2_TOKEN, validator);\n        inProperties.put(WSS4JInInterceptor.VALIDATOR_MAP, customMap);\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/saml2:Assertion\");\n        \n        try {\n            makeInvocation(outProperties, xpaths, inProperties, Collections.emptyMap());\n            fail(\"Failure expected in SAML Validator\");\n        } catch (Fault ex) {\n            // expected\n        }\n        validator.setRequireSenderVouches(false);\n        \n        try {\n            makeInvocation(outProperties, xpaths, inProperties, Collections.emptyMap());\n            fail(\"Failure expected in SAML Validator\");\n        } catch (Fault ex) {\n            // expected\n        }\n        validator.setRequireSAML1Assertion(false);\n\n        Message message = makeInvocation(outProperties, xpaths, inProperties, Collections.emptyMap());\n        final List<WSHandlerResult> handlerResults = \n            CastUtils.cast((List<?>)message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.ST_SIGNED).get(0);\n        SamlAssertionWrapper receivedAssertion = \n            (SamlAssertionWrapper) actionResult.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n        assertTrue(receivedAssertion != null && receivedAssertion.getSaml2() != null);\n        assert receivedAssertion.isSigned();\n        \n        actionResult = handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n        assertTrue(actionResult != null);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSignature() throws Exception {\n        SignatureActionToken actionToken = new SignatureActionToken();\n        actionToken.setCryptoProperties(\"outsecurity.properties\");\n        actionToken.setUser(\"myalias\");\n        List<HandlerAction> actions = \n            Collections.singletonList(new HandlerAction(WSConstants.SIGN, actionToken));\n        \n        Map<String, Object> outProperties = new HashMap<>();\n        outProperties.put(WSHandlerConstants.HANDLER_ACTIONS, actions);\n        outProperties.put(WSHandlerConstants.PW_CALLBACK_REF, new TestPwdCallback());\n        \n        Map<String, String> inProperties = new HashMap<>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","id":11062,"modified_method":"@Test\n    public void testSignature() throws Exception {\n        SignatureActionToken actionToken = new SignatureActionToken();\n        actionToken.setCryptoProperties(\"outsecurity.properties\");\n        actionToken.setUser(\"myalias\");\n        List<HandlerAction> actions = \n            Collections.singletonList(new HandlerAction(WSConstants.SIGN, actionToken));\n        \n        Map<String, Object> outProperties = new HashMap<>();\n        outProperties.put(WSHandlerConstants.HANDLER_ACTIONS, actions);\n        outProperties.put(WSHandlerConstants.PW_CALLBACK_REF, new TestPwdCallback());\n        \n        Map<String, Object> inProperties = new HashMap<>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testEncryption() throws Exception {\n        EncryptionActionToken actionToken = new EncryptionActionToken();\n        actionToken.setCryptoProperties(\"outsecurity.properties\");\n        actionToken.setUser(\"myalias\");\n        List<HandlerAction> actions = \n            Collections.singletonList(new HandlerAction(WSConstants.ENCR, actionToken));\n        \n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.HANDLER_ACTIONS, actions);\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//s:Body/xenc:EncryptedData\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        //\n        // This should contain exactly 1 protection result\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 1);\n        //\n        // This result should contain a reference to the decrypted element,\n        // which should contain the soap:Body Qname\n        //\n        final java.util.Map<String, Object> result =\n            protectionResults.get(0);\n        final java.util.List<WSDataRef> protectedElements =\n            CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n        assertNotNull(protectedElements);\n        assertSame(protectedElements.size(), 1);\n        assertEquals(\n            protectedElements.get(0).getName(),\n            new javax.xml.namespace.QName(\n                \"http://schemas.xmlsoap.org/soap/envelope/\",\n                \"Body\"\n            )\n        );\n    }","id":11063,"modified_method":"@Test\n    public void testEncryption() throws Exception {\n        EncryptionActionToken actionToken = new EncryptionActionToken();\n        actionToken.setCryptoProperties(\"outsecurity.properties\");\n        actionToken.setUser(\"myalias\");\n        List<HandlerAction> actions = \n            Collections.singletonList(new HandlerAction(WSConstants.ENCR, actionToken));\n        \n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.HANDLER_ACTIONS, actions);\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(WSHandlerConstants.PW_CALLBACK_REF, new TestPwdCallback()); \n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//s:Body/xenc:EncryptedData\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        //\n        // This should contain exactly 1 protection result\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 1);\n        //\n        // This result should contain a reference to the decrypted element,\n        // which should contain the soap:Body Qname\n        //\n        final java.util.Map<String, Object> result =\n            protectionResults.get(0);\n        final java.util.List<WSDataRef> protectedElements =\n            CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n        assertNotNull(protectedElements);\n        assertSame(protectedElements.size(), 1);\n        assertEquals(\n            protectedElements.get(0).getName(),\n            new javax.xml.namespace.QName(\n                \"http://schemas.xmlsoap.org/soap/envelope/\",\n                \"Body\"\n            )\n        );\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSignatureConfirmationRequest() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.ENABLE_SIGNATURE_CONFIRMATION, \"true\");\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n        //\n        // This is necessary to convince the WSS4JOutInterceptor that we're\n        // functioning as a requestor\n        //\n        msg.put(org.apache.cxf.message.Message.REQUESTOR_ROLE, true);\n\n        handler.handleMessage(msg);\n        doc = part;\n        \n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        //\n        // Save the signature for future confirmation\n        //\n        Set<Integer> sigv = CastUtils.cast((Set<?>)msg.get(WSHandlerConstants.SEND_SIGV));\n        assertNotNull(sigv);\n        assertTrue(sigv.size() != 0);\n        \n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inHandler.setProperty(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.ENABLE_SIGNATURE_CONFIRMATION, \"true\");\n\n        inHandler.handleMessage(inmsg);\n        \n        //\n        // Check that the inbound signature result was saved\n        //\n        List<WSHandlerResult> sigReceived = \n            CastUtils.cast((List<?>)inmsg.get(WSHandlerConstants.RECV_RESULTS));\n        assertNotNull(sigReceived);\n        assertTrue(sigReceived.size() != 0);\n        \n        testSignatureConfirmationResponse(sigv, sigReceived);\n    }","id":11064,"modified_method":"@org.junit.Test\n    public void testSignatureConfirmationRequest() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.ENABLE_SIGNATURE_CONFIRMATION, \"true\");\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n        //\n        // This is necessary to convince the WSS4JOutInterceptor that we're\n        // functioning as a requestor\n        //\n        msg.put(org.apache.cxf.message.Message.REQUESTOR_ROLE, true);\n\n        handler.handleMessage(msg);\n        \n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        //\n        // Save the signature for future confirmation\n        //\n        Set<Integer> sigv = CastUtils.cast((Set<?>)msg.get(WSHandlerConstants.SEND_SIGV));\n        assertNotNull(sigv);\n        assertTrue(sigv.size() != 0);\n        \n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inHandler.setProperty(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.ENABLE_SIGNATURE_CONFIRMATION, \"true\");\n\n        inHandler.handleMessage(inmsg);\n        \n        //\n        // Check that the inbound signature result was saved\n        //\n        List<WSHandlerResult> sigReceived = \n            CastUtils.cast((List<?>)inmsg.get(WSHandlerConstants.RECV_RESULTS));\n        assertNotNull(sigReceived);\n        assertTrue(sigReceived.size() != 0);\n        \n        testSignatureConfirmationResponse(sigv, sigReceived);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"private void testSignatureConfirmationResponse(\n        Set<Integer> sigSaved,\n        List<WSHandlerResult> sigReceived\n    ) throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        msg.put(WSHandlerConstants.RECV_RESULTS, sigReceived);\n        \n        handler.handleMessage(msg);\n\n        doc = part;\n        \n        assertValid(\"//wsse:Security\", doc);\n        // assertValid(\"//wsse:Security/wsse11:SignatureConfirmation\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        // System.out.println(new String(docbytes));\n        \n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        inmsg.put(WSHandlerConstants.SEND_SIGV, sigSaved);\n\n        inHandler.handleMessage(inmsg);\n    }","id":11065,"modified_method":"private void testSignatureConfirmationResponse(\n        Set<Integer> sigSaved,\n        List<WSHandlerResult> sigReceived\n    ) throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        msg.put(WSHandlerConstants.RECV_RESULTS, sigReceived);\n        \n        handler.handleMessage(msg);\n\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        assertValid(\"//wsse:Security\", doc);\n        // assertValid(\"//wsse:Security/wsse11:SignatureConfirmation\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        // System.out.println(new String(docbytes));\n        \n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        inmsg.put(WSHandlerConstants.SEND_SIGV, sigSaved);\n\n        inHandler.handleMessage(inmsg);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test for WSS4JInInterceptor when it receives a message with no security header. \n     */\n    @Test\n    @org.junit.Ignore\n    public void testNoSecurity() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n        doc = part;\n        \n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inHandler.setProperty(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n        \n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n        \n        try {\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on an message with no security header\");\n        } catch (SoapFault fault) {\n            assertTrue(fault.getReason().startsWith(\n                \"An error was discovered processing the <wsse:Security> header\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"InvalidSecurity\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","id":11066,"modified_method":"/**\n     * Test for WSS4JInInterceptor when it receives a message with no security header. \n     */\n    @Test\n    @org.junit.Ignore\n    public void testNoSecurity() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inHandler.setProperty(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n        \n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n        \n        try {\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on an message with no security header\");\n        } catch (SoapFault fault) {\n            assertTrue(fault.getReason().startsWith(\n                \"An error was discovered processing the <wsse:Security> header\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"InvalidSecurity\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test that an action mismatch gets mapped to a proper fault code \n     */\n    @Test\n    @org.junit.Ignore\n    public void testActionMismatch() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n\n        handler.handleMessage(msg);\n\n        doc = part;\n        \n        assertValid(\"//wsse:Security\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, \n            WSHandlerConstants.TIMESTAMP + \" \" + WSHandlerConstants.USERNAME_TOKEN);\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n\n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n        \n        try {\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on an action mismatch\");\n        } catch (SoapFault fault) {\n            assertTrue(fault.getReason().startsWith(\n                \"An error was discovered processing the <wsse:Security> header\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"InvalidSecurity\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","id":11067,"modified_method":"/**\n     * Test that an action mismatch gets mapped to a proper fault code \n     */\n    @Test\n    @org.junit.Ignore\n    public void testActionMismatch() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n\n        handler.handleMessage(msg);\n\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        assertValid(\"//wsse:Security\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, \n            WSHandlerConstants.TIMESTAMP + \" \" + WSHandlerConstants.USERNAME_TOKEN);\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n\n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n        \n        try {\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on an action mismatch\");\n        } catch (SoapFault fault) {\n            assertTrue(fault.getReason().startsWith(\n                \"An error was discovered processing the <wsse:Security> header\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"InvalidSecurity\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    @org.junit.Ignore\n    public void testSignedEncryptedSOAP12Fault() throws Exception {\n        Document doc = readDocument(\"wsse-response-fault.xml\");\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL).createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n        doc = part;\n        \n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, \n                              WSHandlerConstants.SIGNATURE + \" \"  + WSHandlerConstants.ENCRYPT);\n        inHandler.setProperty(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n        inHandler.setProperty(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n        \n        try {\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on a SOAP Fault\");\n        } catch (SoapFault fault) {\n            fault.printStackTrace();\n            // TODO assertTrue(fault.getReason().startsWith(\n               // \"An error was discovered processing the <wsse:Security> header\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"InvalidSecurity\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","id":11068,"modified_method":"@Test\n    @org.junit.Ignore\n    public void testSignedEncryptedSOAP12Fault() throws Exception {\n        Document doc = readDocument(\"wsse-response-fault.xml\");\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, \n                              WSHandlerConstants.SIGNATURE + \" \"  + WSHandlerConstants.ENCRYPT);\n        inHandler.setProperty(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n        inHandler.setProperty(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n        \n        try {\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on a SOAP Fault\");\n        } catch (SoapFault fault) {\n            fault.printStackTrace();\n            // TODO assertTrue(fault.getReason().startsWith(\n               // \"An error was discovered processing the <wsse:Security> header\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"InvalidSecurity\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test that an invalid Timestamp gets mapped to a proper fault code \n     */\n    @Test\n    @org.junit.Ignore\n    public void testInvalidTimestamp() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        msg.put(WSHandlerConstants.TTL_TIMESTAMP, \"1\");\n\n        handler.handleMessage(msg);\n\n        doc = part;\n        \n        assertValid(\"//wsse:Security\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        inHandler.setProperty(WSHandlerConstants.TTL_TIMESTAMP, \"1\");\n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n\n        try {\n            //\n            // Sleep for over a second to make the timestamp invalid\n            //\n            Thread.sleep(1250);\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on an invalid Timestamp\");\n        } catch (SoapFault fault) {\n            assertTrue(fault.getReason().contains(\"Invalid timestamp\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"MessageExpired\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","id":11069,"modified_method":"/**\n     * Test that an invalid Timestamp gets mapped to a proper fault code \n     */\n    @Test\n    @org.junit.Ignore\n    public void testInvalidTimestamp() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        msg.put(WSHandlerConstants.TTL_TIMESTAMP, \"1\");\n\n        handler.handleMessage(msg);\n\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        assertValid(\"//wsse:Security\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        inHandler.setProperty(WSHandlerConstants.TTL_TIMESTAMP, \"1\");\n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n\n        try {\n            //\n            // Sleep for over a second to make the timestamp invalid\n            //\n            Thread.sleep(1250);\n            inHandler.handleMessage(inmsg);\n            fail(\"Expected failure on an invalid Timestamp\");\n        } catch (SoapFault fault) {\n            assertTrue(fault.getReason().contains(\"Invalid timestamp\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"MessageExpired\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUsernameTokenSignature() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        \n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.SIGNATURE_USER, \"myalias\");\n        outProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n        xpaths.add(\"//wsse:Security/wsse:UsernameToken\");\n\n        makeInvocation(outProperties, xpaths, inProperties);\n    }","id":11070,"modified_method":"@Test\n    public void testUsernameTokenSignature() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        \n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.SIGNATURE_USER, \"myalias\");\n        outProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.SIGNATURE\n        );\n        inProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n        xpaths.add(\"//wsse:Security/wsse:UsernameToken\");\n\n        makeInvocation(outProperties, xpaths, inProperties);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testCustomProcessorObject() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        doc = part;\n        \n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        final Map<String, Object> properties = new HashMap<String, Object>();\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        customMap.put(\n            new QName(\n                WSConstants.SIG_NS,\n                WSConstants.SIG_LN\n            ),\n            CustomProcessor.class\n        );\n        properties.put(\n            WSS4JInInterceptor.PROCESSOR_MAP,\n            customMap\n        );\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor(properties);\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n\n        inHandler.handleMessage(inmsg);\n        \n        List<WSHandlerResult> results = getResults(inmsg);\n        assertTrue(results != null && results.size() == 1);\n        List<WSSecurityEngineResult> signatureResults = \n            results.get(0).getActionResults().get(WSConstants.SIGN);\n        assertTrue(signatureResults.size() == 1);\n        \n        Object obj = signatureResults.get(0).get(\"foo\");\n        assertNotNull(obj);\n        assertEquals(obj.getClass().getName(), CustomProcessor.class.getName());\n    }","id":11071,"modified_method":"@Test\n    public void testCustomProcessorObject() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        final Map<String, Object> properties = new HashMap<String, Object>();\n        final Map<QName, Object> customMap = new HashMap<QName, Object>();\n        customMap.put(\n            new QName(\n                WSConstants.SIG_NS,\n                WSConstants.SIG_LN\n            ),\n            CustomProcessor.class\n        );\n        properties.put(\n            WSS4JInInterceptor.PROCESSOR_MAP,\n            customMap\n        );\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor(properties);\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n        \n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n\n        inHandler.handleMessage(inmsg);\n        \n        List<WSHandlerResult> results = getResults(inmsg);\n        assertTrue(results != null && results.size() == 1);\n        List<WSSecurityEngineResult> signatureResults = \n            results.get(0).getActionResults().get(WSConstants.SIGN);\n        assertTrue(signatureResults.size() == 1);\n        \n        Object obj = signatureResults.get(0).get(\"foo\");\n        assertNotNull(obj);\n        assertEquals(obj.getClass().getName(), CustomProcessor.class.getName());\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testCustomProcessor() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n        \n        SOAPMessage saajMsg = MessageFactory.newInstance().createMessage();\n        SOAPPart part = saajMsg.getSOAPPart();\n        part.setContent(new DOMSource(doc));\n        saajMsg.saveChanges();\n\n        msg.setContent(SOAPMessage.class, saajMsg);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        doc = part;\n        \n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        final Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\n            WSS4JInInterceptor.PROCESSOR_MAP,\n            createCustomProcessorMap()\n        );\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor(properties);\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.NO_SECURITY);\n\n        inHandler.handleMessage(inmsg);\n        \n        List<WSHandlerResult> results = getResults(inmsg);\n        assertTrue(results != null && results.size() == 1);\n        List<WSSecurityEngineResult> signatureResults = \n            results.get(0).getActionResults().get(WSConstants.SIGN);\n        assertTrue(signatureResults == null || signatureResults.size() == 0);\n    }","id":11072,"modified_method":"@Test\n    public void testCustomProcessor() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n\n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        final Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\n            WSS4JInInterceptor.PROCESSOR_MAP,\n            createCustomProcessorMap()\n        );\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor(properties);\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.NO_SECURITY);\n\n        inHandler.handleMessage(inmsg);\n        \n        List<WSHandlerResult> results = getResults(inmsg);\n        assertTrue(results != null && results.size() == 1);\n        List<WSSecurityEngineResult> signatureResults = \n            results.get(0).getActionResults().get(WSConstants.SIGN);\n        assertTrue(signatureResults == null || signatureResults.size() == 0);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUsernameToken() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        outProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"alicePassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        inProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n\n        //\n        // This should fail, as we are requiring a digest password type\n        //\n        try {\n            makeInvocation(outProperties, xpaths, inProperties);\n            fail(\"Failure expected on the wrong password type\");\n        } catch (org.apache.cxf.interceptor.Fault fault) {\n            // expected\n        }\n    }","id":11073,"modified_method":"@Test\n    public void testUsernameToken() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        outProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"alicePassword\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        inProperties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);\n        inProperties.put(WSHandlerConstants.PW_CALLBACK_REF, new TestPwdCallback()); \n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n\n        //\n        // This should fail, as we are requiring a digest password type\n        //\n        try {\n            makeInvocation(outProperties, xpaths, inProperties);\n            fail(\"Failure expected on the wrong password type\");\n        } catch (org.apache.cxf.interceptor.Fault fault) {\n            // expected\n        }\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSignature() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","id":11074,"modified_method":"@Test\n    public void testSignature() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPKIPath() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        outProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, KeystorePasswordCallback.class.getName()\n        );\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USE_SINGLE_CERTIFICATE, \"false\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"cxfca.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate[] certificates = \n            (X509Certificate[]) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATES);\n        assertNotNull(certificates);\n        assertEquals(certificates.length, 2);\n    }","id":11075,"modified_method":"@Test\n    public void testPKIPath() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"alice.properties\");\n        outProperties.put(WSHandlerConstants.PW_CALLBACK_REF, new KeystorePasswordCallback());\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(WSHandlerConstants.USE_SINGLE_CERTIFICATE, \"false\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"cxfca.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate[] certificates = \n            (X509Certificate[]) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATES);\n        assertNotNull(certificates);\n        assertEquals(certificates.length, 2);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testDirectReferenceSignature() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/wsse:BinarySecurityToken\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","id":11076,"modified_method":"@Test\n    public void testDirectReferenceSignature() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        outProperties.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(WSHandlerConstants.SIG_KEY_ID, \"DirectReference\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        inProperties.put(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//wsse:Security/wsse:BinarySecurityToken\");\n        xpaths.add(\"//wsse:Security/ds:Signature\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n        WSSecurityEngineResult actionResult =\n            handlerResults.get(0).getActionResults().get(WSConstants.SIGN).get(0);\n         \n        X509Certificate certificate = \n            (X509Certificate) actionResult.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        assertNotNull(certificate);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testEncryptedUsernameToken() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(\n            WSHandlerConstants.ACTION,\n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"alicePassword\");\n        outProperties.put(WSHandlerConstants.ENCRYPTION_USER, \"myalias\");\n        outProperties.put(\n            WSHandlerConstants.ENCRYPTION_PARTS, \n            \"{Content}{\" + WSConstants.WSSE_NS + \"}UsernameToken\"\n        );\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n\n        SoapMessage inmsg = makeInvocation(outProperties, xpaths, inProperties);\n        List<WSHandlerResult> handlerResults = getResults(inmsg);\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        \n        //\n        // This should contain exactly 2 protection results\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 2);\n        \n        final Principal p1 = (Principal)protectionResults.get(0).get(WSSecurityEngineResult.TAG_PRINCIPAL);\n        final Principal p2 = (Principal)protectionResults.get(1).get(WSSecurityEngineResult.TAG_PRINCIPAL);\n        assertTrue(p1 instanceof UsernameTokenPrincipal || p2 instanceof UsernameTokenPrincipal);\n        \n        Principal utPrincipal = p1 instanceof UsernameTokenPrincipal ? p1 : p2;\n        \n        SecurityContext securityContext = inmsg.get(SecurityContext.class);\n        assertNotNull(securityContext);\n        assertSame(securityContext.getUserPrincipal(), utPrincipal);\n    }","id":11077,"modified_method":"@Test\n    public void testEncryptedUsernameToken() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(\n            WSHandlerConstants.ACTION,\n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"alice\");\n        outProperties.put(\"password\", \"alicePassword\");\n        outProperties.put(WSHandlerConstants.ENCRYPTION_USER, \"myalias\");\n        outProperties.put(\n            WSHandlerConstants.ENCRYPTION_PARTS, \n            \"{Content}{\" + WSConstants.WSSE_NS + \"}UsernameToken\"\n        );\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(\n            WSHandlerConstants.ACTION, \n            WSHandlerConstants.USERNAME_TOKEN + \" \" + WSHandlerConstants.ENCRYPT\n        );\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(WSHandlerConstants.PW_CALLBACK_REF, new TestPwdCallback()); \n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n\n        SoapMessage inmsg = makeInvocation(outProperties, xpaths, inProperties);\n        List<WSHandlerResult> handlerResults = getResults(inmsg);\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        \n        //\n        // This should contain exactly 2 protection results\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 2);\n        \n        final Principal p1 = (Principal)protectionResults.get(0).get(WSSecurityEngineResult.TAG_PRINCIPAL);\n        final Principal p2 = (Principal)protectionResults.get(1).get(WSSecurityEngineResult.TAG_PRINCIPAL);\n        assertTrue(p1 instanceof UsernameTokenPrincipal || p2 instanceof UsernameTokenPrincipal);\n        \n        Principal utPrincipal = p1 instanceof UsernameTokenPrincipal ? p1 : p2;\n        \n        SecurityContext securityContext = inmsg.get(SecurityContext.class);\n        assertNotNull(securityContext);\n        assertSame(securityContext.getUserPrincipal(), utPrincipal);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testEncryption() throws Exception {\n        Map<String, String> outProperties = new HashMap<String, String>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, String> inProperties = new HashMap<String, String>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//s:Body/xenc:EncryptedData\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        //\n        // This should contain exactly 1 protection result\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 1);\n        //\n        // This result should contain a reference to the decrypted element,\n        // which should contain the soap:Body Qname\n        //\n        final java.util.Map<String, Object> result =\n            protectionResults.get(0);\n        final java.util.List<WSDataRef> protectedElements =\n            CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n        assertNotNull(protectedElements);\n        assertSame(protectedElements.size(), 1);\n        assertEquals(\n            protectedElements.get(0).getName(),\n            new javax.xml.namespace.QName(\n                \"http://schemas.xmlsoap.org/soap/envelope/\",\n                \"Body\"\n            )\n        );\n    }","id":11078,"modified_method":"@Test\n    public void testEncryption() throws Exception {\n        Map<String, Object> outProperties = new HashMap<String, Object>();\n        outProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        outProperties.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        outProperties.put(WSHandlerConstants.USER, \"myalias\");\n        outProperties.put(\"password\", \"myAliasPassword\");\n        \n        Map<String, Object> inProperties = new HashMap<String, Object>();\n        inProperties.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        inProperties.put(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inProperties.put(WSHandlerConstants.PW_CALLBACK_REF, new TestPwdCallback()); \n        \n        List<String> xpaths = new ArrayList<String>();\n        xpaths.add(\"//wsse:Security\");\n        xpaths.add(\"//s:Body/xenc:EncryptedData\");\n\n        List<WSHandlerResult> handlerResults = \n            getResults(makeInvocation(outProperties, xpaths, inProperties));\n\n        assertNotNull(handlerResults);\n        assertSame(handlerResults.size(), 1);\n        //\n        // This should contain exactly 1 protection result\n        //\n        final java.util.List<WSSecurityEngineResult> protectionResults =\n            handlerResults.get(0).getResults();\n        assertNotNull(protectionResults);\n        assertSame(protectionResults.size(), 1);\n        //\n        // This result should contain a reference to the decrypted element,\n        // which should contain the soap:Body Qname\n        //\n        final java.util.Map<String, Object> result =\n            protectionResults.get(0);\n        final java.util.List<WSDataRef> protectedElements =\n            CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n        assertNotNull(protectedElements);\n        assertSame(protectedElements.size(), 1);\n        assertEquals(\n            protectedElements.get(0).getName(),\n            new javax.xml.namespace.QName(\n                \"http://schemas.xmlsoap.org/soap/envelope/\",\n                \"Body\"\n            )\n        );\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testEncrypt() throws Exception {\n        SOAPMessage saaj = readSAAJDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        msg.setContent(SOAPMessage.class, saaj);\n        \n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        SOAPPart doc = saaj.getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//s:Body/xenc:EncryptedData\", doc);\n    }","id":11079,"modified_method":"@Test\n    public void testEncrypt() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.ENCRYPT);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.ENC_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        doc = msg.getContent(SOAPMessage.class).getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//s:Body/xenc:EncryptedData\", doc);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testOverrideCustomAction() throws Exception {\n        SOAPMessage saaj = readSAAJDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        msg.setContent(SOAPMessage.class, saaj);\n        \n        CountingUsernameTokenAction action = new CountingUsernameTokenAction();\n        Map<Object, Object> customActions = new HashMap<Object, Object>(1);\n        customActions.put(WSConstants.UT, action);\n                \n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        msg.put(WSS4JOutInterceptor.WSS4J_ACTION_MAP, customActions);\n        handler.handleMessage(msg);\n\n        SOAPPart doc = saaj.getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the plaintext password is used in the header\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n        assertEquals(1, action.getExecutions());\n        \n        try {\n            customActions.put(WSConstants.UT, new Object());\n            handler.handleMessage(msg);\n        } catch (SoapFault e) {\n            assertEquals(\"An invalid action configuration was defined.\", e.getMessage());\n        }\n        \n        try {\n            customActions.put(new Object(), CountingUsernameTokenAction.class);\n            handler.handleMessage(msg);\n        } catch (SoapFault e) {\n            assertEquals(\"An invalid action configuration was defined.\", e.getMessage());\n        }\n    }","id":11080,"modified_method":"@Test\n    public void testOverrideCustomAction() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n        \n        CountingUsernameTokenAction action = new CountingUsernameTokenAction();\n        Map<Object, Object> customActions = new HashMap<Object, Object>(1);\n        customActions.put(WSConstants.UT, action);\n                \n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        msg.put(WSS4JOutInterceptor.WSS4J_ACTION_MAP, customActions);\n        handler.handleMessage(msg);\n\n        doc = msg.getContent(SOAPMessage.class).getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the plaintext password is used in the header\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n        assertEquals(1, action.getExecutions());\n        \n        try {\n            customActions.put(WSConstants.UT, new Object());\n            handler.handleMessage(msg);\n        } catch (SoapFault e) {\n            assertEquals(\"An invalid action configuration was defined.\", e.getMessage());\n        }\n        \n        try {\n            customActions.put(new Object(), CountingUsernameTokenAction.class);\n            handler.handleMessage(msg);\n        } catch (SoapFault e) {\n            assertEquals(\"An invalid action configuration was defined.\", e.getMessage());\n        }\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUsernameTokenDigest() throws Exception {\n        SOAPMessage saaj = readSAAJDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        msg.setContent(SOAPMessage.class, saaj);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);\n        handler.handleMessage(msg);\n\n        SOAPPart doc = saaj.getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the password digest is used in the header\n        assertInvalid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n    }","id":11081,"modified_method":"@Test\n    public void testUsernameTokenDigest() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);\n        handler.handleMessage(msg);\n\n        doc = msg.getContent(SOAPMessage.class).getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the password digest is used in the header\n        assertInvalid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testAddCustomAction() throws Exception {\n        SOAPMessage saaj = readSAAJDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        msg.setContent(SOAPMessage.class, saaj);\n        \n        CountingUsernameTokenAction action = new CountingUsernameTokenAction();\n        Map<Object, Object> customActions = new HashMap<Object, Object>(1);\n        customActions.put(12345, action);\n                \n        msg.put(WSHandlerConstants.ACTION, \"12345\");\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        msg.put(WSS4JOutInterceptor.WSS4J_ACTION_MAP, customActions);\n        handler.handleMessage(msg);\n\n        SOAPPart doc = saaj.getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the plaintext password is used in the header\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n        assertEquals(1, action.getExecutions());\n    }","id":11082,"modified_method":"@Test\n    public void testAddCustomAction() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        CountingUsernameTokenAction action = new CountingUsernameTokenAction();\n        Map<Object, Object> customActions = new HashMap<Object, Object>(1);\n        customActions.put(12345, action);\n                \n        msg.put(WSHandlerConstants.ACTION, \"12345\");\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        msg.put(WSS4JOutInterceptor.WSS4J_ACTION_MAP, customActions);\n        handler.handleMessage(msg);\n\n        doc = msg.getContent(SOAPMessage.class).getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the plaintext password is used in the header\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n        assertEquals(1, action.getExecutions());\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testTimestamp() throws Exception {\n        SOAPMessage saaj = readSAAJDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        msg.setContent(SOAPMessage.class, saaj);\n        \n        ohandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        ohandler.setProperty(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        SOAPPart doc = saaj.getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsu:Timestamp\", doc);\n    }","id":11083,"modified_method":"@Test\n    public void testTimestamp() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        ohandler.setProperty(WSHandlerConstants.ACTION, WSHandlerConstants.TIMESTAMP);\n        ohandler.setProperty(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myalias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        doc = msg.getContent(SOAPMessage.class).getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsu:Timestamp\", doc);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSignature() throws Exception {\n        SOAPMessage saaj = readSAAJDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        msg.setContent(SOAPMessage.class, saaj);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myAlias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        SOAPPart doc = saaj.getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n    }","id":11084,"modified_method":"@Test\n    public void testSignature() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.SIGNATURE);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"myAlias\");\n        msg.put(\"password\", \"myAliasPassword\");\n\n        handler.handleMessage(msg);\n\n        doc = msg.getContent(SOAPMessage.class).getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/ds:Signature\", doc);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUsernameTokenText() throws Exception {\n        SOAPMessage saaj = readSAAJDocument(\"wsse-request-clean.xml\");\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        SoapMessage msg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(msg);\n\n        msg.setContent(SOAPMessage.class, saaj);\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        handler.handleMessage(msg);\n\n        SOAPPart doc = saaj.getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the plaintext password is used in the header\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n    }","id":11085,"modified_method":"@Test\n    public void testUsernameTokenText() throws Exception {\n        Document doc = readDocument(\"wsse-request-clean.xml\");\n        SoapMessage msg = getSoapMessageForDom(doc);\n\n        WSS4JOutInterceptor ohandler = new WSS4JOutInterceptor();\n        PhaseInterceptor<SoapMessage> handler = ohandler.createEndingInterceptor();\n\n        msg.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);\n        msg.put(WSHandlerConstants.SIG_PROP_FILE, \"outsecurity.properties\");\n        msg.put(WSHandlerConstants.USER, \"username\");\n        msg.put(\"password\", \"myAliasPassword\");\n        msg.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);\n        handler.handleMessage(msg);\n\n        doc = msg.getContent(SOAPMessage.class).getSOAPPart();\n        assertValid(\"//wsse:Security\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken\", doc);\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Username[text()='username']\", doc);\n        // Test to see that the plaintext password is used in the header\n        assertValid(\"//wsse:Security/wsse:UsernameToken/wsse:Password[text()='myAliasPassword']\", doc);\n    }","commit_id":"25b8c0e575f1f62a2746d2574fdea5772858fc60","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test for Windows feature that exposes 8.3 filename references\n     * for long filenames.\n     * <p>\n     * See: http://support.microsoft.com/kb/142982\n     * @throws Exception failed test\n     */\n    @Test\n    public void testCase8dot3Alias() throws Exception\n    {\n        File dir = testdir.getDir();\n        Path path = new File(dir, \"TextFile.Long.txt\").toPath();\n        Files.createFile(path);\n        \n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // Long filename\n            Resource resource = base.addPath(\"TextFile.Long.txt\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            // On some versions of Windows, the long filename can be referenced\n            // via a short 8.3 equivalent filename.\n            Resource alias = base.addPath(\"TEXTFI~1.TXT\");\n            if (alias.exists())\n            {\n                // If it exists, it must be an alias\n                assertThat(\"alias\", alias, isAliasFor(resource));\n                assertThat(\"alias.uri\", newResource(alias.getURI()), isAliasFor(resource));\n                assertThat(\"alias.file\", newResource(alias.getFile()), isAliasFor(resource));\n            }\n        }\n    }","id":11086,"modified_method":"/**\n     * Test for Windows feature that exposes 8.3 filename references\n     * for long filenames.\n     * <p>\n     * See: http://support.microsoft.com/kb/142982\n     * @throws Exception failed test\n     */\n    @Test\n    public void testCase8dot3Alias() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path path = dir.resolve(\"TextFile.Long.txt\");\n        Files.createFile(path);\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            // Long filename\n            Resource resource = base.addPath(\"TextFile.Long.txt\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            // On some versions of Windows, the long filename can be referenced\n            // via a short 8.3 equivalent filename.\n            Resource alias = base.addPath(\"TEXTFI~1.TXT\");\n            if (alias.exists())\n            {\n                // If it exists, it must be an alias\n                assertThat(\"alias\", alias, isAliasFor(resource));\n                assertThat(\"alias.uri\", newResource(alias.getURI()), isAliasFor(resource));\n                assertThat(\"alias.file\", newResource(alias.getFile()), isAliasFor(resource));\n            }\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testIsContainedIn() throws Exception\n    {\n        createEmptyFile(\"foo\");\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"is contained in\",res.isContainedIn(base),is(false));\n        }\n    }","id":11087,"modified_method":"@Test\n    public void testIsContainedIn() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        Path foo = dir.resolve(\"foo\");\n        Files.createFile(foo);\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"is contained in\",res.isContainedIn(base),is(false));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleBackTick() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = new File(dir, \"foo` bar\").toPath();\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo` bar\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","id":11088,"modified_method":"@Test\n    public void testSingleBackTick() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try\n        {\n            // attempt to create file\n            Path foo = dir.resolve(\"foo` bar\");\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo` bar\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testBraces() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = new File(dir, \"foo.{bar}.txt\").toPath();\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo.{bar}.txt\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","id":11089,"modified_method":"@Test\n    public void testBraces() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try\n        {\n            // attempt to create file\n            Path foo = dir.resolve(\"foo.{bar}.txt\");\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo.{bar}.txt\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleQuoteInFileName() throws Exception\n    {\n        createEmptyFile(\"foo's.txt\");\n        createEmptyFile(\"f o's.txt\");\n\n        URI refQuoted = testdir.getDir().toURI().resolve(\"foo's.txt\");\n\n        try (Resource fileres = newResource(refQuoted))\n        {\n            assertThat(\"Exists: \" + refQuoted,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refQuoted,fileres,hasNoAlias());\n        }\n\n        URI refEncoded = testdir.getDir().toURI().resolve(\"foo%27s.txt\");\n\n        try (Resource fileres = newResource(refEncoded))\n        {\n            assertThat(\"Exists: \" + refEncoded,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refEncoded,fileres,hasNoAlias());\n        }\n\n        URI refQuoteSpace = testdir.getDir().toURI().resolve(\"f%20o's.txt\");\n\n        try (Resource fileres = newResource(refQuoteSpace))\n        {\n            assertThat(\"Exists: \" + refQuoteSpace,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refQuoteSpace,fileres,hasNoAlias());\n        }\n\n        URI refEncodedSpace = testdir.getDir().toURI().resolve(\"f%20o%27s.txt\");\n\n        try (Resource fileres = newResource(refEncodedSpace))\n        {\n            assertThat(\"Exists: \" + refEncodedSpace,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refEncodedSpace,fileres,hasNoAlias());\n        }\n\n        URI refA = testdir.getDir().toURI().resolve(\"foo's.txt\");\n        URI refB = testdir.getDir().toURI().resolve(\"foo%27s.txt\");\n\n        StringBuilder msg = new StringBuilder();\n        msg.append(\"URI[a].equals(URI[b])\").append(System.lineSeparator());\n        msg.append(\"URI[a] = \").append(refA).append(System.lineSeparator());\n        msg.append(\"URI[b] = \").append(refB);\n\n        // show that simple URI.equals() doesn't work\n        assertThat(msg.toString(),refA.equals(refB),is(false));\n\n        // now show that Resource.equals() does work\n        try (Resource a = newResource(refA); Resource b = newResource(refB);)\n        {\n            assertThat(\"A.equals(B)\",a.equals(b),is(true));\n        }\n    }","id":11090,"modified_method":"@Test\n    public void testSingleQuoteInFileName() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path fooA = dir.resolve(\"foo's.txt\");\n        Path fooB = dir.resolve(\"f o's.txt\");\n        \n        Files.createFile(fooA);\n        Files.createFile(fooB);\n        \n        URI refQuoted = dir.resolve(\"foo's.txt\").toUri();\n\n        try (Resource fileres = newResource(refQuoted))\n        {\n            // FileResource on OSX does not pass this test!\n            // on OSX \"foo's.txt\" with FileResource becomes \"foo%27s.txt\" incorrectly.\n            assumeFalse( (fileres instanceof FileResource) && (OS.IS_OSX) );\n            \n            assertThat(\"Exists: \" + refQuoted,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refQuoted,fileres,hasNoAlias());\n        }\n\n        URI refEncoded = dir.toUri().resolve(\"foo%27s.txt\");\n\n        try (Resource fileres = newResource(refEncoded))\n        {\n            assertThat(\"Exists: \" + refEncoded,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refEncoded,fileres,hasNoAlias());\n        }\n\n        URI refQuoteSpace = dir.toUri().resolve(\"f%20o's.txt\");\n\n        try (Resource fileres = newResource(refQuoteSpace))\n        {\n            assertThat(\"Exists: \" + refQuoteSpace,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refQuoteSpace,fileres,hasNoAlias());\n        }\n\n        URI refEncodedSpace = dir.toUri().resolve(\"f%20o%27s.txt\");\n\n        try (Resource fileres = newResource(refEncodedSpace))\n        {\n            assertThat(\"Exists: \" + refEncodedSpace,fileres.exists(),is(true));\n            assertThat(\"Alias: \" + refEncodedSpace,fileres,hasNoAlias());\n        }\n\n        URI refA = dir.toUri().resolve(\"foo's.txt\");\n        URI refB = dir.toUri().resolve(\"foo%27s.txt\");\n\n        StringBuilder msg = new StringBuilder();\n        msg.append(\"URI[a].equals(URI[b])\").append(System.lineSeparator());\n        msg.append(\"URI[a] = \").append(refA).append(System.lineSeparator());\n        msg.append(\"URI[b] = \").append(refB);\n\n        // show that simple URI.equals() doesn't work\n        assertThat(msg.toString(),refA.equals(refB),is(false));\n\n        // now show that Resource.equals() does work\n        try (Resource a = newResource(refA); Resource b = newResource(refB);)\n        {\n            assertThat(\"A.equals(B)\",a.equals(b),is(true));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testReadableByteChannel() throws Exception\n    {\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        String content = \"Foo is here\";\n\n        try (StringReader reader = new StringReader(content); FileWriter writer = new FileWriter(file))\n        {\n            IO.copy(reader,writer);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            try (ReadableByteChannel channel = foo.getReadableByteChannel())\n            {\n                ByteBuffer buf = ByteBuffer.allocate(256);\n                channel.read(buf);\n                buf.flip();\n                String actual = BufferUtil.toUTF8String(buf);\n                assertThat(\"ReadableByteChannel content\",actual,is(content));\n            }\n        }\n    }","id":11091,"modified_method":"@Test\n    public void testReadableByteChannel() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n\n        Path file = dir.resolve(\"foo\");\n        String content = \"Foo is here\";\n\n        try (StringReader reader = new StringReader(content);\n             BufferedWriter writer = Files.newBufferedWriter(file))\n        {\n            IO.copy(reader,writer);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            try (ReadableByteChannel channel = foo.getReadableByteChannel())\n            {\n                ByteBuffer buf = ByteBuffer.allocate(256);\n                channel.read(buf);\n                buf.flip();\n                String actual = BufferUtil.toUTF8String(buf);\n                assertThat(\"ReadableByteChannel content\",actual,is(content));\n            }\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testList() throws Exception\n    {\n        File dir = testdir.getDir();\n        FS.touch(new File(dir, \"foo\"));\n        FS.touch(new File(dir, \"bar\"));\n        FS.ensureDirExists(new File(dir, \"tick\"));\n        FS.ensureDirExists(new File(dir, \"tock\"));\n        \n        List<String> expected = new ArrayList<>();\n        expected.add(\"foo\");\n        expected.add(\"bar\");\n        expected.add(\"tick/\");\n        expected.add(\"tock/\");\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            String list[] = base.list();\n            List<String> actual = Arrays.asList(list);\n            \n            CollectionAssert.assertContainsUnordered(\"Resource Directory Listing\",\n                    expected,actual);\n        }\n    }","id":11092,"modified_method":"@Test\n    public void testList() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Files.createFile(dir.resolve(\"foo\"));\n        Files.createFile(dir.resolve(\"bar\"));\n        Files.createDirectories(dir.resolve(\"tick\"));\n        Files.createDirectories(dir.resolve(\"tock\"));\n        \n        List<String> expected = new ArrayList<>();\n        expected.add(\"foo\");\n        expected.add(\"bar\");\n        expected.add(\"tick/\");\n        expected.add(\"tock/\");\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            String list[] = base.list();\n            List<String> actual = Arrays.asList(list);\n            \n            CollectionAssert.assertContainsUnordered(\"Resource Directory Listing\",\n                    expected,actual);\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testDelete() throws Exception\n    {\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // Is it there?\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.exists\",res.exists(),is(true));\n            // delete it\n            assertThat(\"foo.delete\",res.delete(),is(true));\n            // is it there?\n            assertThat(\"foo.exists\",res.exists(),is(false));\n        }\n    }","id":11093,"modified_method":"@Test\n    public void testDelete() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        Path file = dir.resolve(\"foo\");\n        Files.createFile(file);\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            // Is it there?\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.exists\",res.exists(),is(true));\n            // delete it\n            assertThat(\"foo.delete\",res.delete(),is(true));\n            // is it there?\n            assertThat(\"foo.exists\",res.exists(),is(false));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testExist_BadURINullX() throws Exception\n    {\n        createEmptyFile(\"a.jsp\");\n\n        try\n        {\n            // request with null and x at end\n            URI uri = testdir.getDir().toURI().resolve(\"a.jsp%00x\");\n            assertThat(\"NullX URI\",uri,notNullValue());\n\n            Resource r = newResource(uri);\n            \n            // if we have r, then it better not exist\n            assertFalse(r.exists());\n        }\n        catch (InvalidPathException e)\n        {\n            // Exception is acceptable\n        }\n    }","id":11094,"modified_method":"@Test\n    public void testExist_BadURINullX() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path path = dir.resolve(\"a.jsp\");\n        Files.createFile(path);\n\n        try\n        {\n            // request with null and x at end\n            URI uri = testdir.getDir().toURI().resolve(\"a.jsp%00x\");\n            assertThat(\"NullX URI\",uri,notNullValue());\n\n            Resource r = newResource(uri);\n            \n            // if we have r, then it better not exist\n            assertFalse(r.exists());\n        }\n        catch (InvalidPathException e)\n        {\n            // Exception is acceptable\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testLastModified() throws Exception\n    {\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        long expected = file.lastModified();\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.lastModified\",res.lastModified()/1000*1000,is(expected));\n        }\n    }","id":11095,"modified_method":"@Test\n    public void testLastModified() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        long expected = file.lastModified();\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.lastModified\",res.lastModified()/1000*1000,is(expected));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * NTFS Alternative Data / File Streams.\n     * <p>\n     * See: http://msdn.microsoft.com/en-us/library/windows/desktop/aa364404(v=vs.85).aspx\n     * @throws Exception failed test\n     */\n    @Test\n    public void testNTFSFileStreamAlias() throws Exception\n    {\n        File dir = testdir.getDir();\n        Path path = new File(dir, \"testfile\").toPath();\n        Files.createFile(path);\n        \n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource resource = base.addPath(\"testfile\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            try\n            {\n                // Attempt to reference same file, but via NTFS simple stream\n                Resource alias = base.addPath(\"testfile:stream\");\n                if (alias.exists())\n                {\n                    // If it exists, it must be an alias\n                    assertThat(\"resource.alias\",alias,isAliasFor(resource));\n                    assertThat(\"resource.uri.alias\",newResource(alias.getURI()),isAliasFor(resource));\n                    assertThat(\"resource.file.alias\",newResource(alias.getFile()),isAliasFor(resource));\n                }\n            }\n            catch (InvalidPathException e)\n            {\n                // NTFS filesystem streams are unsupported on some platforms.\n                assumeNoException(e);\n            }\n        }\n    }","id":11096,"modified_method":"/**\n     * NTFS Alternative Data / File Streams.\n     * <p>\n     * See: http://msdn.microsoft.com/en-us/library/windows/desktop/aa364404(v=vs.85).aspx\n     * @throws Exception failed test\n     */\n    @Test\n    public void testNTFSFileStreamAlias() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n\n        Path path = dir.resolve(\"testfile\");\n        Files.createFile(path);\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource resource = base.addPath(\"testfile\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            try\n            {\n                // Attempt to reference same file, but via NTFS simple stream\n                Resource alias = base.addPath(\"testfile:stream\");\n                if (alias.exists())\n                {\n                    // If it exists, it must be an alias\n                    assertThat(\"resource.alias\",alias,isAliasFor(resource));\n                    assertThat(\"resource.uri.alias\",newResource(alias.getURI()),isAliasFor(resource));\n                    assertThat(\"resource.file.alias\",newResource(alias.getFile()),isAliasFor(resource));\n                }\n            }\n            catch (InvalidPathException e)\n            {\n                // NTFS filesystem streams are unsupported on some platforms.\n                assumeNoException(e);\n            }\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleQuote() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = new File(dir, \"foo' bar\").toPath();\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo' bar\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","id":11097,"modified_method":"@Test\n    public void testSingleQuote() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try\n        {\n            // attempt to create file\n            Path foo = dir.resolve(\"foo' bar\");\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo' bar\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testDelete_NotExists() throws Exception\n    {\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // Is it there?\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.exists\",res.exists(),is(false));\n            // delete it\n            assertThat(\"foo.delete\",res.delete(),is(false));\n            // is it there?\n            assertThat(\"foo.exists\",res.exists(),is(false));\n        }\n    }","id":11098,"modified_method":"@Test\n    public void testDelete_NotExists() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            // Is it there?\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.exists\",res.exists(),is(false));\n            // delete it\n            assertThat(\"foo.delete\",res.delete(),is(false));\n            // is it there?\n            assertThat(\"foo.exists\",res.exists(),is(false));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAddPath() throws Exception\n    {\n        File dir = testdir.getDir();\n        File subdir = new File(dir,\"sub\");\n        FS.ensureDirExists(subdir);\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource sub = base.addPath(\"sub\");\n            assertThat(\"sub/.isDirectory\",sub.isDirectory(),is(true));\n\n            Resource tmp = sub.addPath(\"/tmp\");\n            assertThat(\"No root\",tmp.exists(),is(false));\n        }\n    }","id":11099,"modified_method":"@Test\n    public void testAddPath() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        \n        Path subdir = dir.resolve(\"sub\");\n        FS.ensureDirExists(subdir.toFile());\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource sub = base.addPath(\"sub\");\n            assertThat(\"sub/.isDirectory\",sub.isDirectory(),is(true));\n\n            Resource tmp = sub.addPath(\"/tmp\");\n            assertThat(\"No root\",tmp.exists(),is(false));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testName() throws Exception\n    {\n        String expected = testdir.getDir().getAbsolutePath();\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            assertThat(\"base.name\",base.getName(),is(expected));\n        }\n    }","id":11100,"modified_method":"@Test\n    public void testName() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        String expected = dir.toAbsolutePath().toString();\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            assertThat(\"base.name\",base.getName(),is(expected));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testUtf8Dir() throws Exception\n    {\n        File dir=new File(testdir.getDir(),\"bãm\");\n        dir.mkdir();\n        File file = new File(dir,\"file.txt\");\n        file.createNewFile();\n        \n        Resource base = newResource(dir);\n        assertNull(base.getAlias());\n        \n        Resource r = base.addPath(\"file.txt\");\n        assertNull(r.getAlias());\n    }","id":11101,"modified_method":"@Test\n    public void testUtf8Dir() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Path utf8Dir = dir.resolve(\"bãm\");\n        Files.createDirectories(utf8Dir);\n        \n        Path file = utf8Dir.resolve(\"file.txt\");\n        Files.createFile(file);\n        \n        try (Resource base = newResource(utf8Dir.toFile()))\n        {\n            assertThat(\"Exists: \" + utf8Dir,base.exists(),is(true));\n            assertThat(\"Alias: \" + utf8Dir,base,hasNoAlias());\n\n            Resource r = base.addPath(\"file.txt\");\n            assertThat(\"Exists: \" + r,r.exists(),is(true));\n            assertThat(\"Alias: \" + r,r,hasNoAlias());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * The most basic access example\n     * @throws Exception failed test\n     */\n    @Test\n    public void testExist_Normal() throws Exception\n    {\n        createEmptyFile(\"a.jsp\");\n\n        URI ref = testdir.getDir().toURI().resolve(\"a.jsp\");\n        try (Resource fileres = newResource(ref))\n        {\n            assertThat(\"Resource: \" + fileres,fileres.exists(),is(true));\n        }\n    }","id":11102,"modified_method":"/**\n     * The most basic access example\n     * @throws Exception failed test\n     */\n    @Test\n    public void testExist_Normal() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path path = dir.resolve(\"a.jsp\");\n        Files.createFile(path);\n\n        URI ref = testdir.getDir().toURI().resolve(\"a.jsp\");\n        try (Resource fileres = newResource(ref))\n        {\n            assertThat(\"Resource: \" + fileres,fileres.exists(),is(true));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testInputStream() throws Exception\n    {\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        String content = \"Foo is here\";\n\n        try (StringReader reader = new StringReader(content); FileWriter writer = new FileWriter(file))\n        {\n            IO.copy(reader,writer);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            try (InputStream stream = foo.getInputStream(); InputStreamReader reader = new InputStreamReader(stream); StringWriter writer = new StringWriter())\n            {\n                IO.copy(reader,writer);\n                assertThat(\"Stream\",writer.toString(),is(content));\n            }\n        }\n    }","id":11103,"modified_method":"@Test\n    public void testInputStream() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path file = dir.resolve(\"foo\");\n        String content = \"Foo is here\";\n\n        try (StringReader reader = new StringReader(content);\n             BufferedWriter writer = Files.newBufferedWriter(file))\n        {\n            IO.copy(reader,writer);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            try (InputStream stream = foo.getInputStream(); InputStreamReader reader = new InputStreamReader(stream); StringWriter writer = new StringWriter())\n            {\n                IO.copy(reader,writer);\n                assertThat(\"Stream\",writer.toString(),is(content));\n            }\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * NTFS Alternative Data / File Streams.\n     * <p>\n     * See: http://msdn.microsoft.com/en-us/library/windows/desktop/aa364404(v=vs.85).aspx\n     * @throws Exception failed test\n     */\n    @Test\n    public void testNTFSFileEncodedDataStreamAlias() throws Exception\n    {\n        File dir = testdir.getDir();\n        Path path = new File(dir, \"testfile\").toPath();\n        Files.createFile(path);\n        \n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource resource = base.addPath(\"testfile\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            try\n            {\n                // Attempt to reference same file, but via NTFS DATA stream (encoded addPath version) \n                Resource alias = base.addPath(\"testfile::%24DATA\");\n                if (alias.exists())\n                {\n                    // If it exists, it must be an alias\n                    assertThat(\"resource.alias\",alias,isAliasFor(resource));\n                    assertThat(\"resource.uri.alias\",newResource(alias.getURI()),isAliasFor(resource));\n                    assertThat(\"resource.file.alias\",newResource(alias.getFile()),isAliasFor(resource));\n                }\n            }\n            catch (InvalidPathException e)\n            {\n                // NTFS filesystem streams are unsupported on some platforms.\n                assumeNoException(e);\n            }\n        }\n    }","id":11104,"modified_method":"/**\n     * NTFS Alternative Data / File Streams.\n     * <p>\n     * See: http://msdn.microsoft.com/en-us/library/windows/desktop/aa364404(v=vs.85).aspx\n     * @throws Exception failed test\n     */\n    @Test\n    public void testNTFSFileEncodedDataStreamAlias() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n\n        Path path = dir.resolve(\"testfile\");\n        Files.createFile(path);\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource resource = base.addPath(\"testfile\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            try\n            {\n                // Attempt to reference same file, but via NTFS DATA stream (encoded addPath version) \n                Resource alias = base.addPath(\"testfile::%24DATA\");\n                if (alias.exists())\n                {\n                    // If it exists, it must be an alias\n                    assertThat(\"resource.alias\",alias,isAliasFor(resource));\n                    assertThat(\"resource.uri.alias\",newResource(alias.getURI()),isAliasFor(resource));\n                    assertThat(\"resource.file.alias\",newResource(alias.getFile()),isAliasFor(resource));\n                }\n            }\n            catch (InvalidPathException e)\n            {\n                // NTFS filesystem streams are unsupported on some platforms.\n                assumeNoException(e);\n            }\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetURL() throws Exception\n    {\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        URL expected = file.toURI().toURL();\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            assertThat(\"getURL\",foo.getURL(),is(expected));\n        }\n    }","id":11105,"modified_method":"@SuppressWarnings(\"deprecation\")\n    @Test\n    public void testGetURL() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n\n        Path file = dir.resolve(\"foo\");\n        Files.createFile(file);\n\n        URL expected = file.toUri().toURL();\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            assertThat(\"getURL\",foo.getURL(),is(expected));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testPipe() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = new File(dir, \"foo|bar.txt\").toPath();\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo|bar.txt\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","id":11106,"modified_method":"@Test\n    public void testPipe() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try\n        {\n            // attempt to create file\n            Path foo = dir.resolve(\"foo|bar.txt\");\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo|bar.txt\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testExist_BadURINull() throws Exception\n    {\n        createEmptyFile(\"a.jsp\");\n\n        try\n        {\n            // request with null at end\n            URI uri = testdir.getDir().toURI().resolve(\"a.jsp%00\");\n            assertThat(\"Null URI\",uri,notNullValue());\n\n            Resource r = newResource(uri);\n            \n            // if we have r, then it better not exist\n            assertFalse(r.exists());\n        }\n        catch (InvalidPathException e)\n        {\n            // Exception is acceptable\n        }\n    }","id":11107,"modified_method":"@Test\n    public void testExist_BadURINull() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path path = dir.resolve(\"a.jsp\");\n        Files.createFile(path);\n\n        try\n        {\n            // request with null at end\n            URI uri = testdir.getDir().toURI().resolve(\"a.jsp%00\");\n            assertThat(\"Null URI\",uri,notNullValue());\n\n            Resource r = newResource(uri);\n            \n            // if we have r, then it better not exist\n            assertFalse(r.exists());\n        }\n        catch (InvalidPathException e)\n        {\n            // Exception is acceptable\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSymlink() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        Path foo = new File(dir, \"foo\").toPath();\n        Path bar = new File(dir, \"bar\").toPath();\n        \n        try\n        {\n            Files.createFile(foo);\n            Files.createSymbolicLink(bar,foo);\n        }\n        catch (UnsupportedOperationException | FileSystemException e)\n        {\n            // if unable to create symlink, no point testing the rest\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n        \n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource resFoo = base.addPath(\"foo\");\n            Resource resBar = base.addPath(\"bar\");\n            \n            assertThat(\"resFoo.uri\", resFoo.getURI(), is(foo.toUri()));\n            \n            // Access to the same resource, but via a symlink means that they are not equivalent\n            assertThat(\"foo.equals(bar)\", resFoo.equals(resBar), is(false));\n            \n            assertThat(\"resource.alias\", resFoo, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resFoo.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resFoo.getFile()), hasNoAlias());\n            \n            assertThat(\"alias\", resBar, isAliasFor(resFoo));\n            assertThat(\"uri.alias\", newResource(resBar.getURI()), isAliasFor(resFoo));\n            assertThat(\"file.alias\", newResource(resBar.getFile()), isAliasFor(resFoo));\n        }\n    }","id":11108,"modified_method":"@Test\n    public void testSymlink() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        \n        Path foo = dir.resolve(\"foo\");\n        Path bar = dir.resolve(\"bar\");\n        \n        try\n        {\n            Files.createFile(foo);\n            Files.createSymbolicLink(bar,foo);\n        }\n        catch (UnsupportedOperationException | FileSystemException e)\n        {\n            // if unable to create symlink, no point testing the rest\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource resFoo = base.addPath(\"foo\");\n            Resource resBar = base.addPath(\"bar\");\n            \n            assertThat(\"resFoo.uri\", resFoo.getURI(), is(foo.toUri()));\n            \n            // Access to the same resource, but via a symlink means that they are not equivalent\n            assertThat(\"foo.equals(bar)\", resFoo.equals(resBar), is(false));\n            \n            assertThat(\"resource.alias\", resFoo, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resFoo.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resFoo.getFile()), hasNoAlias());\n            \n            assertThat(\"alias\", resBar, isAliasFor(resFoo));\n            assertThat(\"uri.alias\", newResource(resBar.getURI()), isAliasFor(resFoo));\n            assertThat(\"file.alias\", newResource(resBar.getFile()), isAliasFor(resFoo));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testEncoding() throws Exception\n    {\n        File specials = testdir.getFile(\"a file with,spe#ials\");\n        try(Resource res= newResource(specials))\n        {\n            assertThat(\"Specials URL\", res.getURI().toASCIIString(), containsString(\"a%20file%20with,spe%23ials\"));\n            assertThat(\"Specials Filename\", res.getFile().toString(), containsString(\"a file with,spe#ials\"));\n            \n            res.delete();\n            assertThat(\"File should have been deleted.\",res.exists(),is(false));\n        }\n    }","id":11109,"modified_method":"@Test\n    public void testEncoding() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n\n        Path specials = dir.resolve(\"a file with,spe#ials\");\n        Files.createFile(specials);\n        \n        try(Resource res = newResource(specials.toFile()))\n        {\n            assertThat(\"Specials URL\", res.getURI().toASCIIString(), containsString(\"a%20file%20with,spe%23ials\"));\n            assertThat(\"Specials Filename\", res.getFile().toString(), containsString(\"a file with,spe#ials\"));\n            \n            res.delete();\n            assertThat(\"File should have been deleted.\",res.exists(),is(false));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testLength_NotExists() throws Exception\n    {\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.length\",res.length(),is(0L));\n        }\n    }","id":11110,"modified_method":"@Test\n    public void testLength_NotExists() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.length\",res.length(),is(0L));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testLastModified_NotExists() throws Exception\n    {\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.lastModified\",res.lastModified(),is(0L));\n        }\n    }","id":11111,"modified_method":"@Test\n    public void testLastModified_NotExists() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.lastModified\",res.lastModified(),is(0L));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * NTFS Alternative Data / File Streams.\n     * <p>\n     * See: http://msdn.microsoft.com/en-us/library/windows/desktop/aa364404(v=vs.85).aspx\n     * @throws Exception failed test\n     */\n    @Test\n    public void testNTFSFileDataStreamAlias() throws Exception\n    {\n        File dir = testdir.getDir();\n        Path path = new File(dir, \"testfile\").toPath();\n        Files.createFile(path);\n        \n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource resource = base.addPath(\"testfile\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            try\n            {\n                // Attempt to reference same file, but via NTFS DATA stream\n                Resource alias = base.addPath(\"testfile::$DATA\");\n                if (alias.exists())\n                {\n                    assumeThat(alias.getURI().getScheme(), is(\"http\"));\n                    \n                    // If it exists, it must be an alias\n                    assertThat(\"resource.alias\",alias,isAliasFor(resource));\n                    assertThat(\"resource.uri.alias\",newResource(alias.getURI()),isAliasFor(resource));\n                    assertThat(\"resource.file.alias\",newResource(alias.getFile()),isAliasFor(resource));\n                }\n            }\n            catch (InvalidPathException e)\n            {\n                // NTFS filesystem streams are unsupported on some platforms.\n                assumeNoException(e);\n            }\n        }\n    }","id":11112,"modified_method":"/**\n     * NTFS Alternative Data / File Streams.\n     * <p>\n     * See: http://msdn.microsoft.com/en-us/library/windows/desktop/aa364404(v=vs.85).aspx\n     * @throws Exception failed test\n     */\n    @Test\n    public void testNTFSFileDataStreamAlias() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n\n        Path path = dir.resolve(\"testfile\");\n        Files.createFile(path);\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource resource = base.addPath(\"testfile\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            try\n            {\n                // Attempt to reference same file, but via NTFS DATA stream\n                Resource alias = base.addPath(\"testfile::$DATA\");\n                if (alias.exists())\n                {\n                    assumeThat(alias.getURI().getScheme(), is(\"http\"));\n                    \n                    // If it exists, it must be an alias\n                    assertThat(\"resource.alias\",alias,isAliasFor(resource));\n                    assertThat(\"resource.uri.alias\",newResource(alias.getURI()),isAliasFor(resource));\n                    assertThat(\"resource.file.alias\",newResource(alias.getFile()),isAliasFor(resource));\n                }\n            }\n            catch (InvalidPathException e)\n            {\n                // NTFS filesystem streams are unsupported on some platforms.\n                assumeNoException(e);\n            }\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testCaseInsensitiveAlias() throws Exception\n    {\n        File dir = testdir.getDir();\n        Path path = new File(dir, \"file\").toPath();\n        Files.createFile(path);\n        \n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // Reference to actual resource that exists\n            Resource resource = base.addPath(\"file\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            // On some case insensitive file systems, lets see if an alternate\n            // case for the filename results in an alias reference\n            Resource alias = base.addPath(\"FILE\");\n            if (alias.exists())\n            {\n                // If it exists, it must be an alias\n                assertThat(\"alias\", alias, isAliasFor(resource));\n                assertThat(\"alias.uri\", newResource(alias.getURI()), isAliasFor(resource));\n                assertThat(\"alias.file\", newResource(alias.getFile()), isAliasFor(resource));\n            }\n        }\n    }","id":11113,"modified_method":"@Test\n    public void testCaseInsensitiveAlias() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        Path path = dir.resolve(\"file\");\n        Files.createFile(path);\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            // Reference to actual resource that exists\n            Resource resource = base.addPath(\"file\");\n                        \n            assertThat(\"resource.alias\", resource, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resource.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resource.getFile()), hasNoAlias());\n\n            // On some case insensitive file systems, lets see if an alternate\n            // case for the filename results in an alias reference\n            Resource alias = base.addPath(\"FILE\");\n            if (alias.exists())\n            {\n                // If it exists, it must be an alias\n                assertThat(\"alias\", alias, isAliasFor(resource));\n                assertThat(\"alias.uri\", newResource(alias.getURI()), isAliasFor(resource));\n                assertThat(\"alias.file\", newResource(alias.getFile()), isAliasFor(resource));\n            }\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetURI() throws Exception\n    {\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        URI expected = file.toURI();\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            assertThat(\"getURI\",foo.getURI(),is(expected));\n        }\n    }","id":11114,"modified_method":"@Test\n    public void testGetURI() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n\n        Path file = dir.resolve(\"foo\");\n        Files.createFile(file);\n\n        URI expected = file.toUri();\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource foo = base.addPath(\"foo\");\n            assertThat(\"getURI\",foo.getURI(),is(expected));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testBrackets() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = new File(dir, \"foo[1]\").toPath();\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo[1]\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","id":11115,"modified_method":"@Test\n    public void testBrackets() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try\n        {\n            // attempt to create file\n            Path foo = dir.resolve(\"foo[1]\");\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo[1]\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testLength() throws Exception\n    {\n        File file = testdir.getFile(\"foo\");\n        file.createNewFile();\n\n        try (StringReader reader = new StringReader(\"foo\"); FileWriter writer = new FileWriter(file))\n        {\n            IO.copy(reader,writer);\n        }\n\n        long expected = file.length();\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.length\",res.length(),is(expected));\n        }\n    }","id":11116,"modified_method":"@Test\n    public void testLength() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path file = dir.resolve(\"foo\");\n\n        try (StringReader reader = new StringReader(\"foo\");\n             BufferedWriter writer = Files.newBufferedWriter(file))\n        {\n            IO.copy(reader,writer);\n        }\n\n        long expected = Files.size(file);\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.length\",res.length(),is(expected));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testNonExistantSymlink() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        Path foo = new File(dir, \"foo\").toPath();\n        Path bar = new File(dir, \"bar\").toPath();\n        \n        try\n        {\n            Files.createSymbolicLink(bar,foo);\n        }\n        catch (UnsupportedOperationException | FileSystemException e)\n        {\n            // if unable to create symlink, no point testing the rest\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n        \n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n            \n            Resource resFoo = base.addPath(\"foo\");\n            Resource resBar = base.addPath(\"bar\");\n            \n            assertThat(\"resFoo.uri\", resFoo.getURI(), is(foo.toUri()));\n            \n            // Access to the same resource, but via a symlink means that they are not equivalent\n            assertThat(\"foo.equals(bar)\", resFoo.equals(resBar), is(false));\n            \n            assertThat(\"resource.alias\", resFoo, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resFoo.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resFoo.getFile()), hasNoAlias());\n            \n            assertThat(\"alias\", resBar, isAliasFor(resFoo));\n            assertThat(\"uri.alias\", newResource(resBar.getURI()), isAliasFor(resFoo));\n            assertThat(\"file.alias\", newResource(resBar.getFile()), isAliasFor(resFoo));\n        }\n    }","id":11117,"modified_method":"@Test\n    public void testNonExistantSymlink() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        Path foo = dir.resolve(\"foo\");\n        Path bar = dir.resolve(\"bar\");\n        \n        try\n        {\n            Files.createSymbolicLink(bar,foo);\n        }\n        catch (UnsupportedOperationException | FileSystemException e)\n        {\n            // if unable to create symlink, no point testing the rest\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n        \n        try (Resource base = newResource(dir.toFile()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n            \n            Resource resFoo = base.addPath(\"foo\");\n            Resource resBar = base.addPath(\"bar\");\n            \n            assertThat(\"resFoo.uri\", resFoo.getURI(), is(foo.toUri()));\n            \n            // Access to the same resource, but via a symlink means that they are not equivalent\n            assertThat(\"foo.equals(bar)\", resFoo.equals(resBar), is(false));\n            \n            assertThat(\"resource.alias\", resFoo, hasNoAlias());\n            assertThat(\"resource.uri.alias\", newResource(resFoo.getURI()), hasNoAlias());\n            assertThat(\"resource.file.alias\", newResource(resFoo.getFile()), hasNoAlias());\n            \n            assertThat(\"alias\", resBar, isAliasFor(resFoo));\n            assertThat(\"uri.alias\", newResource(resBar.getURI()), isAliasFor(resFoo));\n            assertThat(\"file.alias\", newResource(resBar.getFile()), isAliasFor(resFoo));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAddRootPath() throws Exception\n    {\n        File dir = testdir.getDir();\n        File subdir = new File(dir,\"sub\");\n        FS.ensureDirExists(subdir);\n\n        String readableRootDir = findRootDir(dir.toPath().getFileSystem());\n        assumeThat(\"Readable Root Dir found\",readableRootDir,notNullValue());\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource sub = base.addPath(\"sub\");\n            assertThat(\"sub\",sub.isDirectory(),is(true));\n\n            Resource rrd = sub.addPath(readableRootDir);\n            assertThat(\"Readable Root Dir\",rrd.exists(),is(false));\n        }\n    }","id":11118,"modified_method":"@Test\n    public void testAddRootPath() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Path subdir = dir.resolve(\"sub\");\n        Files.createDirectories(subdir);\n\n        String readableRootDir = findRootDir(dir.getFileSystem());\n        assumeThat(\"Readable Root Dir found\",readableRootDir,notNullValue());\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource sub = base.addPath(\"sub\");\n            assertThat(\"sub\",sub.isDirectory(),is(true));\n\n            Resource rrd = sub.addPath(readableRootDir);\n            assertThat(\"Readable Root Dir\",rrd.exists(),is(false));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testIsDirectory() throws Exception\n    {\n        File dir = testdir.getDir();\n        createEmptyFile(\"foo\");\n\n        File subdir = new File(dir,\"sub\");\n        FS.ensureDirExists(subdir);\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.isDirectory\",res.isDirectory(),is(false));\n\n            Resource sub = base.addPath(\"sub\");\n            assertThat(\"sub/.isDirectory\",sub.isDirectory(),is(true));\n        }\n    }","id":11119,"modified_method":"@Test\n    public void testIsDirectory() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        Path foo = dir.resolve(\"foo\");\n        Files.createFile(foo);\n\n        Path subdir = dir.resolve(\"sub\");\n        Files.createDirectories(subdir);\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo\");\n            assertThat(\"foo.isDirectory\",res.isDirectory(),is(false));\n\n            Resource sub = base.addPath(\"sub\");\n            assertThat(\"sub/.isDirectory\",sub.isDirectory(),is(true));\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSemicolon() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = new File(dir, \"foo;\").toPath();\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            Resource res = base.addPath(\"foo;\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","id":11120,"modified_method":"@Test\n    public void testSemicolon() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = dir.resolve(\"foo;\");\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            Resource res = base.addPath(\"foo;\");\n            assertThat(\"Alias: \" + res,res,hasNoAlias());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testCaret() throws Exception\n    {\n        File dir = testdir.getDir();\n        \n        try\n        {\n            // attempt to create file\n            Path foo = new File(dir, \"foo^3.txt\").toPath();\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(testdir.getDir()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo^3.txt\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","id":11121,"modified_method":"@Test\n    public void testCaret() throws Exception\n    {\n        Path dir = testdir.getDir().toPath().normalize().toRealPath();\n        Files.createDirectories(dir);\n        \n        try\n        {\n            // attempt to create file\n            Path foo = dir.resolve(\"foo^3.txt\");\n            Files.createFile(foo);\n        }\n        catch (Exception e)\n        {\n            // if unable to create file, no point testing the rest.\n            // this is the path that Microsoft Windows takes.\n            assumeNoException(e);\n        }\n\n        try (Resource base = newResource(dir.toFile()))\n        {\n            // FileResource does not pass this test!\n            assumeFalse(base instanceof FileResource);\n\n            Resource res = base.addPath(\"foo^3.txt\");\n            assertThat(\"Alias: \" + res,res.getAlias(),nullValue());\n        }\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@BeforeClass\n    public static void setUpBeforeClass() throws Exception\n    {\n        _directory = MavenTestingUtils.getTargetTestingDir(ScannerTest.class.getSimpleName());\n        FS.ensureEmpty(_directory);\n\n        _scanner = new Scanner();\n        _scanner.addScanDir(_directory);\n        _scanner.setScanInterval(0);\n        _scanner.addListener(new Scanner.DiscreteListener()\n        {\n            public void fileRemoved(String filename) throws Exception\n            {\n                _queue.add(new Event(filename,Notification.REMOVED));\n            }\n\n            public void fileChanged(String filename) throws Exception\n            {\n                _queue.add(new Event(filename,Notification.CHANGED));\n            }\n\n            public void fileAdded(String filename) throws Exception\n            {\n                _queue.add(new Event(filename,Notification.ADDED));\n            }\n        });\n        _scanner.addListener(new Scanner.BulkListener()\n        {\n            public void filesChanged(List<String> filenames) throws Exception\n            {\n                _bulk.add(filenames);\n            }\n        });\n        _scanner.start();\n\n        _scanner.scan();\n        \n        Assert.assertTrue(_queue.isEmpty());\n        Assert.assertTrue(_bulk.isEmpty());\n    }","id":11122,"modified_method":"@BeforeClass\n    public static void setUpBeforeClass() throws Exception\n    {\n        File testDir = MavenTestingUtils.getTargetTestingDir(ScannerTest.class.getSimpleName());\n        FS.ensureEmpty(testDir);\n        \n        // Use full path, pointing to a real directory (for FileSystems that are case-insensitive, like Windows and OSX to use)\n        // This is only needed for the various comparisons below to make sense.\n        _directory = testDir.toPath().toRealPath().toFile();\n\n        _scanner = new Scanner();\n        _scanner.addScanDir(_directory);\n        _scanner.setScanInterval(0);\n        _scanner.addListener(new Scanner.DiscreteListener()\n        {\n            public void fileRemoved(String filename) throws Exception\n            {\n                _queue.add(new Event(filename,Notification.REMOVED));\n            }\n\n            public void fileChanged(String filename) throws Exception\n            {\n                _queue.add(new Event(filename,Notification.CHANGED));\n            }\n\n            public void fileAdded(String filename) throws Exception\n            {\n                _queue.add(new Event(filename,Notification.ADDED));\n            }\n        });\n        _scanner.addListener(new Scanner.BulkListener()\n        {\n            public void filesChanged(List<String> filenames) throws Exception\n            {\n                _bulk.add(filenames);\n            }\n        });\n        _scanner.start();\n\n        _scanner.scan();\n        \n        Assert.assertTrue(_queue.isEmpty());\n        Assert.assertTrue(_bulk.isEmpty());\n    }","commit_id":"c4eb2da79c473e18f5b4063a28da1db7785d1ef2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        // defaults\r\n        prop.put(\"delay\", \"3600\");\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n\r\n        // seed hash of requester\r\n        String ohash = post.get(\"iam\", \"\");\r\n        if (ohash == null || ohash.length() == 0 ) return prop;\r\n        yacySeed oseed = yacyCore.seedDB.get(ohash);\r\n        if (oseed == null) return prop;\r\n        oseed.setFlagDirectConnect(true);\r\n        oseed.setLastSeenUTC();\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverLog log = sb.getLog();\r\n\r\n        //int proxyPrefetchDepth = Integer.parseInt(env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n        //int crawlingDepth = Integer.parseInt(env.getConfig(\"crawlingDepth\", \"0\"));\r\n\r\n        // request values\r\n        String youare     = post.get(\"youare\", \"\");    // seed hash of the target peer, needed for network stability\r\n        //String process    = post.get(\"process\", \"\");  // process type\r\n        String key        = post.get(\"key\", \"\");      // transmission key\r\n        //String receivedUrlhash    = post.get(\"urlhash\", \"\");  // the url hash that has been crawled\r\n        String result     = post.get(\"result\", \"\");   // the result; either \"ok\" or \"fail\"\r\n        String reason     = post.get(\"reason\", \"\");   // the reason for that result\r\n        //String words      = post.get(\"wordh\", \"\");    // priority word hashes\r\n        String propStr    = crypt.simpleDecode(post.get(\"lurlEntry\", \"\"), key);\r\n        \r\n        /*\r\n         the result can have one of the following values:\r\n         negative cases, no retry\r\n           unavailable - the resource is not available (a broken link); not found or interrupted\r\n           exception   - an exception occurred\r\n           robot       - a robot-file has denied to crawl that resource\r\n\r\n         negative cases, retry possible\r\n           rejected    - the peer has rejected to load the resource\r\n           dequeue     - peer too busy - rejected to crawl\r\n         \r\n         positive cases with crawling\r\n           fill        - the resource was loaded and processed\r\n           update      - the resource was already in database but re-loaded and processed\r\n\t \r\n         positive cases without crawling\t \r\n           known       - the resource is already in database, believed to be fresh and not reloaded\r\n           stale       - the resource was reloaded but not processed because source had no changes\r\n\r\n        */\r\n\r\n        \r\n\r\n        if ((yacyCore.seedDB.mySeed() == null) || (!(yacyCore.seedDB.mySeed().hash.equals(youare)))) {\r\n            // no yacy connection / unknown peers\r\n            return prop;\r\n        }\r\n        \r\n        if (propStr == null) {\r\n            // error with url / wrong key\r\n            return prop;\r\n        }\r\n        \r\n        if ((sb.isRobinsonMode()) && (!sb.isInMyCluster(oseed))) {\r\n        \t// we reject urls that are from outside our cluster\r\n        \tprop.put(\"delay\", \"9999\");\r\n            return prop; // ???\r\n    \t}\r\n        \r\n        // generating a new loaded URL entry\r\n        indexURLEntry entry = sb.wordIndex.loadedURL.newEntry(propStr);\r\n        if (entry == null) {\r\n            log.logWarning(\"crawlReceipt: RECEIVED wrong RECEIPT (entry null) from peer \" + ohash + \"\\n\\tURL properties: \"+ propStr);\r\n            return prop;\r\n        }\r\n        \r\n        indexURLEntry.Components comp = entry.comp();\r\n        if (comp.url() == null) {\r\n            log.logWarning(\"crawlReceipt: RECEIVED wrong RECEIPT (url null) for hash \" + entry.hash() + \" from peer \" + ohash + \"\\n\\tURL properties: \"+ propStr);\r\n            return prop;\r\n        }\r\n        \r\n        // check if the entry is in our network domain\r\n        if (!sb.acceptURL(comp.url())) {\r\n            log.logWarning(\"crawlReceipt: RECEIVED wrong RECEIPT (url outside of our domain) for hash \" + entry.hash() + \" from peer \" + ohash + \"\\n\\tURL properties: \"+ propStr);\r\n            prop.put(\"delay\", \"9999\");\r\n            return prop;\r\n        }\r\n        \r\n        if (result.equals(\"fill\")) try {\r\n            // put new entry into database\r\n            sb.wordIndex.loadedURL.store(entry);\r\n            sb.wordIndex.loadedURL.stack(entry, youare, ohash, 1);\r\n            sb.crawlQueues.delegatedURL.remove(entry.hash()); // the delegated work has been done\r\n            final String otherPeerName = ohash + \":\" + oseed.getName() + \"/\" + oseed.getVersion();\r\n            log.logInfo(\"crawlReceipt: RECEIVED RECEIPT from \" + otherPeerName + \" for URL \" + entry.hash() + \":\" + comp.url().toNormalform(false, true));\r\n\r\n            // ready for more\r\n            prop.put(\"delay\", \"10\");\r\n            return prop;\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return prop;\r\n        }\r\n\r\n        sb.crawlQueues.delegatedURL.remove(entry.hash()); // the delegated work is transformed into an error case\r\n        plasmaCrawlZURL.Entry ee = sb.crawlQueues.errorURL.newEntry(entry.toBalancerEntry(), youare, null, 0, result + \":\" + reason);\r\n        ee.store();\r\n        sb.crawlQueues.errorURL.push(ee);\r\n        //switchboard.noticeURL.remove(receivedUrlhash);\r\n        return prop;\r\n\t\r\n         // return rewrite properties\r\n\t\r\n    }","id":11123,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        \r\n        serverLog log = switchboard.getLog();\r\n\r\n        //int proxyPrefetchDepth = Integer.parseInt(env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n        //int crawlingDepth = Integer.parseInt(env.getConfig(\"crawlingDepth\", \"0\"));\r\n\r\n        // request values\r\n        String iam        = post.get(\"iam\", \"\");      // seed hash of requester\r\n        String youare     = post.get(\"youare\", \"\");    // seed hash of the target peer, needed for network stability\r\n        //String process    = post.get(\"process\", \"\");  // process type\r\n        String key        = post.get(\"key\", \"\");      // transmission key\r\n        //String receivedUrlhash    = post.get(\"urlhash\", \"\");  // the url hash that has been crawled\r\n        String result     = post.get(\"result\", \"\");   // the result; either \"ok\" or \"fail\"\r\n        String reason     = post.get(\"reason\", \"\");   // the reason for that result\r\n        //String words      = post.get(\"wordh\", \"\");    // priority word hashes\r\n        String propStr    = crypt.simpleDecode(post.get(\"lurlEntry\", \"\"), key);\r\n        \r\n        /*\r\n         the result can have one of the following values:\r\n         negative cases, no retry\r\n           unavailable - the resource is not available (a broken link); not found or interrupted\r\n           exception   - an exception occurred\r\n           robot       - a robot-file has denied to crawl that resource\r\n\r\n         negative cases, retry possible\r\n           rejected    - the peer has rejected to load the resource\r\n           dequeue     - peer too busy - rejected to crawl\r\n         \r\n         positive cases with crawling\r\n           fill        - the resource was loaded and processed\r\n           update      - the resource was already in database but re-loaded and processed\r\n\t \r\n         positive cases without crawling\t \r\n           known       - the resource is already in database, believed to be fresh and not reloaded\r\n           stale       - the resource was reloaded but not processed because source had no changes\r\n\r\n        */\r\n        \r\n        final yacySeed otherPeer = yacyCore.seedDB.get(iam);\r\n        final String otherPeerName = iam + \":\" + ((otherPeer == null) ? \"NULL\" : (otherPeer.getName() + \"/\" + otherPeer.getVersion()));        \r\n\r\n        if ((yacyCore.seedDB.mySeed() == null) || (!(yacyCore.seedDB.mySeed().hash.equals(youare)))) {\r\n            // no yacy connection / unknown peers\r\n            prop.put(\"delay\", \"3600\");\r\n            return prop;\r\n        }\r\n        \r\n        if (propStr == null) {\r\n            // error with url / wrong key\r\n            prop.put(\"delay\", \"3600\");\r\n            return prop;\r\n        }\r\n        \r\n        if ((switchboard.isRobinsonMode()) && (!switchboard.isInMyCluster(otherPeer))) {\r\n        \t// we reject urls that are from outside our cluster\r\n        \tprop.put(\"delay\", \"9999\");\r\n    \t}\r\n        \r\n        // generating a new loaded URL entry\r\n        indexURLEntry entry = switchboard.wordIndex.loadedURL.newEntry(propStr);\r\n        if (entry == null) {\r\n            log.logWarning(\"crawlReceipt: RECEIVED wrong RECEIPT (entry null) from peer \" + iam + \"\\n\\tURL properties: \"+ propStr);\r\n            prop.put(\"delay\", \"3600\");\r\n            return prop;\r\n        }\r\n        \r\n        indexURLEntry.Components comp = entry.comp();\r\n        if (comp.url() == null) {\r\n            log.logWarning(\"crawlReceipt: RECEIVED wrong RECEIPT (url null) for hash \" + entry.hash() + \" from peer \" + iam + \"\\n\\tURL properties: \"+ propStr);\r\n            prop.put(\"delay\", \"3600\");\r\n            return prop;\r\n        }\r\n        \r\n        // check if the entry is in our network domain\r\n        if (!switchboard.acceptURL(comp.url())) {\r\n            log.logWarning(\"crawlReceipt: RECEIVED wrong RECEIPT (url outside of our domain) for hash \" + entry.hash() + \" from peer \" + iam + \"\\n\\tURL properties: \"+ propStr);\r\n            prop.put(\"delay\", \"9999\");\r\n            return prop;\r\n        }\r\n        \r\n        if (result.equals(\"fill\")) try {\r\n            // put new entry into database\r\n            switchboard.wordIndex.loadedURL.store(entry);\r\n            switchboard.wordIndex.loadedURL.stack(entry, youare, iam, 1);\r\n            switchboard.crawlQueues.delegatedURL.remove(entry.hash()); // the delegated work has been done\r\n            log.logInfo(\"crawlReceipt: RECEIVED RECEIPT from \" + otherPeerName + \" for URL \" + entry.hash() + \":\" + comp.url().toNormalform(false, true));\r\n\r\n            // ready for more\r\n            prop.put(\"delay\", \"10\");\r\n            return prop;\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            prop.put(\"delay\", \"3600\");\r\n            return prop;\r\n        }\r\n\r\n        switchboard.crawlQueues.delegatedURL.remove(entry.hash()); // the delegated work is transformed into an error case\r\n        plasmaCrawlZURL.Entry ee = switchboard.crawlQueues.errorURL.newEntry(entry.toBalancerEntry(), youare, null, 0, result + \":\" + reason);\r\n        ee.store();\r\n        switchboard.crawlQueues.errorURL.push(ee);\r\n        //switchboard.noticeURL.remove(receivedUrlhash);\r\n        prop.put(\"delay\", \"3600\");\r\n        return prop;\r\n\t\r\n         // return rewrite properties\r\n\t\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws InterruptedException {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        if (post == null || env == null) {\r\n            prop.put(\"message\", \"no post or no enviroment\");\r\n            return prop;\r\n        }\r\n        if (!yacyNetwork.authentifyRequest(post, env)) {\r\n            prop.put(\"message\", \"not in my network\");\r\n            return prop;\r\n        }\r\n        prop.put(\"message\", \"none\");\r\n\r\n//      final String iam      = (String) post.get(\"iam\", \"\");      // complete seed of the requesting peer\r\n//      final String mytime   = (String) post.get(MYTIME, \"\"); //\r\n        final String key      = post.get(\"key\", \"\");      // transmission key for response\r\n        final String seed     = post.get(\"seed\", \"\");\r\n        final String countStr = post.get(\"count\", \"0\");\r\n        int  count = 0;\r\n        try {count = (countStr == null) ? 0 : Integer.parseInt(countStr);} catch (NumberFormatException e) {count = 0;}\r\n//      final Date remoteTime = yacyCore.parseUniversalDate((String) post.get(MYTIME)); // read remote time\r\n        if (seed.length() > yacySeed.maxsize) {\r\n        \tyacyCore.log.logInfo(\"hello/server: rejected contacting seed; too large (\" + seed.length() + \" > \" + yacySeed.maxsize + \")\");\r\n            prop.put(\"message\", \"your seed is too long (\" + seed.length() + \")\");\r\n            return prop;\r\n        }\r\n        final yacySeed oseed = yacySeed.genRemoteSeed(seed, key, false);\r\n\r\n//      System.out.println(\"YACYHELLO: REMOTESEED=\" + ((remoteSeed == null) ? \"NULL\" : remoteSeed.toString()));\r\n        if (oseed == null || oseed.hash == null) {\r\n            prop.put(\"message\", \"cannot parse your seed\");\r\n            return prop;\r\n        }\r\n\r\n//      final String properTest = remoteSeed.isProper();\r\n        // The remote peer might not know its IP yet, so don't abort if the IP check fails\r\n//      if ((properTest != null) && (! properTest.substring(0,1).equals(\"IP\"))) { return null; }\r\n\r\n        // we easily know the caller's IP:\r\n        final String clientip = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP, \"<unknown>\"); // read an artificial header addendum\r\n        InetAddress ias = serverDomains.dnsResolve(clientip);\r\n        if (ias == null) {\r\n            prop.put(\"message\", \"cannot resolve your IP from your reported location \" + clientip);\r\n            return prop;\r\n        }\r\n        final String userAgent = (String) header.get(httpHeader.USER_AGENT, \"<unknown>\");\r\n        final String reportedip = oseed.get(yacySeed.IP, \"\");\r\n        final String reportedPeerType = oseed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_JUNIOR);\r\n        final float clientversion = oseed.getVersion();\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        if (sb.isRobinsonMode() && !sb.isPublicRobinson()) {\r\n            // if we are a robinson cluster, answer only if this client is known by our network definition\r\n            prop.put(\"message\", \"I am robinson, I do not answer\");\r\n            return prop;\r\n        }\r\n\r\n        int urls = -1;\r\n        if (sb.clusterhashes != null) oseed.setAlternativeAddress((String) sb.clusterhashes.get(oseed.hash));\r\n        \r\n        // if the remote client has reported its own IP address and the client supports\r\n        // the port forwarding feature (if client version >= 0.383) then we try to \r\n        // connect to the reported IP address first\r\n        if (reportedip.length() > 0 && !clientip.equals(reportedip) && clientversion >= yacyVersion.YACY_SUPPORTS_PORT_FORWARDING) {            \r\n            serverCore.checkInterruption();\r\n            \r\n            // try first the reportedip, since this may be a connect from a port-forwarding host\r\n            prop.put(\"yourip\", reportedip);\r\n            oseed.put(yacySeed.IP, reportedip);\r\n            urls = yacyClient.queryUrlCount(oseed);\r\n        } else {\r\n            prop.put(\"yourip\", \"unknown\");\r\n        }\r\n\r\n        // if the previous attempt (using the reported ip address) was not successful, try the ip where \r\n        // the request came from\r\n        if (urls < 0) {\r\n        \tboolean isNotLocal = true;\r\n        \t\r\n        \t// we are only allowed to connect to the client IP address if it's not our own address\r\n        \tif (serverCore.portForwardingEnabled || serverCore.useStaticIP) {\r\n        \t\tisNotLocal = !ias.isSiteLocalAddress();\r\n            }\r\n        \tif (isNotLocal) {\r\n        \t\tserverCore.checkInterruption();\r\n                \r\n                prop.put(\"yourip\", clientip);\r\n                oseed.put(yacySeed.IP, clientip);\r\n                urls = yacyClient.queryUrlCount(oseed);\r\n        \t}\r\n        }\r\n\r\n//      System.out.println(\"YACYHELLO: YOUR IP=\" + clientip);\r\n        // set lastseen value (we have seen that peer, it contacted us!)\r\n        oseed.setLastSeenUTC();\r\n        \r\n        // assign status\r\n        if (urls >= 0) {\r\n            if (oseed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR) == null) {\r\n                prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_SENIOR);\r\n                oseed.put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR);\r\n            } else if (oseed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_PRINCIPAL).equals(yacySeed.PEERTYPE_PRINCIPAL)) {\r\n                prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_PRINCIPAL);\r\n            } else {\r\n                prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_SENIOR);\r\n                oseed.put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR);\r\n            }\r\n            // connect the seed\r\n            yacyCore.peerActions.peerArrival(oseed, true);\r\n        } else {\r\n            prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_JUNIOR);\r\n            yacyCore.peerActions.juniorConnects++; // update statistics\r\n            oseed.put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_JUNIOR);\r\n            yacyCore.log.logInfo(\"hello: responded remote junior peer '\" + oseed.getName() + \"' from \" + reportedip);\r\n            // no connection here, instead store junior in connection cache\r\n            if ((oseed.hash != null) && (oseed.isProper() == null)) {\r\n                yacyCore.peerActions.peerPing(oseed);\r\n            }\r\n        }\r\n        yacyCore.peerActions.setUserAgent(clientip, userAgent);\r\n        if (!((String)prop.get(yacySeed.YOURTYPE)).equals(reportedPeerType)) {\r\n            yacyCore.log.logInfo(\"hello: changing remote peer '\" + oseed.getName() +\r\n                                                           \"' [\" + reportedip +\r\n                                             \"] peerType from '\" + reportedPeerType +\r\n                                                        \"' to '\" + prop.get(yacySeed.YOURTYPE) + \"'.\");\r\n        }\r\n\r\n        serverCore.checkInterruption();\r\n        final StringBuffer seeds = new StringBuffer(768);\r\n        // attach some more seeds, as requested\r\n        if ((yacyCore.seedDB != null) && (yacyCore.seedDB.sizeConnected() > 0)) {\r\n            if (count > yacyCore.seedDB.sizeConnected()) { count = yacyCore.seedDB.sizeConnected(); }\r\n            if (count > 100) { count = 100; }\r\n            \r\n            // latest seeds\r\n            final Map<String, yacySeed> ySeeds = yacyCore.seedDB.seedsByAge(true, count); // peerhash/yacySeed relation\r\n            \r\n            // attach also my own seed\r\n            seeds.append(\"seed0=\").append(yacyCore.seedDB.mySeed().genSeedStr(key)).append(serverCore.CRLF_STRING);\r\n            count = 1;            \r\n            \r\n            // attach other seeds\r\n            if (ySeeds != null) {\r\n                seeds.ensureCapacity((ySeeds.size() + 1) * 768);\r\n                Iterator<yacySeed> si = ySeeds.values().iterator();\r\n                yacySeed s;\r\n                while (si.hasNext()) {\r\n                \ts = (yacySeed) si.next();\r\n                    if ((s != null) && (s.isProper() == null)) {\r\n                        seeds.append(\"seed\").append(count).append('=').append(s.genSeedStr(key)).append(serverCore.CRLF_STRING);\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // attach also my own seed\r\n            seeds.append(\"seed0=\").append(yacyCore.seedDB.mySeed().genSeedStr(key)).append(serverCore.CRLF_STRING);\r\n        }\r\n\r\n        prop.put(\"seedlist\", seeds.toString());\r\n        // return rewrite properties\r\n        prop.put(\"message\", \"ok \" + seed.length());\r\n        return prop;\r\n    }","id":11124,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws InterruptedException {\r\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        prop.put(\"message\", \"none\");\r\n        if ((post == null) || (env == null)) {\r\n            prop.put(\"message\", \"no post or no enviroment\");\r\n            return prop;\r\n        }\r\n        if (!yacyNetwork.authentifyRequest(post, env)) {\r\n            prop.put(\"message\", \"not in my network\");\r\n            return prop;\r\n        }\r\n        \r\n//      final String iam      = (String) post.get(\"iam\", \"\");      // complete seed of the requesting peer\r\n//      final String mytime   = (String) post.get(MYTIME, \"\"); //\r\n        final String key      = post.get(\"key\", \"\");      // transmission key for response\r\n        final String seed     = post.get(\"seed\", \"\");\r\n        final String countStr = post.get(\"count\", \"0\");\r\n        int  count = 0;\r\n        try {count = (countStr == null) ? 0 : Integer.parseInt(countStr);} catch (NumberFormatException e) {count = 0;}\r\n//      final Date remoteTime = yacyCore.parseUniversalDate((String) post.get(MYTIME)); // read remote time\r\n        if (seed.length() > yacySeed.maxsize) {\r\n        \tyacyCore.log.logInfo(\"hello/server: rejected contacting seed; too large (\" + seed.length() + \" > \" + yacySeed.maxsize + \")\");\r\n            prop.put(\"message\", \"your seed is too long (\" + seed.length() + \")\");\r\n            return prop;\r\n        }\r\n        final yacySeed remoteSeed = yacySeed.genRemoteSeed(seed, key, false);\r\n\r\n//      System.out.println(\"YACYHELLO: REMOTESEED=\" + ((remoteSeed == null) ? \"NULL\" : remoteSeed.toString()));\r\n        if ((remoteSeed == null) || (remoteSeed.hash == null)) {\r\n            prop.put(\"message\", \"cannot parse your seed\");\r\n            return prop;\r\n        }\r\n        \r\n//      final String properTest = remoteSeed.isProper();\r\n        // The remote peer might not know its IP yet, so don't abort if the IP check fails\r\n//      if ((properTest != null) && (! properTest.substring(0,1).equals(\"IP\"))) { return null; }\r\n\r\n        // we easily know the caller's IP:\r\n        final String clientip = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP, \"<unknown>\"); // read an artificial header addendum\r\n        InetAddress ias = serverDomains.dnsResolve(clientip);\r\n        if (ias == null) {\r\n            prop.put(\"message\", \"cannot resolve your IP from your reported location \" + clientip);\r\n            return prop;\r\n        }\r\n        final String userAgent = (String) header.get(httpHeader.USER_AGENT, \"<unknown>\");\r\n        final String reportedip = remoteSeed.get(yacySeed.IP, \"\");\r\n        final String reportedPeerType = remoteSeed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_JUNIOR);\r\n        final float clientversion = remoteSeed.getVersion();\r\n\r\n        if ((sb.isRobinsonMode()) && (!sb.isPublicRobinson())) {\r\n        \t// if we are a robinson cluster, answer only if this client is known by our network definition\r\n            prop.put(\"message\", \"I am robinson, I do not answer\");\r\n            return prop;\r\n        }\r\n        \r\n        int urls = -1;\r\n        if (sb.clusterhashes != null) remoteSeed.setAlternativeAddress((String) sb.clusterhashes.get(remoteSeed.hash));\r\n        \r\n        // if the remote client has reported its own IP address and the client supports\r\n        // the port forwarding feature (if client version >= 0.383) then we try to \r\n        // connect to the reported IP address first\r\n        if (reportedip.length() > 0 && !clientip.equals(reportedip) && clientversion >= yacyVersion.YACY_SUPPORTS_PORT_FORWARDING) {            \r\n            serverCore.checkInterruption();\r\n            \r\n            // try first the reportedip, since this may be a connect from a port-forwarding host\r\n            prop.put(\"yourip\", reportedip);\r\n            remoteSeed.put(yacySeed.IP, reportedip);\r\n            urls = yacyClient.queryUrlCount(remoteSeed);\r\n        } else {\r\n            prop.put(\"yourip\", \"unknown\");\r\n        }\r\n\r\n        // if the previous attempt (using the reported ip address) was not successful, try the ip where \r\n        // the request came from\r\n        if (urls < 0) {\r\n        \tboolean isNotLocal = true;\r\n        \t\r\n        \t// we are only allowed to connect to the client IP address if it's not our own address\r\n        \tif (serverCore.portForwardingEnabled || serverCore.useStaticIP) {\r\n        \t\tisNotLocal = !ias.isSiteLocalAddress();\r\n            }\r\n        \tif (isNotLocal) {\r\n        \t\tserverCore.checkInterruption();\r\n                \r\n                prop.put(\"yourip\", clientip);\r\n                remoteSeed.put(yacySeed.IP, clientip);\r\n                urls = yacyClient.queryUrlCount(remoteSeed);\r\n        \t}\r\n        }\r\n\r\n//      System.out.println(\"YACYHELLO: YOUR IP=\" + clientip);\r\n        // set lastseen value (we have seen that peer, it contacted us!)\r\n        remoteSeed.setLastSeenUTC();\r\n        \r\n        // assign status\r\n        if (urls >= 0) {\r\n            if (remoteSeed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR) == null) {\r\n                prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_SENIOR);\r\n                remoteSeed.put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR);\r\n            } else if (remoteSeed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_PRINCIPAL).equals(yacySeed.PEERTYPE_PRINCIPAL)) {\r\n                prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_PRINCIPAL);\r\n            } else {\r\n                prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_SENIOR);\r\n                remoteSeed.put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR);\r\n            }\r\n            // connect the seed\r\n            yacyCore.peerActions.peerArrival(remoteSeed, true);\r\n        } else {\r\n            prop.put(yacySeed.YOURTYPE, yacySeed.PEERTYPE_JUNIOR);\r\n            yacyCore.peerActions.juniorConnects++; // update statistics\r\n            remoteSeed.put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_JUNIOR);\r\n            yacyCore.log.logInfo(\"hello: responded remote junior peer '\" + remoteSeed.getName() + \"' from \" + reportedip);\r\n            // no connection here, instead store junior in connection cache\r\n            if ((remoteSeed.hash != null) && (remoteSeed.isProper() == null)) {\r\n                yacyCore.peerActions.peerPing(remoteSeed);\r\n            }\r\n        }\r\n        yacyCore.peerActions.setUserAgent(clientip, userAgent);\r\n        if (!((String)prop.get(yacySeed.YOURTYPE)).equals(reportedPeerType)) {\r\n            yacyCore.log.logInfo(\"hello: changing remote peer '\" + remoteSeed.getName() +\r\n                                                           \"' [\" + reportedip +\r\n                                             \"] peerType from '\" + reportedPeerType +\r\n                                                        \"' to '\" + prop.get(yacySeed.YOURTYPE) + \"'.\");\r\n        }\r\n\r\n        serverCore.checkInterruption();\r\n        final StringBuffer seeds = new StringBuffer(768);\r\n        // attach some more seeds, as requested\r\n        if ((yacyCore.seedDB != null) && (yacyCore.seedDB.sizeConnected() > 0)) {\r\n            if (count > yacyCore.seedDB.sizeConnected()) { count = yacyCore.seedDB.sizeConnected(); }\r\n            if (count > 100) { count = 100; }\r\n            \r\n            // latest seeds\r\n            final Map<String, yacySeed> ySeeds = yacyCore.seedDB.seedsByAge(true, count); // peerhash/yacySeed relation\r\n            \r\n            // attach also my own seed\r\n            seeds.append(\"seed0=\").append(yacyCore.seedDB.mySeed().genSeedStr(key)).append(serverCore.CRLF_STRING);\r\n            count = 1;            \r\n            \r\n            // attach other seeds\r\n            if (ySeeds != null) {\r\n                seeds.ensureCapacity((ySeeds.size() + 1) * 768);\r\n                Iterator<yacySeed> si = ySeeds.values().iterator();\r\n                yacySeed s;\r\n                while (si.hasNext()) {\r\n                \ts = (yacySeed) si.next();\r\n                    if ((s != null) && (s.isProper() == null)) {\r\n                        seeds.append(\"seed\").append(count).append('=').append(s.genSeedStr(key)).append(serverCore.CRLF_STRING);\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // attach also my own seed\r\n            seeds.append(\"seed0=\").append(yacyCore.seedDB.mySeed().genSeedStr(key)).append(serverCore.CRLF_STRING);\r\n        }\r\n\r\n        prop.put(\"seedlist\", seeds.toString());\r\n        // return rewrite properties\r\n        prop.put(\"message\", \"ok \" + seed.length());\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        // defaults\r\n        prop.put(\"response\", \"-1\"); // request rejected\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n\r\n        String process = post.get(\"process\", \"permission\");\r\n        String key = post.get(\"key\", \"\");\r\n\r\n        int messagesize = 10240;\r\n        int attachmentsize = 0;\r\n\r\n        prop.put(\"messagesize\", \"0\");\r\n        prop.put(\"attachmentsize\", \"0\");\r\n\r\n        String youare = post.get(\"youare\", \"\"); // seed hash of the target peer, needed for network stability\r\n        // check if we are the right target and requester has correct information about this peer\r\n        if ((yacyCore.seedDB.mySeed() == null) || (!(yacyCore.seedDB.mySeed().hash.equals(youare)))) {\r\n            // this request has a wrong target\r\n            return prop;\r\n        }\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        if (sb.isRobinsonMode() &&\r\n            !(sb.isPublicRobinson() ||\r\n              sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))) {\r\n            // if we are a robinson cluster, answer only if this client is known by our network definition            \r\n            return prop;\r\n        }\r\n\r\n        prop.put(\"messagesize\", Integer.toString(messagesize));\r\n        prop.put(\"attachmentsize\", Integer.toString(attachmentsize));\r\n\r\n        if (process.equals(\"permission\")) {\r\n            // permission: respond with acceptable message and attachment size\r\n//          String iam = (String) post.get(\"iam\", \"\");    // seed hash of requester\r\n            prop.put(\"response\", \"Welcome to my peer!\");\r\n            // that's it!\r\n        }\r\n\r\n        if (process.equals(\"post\")) {\r\n            // post: post message to message board\r\n            String otherSeedString = post.get(\"myseed\", \"\");\r\n            if (otherSeedString.length() == 0) {\r\n                prop.put(\"response\", \"-1\"); // request rejected\r\n                return prop;\r\n            }\r\n            //Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME)); // read remote time\r\n            yacySeed otherSeed = yacySeed.genRemoteSeed(otherSeedString, key, true);\r\n\r\n            String subject = crypt.simpleDecode(post.get(\"subject\", \"\"), key); // message's subject\r\n            String message = crypt.simpleDecode(post.get(\"message\", \"\"), key); // message body\r\n            if (subject == null || message == null) {\r\n                prop.put(\"response\", \"-1\"); // don't accept empty messages\r\n                return prop;\r\n            }\r\n            message = message.trim();\r\n            subject = subject.trim();\r\n            if (subject.length() == 0 || message.length() == 0) {\r\n                prop.put(\"response\", \"-1\"); // don't accept empty messages\r\n                return prop;\r\n            }\r\n            \r\n            prop.put(\"response\", \"Thank you!\");\r\n\r\n            // save message\r\n            messageBoard.entry msgEntry = null;\r\n            byte[] mb;\r\n            try {\r\n                mb = message.getBytes(\"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                mb = message.getBytes();\r\n            }\r\n            sb.messageDB.write(msgEntry = sb.messageDB.newEntry(\r\n                    \"remote\",\r\n                    otherSeed.get(yacySeed.NAME, \"anonymous\"), otherSeed.hash,\r\n                    yacyCore.seedDB.mySeed().getName(), yacyCore.seedDB.mySeed().hash,\r\n                    subject, mb));\r\n\r\n            messageForwardingViaEmail(env, msgEntry);\r\n\r\n            // finally write notification\r\n            File notifierSource = new File(sb.getRootPath(), sb.getConfig(\"htRootPath\",\"htroot\") + \"/env/grafics/message.gif\");\r\n            File notifierDest   = new File(sb.getConfigPath(\"htDocsPath\", \"DATA/HTDOCS\"), \"notifier.gif\");\r\n            try {\r\n                serverFileUtils.copy(notifierSource, notifierDest);\r\n            } catch (IOException e) {\r\n            \tserverLog.logSevere(\"MESSAGE\", \"NEW MESSAGE ARRIVED! (error: \" + e.getMessage() + \")\");\r\n              \r\n            }\r\n        }\r\n//      System.out.println(\"respond = \" + prop.toString());\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":11125,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        if (post == null || env == null) { return null; }\r\n\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n\r\n        String process = post.get(\"process\", \"permission\");\r\n        String key =  post.get(\"key\", \"\");\r\n\r\n        int messagesize = 10240;\r\n        int attachmentsize = 0;\r\n\r\n        prop.put(\"messagesize\", \"0\");\r\n        prop.put(\"attachmentsize\", \"0\");\r\n\r\n        String youare = post.get(\"youare\", \"\"); // seed hash of the target peer, needed for network stability\r\n        // check if we are the right target and requester has correct information about this peer\r\n        if ((yacyCore.seedDB.mySeed() == null) || (!(yacyCore.seedDB.mySeed().hash.equals(youare)))) {\r\n            // this request has a wrong target\r\n            prop.put(\"response\", \"-1\"); // request rejected\r\n            return prop;\r\n        }\r\n\r\n        if ((sb.isRobinsonMode()) &&\r\n        \t (!((sb.isPublicRobinson()) ||\r\n        \t    (sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))))) {\r\n            // if we are a robinson cluster, answer only if this client is known by our network definition\r\n        \tprop.put(\"response\", \"-1\"); // request rejected\r\n            return prop;\r\n        }\r\n        \r\n        prop.put(\"messagesize\", Integer.toString(messagesize));\r\n        prop.put(\"attachmentsize\", Integer.toString(attachmentsize));\r\n\r\n        if (process.equals(\"permission\")) {\r\n            // permission: respond with acceptable message and attachment size\r\n//          String iam = (String) post.get(\"iam\", \"\");    // seed hash of requester\r\n            prop.put(\"response\", \"Welcome to my peer!\");\r\n            // that's it!\r\n        }\r\n\r\n        if (process.equals(\"post\")) {\r\n            // post: post message to message board\r\n            String otherSeedString = post.get(\"myseed\", \"\");\r\n            if (otherSeedString.length() == 0) {\r\n                prop.put(\"response\", \"-1\"); // request rejected\r\n                return prop;\r\n            }\r\n            //Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME)); // read remote time\r\n            yacySeed otherSeed = yacySeed.genRemoteSeed(otherSeedString, key, true);\r\n\r\n            String subject = crypt.simpleDecode(post.get(\"subject\", \"\"), key); // message's subject\r\n            String message = crypt.simpleDecode(post.get(\"message\", \"\"), key); // message body\r\n            if (subject == null || message == null) {\r\n                prop.put(\"response\", \"-1\"); // don't accept empty messages\r\n                return prop;\r\n            }\r\n            message = message.trim();\r\n            subject = subject.trim();\r\n            if (subject.length() == 0 || message.length() == 0) {\r\n                prop.put(\"response\", \"-1\"); // don't accept empty messages\r\n                return prop;\r\n            }\r\n            \r\n            prop.put(\"response\", \"Thank you!\");\r\n\r\n            // save message\r\n            messageBoard.entry msgEntry = null;\r\n            byte[] mb;\r\n            try {\r\n                mb = message.getBytes(\"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                mb = message.getBytes();\r\n            }\r\n            sb.messageDB.write(msgEntry = sb.messageDB.newEntry(\r\n                    \"remote\",\r\n                    otherSeed.get(yacySeed.NAME, \"anonymous\"), otherSeed.hash,\r\n                    yacyCore.seedDB.mySeed().getName(), yacyCore.seedDB.mySeed().hash,\r\n                    subject, mb));\r\n\r\n            messageForwardingViaEmail(env, msgEntry);\r\n\r\n            // finally write notification\r\n            File notifierSource = new File(sb.getRootPath(), sb.getConfig(\"htRootPath\",\"htroot\") + \"/env/grafics/message.gif\");\r\n            File notifierDest   = new File(sb.getConfigPath(\"htDocsPath\", \"DATA/HTDOCS\"), \"notifier.gif\");\r\n            try {\r\n                serverFileUtils.copy(notifierSource, notifierDest);\r\n            } catch (IOException e) {\r\n            \tserverLog.logSevere(\"MESSAGE\", \"NEW MESSAGE ARRIVED! (error: \" + e.getMessage() + \")\");\r\n              \r\n            }\r\n        }\r\n//      System.out.println(\"respond = \" + prop.toString());\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        // defaults\r\n        prop.put(\"list\", \"0\");\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        if (sb.isRobinsonMode() &&\r\n            !sb.isPublicRobinson() &&\r\n            !sb.isInMyCluster((String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP))) {\r\n            // if we are a robinson cluster, answer only if this client is known by our network definition\r\n            return prop;\r\n        }\r\n\r\n        Properties profile = new Properties();\r\n        int count = 0;\r\n        String key = \"\";\r\n        String value = \"\";\r\n\r\n        FileInputStream fileIn = null;\r\n        try {\r\n            fileIn = new FileInputStream(new File(\"DATA/SETTINGS/profile.txt\"));\r\n            profile.load(fileIn);\r\n        } catch (IOException e) {\r\n        } finally {\r\n            if (fileIn != null) try { fileIn.close(); fileIn = null; } catch (Exception e) {}\r\n        }\r\n\r\n        Iterator<Object> it = profile.keySet().iterator();\r\n        while (it.hasNext()) {\r\n            key = (String) it.next();\r\n            value=profile.getProperty(key, \"\").replaceAll(\"\\r\",\"\").replaceAll(\"\\n\",\"\\\\\\\\n\");\r\n            if( !(key.equals(\"\")) && !(value.equals(\"\")) ){\r\n                prop.put(\"list_\"+count+\"_key\", key);\r\n                prop.put(\"list_\"+count+\"_value\", value);\r\n                count++;\r\n            }\r\n        }\r\n        prop.put(\"list\", count);\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":11126,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n\r\n        if ((sb.isRobinsonMode()) &&\r\n           \t(!sb.isPublicRobinson()) &&\r\n           \t(!sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))) {\r\n               // if we are a robinson cluster, answer only if this client is known by our network definition\r\n        \tprop.put(\"list\", \"0\");\r\n            return prop;\r\n        }\r\n        \r\n        Properties profile = new Properties();\r\n        int count=0;\r\n        String key=\"\";\r\n        String value=\"\";\r\n\r\n        FileInputStream fileIn = null;\r\n        try {\r\n            fileIn = new FileInputStream(new File(\"DATA/SETTINGS/profile.txt\"));\r\n            profile.load(fileIn);        \r\n        } catch(IOException e) {\r\n        } finally {\r\n            if (fileIn != null) try { fileIn.close(); fileIn = null; } catch (Exception e) {}\r\n        }\r\n\r\n        Iterator<Object> it = profile.keySet().iterator();\r\n        while (it.hasNext()) {\r\n            key = (String) it.next();\r\n            value=profile.getProperty(key, \"\").replaceAll(\"\\r\",\"\").replaceAll(\"\\n\",\"\\\\\\\\n\");\r\n            if( !(key.equals(\"\")) && !(value.equals(\"\")) ){\r\n                prop.put(\"list_\"+count+\"_key\", key);\r\n                prop.put(\"list_\"+count+\"_value\", value);\r\n                count++;\r\n            }\r\n        }\r\n        prop.put(\"list\", count);\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        if (sb.isRobinsonMode() &&\r\n            !sb.isPublicRobinson() &&\r\n            !sb.isInMyCluster((String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP))) {\r\n            // if we are a robinson cluster, answer only if we are public robinson peers,\r\n            // or we are a private cluster and the requester is in our cluster.\r\n            // if we don't answer, the remote peer will recognize us as junior peer,\r\n            // what would mean that our peer ping does not work\r\n            prop.put(\"response\", \"-1\"); // request rejected\r\n            return prop;\r\n        }\r\n\r\n//      System.out.println(\"YACYQUERY: RECEIVED POST = \" + ((post == null) ? \"NULL\" : post.toString()));\r\n\r\n        final String ohash  = post.get(\"iam\", \"\");    // complete seed of the requesting peer\r\n        final String youare = post.get(\"youare\", \"\"); // seed hash of the target peer, used for testing network stability\r\n//      final String key    = post.get(\"key\", \"\");    // transmission key for response\r\n        final String obj    = post.get(\"object\", \"\"); // keyword for query subject\r\n        final String qenv    = post.get(\"env\", \"\");    // argument to query\r\n\r\n        final yacySeed oseed = yacyCore.seedDB.get(ohash);\r\n        if (oseed == null) {\r\n            prop.put(\"response\", \"0\");\r\n            return prop;\r\n        } else {\r\n            oseed.setFlagDirectConnect(true);\r\n            oseed.setLastSeenUTC();\r\n        }\r\n\r\n        prop.put(\"mytime\", serverDate.formatShortSecond());\r\n\r\n        // check if we are the right target and requester has correct information about this peer\r\n        if (yacyCore.seedDB.mySeed() == null || !yacyCore.seedDB.mySeed().hash.equals(youare)) {\r\n            // this request has a wrong target\r\n            prop.put(\"response\", \"-1\"); // request rejected\r\n            return prop;\r\n        }\r\n\r\n        // requests about environment\r\n        if (obj.equals(\"rwiurlcount\")) {\r\n            // the total number of different urls in the rwi is returned\r\n            // <env> shall contain a word hash, the number of assigned lurls to this hash is returned\r\n            prop.put(\"response\", sb.wordIndex.indexSize(qenv));\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"rwicount\")) {\r\n            // return the total number of available word indexes\r\n            prop.put(\"response\", sb.wordIndex.size());\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"lurlcount\")) {\r\n            // return the number of all available l-url's\r\n            prop.put(\"response\", sb.wordIndex.loadedURL.size());\r\n            return prop;\r\n        }\r\n\r\n        // requests about requirements\r\n\r\n        if (obj.equals(\"wantedlurls\")) {\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedpurls\")) {\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedword\")) {\r\n            // response returns a list of wanted word hashes\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedrwi\")) {\r\n            // <env> shall contain a word hash, the number of wanted lurls for this hash is returned\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedseeds\")) {\r\n            // return a number of wanted seed\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":11127,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch ss) {\r\n        if (post == null || ss == null) { return null; }\r\n\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) ss;\r\n        final serverObjects prop = new serverObjects();\r\n        if ((post == null) || (ss == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, ss)) return prop;\r\n        \r\n        \r\n        if ((sb.isRobinsonMode()) &&\r\n            (!sb.isPublicRobinson()) &&\r\n            (!sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))) {\r\n        \t// if we are a robinson cluster, answer only if we are public robinson peers,\r\n        \t// or we are a private cluster and the requester is in our cluster.\r\n          \t// if we don't answer, the remote peer will recognize us as junior peer,\r\n          \t// what would mean that our peer ping does not work\r\n        \tprop.put(\"response\", \"-1\"); // request rejected\r\n            return prop;\r\n        }\r\n                  \r\n//      System.out.println(\"YACYQUERY: RECEIVED POST = \" + ((post == null) ? \"NULL\" : post.toString()));\r\n\r\n//      final String iam    = post.get(\"iam\", \"\");    // complete seed of the requesting peer\r\n        final String youare = post.get(\"youare\", \"\"); // seed hash of the target peer, used for testing network stability\r\n//      final String key    = post.get(\"key\", \"\");    // transmission key for response\r\n        final String obj    = post.get(\"object\", \"\"); // keyword for query subject\r\n        final String env    = post.get(\"env\", \"\");    // argument to query\r\n\r\n        prop.put(\"mytime\", serverDate.formatShortSecond());\r\n\r\n        // check if we are the right target and requester has correct information about this peer\r\n        if (yacyCore.seedDB.mySeed() == null || !yacyCore.seedDB.mySeed().hash.equals(youare)) {\r\n            // this request has a wrong target\r\n            prop.put(\"response\", \"-1\"); // request rejected\r\n            return prop;\r\n        }\r\n\r\n        // requests about environment\r\n        if (obj.equals(\"rwiurlcount\")) {\r\n            // the total number of different urls in the rwi is returned\r\n            // <env> shall contain a word hash, the number of assigned lurls to this hash is returned\r\n            prop.put(\"response\", sb.wordIndex.indexSize(env));\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"rwicount\")) {\r\n            // return the total number of available word indexes\r\n            prop.put(\"response\", sb.wordIndex.size());\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"lurlcount\")) {\r\n            // return the number of all available l-url's\r\n            prop.put(\"response\", sb.wordIndex.loadedURL.size());\r\n            return prop;\r\n        }\r\n\r\n        // requests about requirements\r\n\r\n        if (obj.equals(\"wantedlurls\")) {\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedpurls\")) {\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedword\")) {\r\n            // response returns a list of wanted word hashes\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedrwi\")) {\r\n            // <env> shall contain a word hash, the number of wanted lurls for this hash is returned\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        if (obj.equals(\"wantedseeds\")) {\r\n            // return a number of wanted seed\r\n            prop.put(\"response\", \"0\"); // dummy response\r\n            return prop;\r\n        }\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        // defaults\r\n        prop.put(\"links\", \"\");\r\n        prop.put(\"linkcount\", \"0\");\r\n        prop.put(\"references\", \"\");\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP);\r\n        \r\n        // test:\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Q (search for linux)\r\n        // http://localhost:8080/yacy/search.html?query=gh8DKIhGKXws (search for book)\r\n        // http://localhost:8080/yacy/search.html?query=UEhMGfGv2vOE (search for kernel)\r\n        // http://localhost:8080/yacy/search.html?query=ZX-LjaYo74PP (search for help)\r\n        // http://localhost:8080/yacy/search.html?query=uDqIalxDfM2a (search for mail)\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Qgh8DKIhGKXws&abstracts=auto (search for linux and book, generate abstract automatically)\r\n        // http://localhost:8080/yacy/search.html?query=&abstracts=4galTpdpDM5Q (only abstracts for linux)\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        if (sb.isRobinsonMode() &&\r\n           !(sb.isPublicRobinson() ||\r\n             sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))) {\r\n            // if we are a robinson cluster, answer only if this client is known by our network definition\r\n            return prop;\r\n        }\r\n\r\n        final String query = post.get(\"query\", \"\"); // a string of word hashes that shall be searched and combined\r\n        final String abstracts = post.get(\"abstracts\", \"\"); // a string of word hashes for abstracts that shall be generated, or 'auto' (for maxcount-word), or '' (for none)\r\n        if ((query == null || query.length() == 0) & (abstracts == null || abstracts.length() == 0)) {\r\n            return prop;\r\n        }\r\n\r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(3000);\r\n        sb.remoteSearchLastAccess = System.currentTimeMillis();\r\n\r\n        // myseed = complete seed of the requesting peer, key = transmission key for response\r\n        final yacySeed oseed = yacySeed.genRemoteSeed(post.get(\"myseed\", \"\"), post.get(\"key\", \"\"), true);\r\n        // store accessing peer\r\n        if (yacyCore.seedDB == null) {\r\n            yacyCore.log.logSevere(\"yacy.search: seed cache not initialized\");\r\n        } else {\r\n            yacyCore.peerActions.peerArrival(oseed, true);\r\n        }\r\n\r\n//      final String youare  = post.get(\"youare\", \"\");  // seed hash of the target peer, used for testing network stability\r\n//      final String fwdep   = post.get(\"fwdep\", \"\");   // forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n//      final String fwden   = post.get(\"fwden\", \"\");   // forward deny, a list of seed hashes. They may NOT be target of forward hopping                \r\n        String       profile = post.get(\"profile\", \"\"); // remote profile hand-over\r\n        String       urls    = post.get(\"urls\", \"\");    // a string of url hashes that are preselected for the search: no other may be returned\r\n        final String exclude = post.get(\"exclude\", \"\"); // a string of word hashes that shall not be within the search result\r\n        final int    count   = Math.min(100, post.getInt(\"count\", 10)); // maximum number of wanted results\r\n        final int    maxdist = post.getInt(\"maxdist\", Integer.MAX_VALUE);\r\n        final String prefer  = post.get(\"prefer\", \"\");\r\n        final String filter  = post.get(\"filter\", \".*\");\r\n        final int    partitions = post.getInt(\"partitions\", 30);\r\n        final String contentdom = post.get(\"contentdom\", \"text\");\r\n\r\n        if (profile.length() > 0) profile = crypt.simpleDecode(profile, null);\r\n        //final boolean includesnippet = post.get(\"includesnippet\", \"false\").equals(\"true\");\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (constraint != null) {\r\n            // check bad handover parameter from older versions\r\n            boolean allon = true;\r\n            for (int i = 0; i < 32; i++) {\r\n                if (!constraint.get(i)) {allon = false; break;}\r\n            }\r\n            if (allon) constraint = null;\r\n        }\r\n//      final boolean global = ((String) post.get(\"resource\", \"global\")).equals(\"global\"); // if true, then result may consist of answers from other peers\r\n//      Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME));        // read remote time\r\n\r\n\r\n        // prepare search\r\n        final TreeSet<String> queryhashes = plasmaSearchQuery.hashes2Set(query);\r\n        final TreeSet<String> abstractSet = (abstracts.length() == 0 || abstracts.equals(\"auto\")) ? null : plasmaSearchQuery.hashes2Set(abstracts);\r\n        final TreeSet<String> excludehashes = (exclude.length() == 0) ? new TreeSet<String>(kelondroBase64Order.enhancedComparator) : plasmaSearchQuery.hashes2Set(exclude);\r\n        final long timestamp = System.currentTimeMillis();\r\n\r\n        // prepare a search profile\r\n        plasmaSearchRankingProfile rankingProfile = (profile.length() == 0) ? new plasmaSearchRankingProfile(plasmaSearchQuery.contentdomParser(contentdom)) : new plasmaSearchRankingProfile(\"\", profile);\r\n\r\n        // prepare an abstract result\r\n        StringBuffer indexabstract = new StringBuffer();\r\n        int indexabstractContainercount = 0;\r\n        int joincount = 0;\r\n        plasmaSearchQuery theQuery = null;\r\n        ArrayList<kelondroSortStack<ResultEntry>.stackElement> accu = null;\r\n        plasmaSearchEvent theSearch = null;\r\n        if ((query.length() == 0) && (abstractSet != null)) {\r\n            // this is _not_ a normal search, only a request for index abstracts\r\n            theQuery = new plasmaSearchQuery(null, abstractSet, new TreeSet<String>(kelondroBase64Order.enhancedComparator), rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, null, false, yacyURL.TLD_any_zone_filter, client);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (abstracts only): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n\r\n            long timer = System.currentTimeMillis();\r\n            Map<String, indexContainer>[] containers = sb.wordIndex.localSearchContainers(theQuery, plasmaSearchQuery.hashes2Set(urls));\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.COLLECTION, containers[0].size(), System.currentTimeMillis() - timer));\r\n            if (containers != null) {\r\n                Iterator<Map.Entry<String, indexContainer>> ci = containers[0].entrySet().iterator();\r\n                Map.Entry<String, indexContainer> entry;\r\n                String wordhash;\r\n                while (ci.hasNext()) {\r\n                    entry = ci.next();\r\n                    wordhash = entry.getKey();\r\n                    indexContainer container = entry.getValue();\r\n                    indexabstractContainercount += container.size();\r\n                    indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append(indexContainer.compressIndex(container, null, 1000).toString()).append(serverCore.CRLF_STRING);                \r\n                }\r\n            }\r\n            prop.put(\"indexcount\", \"\");\r\n            prop.put(\"joincount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n\r\n        } else {\r\n            // retrieve index containers from search request\r\n            theQuery = new plasmaSearchQuery(null, queryhashes, excludehashes, rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, constraint, false, yacyURL.TLD_any_zone_filter, client);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (query-\" + abstracts + \"): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n\r\n            // make event\r\n            theSearch = plasmaSearchEvent.getEvent(theQuery, rankingProfile, sb.wordIndex, null, true); \r\n\r\n            // set statistic details of search result and find best result index set\r\n            if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                prop.put(\"indexcount\", \"\");\r\n                prop.put(\"joincount\", \"0\");\r\n            } else {\r\n                // attach information about index abstracts\r\n                StringBuffer indexcount = new StringBuffer();\r\n                Map.Entry<String, Integer> entry;\r\n                Iterator<Map.Entry<String, Integer>> i = theSearch.IACount.entrySet().iterator();\r\n                while (i.hasNext()) {\r\n                    entry = i.next();\r\n                    indexcount.append(\"indexcount.\").append((String) entry.getKey()).append('=').append(((Integer) entry.getValue()).toString()).append(serverCore.CRLF_STRING);\r\n                }\r\n                if (abstractSet != null) {\r\n                    // if a specific index-abstract is demanded, attach it here\r\n                    Iterator<String> j = abstractSet.iterator();\r\n                    String wordhash;\r\n                    while (j.hasNext()) {\r\n                        wordhash = (String) j.next();\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(wordhash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append((String) theSearch.IAResults.get(wordhash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                }\r\n                prop.put(\"indexcount\", indexcount.toString());\r\n\r\n                if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                    joincount = 0;\r\n                    prop.put(\"joincount\", \"0\");\r\n                } else {\r\n                    joincount = theSearch.getRankingResult().getLocalResourceSize();\r\n                    prop.put(\"joincount\", Integer.toString(joincount));\r\n                    accu = theSearch.completeResults(3000);\r\n                }\r\n\r\n                // generate compressed index for maxcounthash\r\n                // this is not needed if the search is restricted to specific\r\n                // urls, because it is a re-search\r\n                if ((theSearch.IAmaxcounthash == null) || (urls.length() != 0) || (queryhashes.size() <= 1) || (abstracts.length() == 0)) {\r\n                    prop.put(\"indexabstract\", \"\");\r\n                } else if (abstracts.equals(\"auto\")) {\r\n                    // automatically attach the index abstract for the index that has the most references. This should be our target dht position\r\n                    indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAmaxcounthash)).intValue();\r\n                    indexabstract.append(\"indexabstract.\" + theSearch.IAmaxcounthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAmaxcounthash)).append(serverCore.CRLF_STRING);\r\n                    if ((theSearch.IAneardhthash != null) && (!(theSearch.IAneardhthash.equals(theSearch.IAmaxcounthash)))) {\r\n                        // in case that the neardhthash is different from the maxcounthash attach also the neardhthash-container\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAneardhthash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + theSearch.IAneardhthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAneardhthash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: maxcounthash = \" + maxcounthash);\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: neardhthash  = \"+ neardhthash);\r\n                    //yacyCore.log.logFine(\"DEBUG HASH SEARCH: \" + indexabstract);\r\n                }\r\n            }\r\n            if (partitions > 0) sb.requestedQueries = sb.requestedQueries + 1d / partitions; // increase query counter\r\n\r\n            // prepare reference hints\r\n            long timer = System.currentTimeMillis();\r\n            Set<String> ws = theSearch.references(10);\r\n            StringBuffer refstr = new StringBuffer();\r\n            Iterator<String> j = ws.iterator();\r\n            while (j.hasNext()) {\r\n                refstr.append(\",\").append((String) j.next());\r\n            }\r\n            prop.put(\"references\", (refstr.length() > 0) ? refstr.substring(1) : refstr.toString());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"reference collection\", ws.size(), System.currentTimeMillis() - timer));\r\n        }\r\n        prop.put(\"indexabstract\", indexabstract.toString());\r\n\r\n        // prepare result\r\n        if (joincount != 0 || accu != null) {\r\n            // result is a List of urlEntry elements\r\n            long timer = System.currentTimeMillis();\r\n            StringBuffer links = new StringBuffer();\r\n            String resource = null;\r\n            kelondroSortStack<plasmaSearchEvent.ResultEntry>.stackElement entry;\r\n            for (int i = 0; i < accu.size(); i++) {\r\n                entry = accu.get(i);\r\n                resource = entry.element.resource();\r\n                if (resource != null) {\r\n                    links.append(\"resource\").append(i).append('=').append(resource).append(serverCore.CRLF_STRING);\r\n                }\r\n            }\r\n            prop.put(\"links\", links.toString());\r\n            prop.put(\"linkcount\", accu.size());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"result list preparation\", accu.size(), System.currentTimeMillis() - timer));\r\n        }\r\n\r\n        // add information about forward peers\r\n        prop.put(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n        prop.put(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n        prop.put(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n\r\n        // prepare search statistics\r\n        theQuery.remotepeer = yacyCore.seedDB.lookupByIP(natLib.getInetAddress(client), true, false, false);\r\n        theQuery.resultcount = (theSearch == null) ? 0 : theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n        theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n        theQuery.urlretrievaltime = (theSearch == null) ? 0 : theSearch.getURLRetrievalTime();\r\n        theQuery.snippetcomputationtime = (theSearch == null) ? 0 : theSearch.getSnippetComputationTime();\r\n        sb.remoteSearches.add(theQuery);\r\n        TreeSet<Long> handles = sb.remoteSearchTracker.get(client);\r\n        if (handles == null) handles = new TreeSet<Long>();\r\n        handles.add(theQuery.handle);\r\n        sb.remoteSearchTracker.put(client, handles);\r\n\r\n        // log\r\n        yacyCore.log.logInfo(\"EXIT HASH SEARCH: \" +\r\n                plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + joincount + \" links found, \" +\r\n                prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n                indexabstractContainercount + \" index abstracts, \" +\r\n                (System.currentTimeMillis() - timestamp) + \" milliseconds\");\r\n\r\n        prop.put(\"searchtime\", System.currentTimeMillis() - timestamp);\r\n\r\n        final int links = Integer.parseInt(prop.get(\"linkcount\", \"0\"));\r\n        yacyCore.seedDB.mySeed().incSI(links);\r\n        yacyCore.seedDB.mySeed().incSU(links);\r\n        return prop;\r\n    }","id":11128,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.remoteSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP);\r\n\r\n        //System.out.println(\"yacy: search received request = \" + post.toString());\r\n\r\n        final String  oseed  = post.get(\"myseed\", \"\"); // complete seed of the requesting peer\r\n//      final String  youare = post.get(\"youare\", \"\"); // seed hash of the target peer, used for testing network stability\r\n        final String  key    = post.get(\"key\", \"\");    // transmission key for response\r\n        final String  query  = post.get(\"query\", \"\");  // a string of word hashes that shall be searched and combined\r\n        final String  exclude= post.get(\"exclude\", \"\");// a string of word hashes that shall not be within the search result\r\n        String  urls   = post.get(\"urls\", \"\");         // a string of url hashes that are preselected for the search: no other may be returned\r\n        String abstracts = post.get(\"abstracts\", \"\");  // a string of word hashes for abstracts that shall be generated, or 'auto' (for maxcount-word), or '' (for none)\r\n//      final String  fwdep  = post.get(\"fwdep\", \"\");  // forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n//      final String  fwden  = post.get(\"fwden\", \"\");  // forward deny, a list of seed hashes. They may NOT be target of forward hopping\r\n        final int     count  = Math.min(100, post.getInt(\"count\", 10)); // maximum number of wanted results\r\n        final int     maxdist= post.getInt(\"maxdist\", Integer.MAX_VALUE);\r\n        final String  prefer = post.get(\"prefer\", \"\");\r\n        final String  contentdom = post.get(\"contentdom\", \"text\");\r\n        final String  filter = post.get(\"filter\", \".*\");\r\n        final int     partitions = post.getInt(\"partitions\", 30);\r\n        String  profile = post.get(\"profile\", \"\"); // remote profile hand-over\r\n        if (profile.length() > 0) profile = crypt.simpleDecode(profile, null);\r\n        //final boolean includesnippet = post.get(\"includesnippet\", \"false\").equals(\"true\");\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (constraint != null) {\r\n        \t// check bad handover parameter from older versions\r\n            boolean allon = true;\r\n            for (int i = 0; i < 32; i++) {\r\n            \tif (!constraint.get(i)) {allon = false; break;}\r\n            }\r\n            if (allon) constraint = null;\r\n        }\r\n//      final boolean global = ((String) post.get(\"resource\", \"global\")).equals(\"global\"); // if true, then result may consist of answers from other peers\r\n//      Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME));        // read remote time\r\n\r\n        // test:\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Q (search for linux)\r\n        // http://localhost:8080/yacy/search.html?query=gh8DKIhGKXws (search for book)\r\n        // http://localhost:8080/yacy/search.html?query=UEhMGfGv2vOE (search for kernel)\r\n        // http://localhost:8080/yacy/search.html?query=ZX-LjaYo74PP (search for help)\r\n        // http://localhost:8080/yacy/search.html?query=uDqIalxDfM2a (search for mail)\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Qgh8DKIhGKXws&abstracts=auto (search for linux and book, generate abstract automatically)\r\n        // http://localhost:8080/yacy/search.html?query=&abstracts=4galTpdpDM5Q (only abstracts for linux)\r\n\r\n        if ((sb.isRobinsonMode()) &&\r\n             \t (!((sb.isPublicRobinson()) ||\r\n             \t    (sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))))) {\r\n                 // if we are a robinson cluster, answer only if this client is known by our network definition\r\n        \tprop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n        \treturn prop;\r\n        }\r\n        \r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(3000);\r\n\r\n        TreeSet<String> abstractSet = ((abstracts.length() == 0) || (abstracts.equals(\"auto\"))) ? null : plasmaSearchQuery.hashes2Set(abstracts);\r\n        \r\n        // store accessing peer\r\n        if (yacyCore.seedDB == null) {\r\n            yacyCore.log.logSevere(\"yacy.search: seed cache not initialized\");\r\n        } else {\r\n            yacyCore.peerActions.peerArrival(yacySeed.genRemoteSeed(oseed, key, true), true);\r\n        }\r\n\r\n        // prepare search\r\n        final TreeSet<String> queryhashes = plasmaSearchQuery.hashes2Set(query);\r\n        final TreeSet<String> excludehashes = (exclude.length() == 0) ? new TreeSet<String>(kelondroBase64Order.enhancedComparator) : plasmaSearchQuery.hashes2Set(exclude);\r\n        final long timestamp = System.currentTimeMillis();\r\n        \r\n    \t// prepare a search profile\r\n        plasmaSearchRankingProfile rankingProfile = (profile.length() == 0) ? new plasmaSearchRankingProfile(plasmaSearchQuery.contentdomParser(contentdom)) : new plasmaSearchRankingProfile(\"\", profile);\r\n        \r\n        // prepare an abstract result\r\n        StringBuffer indexabstract = new StringBuffer();\r\n        int indexabstractContainercount = 0;\r\n        int joincount = 0;\r\n        plasmaSearchQuery theQuery = null;\r\n        ArrayList<kelondroSortStack<ResultEntry>.stackElement> accu = null;\r\n        plasmaSearchEvent theSearch = null;\r\n        if ((query.length() == 0) && (abstractSet != null)) {\r\n            // this is _not_ a normal search, only a request for index abstracts\r\n            theQuery = new plasmaSearchQuery(null, abstractSet, new TreeSet<String>(kelondroBase64Order.enhancedComparator), rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, null, false, yacyURL.TLD_any_zone_filter, client);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (abstracts only): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n\r\n            long timer = System.currentTimeMillis();\r\n            Map<String, indexContainer>[] containers = sb.wordIndex.localSearchContainers(theQuery, plasmaSearchQuery.hashes2Set(urls));\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.COLLECTION, containers[0].size(), System.currentTimeMillis() - timer));\r\n            if (containers != null) {\r\n                Iterator<Map.Entry<String, indexContainer>> ci = containers[0].entrySet().iterator();\r\n                Map.Entry<String, indexContainer> entry;\r\n                String wordhash;\r\n                while (ci.hasNext()) {\r\n                    entry = ci.next();\r\n                    wordhash = entry.getKey();\r\n                    indexContainer container = entry.getValue();\r\n                    indexabstractContainercount += container.size();\r\n                    indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append(indexContainer.compressIndex(container, null, 1000).toString()).append(serverCore.CRLF_STRING);                \r\n                }\r\n            }\r\n            \r\n            prop.put(\"indexcount\", \"\");\r\n            prop.put(\"joincount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n            \r\n        } else {\r\n            // retrieve index containers from search request\r\n            theQuery = new plasmaSearchQuery(null, queryhashes, excludehashes, rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, constraint, false, yacyURL.TLD_any_zone_filter, client);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (query-\" + abstracts + \"): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n            \r\n            // make event\r\n            theSearch = plasmaSearchEvent.getEvent(theQuery, rankingProfile, sb.wordIndex, null, true); \r\n            \r\n            // set statistic details of search result and find best result index set\r\n            if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                prop.put(\"indexcount\", \"\");\r\n                prop.put(\"joincount\", \"0\");\r\n            } else {\r\n                // attach information about index abstracts\r\n                StringBuffer indexcount = new StringBuffer();\r\n                Map.Entry<String, Integer> entry;\r\n                Iterator<Map.Entry<String, Integer>> i = theSearch.IACount.entrySet().iterator();\r\n                while (i.hasNext()) {\r\n                    entry = i.next();\r\n                    indexcount.append(\"indexcount.\").append((String) entry.getKey()).append('=').append(((Integer) entry.getValue()).toString()).append(serverCore.CRLF_STRING);\r\n                }\r\n                if (abstractSet != null) {\r\n                    // if a specific index-abstract is demanded, attach it here\r\n                    Iterator<String> j = abstractSet.iterator();\r\n                    String wordhash;\r\n                    while (j.hasNext()) {\r\n                        wordhash = (String) j.next();\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(wordhash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append((String) theSearch.IAResults.get(wordhash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                }\r\n                prop.put(\"indexcount\", indexcount.toString());\r\n                \r\n                if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                    joincount = 0;\r\n                    prop.put(\"joincount\", \"0\");\r\n                } else {\r\n                    joincount = theSearch.getRankingResult().getLocalResourceSize();\r\n                    prop.put(\"joincount\", Integer.toString(joincount));\r\n                    accu = theSearch.completeResults(3000);\r\n                }\r\n                \r\n                // generate compressed index for maxcounthash\r\n                // this is not needed if the search is restricted to specific\r\n                // urls, because it is a re-search\r\n                if ((theSearch.IAmaxcounthash == null) || (urls.length() != 0) || (queryhashes.size() <= 1) || (abstracts.length() == 0)) {\r\n                    prop.put(\"indexabstract\", \"\");\r\n                } else if (abstracts.equals(\"auto\")) {\r\n                    // automatically attach the index abstract for the index that has the most references. This should be our target dht position\r\n                    indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAmaxcounthash)).intValue();\r\n                    indexabstract.append(\"indexabstract.\" + theSearch.IAmaxcounthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAmaxcounthash)).append(serverCore.CRLF_STRING);\r\n                    if ((theSearch.IAneardhthash != null) && (!(theSearch.IAneardhthash.equals(theSearch.IAmaxcounthash)))) {\r\n                        // in case that the neardhthash is different from the maxcounthash attach also the neardhthash-container\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAneardhthash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + theSearch.IAneardhthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAneardhthash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: maxcounthash = \" + maxcounthash);\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: neardhthash  = \"+ neardhthash);\r\n                    //yacyCore.log.logFine(\"DEBUG HASH SEARCH: \" + indexabstract);\r\n                }\r\n            }\r\n            if (partitions > 0) sb.requestedQueries = sb.requestedQueries + 1d / partitions; // increase query counter\r\n            \r\n            // prepare reference hints\r\n            long timer = System.currentTimeMillis();\r\n            Set<String> ws = theSearch.references(10);\r\n            StringBuffer refstr = new StringBuffer();\r\n            Iterator<String> j = ws.iterator();\r\n            while (j.hasNext()) {\r\n                refstr.append(\",\").append((String) j.next());\r\n            }\r\n            prop.put(\"references\", (refstr.length() > 0) ? refstr.substring(1) : refstr.toString());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"reference collection\", ws.size(), System.currentTimeMillis() - timer));\r\n        }\r\n        prop.put(\"indexabstract\", indexabstract.toString());\r\n        \r\n        // prepare result\r\n        if ((joincount == 0) || (accu == null)) {\r\n            \r\n            // no results\r\n            prop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n\r\n        } else {\r\n            // result is a List of urlEntry elements\r\n            long timer = System.currentTimeMillis();\r\n            StringBuffer links = new StringBuffer();\r\n            String resource = null;\r\n            kelondroSortStack<plasmaSearchEvent.ResultEntry>.stackElement entry;\r\n            for (int i = 0; i < accu.size(); i++) {\r\n                entry = accu.get(i);\r\n                resource = entry.element.resource();\r\n                if (resource != null) {\r\n                    links.append(\"resource\").append(i).append('=').append(resource).append(serverCore.CRLF_STRING);\r\n                }\r\n            }\r\n            prop.put(\"links\", links.toString());\r\n            prop.put(\"linkcount\", accu.size());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"result list preparation\", accu.size(), System.currentTimeMillis() - timer));\r\n        }\r\n        \r\n        // add information about forward peers\r\n        prop.put(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n        prop.put(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n        prop.put(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n\r\n        // prepare search statistics\r\n        theQuery.remotepeer = yacyCore.seedDB.lookupByIP(natLib.getInetAddress(client), true, false, false);\r\n        theQuery.resultcount = (theSearch == null) ? 0 : theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n        theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n        theQuery.urlretrievaltime = (theSearch == null) ? 0 : theSearch.getURLRetrievalTime();\r\n        theQuery.snippetcomputationtime = (theSearch == null) ? 0 : theSearch.getSnippetComputationTime();\r\n        sb.remoteSearches.add(theQuery);\r\n        TreeSet<Long> handles = sb.remoteSearchTracker.get(client);\r\n        if (handles == null) handles = new TreeSet<Long>();\r\n        handles.add(theQuery.handle);\r\n        sb.remoteSearchTracker.put(client, handles);\r\n        \r\n        // log\r\n        yacyCore.log.logInfo(\"EXIT HASH SEARCH: \" +\r\n                plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + joincount + \" links found, \" +\r\n                prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n                indexabstractContainercount + \" index abstracts, \" +\r\n                (System.currentTimeMillis() - timestamp) + \" milliseconds\");\r\n \r\n        prop.put(\"searchtime\", System.currentTimeMillis() - timestamp);\r\n\r\n        final int links = Integer.parseInt(prop.get(\"linkcount\",\"0\"));\r\n        yacyCore.seedDB.mySeed().incSI(links);\r\n        yacyCore.seedDB.mySeed().incSU(links);\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n\r\n        String process  = post.get(\"process\", \"\");  // permission or store\r\n//      String key      = post.get(\"key\", \"\");      // a transmission key from the client\r\n        String ohash    = post.get(\"iam\", \"\");      // identification of the client (a peer-hash)\r\n        String purpose  = post.get(\"purpose\", \"\");  // declares how the file shall be treated\r\n        String filename = post.get(\"filename\", \"\"); // a name of a file without path\r\n//      long   filesize = Long.parseLong((String) post.get(\"filesize\", \"\")); // the size of the file\r\n\r\n        prop.put(\"process\", \"0\");\r\n        prop.put(\"response\", \"denied\"); // reject is default and is overwritten if ok\r\n        prop.put(\"process_access\", \"\");\r\n        prop.put(\"process_address\", \"\");\r\n        prop.put(\"process_protocol\", \"\");\r\n        prop.put(\"process_path\", \"\");\r\n        prop.put(\"process_maxsize\", \"0\");\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        if (sb.isRobinsonMode() || !sb.rankingOn) {\r\n            // in a robinson environment, do not answer. We do not do any transfer in a robinson cluster.\r\n            return prop;\r\n        }\r\n\r\n        final yacySeed oseed = yacyCore.seedDB.get(ohash);\r\n        if (oseed == null) {\r\n            // reject unknown peers: this does not appear fair, but anonymous senders are dangerous\r\n            sb.getLog().logFine(\"RankingTransmission: rejected unknown peer '\" + ohash + \"', current IP \" + header.get(httpHeader.CONNECTION_PROP_CLIENTIP, \"unknown\"));\r\n            return prop;\r\n        }\r\n        oseed.setFlagDirectConnect(true);\r\n        oseed.setLastSeenUTC();\r\n\r\n        if (filename.indexOf(\"..\") >= 0) {\r\n            // reject paths that contain '..' because they are dangerous\r\n            sb.getLog().logFine(\"RankingTransmission: rejected wrong path '\" + filename + \"' from peer \" + oseed.getName() + \"/\" + oseed.getPublicAddress()+ \", current IP \" + header.get(httpHeader.CONNECTION_PROP_CLIENTIP, \"unknown\"));\r\n            return prop;\r\n        }\r\n\r\n        if (process.equals(\"permission\")) {\r\n            prop.put(\"process\", \"0\");\r\n            if (((purpose.equals(\"crcon\")) && (filename.startsWith(\"CRG\")) && (filename.endsWith(\".cr.gz\"))) || ((filename.startsWith(\"domlist\")) && (filename.endsWith(\".txt.gz\") || filename.endsWith(\".zip\")))) {\r\n                // consolidation of cr files\r\n                //System.out.println(\"yacy/transfer:post=\" + post.toString());\r\n                //String cansendprotocol = (String) post.get(\"can-send-protocol\", \"http\");\r\n                String access = kelondroBase64Order.enhancedCoder.encode(serverCodings.encodeMD5Raw(ohash + \":\" + filename)) + \":\" + kelondroBase64Order.enhancedCoder.encode(serverCodings.encodeMD5Raw(\"\" + System.currentTimeMillis()));\r\n                prop.put(\"response\", \"ok\");\r\n                prop.put(\"process_access\", access);\r\n                prop.put(\"process_address\", yacyCore.seedDB.mySeed().getPublicAddress());\r\n                prop.put(\"process_protocol\", \"http\");\r\n                prop.put(\"process_path\", \"\");  // currently empty; the store process will find a path\r\n                prop.put(\"process_maxsize\", \"-1\"); // if response is too big we return the size of the file\r\n                sb.rankingPermissions.put(serverCodings.encodeMD5Hex(kelondroBase64Order.standardCoder.encodeString(access)), filename);\r\n                sb.getLog().logFine(\"RankingTransmission: granted peer \" + oseed.hash + \":\" + oseed.getName() + \" to send CR file \" + filename);\r\n            }\r\n            return prop;\r\n        }\r\n\r\n        if (process.equals(\"store\")) {\r\n            prop.put(\"process\", \"1\");\r\n            if (purpose.equals(\"crcon\")) {\r\n                String fileString = post.get(\"filename$file\");\r\n                String accesscode = post.get(\"access\", \"\");   // one-time authentication\r\n                String md5 = post.get(\"md5\", \"\");   // one-time authentication\r\n                //java.util.HashMap perm = sb.rankingPermissions;\r\n                //System.out.println(\"PERMISSIONDEBUG: accesscode=\" + accesscode + \", permissions=\" + perm.toString());\r\n                String grantedFile = (String) sb.rankingPermissions.get(accesscode);\r\n                prop.put(\"process_tt\", \"\");\r\n                if ((grantedFile == null) || (!(grantedFile.equals(filename)))) {\r\n                    // fraud-access of this interface\r\n                    prop.put(\"response\", \"denied\");\r\n                    sb.getLog().logFine(\"RankingTransmission: denied \" + oseed.hash + \":\" + oseed.getName() + \" to send CR file \" + filename + \": wrong access code\");\r\n                } else {\r\n                    sb.rankingPermissions.remove(accesscode); // not needed any more\r\n                    File path = new File(sb.rankingPath, plasmaRankingDistribution.CR_OTHER);\r\n                    path.mkdirs();\r\n                    File file = new File(path, filename);\r\n                    try {\r\n                        if (file.getCanonicalPath().toString().startsWith(path.getCanonicalPath().toString())){\r\n                            serverFileUtils.write(fileString.getBytes(), file);\r\n                            String md5t = serverCodings.encodeMD5Hex(file);\r\n                            if (md5t.equals(md5)) {\r\n                                prop.put(\"response\", \"ok\");\r\n                                sb.getLog().logFine(\"RankingTransmission: received from peer \" + oseed.hash + \":\" + oseed.getName() + \" CR file \" + filename);\r\n                            } else {\r\n                                prop.put(\"response\", \"transfer failure\");\r\n                                sb.getLog().logFine(\"RankingTransmission: transfer failure from peer \" + oseed.hash + \":\" + oseed.getName() + \" for CR file \" + filename);\r\n                            }\r\n                        }else{\r\n                            //exploit?\r\n                            prop.put(\"response\", \"io error\");\r\n                            return prop;\r\n                        }\r\n                    } catch (IOException e) {\r\n                        prop.put(\"response\", \"io error\");\r\n                    }\r\n                }\r\n            }\r\n            return prop;\r\n        }\r\n\r\n        // wrong access\r\n        sb.getLog().logFine(\"RankingTransmission: rejected unknown process \" + process + \":\" + purpose + \" from peer \" + oseed.hash + \":\" + oseed.getName());\r\n        return prop;\r\n    }","id":11129,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        \r\n        String process   = post.get(\"process\", \"\");  // permission or store\r\n        //String key       = post.get(\"key\", \"\");      // a transmission key from the client\r\n        String otherpeer = post.get(\"iam\", \"\");      // identification of the client (a peer-hash)\r\n        String purpose   = post.get(\"purpose\", \"\");  // declares how the file shall be treated\r\n        String filename  = post.get(\"filename\", \"\"); // a name of a file without path\r\n        //long   filesize  = Long.parseLong((String) post.get(\"filesize\", \"\")); // the size of the file\r\n\r\n        prop.put(\"process\", \"0\");\r\n        prop.put(\"response\", \"denied\"); // reject is default and is overwritten if ok\r\n        prop.put(\"process_access\", \"\");\r\n        prop.put(\"process_address\", \"\");\r\n        prop.put(\"process_protocol\", \"\");\r\n        prop.put(\"process_path\", \"\");\r\n        prop.put(\"process_maxsize\", \"0\");\r\n\r\n        if (sb.isRobinsonMode() || !sb.rankingOn) {\r\n        \t// in a robinson environment, do not answer. We do not do any transfer in a robinson cluster.\r\n        \treturn prop;\r\n        }\r\n\r\n        yacySeed otherseed = yacyCore.seedDB.get(otherpeer);\r\n        if ((otherseed == null) || (filename.indexOf(\"..\") >= 0)) {\r\n            // reject unknown peers: this does not appear fair, but anonymous senders are dangerous\r\n            // reject paths that contain '..' because they are dangerous\r\n            if (otherseed == null) sb.getLog().logFine(\"RankingTransmission: rejected unknown peer '\" + otherpeer + \"', current IP \" + header.get(httpHeader.CONNECTION_PROP_CLIENTIP, \"unknown\"));\r\n            if (filename.indexOf(\"..\") >= 0) sb.getLog().logFine(\"RankingTransmission: rejected wrong path '\" + filename + \"' from peer \" + otherseed.getName() + \"/\" + otherseed.getPublicAddress()+ \", current IP \" + header.get(httpHeader.CONNECTION_PROP_CLIENTIP, \"unknown\"));\r\n            return prop;\r\n        }\r\n        \r\n        String otherpeerName = otherseed.hash + \":\" + otherseed.getName();\r\n        \r\n        if (process.equals(\"permission\")) {\r\n            prop.put(\"process\", \"0\");\r\n            if (((purpose.equals(\"crcon\")) && (filename.startsWith(\"CRG\")) && (filename.endsWith(\".cr.gz\"))) || ((filename.startsWith(\"domlist\")) && (filename.endsWith(\".txt.gz\") || filename.endsWith(\".zip\")))) {\r\n                // consolidation of cr files\r\n                //System.out.println(\"yacy/transfer:post=\" + post.toString());\r\n                //String cansendprotocol = (String) post.get(\"can-send-protocol\", \"http\");\r\n                String access = kelondroBase64Order.enhancedCoder.encode(serverCodings.encodeMD5Raw(otherpeer + \":\" + filename)) + \":\" + kelondroBase64Order.enhancedCoder.encode(serverCodings.encodeMD5Raw(\"\" + System.currentTimeMillis()));\r\n                prop.put(\"response\", \"ok\");\r\n                prop.put(\"process_access\", access);\r\n                prop.put(\"process_address\", yacyCore.seedDB.mySeed().getPublicAddress());\r\n                prop.put(\"process_protocol\", \"http\");\r\n                prop.put(\"process_path\", \"\");  // currently empty; the store process will find a path\r\n                prop.put(\"process_maxsize\", \"-1\"); // if response is too big we return the size of the file\r\n                sb.rankingPermissions.put(serverCodings.encodeMD5Hex(kelondroBase64Order.standardCoder.encodeString(access)), filename);\r\n                sb.getLog().logFine(\"RankingTransmission: granted peer \" + otherpeerName + \" to send CR file \" + filename);\r\n            }\r\n            return prop;\r\n        }\r\n\r\n        if (process.equals(\"store\")) {\r\n            prop.put(\"process\", \"1\");\r\n            if (purpose.equals(\"crcon\")) {\r\n                String fileString = post.get(\"filename$file\");\r\n                String accesscode = post.get(\"access\", \"\");   // one-time authentication\r\n                String md5 = post.get(\"md5\", \"\");   // one-time authentication\r\n                //java.util.HashMap perm = sb.rankingPermissions;\r\n                //System.out.println(\"PERMISSIONDEBUG: accesscode=\" + accesscode + \", permissions=\" + perm.toString());\r\n                String grantedFile = (String) sb.rankingPermissions.get(accesscode);\r\n                prop.put(\"process_tt\", \"\");\r\n                if ((grantedFile == null) || (!(grantedFile.equals(filename)))) {\r\n                    // fraud-access of this interface\r\n                    prop.put(\"response\", \"denied\");\r\n                    sb.getLog().logFine(\"RankingTransmission: denied \" + otherpeerName + \" to send CR file \" + filename + \": wrong access code\");\r\n                } else {\r\n                    sb.rankingPermissions.remove(accesscode); // not needed any more\r\n                    File path = new File(sb.rankingPath, plasmaRankingDistribution.CR_OTHER);\r\n                    path.mkdirs();\r\n                    File file = new File(path, filename);\r\n                    try {\r\n                        if (file.getCanonicalPath().toString().startsWith(path.getCanonicalPath().toString())){\r\n                            serverFileUtils.write(fileString.getBytes(), file);\r\n                            String md5t = serverCodings.encodeMD5Hex(file);\r\n                            if (md5t.equals(md5)) {\r\n                                prop.put(\"response\", \"ok\");\r\n                                sb.getLog().logFine(\"RankingTransmission: received from peer \" + otherpeerName + \" CR file \" + filename);\r\n                            } else {\r\n                                prop.put(\"response\", \"transfer failure\");\r\n                                sb.getLog().logFine(\"RankingTransmission: transfer failure from peer \" + otherpeerName + \" for CR file \" + filename);\r\n                            }\r\n                        }else{\r\n                            //exploit?\r\n                            prop.put(\"response\", \"io error\");\r\n                            return prop;\r\n                        }\r\n                    } catch (IOException e) {\r\n                        prop.put(\"response\", \"io error\");\r\n                    }\r\n                }\r\n            }\r\n            return prop;\r\n        }\r\n\r\n        // wrong access\r\n        sb.getLog().logFine(\"RankingTransmission: rejected unknown process \" + process + \":\" + purpose + \" from peer \" + otherpeerName);\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws InterruptedException {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n\r\n        if (!post.containsKey(\"wordc\")) return prop;\r\n        if (!post.containsKey(\"entryc\")) return prop;\r\n\r\n        // request values\r\n        final String ohash  = post.get(\"iam\", \"\");                // seed hash of requester\r\n        final String youare = post.get(\"youare\", \"\");             // seed hash of the target peer, needed for network stability\r\n//      final String key    = (String) post.get(\"key\", \"\");       // transmission key\r\n        final int wordc     = post.getInt(\"wordc\", 0);            // number of different words\r\n        final int entryc    = post.getInt(\"entryc\", 0);           // number of entries in indexes\r\n        byte[] indexes      = post.get(\"indexes\", \"\").getBytes(); // the indexes, as list of word entries\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        boolean granted       = sb.getConfig(\"allowReceiveIndex\", \"false\").equals(\"true\");\r\n        boolean blockBlacklist = sb.getConfig(\"indexReceiveBlockBlacklist\", \"false\").equals(\"true\");\r\n        boolean checkLimit    = sb.getConfigBool(\"indexDistribution.transferRWIReceiptLimitEnabled\", true);\r\n        final long cachelimit = sb.getConfigLong(\"indexDistribution.dhtReceiptLimit\", 10000);\r\n\r\n        final yacySeed oseed = yacyCore.seedDB.get(ohash);\r\n        if (oseed == null) {\r\n            prop.put(\"unknownURL\", \"\");\r\n            prop.put(\"result\", \"busy\");\r\n            prop.put(\"pause\", \"120000\");\r\n            return prop;\r\n        } else {\r\n            oseed.setFlagDirectConnect(true);\r\n            oseed.setLastSeenUTC();\r\n        }\r\n        final String oname = ohash + \":\" + oseed.getName() + \"/\" + oseed.getVersion();\r\n\r\n        // response values\r\n        String       result      = \"ok\";\r\n        StringBuffer unknownURLs = new StringBuffer();\r\n        int          pause       = 10000;\r\n\r\n        if ((youare == null) || (!youare.equals(yacyCore.seedDB.mySeed().hash))) {\r\n        \tsb.getLog().logInfo(\"Rejecting RWIs from peer \" + oname + \". Wrong target. Wanted peer=\" + youare + \", iam=\" + yacyCore.seedDB.mySeed().hash);\r\n            result = \"wrong_target\";\r\n            pause = 0;\r\n        } else if ((!granted) || (sb.isRobinsonMode())) {\r\n            // we dont want to receive indexes\r\n            sb.getLog().logInfo(\"Rejecting RWIs from peer \" + oname + \". Not granted.\");\r\n            result = \"not_granted\";\r\n            pause = 0;\r\n        } else if (checkLimit && sb.wordIndex.dhtInCacheSize() > cachelimit) {\r\n            // we are too busy to receive indexes\r\n            sb.getLog().logInfo(\"Rejecting RWIs from peer \" + oname + \". We are too busy (buffersize=\" + sb.wordIndex.dhtInCacheSize() + \").\");\r\n            granted = false; // don't accept more words if there are too many words to flush\r\n            result = \"busy\";\r\n            pause = 60000;\r\n        } /* else if ((checkLimit && sb.wordIndex.dhtOutCacheSize() > sb.getConfigLong(plasmaSwitchboard.WORDCACHE_MAX_COUNT, 20000)) || ((sb.wordIndex.busyCacheFlush) && (!shortCacheFlush))) {\r\n            // we are too busy flushing the ramCache to receive indexes\r\n            sb.getLog().logInfo(\"Rejecting RWIs from peer \" + otherPeerName + \". We are too busy (wordcachesize=\" + sb.wordIndex.dhtOutCacheSize() + \").\");\r\n            granted = false; // don't accept more words if there are too many words to flush\r\n            result = \"busy\";\r\n            pause = 300000;\r\n        } */ else {\r\n            // we want and can receive indexes\r\n            // log value status (currently added to find outOfMemory error\r\n            sb.getLog().logFine(\"Processing \" + indexes.length + \" bytes / \" + wordc + \" words / \" + entryc + \" entries from \" + oname);\r\n            final long startProcess = System.currentTimeMillis();\r\n\r\n            // decode request\r\n            final List<String> v = nxTools.strings(indexes, null);\r\n\r\n            // free memory\r\n            indexes = null;\r\n            \r\n            // the value-vector should now have the same length as entryc\r\n            if (v.size() != entryc) sb.getLog().logSevere(\"ERROR WITH ENTRY COUNTER: v=\" + v.size() + \", entryc=\" + entryc);\r\n\r\n            // now parse the Strings in the value-vector and write index entries\r\n            String estring;\r\n            int p;\r\n            String wordHash;\r\n            String urlHash;\r\n            indexRWIRowEntry iEntry;\r\n            final HashSet<String> unknownURL = new HashSet<String>();\r\n            final HashSet<String> knownURL = new HashSet<String>();\r\n            String[] wordhashes = new String[v.size()];\r\n            int received = 0;\r\n            int blocked = 0;\r\n            int receivedURL = 0;\r\n            Iterator<String> i = v.iterator();\r\n            while (i.hasNext()) {\r\n                serverCore.checkInterruption();\r\n                estring = (String) i.next();\r\n                \r\n                // check if RWI entry is well-formed\r\n                p = estring.indexOf(\"{\");\r\n                if ((p < 0) || (estring.indexOf(\"x=\") < 0)) {\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                wordHash = estring.substring(0, p);\r\n                wordhashes[received] = wordHash;\r\n                iEntry = new indexRWIRowEntry(estring.substring(p));\r\n                urlHash = iEntry.urlHash();\r\n                \r\n                // block blacklisted entries\r\n                if ((blockBlacklist) && (plasmaSwitchboard.urlBlacklist.hashInBlacklistedCache(plasmaURLPattern.BLACKLIST_DHT, urlHash))) {\r\n                    int deleted = sb.wordIndex.tryRemoveURLs(urlHash);\r\n                    yacyCore.log.logFine(\"transferRWI: blocked blacklisted URLHash '\" + urlHash + \"' from peer \" + oname + \"; deleted \" + deleted + \" URL entries from RWIs\");\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // learn entry\r\n                sb.wordIndex.addEntry(wordHash, iEntry, System.currentTimeMillis(), true);\r\n                serverCore.checkInterruption();\r\n\r\n                // check if we need to ask for the corresponding URL\r\n                if (!(knownURL.contains(urlHash)||unknownURL.contains(urlHash)))  try {\r\n                    if (sb.wordIndex.loadedURL.exists(urlHash)) {\r\n                        knownURL.add(urlHash);\r\n                    } else {\r\n                        unknownURL.add(urlHash);\r\n                    }\r\n                    receivedURL++;\r\n                } catch (Exception ex) {\r\n                    sb.getLog().logWarning(\r\n                                \"transferRWI: DB-Error while trying to determine if URL with hash '\" +\r\n                                urlHash + \"' is known.\", ex);\r\n                }\r\n                received++;\r\n            }\r\n            yacyCore.seedDB.mySeed().incRI(received);\r\n\r\n            // finally compose the unknownURL hash list\r\n            final Iterator<String> it = unknownURL.iterator();  \r\n            unknownURLs.ensureCapacity(unknownURL.size()*13);\r\n            while (it.hasNext()) {\r\n                unknownURLs.append(\",\").append(it.next());\r\n            }\r\n            if (unknownURLs.length() > 0) { unknownURLs.delete(0, 1); }\r\n            if ((wordhashes.length == 0) || (received == 0)) {\r\n                sb.getLog().logInfo(\"Received 0 RWIs from \" + oname + \", processed in \" + (System.currentTimeMillis() - startProcess) + \" milliseconds, requesting \" + unknownURL.size() + \" URLs, blocked \" + blocked + \" RWIs\");\r\n            } else {\r\n                final double avdist = (yacyDHTAction.dhtDistance(yacyCore.seedDB.mySeed().hash, wordhashes[0]) + yacyDHTAction.dhtDistance(yacyCore.seedDB.mySeed().hash, wordhashes[received - 1])) / 2.0;\r\n                sb.getLog().logInfo(\"Received \" + received + \" Entries \" + wordc + \" Words [\" + wordhashes[0] + \" .. \" + wordhashes[received - 1] + \"]/\" + avdist + \" from \" + oname + \", processed in \" + (System.currentTimeMillis() - startProcess) + \" milliseconds, requesting \" + unknownURL.size() + \"/\" + receivedURL + \" URLs, blocked \" + blocked + \" RWIs\");\r\n            }\r\n            result = \"ok\";\r\n            \r\n            if (checkLimit) {\r\n                pause = (sb.wordIndex.dhtInCacheSize() < 500) ? 0 : sb.wordIndex.dhtInCacheSize(); // estimation of necessary pause time\r\n            }\r\n        }\r\n\r\n        prop.put(\"unknownURL\", unknownURLs.toString());\r\n        prop.put(\"result\", result);\r\n        prop.put(\"pause\", pause);\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":11130,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws InterruptedException {\r\n        \r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        if (!post.containsKey(\"wordc\")) return prop;\r\n        if (!post.containsKey(\"entryc\")) return prop;\r\n        \r\n        // request values\r\n        final String iam      = post.get(\"iam\", \"\");                      // seed hash of requester\r\n        final String youare   = post.get(\"youare\", \"\");                   // seed hash of the target peer, needed for network stability\r\n//      final String key      = (String) post.get(\"key\", \"\");             // transmission key\r\n        final int wordc       = post.getInt(\"wordc\", 0);                  // number of different words\r\n        final int entryc      = post.getInt(\"entryc\", 0);                 // number of entries in indexes\r\n        byte[] indexes        = post.get(\"indexes\", \"\").getBytes();       // the indexes, as list of word entries\r\n        boolean granted       = sb.getConfig(\"allowReceiveIndex\", \"false\").equals(\"true\");\r\n        boolean blockBlacklist = sb.getConfig(\"indexReceiveBlockBlacklist\", \"false\").equals(\"true\");\r\n        boolean checkLimit    = sb.getConfigBool(\"indexDistribution.transferRWIReceiptLimitEnabled\", true);\r\n        final long cachelimit = sb.getConfigLong(\"indexDistribution.dhtReceiptLimit\", 10000);\r\n        final yacySeed otherPeer = yacyCore.seedDB.get(iam);\r\n        final String otherPeerName = iam + \":\" + ((otherPeer == null) ? \"NULL\" : (otherPeer.getName() + \"/\" + otherPeer.getVersion()));                \r\n        \r\n        // response values\r\n        String       result      = \"ok\";\r\n        StringBuffer unknownURLs = new StringBuffer();\r\n        int          pause       = 10000;\r\n        \r\n        if ((youare == null) || (!youare.equals(yacyCore.seedDB.mySeed().hash))) {\r\n        \tsb.getLog().logInfo(\"Rejecting RWIs from peer \" + otherPeerName + \". Wrong target. Wanted peer=\" + youare + \", iam=\" + yacyCore.seedDB.mySeed().hash);\r\n            result = \"wrong_target\";\r\n            pause = 0;\r\n        } else if ((!granted) || (sb.isRobinsonMode())) {\r\n            // we dont want to receive indexes\r\n            sb.getLog().logInfo(\"Rejecting RWIs from peer \" + otherPeerName + \". Not granted.\");\r\n            result = \"not_granted\";\r\n            pause = 0;\r\n        } else if (checkLimit && sb.wordIndex.dhtInCacheSize() > cachelimit) {\r\n            // we are too busy to receive indexes\r\n            sb.getLog().logInfo(\"Rejecting RWIs from peer \" + otherPeerName + \". We are too busy (buffersize=\" + sb.wordIndex.dhtInCacheSize() + \").\");\r\n            granted = false; // don't accept more words if there are too many words to flush\r\n            result = \"busy\";\r\n            pause = 60000;\r\n        } /* else if ((checkLimit && sb.wordIndex.dhtOutCacheSize() > sb.getConfigLong(plasmaSwitchboard.WORDCACHE_MAX_COUNT, 20000)) || ((sb.wordIndex.busyCacheFlush) && (!shortCacheFlush))) {\r\n            // we are too busy flushing the ramCache to receive indexes\r\n            sb.getLog().logInfo(\"Rejecting RWIs from peer \" + otherPeerName + \". We are too busy (wordcachesize=\" + sb.wordIndex.dhtOutCacheSize() + \").\");\r\n            granted = false; // don't accept more words if there are too many words to flush\r\n            result = \"busy\";\r\n            pause = 300000;\r\n        } */ else {\r\n            // we want and can receive indexes\r\n            // log value status (currently added to find outOfMemory error\r\n            sb.getLog().logFine(\"Processing \" + indexes.length + \" bytes / \" + wordc + \" words / \" + entryc + \" entries from \" + otherPeerName);\r\n            final long startProcess = System.currentTimeMillis();\r\n\r\n            // decode request\r\n            final List<String> v = nxTools.strings(indexes, null);\r\n\r\n            // free memory\r\n            indexes = null;\r\n            \r\n            // the value-vector should now have the same length as entryc\r\n            if (v.size() != entryc) sb.getLog().logSevere(\"ERROR WITH ENTRY COUNTER: v=\" + v.size() + \", entryc=\" + entryc);\r\n\r\n            // now parse the Strings in the value-vector and write index entries\r\n            String estring;\r\n            int p;\r\n            String wordHash;\r\n            String urlHash;\r\n            indexRWIRowEntry iEntry;\r\n            final HashSet<String> unknownURL = new HashSet<String>();\r\n            final HashSet<String> knownURL = new HashSet<String>();\r\n            String[] wordhashes = new String[v.size()];\r\n            int received = 0;\r\n            int blocked = 0;\r\n            int receivedURL = 0;\r\n            Iterator<String> i = v.iterator();\r\n            while (i.hasNext()) {\r\n                serverCore.checkInterruption();\r\n                estring = (String) i.next();\r\n                \r\n                // check if RWI entry is well-formed\r\n                p = estring.indexOf(\"{\");\r\n                if ((p < 0) || (estring.indexOf(\"x=\") < 0)) {\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                wordHash = estring.substring(0, p);\r\n                wordhashes[received] = wordHash;\r\n                iEntry = new indexRWIRowEntry(estring.substring(p));\r\n                urlHash = iEntry.urlHash();\r\n                \r\n                // block blacklisted entries\r\n                if ((blockBlacklist) && (plasmaSwitchboard.urlBlacklist.hashInBlacklistedCache(plasmaURLPattern.BLACKLIST_DHT, urlHash))) {\r\n                    int deleted = sb.wordIndex.tryRemoveURLs(urlHash);\r\n                    yacyCore.log.logFine(\"transferRWI: blocked blacklisted URLHash '\" + urlHash + \"' from peer \" + otherPeerName + \"; deleted \" + deleted + \" URL entries from RWIs\");\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // learn entry\r\n                sb.wordIndex.addEntry(wordHash, iEntry, System.currentTimeMillis(), true);\r\n                serverCore.checkInterruption();\r\n\r\n                // check if we need to ask for the corresponding URL\r\n                if (!(knownURL.contains(urlHash)||unknownURL.contains(urlHash)))  try {\r\n                    if (sb.wordIndex.loadedURL.exists(urlHash)) {\r\n                        knownURL.add(urlHash);\r\n                    } else {\r\n                        unknownURL.add(urlHash);\r\n                    }\r\n                    receivedURL++;\r\n                } catch (Exception ex) {\r\n                    sb.getLog().logWarning(\r\n                                \"transferRWI: DB-Error while trying to determine if URL with hash '\" +\r\n                                urlHash + \"' is known.\", ex);\r\n                }\r\n                received++;\r\n            }\r\n            yacyCore.seedDB.mySeed().incRI(received);\r\n\r\n            // finally compose the unknownURL hash list\r\n            final Iterator<String> it = unknownURL.iterator();  \r\n            unknownURLs.ensureCapacity(unknownURL.size()*13);\r\n            while (it.hasNext()) {\r\n                unknownURLs.append(\",\").append(it.next());\r\n            }\r\n            if (unknownURLs.length() > 0) { unknownURLs.delete(0, 1); }\r\n            if ((wordhashes.length == 0) || (received == 0)) {\r\n                sb.getLog().logInfo(\"Received 0 RWIs from \" + otherPeerName + \", processed in \" + (System.currentTimeMillis() - startProcess) + \" milliseconds, requesting \" + unknownURL.size() + \" URLs, blocked \" + blocked + \" RWIs\");\r\n            } else {\r\n                final double avdist = (yacyDHTAction.dhtDistance(yacyCore.seedDB.mySeed().hash, wordhashes[0]) + yacyDHTAction.dhtDistance(yacyCore.seedDB.mySeed().hash, wordhashes[received - 1])) / 2.0;\r\n                sb.getLog().logInfo(\"Received \" + received + \" Entries \" + wordc + \" Words [\" + wordhashes[0] + \" .. \" + wordhashes[received - 1] + \"]/\" + avdist + \" from \" + otherPeerName + \", processed in \" + (System.currentTimeMillis() - startProcess) + \" milliseconds, requesting \" + unknownURL.size() + \"/\" + receivedURL + \" URLs, blocked \" + blocked + \" RWIs\");\r\n            }\r\n            result = \"ok\";\r\n            \r\n            if (checkLimit) {\r\n                pause = (sb.wordIndex.dhtInCacheSize() < 500) ? 0 : sb.wordIndex.dhtInCacheSize(); // estimation of necessary pause time\r\n            }\r\n        }\r\n\r\n        prop.put(\"unknownURL\", unknownURLs.toString());\r\n        prop.put(\"result\", result);\r\n        prop.put(\"pause\", pause);\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws InterruptedException {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        if (post == null || env == null || !yacyNetwork.authentifyRequest(post, env)) {\r\n            return prop;\r\n        }\r\n\r\n        long start = System.currentTimeMillis();\r\n        long freshdate = 0;\r\n        try {freshdate = serverDate.parseShortDay(\"20061101\").getTime();} catch (ParseException e1) {}\r\n\r\n        // request values\r\n        final String ohash  = post.get(\"iam\", \"\");    // seed hash of requester\r\n        final String youare = post.get(\"youare\", \"\"); // seed hash of the target peer, needed for network stability\r\n//      final String key    = post.get(\"key\", \"\");    // transmission key\r\n        final int urlc      = post.getInt(\"urlc\", 0); // number of transported urls\r\n\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        final boolean granted = sb.getConfig(\"allowReceiveIndex\", \"false\").equals(\"true\");\r\n        final boolean blockBlacklist = sb.getConfig(\"indexReceiveBlockBlacklist\", \"false\").equals(\"true\");\r\n\r\n        final yacySeed oseed = yacyCore.seedDB.get(ohash);\r\n        if (oseed == null) {\r\n            prop.put(\"result\", \"error_not_granted\");\r\n            prop.put(\"pause\", \"120000\");\r\n            return prop;\r\n        } else {\r\n            oseed.setFlagDirectConnect(true);\r\n            oseed.setLastSeenUTC();\r\n        }\r\n        final String oname = ohash + \":\" + oseed.getName() + \"/\" + oseed.getVersion();\r\n\r\n        // response values\r\n        String result = \"\";\r\n        String doublevalues = \"0\";\r\n\r\n        if ((youare == null) || (!youare.equals(yacyCore.seedDB.mySeed().hash))) {\r\n        \tsb.getLog().logInfo(\"Rejecting URLs from peer \" + oname + \". Wrong target. Wanted peer=\" + youare + \", iam=\" + yacyCore.seedDB.mySeed().hash);\r\n            result = \"wrong_target\";\r\n        } else if ((!granted) || (sb.isRobinsonMode())) {\r\n        \tsb.getLog().logInfo(\"Rejecting URLs from peer \" + oname + \". Not granted.\");\r\n            result = \"error_not_granted\";\r\n        } else {\r\n            int received = 0;\r\n            int blocked = 0;\r\n            final int sizeBefore = sb.wordIndex.loadedURL.size();\r\n            // read the urls from the other properties and store\r\n            String urls;\r\n            indexURLEntry lEntry;\r\n            for (int i = 0; i < urlc; i++) {\r\n                serverCore.checkInterruption();\r\n                \r\n                // read new lurl-entry\r\n                urls = (String) post.get(\"url\" + i);\r\n                if (urls == null) {\r\n                    yacyCore.log.logFine(\"transferURL: got null URL-string from peer \" + oname);\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n\r\n                // parse new lurl-entry\r\n                lEntry = sb.wordIndex.loadedURL.newEntry(urls);\r\n                if (lEntry == null) {\r\n                    yacyCore.log.logWarning(\"transferURL: received invalid URL (entry null) from peer \" + oname + \"\\n\\tURL Property: \" + urls);\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check if entry is well-formed\r\n                indexURLEntry.Components comp = lEntry.comp();\r\n                if (comp.url() == null) {\r\n                    yacyCore.log.logWarning(\"transferURL: received invalid URL from peer \" + oname + \"\\n\\tURL Property: \" + urls);\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check whether entry is too old\r\n                if (lEntry.freshdate().getTime() <= freshdate) {\r\n                    yacyCore.log.logFine(\"transerURL: received too old URL from peer \" + oname + \": \" + lEntry.freshdate());\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check if the entry is blacklisted\r\n                if ((blockBlacklist) && (plasmaSwitchboard.urlBlacklist.isListed(plasmaURLPattern.BLACKLIST_DHT, comp.url()))) {\r\n                    int deleted = sb.wordIndex.tryRemoveURLs(lEntry.hash());\r\n                    yacyCore.log.logFine(\"transferURL: blocked blacklisted URL '\" + comp.url().toNormalform(false, true) + \"' from peer \" + oname + \"; deleted \" + deleted + \" URL entries from RWIs\");\r\n                    lEntry = null;\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check if the entry is in our network domain\r\n                if (!sb.acceptURL(comp.url())) {\r\n                    yacyCore.log.logFine(\"transferURL: blocked URL outside of our domain '\" + comp.url().toNormalform(false, true) + \"' from peer \" + oname);\r\n                    lEntry = null;\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // write entry to database\r\n                try {\r\n                    sb.wordIndex.loadedURL.store(lEntry);\r\n                    sb.wordIndex.loadedURL.stack(lEntry, ohash, ohash, 3);\r\n                    yacyCore.log.logFine(\"transferURL: received URL '\" + comp.url().toNormalform(false, true) + \"' from peer \" + oname);\r\n                    received++;\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n\r\n            yacyCore.seedDB.mySeed().incRU(received);\r\n\r\n            // return rewrite properties\r\n            final int more = sb.wordIndex.loadedURL.size() - sizeBefore;\r\n            doublevalues = Integer.toString(received - more);\r\n            sb.getLog().logInfo(\"Received \" + received + \" URLs from peer \" + oname + \" in \" + (System.currentTimeMillis() - start) + \" ms, Blocked \" + blocked + \" URLs\");\r\n            if ((received - more) > 0) sb.getLog().logSevere(\"Received \" + doublevalues + \" double URLs from peer \" + oname);\r\n            result = \"ok\";\r\n        }\r\n\r\n        prop.put(\"double\", doublevalues);\r\n        prop.put(\"result\", result);\r\n        return prop;\r\n    }","id":11131,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws InterruptedException {\r\n        long start = System.currentTimeMillis();\r\n        long freshdate = 0;\r\n        try {freshdate = serverDate.parseShortDay(\"20061101\").getTime();} catch (ParseException e1) {}\r\n        \r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n\r\n        // request values\r\n        final String iam      = post.get(\"iam\", \"\");      // seed hash of requester\r\n        final String youare   = post.get(\"youare\", \"\");   // seed hash of the target peer, needed for network stability\r\n//      final String key      = post.get(\"key\", \"\");      // transmission key\r\n        final int urlc        = post.getInt(\"urlc\", 0);    // number of transported urls\r\n        final boolean granted = sb.getConfig(\"allowReceiveIndex\", \"false\").equals(\"true\");\r\n        final boolean blockBlacklist = sb.getConfig(\"indexReceiveBlockBlacklist\", \"false\").equals(\"true\");\r\n\r\n        // response values\r\n        String result = \"\";\r\n        String doublevalues = \"0\";\r\n\r\n        final yacySeed otherPeer = yacyCore.seedDB.get(iam);\r\n        final String otherPeerName = iam + \":\" + ((otherPeer == null) ? \"NULL\" : (otherPeer.getName() + \"/\" + otherPeer.getVersion()));\r\n\r\n        if ((youare == null) || (!youare.equals(yacyCore.seedDB.mySeed().hash))) {\r\n        \tsb.getLog().logInfo(\"Rejecting URLs from peer \" + otherPeerName + \". Wrong target. Wanted peer=\" + youare + \", iam=\" + yacyCore.seedDB.mySeed().hash);\r\n            result = \"wrong_target\";\r\n        } else if ((!granted) || (sb.isRobinsonMode())) {\r\n        \tsb.getLog().logInfo(\"Rejecting URLs from peer \" + otherPeerName + \". Not granted.\");\r\n            result = \"error_not_granted\";\r\n        } else {\r\n            int received = 0;\r\n            int blocked = 0;\r\n            final int sizeBefore = sb.wordIndex.loadedURL.size();\r\n            // read the urls from the other properties and store\r\n            String urls;\r\n            indexURLEntry lEntry;\r\n            for (int i = 0; i < urlc; i++) {\r\n                serverCore.checkInterruption();\r\n                \r\n                // read new lurl-entry\r\n                urls = (String) post.get(\"url\" + i);\r\n                if (urls == null) {\r\n                    yacyCore.log.logFine(\"transferURL: got null URL-string from peer \" + otherPeerName);\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n\r\n                // parse new lurl-entry\r\n                lEntry = sb.wordIndex.loadedURL.newEntry(urls);\r\n                if (lEntry == null) {\r\n                    yacyCore.log.logWarning(\"transferURL: received invalid URL (entry null) from peer \" + otherPeerName + \"\\n\\tURL Property: \" + urls);\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check if entry is well-formed\r\n                indexURLEntry.Components comp = lEntry.comp();\r\n                if (comp.url() == null) {\r\n                    yacyCore.log.logWarning(\"transferURL: received invalid URL from peer \" + otherPeerName + \"\\n\\tURL Property: \" + urls);\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check whether entry is too old\r\n                if (lEntry.freshdate().getTime() <= freshdate) {\r\n                    yacyCore.log.logFine(\"transerURL: received too old URL from peer \" + otherPeerName + \": \" + lEntry.freshdate());\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check if the entry is blacklisted\r\n                if ((blockBlacklist) && (plasmaSwitchboard.urlBlacklist.isListed(plasmaURLPattern.BLACKLIST_DHT, comp.url()))) {\r\n                    int deleted = sb.wordIndex.tryRemoveURLs(lEntry.hash());\r\n                    yacyCore.log.logFine(\"transferURL: blocked blacklisted URL '\" + comp.url().toNormalform(false, true) + \"' from peer \" + otherPeerName + \"; deleted \" + deleted + \" URL entries from RWIs\");\r\n                    lEntry = null;\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // check if the entry is in our network domain\r\n                if (!sb.acceptURL(comp.url())) {\r\n                    yacyCore.log.logFine(\"transferURL: blocked URL outside of our domain '\" + comp.url().toNormalform(false, true) + \"' from peer \" + otherPeerName);\r\n                    lEntry = null;\r\n                    blocked++;\r\n                    continue;\r\n                }\r\n                \r\n                // write entry to database\r\n                try {\r\n                    sb.wordIndex.loadedURL.store(lEntry);\r\n                    sb.wordIndex.loadedURL.stack(lEntry, iam, iam, 3);\r\n                    yacyCore.log.logFine(\"transferURL: received URL '\" + comp.url().toNormalform(false, true) + \"' from peer \" + otherPeerName);\r\n                    received++;\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n\r\n            yacyCore.seedDB.mySeed().incRU(received);\r\n\r\n            // return rewrite properties\r\n            final int more = sb.wordIndex.loadedURL.size() - sizeBefore;\r\n            doublevalues = Integer.toString(received - more);\r\n            sb.getLog().logInfo(\"Received \" + received + \" URLs from peer \" + otherPeerName + \" in \" + (System.currentTimeMillis() - start) + \" ms, Blocked \" + blocked + \" URLs\");\r\n            if ((received - more) > 0) sb.getLog().logSevere(\"Received \" + doublevalues + \" double URLs from peer \" + otherPeerName);\r\n            result = \"ok\";\r\n        }\r\n\r\n        prop.put(\"double\", doublevalues);\r\n        prop.put(\"result\", result);\r\n        return prop;\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private int publishMySeed(boolean force) {\r\n        try {\r\n            // call this after the httpd was started up\r\n\r\n            // we need to find out our own ip\r\n            // This is not always easy, since the application may\r\n            // live behind a firewall or nat.\r\n            // the normal way to do this is either measure the value that java gives us,\r\n            // but this is not correct if the peer lives behind a NAT/Router or has several\r\n            // addresses and not the right one can be found out.\r\n            // We have several alternatives:\r\n            // 1. ask another peer. This should be normal and the default method.\r\n            //    but if no other peer lives, or we don't know them, we cannot do that\r\n            // 2. ask own NAT. This is only an option if the NAT is a DI604, because this is the\r\n            //    only supported for address retrieval\r\n            // 3. ask ip respond services in the internet. There are several, and they are all\r\n            //    probed until we get a valid response.\r\n\r\n            // init yacyHello-process\r\n            Map<String, yacySeed> seeds; // hash/yacySeed relation\r\n\r\n            int attempts = seedDB.sizeConnected();\r\n\r\n            // getting a list of peers to contact\r\n            if (seedDB.mySeed().isVirgin()) {\r\n                attempts = Math.min(attempts, PING_INITIAL);\r\n                final Map<String, String> ch = plasmaSwitchboard.getSwitchboard().clusterhashes;\r\n                seeds = seedDB.seedsByAge(true, attempts - ((ch == null) ? 0 : ch.size())); // best for fast connection\r\n                // add also all peers from cluster if this is a public robinson cluster\r\n                if (plasmaSwitchboard.getSwitchboard().clusterhashes != null) {\r\n                    final Iterator<Map.Entry<String, String>> i = ch.entrySet().iterator();\r\n                    String hash;\r\n                    Map.Entry<String, String> entry;\r\n                    yacySeed seed;\r\n                    while (i.hasNext()) {\r\n                        entry = i.next();\r\n                        hash = entry.getKey();\r\n                        seed = seeds.get(hash);\r\n                        if (seed == null) {\r\n                            seed = seedDB.get(hash);\r\n                            if (seed == null) { continue; }\r\n                        }\r\n                        seed.setAlternativeAddress(entry.getValue());\r\n                        seeds.put(hash, seed);\r\n                    }\r\n                }\r\n            } else {\r\n                seeds = seedDB.getOldestSeeds(attempts / 5, PING_MIN_LASTSEEN);\r\n            }\r\n            if (seeds == null || seeds.size() == 0) { return 0; }\r\n            attempts = seeds.size();\r\n\r\n            // include a YaCyNews record to my seed\r\n            try {\r\n                final yacyNewsRecord record = newsPool.myPublication();\r\n                if (record == null) {\r\n                    seedDB.mySeed().put(\"news\", \"\");\r\n                } else {\r\n                    seedDB.mySeed().put(\"news\", de.anomic.tools.crypt.simpleEncode(record.toString()));\r\n                }\r\n            } catch (IOException e) {\r\n                log.logSevere(\"publishMySeed: problem with news encoding\", e);\r\n            }\r\n            seedDB.mySeed().setUnusedFlags();\r\n\r\n            // include current citation-rank file count\r\n            seedDB.mySeed().put(yacySeed.CRWCNT, Integer.toString(switchboard.rankingOwnDistribution.size()));\r\n            seedDB.mySeed().put(yacySeed.CRTCNT, Integer.toString(switchboard.rankingOtherDistribution.size()));\r\n            int newSeeds = -1;\r\n            //if (seeds.length > 1) {\r\n            // holding a reference to all started threads\r\n            int contactedSeedCount = 0;\r\n            final List<Thread> syncList = Collections.synchronizedList(new LinkedList<Thread>()); // memory for threads\r\n            final serverSemaphore sync = new serverSemaphore(attempts);\r\n\r\n            // This will try to get Peers that are not currently in amIAccessibleDB\r\n            Iterator<yacySeed> si = seeds.values().iterator();\r\n            yacySeed seed;\r\n\r\n            // going through the peer list and starting a new publisher thread for each peer\r\n            int i = 0;\r\n            while (si.hasNext()) {\r\n                seed = si.next();\r\n                if (seed == null) {\r\n                    sync.P();\r\n                    continue;\r\n                }\r\n                i++;\r\n\r\n                final String address = seed.getClusterAddress();\r\n                log.logFine(\"HELLO #\" + i + \" to peer '\" + seed.get(yacySeed.NAME, \"\") + \"' at \" + address); // debug\r\n                final String seederror = seed.isProper();\r\n                if (address == null || seederror != null) {\r\n                    // we don't like that address, delete it\r\n                    peerActions.peerDeparture(seed, \"peer ping to peer resulted in address = \" + address + \"; seederror = \" + seederror);\r\n                    sync.P();\r\n                } else {\r\n                    // starting a new publisher thread\r\n                    contactedSeedCount++;\r\n                    (new publishThread(yacyCore.publishThreadGroup, seed, sync, syncList)).start();\r\n                }\r\n            }\r\n\r\n            // receiving the result of all started publisher threads\r\n            for (int j = 0; j < contactedSeedCount; j++) {\r\n\r\n                // waiting for the next thread to finish\r\n                sync.P();\r\n\r\n                // if this is true something is wrong ...\r\n                if (syncList.isEmpty()) {\r\n                    log.logWarning(\"PeerPing: syncList.isEmpty()==true\");\r\n                    continue;\r\n                    //return 0;\r\n                }\r\n\r\n                // getting a reference to the finished thread\r\n                final publishThread t = (publishThread) syncList.remove(0);\r\n\r\n                // getting the amount of new reported seeds\r\n                if (t.added >= 0) {\r\n                    if (newSeeds == -1) {\r\n                        newSeeds =  t.added;\r\n                    } else {\r\n                        newSeeds += t.added;\r\n                    }\r\n                }\r\n            }\r\n\r\n            int accessible = 0;\r\n            int notaccessible = 0;\r\n            final long cutofftime = System.currentTimeMillis() - PING_MAX_DBAGE;\r\n            final int dbSize;\r\n            synchronized (amIAccessibleDB) {\r\n                dbSize = amIAccessibleDB.size();\r\n                final Iterator<String> ai = amIAccessibleDB.keySet().iterator();\r\n                while (ai.hasNext()) {\r\n                    final yacyAccessible ya = amIAccessibleDB.get(ai.next());\r\n                    if (ya.lastUpdated < cutofftime) {\r\n                        ai.remove();\r\n                    } else {\r\n                        if (ya.IWasAccessed) {\r\n                            accessible++;\r\n                        } else {\r\n                            notaccessible++;\r\n                        }\r\n                    }\r\n                }\r\n                log.logFine(\"DBSize before -> after Cleanup: \" + dbSize + \" -> \" + amIAccessibleDB.size());\r\n            }\r\n            log.logInfo(\"PeerPing: I am accessible for \" + accessible +\r\n                \" peer(s), not accessible for \" + notaccessible + \" peer(s).\");\r\n\r\n            if (accessible + notaccessible > 0) {\r\n                final String newPeerType;\r\n                // At least one other Peer told us our type\r\n                if (accessible >= PING_MIN_PEERSEEN ||\r\n                    accessible >= notaccessible) {\r\n                    // We can be reached from a majority of other Peers\r\n                    if (yacyCore.seedDB.mySeed().isPrincipal()) {\r\n                        newPeerType = yacySeed.PEERTYPE_PRINCIPAL;\r\n                    } else {\r\n                        newPeerType = yacySeed.PEERTYPE_SENIOR;\r\n                    }\r\n                } else {\r\n                    // We cannot be reached from the outside\r\n                    newPeerType = yacySeed.PEERTYPE_JUNIOR;\r\n                }\r\n                if (yacyCore.seedDB.mySeed().isType(newPeerType)) {\r\n                    log.logInfo(\"PeerPing: myType is \" + yacyCore.seedDB.mySeed().orVirgin());\r\n                } else {\r\n                    log.logInfo(\"PeerPing: changing myType from '\" + yacyCore.seedDB.mySeed().orVirgin() + \"' to '\" + newPeerType + \"'\");\r\n                    yacyCore.seedDB.mySeed().setType(newPeerType);\r\n                }\r\n            } else {\r\n                log.logInfo(\"PeerPing: No data, staying at myType: \" + yacyCore.seedDB.mySeed().orVirgin());\r\n            }\r\n\r\n            if (newSeeds >= 0) {\r\n                // success! we have published our peer to a senior peer\r\n                // update latest news from the other peer\r\n                // log.logInfo(\"publish: handshaked \" + t.seed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR) + \" peer '\" + t.seed.getName() + \"' at \" + t.seed.getAddress());\r\n                peerActions.saveMySeed();\r\n                return newSeeds;\r\n            }\r\n\r\n            // if we have an address, we do nothing\r\n            if (seedDB.mySeed().isProper() == null && !force) { return 0; }\r\n\r\n            // still no success: ask own NAT or internet responder\r\n            //final boolean DI604use = switchboard.getConfig(\"DI604use\", \"false\").equals(\"true\");\r\n            //final String  DI604pw  = switchboard.getConfig(\"DI604pw\", \"\");\r\n            String  ip = switchboard.getConfig(\"staticIP\", \"\");\r\n            //if (ip.equals(\"\")) ip = natLib.retrieveIP(DI604use, DI604pw);\r\n            \r\n            // yacyCore.log.logDebug(\"DEBUG: new IP=\" + ip);\r\n            seedDB.mySeed().put(yacySeed.IP, ip);\r\n            if (seedDB.mySeed().get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_JUNIOR).equals(yacySeed.PEERTYPE_JUNIOR)) // ???????????????\r\n                seedDB.mySeed().put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR); // to start bootstraping, we need to be recognised as PEERTYPE_SENIOR peer\r\n            log.logInfo(\"publish: no recipient found, our address is \" +\r\n                    ((seedDB.mySeed().getPublicAddress() == null) ? \"unknown\" : seedDB.mySeed().getPublicAddress()));\r\n            peerActions.saveMySeed();\r\n            return 0;\r\n        } catch (InterruptedException e) {\r\n            try {\r\n                log.logInfo(\"publish: Interruption detected while publishing my seed.\");\r\n\r\n                // consuming the theads interrupted signal\r\n                Thread.interrupted();\r\n\r\n                // interrupt all already started publishThreads\r\n                log.logInfo(\"publish: Signaling shutdown to \" + yacyCore.publishThreadGroup.activeCount() +  \" remaining publishing threads ...\");\r\n                yacyCore.publishThreadGroup.interrupt();\r\n\r\n                // waiting some time for the publishThreads to finish execution\r\n                try { Thread.sleep(500); } catch (InterruptedException ex) {}\r\n\r\n                // getting the amount of remaining publishing threads\r\n                int threadCount  = yacyCore.publishThreadGroup.activeCount();\r\n                final Thread[] threadList = new Thread[threadCount];\r\n                threadCount = yacyCore.publishThreadGroup.enumerate(threadList);\r\n\r\n                // we need to use a timeout here because of missing interruptable session threads ...\r\n                log.logFine(\"publish: Trying to abort \" + yacyCore.publishThreadGroup.activeCount() +  \" remaining publishing threads ...\");\r\n                for (int currentThreadIdx = 0; currentThreadIdx < threadCount; currentThreadIdx++) {\r\n                    Thread currentThread = threadList[currentThreadIdx];\r\n\r\n                    if (currentThread.isAlive()) {\r\n                        // TODO: this object should care of all open clien connections within this class and close them here\r\n                    }\r\n                }\r\n\r\n                // we need to use a timeout here because of missing interruptable session threads ...\r\n                log.logFine(\"publish: Waiting for \" + yacyCore.publishThreadGroup.activeCount() +  \" remaining publishing threads to finish shutdown ...\");\r\n                for (int currentThreadIdx = 0; currentThreadIdx < threadCount; currentThreadIdx++) {\r\n                    final Thread currentThread = threadList[currentThreadIdx];\r\n\r\n                    if (currentThread.isAlive()) {\r\n                        log.logFine(\"publish: Waiting for remaining publishing thread '\" + currentThread.getName() + \"' to finish shutdown\");\r\n                        try { currentThread.join(500); } catch (InterruptedException ex) {}\r\n                    }\r\n                }\r\n\r\n                log.logInfo(\"publish: Shutdown off all remaining publishing thread finished.\");\r\n\r\n            } catch (Exception ee) {\r\n                log.logWarning(\"publish: Unexpected error while trying to shutdown all remaining publishing threads.\", e);\r\n            }\r\n\r\n            return 0;\r\n        }\r\n    }","id":11132,"modified_method":"private int publishMySeed(boolean force) {\r\n        try {\r\n            // call this after the httpd was started up\r\n\r\n            // we need to find out our own ip\r\n            // This is not always easy, since the application may\r\n            // live behind a firewall or nat.\r\n            // the normal way to do this is either measure the value that java gives us,\r\n            // but this is not correct if the peer lives behind a NAT/Router or has several\r\n            // addresses and not the right one can be found out.\r\n            // We have several alternatives:\r\n            // 1. ask another peer. This should be normal and the default method.\r\n            //    but if no other peer lives, or we don't know them, we cannot do that\r\n            // 2. ask own NAT. This is only an option if the NAT is a DI604, because this is the\r\n            //    only supported for address retrieval\r\n            // 3. ask ip respond services in the internet. There are several, and they are all\r\n            //    probed until we get a valid response.\r\n\r\n            // init yacyHello-process\r\n            Map<String, yacySeed> seeds; // hash/yacySeed relation\r\n\r\n            int attempts = seedDB.sizeConnected();\r\n\r\n            // getting a list of peers to contact\r\n            if (seedDB.mySeed().get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_VIRGIN).equals(yacySeed.PEERTYPE_VIRGIN)) {\r\n                if (attempts > PING_INITIAL) { attempts = PING_INITIAL; }\r\n                Map<String, String> ch = plasmaSwitchboard.getSwitchboard().clusterhashes;\r\n                seeds = seedDB.seedsByAge(true, attempts - ((ch == null) ? 0 : ch.size())); // best for fast connection\r\n                // add also all peers from cluster if this is a public robinson cluster\r\n                if (plasmaSwitchboard.getSwitchboard().clusterhashes != null) {\r\n                    Iterator<Map.Entry<String, String>> i = ch.entrySet().iterator();\r\n                    String hash;\r\n                    Map.Entry<String, String> entry;\r\n                    yacySeed seed;\r\n                    while (i.hasNext()) {\r\n                        entry = i.next();\r\n                        hash = entry.getKey();\r\n                        seed = (yacySeed) seeds.get(hash);\r\n                        if (seed == null) {\r\n                            seed = seedDB.get(hash);\r\n                            if (seed == null) continue;\r\n                        }\r\n                        seed.setAlternativeAddress((String) entry.getValue());\r\n                        seeds.put(hash, seed);\r\n                \t}\r\n                }\r\n            } else {\r\n                int diff = PING_MIN_DBSIZE - amIAccessibleDB.size();\r\n                if (diff > PING_MIN_RUNNING) {\r\n                    diff = Math.min(diff, PING_MAX_RUNNING);\r\n                    if (attempts > diff) { attempts = diff; }\r\n                } else {\r\n                    if (attempts > PING_MIN_RUNNING) { attempts = PING_MIN_RUNNING; }\r\n                }\r\n                seeds = seedDB.seedsByAge(false, attempts); // best for seed list maintenance/cleaning\r\n            }\r\n\r\n            if ((seeds == null) || seeds.size() == 0) { return 0; }\r\n            if (seeds.size() < attempts) { attempts = seeds.size(); }\r\n\r\n            // This will try to get Peers that are not currently in amIAccessibleDB\r\n            Iterator<yacySeed> si = seeds.values().iterator();\r\n            yacySeed seed;\r\n\r\n            // include a YaCyNews record to my seed\r\n            try {\r\n                final yacyNewsRecord record = newsPool.myPublication();\r\n                if (record == null) {\r\n                    seedDB.mySeed().put(\"news\", \"\");\r\n                } else {\r\n                    seedDB.mySeed().put(\"news\", de.anomic.tools.crypt.simpleEncode(record.toString()));\r\n                }\r\n            } catch (IOException e) {\r\n                log.logSevere(\"publishMySeed: problem with news encoding\", e);\r\n            }\r\n            seedDB.mySeed().setUnusedFlags();\r\n\r\n            // include current citation-rank file count\r\n            seedDB.mySeed().put(yacySeed.CRWCNT, Integer.toString(switchboard.rankingOwnDistribution.size()));\r\n            seedDB.mySeed().put(yacySeed.CRTCNT, Integer.toString(switchboard.rankingOtherDistribution.size()));\r\n            int newSeeds = -1;\r\n            //if (seeds.length > 1) {\r\n            // holding a reference to all started threads\r\n            int contactedSeedCount = 0;\r\n            final List<Thread> syncList = Collections.synchronizedList(new LinkedList<Thread>()); // memory for threads\r\n            final serverSemaphore sync = new serverSemaphore(attempts);\r\n\r\n            // going through the peer list and starting a new publisher thread for each peer\r\n            int i = 0;\r\n            while (si. hasNext()) {\r\n                seed = (yacySeed) si.next();\r\n                if (seed == null) {\r\n                    sync.P();\r\n                    continue;\r\n                }\r\n                i++;\r\n\r\n                final String address = seed.getClusterAddress();\r\n                log.logFine(\"HELLO #\" + i + \" to peer '\" + seed.get(yacySeed.NAME, \"\") + \"' at \" + address); // debug\r\n                String seederror = seed.isProper();\r\n                if ((address == null) || (seederror != null)) {\r\n                    // we don't like that address, delete it\r\n                    peerActions.peerDeparture(seed, \"peer ping to peer resulted in address = \" + address + \"; seederror = \" + seederror);\r\n                    sync.P();\r\n                } else {\r\n                    // starting a new publisher thread\r\n                    contactedSeedCount++;\r\n                    (new publishThread(yacyCore.publishThreadGroup, seed, sync, syncList)).start();\r\n                }\r\n            }\r\n\r\n            // receiving the result of all started publisher threads\r\n            for (int j = 0; j < contactedSeedCount; j++) {\r\n\r\n                // waiting for the next thread to finish\r\n                sync.P();\r\n\r\n                // if this is true something is wrong ...\r\n                if (syncList.isEmpty()) {\r\n                    log.logWarning(\"PeerPing: syncList.isEmpty()==true\");\r\n                    continue;\r\n                    //return 0;\r\n                }\r\n\r\n                // getting a reference to the finished thread\r\n                final publishThread t = (publishThread) syncList.remove(0);\r\n\r\n                // getting the amount of new reported seeds\r\n                if (t.added >= 0) {\r\n                    if (newSeeds == -1) {\r\n                        newSeeds =  t.added;\r\n                    } else {\r\n                        newSeeds += t.added;\r\n                    }\r\n                }\r\n            }\r\n\r\n            int accessible = 0;\r\n            int notaccessible = 0;\r\n            final long cutofftime = System.currentTimeMillis() - PING_MAX_DBAGE;\r\n            final int dbSize;\r\n            synchronized (amIAccessibleDB) {\r\n                dbSize = amIAccessibleDB.size();\r\n                Iterator<String> ai = amIAccessibleDB.keySet().iterator();\r\n                while (ai.hasNext()) {\r\n                    yacyAccessible ya = (yacyAccessible) amIAccessibleDB.get(ai.next());\r\n                    if (ya.lastUpdated < cutofftime) {\r\n                        ai.remove();\r\n                    } else {\r\n                        if (ya.IWasAccessed) {\r\n                            accessible++;\r\n                        } else {\r\n                            notaccessible++;\r\n                        }\r\n                    }\r\n                }\r\n                log.logFine(\"DBSize before -> after Cleanup: \" + dbSize + \" -> \" + amIAccessibleDB.size());\r\n            }\r\n            log.logInfo(\"PeerPing: I am accessible for \" + accessible +\r\n                \" peer(s), not accessible for \" + notaccessible + \" peer(s).\");\r\n\r\n            if ((accessible + notaccessible) > 0) {\r\n                final String newPeerType;\r\n                // At least one other Peer told us our type\r\n                if ((accessible >= PING_MIN_PEERSEEN) ||\r\n                    (accessible >= notaccessible)) {\r\n                    // We can be reached from a majority of other Peers\r\n                    if (yacyCore.seedDB.mySeed().isPrincipal()) {\r\n                        newPeerType = yacySeed.PEERTYPE_PRINCIPAL;\r\n                    } else {\r\n                        newPeerType = yacySeed.PEERTYPE_SENIOR;\r\n                    }\r\n                } else {\r\n                    // We cannot be reached from the outside\r\n                    newPeerType = yacySeed.PEERTYPE_JUNIOR;\r\n                }\r\n                if (yacyCore.seedDB.mySeed().orVirgin().equals(newPeerType)) {\r\n                    log.logInfo(\"PeerPing: myType is \" + yacyCore.seedDB.mySeed().orVirgin());\r\n                } else {\r\n                    log.logInfo(\"PeerPing: changing myType from '\" + yacyCore.seedDB.mySeed().orVirgin() + \"' to '\" + newPeerType + \"'\");\r\n                    yacyCore.seedDB.mySeed().put(yacySeed.PEERTYPE, newPeerType);\r\n                }\r\n            } else {\r\n                log.logInfo(\"PeerPing: No data, staying at myType: \" + yacyCore.seedDB.mySeed().orVirgin());\r\n            }\r\n\r\n            if (newSeeds >= 0) {\r\n                // success! we have published our peer to a senior peer\r\n                // update latest news from the other peer\r\n                // log.logInfo(\"publish: handshaked \" + t.seed.get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR) + \" peer '\" + t.seed.getName() + \"' at \" + t.seed.getAddress());\r\n                peerActions.saveMySeed();\r\n                return newSeeds;\r\n            }\r\n\r\n            // if we have an address, we do nothing\r\n            if (seedDB.mySeed().isProper() == null && !force) { return 0; }\r\n\r\n            // still no success: ask own NAT or internet responder\r\n            //final boolean DI604use = switchboard.getConfig(\"DI604use\", \"false\").equals(\"true\");\r\n            //final String  DI604pw  = switchboard.getConfig(\"DI604pw\", \"\");\r\n            String  ip = switchboard.getConfig(\"staticIP\", \"\");\r\n            //if (ip.equals(\"\")) ip = natLib.retrieveIP(DI604use, DI604pw);\r\n            \r\n            // yacyCore.log.logDebug(\"DEBUG: new IP=\" + ip);\r\n            seedDB.mySeed().put(yacySeed.IP, ip);\r\n            if (seedDB.mySeed().get(yacySeed.PEERTYPE, yacySeed.PEERTYPE_JUNIOR).equals(yacySeed.PEERTYPE_JUNIOR)) // ???????????????\r\n                seedDB.mySeed().put(yacySeed.PEERTYPE, yacySeed.PEERTYPE_SENIOR); // to start bootstraping, we need to be recognised as PEERTYPE_SENIOR peer\r\n            log.logInfo(\"publish: no recipient found, our address is \" +\r\n                    ((seedDB.mySeed().getPublicAddress() == null) ? \"unknown\" : seedDB.mySeed().getPublicAddress()));\r\n            peerActions.saveMySeed();\r\n            return 0;\r\n        } catch (InterruptedException e) {\r\n            try {\r\n                log.logInfo(\"publish: Interruption detected while publishing my seed.\");\r\n\r\n                // consuming the theads interrupted signal\r\n                Thread.interrupted();\r\n\r\n                // interrupt all already started publishThreads\r\n                log.logInfo(\"publish: Signaling shutdown to \" + yacyCore.publishThreadGroup.activeCount() +  \" remaining publishing threads ...\");\r\n                yacyCore.publishThreadGroup.interrupt();\r\n\r\n                // waiting some time for the publishThreads to finish execution\r\n                try { Thread.sleep(500); } catch (InterruptedException ex) {}\r\n\r\n                // getting the amount of remaining publishing threads\r\n                int threadCount  = yacyCore.publishThreadGroup.activeCount();\r\n                final Thread[] threadList = new Thread[threadCount];\r\n                threadCount = yacyCore.publishThreadGroup.enumerate(threadList);\r\n\r\n                // we need to use a timeout here because of missing interruptable session threads ...\r\n                log.logFine(\"publish: Trying to abort \" + yacyCore.publishThreadGroup.activeCount() +  \" remaining publishing threads ...\");\r\n                for (int currentThreadIdx = 0; currentThreadIdx < threadCount; currentThreadIdx++) {\r\n                    Thread currentThread = threadList[currentThreadIdx];\r\n\r\n                    if (currentThread.isAlive()) {\r\n                        // TODO: this object should care of all open clien connections within this class and close them here\r\n                    }\r\n                }\r\n\r\n                // we need to use a timeout here because of missing interruptable session threads ...\r\n                log.logFine(\"publish: Waiting for \" + yacyCore.publishThreadGroup.activeCount() +  \" remaining publishing threads to finish shutdown ...\");\r\n                for (int currentThreadIdx = 0; currentThreadIdx < threadCount; currentThreadIdx++) {\r\n                    final Thread currentThread = threadList[currentThreadIdx];\r\n\r\n                    if (currentThread.isAlive()) {\r\n                        log.logFine(\"publish: Waiting for remaining publishing thread '\" + currentThread.getName() + \"' to finish shutdown\");\r\n                        try { currentThread.join(500); } catch (InterruptedException ex) {}\r\n                    }\r\n                }\r\n\r\n                log.logInfo(\"publish: Shutdown off all remaining publishing thread finished.\");\r\n\r\n            } catch (Exception ee) {\r\n                log.logWarning(\"publish: Unexpected error while trying to shutdown all remaining publishing threads.\", e);\r\n            }\r\n\r\n            return 0;\r\n        }\r\n    }","commit_id":"5530b8e1ca4559e0b195c09086370853b6c78c01","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public UpdateSession updateDirectories(final FilePath[] contentRoots,\n                                         final UpdatedFiles updatedFiles,\n                                         final ProgressIndicator progressIndicator)\n    throws ProcessCanceledException {\n\n    final ArrayList<VcsException> exceptions = new ArrayList<VcsException>();\n    ISVNEventHandler eventHandler = new UpdateEventHandler(myVcs, progressIndicator, updatedFiles);\n\n    boolean totalUpdate = true;\n    AbstractUpdateIntegrateCrawler crawler = createCrawler(eventHandler, totalUpdate, exceptions, updatedFiles);\n\n    Collection<File> updatedRoots = new HashSet<File>();\n    for (FilePath contentRoot : contentRoots) {\n      if (progressIndicator != null && progressIndicator.isCanceled()) {\n        throw new ProcessCanceledException();\n      }\n      Collection<File> roots = SvnUtil.crawlWCRoots(contentRoot.getIOFile(), crawler, progressIndicator);\n      updatedRoots.addAll(roots);\n    }\n    if (updatedRoots.isEmpty()) {\n      Messages.showErrorDialog(myVcs.getProject(), SvnBundle.message(\"message.text.update.no.directories.found\"), SvnBundle.message(\"messate.text.update.error\"));\n    }\n\n    final Collection<String> conflictedFiles = updatedFiles.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID).getFiles();\n    return new UpdateSessionAdapter(exceptions, false) {\n      public void onRefreshFilesCompleted() {\n        for(FilePath contentRoot: contentRoots) {\n          // update switched/ignored status of directories\n          VcsDirtyScopeManager.getInstance(myVcs.getProject()).fileDirty(contentRoot);\n        }\n        if (conflictedFiles != null && !conflictedFiles.isEmpty() && !isDryRun()) {\n          List<VirtualFile> vfFiles = new ArrayList<VirtualFile>();\n          for (final String conflictedFile : conflictedFiles) {\n            @NonNls final String path = \"file://\" + conflictedFile.replace(File.separatorChar, '/');\n            VirtualFile vf = ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n              @Nullable public VirtualFile compute() {\n                return VirtualFileManager.getInstance().findFileByUrl(path);\n              }\n\n            });\n            if (vf != null) {\n              // refresh base directory so that conflict files should be detected\n              vf.getParent().refresh(true, false);\n              VcsDirtyScopeManager.getInstance(myVcs.getProject()).fileDirty(vf);\n              if (ProjectLevelVcsManager.getInstance(myVcs.getProject()).getVcsFor(vf).equals(myVcs)) {\n                vfFiles.add(vf);\n              }\n            }\n          }\n          if (!vfFiles.isEmpty()) {\n            final AbstractVcsHelper vcsHelper = AbstractVcsHelper.getInstance(myVcs.getProject());\n            List<VirtualFile> mergedFiles = vcsHelper.showMergeDialog(vfFiles, new SvnMergeProvider(myVcs.getProject()));\n            FileGroup mergedGroup = updatedFiles.getGroupById(FileGroup.MERGED_ID);\n            for(VirtualFile mergedFile: mergedFiles) {\n              String path = FileUtil.toSystemDependentName(mergedFile.getPresentableUrl());\n              conflictedFiles.remove(path);\n              mergedGroup.add(path);\n            }\n          }\n        }\n      }\n\n    };\n  }","id":11133,"modified_method":"public UpdateSession updateDirectories(final FilePath[] contentRoots,\n                                         final UpdatedFiles updatedFiles,\n                                         final ProgressIndicator progressIndicator)\n    throws ProcessCanceledException {\n\n    final ArrayList<VcsException> exceptions = new ArrayList<VcsException>();\n    ISVNEventHandler eventHandler = new UpdateEventHandler(myVcs, progressIndicator, updatedFiles);\n\n    boolean totalUpdate = true;\n    AbstractUpdateIntegrateCrawler crawler = createCrawler(eventHandler, totalUpdate, exceptions, updatedFiles);\n\n    Collection<File> updatedRoots = new HashSet<File>();\n    for (FilePath contentRoot : contentRoots) {\n      if (progressIndicator != null && progressIndicator.isCanceled()) {\n        throw new ProcessCanceledException();\n      }\n      Collection<File> roots = SvnUtil.crawlWCRoots(contentRoot.getIOFile(), crawler, progressIndicator);\n      updatedRoots.addAll(roots);\n    }\n    if (updatedRoots.isEmpty()) {\n      Messages.showErrorDialog(myVcs.getProject(), SvnBundle.message(\"message.text.update.no.directories.found\"), SvnBundle.message(\"messate.text.update.error\"));\n    }\n\n    final FileGroup conflictedGroup = updatedFiles.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID);\n    final Collection<String> conflictedFiles = conflictedGroup.getFiles();\n    return new UpdateSessionAdapter(exceptions, false) {\n      public void onRefreshFilesCompleted() {\n        for(FilePath contentRoot: contentRoots) {\n          // update switched/ignored status of directories\n          VcsDirtyScopeManager.getInstance(myVcs.getProject()).fileDirty(contentRoot);\n        }\n        if (conflictedFiles != null && !conflictedFiles.isEmpty() && !isDryRun()) {\n          List<VirtualFile> vfFiles = new ArrayList<VirtualFile>();\n          for (final String conflictedFile : conflictedFiles) {\n            @NonNls final String path = \"file://\" + conflictedFile.replace(File.separatorChar, '/');\n            VirtualFile vf = ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n              @Nullable public VirtualFile compute() {\n                return VirtualFileManager.getInstance().findFileByUrl(path);\n              }\n\n            });\n            if (vf != null) {\n              // refresh base directory so that conflict files should be detected\n              vf.getParent().refresh(true, false);\n              VcsDirtyScopeManager.getInstance(myVcs.getProject()).fileDirty(vf);\n              if (ProjectLevelVcsManager.getInstance(myVcs.getProject()).getVcsFor(vf).equals(myVcs)) {\n                vfFiles.add(vf);\n              }\n            }\n          }\n          if (!vfFiles.isEmpty()) {\n            final AbstractVcsHelper vcsHelper = AbstractVcsHelper.getInstance(myVcs.getProject());\n            List<VirtualFile> mergedFiles = vcsHelper.showMergeDialog(vfFiles, new SvnMergeProvider(myVcs.getProject()));\n            FileGroup mergedGroup = updatedFiles.getGroupById(FileGroup.MERGED_ID);\n            for(VirtualFile mergedFile: mergedFiles) {\n              String path = FileUtil.toSystemDependentName(mergedFile.getPresentableUrl());\n              VcsRevisionNumber revision = conflictedGroup.getRevision(myVcs.getProject(), path); \n              conflictedGroup.remove(path);\n              mergedGroup.add(path, myVcs, revision);\n            }\n          }\n        }\n      }\n\n    };\n  }","commit_id":"a608269d542e2d86f37b4c1d6dd1bc5909ca668b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleEvent(SVNEvent event, double progress) {\n      if (event == null || event.getFile() == null) {\n        return;\n      }\n      String path = event.getFile().getAbsolutePath();\n      String displayPath = event.getFile().getName();\n      String text2 = null;\n      String text = null;\n      if (event.getAction() == SVNEventAction.UPDATE_ADD ||\n          event.getAction() == SVNEventAction.ADD) {\n        text2 = SvnBundle.message(\"progress.text2.added\", displayPath);\n        if (myUpdatedFiles.getGroupById(FileGroup.REMOVED_FROM_REPOSITORY_ID).getFiles().contains(path)) {\n          myUpdatedFiles.getGroupById(FileGroup.REMOVED_FROM_REPOSITORY_ID).getFiles().remove(path);\n          if (myUpdatedFiles.getGroupById(SvnStatusEnvironment.REPLACED_ID) == null) {\n            myUpdatedFiles.registerGroup(SvnStatusEnvironment.createFileGroup(SvnBundle.message(\"status.group.name.replaced\"), SvnStatusEnvironment.REPLACED_ID));\n          }\n          myUpdatedFiles.getGroupById(SvnStatusEnvironment.REPLACED_ID).add(path);\n        } else {\n          myUpdatedFiles.getGroupById(FileGroup.CREATED_ID).add(path);\n        }\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_NONE) {\n        // skip it\n        return;\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_DELETE) {\n        text2 = SvnBundle.message(\"progress.text2.deleted\", displayPath);\n        myUpdatedFiles.getGroupById(FileGroup.REMOVED_FROM_REPOSITORY_ID).add(path);\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_UPDATE) {\n        if (event.getContentsStatus() == SVNStatusType.CONFLICTED || event.getPropertiesStatus() == SVNStatusType.CONFLICTED) {\n          myUpdatedFiles.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID).add(path);\n          text2 = SvnBundle.message(\"progress.text2.conflicted\", displayPath);\n        }\n        else if (event.getContentsStatus() == SVNStatusType.MERGED || event.getPropertiesStatus() == SVNStatusType.MERGED) {\n          text2 = SvnBundle.message(\"progres.text2.merged\", displayPath);\n          myUpdatedFiles.getGroupById(FileGroup.MERGED_ID).add(path);\n        }\n        else if (event.getContentsStatus() == SVNStatusType.CHANGED || event.getPropertiesStatus() == SVNStatusType.CHANGED) {\n          text2 = SvnBundle.message(\"progres.text2.updated\", displayPath);\n          myUpdatedFiles.getGroupById(FileGroup.UPDATED_ID).add(path);\n        }\n        else if (event.getContentsStatus() == SVNStatusType.UNCHANGED && event.getPropertiesStatus() == SVNStatusType.UNCHANGED) {\n          text2 = SvnBundle.message(\"progres.text2.updated\", displayPath);\n        }\n        else {\n          text2 = \"\";\n          myUpdatedFiles.getGroupById(FileGroup.UNKNOWN_ID).add(path);\n        }\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_EXTERNAL) {\n        myExternalsCount++;\n        if (myUpdatedFiles.getGroupById(SvnStatusEnvironment.EXTERNAL_ID) == null) {\n          myUpdatedFiles.registerGroup(new FileGroup(SvnBundle.message(\"status.group.name.externals\"),\n                                                     SvnBundle.message(\"status.group.name.externals\"),\n                                                     false, SvnStatusEnvironment.EXTERNAL_ID, true));\n        }\n        myUpdatedFiles.getGroupById(SvnStatusEnvironment.EXTERNAL_ID).add(path);\n        text = SvnBundle.message(\"progress.text.updating.external.location\", event.getFile().getAbsolutePath());\n      }\n      else if (event.getAction() == SVNEventAction.RESTORE) {\n        text2 = SvnBundle.message(\"progress.text2.restored.file\", displayPath);\n        myUpdatedFiles.getGroupById(FileGroup.RESTORED_ID).add(path);\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_COMPLETED && event.getRevision() >= 0) {\n        myExternalsCount--;\n        text2 = SvnBundle.message(\"progres.text2.updated.to.revision\", event.getRevision());\n        if (myExternalsCount == 0) {\n          myExternalsCount = 1;\n          WindowManager.getInstance().getStatusBar(myVCS.getProject()).setInfo(\n            SvnBundle.message(\"status.text.updated.to.revision\", event.getRevision()));\n        }\n      }\n      else if (event.getAction() == SVNEventAction.SKIP) {\n        text2 = SvnBundle.message(\"progress.text2.skipped.file\", displayPath);\n        if (myUpdatedFiles.getGroupById(SKIP_ID) == null) {\n          myUpdatedFiles.registerGroup(new FileGroup(SvnBundle.message(\"update.group.name.skipped\"),\n                                                     SvnBundle.message(\"update.group.name.skipped\"), false, SKIP_ID, true));\n        }\n        myUpdatedFiles.getGroupById(SKIP_ID).add(path);\n      }\n\n      if (myProgressIndicator != null) {\n        if (text != null) {\n          myProgressIndicator.setText(text);\n        }\n        if (text2 != null) {\n          myProgressIndicator.setText2(text2);\n        }\n      }\n    }","id":11134,"modified_method":"public void handleEvent(SVNEvent event, double progress) {\n      if (event == null || event.getFile() == null) {\n        return;\n      }\n      String path = event.getFile().getAbsolutePath();\n      String displayPath = event.getFile().getName();\n      String text2 = null;\n      String text = null;\n      if (event.getAction() == SVNEventAction.UPDATE_ADD ||\n          event.getAction() == SVNEventAction.ADD) {\n        text2 = SvnBundle.message(\"progress.text2.added\", displayPath);\n        if (myUpdatedFiles.getGroupById(FileGroup.REMOVED_FROM_REPOSITORY_ID).getFiles().contains(path)) {\n          myUpdatedFiles.getGroupById(FileGroup.REMOVED_FROM_REPOSITORY_ID).getFiles().remove(path);\n          if (myUpdatedFiles.getGroupById(SvnStatusEnvironment.REPLACED_ID) == null) {\n            myUpdatedFiles.registerGroup(SvnStatusEnvironment.createFileGroup(SvnBundle.message(\"status.group.name.replaced\"), SvnStatusEnvironment.REPLACED_ID));\n          }\n          addFileToGroup(SvnStatusEnvironment.REPLACED_ID, event);\n        } else {\n          addFileToGroup(FileGroup.CREATED_ID, event);\n        }\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_NONE) {\n        // skip it\n        return;\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_DELETE) {\n        text2 = SvnBundle.message(\"progress.text2.deleted\", displayPath);\n        addFileToGroup(FileGroup.REMOVED_FROM_REPOSITORY_ID, event);\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_UPDATE) {\n        if (event.getContentsStatus() == SVNStatusType.CONFLICTED || event.getPropertiesStatus() == SVNStatusType.CONFLICTED) {\n          addFileToGroup(FileGroup.MERGED_WITH_CONFLICT_ID, event);\n          text2 = SvnBundle.message(\"progress.text2.conflicted\", displayPath);\n        }\n        else if (event.getContentsStatus() == SVNStatusType.MERGED || event.getPropertiesStatus() == SVNStatusType.MERGED) {\n          text2 = SvnBundle.message(\"progres.text2.merged\", displayPath);\n          addFileToGroup(FileGroup.MERGED_ID, event);\n        }\n        else if (event.getContentsStatus() == SVNStatusType.CHANGED || event.getPropertiesStatus() == SVNStatusType.CHANGED) {\n          text2 = SvnBundle.message(\"progres.text2.updated\", displayPath);\n          addFileToGroup(FileGroup.UPDATED_ID, event);\n        }\n        else if (event.getContentsStatus() == SVNStatusType.UNCHANGED && event.getPropertiesStatus() == SVNStatusType.UNCHANGED) {\n          text2 = SvnBundle.message(\"progres.text2.updated\", displayPath);\n        }\n        else {\n          text2 = \"\";\n          addFileToGroup(FileGroup.UNKNOWN_ID, event);\n        }\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_EXTERNAL) {\n        myExternalsCount++;\n        if (myUpdatedFiles.getGroupById(SvnStatusEnvironment.EXTERNAL_ID) == null) {\n          myUpdatedFiles.registerGroup(new FileGroup(SvnBundle.message(\"status.group.name.externals\"),\n                                                     SvnBundle.message(\"status.group.name.externals\"),\n                                                     false, SvnStatusEnvironment.EXTERNAL_ID, true));\n        }\n        addFileToGroup(SvnStatusEnvironment.EXTERNAL_ID, event);\n        text = SvnBundle.message(\"progress.text.updating.external.location\", event.getFile().getAbsolutePath());\n      }\n      else if (event.getAction() == SVNEventAction.RESTORE) {\n        text2 = SvnBundle.message(\"progress.text2.restored.file\", displayPath);\n        addFileToGroup(FileGroup.RESTORED_ID, event);\n      }\n      else if (event.getAction() == SVNEventAction.UPDATE_COMPLETED && event.getRevision() >= 0) {\n        myExternalsCount--;\n        text2 = SvnBundle.message(\"progres.text2.updated.to.revision\", event.getRevision());\n        if (myExternalsCount == 0) {\n          myExternalsCount = 1;\n          WindowManager.getInstance().getStatusBar(myVCS.getProject()).setInfo(\n            SvnBundle.message(\"status.text.updated.to.revision\", event.getRevision()));\n        }\n      }\n      else if (event.getAction() == SVNEventAction.SKIP) {\n        text2 = SvnBundle.message(\"progress.text2.skipped.file\", displayPath);\n        if (myUpdatedFiles.getGroupById(SKIP_ID) == null) {\n          myUpdatedFiles.registerGroup(new FileGroup(SvnBundle.message(\"update.group.name.skipped\"),\n                                                     SvnBundle.message(\"update.group.name.skipped\"), false, SKIP_ID, true));\n        }\n        addFileToGroup(SKIP_ID, event);\n      }\n\n      if (myProgressIndicator != null) {\n        if (text != null) {\n          myProgressIndicator.setText(text);\n        }\n        if (text2 != null) {\n          myProgressIndicator.setText2(text2);\n        }\n      }\n    }","commit_id":"a608269d542e2d86f37b4c1d6dd1bc5909ca668b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected long doUpdate(\n      final File root,\n      final SVNUpdateClient client) throws\n                                    SVNException {\n      final long rev;\n\n      final SvnConfiguration configuration = SvnConfiguration.getInstance(myVcs.getProject());\n      final UpdateRootInfo rootInfo = configuration.getUpdateRootInfo(root, myVcs);\n\n      if (rootInfo != null) {\n        final SVNURL url = rootInfo.getUrl();\n        if (url != null && url.equals(getSourceUrl(root))) {\n          if (rootInfo.isUpdateToRevision()) {\n            rev = client.doUpdate(root, rootInfo.getRevision(), configuration.UPDATE_RECURSIVELY);\n          } else {\n            rev = client.doUpdate(root, SVNRevision.HEAD, configuration.UPDATE_RECURSIVELY);\n          }\n\n        } else if (url != null) {\n          rev = client.doSwitch(root, url,\n                                rootInfo.getRevision(), configuration.UPDATE_RECURSIVELY);\n        } else {\n          rev = client.doUpdate(root, SVNRevision.HEAD, configuration.UPDATE_RECURSIVELY);\n        }\n      } else {\n        rev = client.doUpdate(root, SVNRevision.HEAD, configuration.UPDATE_RECURSIVELY);\n      }\n\n      return rev;\n    }","id":11135,"modified_method":"protected long doUpdate(\n      final File root,\n      final SVNUpdateClient client) throws\n                                    SVNException {\n      final long rev;\n\n      final SvnConfiguration configuration = SvnConfiguration.getInstance(myVcs.getProject());\n      final UpdateRootInfo rootInfo = configuration.getUpdateRootInfo(root, myVcs);\n\n      if (rootInfo != null) {\n        final SVNURL url = rootInfo.getUrl();\n        if (url != null && url.equals(getSourceUrl(root))) {\n          if (rootInfo.isUpdateToRevision()) {\n            rev = client.doUpdate(root, rootInfo.getRevision(), configuration.UPDATE_RECURSIVELY);\n          } else {\n            rev = client.doUpdate(root, SVNRevision.HEAD, configuration.UPDATE_RECURSIVELY);\n          }\n\n        } else if (url != null) {\n          rev = client.doSwitch(root, url,\n                                rootInfo.getRevision(), configuration.UPDATE_RECURSIVELY);\n        } else {\n          rev = client.doUpdate(root, SVNRevision.HEAD, configuration.UPDATE_RECURSIVELY);\n        }\n      } else {\n        rev = client.doUpdate(root, SVNRevision.HEAD, configuration.UPDATE_RECURSIVELY);\n      }\n\n      myPostUpdateFiles.setRevisions(root.getAbsolutePath(), myVcs, new SvnRevisionNumber(SVNRevision.create(rev)));\n\n      return rev;\n    }","commit_id":"a608269d542e2d86f37b4c1d6dd1bc5909ca668b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * When a message is received determines whether to open a new chat window\n     * or chat window tab, or to indicate that a message is received from a\n     * contact which already has an open chat. When the chat is found checks if\n     * in mode \"Auto popup enabled\" and if this is the case shows the message in\n     * the appropriate chat panel.\n     * \n     * @param evt the event containing details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n\n        Contact protocolContact = evt.getSourceContact();\n        Date date = evt.getTimestamp();\n        Message message = evt.getSourceMessage();\n\n        MetaContact metaContact = mainFrame.getContactList()\n                .findMetaContactByContact(protocolContact);\n\n        PresenceStatus contactStatus = ((ContactListModel) this.contactList\n                .getModel()).getMetaContactStatus(metaContact);\n\n        if (!Constants.TABBED_CHAT_WINDOW) {\n            // If in mode \"open all messages in new window\"\n            if (contactMsgWindows.containsKey(metaContact)) {\n                /*\n                 * If a chat window for this contact is already opened show it.\n                 */\n                ChatWindow msgWindow = (ChatWindow) contactMsgWindows\n                        .get(metaContact);\n\n                msgWindow.getCurrentChatPanel().processMessage(\n                        protocolContact.getDisplayName(), date,\n                        Constants.INCOMING_MESSAGE, message.getContent());\n\n                if (msgWindow.getState() == JFrame.ICONIFIED) {\n                    msgWindow.setTitle(\"*\" + msgWindow.getTitle());\n                }\n\n                if (Constants.AUTO_POPUP_NEW_MESSAGE) {\n                    if(msgWindow.isVisible())\n                        msgWindow.toFront();\n                    else\n                        msgWindow.setVisible(true);\n                }\n            }\n            else {\n                ChatWindow msgWindow = new ChatWindow(mainFrame);\n\n                contactMsgWindows.put(metaContact, msgWindow);\n\n                ChatPanel chatPanel = msgWindow.createChat(metaContact,\n                        contactStatus, protocolContact);\n\n                chatPanel.loadHistory(message.getMessageUID());\n                chatPanel.processMessage(protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE, message.getContent());\n                /*\n                 * If there's no chat window for the contact create it and show\n                 * it.\n                 */\n                if (Constants.AUTO_POPUP_NEW_MESSAGE) {\n                    msgWindow.addChat(chatPanel);\n\n                    msgWindow.pack();\n\n                    msgWindow.setVisible(true);\n\n                    chatPanel.setCaretToEnd();\n                }\n            }\n        }\n        else {\n            // If in mode \"group messages in one chat window\"\n            if (tabbedChatWindow == null) {\n                // If there's no open chat window\n                tabbedChatWindow = new ChatWindow(mainFrame);\n\n                tabbedChatWindow.addWindowListener(new WindowAdapter() {\n\n                    public void windowClosing(WindowEvent e)\n                    {\n                        tabbedChatWindow = null;\n                    }\n                });\n            }\n            \n            Hashtable contactTabsTable = tabbedChatWindow\n                    .getContactChatsTable();\n\n            ChatPanel chatPanel;\n\n            // If there's no open tab for the given contact.\n            if (contactTabsTable.get(metaContact.getMetaUID()) == null) {\n                chatPanel = tabbedChatWindow.createChat(metaContact,\n                        contactStatus, protocolContact);\n\n                chatPanel.loadHistory(message.getMessageUID());\n                chatPanel.processMessage(protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE, message.getContent());\n\n                if (Constants.AUTO_POPUP_NEW_MESSAGE) {\n                    tabbedChatWindow.addChatTab(chatPanel);\n\n                    if(tabbedChatWindow.isVisible())\n                        tabbedChatWindow.toFront();\n                    else\n                        tabbedChatWindow.setVisible(true);\n\n                    chatPanel.setCaretToEnd();\n\n                    tabbedChatWindow.getCurrentChatPanel()\n                            .requestFocusInWriteArea();\n\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow.highlightTab(metaContact);\n                    }\n                }\n            }\n            else {\n                chatPanel = tabbedChatWindow.getChatPanel(metaContact);\n\n                chatPanel.processMessage(protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE, message.getContent());\n\n                if (tabbedChatWindow.getState() == JFrame.ICONIFIED) {\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow.setSelectedContactTab(metaContact);\n                    }\n\n                    if (!tabbedChatWindow.getTitle().startsWith(\"*\")) {\n                        tabbedChatWindow.setTitle(\n                                \"*\" + tabbedChatWindow.getTitle());\n                    }\n                }\n                else {\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow.highlightTab(metaContact);\n                    }\n                    \n                    if(tabbedChatWindow.isVisible())\n                        tabbedChatWindow.toFront();\n                    else\n                        tabbedChatWindow.setVisible(true);\n                }\n            }\n        }\n\n        if (Constants.AUTO_POPUP_NEW_MESSAGE)\n            Constants.getDefaultMessageAudio().play();\n    }","id":11136,"modified_method":"/**\n     * When a message is received determines whether to open a new chat window\n     * or chat window tab, or to indicate that a message is received from a\n     * contact which already has an open chat. When the chat is found checks if\n     * in mode \"Auto popup enabled\" and if this is the case shows the message in\n     * the appropriate chat panel.\n     * \n     * @param evt the event containing details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n\n        Contact protocolContact = evt.getSourceContact();\n        Date date = evt.getTimestamp();\n        Message message = evt.getSourceMessage();\n\n        MetaContact metaContact = mainFrame.getContactList()\n                .findMetaContactByContact(protocolContact);\n\n        PresenceStatus contactStatus = ((ContactListModel) this.contactList\n                .getModel()).getMetaContactStatus(metaContact);\n\n        if (!Constants.TABBED_CHAT_WINDOW) {\n            // If in mode \"open all messages in new window\"\n            if (contactMsgWindows.containsKey(metaContact)) {\n                /*\n                 * If a chat window for this contact is already opened show it.\n                 */\n                ChatWindow msgWindow = (ChatWindow) contactMsgWindows\n                        .get(metaContact);\n\n                msgWindow.getCurrentChatPanel().processMessage(\n                        protocolContact.getDisplayName(), date,\n                        Constants.INCOMING_MESSAGE, message.getContent());\n\n                if (msgWindow.getState() == JFrame.ICONIFIED) {\n                    msgWindow.setTitle(\"*\" + msgWindow.getTitle());\n                }\n\n                if (Constants.AUTO_POPUP_NEW_MESSAGE) {\n                    if(msgWindow.isVisible()) {\n                        \n                        if(msgWindow.getState() == JFrame.ICONIFIED)\n                            msgWindow.setState(JFrame.NORMAL);\n                        \n                        msgWindow.toFront();\n                    }\n                    else\n                        msgWindow.setVisible(true);\n                }\n            }\n            else {\n                ChatWindow msgWindow = new ChatWindow(mainFrame);\n\n                contactMsgWindows.put(metaContact, msgWindow);\n\n                ChatPanel chatPanel = msgWindow.createChat(metaContact,\n                        contactStatus, protocolContact);\n\n                chatPanel.loadHistory(message.getMessageUID());\n                chatPanel.processMessage(protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE, message.getContent());\n                /*\n                 * If there's no chat window for the contact create it and show\n                 * it.\n                 */\n                if (Constants.AUTO_POPUP_NEW_MESSAGE) {\n                    msgWindow.addChat(chatPanel);\n\n                    msgWindow.pack();\n\n                    msgWindow.setVisible(true);\n\n                    chatPanel.setCaretToEnd();\n                }\n            }\n        }\n        else {\n            // If in mode \"group messages in one chat window\"\n            if (tabbedChatWindow == null) {\n                // If there's no open chat window\n                tabbedChatWindow = new ChatWindow(mainFrame);\n\n                tabbedChatWindow.addWindowListener(new WindowAdapter() {\n\n                    public void windowClosing(WindowEvent e)\n                    {\n                        tabbedChatWindow = null;\n                    }\n                });\n            }\n            \n            Hashtable contactTabsTable = tabbedChatWindow\n                    .getContactChatsTable();\n\n            ChatPanel chatPanel;\n\n            // If there's no open tab for the given contact.\n            if (contactTabsTable.get(metaContact.getMetaUID()) == null) {\n                chatPanel = tabbedChatWindow.createChat(metaContact,\n                        contactStatus, protocolContact);\n\n                chatPanel.loadHistory(message.getMessageUID());\n                chatPanel.processMessage(protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE, message.getContent());\n\n                if (Constants.AUTO_POPUP_NEW_MESSAGE) {\n                    tabbedChatWindow.addChatTab(chatPanel);\n\n                    if(tabbedChatWindow.isVisible()) {\n                        if(tabbedChatWindow.getState() == JFrame.ICONIFIED)\n                            tabbedChatWindow.setState(JFrame.NORMAL);\n                        \n                        tabbedChatWindow.toFront();\n                    }\n                    else\n                        tabbedChatWindow.setVisible(true);\n\n                    chatPanel.setCaretToEnd();\n\n                    tabbedChatWindow.getCurrentChatPanel()\n                            .requestFocusInWriteArea();\n\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow.highlightTab(metaContact);\n                    }\n                }\n            }\n            else {\n                chatPanel = tabbedChatWindow.getChatPanel(metaContact);\n\n                chatPanel.processMessage(protocolContact.getDisplayName(),\n                        date, Constants.INCOMING_MESSAGE, message.getContent());\n\n                if (tabbedChatWindow.getState() == JFrame.ICONIFIED) {\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow.setSelectedContactTab(metaContact);\n                    }\n\n                    if (!tabbedChatWindow.getTitle().startsWith(\"*\")) {\n                        tabbedChatWindow.setTitle(\n                                \"*\" + tabbedChatWindow.getTitle());\n                    }\n                }\n                else {\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow.highlightTab(metaContact);\n                    }\n                    \n                    if(tabbedChatWindow.isVisible())\n                        tabbedChatWindow.toFront();\n                    else\n                        tabbedChatWindow.setVisible(true);\n                }\n            }\n        }\n\n        if (Constants.AUTO_POPUP_NEW_MESSAGE)\n            Constants.getDefaultMessageAudio().play();\n    }","commit_id":"254d252f852ded153b5138ffcb7e45ad603bbf62","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            PresenceStatus contactStatus = ((ContactListModel) contactList\n                    .getModel()).getMetaContactStatus(this.contactItem);\n\n            if (!Constants.TABBED_CHAT_WINDOW) {\n                // If in mode \"open messages in new window\"\n                if (contactMsgWindows.containsKey(this.contactItem)) {\n                    /*\n                     * If a chat window for this contact is already opened show\n                     * it.\n                     */\n                    ChatWindow msgWindow = (ChatWindow) contactMsgWindows\n                            .get(this.contactItem);\n\n                    if (msgWindow.isVisible())\n                        msgWindow.toFront();\n                    else\n                        msgWindow.setVisible(true);\n                }\n                else {\n                    /*\n                     * If there's no chat window for the contact create it and\n                     * show it.\n                     */\n                    ChatWindow msgWindow = new ChatWindow(mainFrame);\n\n                    contactMsgWindows.put(this.contactItem, msgWindow);\n\n                    ChatPanel chatPanel = msgWindow.createChat(\n                            this.contactItem, contactStatus, protocolContact);\n\n                    chatPanel.loadHistory();\n\n                    msgWindow.addChat(chatPanel);\n\n                    msgWindow.pack();\n\n                    msgWindow.setVisible(true);\n\n                    msgWindow.getCurrentChatPanel().requestFocusInWriteArea();\n                }\n            }\n            else {\n                // If in mode \"group messages in one chat window\"\n                if (tabbedChatWindow == null) {\n                    // If there's no open chat window\n                    tabbedChatWindow = new ChatWindow(mainFrame);\n\n                    tabbedChatWindow.addWindowListener(new WindowAdapter() {\n                        public void windowClosing(WindowEvent e)\n                        {\n                            tabbedChatWindow = null;\n                        }\n                    });\n                }\n                /*\n                 * Get the hashtable containg all tabs and corresponding chat\n                 * panels.\n                 */\n                Hashtable contactTabsTable = tabbedChatWindow\n                        .getContactChatsTable();\n\n                // If there's no open tab for the given contact.\n                if (contactTabsTable.get(this.contactItem.getMetaUID()) == null) {\n                    ChatPanel chatPanel = tabbedChatWindow.createChat(\n                            this.contactItem, contactStatus, protocolContact);\n\n                    chatPanel.loadHistory();\n\n                    tabbedChatWindow.addChatTab(chatPanel);\n\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow\n                                .setSelectedContactTab(this.contactItem);\n                    }\n\n                    if (tabbedChatWindow.isVisible())\n                        tabbedChatWindow.toFront();\n                    else\n                        tabbedChatWindow.setVisible(true);\n\n                    tabbedChatWindow.getCurrentChatPanel()\n                            .requestFocusInWriteArea();\n                }\n                else {\n                    // If a tab for the given contact already exists.\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow\n                                .setSelectedContactTab(this.contactItem);\n                    }\n\n                    if (tabbedChatWindow.isVisible())\n                        tabbedChatWindow.toFront();\n                    else\n                        tabbedChatWindow.setVisible(true);\n\n                    tabbedChatWindow.getCurrentChatPanel()\n                            .requestFocusInWriteArea();\n                }\n            }\n\n        }","id":11137,"modified_method":"public void run()\n        {\n            PresenceStatus contactStatus = ((ContactListModel) contactList\n                    .getModel()).getMetaContactStatus(this.contactItem);\n\n            if (!Constants.TABBED_CHAT_WINDOW) {\n                // If in mode \"open messages in new window\"\n                if (contactMsgWindows.containsKey(this.contactItem)) {\n                    /*\n                     * If a chat window for this contact is already opened show\n                     * it.\n                     */\n                    ChatWindow msgWindow = (ChatWindow) contactMsgWindows\n                            .get(this.contactItem);\n\n                    if (msgWindow.isVisible()) {\n                        if(msgWindow.getState() == JFrame.ICONIFIED)\n                            msgWindow.setState(JFrame.NORMAL);\n                        \n                        msgWindow.toFront();\n                    }\n                    else\n                        msgWindow.setVisible(true);\n                }\n                else {\n                    /*\n                     * If there's no chat window for the contact create it and\n                     * show it.\n                     */\n                    ChatWindow msgWindow = new ChatWindow(mainFrame);\n\n                    contactMsgWindows.put(this.contactItem, msgWindow);\n\n                    ChatPanel chatPanel = msgWindow.createChat(\n                            this.contactItem, contactStatus, protocolContact);\n\n                    chatPanel.loadHistory();\n\n                    msgWindow.addChat(chatPanel);\n\n                    msgWindow.pack();\n\n                    msgWindow.setVisible(true);\n\n                    msgWindow.getCurrentChatPanel().requestFocusInWriteArea();\n                }\n            }\n            else {\n                // If in mode \"group messages in one chat window\"\n                if (tabbedChatWindow == null) {\n                    // If there's no open chat window\n                    tabbedChatWindow = new ChatWindow(mainFrame);\n\n                    tabbedChatWindow.addWindowListener(new WindowAdapter() {\n                        public void windowClosing(WindowEvent e)\n                        {\n                            tabbedChatWindow = null;\n                        }\n                    });\n                }\n                /*\n                 * Get the hashtable containg all tabs and corresponding chat\n                 * panels.\n                 */\n                Hashtable contactTabsTable = tabbedChatWindow\n                        .getContactChatsTable();\n\n                // If there's no open tab for the given contact.\n                if (contactTabsTable.get(this.contactItem.getMetaUID()) == null) {\n                    ChatPanel chatPanel = tabbedChatWindow.createChat(\n                            this.contactItem, contactStatus, protocolContact);\n\n                    chatPanel.loadHistory();\n\n                    tabbedChatWindow.addChatTab(chatPanel);\n\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow\n                                .setSelectedContactTab(this.contactItem);\n                    }\n\n                    if (tabbedChatWindow.isVisible()) {\n                        \n                        if(tabbedChatWindow.getState() == JFrame.ICONIFIED)\n                            tabbedChatWindow.setState(JFrame.NORMAL);\n                        \n                        tabbedChatWindow.toFront();\n                    }\n                    else\n                        tabbedChatWindow.setVisible(true);\n\n                    tabbedChatWindow.getCurrentChatPanel()\n                            .requestFocusInWriteArea();\n                }\n                else {\n                    // If a tab for the given contact already exists.\n                    if (tabbedChatWindow.getTabCount() > 1) {\n                        tabbedChatWindow\n                                .setSelectedContactTab(this.contactItem);\n                    }\n\n                    if (tabbedChatWindow.isVisible()) {\n                        \n                        if(tabbedChatWindow.getState() == JFrame.ICONIFIED)\n                            tabbedChatWindow.setState(JFrame.NORMAL);\n                        tabbedChatWindow.toFront();\n                    }\n                    else\n                        tabbedChatWindow.setVisible(true);\n\n                    tabbedChatWindow.getCurrentChatPanel()\n                            .requestFocusInWriteArea();\n                }\n            }\n\n        }","commit_id":"254d252f852ded153b5138ffcb7e45ad603bbf62","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt>. Determines which menu item was\n     * selected and makes the appropriate operations.\n     */\n    public void actionPerformed(ActionEvent e){\n\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n        String itemText = menuItem.getText();\n\n        if (itemName.startsWith(addSubcontactPrefix)) {\n            \n            ProtocolProviderService pps\n                = mainFrame.getProtocolProviderForAccount(itemText);\n\n            if(pps != null) {\n                AddContactDialog dialog = new AddContactDialog(\n                        mainFrame,\n                        contactItem, pps);\n    \n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 250,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 100\n                        );\n    \n                dialog.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"sendMessage\")) {\n            ContactListPanel clistPanel = mainFrame.getContactListPanel();\n            SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(\n                    contactItem));\n        }\n        else if (itemName.equalsIgnoreCase(\"sendFile\")) {\n            // disabled\n        }\n        else if (itemName.equalsIgnoreCase(\"renameContact\")) {\n            RenameContactDialog dialog = new RenameContactDialog(\n                    mainFrame, contactItem);\n\n            dialog.setLocation(\n                    Toolkit.getDefaultToolkit().getScreenSize().width/2\n                        - 200,\n                    Toolkit.getDefaultToolkit().getScreenSize().height/2\n                        - 50\n                    );\n\n            dialog.setVisible(true);\n            \n            dialog.requestFocusInFiled();\n        }\n        else if (itemName.equalsIgnoreCase(\"viewHistory\")) {\n\n            HistoryWindow history;\n            \n            if(guiContactList.containsHistoryWindowForContact(contactItem)) {                \n                history = guiContactList.getHistoryWindowForContact(contactItem);\n                \n                history.toFront();\n            }\n            else {\n                history = new HistoryWindow(\n                    this.mainFrame, this.contactItem);\n                \n                guiContactList.addHistoryWindowForContact(contactItem, history);\n                \n                history.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"userInfo\")) {\n            Contact defaultContact = contactItem.getDefaultContact();\n\n            ProtocolProviderService defaultProvider\n                = defaultContact.getProtocolProvider();\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfo(defaultProvider);\n\n            CrossPlatformBrowserLauncher.openURL(\n                    wContactInfo.getWebContactInfo(defaultContact)\n                        .toString());\n        }\n        else if (itemName.startsWith(moveToPrefix)) {\n            \n            MetaContactGroup group\n                = mainFrame.getGroupByID(\n                        itemName.substring(moveToPrefix.length()));\n\n            if(group != null) {\n                mainFrame.getContactList().moveMetaContact(contactItem, group);\n            }\n        }\n        else if (itemName.startsWith(removeContactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(removeContactPrefix.length()));\n\n            if(contact != null) {\n                new RemoveContactThread(contact).start();                \n            }\n            else {\n                new RemoveAllContactsThread().start();\n            }\n        }\n        else if(itemName.startsWith(moveSubcontactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(moveSubcontactPrefix.length()));\n\n            guiContactList.addExcContactListListener(this);\n            guiContactList.setCursor(\n                    Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n            \n            this.moveDialog = new MoveSubcontactMessageDialog(mainFrame, this);\n            \n            this.moveDialog.setVisible(true);\n                        \n            if(contact != null) {\n                this.contactToMove = contact;                \n            }\n            else {\n                this.moveAllContacts = true;\n            }\n        }\n    }","id":11138,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt>. Determines which menu item was\n     * selected and makes the appropriate operations.\n     */\n    public void actionPerformed(ActionEvent e){\n\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n        String itemText = menuItem.getText();\n\n        if (itemName.startsWith(addSubcontactPrefix)) {\n            \n            ProtocolProviderService pps\n                = mainFrame.getProtocolProviderForAccount(itemText);\n\n            if(pps != null) {\n                AddContactDialog dialog = new AddContactDialog(\n                        mainFrame,\n                        contactItem, pps);\n    \n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 250,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 100\n                        );\n    \n                dialog.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"sendMessage\")) {\n            ContactListPanel clistPanel = mainFrame.getContactListPanel();\n            SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(\n                    contactItem));\n        }\n        else if (itemName.equalsIgnoreCase(\"sendFile\")) {\n            // disabled\n        }\n        else if (itemName.equalsIgnoreCase(\"renameContact\")) {\n            RenameContactDialog dialog = new RenameContactDialog(\n                    mainFrame, contactItem);\n\n            dialog.setLocation(\n                    Toolkit.getDefaultToolkit().getScreenSize().width/2\n                        - 200,\n                    Toolkit.getDefaultToolkit().getScreenSize().height/2\n                        - 50\n                    );\n\n            dialog.setVisible(true);\n            \n            dialog.requestFocusInFiled();\n        }\n        else if (itemName.equalsIgnoreCase(\"viewHistory\")) {\n\n            HistoryWindow history;\n            \n            if(guiContactList.containsHistoryWindowForContact(contactItem)) {                \n                history = guiContactList.getHistoryWindowForContact(contactItem);\n                \n                if(history.getState() == JFrame.ICONIFIED)\n                    history.setState(JFrame.NORMAL);\n                \n                history.toFront();\n            }\n            else {\n                history = new HistoryWindow(\n                    this.mainFrame, this.contactItem);\n                \n                guiContactList.addHistoryWindowForContact(contactItem, history);\n                \n                history.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"userInfo\")) {\n            Contact defaultContact = contactItem.getDefaultContact();\n\n            ProtocolProviderService defaultProvider\n                = defaultContact.getProtocolProvider();\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfo(defaultProvider);\n\n            CrossPlatformBrowserLauncher.openURL(\n                    wContactInfo.getWebContactInfo(defaultContact)\n                        .toString());\n        }\n        else if (itemName.startsWith(moveToPrefix)) {\n            \n            MetaContactGroup group\n                = mainFrame.getGroupByID(\n                        itemName.substring(moveToPrefix.length()));\n\n            if(group != null) {\n                mainFrame.getContactList().moveMetaContact(contactItem, group);\n            }\n        }\n        else if (itemName.startsWith(removeContactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(removeContactPrefix.length()));\n\n            if(contact != null) {\n                new RemoveContactThread(contact).start();                \n            }\n            else {\n                new RemoveAllContactsThread().start();\n            }\n        }\n        else if(itemName.startsWith(moveSubcontactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(moveSubcontactPrefix.length()));\n\n            guiContactList.addExcContactListListener(this);\n            guiContactList.setCursor(\n                    Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n            \n            this.moveDialog = new MoveSubcontactMessageDialog(mainFrame, this);\n            \n            this.moveDialog.setVisible(true);\n                        \n            if(contact != null) {\n                this.contactToMove = contact;                \n            }\n            else {\n                this.moveAllContacts = true;\n            }\n        }\n    }","commit_id":"254d252f852ded153b5138ffcb7e45ad603bbf62","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Test\n    public void testAbstract() throws Exception {\n        final InternalReadAccessor ex = store.getReader( TestAbstract.class,\n                                                         \"something\",\n                                                         getClass().getClassLoader() );\n        assertEquals( 0,\n                      ex.getIndex() );\n        assertEquals( \"foo\",\n                      ex.getValue( null,\n                                   new TestAbstractImpl() ) );\n    }","id":11139,"modified_method":"@Test\n    public void testAbstract() throws Exception {\n        final InternalReadAccessor ex = store.getReader( TestAbstract.class,\n                                                         \"something\",\n                                                         getClass().getClassLoader() );\n        assertEquals( 2,\n                      ex.getIndex() );\n        assertEquals( \"foo\",\n                      ex.getValue( null,\n                                   new TestAbstractImpl() ) );\n    }","commit_id":"49ae5f8fd7168631009f62e73ec4a500385cb6da","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testInterface() throws Exception {\n        final InternalReadAccessor ex = store.getReader( TestInterface.class,\n                                                         \"something\",\n                                                         getClass().getClassLoader() );\n        assertEquals( 0,\n                      ex.getIndex() );\n        assertEquals( \"foo\",\n                      ex.getValue( null,\n                                   new TestInterfaceImpl() ) );\n    }","id":11140,"modified_method":"@Test\n    public void testInterface() throws Exception {\n        final InternalReadAccessor ex = store.getReader( TestInterface.class,\n                                                         \"something\",\n                                                         getClass().getClassLoader() );\n        assertEquals( 1,\n                      ex.getIndex() );\n        assertEquals( \"foo\",\n                      ex.getValue( null,\n                                   new TestInterfaceImpl() ) );\n    }","commit_id":"49ae5f8fd7168631009f62e73ec4a500385cb6da","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void processClassWithoutByteCode( final Class< ? > clazz,\n                                              final boolean includeFinalMethods ) {\n        final Method[] methods = clazz.getMethods();\n        for ( int i = 0; i < methods.length; i++ ) {\n            // modifiers mask  \n            final int mask = includeFinalMethods ? Modifier.PUBLIC : Modifier.PUBLIC | Modifier.FINAL;\n\n            if ( ((methods[i].getModifiers() & mask) == Opcodes.ACC_PUBLIC) && (methods[i].getParameterTypes().length == 0) && (!methods[i].getName().equals( \"<init>\" )) && (!methods[i].getName().equals( \"<clinit>\" ))\n                    && (methods[i].getReturnType() != void.class) ) {\n\n                // want public methods that start with 'get' or 'is' and have no args, and return a value\n                final int fieldIndex = this.fieldNames.size();\n                addToMapping( methods[i],\n                              fieldIndex );\n\n            } else if ( ((methods[i].getModifiers() & mask) == Opcodes.ACC_PUBLIC) && (methods[i].getParameterTypes().length == 1) && (methods[i].getName().startsWith( \"set\" )) ) {\n\n                // want public methods that start with 'set' and have one arg\n                final int fieldIndex = this.fieldNames.size();\n                addToMapping( methods[i],\n                              fieldIndex );\n\n            }\n        }\n    }","id":11141,"modified_method":"private void processClassWithoutByteCode( final Class< ? > clazz,\n                                              final boolean includeFinalMethods ) {\n        final List<Method> methods = Arrays.asList( clazz.getMethods() );\n        // different JVMs might return the methods in different order, so has to be sorted in order \n        // to be compatible with all JVMs\n        Collections.sort( methods,  new Comparator<Method>() {\n            public int compare(Method m1,\n                               Method m2) {\n                return m1.getName().compareTo( m2.getName() );\n            }\n        });\n        \n        for ( int i = 0; i < methods.size(); i++ ) {\n            // modifiers mask  \n            final int mask = includeFinalMethods ? Modifier.PUBLIC : Modifier.PUBLIC | Modifier.FINAL;\n            Method method = methods.get( i );\n\n            if ( ((method.getModifiers() & mask) == Opcodes.ACC_PUBLIC) && (method.getParameterTypes().length == 0) && (!method.getName().equals( \"<init>\" )) && (!method.getName().equals( \"<clinit>\" ))\n                    && (method.getReturnType() != void.class) ) {\n\n                // want public methods that start with 'get' or 'is' and have no args, and return a value\n                final int fieldIndex = this.fieldNames.size();\n                addToMapping( method,\n                              fieldIndex );\n\n            } else if ( ((method.getModifiers() & mask) == Opcodes.ACC_PUBLIC) && (method.getParameterTypes().length == 1) && (method.getName().startsWith( \"set\" )) ) {\n\n                // want public methods that start with 'set' and have one arg\n                final int fieldIndex = this.fieldNames.size();\n                addToMapping( method,\n                              fieldIndex );\n\n            }\n        }\n    }","commit_id":"49ae5f8fd7168631009f62e73ec4a500385cb6da","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testLogicalInsertionsDynamicRule() throws Exception {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"test_LogicalInsertionsDynamicRule.drl\",\n                                                            getClass() ),\n                      ResourceType.DRL );\n        \n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n\n        Collection<KnowledgePackage> kpkgs = kbuilder.getKnowledgePackages();\n        KnowledgeBase kbase = getKnowledgeBase();\n        kbase.addKnowledgePackages( kpkgs );\n        StatefulKnowledgeSession ksession = createKnowledgeSession(kbase);\n\n        final Cheese c1 = new Cheese( \"a\",\n                                      1 );\n        final Cheese c2 = new Cheese( \"b\",\n                                      2 );\n        final Cheese c3 = new Cheese( \"c\",\n                                      3 );\n        List list;\n\n        ksession.insert( c1 );\n        FactHandle h = ksession.insert( c2 );\n        ksession.insert( c3 );\n        ksession.fireAllRules();\n        \n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n\n        // Check logical Insertions where made for c2 and c3        \n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( 2,\n                      list.size() );\n        assertFalse( list.contains( new Person( c1.getType() ) ) );\n        assertTrue( list.contains( new Person( c2.getType() ) ) );\n        assertTrue( list.contains( new Person( c3.getType() ) ) );\n\n        // this rule will make a logical assertion for c1 too\n        kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"test_LogicalInsertionsDynamicRule2.drl\",\n                                                            getClass() ),\n                      ResourceType.DRL );\n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }        \n        Collection<KnowledgePackage> kpkgs2 = kbuilder.getKnowledgePackages();\n        kbase.addKnowledgePackages( kpkgs2 );\n        kbase = SerializationHelper.serializeObject( kbase );\n\n        ksession.fireAllRules();\n        \n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n\n        kbase = ksession.getKnowledgeBase();\n\n        // check all now have just one logical assertion each\n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( 3,\n                      list.size() );\n        assertTrue( list.contains( new Person( c1.getType() ) ) );\n        assertTrue( list.contains( new Person( c2.getType() ) ) );\n        assertTrue( list.contains( new Person( c3.getType() ) ) );\n        \n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n\n        // check the packages are correctly populated\n        KnowledgePackage[] pkgs = (KnowledgePackage[]) kbase.getKnowledgePackages().toArray( new KnowledgePackage[]{} );\n        assertEquals( \"org.drools.test\",\n                      pkgs[0].getName() );\n        assertEquals( \"org.drools.test2\",\n                      pkgs[1].getName() );\n        assertEquals( \"rule1\",\n                      pkgs[0].getRules().iterator().next().getName() );\n        assertEquals( \"rule2\",\n                      pkgs[1].getRules().iterator().next().getName() );\n\n        // now remove the first rule\n        kbase.removeRule( pkgs[0].getName(),\n                          pkgs[0].getRules().iterator().next().getName() );\n        pkgs = (KnowledgePackage[]) kbase.getKnowledgePackages().toArray( new KnowledgePackage[]{} );\n\n        // Check the rule was correctly remove\n        assertEquals( 0,\n                      pkgs[0].getRules().size() );\n        assertEquals( 1,\n                      pkgs[1].getRules().size() );\n        assertEquals( \"org.drools.test2\",\n                      pkgs[1].getName() );\n        assertEquals( \"rule2\",\n                      pkgs[1].getRules().iterator().next().getName() );\n\n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( \"removal of the rule should result in retraction of c3's logical assertion\",\n                      2,\n                      list.size() );\n        assertTrue( \"c1's logical assertion should not be retracted\",\n                    list.contains( new Person( c1.getType() ) ) );\n        assertTrue( \"c2's logical assertion should  not be retracted\",\n                    list.contains( new Person( c2.getType() ) ) );\n        assertFalse( \"c3's logical assertion should be  retracted\",\n                     list.contains( new Person( c3.getType() ) ) );\n\n        c2.setPrice( 3 );\n        h = getFactHandle( h, ksession );\n        ksession.update( h,\n                         c2 );\n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( \"c2 now has a higher price, its logical assertion should  be cancelled\",\n                      1,\n                      list.size() );\n        assertFalse( \"The logical assertion cor c2 should have been retracted\",\n                     list.contains( new Person( c2.getType() ) ) );\n        assertTrue( \"The logical assertion  for c1 should exist\",\n                    list.contains( new Person( c1.getType() ) ) );\n\n        pkgs = (KnowledgePackage[]) kbase.getKnowledgePackages().toArray( new KnowledgePackage[]{} );\n        kbase.removeRule( pkgs[1].getName(),\n                          pkgs[1].getRules().iterator().next().getName() );\n        kbase = SerializationHelper.serializeObject( kbase );\n        pkgs = (KnowledgePackage[]) kbase.getKnowledgePackages().toArray( new KnowledgePackage[]{} );\n        assertEquals( 0,\n                      pkgs[0].getRules().size() );\n        assertEquals( 0,\n                      pkgs[1].getRules().size() );\n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( 0,\n                      list.size() );\n    }","id":11142,"modified_method":"@Test\n    public void testLogicalInsertionsDynamicRule() throws Exception {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"test_LogicalInsertionsDynamicRule.drl\",\n                                                            getClass() ),\n                      ResourceType.DRL );\n        \n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n\n        Collection<KnowledgePackage> kpkgs = kbuilder.getKnowledgePackages();\n        KnowledgeBase kbase = getKnowledgeBase();\n        kbase.addKnowledgePackages( kpkgs );\n        StatefulKnowledgeSession ksession = createKnowledgeSession(kbase);\n\n        final Cheese c1 = new Cheese( \"a\",\n                                      1 );\n        final Cheese c2 = new Cheese( \"b\",\n                                      2 );\n        final Cheese c3 = new Cheese( \"c\",\n                                      3 );\n        List list;\n\n        ksession.insert( c1 );\n        FactHandle h = ksession.insert( c2 );\n        ksession.insert( c3 );\n        ksession.fireAllRules();\n        \n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n\n        // Check logical Insertions where made for c2 and c3        \n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( 2,\n                      list.size() );\n        assertFalse( list.contains( new Person( c1.getType() ) ) );\n        assertTrue( list.contains( new Person( c2.getType() ) ) );\n        assertTrue( list.contains( new Person( c3.getType() ) ) );\n\n        // this rule will make a logical assertion for c1 too\n        kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"test_LogicalInsertionsDynamicRule2.drl\",\n                                                            getClass() ),\n                      ResourceType.DRL );\n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }        \n        Collection<KnowledgePackage> kpkgs2 = kbuilder.getKnowledgePackages();\n        kbase.addKnowledgePackages( kpkgs2 );\n        kbase = SerializationHelper.serializeObject( kbase );\n\n        ksession.fireAllRules();\n        \n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n\n        kbase = ksession.getKnowledgeBase();\n\n        // check all now have just one logical assertion each\n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( 3,\n                      list.size() );\n        assertTrue( list.contains( new Person( c1.getType() ) ) );\n        assertTrue( list.contains( new Person( c2.getType() ) ) );\n        assertTrue( list.contains( new Person( c3.getType() ) ) );\n        \n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n\n        // check the packages are correctly populated\n        assertEquals( 2, kbase.getKnowledgePackages().size() );\n        KnowledgePackage test = null, test2 = null;\n        // different JVMs return the package list in different order\n        for( KnowledgePackage kpkg : kbase.getKnowledgePackages() ) {\n            if( kpkg.getName().equals( \"org.drools.test\" )) {\n                test = kpkg;\n            } else if( kpkg.getName().equals( \"org.drools.test2\" )) {\n                test2 = kpkg;\n            }\n        }\n        \n        assertNotNull( test );\n        assertNotNull( test2 );\n        assertEquals( \"rule1\",\n                      test.getRules().iterator().next().getName() );\n        assertEquals( \"rule2\",\n                      test2.getRules().iterator().next().getName() );\n\n        // now remove the first rule\n        kbase.removeRule( test.getName(),\n                          test.getRules().iterator().next().getName() );\n        // different JVMs return the package list in different order\n        for( KnowledgePackage kpkg : kbase.getKnowledgePackages() ) {\n            if( kpkg.getName().equals( \"org.drools.test\" )) {\n                test = kpkg;\n            } else if( kpkg.getName().equals( \"org.drools.test2\" )) {\n                test2 = kpkg;\n            }\n        }\n        assertNotNull( test );\n        assertNotNull( test2 );\n\n        // Check the rule was correctly remove\n        assertEquals( 0,\n                      test.getRules().size() );\n        assertEquals( 1,\n                      test2.getRules().size() );\n        assertEquals( \"rule2\",\n                      test2.getRules().iterator().next().getName() );\n\n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( \"removal of the rule should result in retraction of c3's logical assertion\",\n                      2,\n                      list.size() );\n        assertTrue( \"c1's logical assertion should not be retracted\",\n                    list.contains( new Person( c1.getType() ) ) );\n        assertTrue( \"c2's logical assertion should  not be retracted\",\n                    list.contains( new Person( c2.getType() ) ) );\n        assertFalse( \"c3's logical assertion should be  retracted\",\n                     list.contains( new Person( c3.getType() ) ) );\n\n        c2.setPrice( 3 );\n        h = getFactHandle( h, ksession );\n        ksession.update( h,\n                         c2 );\n        ksession = getSerialisedStatefulKnowledgeSession( ksession,\n                                                          true );        \n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( \"c2 now has a higher price, its logical assertion should  be cancelled\",\n                      1,\n                      list.size() );\n        assertFalse( \"The logical assertion cor c2 should have been retracted\",\n                     list.contains( new Person( c2.getType() ) ) );\n        assertTrue( \"The logical assertion  for c1 should exist\",\n                    list.contains( new Person( c1.getType() ) ) );\n\n        // different JVMs return the package list in different order\n        for( KnowledgePackage kpkg : kbase.getKnowledgePackages() ) {\n            if( kpkg.getName().equals( \"org.drools.test\" )) {\n                test = kpkg;\n            } else if( kpkg.getName().equals( \"org.drools.test2\" )) {\n                test2 = kpkg;\n            }\n        }\n        assertNotNull( test );\n        assertNotNull( test2 );\n\n        kbase.removeRule( test2.getName(),\n                          test2.getRules().iterator().next().getName() );\n        kbase = SerializationHelper.serializeObject( kbase );\n        \n        // different JVMs return the package list in different order\n        for( KnowledgePackage kpkg : kbase.getKnowledgePackages() ) {\n            if( kpkg.getName().equals( \"org.drools.test\" )) {\n                test = kpkg;\n            } else if( kpkg.getName().equals( \"org.drools.test2\" )) {\n                test2 = kpkg;\n            }\n        }\n        assertNotNull( test );\n        assertNotNull( test2 );\n        \n        assertEquals( 0,\n                      test.getRules().size() );\n        assertEquals( 0,\n                      test2.getRules().size() );\n        list = new ArrayList( ksession.getObjects( new ClassObjectFilter( Person.class ) ) );\n        assertEquals( 0,\n                      list.size() );\n    }","commit_id":"49ae5f8fd7168631009f62e73ec4a500385cb6da","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Deprecated\n\tpublic Address addAddress(\n\t\t\tlong userId, String className, long classPK, String street1,\n\t\t\tString street2, String street3, String city, String zip,\n\t\t\tlong regionId, long countryId, int typeId, boolean mailing,\n\t\t\tboolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addAddress(\n\t\t\tuserId, className, classPK, street1, street2, street3, city, zip,\n\t\t\tregionId, countryId, typeId, mailing, primary, null);\n\t}","id":11143,"modified_method":"/**\n\t * @deprecated As of 6.2.0, replaced by {@link #addAddress(long,\n\t *             String, long, String, String, String, String, String, long,\n\t *             long, int, boolean, boolean, ServiceContext)}\n\t */\n\t@Deprecated\n\tpublic Address addAddress(\n\t\t\tlong userId, String className, long classPK, String street1,\n\t\t\tString street2, String street3, String city, String zip,\n\t\t\tlong regionId, long countryId, int typeId, boolean mailing,\n\t\t\tboolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addAddress(\n\t\t\tuserId, className, classPK, street1, street2, street3, city, zip,\n\t\t\tregionId, countryId, typeId, mailing, primary, null);\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Address addAddress(\n\t\t\tlong userId, String className, long classPK, String street1,\n\t\t\tString street2, String street3, String city, String zip,\n\t\t\tlong regionId, long countryId, int typeId, boolean mailing,\n\t\t\tboolean primary, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, street1, city, zip,\n\t\t\tregionId, countryId, typeId, mailing, primary);\n\n\t\tlong addressId = counterLocalService.increment();\n\n\t\tAddress address = addressPersistence.create(addressId);\n\n\t\tif (serviceContext != null) {\n\t\t\taddress.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\taddress.setCompanyId(user.getCompanyId());\n\t\taddress.setUserId(user.getUserId());\n\t\taddress.setUserName(user.getFullName());\n\t\taddress.setCreateDate(now);\n\t\taddress.setModifiedDate(now);\n\t\taddress.setClassNameId(classNameId);\n\t\taddress.setClassPK(classPK);\n\t\taddress.setStreet1(street1);\n\t\taddress.setStreet2(street2);\n\t\taddress.setStreet3(street3);\n\t\taddress.setCity(city);\n\t\taddress.setZip(zip);\n\t\taddress.setRegionId(regionId);\n\t\taddress.setCountryId(countryId);\n\t\taddress.setTypeId(typeId);\n\t\taddress.setMailing(mailing);\n\t\taddress.setPrimary(primary);\n\n\t\taddressPersistence.update(address);\n\n\t\treturn address;\n\t}","id":11144,"modified_method":"public Address addAddress(\n\t\t\tlong userId, String className, long classPK, String street1,\n\t\t\tString street2, String street3, String city, String zip,\n\t\t\tlong regionId, long countryId, int typeId, boolean mailing,\n\t\t\tboolean primary, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, street1, city, zip,\n\t\t\tregionId, countryId, typeId, mailing, primary);\n\n\t\tlong addressId = counterLocalService.increment();\n\n\t\tAddress address = addressPersistence.create(addressId);\n\n\t\tif (serviceContext != null) {\n\t\t\taddress.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\taddress.setCompanyId(user.getCompanyId());\n\t\taddress.setUserId(user.getUserId());\n\t\taddress.setUserName(user.getFullName());\n\n\t\tif (serviceContext != null) {\n\t\t\taddress.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\taddress.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t}\n\t\telse {\n\t\t\taddress.setCreateDate(now);\n\t\t\taddress.setModifiedDate(now);\n\t\t}\n\n\t\taddress.setClassNameId(classNameId);\n\t\taddress.setClassPK(classPK);\n\t\taddress.setStreet1(street1);\n\t\taddress.setStreet2(street2);\n\t\taddress.setStreet3(street3);\n\t\taddress.setCity(city);\n\t\taddress.setZip(zip);\n\t\taddress.setRegionId(regionId);\n\t\taddress.setCountryId(countryId);\n\t\taddress.setTypeId(typeId);\n\t\taddress.setMailing(mailing);\n\t\taddress.setPrimary(primary);\n\n\t\taddressPersistence.update(address);\n\n\t\treturn address;\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Deprecated\n\tpublic EmailAddress addEmailAddress(\n\t\t\tlong userId, String className, long classPK, String address,\n\t\t\tint typeId, boolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addEmailAddress(\n\t\t\tuserId, className, classPK, address, typeId, primary, null);\n\t}","id":11145,"modified_method":"/**\n\t * @deprecated As of 6.2.0, replaced by {@link #addEmailAddress(long,\n\t *             String, long, String, int, boolean, ServiceContext)}\n\t */\n\t@Deprecated\n\tpublic EmailAddress addEmailAddress(\n\t\t\tlong userId, String className, long classPK, String address,\n\t\t\tint typeId, boolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addEmailAddress(\n\t\t\tuserId, className, classPK, address, typeId, primary, null);\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public EmailAddress addEmailAddress(\n\t\t\tlong userId, String className, long classPK, String address,\n\t\t\tint typeId, boolean primary, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, address, typeId,\n\t\t\tprimary);\n\n\t\tlong emailAddressId = counterLocalService.increment();\n\n\t\tEmailAddress emailAddress = emailAddressPersistence.create(\n\t\t\temailAddressId);\n\n\t\tif (serviceContext != null) {\n\t\t\temailAddress.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\temailAddress.setCompanyId(user.getCompanyId());\n\t\temailAddress.setUserId(user.getUserId());\n\t\temailAddress.setUserName(user.getFullName());\n\t\temailAddress.setCreateDate(now);\n\t\temailAddress.setModifiedDate(now);\n\t\temailAddress.setClassNameId(classNameId);\n\t\temailAddress.setClassPK(classPK);\n\t\temailAddress.setAddress(address);\n\t\temailAddress.setTypeId(typeId);\n\t\temailAddress.setPrimary(primary);\n\n\t\temailAddressPersistence.update(emailAddress);\n\n\t\treturn emailAddress;\n\t}","id":11146,"modified_method":"public EmailAddress addEmailAddress(\n\t\t\tlong userId, String className, long classPK, String address,\n\t\t\tint typeId, boolean primary, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, address, typeId,\n\t\t\tprimary);\n\n\t\tlong emailAddressId = counterLocalService.increment();\n\n\t\tEmailAddress emailAddress = emailAddressPersistence.create(\n\t\t\temailAddressId);\n\n\t\tif (serviceContext != null) {\n\t\t\temailAddress.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\temailAddress.setCompanyId(user.getCompanyId());\n\t\temailAddress.setUserId(user.getUserId());\n\t\temailAddress.setUserName(user.getFullName());\n\n\t\tif (serviceContext != null) {\n\t\t\temailAddress.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\temailAddress.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t}\n\t\telse {\n\t\t\temailAddress.setCreateDate(now);\n\t\t\temailAddress.setModifiedDate(now);\n\t\t}\n\n\t\temailAddress.setClassNameId(classNameId);\n\t\temailAddress.setClassPK(classPK);\n\t\temailAddress.setAddress(address);\n\t\temailAddress.setTypeId(typeId);\n\t\temailAddress.setPrimary(primary);\n\n\t\temailAddressPersistence.update(emailAddress);\n\n\t\treturn emailAddress;\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Deprecated\n\tpublic Phone addPhone(\n\t\t\tlong userId, String className, long classPK, String number,\n\t\t\tString extension, int typeId, boolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addPhone(\n\t\t\tuserId, className, classPK, number, extension, typeId, primary,\n\t\t\tnull);\n\t}","id":11147,"modified_method":"/**\n\t * @deprecated As of 6.2.0, replaced by {@link #addPhone(long,\n\t *             String, long, String, String, int, boolean, ServiceContext)}\n\t */\n\t@Deprecated\n\tpublic Phone addPhone(\n\t\t\tlong userId, String className, long classPK, String number,\n\t\t\tString extension, int typeId, boolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addPhone(\n\t\t\tuserId, className, classPK, number, extension, typeId, primary,\n\t\t\tnull);\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Phone addPhone(\n\t\t\tlong userId, String className, long classPK, String number,\n\t\t\tString extension, int typeId, boolean primary,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, number, extension,\n\t\t\ttypeId, primary);\n\n\t\tlong phoneId = counterLocalService.increment();\n\n\t\tPhone phone = phonePersistence.create(phoneId);\n\n\t\tif (serviceContext != null) {\n\t\t\tphone.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\tphone.setCompanyId(user.getCompanyId());\n\t\tphone.setUserId(user.getUserId());\n\t\tphone.setUserName(user.getFullName());\n\t\tphone.setCreateDate(now);\n\t\tphone.setModifiedDate(now);\n\t\tphone.setClassNameId(classNameId);\n\t\tphone.setClassPK(classPK);\n\t\tphone.setNumber(number);\n\t\tphone.setExtension(extension);\n\t\tphone.setTypeId(typeId);\n\t\tphone.setPrimary(primary);\n\n\t\tphonePersistence.update(phone);\n\n\t\treturn phone;\n\t}","id":11148,"modified_method":"public Phone addPhone(\n\t\t\tlong userId, String className, long classPK, String number,\n\t\t\tString extension, int typeId, boolean primary,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, number, extension,\n\t\t\ttypeId, primary);\n\n\t\tlong phoneId = counterLocalService.increment();\n\n\t\tPhone phone = phonePersistence.create(phoneId);\n\n\t\tif (serviceContext != null) {\n\t\t\tphone.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\tphone.setCompanyId(user.getCompanyId());\n\t\tphone.setUserId(user.getUserId());\n\t\tphone.setUserName(user.getFullName());\n\n\t\tif (serviceContext != null) {\n\t\t\tphone.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\tphone.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t}\n\t\telse {\n\t\t\tphone.setCreateDate(now);\n\t\t\tphone.setModifiedDate(now);\n\t\t}\n\n\t\tphone.setClassNameId(classNameId);\n\t\tphone.setClassPK(classPK);\n\t\tphone.setNumber(number);\n\t\tphone.setExtension(extension);\n\t\tphone.setTypeId(typeId);\n\t\tphone.setPrimary(primary);\n\n\t\tphonePersistence.update(phone);\n\n\t\treturn phone;\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Deprecated\n\tpublic Website addWebsite(\n\t\t\tlong userId, String className, long classPK, String url, int typeId,\n\t\t\tboolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addWebsite(\n\t\t\tuserId, className, classPK, url, typeId, primary, null);\n\t}","id":11149,"modified_method":"/**\n\t * @deprecated As of 6.2.0, replaced by {@link #addWebsite(long,\n\t *             String, long, String, int, boolean, ServiceContext)}\n\t */\n\t@Deprecated\n\tpublic Website addWebsite(\n\t\t\tlong userId, String className, long classPK, String url, int typeId,\n\t\t\tboolean primary)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addWebsite(\n\t\t\tuserId, className, classPK, url, typeId, primary, null);\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Website addWebsite(\n\t\t\tlong userId, String className, long classPK, String url, int typeId,\n\t\t\tboolean primary, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, url, typeId, primary);\n\n\t\tlong websiteId = counterLocalService.increment();\n\n\t\tWebsite website = websitePersistence.create(websiteId);\n\n\t\tif (serviceContext != null) {\n\t\t\twebsite.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\twebsite.setCompanyId(user.getCompanyId());\n\t\twebsite.setUserId(user.getUserId());\n\t\twebsite.setUserName(user.getFullName());\n\t\twebsite.setCreateDate(now);\n\t\twebsite.setModifiedDate(now);\n\t\twebsite.setClassNameId(classNameId);\n\t\twebsite.setClassPK(classPK);\n\t\twebsite.setUrl(url);\n\t\twebsite.setTypeId(typeId);\n\t\twebsite.setPrimary(primary);\n\n\t\twebsitePersistence.update(website);\n\n\t\treturn website;\n\t}","id":11150,"modified_method":"public Website addWebsite(\n\t\t\tlong userId, String className, long classPK, String url, int typeId,\n\t\t\tboolean primary, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\t0, user.getCompanyId(), classNameId, classPK, url, typeId, primary);\n\n\t\tlong websiteId = counterLocalService.increment();\n\n\t\tWebsite website = websitePersistence.create(websiteId);\n\n\t\tif (serviceContext != null) {\n\t\t\twebsite.setUuid(serviceContext.getUuid());\n\t\t}\n\n\t\twebsite.setCompanyId(user.getCompanyId());\n\t\twebsite.setUserId(user.getUserId());\n\t\twebsite.setUserName(user.getFullName());\n\t\twebsite.setCreateDate(now);\n\n\t\tif (serviceContext != null) {\n\t\t\twebsite.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\twebsite.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t}\n\t\telse {\n\t\t\twebsite.setCreateDate(now);\n\t\t\twebsite.setModifiedDate(now);\n\t\t}\n\n\t\twebsite.setClassPK(classPK);\n\t\twebsite.setUrl(url);\n\t\twebsite.setTypeId(typeId);\n\t\twebsite.setPrimary(primary);\n\n\t\twebsitePersistence.update(website);\n\n\t\treturn website;\n\t}","commit_id":"cc16cefbbe04fa825ea972e1457e1b0ee59f1a10","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getCSharpType(String type, Map<String, String> languageMapping) {\n        return getLanguageType(Lang.CS, type, JAVA_TO_CSHARP_TYPES);\n    }","id":11151,"modified_method":"public static String getCSharpType(String type) {\n        return getLanguageType(Lang.CS, type, JAVA_TO_CSHARP_TYPES);\n    }","commit_id":"d4d7357d0a3c35332c13e3eef9fc1fb2a34e5c10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void generateCodec(CodecModel codecModel, Template codecTemplate) {\n        final String content = generateFromTemplate(codecTemplate, codecModel);\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            //TODO\n            saveFile(codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase(), codecModel.getPackageName(),\n                    content);\n        }\n    }","id":11152,"modified_method":"public void generateCodec(CodecModel codecModel, Template codecTemplate) {\n        final String content = generateFromTemplate(codecTemplate, codecModel);\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            String fileName = codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase();\n            if(codecModel.getLang() == Lang.PY) {\n                fileName = fileName.replaceAll(\"(.)(\\\\p{Upper})\", \"$1_$2\").toLowerCase();\n            }\n            saveFile(fileName, codecModel.getPackageName(), content);\n        }\n    }","commit_id":"d4d7357d0a3c35332c13e3eef9fc1fb2a34e5c10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void saveContent(Model codecModel, String content) {\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            //TODO\n            saveFile(codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase(), codecModel.getPackageName(),\n                    content);\n        }\n    }","id":11153,"modified_method":"private void saveContent(Model codecModel, String content) {\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            String fileName = codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase();\n            if(codecModel.getLang() == Lang.PY) {\n                fileName = fileName.replaceAll(\"(.)(\\\\p{Upper})\", \"$1_$2\").toLowerCase();\n            }\n            saveFile(fileName, codecModel.getPackageName(), content);\n        }\n    }","commit_id":"d4d7357d0a3c35332c13e3eef9fc1fb2a34e5c10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void initParameters(ExecutableElement methodElement, ExecutableElement responseElement,\n                                List<ExecutableElement> eventElementList, Lang lang) {\n        //request parameters\n        for (VariableElement param : methodElement.getParameters()) {\n            final Nullable nullable = param.getAnnotation(Nullable.class);\n\n            ParameterModel pm = new ParameterModel();\n            pm.name = param.getSimpleName().toString();\n            pm.type = param.asType().toString();\n            pm.lang = lang;\n            pm.nullable = nullable != null;\n            requestParams.add(pm);\n        }\n\n        //response parameters\n        for (VariableElement param : responseElement.getParameters()) {\n            final Nullable nullable = param.getAnnotation(Nullable.class);\n            ParameterModel pm = new ParameterModel();\n            pm.name = param.getSimpleName().toString();\n            pm.type = param.asType().toString();\n            pm.lang = lang;\n            pm.nullable = nullable != null;\n            responseParams.add(pm);\n        }\n\n        //event parameters\n        for (ExecutableElement element : eventElementList) {\n            EventModel eventModel = new EventModel();\n            eventModel.comment = elementUtil.getDocComment(element);\n\n            List<ParameterModel> eventParam = new ArrayList<ParameterModel>();\n            for (VariableElement param : element.getParameters()) {\n                final Nullable nullable = param.getAnnotation(Nullable.class);\n                ParameterModel pm = new ParameterModel();\n                pm.name = param.getSimpleName().toString();\n                pm.type = param.asType().toString();\n                pm.lang = lang;\n                pm.nullable = nullable != null;\n                pm.description = CodeGenerationUtils.getDescription(pm.name, eventModel.comment);\n                eventParam.add(pm);\n            }\n\n            eventModel.type = element.getAnnotation(EventResponse.class).value();\n            eventModel.name = element.getSimpleName().toString();\n            eventModel.eventParams = eventParam;\n\n            events.add(eventModel);\n        }\n    }","id":11154,"modified_method":"private void initParameters(ExecutableElement methodElement, ExecutableElement responseElement,\n                                List<ExecutableElement> eventElementList, Lang lang) {\n        //request parameters\n        for (VariableElement param : methodElement.getParameters()) {\n            final Nullable nullable = param.getAnnotation(Nullable.class);\n\n            ParameterModel pm = new ParameterModel();\n            pm.name = CodeGenerationUtils.escape(param.getSimpleName().toString(), lang);\n            pm.type = param.asType().toString();\n            pm.lang = lang;\n            pm.nullable = nullable != null;\n            requestParams.add(pm);\n        }\n\n        //response parameters\n        for (VariableElement param : responseElement.getParameters()) {\n            final Nullable nullable = param.getAnnotation(Nullable.class);\n            ParameterModel pm = new ParameterModel();\n            pm.name = param.getSimpleName().toString();\n            pm.type = param.asType().toString();\n            pm.lang = lang;\n            pm.nullable = nullable != null;\n            responseParams.add(pm);\n        }\n\n        //event parameters\n        for (ExecutableElement element : eventElementList) {\n            EventModel eventModel = new EventModel();\n            eventModel.comment = elementUtil.getDocComment(element);\n\n            List<ParameterModel> eventParam = new ArrayList<ParameterModel>();\n            for (VariableElement param : element.getParameters()) {\n                final Nullable nullable = param.getAnnotation(Nullable.class);\n                ParameterModel pm = new ParameterModel();\n                pm.name = param.getSimpleName().toString();\n                pm.type = param.asType().toString();\n                pm.lang = lang;\n                pm.nullable = nullable != null;\n                pm.description = CodeGenerationUtils.getDescription(pm.name, eventModel.comment);\n                eventParam.add(pm);\n            }\n\n            eventModel.type = element.getAnnotation(EventResponse.class).value();\n            eventModel.name = element.getSimpleName().toString();\n            eventModel.eventParams = eventParam;\n\n            events.add(eventModel);\n        }\n    }","commit_id":"d4d7357d0a3c35332c13e3eef9fc1fb2a34e5c10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static String getCSharpType(String type, Map<String, String> languageMapping) {\n        return getLanguageType(Lang.CS, type, JAVA_TO_CSHARP_TYPES);\n    }","id":11155,"modified_method":"public static String getCSharpType(String type) {\n        return getLanguageType(Lang.CS, type, JAVA_TO_CSHARP_TYPES);\n    }","commit_id":"20ae52123a3c2f61cd0b1477a96ab28f74e2e372","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void saveContent(Model codecModel, String content) {\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            //TODO\n            saveFile(codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase(), codecModel.getPackageName(),\n                    content);\n        }\n    }","id":11156,"modified_method":"private void saveContent(Model codecModel, String content) {\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            String fileName = codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase();\n            if(codecModel.getLang() == Lang.PY) {\n                fileName = fileName.replaceAll(\"(.)(\\\\p{Upper})\", \"$1_$2\").toLowerCase();\n            }\n            saveFile(fileName, codecModel.getPackageName(), content);\n        }\n    }","commit_id":"20ae52123a3c2f61cd0b1477a96ab28f74e2e372","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void generateCodec(CodecModel codecModel, Template codecTemplate) {\n        final String content = generateFromTemplate(codecTemplate, codecModel);\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            //TODO\n            saveFile(codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase(), codecModel.getPackageName(),\n                    content);\n        }\n    }","id":11157,"modified_method":"public void generateCodec(CodecModel codecModel, Template codecTemplate) {\n        final String content = generateFromTemplate(codecTemplate, codecModel);\n        if (codecModel.getLang() == Lang.JAVA) {\n            saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n        } else {\n            String fileName = codecModel.getClassName() + \".\" + codecModel.getLang().name().toLowerCase();\n            if(codecModel.getLang() == Lang.PY) {\n                fileName = fileName.replaceAll(\"(.)(\\\\p{Upper})\", \"$1_$2\").toLowerCase();\n            }\n            saveFile(fileName, codecModel.getPackageName(), content);\n        }\n    }","commit_id":"20ae52123a3c2f61cd0b1477a96ab28f74e2e372","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void load() {\n        hashSetTable.clearSelection(); // Deselect all rows\n        HashDbXML.getCurrent().reload(); // Reload XML\n        initUI(null); // Update the UI\n    }","id":11158,"modified_method":"@Override\n    public void load() {\n        hashSetTable.clearSelection();      // Deselect all rows\n        HashDbXML.getCurrent().reload();    // Reload XML\n        initUI(null);                       // Update the UI\n        hashSetTableModel.resync();         // resync the table\n    }","commit_id":"2b406e2520660149e1da75cc12e9ad7b53b81e75","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jLabel2 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        jLabel6 = new javax.swing.JLabel();\n        jButton3 = new javax.swing.JButton();\n        ingestWarningLabel = new javax.swing.JLabel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashSetTable = new HashSetTable();\n        deleteButton = new javax.swing.JButton();\n        importButton = new javax.swing.JButton();\n        hashDatabasesLabel = new javax.swing.JLabel();\n        nameLabel = new javax.swing.JLabel();\n        hashDbNameLabel = new javax.swing.JLabel();\n        hashDbLocationLabel = new javax.swing.JLabel();\n        locationLabel = new javax.swing.JLabel();\n        typeLabel = new javax.swing.JLabel();\n        hashDbTypeLabel = new javax.swing.JLabel();\n        hashDbIndexStatusLabel = new javax.swing.JLabel();\n        indexLabel = new javax.swing.JLabel();\n        indexButton = new javax.swing.JButton();\n        useForIngestCheckbox = new javax.swing.JCheckBox();\n        showInboxMessagesCheckBox = new javax.swing.JCheckBox();\n        informationLabel = new javax.swing.JLabel();\n        optionsLabel = new javax.swing.JLabel();\n        informationSeparator = new javax.swing.JSeparator();\n        optionsSeparator = new javax.swing.JSeparator();\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jLabel4.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel6, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jLabel6.text\")); // NOI18N\n\n        jButton3.setFont(new java.awt.Font(\"Tahoma\", 0, 14)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jButton3, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jButton3.text\")); // NOI18N\n\n        setMinimumSize(new java.awt.Dimension(700, 500));\n        setPreferredSize(new java.awt.Dimension(700, 500));\n\n        ingestWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/hashdatabase/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestWarningLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.ingestWarningLabel.text\")); // NOI18N\n\n        hashSetTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        hashSetTable.setShowHorizontalLines(false);\n        hashSetTable.setShowVerticalLines(false);\n        hashSetTable.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyPressed(java.awt.event.KeyEvent evt) {\n                hashSetTableKeyPressed(evt);\n            }\n        });\n        jScrollPane1.setViewportView(hashSetTable);\n\n        deleteButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/hashdatabase/delete16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(deleteButton, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.deleteButton.text\")); // NOI18N\n        deleteButton.setMaximumSize(new java.awt.Dimension(140, 25));\n        deleteButton.setMinimumSize(new java.awt.Dimension(140, 25));\n        deleteButton.setPreferredSize(new java.awt.Dimension(140, 25));\n        deleteButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteButtonActionPerformed(evt);\n            }\n        });\n\n        importButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/hashdatabase/import16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(importButton, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.importButton.text\")); // NOI18N\n        importButton.setMaximumSize(new java.awt.Dimension(140, 25));\n        importButton.setMinimumSize(new java.awt.Dimension(140, 25));\n        importButton.setPreferredSize(new java.awt.Dimension(140, 25));\n        importButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                importButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDatabasesLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDatabasesLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(nameLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.nameLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbNameLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbNameLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbLocationLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbLocationLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(locationLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.locationLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(typeLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.typeLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbTypeLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbTypeLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbIndexStatusLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbIndexStatusLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(indexLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(indexButton, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexButton.text\")); // NOI18N\n        indexButton.setEnabled(false);\n        indexButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                indexButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(useForIngestCheckbox, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.useForIngestCheckbox.text\")); // NOI18N\n        useForIngestCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useForIngestCheckboxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(showInboxMessagesCheckBox, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.showInboxMessagesCheckBox.text\")); // NOI18N\n        showInboxMessagesCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                showInboxMessagesCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(informationLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.informationLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(optionsLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.optionsLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(hashDatabasesLabel)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                                .addComponent(importButton, javax.swing.GroupLayout.PREFERRED_SIZE, 133, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(deleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, 132, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(10, 10, 10)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                                            .addComponent(indexButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                            .addComponent(nameLabel, javax.swing.GroupLayout.Alignment.LEADING)\n                                            .addComponent(locationLabel, javax.swing.GroupLayout.Alignment.LEADING)\n                                            .addComponent(typeLabel, javax.swing.GroupLayout.Alignment.LEADING)\n                                            .addComponent(indexLabel))\n                                        .addGap(18, 18, 18)\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                            .addComponent(hashDbTypeLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                            .addComponent(hashDbLocationLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                            .addComponent(hashDbIndexStatusLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                            .addComponent(hashDbNameLabel)))\n                                    .addComponent(useForIngestCheckbox)\n                                    .addComponent(showInboxMessagesCheckBox)))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(informationLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(informationSeparator))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(optionsLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(optionsSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 324, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(ingestWarningLabel))))\n                .addContainerGap(41, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(hashDatabasesLabel)\n                .addGap(6, 6, 6)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(informationLabel)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(7, 7, 7)\n                                .addComponent(informationSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 3, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                        .addGap(7, 7, 7)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(nameLabel)\n                            .addComponent(hashDbNameLabel))\n                        .addGap(5, 5, 5)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(locationLabel)\n                            .addComponent(hashDbLocationLabel))\n                        .addGap(5, 5, 5)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(typeLabel)\n                            .addComponent(hashDbTypeLabel))\n                        .addGap(5, 5, 5)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(indexLabel)\n                            .addComponent(hashDbIndexStatusLabel))\n                        .addGap(5, 5, 5)\n                        .addComponent(indexButton)\n                        .addGap(18, 18, 18)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(optionsLabel)\n                            .addComponent(optionsSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(useForIngestCheckbox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(showInboxMessagesCheckBox)\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestWarningLabel)\n                        .addGap(0, 0, Short.MAX_VALUE))\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 422, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(importButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(deleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap())\n        );\n    }","id":11159,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jLabel2 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        jLabel6 = new javax.swing.JLabel();\n        jButton3 = new javax.swing.JButton();\n        ingestWarningLabel = new javax.swing.JLabel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashSetTable = new HashSetTable();\n        deleteButton = new javax.swing.JButton();\n        importButton = new javax.swing.JButton();\n        hashDatabasesLabel = new javax.swing.JLabel();\n        nameLabel = new javax.swing.JLabel();\n        hashDbNameLabel = new javax.swing.JLabel();\n        hashDbLocationLabel = new javax.swing.JLabel();\n        locationLabel = new javax.swing.JLabel();\n        typeLabel = new javax.swing.JLabel();\n        hashDbTypeLabel = new javax.swing.JLabel();\n        hashDbIndexStatusLabel = new javax.swing.JLabel();\n        indexLabel = new javax.swing.JLabel();\n        indexButton = new javax.swing.JButton();\n        useForIngestCheckbox = new javax.swing.JCheckBox();\n        showInboxMessagesCheckBox = new javax.swing.JCheckBox();\n        informationLabel = new javax.swing.JLabel();\n        optionsLabel = new javax.swing.JLabel();\n        informationSeparator = new javax.swing.JSeparator();\n        optionsSeparator = new javax.swing.JSeparator();\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jLabel4.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel6, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jLabel6.text\")); // NOI18N\n\n        jButton3.setFont(new java.awt.Font(\"Tahoma\", 0, 14)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jButton3, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.jButton3.text\")); // NOI18N\n\n        setMinimumSize(new java.awt.Dimension(700, 500));\n        setPreferredSize(new java.awt.Dimension(700, 500));\n\n        ingestWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/hashdatabase/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestWarningLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.ingestWarningLabel.text\")); // NOI18N\n\n        hashSetTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        hashSetTable.setShowHorizontalLines(false);\n        hashSetTable.setShowVerticalLines(false);\n        hashSetTable.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyPressed(java.awt.event.KeyEvent evt) {\n                hashSetTableKeyPressed(evt);\n            }\n        });\n        jScrollPane1.setViewportView(hashSetTable);\n\n        deleteButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/hashdatabase/delete16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(deleteButton, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.deleteButton.text\")); // NOI18N\n        deleteButton.setMaximumSize(new java.awt.Dimension(140, 25));\n        deleteButton.setMinimumSize(new java.awt.Dimension(140, 25));\n        deleteButton.setPreferredSize(new java.awt.Dimension(140, 25));\n        deleteButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteButtonActionPerformed(evt);\n            }\n        });\n\n        importButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/hashdatabase/import16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(importButton, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.importButton.text\")); // NOI18N\n        importButton.setMaximumSize(new java.awt.Dimension(140, 25));\n        importButton.setMinimumSize(new java.awt.Dimension(140, 25));\n        importButton.setPreferredSize(new java.awt.Dimension(140, 25));\n        importButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                importButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDatabasesLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDatabasesLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(nameLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.nameLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbNameLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbNameLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbLocationLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbLocationLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(locationLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.locationLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(typeLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.typeLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbTypeLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbTypeLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashDbIndexStatusLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbIndexStatusLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(indexLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(indexButton, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexButton.text\")); // NOI18N\n        indexButton.setEnabled(false);\n        indexButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                indexButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(useForIngestCheckbox, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.useForIngestCheckbox.text\")); // NOI18N\n        useForIngestCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useForIngestCheckboxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(showInboxMessagesCheckBox, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.showInboxMessagesCheckBox.text\")); // NOI18N\n        showInboxMessagesCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                showInboxMessagesCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(informationLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.informationLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(optionsLabel, org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.optionsLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(hashDatabasesLabel)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                                .addComponent(importButton, javax.swing.GroupLayout.PREFERRED_SIZE, 133, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(deleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, 132, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(informationLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(informationSeparator))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(optionsLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(optionsSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 324, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(ingestWarningLabel)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(10, 10, 10)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                            .addGroup(layout.createSequentialGroup()\n                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                                    .addComponent(nameLabel)\n                                                    .addComponent(locationLabel)\n                                                    .addComponent(typeLabel))\n                                                .addGap(40, 40, 40))\n                                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                                .addComponent(indexLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                                .addGap(18, 18, 18)))\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                            .addComponent(hashDbTypeLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                            .addComponent(hashDbLocationLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                            .addComponent(hashDbIndexStatusLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                            .addComponent(hashDbNameLabel)))\n                                    .addComponent(useForIngestCheckbox)\n                                    .addComponent(showInboxMessagesCheckBox)\n                                    .addComponent(indexButton, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE))))))\n                .addContainerGap(40, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(hashDatabasesLabel)\n                .addGap(6, 6, 6)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(informationLabel)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(7, 7, 7)\n                                .addComponent(informationSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 3, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                        .addGap(7, 7, 7)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(nameLabel)\n                            .addComponent(hashDbNameLabel))\n                        .addGap(5, 5, 5)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(locationLabel)\n                            .addComponent(hashDbLocationLabel))\n                        .addGap(5, 5, 5)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(typeLabel)\n                            .addComponent(hashDbTypeLabel))\n                        .addGap(5, 5, 5)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(hashDbIndexStatusLabel)\n                            .addComponent(indexLabel))\n                        .addGap(5, 5, 5)\n                        .addComponent(indexButton)\n                        .addGap(18, 18, 18)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(optionsLabel)\n                            .addComponent(optionsSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(useForIngestCheckbox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(showInboxMessagesCheckBox)\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestWarningLabel)\n                        .addGap(0, 0, Short.MAX_VALUE))\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 422, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(importButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(deleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap())\n        );\n    }","commit_id":"2b406e2520660149e1da75cc12e9ad7b53b81e75","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** \n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        buttonGroup1 = new javax.swing.ButtonGroup();\n        jLabel2 = new javax.swing.JLabel();\n        nextLabel = new javax.swing.JLabel();\n        typeTabel = new javax.swing.JLabel();\n        typeComboBox = new javax.swing.JComboBox();\n        containerPanel = new javax.swing.JPanel();\n        noFatOrphansCheckbox = new javax.swing.JCheckBox();\n        timeZoneLabel = new javax.swing.JLabel();\n        descLabel = new javax.swing.JLabel();\n        timeZoneComboBox = new javax.swing.JComboBox();\n        typePanel = new javax.swing.JPanel();\n        jLabel1 = new javax.swing.JLabel();\n        jSeparator1 = new javax.swing.JSeparator();\n        jLabel3 = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel2.text\")); // NOI18N\n\n        setPreferredSize(new java.awt.Dimension(588, 328));\n\n        org.openide.awt.Mnemonics.setLocalizedText(nextLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.nextLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(typeTabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.typeTabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(noFatOrphansCheckbox, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.text\")); // NOI18N\n        noFatOrphansCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.toolTipText\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(timeZoneLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.timeZoneLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(descLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.descLabel.text\")); // NOI18N\n\n        timeZoneComboBox.setMaximumRowCount(30);\n\n        typePanel.setMinimumSize(new java.awt.Dimension(0, 60));\n\n        javax.swing.GroupLayout typePanelLayout = new javax.swing.GroupLayout(typePanel);\n        typePanel.setLayout(typePanelLayout);\n        typePanelLayout.setHorizontalGroup(\n            typePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 549, Short.MAX_VALUE)\n        );\n        typePanelLayout.setVerticalGroup(\n            typePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 144, Short.MAX_VALUE)\n        );\n\n        javax.swing.GroupLayout containerPanelLayout = new javax.swing.GroupLayout(containerPanel);\n        containerPanel.setLayout(containerPanelLayout);\n        containerPanelLayout.setHorizontalGroup(\n            containerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, containerPanelLayout.createSequentialGroup()\n                .addContainerGap(20, Short.MAX_VALUE)\n                .addGroup(containerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(timeZoneLabel)\n                    .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 252, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(noFatOrphansCheckbox)\n                    .addGroup(containerPanelLayout.createSequentialGroup()\n                        .addGap(21, 21, 21)\n                        .addComponent(descLabel))\n                    .addComponent(typePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(20, 20, 20))\n        );\n        containerPanelLayout.setVerticalGroup(\n            containerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(containerPanelLayout.createSequentialGroup()\n                .addComponent(typePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(timeZoneLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(11, 11, 11)\n                .addComponent(noFatOrphansCheckbox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(descLabel))\n        );\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel1.text\")); // NOI18N\n\n        jSeparator1.setForeground(new java.awt.Color(102, 102, 102));\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel3.text\")); // NOI18N\n\n        jSeparator2.setForeground(new java.awt.Color(102, 102, 102));\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(containerPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel3)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(jSeparator2))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel1)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(jSeparator1))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(nextLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(10, 10, 10)\n                                .addComponent(typeTabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(typeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 292, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                        .addGap(0, 0, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel1)\n                    .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(typeTabel)\n                    .addComponent(typeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jLabel3)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(8, 8, 8)\n                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(containerPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 22, Short.MAX_VALUE)\n                .addComponent(nextLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n        );\n    }","id":11160,"modified_method":"/** \n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        buttonGroup1 = new javax.swing.ButtonGroup();\n        jLabel2 = new javax.swing.JLabel();\n        nextLabel = new javax.swing.JLabel();\n        typeTabel = new javax.swing.JLabel();\n        typeComboBox = new javax.swing.JComboBox();\n        containerPanel = new javax.swing.JPanel();\n        noFatOrphansCheckbox = new javax.swing.JCheckBox();\n        timeZoneLabel = new javax.swing.JLabel();\n        descLabel = new javax.swing.JLabel();\n        timeZoneComboBox = new javax.swing.JComboBox();\n        typePanel = new javax.swing.JPanel();\n        jLabel1 = new javax.swing.JLabel();\n        jSeparator1 = new javax.swing.JSeparator();\n        jLabel3 = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel2.text\")); // NOI18N\n\n        setPreferredSize(new java.awt.Dimension(588, 328));\n\n        org.openide.awt.Mnemonics.setLocalizedText(nextLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.nextLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(typeTabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.typeTabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(noFatOrphansCheckbox, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.text\")); // NOI18N\n        noFatOrphansCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.toolTipText\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(timeZoneLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.timeZoneLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(descLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.descLabel.text\")); // NOI18N\n\n        timeZoneComboBox.setMaximumRowCount(30);\n\n        typePanel.setMinimumSize(new java.awt.Dimension(0, 60));\n\n        javax.swing.GroupLayout typePanelLayout = new javax.swing.GroupLayout(typePanel);\n        typePanel.setLayout(typePanelLayout);\n        typePanelLayout.setHorizontalGroup(\n            typePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 0, Short.MAX_VALUE)\n        );\n        typePanelLayout.setVerticalGroup(\n            typePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 144, Short.MAX_VALUE)\n        );\n\n        javax.swing.GroupLayout containerPanelLayout = new javax.swing.GroupLayout(containerPanel);\n        containerPanel.setLayout(containerPanelLayout);\n        containerPanelLayout.setHorizontalGroup(\n            containerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(containerPanelLayout.createSequentialGroup()\n                .addGap(20, 20, 20)\n                .addGroup(containerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(typePanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addGroup(containerPanelLayout.createSequentialGroup()\n                        .addGroup(containerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(timeZoneLabel)\n                            .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 252, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(noFatOrphansCheckbox)\n                            .addGroup(containerPanelLayout.createSequentialGroup()\n                                .addGap(21, 21, 21)\n                                .addComponent(descLabel)))\n                        .addGap(0, 0, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        containerPanelLayout.setVerticalGroup(\n            containerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(containerPanelLayout.createSequentialGroup()\n                .addComponent(typePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(timeZoneLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(11, 11, 11)\n                .addComponent(noFatOrphansCheckbox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(descLabel))\n        );\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel1.text\")); // NOI18N\n\n        jSeparator1.setForeground(new java.awt.Color(102, 102, 102));\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel3.text\")); // NOI18N\n\n        jSeparator2.setForeground(new java.awt.Color(102, 102, 102));\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(containerPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel3)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(jSeparator2))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel1)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(jSeparator1))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(nextLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(10, 10, 10)\n                                .addComponent(typeTabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(typeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 292, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                        .addGap(0, 54, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel1)\n                    .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(typeTabel)\n                    .addComponent(typeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jLabel3)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(8, 8, 8)\n                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(containerPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(nextLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n        );\n    }","commit_id":"8388cf54bba15755a4e87b0044ea573e8657c3ca","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public IngestDialog(JFrame frame, String title, boolean modal) {\n        super(frame, title, modal);\n    }","id":11161,"modified_method":"public IngestDialog(JFrame frame, String title, boolean modal) {\n        super(frame, title, modal);\n        this.manager = IngestManager.getDefault();\n    }","commit_id":"315812d9d824a14ca6d4e4163dc64ef3fb5db2f0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void setImage(Image image) {\n        panel.setImage(image);\n    }","id":11162,"modified_method":"public void setImage(Image image) {\n        this.image = image;\n    }","commit_id":"315812d9d824a14ca6d4e4163dc64ef3fb5db2f0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Shows the Ingest dialog.\n     */\n    public void display() {\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n\n        // set the popUp window / JFrame\n        setSize(DIMENSIONS);\n        int w = this.getSize().width;\n        int h = this.getSize().height;\n\n        // set the location of the popUp Window on the center of the screen\n        setLocation((screenDimension.width - w) / 2, (screenDimension.height - h) / 2);\n\n        // add the command to close the window to both buttons\n        panel.setCloseButtonActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                close();\n            }\n        });\n        panel.setStartButtonActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                close();\n            }\n        });\n\n        add(panel);\n        pack();\n        setResizable(false);\n        setVisible(true);\n    }","id":11163,"modified_method":"/**\n     * Shows the Ingest dialog.\n     */\n    public void display() {\n        setLayout(new BorderLayout());\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n\n        // set the popUp window / JFrame\n        setSize(DIMENSIONS);\n        int w = this.getSize().width;\n        int h = this.getSize().height;\n\n        // set the location of the popUp Window on the center of the screen\n        setLocation((screenDimension.width - w) / 2, (screenDimension.height - h) / 2);\n\n        add(panel, BorderLayout.PAGE_START);\n        JButton startButton = new JButton(\"Start\");\n        JButton closeButton = new JButton(\"Close\");\n        startButton.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                //pick the services\n                List<IngestServiceAbstract> servicesToStart = panel.getServicesToStart();\n\n                if (!servicesToStart.isEmpty()) {\n                    manager.execute(servicesToStart, image);\n                }\n\n                //update ingest freq. refresh\n                if (panel.freqSliderEnabled()) {\n                    manager.setUpdateFrequency(panel.sliderValue());\n                }\n                close();\n            }\n        });\n        closeButton.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                close();\n            }\n        });\n        add(startButton, BorderLayout.LINE_START);\n        add(closeButton, BorderLayout.LINE_END);\n        \n        pack();\n        setResizable(false);\n        setVisible(true);\n    }","commit_id":"315812d9d824a14ca6d4e4163dc64ef3fb5db2f0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        startButton = new javax.swing.JButton();\n        closeButton = new javax.swing.JButton();\n        freqSlider = new javax.swing.JSlider();\n        freqSliderLabel = new javax.swing.JLabel();\n        servicesScrollPane = new javax.swing.JScrollPane();\n        servicesTable = new javax.swing.JTable();\n        configurePane = new javax.swing.JLayeredPane();\n        advancedButton = new javax.swing.JButton();\n\n        startButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.startButton.text\")); // NOI18N\n        startButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                startButtonActionPerformed(evt);\n            }\n        });\n\n        closeButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.closeButton.text\")); // NOI18N\n\n        freqSlider.setMajorTickSpacing(5);\n        freqSlider.setMaximum(30);\n        freqSlider.setMinorTickSpacing(2);\n        freqSlider.setPaintLabels(true);\n        freqSlider.setPaintTicks(true);\n        freqSlider.setSnapToTicks(true);\n        freqSlider.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSlider.toolTipText\")); // NOI18N\n        freqSlider.setValue(15);\n\n        freqSliderLabel.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.text\")); // NOI18N\n        freqSliderLabel.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.toolTipText\")); // NOI18N\n\n        servicesScrollPane.setPreferredSize(new java.awt.Dimension(161, 201));\n\n        servicesTable.setBackground(new java.awt.Color(240, 240, 240));\n        servicesTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        servicesTable.setShowHorizontalLines(false);\n        servicesTable.setShowVerticalLines(false);\n        servicesScrollPane.setViewportView(servicesTable);\n\n        configurePane.setOpaque(true);\n        configurePane.setPreferredSize(new java.awt.Dimension(300, 300));\n        configurePane.setRequestFocusEnabled(false);\n\n        advancedButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.advancedButton.text\")); // NOI18N\n        advancedButton.setEnabled(false);\n        advancedButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                advancedButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(startButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(closeButton))\n                    .addComponent(freqSliderLabel)\n                    .addComponent(freqSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(servicesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 200, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(configurePane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(advancedButton))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(configurePane, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(servicesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 228, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(freqSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(freqSliderLabel)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(closeButton)\n                    .addComponent(startButton)\n                    .addComponent(advancedButton))\n                .addContainerGap())\n        );\n    }","id":11164,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        freqSlider = new javax.swing.JSlider();\n        freqSliderLabel = new javax.swing.JLabel();\n        servicesScrollPane = new javax.swing.JScrollPane();\n        servicesTable = new javax.swing.JTable();\n        configurePane = new javax.swing.JLayeredPane();\n        advancedButton = new javax.swing.JButton();\n\n        freqSlider.setMajorTickSpacing(5);\n        freqSlider.setMaximum(30);\n        freqSlider.setMinorTickSpacing(2);\n        freqSlider.setPaintLabels(true);\n        freqSlider.setPaintTicks(true);\n        freqSlider.setSnapToTicks(true);\n        freqSlider.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSlider.toolTipText\")); // NOI18N\n        freqSlider.setValue(15);\n\n        freqSliderLabel.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.text\")); // NOI18N\n        freqSliderLabel.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.toolTipText\")); // NOI18N\n\n        servicesScrollPane.setPreferredSize(new java.awt.Dimension(161, 201));\n\n        servicesTable.setBackground(new java.awt.Color(240, 240, 240));\n        servicesTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        servicesTable.setShowHorizontalLines(false);\n        servicesTable.setShowVerticalLines(false);\n        servicesScrollPane.setViewportView(servicesTable);\n\n        configurePane.setOpaque(true);\n        configurePane.setPreferredSize(new java.awt.Dimension(300, 300));\n        configurePane.setRequestFocusEnabled(false);\n\n        advancedButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.advancedButton.text\")); // NOI18N\n        advancedButton.setEnabled(false);\n        advancedButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                advancedButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(19, 19, 19)\n                        .addComponent(freqSliderLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(freqSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(servicesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 200, Short.MAX_VALUE)))\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(6, 6, 6)\n                        .addComponent(configurePane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addContainerGap())\n                    .addGroup(layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(advancedButton))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(servicesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(freqSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(configurePane, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(advancedButton)\n                    .addComponent(freqSliderLabel))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n    }","commit_id":"315812d9d824a14ca6d4e4163dc64ef3fb5db2f0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void resetComponent() {\n        // clear / reset the fields\n        currentPage = 1;\n        currentOffset = 0;\n        this.dataSource = null;\n        currentPageLabel.setText(\"\");\n        totalPageLabel.setText(\"\");\n        prevPageButton.setEnabled(false);\n        nextPageButton.setEnabled(false);\n        setComponentsVisibility(false); // hides the components that not needed\n        noTextLabel.setText(\"\");\n    }","id":11165,"modified_method":"@Override\n    public void resetComponent() {\n        // clear / reset the fields\n        currentPage = 1;\n        currentOffset = 0;\n        this.dataSource = null;\n        currentPageLabel.setText(\"\");\n        totalPageLabel.setText(\"\");\n        prevPageButton.setEnabled(false);\n        nextPageButton.setEnabled(false);\n        setComponentsVisibility(false); // hides the components that not needed\n    }","commit_id":"5a5b59c22f5b0daa294724451f5c977f83ba8c50","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Sets the DataView (The tabbed panel)\n     *\n     * @param dataSource  the content that want to be shown\n     * @param offset      the starting offset\n     * @param reset       whether to reset the dataView or not\n     */\n    public void setDataView(Content dataSource, long offset, boolean reset) {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            try {\n                this.dataSource = dataSource;\n\n                int bytesRead = 0;\n                if (!reset && dataSource.getSize() > 0) {\n                    bytesRead = dataSource.read(data, offset, pageLength); // read the data\n                } \n\n\n                // set the data on the bottom and show it\n                String text = \"\";\n                Boolean setVisible = false;\n\n                if (bytesRead > 0) {\n                    //text = DataConversion.getString(data, bytesRead, 4);\n                    final SCRIPT selScript = (SCRIPT) languageCombo.getSelectedItem();\n                    stringExtract.setEnabledScript(selScript);\n                    StringExtractResult res = stringExtract.extract(data, bytesRead, 0);\n                    text = res.getText();\n                    if (text.trim().isEmpty()) {\n                        noTextLabel.setText(\"(offset \" + currentOffset + \"-\" + (currentOffset + pageLength) \n                                + \" contains no text)\");\n                    }\n                    else {\n                        noTextLabel.setText(\"\");\n                    }\n                    setVisible = true;\n                }\n\n                // disable or enable the next button\n                if (!reset && offset + pageLength < dataSource.getSize()) {\n                    nextPageButton.setEnabled(true);\n                } else {\n                    nextPageButton.setEnabled(false);\n                }\n\n                if (offset == 0) {\n                    prevPageButton.setEnabled(false);\n                    currentPage = 1; // reset the page number\n                } else {\n                    prevPageButton.setEnabled(true);\n                }\n\n                if (setVisible) {\n                    int totalPage = Math.round((dataSource.getSize()-1) / pageLength) + 1;\n                    totalPageLabel.setText(Integer.toString(totalPage));\n                    currentPageLabel.setText(Integer.toString(currentPage));\n                    outputViewPane.setText(text); // set the output view\n                    setComponentsVisibility(true); // shows the components that not needed\n                } else {\n                    // reset or hide the labels\n                    totalPageLabel.setText(\"\");\n                    currentPageLabel.setText(\"\");\n                    outputViewPane.setText(\"\"); // reset the output view\n                    setComponentsVisibility(false); // hides the components that not needed\n                }\n                outputViewPane.moveCaretPosition(0);\n            } catch (TskException ex) {\n                Logger logger = Logger.getLogger(this.className);\n                logger.log(Level.WARNING, \"Error while trying to show the String content.\", ex);\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","id":11166,"modified_method":"/**\n     * Sets the DataView (The tabbed panel)\n     *\n     * @param dataSource  the content that want to be shown\n     * @param offset      the starting offset\n     * @param reset       whether to reset the dataView or not\n     */\n    public void setDataView(Content dataSource, long offset, boolean reset) {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            try {\n                this.dataSource = dataSource;\n\n                int bytesRead = 0;\n                if (!reset && dataSource.getSize() > 0) {\n                    bytesRead = dataSource.read(data, offset, pageLength); // read the data\n                } \n\n\n                // set the data on the bottom and show it\n                String text = \"\";\n                Boolean setVisible = false;\n\n                if (bytesRead > 0) {\n                    //text = DataConversion.getString(data, bytesRead, 4);\n                    final SCRIPT selScript = (SCRIPT) languageCombo.getSelectedItem();\n                    stringExtract.setEnabledScript(selScript);\n                    StringExtractResult res = stringExtract.extract(data, bytesRead, 0);\n                    text = res.getText();\n                    if (text.trim().isEmpty()) {\n                        text = \"(offset \" + currentOffset + \"-\" + (currentOffset + pageLength) \n                                + \" contains no text)\";\n                    }\n  \n                    setVisible = true;\n                }\n\n                // disable or enable the next button\n                if (!reset && offset + pageLength < dataSource.getSize()) {\n                    nextPageButton.setEnabled(true);\n                } else {\n                    nextPageButton.setEnabled(false);\n                }\n\n                if (offset == 0) {\n                    prevPageButton.setEnabled(false);\n                    currentPage = 1; // reset the page number\n                } else {\n                    prevPageButton.setEnabled(true);\n                }\n\n                if (setVisible) {\n                    int totalPage = Math.round((dataSource.getSize()-1) / pageLength) + 1;\n                    totalPageLabel.setText(Integer.toString(totalPage));\n                    currentPageLabel.setText(Integer.toString(currentPage));\n                    outputViewPane.setText(text); // set the output view\n                    setComponentsVisibility(true); // shows the components that not needed\n                } else {\n                    // reset or hide the labels\n                    totalPageLabel.setText(\"\");\n                    currentPageLabel.setText(\"\");\n                    outputViewPane.setText(\"\"); // reset the output view\n                    setComponentsVisibility(false); // hides the components that not needed\n                }\n                outputViewPane.moveCaretPosition(0);\n            } catch (TskException ex) {\n                Logger logger = Logger.getLogger(this.className);\n                logger.log(Level.WARNING, \"Error while trying to show the String content.\", ex);\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","commit_id":"5a5b59c22f5b0daa294724451f5c977f83ba8c50","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        copyMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        jPanel1 = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        outputViewPane = new javax.swing.JTextPane();\n        totalPageLabel = new javax.swing.JLabel();\n        ofLabel = new javax.swing.JLabel();\n        currentPageLabel = new javax.swing.JLabel();\n        pageLabel = new javax.swing.JLabel();\n        nextPageButton = new javax.swing.JButton();\n        pageLabel2 = new javax.swing.JLabel();\n        prevPageButton = new javax.swing.JButton();\n        goToPageLabel = new javax.swing.JLabel();\n        goToPageTextField = new javax.swing.JTextField();\n        languageCombo = new javax.swing.JComboBox();\n        languageLabel = new javax.swing.JLabel();\n        noTextLabel = new javax.swing.JLabel();\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        outputViewPane.setEditable(false);\n        outputViewPane.setFont(new java.awt.Font(\"Courier New\", 0, 11)); // NOI18N\n        outputViewPane.setPreferredSize(new java.awt.Dimension(700, 400));\n        jScrollPane1.setViewportView(outputViewPane);\n\n        totalPageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.totalPageLabel.text_1\")); // NOI18N\n\n        ofLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.ofLabel.text_1\")); // NOI18N\n\n        currentPageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.currentPageLabel.text_1\")); // NOI18N\n        currentPageLabel.setMaximumSize(new java.awt.Dimension(18, 14));\n        currentPageLabel.setMinimumSize(new java.awt.Dimension(18, 14));\n        currentPageLabel.setPreferredSize(new java.awt.Dimension(18, 14));\n\n        pageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.pageLabel.text_1\")); // NOI18N\n        pageLabel.setMaximumSize(new java.awt.Dimension(33, 14));\n        pageLabel.setMinimumSize(new java.awt.Dimension(33, 14));\n        pageLabel.setPreferredSize(new java.awt.Dimension(33, 14));\n\n        nextPageButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_forward.png\"))); // NOI18N\n        nextPageButton.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.nextPageButton.text\")); // NOI18N\n        nextPageButton.setBorderPainted(false);\n        nextPageButton.setContentAreaFilled(false);\n        nextPageButton.setDisabledIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_forward_disabled.png\"))); // NOI18N\n        nextPageButton.setMargin(new java.awt.Insets(2, 0, 2, 0));\n        nextPageButton.setPreferredSize(new java.awt.Dimension(55, 23));\n        nextPageButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_forward_hover.png\"))); // NOI18N\n        nextPageButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                nextPageButtonActionPerformed(evt);\n            }\n        });\n\n        pageLabel2.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.pageLabel2.text\")); // NOI18N\n        pageLabel2.setMaximumSize(new java.awt.Dimension(29, 14));\n        pageLabel2.setMinimumSize(new java.awt.Dimension(29, 14));\n        pageLabel2.setPreferredSize(new java.awt.Dimension(29, 14));\n\n        prevPageButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_back.png\"))); // NOI18N\n        prevPageButton.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.prevPageButton.text\")); // NOI18N\n        prevPageButton.setBorderPainted(false);\n        prevPageButton.setContentAreaFilled(false);\n        prevPageButton.setDisabledIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_back_disabled.png\"))); // NOI18N\n        prevPageButton.setMargin(new java.awt.Insets(2, 0, 2, 0));\n        prevPageButton.setPreferredSize(new java.awt.Dimension(55, 23));\n        prevPageButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_back_hover.png\"))); // NOI18N\n        prevPageButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                prevPageButtonActionPerformed(evt);\n            }\n        });\n\n        goToPageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.goToPageLabel.text\")); // NOI18N\n\n        goToPageTextField.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.goToPageTextField.text\")); // NOI18N\n        goToPageTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                goToPageTextFieldActionPerformed(evt);\n            }\n        });\n\n        languageCombo.setToolTipText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.languageCombo.toolTipText\")); // NOI18N\n        languageCombo.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                languageComboActionPerformed(evt);\n            }\n        });\n\n        languageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.languageLabel.text\")); // NOI18N\n        languageLabel.setToolTipText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.languageLabel.toolTipText\")); // NOI18N\n\n        noTextLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.noTextLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(pageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addComponent(currentPageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(ofLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(totalPageLabel)\n                .addGap(50, 50, 50)\n                .addComponent(pageLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(prevPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 0, 0)\n                .addComponent(nextPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addComponent(goToPageLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(goToPageTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(noTextLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(languageLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(languageCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 229, javax.swing.GroupLayout.PREFERRED_SIZE))\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 756, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(pageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(currentPageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(ofLabel)\n                        .addComponent(totalPageLabel))\n                    .addComponent(pageLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(nextPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(prevPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(goToPageLabel)\n                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(goToPageTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(languageCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(languageLabel)\n                        .addComponent(noTextLabel)))\n                .addGap(0, 0, 0)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 401, Short.MAX_VALUE))\n        );\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n    }","id":11167,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        copyMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        jPanel1 = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        outputViewPane = new javax.swing.JTextPane();\n        totalPageLabel = new javax.swing.JLabel();\n        ofLabel = new javax.swing.JLabel();\n        currentPageLabel = new javax.swing.JLabel();\n        pageLabel = new javax.swing.JLabel();\n        nextPageButton = new javax.swing.JButton();\n        pageLabel2 = new javax.swing.JLabel();\n        prevPageButton = new javax.swing.JButton();\n        goToPageLabel = new javax.swing.JLabel();\n        goToPageTextField = new javax.swing.JTextField();\n        languageCombo = new javax.swing.JComboBox();\n        languageLabel = new javax.swing.JLabel();\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        outputViewPane.setEditable(false);\n        outputViewPane.setFont(new java.awt.Font(\"Courier New\", 0, 11)); // NOI18N\n        outputViewPane.setPreferredSize(new java.awt.Dimension(700, 400));\n        jScrollPane1.setViewportView(outputViewPane);\n\n        totalPageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.totalPageLabel.text_1\")); // NOI18N\n\n        ofLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.ofLabel.text_1\")); // NOI18N\n\n        currentPageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.currentPageLabel.text_1\")); // NOI18N\n        currentPageLabel.setMaximumSize(new java.awt.Dimension(18, 14));\n        currentPageLabel.setMinimumSize(new java.awt.Dimension(18, 14));\n        currentPageLabel.setPreferredSize(new java.awt.Dimension(18, 14));\n\n        pageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.pageLabel.text_1\")); // NOI18N\n        pageLabel.setMaximumSize(new java.awt.Dimension(33, 14));\n        pageLabel.setMinimumSize(new java.awt.Dimension(33, 14));\n        pageLabel.setPreferredSize(new java.awt.Dimension(33, 14));\n\n        nextPageButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_forward.png\"))); // NOI18N\n        nextPageButton.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.nextPageButton.text\")); // NOI18N\n        nextPageButton.setBorderPainted(false);\n        nextPageButton.setContentAreaFilled(false);\n        nextPageButton.setDisabledIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_forward_disabled.png\"))); // NOI18N\n        nextPageButton.setMargin(new java.awt.Insets(2, 0, 2, 0));\n        nextPageButton.setPreferredSize(new java.awt.Dimension(55, 23));\n        nextPageButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_forward_hover.png\"))); // NOI18N\n        nextPageButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                nextPageButtonActionPerformed(evt);\n            }\n        });\n\n        pageLabel2.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.pageLabel2.text\")); // NOI18N\n        pageLabel2.setMaximumSize(new java.awt.Dimension(29, 14));\n        pageLabel2.setMinimumSize(new java.awt.Dimension(29, 14));\n        pageLabel2.setPreferredSize(new java.awt.Dimension(29, 14));\n\n        prevPageButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_back.png\"))); // NOI18N\n        prevPageButton.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.prevPageButton.text\")); // NOI18N\n        prevPageButton.setBorderPainted(false);\n        prevPageButton.setContentAreaFilled(false);\n        prevPageButton.setDisabledIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_back_disabled.png\"))); // NOI18N\n        prevPageButton.setMargin(new java.awt.Insets(2, 0, 2, 0));\n        prevPageButton.setPreferredSize(new java.awt.Dimension(55, 23));\n        prevPageButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/btn_step_back_hover.png\"))); // NOI18N\n        prevPageButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                prevPageButtonActionPerformed(evt);\n            }\n        });\n\n        goToPageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.goToPageLabel.text\")); // NOI18N\n\n        goToPageTextField.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.goToPageTextField.text\")); // NOI18N\n        goToPageTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                goToPageTextFieldActionPerformed(evt);\n            }\n        });\n\n        languageCombo.setToolTipText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.languageCombo.toolTipText\")); // NOI18N\n        languageCombo.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                languageComboActionPerformed(evt);\n            }\n        });\n\n        languageLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.languageLabel.text\")); // NOI18N\n        languageLabel.setToolTipText(org.openide.util.NbBundle.getMessage(DataContentViewerString.class, \"DataContentViewerString.languageLabel.toolTipText\")); // NOI18N\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                    .addGroup(jPanel1Layout.createSequentialGroup()\n                        .addComponent(pageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(18, 18, 18)\n                        .addComponent(currentPageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(ofLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(totalPageLabel)\n                        .addGap(50, 50, 50)\n                        .addComponent(pageLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(prevPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 0, 0)\n                        .addComponent(nextPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(18, 18, 18)\n                        .addComponent(goToPageLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(goToPageTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(33, 33, 33)\n                        .addComponent(languageLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(languageCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 11, Short.MAX_VALUE))))\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(pageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(currentPageLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(ofLabel)\n                        .addComponent(totalPageLabel))\n                    .addComponent(pageLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(nextPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(prevPageButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(goToPageLabel)\n                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(goToPageTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(languageCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(languageLabel)))\n                .addGap(0, 0, 0)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 401, Short.MAX_VALUE))\n        );\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n    }","commit_id":"5a5b59c22f5b0daa294724451f5c977f83ba8c50","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n   * Get metrics for an app grouped by the requested @TemporalInfo which is a\n   * part of the @TimelineAppMetricCacheKey\n   * @param key @TimelineAppMetricCacheKey\n   * @return @org.apache.hadoop.metrics2.sink.timeline.TimelineMetrics\n   */\n  public TimelineMetrics getAppTimelineMetricsFromCache(TimelineAppMetricCacheKey key) throws IllegalArgumentException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Fetching metrics with key: \" + key);\n    }\n\n    // Make sure key is valid\n    validateKey(key);\n\n    Element element = get(key);\n    TimelineMetrics timelineMetrics = new TimelineMetrics();\n    if (element != null && element.getObjectValue() != null) {\n      TimelineMetricsCacheValue value = (TimelineMetricsCacheValue) element.getObjectValue();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Returning value from cache: \" + value);\n      }\n      timelineMetrics.setMetrics(new ArrayList<TimelineMetric>(value.getTimelineMetrics().values()));\n    }\n\n    if (LOG.isDebugEnabled()) {\n      // Print stats every 100 calls - Note: Supported in debug mode only\n      if (printCacheStatsCounter.getAndIncrement() == 0) {\n        StatisticsGateway statistics = this.getStatistics();\n        LOG.debug(\"Metrics cache stats => \\n\" +\n          \", Evictions = \" + statistics.cacheEvictedCount() +\n          \", Expired = \" + statistics.cacheExpiredCount() +\n          \", Hits = \" + statistics.cacheHitCount() +\n          \", Misses = \" + statistics.cacheMissCount() +\n          \", Hit ratio = \" + statistics.cacheHitRatio() +\n          \", Puts = \" + statistics.cachePutCount() +\n          \", Size in MB = \" + (statistics.getLocalHeapSizeInBytes() / 1048576));\n      } else {\n        printCacheStatsCounter.compareAndSet(100, 0);\n      }\n    }\n\n    return timelineMetrics;\n  }","id":11168,"modified_method":"/**\n   * Get metrics for an app grouped by the requested @TemporalInfo which is a\n   * part of the @TimelineAppMetricCacheKey\n   * @param key @TimelineAppMetricCacheKey\n   * @return @org.apache.hadoop.metrics2.sink.timeline.TimelineMetrics\n   */\n  public TimelineMetrics getAppTimelineMetricsFromCache(TimelineAppMetricCacheKey key) throws IllegalArgumentException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Fetching metrics with key: \" + key);\n    }\n\n    // Make sure key is valid\n    validateKey(key);\n\n    Element element = get(key);\n    TimelineMetrics timelineMetrics = new TimelineMetrics();\n    if (element != null && element.getObjectValue() != null) {\n      TimelineMetricsCacheValue value = (TimelineMetricsCacheValue) element.getObjectValue();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Returning value from cache: \" + value);\n      }\n      timelineMetrics = value.getTimelineMetrics();\n    }\n\n    if (LOG.isDebugEnabled()) {\n      // Print stats every 100 calls - Note: Supported in debug mode only\n      if (printCacheStatsCounter.getAndIncrement() == 0) {\n        StatisticsGateway statistics = this.getStatistics();\n        LOG.debug(\"Metrics cache stats => \\n\" +\n          \", Evictions = \" + statistics.cacheEvictedCount() +\n          \", Expired = \" + statistics.cacheExpiredCount() +\n          \", Hits = \" + statistics.cacheHitCount() +\n          \", Misses = \" + statistics.cacheMissCount() +\n          \", Hit ratio = \" + statistics.cacheHitRatio() +\n          \", Puts = \" + statistics.cachePutCount() +\n          \", Size in MB = \" + (statistics.getLocalHeapSizeInBytes() / 1048576));\n      } else {\n        printCacheStatsCounter.compareAndSet(100, 0);\n      }\n    }\n\n    return timelineMetrics;\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * This method is called on a get element from cache call when key is not\n   * found in cache, returns a value for the key to be cached.\n   *\n   * @param key @org.apache.ambari.server.controller.metrics.timeline.cache.TimelineAppMetricCacheKey\n   * @return @org.apache.hadoop.metrics2.sink.timeline.TimelineMetrics\n   * @throws Exception\n   */\n  @Override\n  public Object createEntry(Object key) throws Exception {\n    LOG.debug(\"Creating cache entry since none exists, key = \" + key);\n    TimelineAppMetricCacheKey metricCacheKey = (TimelineAppMetricCacheKey) key;\n\n    TimelineMetrics timelineMetrics = null;\n    try {\n      timelineMetrics = requestHelperForGets.fetchTimelineMetrics(metricCacheKey.getSpec());\n    } catch (IOException io) {\n      LOG.debug(\"Caught IOException on fetching metrics. \" + io.getMessage());\n    }\n\n    TimelineMetricsCacheValue value = null;\n\n    if (timelineMetrics != null && !timelineMetrics.getMetrics().isEmpty()) {\n      Map<String, TimelineMetric> cacheValue =\n        new HashMap<String, TimelineMetric>(timelineMetrics.getMetrics().size());\n      for (TimelineMetric metric : timelineMetrics.getMetrics()) {\n        cacheValue.put(metric.getMetricName(), metric);\n      }\n\n      value = new TimelineMetricsCacheValue(\n        metricCacheKey.getTemporalInfo().getStartTime(),\n        metricCacheKey.getTemporalInfo().getEndTime(),\n        cacheValue, // Null or empty should prompt a refresh\n        Precision.getPrecision(metricCacheKey.getTemporalInfo().getStartTimeMillis(),\n          metricCacheKey.getTemporalInfo().getEndTimeMillis()) //Initial Precision\n      );\n\n      LOG.debug(\"Created cache entry: \" + value);\n    }\n\n    return value;\n  }","id":11169,"modified_method":"/**\n   * This method is called on a get element from cache call when key is not\n   * found in cache, returns a value for the key to be cached.\n   *\n   * @param key @org.apache.ambari.server.controller.metrics.timeline.cache.TimelineAppMetricCacheKey\n   * @return @org.apache.hadoop.metrics2.sink.timeline.TimelineMetrics\n   * @throws Exception\n   */\n  @Override\n  public Object createEntry(Object key) throws Exception {\n    LOG.debug(\"Creating cache entry since none exists, key = \" + key);\n    TimelineAppMetricCacheKey metricCacheKey = (TimelineAppMetricCacheKey) key;\n\n    TimelineMetrics timelineMetrics = null;\n    try {\n      timelineMetrics = requestHelperForGets.fetchTimelineMetrics(metricCacheKey.getSpec());\n    } catch (IOException io) {\n      LOG.debug(\"Caught IOException on fetching metrics. \" + io.getMessage());\n    }\n\n    TimelineMetricsCacheValue value = null;\n\n    if (timelineMetrics != null && !timelineMetrics.getMetrics().isEmpty()) {\n      value = new TimelineMetricsCacheValue(\n        metricCacheKey.getTemporalInfo().getStartTime(),\n        metricCacheKey.getTemporalInfo().getEndTime(),\n        timelineMetrics, // Null or empty should prompt a refresh\n        Precision.getPrecision(metricCacheKey.getTemporalInfo().getStartTimeMillis(),\n          metricCacheKey.getTemporalInfo().getEndTimeMillis()) //Initial Precision\n      );\n\n      LOG.debug(\"Created cache entry: \" + value);\n    }\n\n    return value;\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Update cache with new timeseries data\n   */\n  protected void updateTimelineMetricsInCache(TimelineMetrics newMetrics,\n      TimelineMetricsCacheValue timelineMetricsCacheValue,\n      Long requestedStartTime, Long requestedEndTime, boolean removeAll) {\n\n    Map<String, TimelineMetric> existingTimelineMetricMap = timelineMetricsCacheValue.getTimelineMetrics();\n\n    // NOTE: Metrics names so far are unique, the Map optimization avoids\n    // multiple iterations of the List\n    for (TimelineMetric timelineMetric : newMetrics.getMetrics()) {\n      if (LOG.isTraceEnabled()) {\n        TreeMap<Long, Double> sortedMetrics = new TreeMap<Long, Double>(timelineMetric.getMetricValues());\n\n        LOG.trace(\"New metric: \" + timelineMetric.getMetricName() +\n          \" # \" + timelineMetric.getMetricValues().size() + \", startTime = \" +\n          sortedMetrics.firstKey() + \", endTime = \" + sortedMetrics.lastKey());\n      }\n\n\n      TimelineMetric existingMetric = existingTimelineMetricMap.get(timelineMetric.getMetricName());\n\n      if (existingMetric != null) {\n\n        if(removeAll) {\n          existingMetric.setMetricValues(new TreeMap<Long, Double>());\n        }\n\n        Map<Long, Double> existingMetricValues = existingMetric.getMetricValues();\n        LOG.trace(\"Existing metric: \" + timelineMetric.getMetricName() +\n          \" # \" + existingMetricValues.size());\n\n        Iterator<Map.Entry<Long, Double>> valueIterator = existingMetricValues.entrySet().iterator();\n\n        // Remove old values\n        // Assumption: All return value are millis\n        while (valueIterator.hasNext()) {\n          Map.Entry<Long, Double> metricEntry = valueIterator.next();\n          if (metricEntry.getKey() < requestedStartTime\n              || metricEntry.getKey() > requestedEndTime) {\n            valueIterator.remove();\n          }\n        }\n\n        // Add new ones\n        existingMetricValues.putAll(timelineMetric.getMetricValues());\n\n        if (LOG.isTraceEnabled()) {\n          TreeMap<Long, Double> sortedMetrics = new TreeMap<Long, Double>(existingMetricValues);\n          LOG.trace(\"Merged metric: \" + timelineMetric.getMetricName() + \", \" +\n            \"Final size: \" + existingMetricValues.size() + \", startTime = \" +\n            sortedMetrics.firstKey() + \", endTime = \" + sortedMetrics.lastKey());\n        }\n      } else {\n        existingTimelineMetricMap.put(timelineMetric.getMetricName(), timelineMetric);\n      }\n    }\n  }","id":11170,"modified_method":"/**\n   * Update cache with new timeseries data\n   */\n  protected void updateTimelineMetricsInCache(TimelineMetrics newMetrics,\n      TimelineMetricsCacheValue timelineMetricsCacheValue,\n      Long requestedStartTime, Long requestedEndTime, boolean removeAll) {\n\n    TimelineMetrics existingTimelineMetrics = timelineMetricsCacheValue.getTimelineMetrics();\n\n    // Remove values that do not fit before adding new data\n    updateExistingMetricValues(existingTimelineMetrics, requestedStartTime,\n      requestedEndTime, removeAll);\n\n    if (newMetrics != null && !newMetrics.getMetrics().isEmpty()) {\n      for (TimelineMetric timelineMetric : newMetrics.getMetrics()) {\n        if (LOG.isTraceEnabled()) {\n          TreeMap<Long, Double> sortedMetrics = new TreeMap<Long, Double>(timelineMetric.getMetricValues());\n\n          LOG.trace(\"New metric: \" + timelineMetric.getMetricName() +\n            \" # \" + timelineMetric.getMetricValues().size() + \", startTime = \" +\n            sortedMetrics.firstKey() + \", endTime = \" + sortedMetrics.lastKey());\n        }\n\n        TimelineMetric existingMetric = null;\n\n        for (TimelineMetric metric : existingTimelineMetrics.getMetrics()) {\n          if (metric.equalsExceptTime(timelineMetric)) {\n            existingMetric = metric;\n          }\n        }\n\n        if (existingMetric != null) {\n          // Add new ones\n          existingMetric.getMetricValues().putAll(timelineMetric.getMetricValues());\n\n          if (LOG.isTraceEnabled()) {\n            TreeMap<Long, Double> sortedMetrics = new TreeMap<Long, Double>(existingMetric.getMetricValues());\n            LOG.trace(\"Merged metric: \" + timelineMetric.getMetricName() + \", \" +\n              \"Final size: \" + existingMetric.getMetricValues().size() + \", startTime = \" +\n              sortedMetrics.firstKey() + \", endTime = \" + sortedMetrics.lastKey());\n          }\n        } else {\n          existingTimelineMetrics.getMetrics().add(timelineMetric);\n        }\n      }\n    }\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"private TimelineMetric getSampleTimelineMetric(String metricName) {\n    TimelineMetric metric = new TimelineMetric();\n    metric.setMetricName(metricName);\n    metric.setAppId(\"KAFKA_BROKER\");\n    metric.setInstanceId(\"NULL\");\n    metric.setHostName(\"my.privatehostname.of.average.length\");\n    metric.setTimestamp(System.currentTimeMillis());\n    metric.setStartTime(System.currentTimeMillis());\n    metric.setType(\"LONG\");\n\n    // JSON dser gives a LinkedHashMap\n    TreeMap<Long, Double> valueMap = new TreeMap<>();\n    long now = System.currentTimeMillis();\n    for (int i = 0; i < 25000; i++) {\n      valueMap.put(new Long(now + i), new Double(1.0 + i));\n    }\n\n    metric.setMetricValues(valueMap);\n\n    return metric;\n  }","id":11171,"modified_method":"private TimelineMetric getSampleTimelineMetric(String metricName) {\n    TimelineMetric metric = new TimelineMetric();\n    metric.setMetricName(metricName);\n    metric.setAppId(\"KAFKA_BROKER\");\n    metric.setInstanceId(\"NULL\");\n    metric.setHostName(\"my.privatehostname.of.average.length\");\n    metric.setTimestamp(System.currentTimeMillis());\n    metric.setStartTime(System.currentTimeMillis());\n    metric.setType(\"LONG\");\n\n    // JSON dser gives a LinkedHashMap\n    TreeMap<Long, Double> valueMap = new TreeMap<>();\n    long now = System.currentTimeMillis();\n    for (int i = 0; i < 50000; i++) {\n      valueMap.put(new Long(now + i), new Double(1.0 + i));\n    }\n\n    metric.setMetricValues(valueMap);\n\n    return metric;\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testTimelineMetricCacheSizing() throws Exception {\n    Set<String> metricNames = new HashSet<>();\n    String metric1 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName1\";\n    String metric2 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName2\";\n    String metric3 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName3\";\n    String metric4 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName4\";\n    String metric5 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName5\";\n    String metric6 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName6\";\n\n    metricNames.add(metric1);\n    metricNames.add(metric2);\n    metricNames.add(metric3);\n    metricNames.add(metric4);\n    metricNames.add(metric5);\n    metricNames.add(metric6);\n\n    long now = System.currentTimeMillis();\n    TemporalInfo temporalInfo = new TemporalInfoImpl(now - 1000, now, 15);\n\n    TimelineAppMetricCacheKey key = new TimelineAppMetricCacheKey(\n      metricNames, \"KAFKA_BROKER\", temporalInfo);\n    // Some random spec\n    key.setSpec(\"http://104.196.94.129:6188/ws/v1/timeline/metrics?metricNames=\" +\n      \"jvm.JvmMetrics.MemHeapCommittedM&appId=RESOURCEMANAGER&\" +\n      \"startTime=1439522640000&endTime=1440127440000&precision=hours\");\n\n    Map<String, TimelineMetric> metricMap = new HashMap<>();\n    metricMap.put(metric1, getSampleTimelineMetric(metric1));\n    metricMap.put(metric2, getSampleTimelineMetric(metric2));\n    metricMap.put(metric3, getSampleTimelineMetric(metric3));\n    metricMap.put(metric4, getSampleTimelineMetric(metric4));\n    metricMap.put(metric5, getSampleTimelineMetric(metric5));\n    metricMap.put(metric6, getSampleTimelineMetric(metric6));\n\n    TimelineMetricsCacheValue value = new TimelineMetricsCacheValue(now -\n      1000, now, metricMap, null);\n\n    TimelineMetricsCacheSizeOfEngine customSizeOfEngine = new TimelineMetricsCacheSizeOfEngine();\n\n    long bytesFromReflectionEngine =\n      reflectionSizeOf.deepSizeOf(1000, false, key).getCalculated() +\n      reflectionSizeOf.deepSizeOf(1000, false, value).getCalculated();\n\n    long bytesFromCustomSizeOfEngine = customSizeOfEngine.sizeOf(key, value, null).getCalculated();\n\n    long sampleSizeInMB = bytesFromReflectionEngine / (1024 * 1024);\n    long discrepancyInKB = Math.abs(bytesFromCustomSizeOfEngine - bytesFromReflectionEngine) / 1024;\n\n    Assert.assertTrue(\"Sample size is greater that 10 MB\", sampleSizeInMB > 10);\n    Assert.assertTrue(\"Discrepancy in values is less than 10K\", discrepancyInKB  < 10);\n  }","id":11172,"modified_method":"@Test\n  public void testTimelineMetricCacheSizing() throws Exception {\n    Set<String> metricNames = new HashSet<>();\n    String metric1 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName1\";\n    String metric2 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName2\";\n    String metric3 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName3\";\n    String metric4 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName4\";\n    String metric5 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName5\";\n    String metric6 = \"prefix1.suffix1.suffix2.actualNamePrefix.longMetricName6\";\n\n    metricNames.add(metric1);\n    metricNames.add(metric2);\n    metricNames.add(metric3);\n    metricNames.add(metric4);\n    metricNames.add(metric5);\n    metricNames.add(metric6);\n\n    long now = System.currentTimeMillis();\n    TemporalInfo temporalInfo = new TemporalInfoImpl(now - 1000, now, 15);\n\n    TimelineAppMetricCacheKey key = new TimelineAppMetricCacheKey(\n      metricNames, \"KAFKA_BROKER\", temporalInfo);\n    // Some random spec\n    key.setSpec(\"http://104.196.94.129:6188/ws/v1/timeline/metrics?metricNames=\" +\n      \"jvm.JvmMetrics.MemHeapCommittedM&appId=RESOURCEMANAGER&\" +\n      \"startTime=1439522640000&endTime=1440127440000&precision=hours\");\n\n    TimelineMetrics metrics = new TimelineMetrics();\n    metrics.getMetrics().add(getSampleTimelineMetric(metric1));\n    metrics.getMetrics().add(getSampleTimelineMetric(metric2));\n    metrics.getMetrics().add(getSampleTimelineMetric(metric3));\n    metrics.getMetrics().add(getSampleTimelineMetric(metric4));\n    metrics.getMetrics().add(getSampleTimelineMetric(metric5));\n    metrics.getMetrics().add(getSampleTimelineMetric(metric6));\n\n    TimelineMetricsCacheValue value = new TimelineMetricsCacheValue(now -\n      1000, now, metrics, null);\n\n    TimelineMetricsCacheSizeOfEngine customSizeOfEngine = new TimelineMetricsCacheSizeOfEngine();\n\n    long bytesFromReflectionEngine =\n      reflectionSizeOf.deepSizeOf(1000, false, key).getCalculated() +\n      reflectionSizeOf.deepSizeOf(1000, false, value).getCalculated();\n\n    long bytesFromCustomSizeOfEngine = customSizeOfEngine.sizeOf(key, value, null).getCalculated();\n\n    long sampleSizeInMB = bytesFromReflectionEngine / (1024 * 1024);\n    long discrepancyInKB = Math.abs(bytesFromCustomSizeOfEngine - bytesFromReflectionEngine) / 1024;\n\n    Assert.assertTrue(\"Sample size is greater that 10 MB\", sampleSizeInMB > 10);\n    Assert.assertTrue(\"Discrepancy in values is less than 10K\", discrepancyInKB  < 10);\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testTimelineMetricCacheTimeseriesUpdates() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    expect(configuration.getMetricsRequestConnectTimeoutMillis()).andReturn(10000);\n    expect(configuration.getMetricsRequestReadTimeoutMillis()).andReturn(10000);\n    expect(configuration.getMetricsRequestIntervalReadTimeoutMillis()).andReturn(10000);\n    // Disable buffer fudge factor\n    expect(configuration.getMetricRequestBufferTimeCatchupInterval()).andReturn(0l);\n\n    replay(configuration);\n\n    TimelineMetricCacheEntryFactory factory =\n      createMockBuilder(TimelineMetricCacheEntryFactory.class)\n        .withConstructor(configuration).createMock();\n\n    replay(factory);\n\n    long now = System.currentTimeMillis();\n\n    // Existing values\n\n    final TimelineMetric timelineMetric1 = new TimelineMetric();\n    timelineMetric1.setMetricName(\"cpu_user\");\n    timelineMetric1.setAppId(\"app1\");\n    TreeMap<Long, Double> metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now - 100, 1.0);\n    metricValues.put(now - 200, 2.0);\n    metricValues.put(now - 300, 3.0);\n    timelineMetric1.setMetricValues(metricValues);\n    final TimelineMetric timelineMetric2 = new TimelineMetric();\n    timelineMetric2.setMetricName(\"cpu_nice\");\n    timelineMetric2.setAppId(\"app1\");\n    metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now + 400, 1.0);\n    metricValues.put(now + 500, 2.0);\n    metricValues.put(now + 600, 3.0);\n    timelineMetric2.setMetricValues(metricValues);\n\n    TimelineMetricsCacheValue existingMetricValue = new TimelineMetricsCacheValue(\n      now - 1000, now + 1000,\n      new HashMap<String, TimelineMetric>() {{\n        put(\"cpu_user\", timelineMetric1);\n        put(\"cpu_nice\", timelineMetric2);\n      }}, null);\n\n    // New values\n    TimelineMetrics newMetrics = new TimelineMetrics();\n    TimelineMetric timelineMetric3 = new TimelineMetric();\n    timelineMetric3.setMetricName(\"cpu_user\");\n    timelineMetric3.setAppId(\"app1\");\n    metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now + 1400, 1.0);\n    metricValues.put(now + 1500, 2.0);\n    metricValues.put(now + 1600, 3.0);\n    timelineMetric3.setMetricValues(metricValues);\n    newMetrics.getMetrics().add(timelineMetric3);\n\n    factory.updateTimelineMetricsInCache(newMetrics, existingMetricValue,\n      now, now + 2000,true);\n\n    Assert.assertEquals(2, existingMetricValue.getTimelineMetrics().size());\n    Assert.assertEquals(3, existingMetricValue.getTimelineMetrics().get(\"cpu_user\").getMetricValues().size());\n    Assert.assertEquals(3, existingMetricValue.getTimelineMetrics().get(\"cpu_nice\").getMetricValues().size());\n    Map<Long, Double> newMetricsMap = existingMetricValue.getTimelineMetrics().get(\"cpu_user\").getMetricValues();\n    Iterator<Long> metricKeyIterator = newMetricsMap.keySet().iterator();\n    Assert.assertEquals(now + 1400, metricKeyIterator.next().longValue());\n    Assert.assertEquals(now + 1500, metricKeyIterator.next().longValue());\n    Assert.assertEquals(now + 1600, metricKeyIterator.next().longValue());\n\n    verify(configuration, factory);\n  }","id":11173,"modified_method":"@Test\n  public void testTimelineMetricCacheTimeseriesUpdates() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    expect(configuration.getMetricsRequestConnectTimeoutMillis()).andReturn(10000);\n    expect(configuration.getMetricsRequestReadTimeoutMillis()).andReturn(10000);\n    expect(configuration.getMetricsRequestIntervalReadTimeoutMillis()).andReturn(10000);\n    // Disable buffer fudge factor\n    expect(configuration.getMetricRequestBufferTimeCatchupInterval()).andReturn(0l);\n\n    replay(configuration);\n\n    TimelineMetricCacheEntryFactory factory =\n      createMockBuilder(TimelineMetricCacheEntryFactory.class)\n        .withConstructor(configuration).createMock();\n\n    replay(factory);\n\n    long now = System.currentTimeMillis();\n\n    // Existing values\n\n    final TimelineMetric timelineMetric1 = new TimelineMetric();\n    timelineMetric1.setMetricName(\"cpu_user\");\n    timelineMetric1.setAppId(\"app1\");\n    TreeMap<Long, Double> metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now - 100, 1.0);\n    metricValues.put(now - 200, 2.0);\n    metricValues.put(now - 300, 3.0);\n    timelineMetric1.setMetricValues(metricValues);\n    final TimelineMetric timelineMetric2 = new TimelineMetric();\n    timelineMetric2.setMetricName(\"cpu_nice\");\n    timelineMetric2.setAppId(\"app1\");\n    metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now + 400, 1.0);\n    metricValues.put(now + 500, 2.0);\n    metricValues.put(now + 600, 3.0);\n    timelineMetric2.setMetricValues(metricValues);\n\n    TimelineMetrics existingMetrics = new TimelineMetrics();\n    existingMetrics.getMetrics().add(timelineMetric1);\n    existingMetrics.getMetrics().add(timelineMetric2);\n\n    TimelineMetricsCacheValue existingMetricValue = new TimelineMetricsCacheValue(\n      now - 1000, now + 1000, existingMetrics, null);\n\n    // New values\n    TimelineMetrics newMetrics = new TimelineMetrics();\n    TimelineMetric timelineMetric3 = new TimelineMetric();\n    timelineMetric3.setMetricName(\"cpu_user\");\n    timelineMetric3.setAppId(\"app1\");\n    metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now + 1400, 1.0);\n    metricValues.put(now + 1500, 2.0);\n    metricValues.put(now + 1600, 3.0);\n    timelineMetric3.setMetricValues(metricValues);\n    newMetrics.getMetrics().add(timelineMetric3);\n\n    factory.updateTimelineMetricsInCache(newMetrics, existingMetricValue,\n      now, now + 2000, false);\n\n    Assert.assertEquals(2, existingMetricValue.getTimelineMetrics().getMetrics().size());\n\n    TimelineMetric newMetric1 = null;\n    TimelineMetric newMetric2 = null;\n\n    for (TimelineMetric metric : existingMetricValue.getTimelineMetrics().getMetrics()) {\n      if (metric.getMetricName().equals(\"cpu_user\")) {\n        newMetric1 = metric;\n      }\n      if (metric.getMetricName().equals(\"cpu_nice\")) {\n        newMetric2 = metric;\n      }\n    }\n\n    Assert.assertNotNull(newMetric1);\n    Assert.assertNotNull(newMetric2);\n    Assert.assertEquals(3, newMetric1.getMetricValues().size());\n    Assert.assertEquals(3, newMetric2.getMetricValues().size());\n    Map<Long, Double> newMetricsMap = newMetric1.getMetricValues();\n    Iterator<Long> metricKeyIterator = newMetricsMap.keySet().iterator();\n    Assert.assertEquals(now + 1400, metricKeyIterator.next().longValue());\n    Assert.assertEquals(now + 1500, metricKeyIterator.next().longValue());\n    Assert.assertEquals(now + 1600, metricKeyIterator.next().longValue());\n\n    verify(configuration, factory);\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testTimlineMetricCacheProviderGets() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    expect(configuration.getMetricCacheTTLSeconds()).andReturn(3600);\n    expect(configuration.getMetricCacheIdleSeconds()).andReturn(100);\n    expect(configuration.getMetricsCacheManagerHeapPercent()).andReturn(\"10%\");\n\n    replay(configuration);\n\n    final long now = System.currentTimeMillis();\n    Map<String, TimelineMetric> valueMap = new HashMap<String, TimelineMetric>();\n    TimelineMetric timelineMetric = new TimelineMetric();\n    timelineMetric.setMetricName(\"cpu_user\");\n    timelineMetric.setAppId(\"app1\");\n    TreeMap<Long, Double> metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now + 100, 1.0);\n    metricValues.put(now + 200, 2.0);\n    metricValues.put(now + 300, 3.0);\n    timelineMetric.setMetricValues(metricValues);\n    valueMap.put(\"cpu_user\", timelineMetric);\n\n    TimelineMetricCacheEntryFactory cacheEntryFactory = createMock(TimelineMetricCacheEntryFactory.class);\n\n    TimelineAppMetricCacheKey queryKey = new TimelineAppMetricCacheKey(\n      Collections.singleton(\"cpu_user\"),\n      \"app1\",\n      new TemporalInfoImpl(now, now + 1000, 1)\n    );\n    TimelineMetricsCacheValue value = new TimelineMetricsCacheValue(now, now + 1000, valueMap, null);\n    TimelineAppMetricCacheKey testKey = new TimelineAppMetricCacheKey(\n      Collections.singleton(\"cpu_user\"),\n      \"app1\",\n      new TemporalInfoImpl(now, now + 2000, 1)\n    );\n\n    expect(cacheEntryFactory.createEntry(anyObject())).andReturn(value);\n    cacheEntryFactory.updateEntryValue(testKey, value);\n    expectLastCall().once();\n\n    replay(cacheEntryFactory);\n\n    TimelineMetricCacheProvider cacheProvider = getMetricCacheProvider(configuration, cacheEntryFactory);\n    TimelineMetricCache cache = cacheProvider.getTimelineMetricsCache();\n\n    // call to get\n    TimelineMetrics metrics = cache.getAppTimelineMetricsFromCache(queryKey);\n    List<TimelineMetric> metricsList = metrics.getMetrics();\n    Assert.assertEquals(1, metricsList.size());\n    TimelineMetric metric = metricsList.iterator().next();\n    Assert.assertEquals(\"cpu_user\", metric.getMetricName());\n    Assert.assertEquals(\"app1\", metric.getAppId());\n    Assert.assertSame(metricValues, metric.getMetricValues());\n\n    // call to update with new key\n    metrics = cache.getAppTimelineMetricsFromCache(testKey);\n    metricsList = metrics.getMetrics();\n    Assert.assertEquals(1, metricsList.size());\n    Assert.assertEquals(\"cpu_user\", metric.getMetricName());\n    Assert.assertEquals(\"app1\", metric.getAppId());\n    Assert.assertSame(metricValues, metric.getMetricValues());\n\n    verify(configuration, cacheEntryFactory);\n  }","id":11174,"modified_method":"@Test\n  public void testTimlineMetricCacheProviderGets() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    expect(configuration.getMetricCacheTTLSeconds()).andReturn(3600);\n    expect(configuration.getMetricCacheIdleSeconds()).andReturn(100);\n    expect(configuration.getMetricsCacheManagerHeapPercent()).andReturn(\"10%\");\n\n    replay(configuration);\n\n    final long now = System.currentTimeMillis();\n\n    TimelineMetrics metrics = new TimelineMetrics();\n\n    TimelineMetric timelineMetric = new TimelineMetric();\n    timelineMetric.setMetricName(\"cpu_user\");\n    timelineMetric.setAppId(\"app1\");\n    TreeMap<Long, Double> metricValues = new TreeMap<Long, Double>();\n    metricValues.put(now + 100, 1.0);\n    metricValues.put(now + 200, 2.0);\n    metricValues.put(now + 300, 3.0);\n    timelineMetric.setMetricValues(metricValues);\n\n    metrics.getMetrics().add(timelineMetric);\n\n    TimelineMetricCacheEntryFactory cacheEntryFactory = createMock(TimelineMetricCacheEntryFactory.class);\n\n    TimelineAppMetricCacheKey queryKey = new TimelineAppMetricCacheKey(\n      Collections.singleton(\"cpu_user\"),\n      \"app1\",\n      new TemporalInfoImpl(now, now + 1000, 1)\n    );\n    TimelineMetricsCacheValue value = new TimelineMetricsCacheValue(now, now + 1000, metrics, null);\n    TimelineAppMetricCacheKey testKey = new TimelineAppMetricCacheKey(\n      Collections.singleton(\"cpu_user\"),\n      \"app1\",\n      new TemporalInfoImpl(now, now + 2000, 1)\n    );\n\n    expect(cacheEntryFactory.createEntry(anyObject())).andReturn(value);\n    cacheEntryFactory.updateEntryValue(testKey, value);\n    expectLastCall().once();\n\n    replay(cacheEntryFactory);\n\n    TimelineMetricCacheProvider cacheProvider = getMetricCacheProvider(configuration, cacheEntryFactory);\n    TimelineMetricCache cache = cacheProvider.getTimelineMetricsCache();\n\n    // call to get\n    metrics = cache.getAppTimelineMetricsFromCache(queryKey);\n    List<TimelineMetric> metricsList = metrics.getMetrics();\n    Assert.assertEquals(1, metricsList.size());\n    TimelineMetric metric = metricsList.iterator().next();\n    Assert.assertEquals(\"cpu_user\", metric.getMetricName());\n    Assert.assertEquals(\"app1\", metric.getAppId());\n    Assert.assertSame(metricValues, metric.getMetricValues());\n\n    // call to update with new key\n    metrics = cache.getAppTimelineMetricsFromCache(testKey);\n    metricsList = metrics.getMetrics();\n    Assert.assertEquals(1, metricsList.size());\n    Assert.assertEquals(\"cpu_user\", metric.getMetricName());\n    Assert.assertEquals(\"app1\", metric.getAppId());\n    Assert.assertSame(metricValues, metric.getMetricValues());\n\n    verify(configuration, cacheEntryFactory);\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"private long getTimelineMetricCacheValueSize(TimelineMetricsCacheValue value) {\n    long size = 16; // startTime + endTime\n    Map<String, TimelineMetric> metrics = value.getTimelineMetrics();\n    size += 8; // Object reference\n\n    if (metrics != null) {\n      for (Map.Entry<String, TimelineMetric> metricEntry : metrics.entrySet()) {\n        size += reflectionSizeOf.sizeOf(metricEntry.getKey());\n\n        TimelineMetric metric = metricEntry.getValue();\n\n        if (timelineMetricPrimitivesApproximation == 0) {\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getMetricName());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getAppId());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getHostName());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getInstanceId());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getTimestamp());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getStartTime());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getType());\n          timelineMetricPrimitivesApproximation += 8; // Object overhead\n\n          LOG.debug(\"timelineMetricPrimitivesApproximation bytes = \" + timelineMetricPrimitivesApproximation);\n        }\n        size += timelineMetricPrimitivesApproximation;\n\n        Map<Long, Double> metricValues = metric.getMetricValues();\n        if (metricValues != null && !metricValues.isEmpty()) {\n          // Numeric wrapper: 12 bytes + 8 bytes Data type + 4 bytes alignment = 48 (Long, Double)\n          // Tree Map: 12 bytes for header + 20 bytes for 5 object fields : pointers + 1 byte for flag = 40\n          LOG.debug(\"Size of metric value: \" + (48 + 40) * metricValues.size());\n          size += (48 + 40) * metricValues.size(); // Treemap size is O(1)\n        }\n      }\n      LOG.debug(\"Total Size of metric values in cache: \" + size);\n    }\n\n    return size;\n  }","id":11175,"modified_method":"private long getTimelineMetricCacheValueSize(TimelineMetricsCacheValue value) {\n    long size = 16; // startTime + endTime\n    TimelineMetrics metrics = value.getTimelineMetrics();\n    size += 8; // Object reference\n\n    if (metrics != null) {\n      for (TimelineMetric metric : metrics.getMetrics()) {\n\n        if (timelineMetricPrimitivesApproximation == 0) {\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getMetricName());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getAppId());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getHostName());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getInstanceId());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getTimestamp());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getStartTime());\n          timelineMetricPrimitivesApproximation += reflectionSizeOf.sizeOf(metric.getType());\n          timelineMetricPrimitivesApproximation += 8; // Object overhead\n\n          LOG.debug(\"timelineMetricPrimitivesApproximation bytes = \" + timelineMetricPrimitivesApproximation);\n        }\n        size += timelineMetricPrimitivesApproximation;\n\n        Map<Long, Double> metricValues = metric.getMetricValues();\n        if (metricValues != null && !metricValues.isEmpty()) {\n          // Numeric wrapper: 12 bytes + 8 bytes Data type + 4 bytes alignment = 48 (Long, Double)\n          // Tree Map: 12 bytes for header + 20 bytes for 5 object fields : pointers + 1 byte for flag = 40\n          LOG.debug(\"Size of metric value: \" + (48 + 40) * metricValues.size());\n          size += (48 + 40) * metricValues.size(); // Treemap size is O(1)\n        }\n      }\n      LOG.debug(\"Total Size of metric values in cache: \" + size);\n    }\n\n    return size;\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"public TimelineMetricsCacheValue(Long startTime, Long endTime, Map<String, TimelineMetric> timelineMetrics, Precision precision) {\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.timelineMetrics = timelineMetrics;\n    this.precision = precision;\n  }","id":11176,"modified_method":"public TimelineMetricsCacheValue(Long startTime, Long endTime, TimelineMetrics timelineMetrics, Precision precision) {\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.timelineMetrics = timelineMetrics;\n    this.precision = precision;\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Map of metricName to metric values. Works on the assumption that metric\n   * name is unique\n   */\n  public void setTimelineMetrics(Map<String, TimelineMetric> timelineMetrics) {\n    this.timelineMetrics = timelineMetrics;\n  }","id":11177,"modified_method":"/**\n   * Map of metricName to metric values. Works on the assumption that metric\n   * name is unique\n   */\n  public void setTimelineMetrics(TimelineMetrics timelineMetrics) {\n    this.timelineMetrics = timelineMetrics;\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"TimelineMetricsCacheValue {\" +\n      \"metricNames = \" + timelineMetrics.keySet() +\n      \", startTime = \" + new Date(getMillisecondsTime(startTime)) +\n      \", endTime = \" + new Date(getMillisecondsTime(endTime)) +\n      \", precision = \" + precision +\n      \", timelineMetrics =\");\n\n    for (TimelineMetric metric : timelineMetrics.values()) {\n      sb.append(\" { \");\n      sb.append(metric.getMetricName());\n      sb.append(\" # \");\n      sb.append(metric.getMetricValues().size());\n      sb.append(\" }\");\n    }\n    sb.append(\"}\");\n    return sb.toString();\n  }","id":11178,"modified_method":"@Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"TimelineMetricsCacheValue {\" +\n      \", startTime = \" + new Date(getMillisecondsTime(startTime)) +\n      \", endTime = \" + new Date(getMillisecondsTime(endTime)) +\n      \", precision = \" + precision +\n      \", timelineMetrics =\");\n\n    for (TimelineMetric metric : timelineMetrics.getMetrics()) {\n      sb.append(\" { \");\n      sb.append(metric.getMetricName());\n      sb.append(\", \");\n      sb.append(metric.getHostName());\n      sb.append(\" # \");\n      sb.append(metric.getMetricValues().size());\n      sb.append(\" }\");\n    }\n\n    sb.append(\"}\");\n    return sb.toString();\n  }","commit_id":"db12ed3b0641093d91e2cb8edd08a947fa66269b","url":"https://github.com/apache/ambari"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jPanel1 = new javax.swing.JPanel();\n        tabbedPane = new javax.swing.JTabbedPane();\n\n        tabbedPane.setPreferredSize(new java.awt.Dimension(420, 200));\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(tabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 691, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addComponent(tabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 231, Short.MAX_VALUE)\n                .addGap(0, 0, 0))\n        );\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(0, 0, 0)\n                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addGap(0, 0, 0))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n    }","id":11179,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jPanel1 = new javax.swing.JPanel();\n        tabbedPane = new javax.swing.JTabbedPane();\n        closeButton = new javax.swing.JButton();\n\n        tabbedPane.setPreferredSize(new java.awt.Dimension(420, 200));\n\n        org.openide.awt.Mnemonics.setLocalizedText(closeButton, org.openide.util.NbBundle.getMessage(CaseInformationPanel.class, \"CaseInformationPanel.closeButton.text\")); // NOI18N\n        closeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                closeButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(tabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 709, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(closeButton)\n                .addGap(5, 5, 5))\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addComponent(tabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 223, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(closeButton)\n                .addGap(5, 5, 5))\n        );\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(0, 0, 0)\n                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addGap(0, 0, 0))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n    }","commit_id":"3d7b40ca98591304e539c5224b32ebca9a9ae031","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Pop-up the Case Properties Form window where user can change the case\n     * properties (example: update case name and remove the image from the case)\n     */\n    @Override\n    public void performAction() {\n        if (popUpWindow == null) {\n            // create the popUp window for it\n            String title = NbBundle.getMessage(this.getClass(), \"CasePropertiesAction.window.title\");\n            final JFrame frame = new JFrame(title);\n            popUpWindow = new JDialog(frame, title, false);\n            try {\n\n                CaseInformationPanel caseInformationPanel = new CaseInformationPanel();\n\n                popUpWindow.add(caseInformationPanel);\n                popUpWindow.setResizable(true);\n                popUpWindow.pack();\n\n                // set the location of the popUp Window on the center of the screen\n                Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n                double w = popUpWindow.getSize().getWidth();\n                double h = popUpWindow.getSize().getHeight();\n                popUpWindow.setLocation((int) ((screenDimension.getWidth() - w) / 2), (int) ((screenDimension.getHeight() - h) / 2));\n\n                popUpWindow.setVisible(true);\n            } catch (Exception ex) {\n                Logger.getLogger(CasePropertiesAction.class.getName()).log(Level.WARNING, \"Error displaying Case Properties window.\", ex); //NON-NLS\n            }\n        }\n        popUpWindow.setVisible(true);\n        popUpWindow.toFront();\n    }","id":11180,"modified_method":"/**\n     * Pop-up the Case Properties Form window where user can change the case\n     * properties (example: update case name and remove the image from the case)\n     */\n    @Override\n    public void performAction() {\n        if (popUpWindow == null) {\n            // create the popUp window for it\n            String title = NbBundle.getMessage(this.getClass(), \"CasePropertiesAction.window.title\");\n            final JFrame frame = new JFrame(title);\n            popUpWindow = new JDialog(frame, title, false);\n            try {\n\n                CaseInformationPanel caseInformationPanel = new CaseInformationPanel();\n                caseInformationPanel.addCloseButtonAction((ActionEvent e) -> {\n                    popUpWindow.dispose();\n                });\n\n                popUpWindow.add(caseInformationPanel);\n                popUpWindow.setResizable(true);\n                popUpWindow.pack();\n\n                // set the location of the popUp Window on the center of the screen\n                Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n                double w = popUpWindow.getSize().getWidth();\n                double h = popUpWindow.getSize().getHeight();\n                popUpWindow.setLocation((int) ((screenDimension.getWidth() - w) / 2), (int) ((screenDimension.getHeight() - h) / 2));\n\n                popUpWindow.setVisible(true);\n            } catch (Exception ex) {\n                Logger.getLogger(CasePropertiesAction.class.getName()).log(Level.WARNING, \"Error displaying Case Properties window.\", ex); //NON-NLS\n            }\n        }\n        popUpWindow.setVisible(true);\n        popUpWindow.toFront();\n    }","commit_id":"3d7b40ca98591304e539c5224b32ebca9a9ae031","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        timeGroup = new javax.swing.ButtonGroup();\n        modulesScrollPane = new javax.swing.JScrollPane();\n        modulesTable = new javax.swing.JTable();\n        jPanel1 = new javax.swing.JPanel();\n        globalSettingsButton = new javax.swing.JButton();\n        jSeparator2 = new javax.swing.JSeparator();\n        descriptionLabel = new javax.swing.JLabel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        ingestSettingsPanel = new javax.swing.JPanel();\n        jButtonSelectAll = new javax.swing.JButton();\n        jButtonDeselectAll = new javax.swing.JButton();\n        processUnallocCheckbox = new javax.swing.JCheckBox();\n        pastJobsButton = new javax.swing.JButton();\n\n        setMaximumSize(new java.awt.Dimension(5750, 3000));\n        setMinimumSize(new java.awt.Dimension(0, 0));\n        setPreferredSize(new java.awt.Dimension(625, 450));\n\n        modulesScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        modulesScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));\n        modulesScrollPane.setPreferredSize(new java.awt.Dimension(160, 160));\n\n        modulesTable.setBackground(new java.awt.Color(240, 240, 240));\n        modulesTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        modulesTable.setShowHorizontalLines(false);\n        modulesTable.setShowVerticalLines(false);\n        modulesScrollPane.setViewportView(modulesTable);\n\n        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        jPanel1.setPreferredSize(new java.awt.Dimension(338, 257));\n\n        globalSettingsButton.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.text\")); // NOI18N\n        globalSettingsButton.setActionCommand(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.actionCommand\")); // NOI18N\n        globalSettingsButton.setEnabled(false);\n        globalSettingsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                globalSettingsButtonActionPerformed(evt);\n            }\n        });\n\n        descriptionLabel.setText(\"DO NOT REMOVE. This dummy text is used to anchor the inner panel's size to the outer panel, while still being expandable. Without this the expandability behavior doesn't work well. This text will never be shown, as it would only be shown when no module is selected (which is not possible).\");\n\n        jScrollPane1.setBorder(null);\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(250, 180));\n\n        ingestSettingsPanel.setMinimumSize(new java.awt.Dimension(0, 300));\n        ingestSettingsPanel.setLayout(new javax.swing.BoxLayout(ingestSettingsPanel, javax.swing.BoxLayout.PAGE_AXIS));\n        jScrollPane1.setViewportView(ingestSettingsPanel);\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.TRAILING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 337, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(globalSettingsButton)))\n                .addContainerGap())\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 347, Short.MAX_VALUE)\n                .addGap(18, 18, 18)\n                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(8, 8, 8)\n                .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(globalSettingsButton)\n                .addGap(8, 8, 8))\n        );\n\n        jButtonSelectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonSelectAll.text\")); // NOI18N\n        jButtonSelectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonSelectAllActionPerformed(evt);\n            }\n        });\n\n        jButtonDeselectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonDeselectAll.text\")); // NOI18N\n        jButtonDeselectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonDeselectAllActionPerformed(evt);\n            }\n        });\n\n        processUnallocCheckbox.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.text\")); // NOI18N\n        processUnallocCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.toolTipText\")); // NOI18N\n        processUnallocCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                processUnallocCheckboxActionPerformed(evt);\n            }\n        });\n\n        pastJobsButton.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.pastJobsButton.text\")); // NOI18N\n        pastJobsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                pastJobsButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jButtonSelectAll, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(jButtonDeselectAll))\n                    .addComponent(pastJobsButton)\n                    .addComponent(processUnallocCheckbox)\n                    .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 261, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 359, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jButtonSelectAll)\n                            .addComponent(jButtonDeselectAll))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(pastJobsButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(processUnallocCheckbox, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE)\n                        .addContainerGap())))\n        );\n    }","id":11181,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        timeGroup = new javax.swing.ButtonGroup();\n        modulesScrollPane = new javax.swing.JScrollPane();\n        modulesTable = new javax.swing.JTable();\n        jPanel1 = new javax.swing.JPanel();\n        globalSettingsButton = new javax.swing.JButton();\n        jSeparator2 = new javax.swing.JSeparator();\n        descriptionLabel = new javax.swing.JLabel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        ingestSettingsPanel = new javax.swing.JPanel();\n        jButtonSelectAll = new javax.swing.JButton();\n        jButtonDeselectAll = new javax.swing.JButton();\n        processUnallocCheckbox = new javax.swing.JCheckBox();\n        pastJobsButton = new javax.swing.JButton();\n\n        setMaximumSize(new java.awt.Dimension(5750, 3000));\n        setMinimumSize(new java.awt.Dimension(0, 0));\n        setPreferredSize(new java.awt.Dimension(625, 450));\n\n        modulesScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        modulesScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));\n        modulesScrollPane.setPreferredSize(new java.awt.Dimension(160, 160));\n\n        modulesTable.setBackground(new java.awt.Color(240, 240, 240));\n        modulesTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        modulesTable.setShowHorizontalLines(false);\n        modulesTable.setShowVerticalLines(false);\n        modulesScrollPane.setViewportView(modulesTable);\n\n        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        jPanel1.setPreferredSize(new java.awt.Dimension(338, 257));\n\n        globalSettingsButton.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.text\")); // NOI18N\n        globalSettingsButton.setActionCommand(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.actionCommand\")); // NOI18N\n        globalSettingsButton.setEnabled(false);\n        globalSettingsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                globalSettingsButtonActionPerformed(evt);\n            }\n        });\n\n        descriptionLabel.setText(\"DO NOT REMOVE. This dummy text is used to anchor the inner panel's size to the outer panel, while still being expandable. Without this the expandability behavior doesn't work well. This text will never be shown, as it would only be shown when no module is selected (which is not possible).\");\n\n        jScrollPane1.setBorder(null);\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(250, 180));\n\n        ingestSettingsPanel.setMinimumSize(new java.awt.Dimension(0, 300));\n        ingestSettingsPanel.setLayout(new javax.swing.BoxLayout(ingestSettingsPanel, javax.swing.BoxLayout.PAGE_AXIS));\n        jScrollPane1.setViewportView(ingestSettingsPanel);\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.TRAILING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 321, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(globalSettingsButton)))\n                .addContainerGap())\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 330, Short.MAX_VALUE)\n                .addGap(18, 18, 18)\n                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(8, 8, 8)\n                .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(globalSettingsButton)\n                .addGap(8, 8, 8))\n        );\n\n        jButtonSelectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonSelectAll.text\")); // NOI18N\n        jButtonSelectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonSelectAllActionPerformed(evt);\n            }\n        });\n\n        jButtonDeselectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonDeselectAll.text\")); // NOI18N\n        jButtonDeselectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonDeselectAllActionPerformed(evt);\n            }\n        });\n\n        processUnallocCheckbox.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.text\")); // NOI18N\n        processUnallocCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.toolTipText\")); // NOI18N\n        processUnallocCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                processUnallocCheckboxActionPerformed(evt);\n            }\n        });\n\n        pastJobsButton.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.pastJobsButton.text\")); // NOI18N\n        pastJobsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                pastJobsButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 256, Short.MAX_VALUE)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(processUnallocCheckbox)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                                    .addComponent(jButtonSelectAll, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                    .addComponent(pastJobsButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                                .addGap(5, 5, 5)\n                                .addComponent(jButtonDeselectAll)))\n                        .addGap(0, 0, Short.MAX_VALUE)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 343, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jButtonSelectAll)\n                            .addComponent(jButtonDeselectAll))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(pastJobsButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(processUnallocCheckbox, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 428, Short.MAX_VALUE)\n                        .addContainerGap())))\n        );\n    }","commit_id":"3d7b40ca98591304e539c5224b32ebca9a9ae031","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public CardDimensions(double scaleFactor) {\n\t\tframeHeight = (int)(FRAME_MAX_HEIGHT * scaleFactor);\n\t\tframeWidth = (int)(FRAME_MAX_WIDTH * scaleFactor);\n\t\tsymbolHeight = (int)(SYMBOL_MAX_HEIGHT * scaleFactor);\n\t\tsymbolWidth = (int)(SYMBOL_MAX_WIDTH * scaleFactor);\n\t\tcontentXOffset = (int)(CONTENT_MAX_XOFFSET * scaleFactor);\n\t\tnameYOffset = (int)(NAME_MAX_YOFFSET * scaleFactor);\n\t\ttypeYOffset = (int)(TYPE_MAX_YOFFSET * scaleFactor);\n\t\ttextYOffset = (int)(TEXT_MAX_YOFFSET * scaleFactor);\n\t\ttextWidth = (int)(TEXT_MAX_WIDTH * scaleFactor);\n\t\ttextHeight = (int)(TEXT_MAX_HEIGHT * scaleFactor);\n\t\tpowBoxTextTop = (int)(POWBOX_MAX_TOP * scaleFactor);\n\t\tpowBoxTextLeft = (int)(POWBOX_MAX_LEFT * scaleFactor);\n\t\tnameFontSize = Math.max(9, (int)(NAME_FONT_MAX_SIZE * scaleFactor));\n\t}","id":11182,"modified_method":"public CardDimensions(double scaleFactor) {\n\t\tframeHeight = (int)(FRAME_MAX_HEIGHT * scaleFactor);\n\t\tframeWidth = (int)(FRAME_MAX_WIDTH * scaleFactor);\n\t\tsymbolHeight = (int)(SYMBOL_MAX_HEIGHT * scaleFactor);\n\t\tsymbolWidth = (int)(SYMBOL_MAX_WIDTH * scaleFactor);\n\t\tcontentXOffset = (int)(CONTENT_MAX_XOFFSET * scaleFactor);\n\t\tnameYOffset = (int)(NAME_MAX_YOFFSET * scaleFactor);\n\t\ttypeYOffset = (int)(TYPE_MAX_YOFFSET * scaleFactor);\n\t\ttextYOffset = (int)(TEXT_MAX_YOFFSET * scaleFactor);\n\t\ttextWidth = (int)(TEXT_MAX_WIDTH * scaleFactor);\n\t\ttextHeight = (int)(TEXT_MAX_HEIGHT * scaleFactor);\n\t\tpowBoxTextTop = (int)(POWBOX_TEXT_MAX_TOP * scaleFactor);\n\t\tpowBoxTextLeft = (int)(POWBOX_TEXT_MAX_LEFT * scaleFactor);\n\t\tnameFontSize = Math.max(9, (int)(NAME_FONT_MAX_SIZE * scaleFactor));\n\t}","commit_id":"4d5c30d06c7dfdc149c71078549f2d77a99aec0e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic void processCallback(ClientCallback callback) {\n\t\tif (callback.getMethod().equals(\"startGame\")) {\n\t\t\tUUID[] data = (UUID[]) callback.getData();\n\t\t\tgameStarted(data[0], data[1]);\n\t\t}\n\t\telse if (callback.getMethod().equals(\"replayGame\")) {\n\t\t\treplayGame();\n\t\t}\n\t\telse if (callback.getMethod().equals(\"watchGame\")) {\n\t\t\twatchGame((UUID) callback.getData());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"chatMessage\")) {\n\t\t\tChatMessage message = (ChatMessage) callback.getData();\n\t\t\tsession.getChats().get(message.getChatId()).receiveMessage(message.getMessage());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"replayInit\")) {\n\t\t\tsession.getGame().init((GameView) callback.getData());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"replayDone\")) {\n\t\t\tsession.getGame().modalMessage((String) callback.getData());\n\t\t\tsession.getGame().hideGame();\n\t\t}\n\t\telse if (callback.getMethod().equals(\"replayUpdate\")) {\n\t\t\tsession.getGame().updateGame((GameView) callback.getData());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameInit\")) {\n\t\t\tsession.getGame().init((GameView) callback.getData());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameUpdate\")) {\n\t\t\tsession.getGame().updateGame((GameView) callback.getData());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameInform\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().inform(message.getMessage(), null, message.getGameView());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameOver\")) {\n\t\t\tsession.getGame().modalMessage((String) callback.getData());\n\t\t\tsession.getGame().hideGame();\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameAsk\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().updateGame(message.getGameView());\n\t\t\tsession.getGame().ask(message.getMessage());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameTarget\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tif (message.isFlag()) {\n\t\t\t\tsession.getGame().inform(message.getMessage(), message.getCardsView(), message.getGameView());\n\t\t\t} else {\n\t\t\t\tsession.getGame().cancel(message.getMessage(), message.getCardsView(), message.getGameView());\n\t\t\t}\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameSelect\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().select(message.getMessage(), message.getGameView());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameChooseAbility\")) {\n\t\t\tsession.getGame().pickAbility((AbilityPickerView) callback.getData());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameChoose\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().getChoice(message.getMessage(), message.getStrings());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gamePlayMana\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().playMana(message.getMessage(), message.getGameView());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gamePlayXMana\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().playXMana(message.getMessage(), message.getGameView());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameSelectAmount\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().getAmount(message.getMin(), message.getMax());\n\t\t}\n\t\telse if (callback.getMethod().equals(\"gameReveal\")) {\n\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\tsession.getGame().revealCards(message.getMessage(), message.getCardsView());\n\t\t}\n\t}","id":11183,"modified_method":"@Override\n\tpublic synchronized void processCallback(ClientCallback callback) {\n\t\tif (callback.getMessageId() > messageId) {\n\t\t\tmessageId = callback.getMessageId();\n\t\t\tlogger.info(callback.getMessageId() + \" - \" + callback.getMethod());\n\t\t\tif (callback.getMethod().equals(\"startGame\")) {\n\t\t\t\tUUID[] data = (UUID[]) callback.getData();\n\t\t\t\tgameStarted(data[0], data[1]);\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"replayGame\")) {\n\t\t\t\treplayGame();\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"watchGame\")) {\n\t\t\t\twatchGame((UUID) callback.getData());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"chatMessage\")) {\n\t\t\t\tChatMessage message = (ChatMessage) callback.getData();\n\t\t\t\tsession.getChats().get(message.getChatId()).receiveMessage(message.getMessage());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"replayInit\")) {\n\t\t\t\tsession.getGame().init((GameView) callback.getData());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"replayDone\")) {\n\t\t\t\tsession.getGame().modalMessage((String) callback.getData());\n\t\t\t\tsession.getGame().hideGame();\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"replayUpdate\")) {\n\t\t\t\tsession.getGame().updateGame((GameView) callback.getData());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameInit\")) {\n\t\t\t\tsession.getGame().init((GameView) callback.getData());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameUpdate\")) {\n\t\t\t\tsession.getGame().updateGame((GameView) callback.getData());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameInform\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().inform(message.getMessage(), null, message.getGameView());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameOver\")) {\n\t\t\t\tsession.getGame().modalMessage((String) callback.getData());\n\t\t\t\tsession.getGame().hideGame();\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameAsk\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().updateGame(message.getGameView());\n\t\t\t\tsession.getGame().ask(message.getMessage());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameTarget\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tif (message.isFlag()) {\n\t\t\t\t\tsession.getGame().inform(message.getMessage(), message.getCardsView(), message.getGameView());\n\t\t\t\t} else {\n\t\t\t\t\tsession.getGame().cancel(message.getMessage(), message.getCardsView(), message.getGameView());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameSelect\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().select(message.getMessage(), message.getGameView());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameChooseAbility\")) {\n\t\t\t\tsession.getGame().pickAbility((AbilityPickerView) callback.getData());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameChoose\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().getChoice(message.getMessage(), message.getStrings());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gamePlayMana\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().playMana(message.getMessage(), message.getGameView());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gamePlayXMana\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().playXMana(message.getMessage(), message.getGameView());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameSelectAmount\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().getAmount(message.getMin(), message.getMax(), message.getMessage());\n\t\t\t}\n\t\t\telse if (callback.getMethod().equals(\"gameReveal\")) {\n\t\t\t\tGameClientMessage message = (GameClientMessage) callback.getData();\n\t\t\t\tsession.getGame().revealCards(message.getMessage(), message.getCardsView());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warning(\"message out of sequence - ignoring\");\n\t\t}\n\t}","commit_id":"4d5c30d06c7dfdc149c71078549f2d77a99aec0e","url":"https://github.com/magefree/mage"},{"original_method":"public void getAmount(int min, int max) {\n\t\tPickNumberDialog pickNumber = new PickNumberDialog();\n\t\tpickNumber.showDialog(min, max);\n\t\tif (pickNumber.isCancel())\n\t\t\tsession.sendPlayerBoolean(gameId, false);\n\t\telse\n\t\t\tsession.sendPlayerInteger(gameId, pickNumber.getAmount());\n\t}","id":11184,"modified_method":"public void getAmount(int min, int max, String message) {\n\t\tpickNumber.showDialog(min, max, message);\n\t\tif (pickNumber.isCancel())\n\t\t\tsession.sendPlayerBoolean(gameId, false);\n\t\telse\n\t\t\tsession.sendPlayerInteger(gameId, pickNumber.getAmount());\n\t}","commit_id":"4d5c30d06c7dfdc149c71078549f2d77a99aec0e","url":"https://github.com/magefree/mage"},{"original_method":"public synchronized void init(GameView game) {\n\t\tcombat.init(gameId, bigCard);\n\t\tMageFrame.getDesktop().add(combat, JLayeredPane.POPUP_LAYER);\n\t\tcombat.setLocation(500, 300);\n\t\tthis.players.clear();\n\t\tthis.pnlBattlefield.removeAll();\n\t\t//arrange players in a circle with the session player at the bottom left\n\t\tint numSeats = game.getPlayers().size();\n\t\tint numColumns = (numSeats + 1) / 2;\n\t\tboolean oddNumber = (numColumns > 1 && numSeats % 2 == 1);\n\t\tint col = 0;\n\t\tint row = 1;\n\t\tint playerSeat = 0;\n\t\tfor (PlayerView player: game.getPlayers()) {\n\t\t\tif (playerId.equals(player.getPlayerId()))\n\t\t\t\tbreak;\n\t\t\tplayerSeat++;\n\t\t}\n\t\tPlayerView player = game.getPlayers().get(playerSeat);\n\t\tPlayAreaPanel sessionPlayer = new PlayAreaPanel(player, bigCard, gameId);\n\t\tplayers.put(player.getPlayerId(), sessionPlayer);\n\t\tGridBagConstraints c = new GridBagConstraints();\n\t\tc.fill = GridBagConstraints.BOTH;\n\t\tc.weightx = 0.5;\n\t\tc.weighty = 0.5;\n\t\tif (oddNumber)\n\t\t\tc.gridwidth = 2;\n\t\tc.gridx = col;\n\t\tc.gridy = row;\n\t\tthis.pnlBattlefield.add(sessionPlayer, c);\n\t\tsessionPlayer.setVisible(true);\n\t\tif (oddNumber)\n\t\t\tcol++;\n\t\tint playerNum = playerSeat + 1;\n\t\twhile (true) {\n\t\t\tif (row == 1)\n\t\t\t\tcol++;\n\t\t\telse\n\t\t\t\tcol--;\n\t\t\tif (col >= numColumns) {\n\t\t\t\trow = 0;\n\t\t\t\tcol = numColumns - 1;\n\t\t\t}\n\t\t\tplayer = game.getPlayers().get(playerNum);\n\t\t\tPlayAreaPanel playerPanel = new PlayAreaPanel(player, bigCard, gameId);\n\t\t\tplayers.put(player.getPlayerId(), playerPanel);\n\t\t\tc = new GridBagConstraints();\n\t\t\tc.fill = GridBagConstraints.BOTH;\n\t\t\tc.weightx = 0.5;\n\t\t\tc.weighty = 0.5;\n\t\t\tc.gridx = col;\n\t\t\tc.gridy = row;\n\t\t\tthis.pnlBattlefield.add(playerPanel, c);\n\t\t\tplayerPanel.setVisible(true);\n\t\t\tplayerNum++;\n\t\t\tif (playerNum >= numSeats)\n\t\t\t\tplayerNum = 0;\n\t\t\tif (playerNum == playerSeat)\n\t\t\t\tbreak;\n\t\t}\n\t\tupdateGame(game);\n\t}","id":11185,"modified_method":"public synchronized void init(GameView game) {\n\t\tcombat.init(gameId, bigCard);\n\t\tMageFrame.getDesktop().add(combat, JLayeredPane.POPUP_LAYER);\n\t\tcombat.setLocation(500, 300);\n\t\tMageFrame.getDesktop().add(pickNumber, JLayeredPane.POPUP_LAYER);\n\t\tthis.players.clear();\n\t\tthis.pnlBattlefield.removeAll();\n\t\t//arrange players in a circle with the session player at the bottom left\n\t\tint numSeats = game.getPlayers().size();\n\t\tint numColumns = (numSeats + 1) / 2;\n\t\tboolean oddNumber = (numColumns > 1 && numSeats % 2 == 1);\n\t\tint col = 0;\n\t\tint row = 1;\n\t\tint playerSeat = 0;\n\t\tfor (PlayerView player: game.getPlayers()) {\n\t\t\tif (playerId.equals(player.getPlayerId()))\n\t\t\t\tbreak;\n\t\t\tplayerSeat++;\n\t\t}\n\t\tPlayerView player = game.getPlayers().get(playerSeat);\n\t\tPlayAreaPanel sessionPlayer = new PlayAreaPanel(player, bigCard, gameId);\n\t\tplayers.put(player.getPlayerId(), sessionPlayer);\n\t\tGridBagConstraints c = new GridBagConstraints();\n\t\tc.fill = GridBagConstraints.BOTH;\n\t\tc.weightx = 0.5;\n\t\tc.weighty = 0.5;\n\t\tif (oddNumber)\n\t\t\tc.gridwidth = 2;\n\t\tc.gridx = col;\n\t\tc.gridy = row;\n\t\tthis.pnlBattlefield.add(sessionPlayer, c);\n\t\tsessionPlayer.setVisible(true);\n\t\tif (oddNumber)\n\t\t\tcol++;\n\t\tint playerNum = playerSeat + 1;\n\t\twhile (true) {\n\t\t\tif (row == 1)\n\t\t\t\tcol++;\n\t\t\telse\n\t\t\t\tcol--;\n\t\t\tif (col >= numColumns) {\n\t\t\t\trow = 0;\n\t\t\t\tcol = numColumns - 1;\n\t\t\t}\n\t\t\tplayer = game.getPlayers().get(playerNum);\n\t\t\tPlayAreaPanel playerPanel = new PlayAreaPanel(player, bigCard, gameId);\n\t\t\tplayers.put(player.getPlayerId(), playerPanel);\n\t\t\tc = new GridBagConstraints();\n\t\t\tc.fill = GridBagConstraints.BOTH;\n\t\t\tc.weightx = 0.5;\n\t\t\tc.weighty = 0.5;\n\t\t\tc.gridx = col;\n\t\t\tc.gridy = row;\n\t\t\tthis.pnlBattlefield.add(playerPanel, c);\n\t\t\tplayerPanel.setVisible(true);\n\t\t\tplayerNum++;\n\t\t\tif (playerNum >= numSeats)\n\t\t\t\tplayerNum = 0;\n\t\t\tif (playerNum == playerSeat)\n\t\t\t\tbreak;\n\t\t}\n\t\tupdateGame(game);\n\t}","commit_id":"4d5c30d06c7dfdc149c71078549f2d77a99aec0e","url":"https://github.com/magefree/mage"},{"original_method":"public void showDialog(int min, int max) {\n\t\tthis.spnAmount.setModel(new SpinnerNumberModel(min, min, max, 1));\n\t\tthis.btnCancel.setVisible(false);\n\t\tthis.setVisible(true);\n\t}","id":11186,"modified_method":"public void showDialog(int min, int max, String message) {\n\t\tthis.spnAmount.setModel(new SpinnerNumberModel(min, min, max, 1));\n\t\tthis.lblMessage.setText(message);\n\t\tthis.btnCancel.setVisible(false);\n\t\tthis.setVisible(true);\n\t}","commit_id":"4d5c30d06c7dfdc149c71078549f2d77a99aec0e","url":"https://github.com/magefree/mage"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        spnAmount = new javax.swing.JSpinner();\n        btnCancel = new javax.swing.JButton();\n        btnOk = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n\n        spnAmount.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(1), null, null, Integer.valueOf(1)));\n\n        btnCancel.setText(\"Cancel\");\n        btnCancel.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCancelActionPerformed(evt);\n            }\n        });\n\n        btnOk.setText(\"OK\");\n        btnOk.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnOkActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(btnOk)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(btnCancel)\n                .addContainerGap())\n            .addGroup(layout.createSequentialGroup()\n                .addGap(61, 61, 61)\n                .addComponent(spnAmount, javax.swing.GroupLayout.PREFERRED_SIZE, 48, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(51, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(spnAmount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 15, Short.MAX_VALUE)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(btnCancel)\n                    .addComponent(btnOk))\n                .addContainerGap())\n        );\n\n        pack();\n    }","id":11187,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        spnAmount = new javax.swing.JSpinner();\n        btnCancel = new javax.swing.JButton();\n        btnOk = new javax.swing.JButton();\n        lblMessage = new javax.swing.JLabel();\n\n        spnAmount.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(1), null, null, Integer.valueOf(1)));\n\n        btnCancel.setText(\"Cancel\");\n        btnCancel.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCancelActionPerformed(evt);\n            }\n        });\n\n        btnOk.setText(\"OK\");\n        btnOk.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnOkActionPerformed(evt);\n            }\n        });\n\n        lblMessage.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap(13, Short.MAX_VALUE)\n                        .addComponent(btnOk)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(btnCancel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(44, 44, 44)\n                        .addComponent(spnAmount, javax.swing.GroupLayout.PREFERRED_SIZE, 52, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(lblMessage, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(lblMessage, javax.swing.GroupLayout.DEFAULT_SIZE, 30, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(spnAmount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(btnCancel)\n                    .addComponent(btnOk))\n                .addContainerGap())\n        );\n\n        pack();\n    }","commit_id":"4d5c30d06c7dfdc149c71078549f2d77a99aec0e","url":"https://github.com/magefree/mage"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        servicesLabel = new javax.swing.JLabel();\n        servicesPanel = new javax.swing.JPanel();\n        startButton = new javax.swing.JButton();\n        closeButton = new javax.swing.JButton();\n        freqSlider = new javax.swing.JSlider();\n        freqSliderLabel = new javax.swing.JLabel();\n\n        servicesLabel.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.servicesLabel.text\")); // NOI18N\n\n        servicesPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));\n        servicesPanel.setMinimumSize(new java.awt.Dimension(200, 150));\n        servicesPanel.setPreferredSize(new java.awt.Dimension(200, 150));\n\n        javax.swing.GroupLayout servicesPanelLayout = new javax.swing.GroupLayout(servicesPanel);\n        servicesPanel.setLayout(servicesPanelLayout);\n        servicesPanelLayout.setHorizontalGroup(\n            servicesPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 198, Short.MAX_VALUE)\n        );\n        servicesPanelLayout.setVerticalGroup(\n            servicesPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 148, Short.MAX_VALUE)\n        );\n\n        startButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.startButton.text\")); // NOI18N\n        startButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                startButtonActionPerformed(evt);\n            }\n        });\n\n        closeButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.closeButton.text\")); // NOI18N\n\n        freqSlider.setMajorTickSpacing(5);\n        freqSlider.setMaximum(60);\n        freqSlider.setMinimum(5);\n        freqSlider.setMinorTickSpacing(1);\n        freqSlider.setPaintLabels(true);\n        freqSlider.setPaintTicks(true);\n        freqSlider.setSnapToTicks(true);\n        freqSlider.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSlider.toolTipText\")); // NOI18N\n        freqSlider.setValue(30);\n\n        freqSliderLabel.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.text\")); // NOI18N\n        freqSliderLabel.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.toolTipText\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(servicesLabel)\n                    .addComponent(servicesPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(21, Short.MAX_VALUE))\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(freqSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(21, Short.MAX_VALUE))\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap(93, Short.MAX_VALUE)\n                .addComponent(startButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(closeButton)\n                .addGap(16, 16, 16))\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap(54, Short.MAX_VALUE)\n                .addComponent(freqSliderLabel)\n                .addGap(52, 52, 52))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(servicesLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(servicesPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(freqSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(freqSliderLabel)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(startButton)\n                    .addComponent(closeButton))\n                .addGap(23, 23, 23))\n        );\n    }","id":11188,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        servicesLabel = new javax.swing.JLabel();\n        servicesPanel = new javax.swing.JPanel();\n        startButton = new javax.swing.JButton();\n        closeButton = new javax.swing.JButton();\n        freqSlider = new javax.swing.JSlider();\n        freqSliderLabel = new javax.swing.JLabel();\n\n        servicesLabel.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.servicesLabel.text\")); // NOI18N\n\n        servicesPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));\n        servicesPanel.setMinimumSize(new java.awt.Dimension(200, 150));\n        servicesPanel.setPreferredSize(new java.awt.Dimension(200, 150));\n\n        javax.swing.GroupLayout servicesPanelLayout = new javax.swing.GroupLayout(servicesPanel);\n        servicesPanel.setLayout(servicesPanelLayout);\n        servicesPanelLayout.setHorizontalGroup(\n            servicesPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 198, Short.MAX_VALUE)\n        );\n        servicesPanelLayout.setVerticalGroup(\n            servicesPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 148, Short.MAX_VALUE)\n        );\n\n        startButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.startButton.text\")); // NOI18N\n        startButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                startButtonActionPerformed(evt);\n            }\n        });\n\n        closeButton.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.closeButton.text\")); // NOI18N\n\n        freqSlider.setMajorTickSpacing(5);\n        freqSlider.setMaximum(60);\n        freqSlider.setMinimum(5);\n        freqSlider.setMinorTickSpacing(1);\n        freqSlider.setPaintLabels(true);\n        freqSlider.setPaintTicks(true);\n        freqSlider.setSnapToTicks(true);\n        freqSlider.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSlider.toolTipText\")); // NOI18N\n        freqSlider.setValue(30);\n\n        freqSliderLabel.setText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.text\")); // NOI18N\n        freqSliderLabel.setToolTipText(org.openide.util.NbBundle.getMessage(IngestDialogPanel.class, \"IngestDialogPanel.freqSliderLabel.toolTipText\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(servicesLabel)\n                            .addComponent(servicesPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addContainerGap(21, Short.MAX_VALUE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addComponent(freqSliderLabel)\n                        .addGap(52, 52, 52))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(startButton)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(closeButton))\n                            .addComponent(freqSlider, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addContainerGap(21, Short.MAX_VALUE))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(servicesLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(servicesPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(freqSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(freqSliderLabel)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(closeButton)\n                    .addComponent(startButton))\n                .addContainerGap())\n        );\n    }","commit_id":"a42cc5a77fb12c6a6a1a11f874ef325f95384483","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            out.writeVInt(collectors.length);\n            for (GarbageCollector gc : collectors) {\n                gc.writeTo(out);\n            }\n        }","id":11189,"modified_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            out.writeArray(collectors);\n        }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static GarbageCollector readGarbageCollector(StreamInput in) throws IOException {\n            GarbageCollector gc = new GarbageCollector();\n            gc.readFrom(in);\n            return gc;\n        }","id":11190,"modified_method":"public Threads(int count, int peakCount) {\n            this.count = count;\n            this.peakCount = peakCount;\n        }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeVLong(timestamp);\n        out.writeVLong(uptime);\n\n        mem.writeTo(out);\n        threads.writeTo(out);\n        gc.writeTo(out);\n\n        if (bufferPools == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeVInt(bufferPools.size());\n            for (BufferPool bufferPool : bufferPools) {\n                bufferPool.writeTo(out);\n            }\n        }\n    }","id":11191,"modified_method":"public GarbageCollectors(GarbageCollector[] collectors) {\n            this.collectors = collectors;\n        }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(Fields.JVM);\n        builder.field(Fields.TIMESTAMP, timestamp);\n        builder.timeValueField(Fields.UPTIME_IN_MILLIS, Fields.UPTIME, uptime);\n        if (mem != null) {\n            builder.startObject(Fields.MEM);\n\n            builder.byteSizeField(Fields.HEAP_USED_IN_BYTES, Fields.HEAP_USED, mem.heapUsed);\n            if (mem.getHeapUsedPercent() >= 0) {\n                builder.field(Fields.HEAP_USED_PERCENT, mem.getHeapUsedPercent());\n            }\n            builder.byteSizeField(Fields.HEAP_COMMITTED_IN_BYTES, Fields.HEAP_COMMITTED, mem.heapCommitted);\n            builder.byteSizeField(Fields.HEAP_MAX_IN_BYTES, Fields.HEAP_MAX, mem.heapMax);\n            builder.byteSizeField(Fields.NON_HEAP_USED_IN_BYTES, Fields.NON_HEAP_USED, mem.nonHeapUsed);\n            builder.byteSizeField(Fields.NON_HEAP_COMMITTED_IN_BYTES, Fields.NON_HEAP_COMMITTED, mem.nonHeapCommitted);\n\n            builder.startObject(Fields.POOLS);\n            for (MemoryPool pool : mem) {\n                builder.startObject(pool.getName());\n                builder.byteSizeField(Fields.USED_IN_BYTES, Fields.USED, pool.used);\n                builder.byteSizeField(Fields.MAX_IN_BYTES, Fields.MAX, pool.max);\n\n                builder.byteSizeField(Fields.PEAK_USED_IN_BYTES, Fields.PEAK_USED, pool.peakUsed);\n                builder.byteSizeField(Fields.PEAK_MAX_IN_BYTES, Fields.PEAK_MAX, pool.peakMax);\n\n                builder.endObject();\n            }\n            builder.endObject();\n\n            builder.endObject();\n        }\n        if (threads != null) {\n            builder.startObject(Fields.THREADS);\n            builder.field(Fields.COUNT, threads.getCount());\n            builder.field(Fields.PEAK_COUNT, threads.getPeakCount());\n            builder.endObject();\n        }\n        if (gc != null) {\n            builder.startObject(Fields.GC);\n\n            builder.startObject(Fields.COLLECTORS);\n            for (GarbageCollector collector : gc) {\n                builder.startObject(collector.getName());\n                builder.field(Fields.COLLECTION_COUNT, collector.getCollectionCount());\n                builder.timeValueField(Fields.COLLECTION_TIME_IN_MILLIS, Fields.COLLECTION_TIME, collector.collectionTime);\n                builder.endObject();\n            }\n            builder.endObject();\n\n            builder.endObject();\n        }\n\n        if (bufferPools != null) {\n            builder.startObject(Fields.BUFFER_POOLS);\n            for (BufferPool bufferPool : bufferPools) {\n                builder.startObject(bufferPool.getName());\n                builder.field(Fields.COUNT, bufferPool.getCount());\n                builder.byteSizeField(Fields.USED_IN_BYTES, Fields.USED, bufferPool.used);\n                builder.byteSizeField(Fields.TOTAL_CAPACITY_IN_BYTES, Fields.TOTAL_CAPACITY, bufferPool.totalCapacity);\n                builder.endObject();\n            }\n            builder.endObject();\n        }\n\n        if (classes != null) {\n            builder.startObject(Fields.CLASSES);\n            builder.field(Fields.CURRENT_LOADED_COUNT, classes.getLoadedClassCount());\n            builder.field(Fields.TOTAL_LOADED_COUNT, classes.getTotalLoadedClassCount());\n            builder.field(Fields.TOTAL_UNLOADED_COUNT, classes.getUnloadedClassCount());\n            builder.endObject();\n        }\n\n        builder.endObject();\n        return builder;\n    }","id":11192,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(Fields.JVM);\n        builder.field(Fields.TIMESTAMP, timestamp);\n        builder.timeValueField(Fields.UPTIME_IN_MILLIS, Fields.UPTIME, uptime);\n\n        builder.startObject(Fields.MEM);\n\n        builder.byteSizeField(Fields.HEAP_USED_IN_BYTES, Fields.HEAP_USED, mem.heapUsed);\n        if (mem.getHeapUsedPercent() >= 0) {\n            builder.field(Fields.HEAP_USED_PERCENT, mem.getHeapUsedPercent());\n        }\n        builder.byteSizeField(Fields.HEAP_COMMITTED_IN_BYTES, Fields.HEAP_COMMITTED, mem.heapCommitted);\n        builder.byteSizeField(Fields.HEAP_MAX_IN_BYTES, Fields.HEAP_MAX, mem.heapMax);\n        builder.byteSizeField(Fields.NON_HEAP_USED_IN_BYTES, Fields.NON_HEAP_USED, mem.nonHeapUsed);\n        builder.byteSizeField(Fields.NON_HEAP_COMMITTED_IN_BYTES, Fields.NON_HEAP_COMMITTED, mem.nonHeapCommitted);\n\n        builder.startObject(Fields.POOLS);\n        for (MemoryPool pool : mem) {\n            builder.startObject(pool.getName());\n            builder.byteSizeField(Fields.USED_IN_BYTES, Fields.USED, pool.used);\n            builder.byteSizeField(Fields.MAX_IN_BYTES, Fields.MAX, pool.max);\n\n            builder.byteSizeField(Fields.PEAK_USED_IN_BYTES, Fields.PEAK_USED, pool.peakUsed);\n            builder.byteSizeField(Fields.PEAK_MAX_IN_BYTES, Fields.PEAK_MAX, pool.peakMax);\n\n            builder.endObject();\n        }\n        builder.endObject();\n\n        builder.endObject();\n\n        builder.startObject(Fields.THREADS);\n        builder.field(Fields.COUNT, threads.getCount());\n        builder.field(Fields.PEAK_COUNT, threads.getPeakCount());\n        builder.endObject();\n\n        builder.startObject(Fields.GC);\n\n        builder.startObject(Fields.COLLECTORS);\n        for (GarbageCollector collector : gc) {\n            builder.startObject(collector.getName());\n            builder.field(Fields.COLLECTION_COUNT, collector.getCollectionCount());\n            builder.timeValueField(Fields.COLLECTION_TIME_IN_MILLIS, Fields.COLLECTION_TIME, collector.collectionTime);\n            builder.endObject();\n        }\n        builder.endObject();\n\n        builder.endObject();\n\n        if (bufferPools != null) {\n            builder.startObject(Fields.BUFFER_POOLS);\n            for (BufferPool bufferPool : bufferPools) {\n                builder.startObject(bufferPool.getName());\n                builder.field(Fields.COUNT, bufferPool.getCount());\n                builder.byteSizeField(Fields.USED_IN_BYTES, Fields.USED, bufferPool.used);\n                builder.byteSizeField(Fields.TOTAL_CAPACITY_IN_BYTES, Fields.TOTAL_CAPACITY, bufferPool.totalCapacity);\n                builder.endObject();\n            }\n            builder.endObject();\n        }\n\n        builder.startObject(Fields.CLASSES);\n        builder.field(Fields.CURRENT_LOADED_COUNT, classes.getLoadedClassCount());\n        builder.field(Fields.TOTAL_LOADED_COUNT, classes.getTotalLoadedClassCount());\n        builder.field(Fields.TOTAL_UNLOADED_COUNT, classes.getUnloadedClassCount());\n        builder.endObject();\n\n        builder.endObject();\n        return builder;\n    }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static JvmStats jvmStats() {\n        JvmStats stats = new JvmStats(System.currentTimeMillis(), runtimeMXBean.getUptime());\n        stats.mem = new Mem();\n        MemoryUsage memUsage = memoryMXBean.getHeapMemoryUsage();\n        stats.mem.heapUsed = memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();\n        stats.mem.heapCommitted = memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();\n        stats.mem.heapMax = memUsage.getMax() < 0 ? 0 : memUsage.getMax();\n        memUsage = memoryMXBean.getNonHeapMemoryUsage();\n        stats.mem.nonHeapUsed = memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();\n        stats.mem.nonHeapCommitted = memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();\n\n        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n        List<MemoryPool> pools = new ArrayList<>();\n        for (int i = 0; i < memoryPoolMXBeans.size(); i++) {\n            try {\n                MemoryPoolMXBean memoryPoolMXBean = memoryPoolMXBeans.get(i);\n                MemoryUsage usage = memoryPoolMXBean.getUsage();\n                MemoryUsage peakUsage = memoryPoolMXBean.getPeakUsage();\n                String name = GcNames.getByMemoryPoolName(memoryPoolMXBean.getName(), null);\n                if (name == null) { // if we can't resolve it, its not interesting.... (Per Gen, Code Cache)\n                    continue;\n                }\n                pools.add(new MemoryPool(name,\n                        usage.getUsed() < 0 ? 0 : usage.getUsed(),\n                        usage.getMax() < 0 ? 0 : usage.getMax(),\n                        peakUsage.getUsed() < 0 ? 0 : peakUsage.getUsed(),\n                        peakUsage.getMax() < 0 ? 0 : peakUsage.getMax()\n                ));\n            } catch (Exception ex) {\n                /* ignore some JVMs might barf here with:\n                 * java.lang.InternalError: Memory Pool not found\n                 * we just omit the pool in that case!*/\n            }\n        }\n        stats.mem.pools = pools.toArray(new MemoryPool[pools.size()]);\n\n        stats.threads = new Threads();\n        stats.threads.count = threadMXBean.getThreadCount();\n        stats.threads.peakCount = threadMXBean.getPeakThreadCount();\n\n        List<GarbageCollectorMXBean> gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();\n        stats.gc = new GarbageCollectors();\n        stats.gc.collectors = new GarbageCollector[gcMxBeans.size()];\n        for (int i = 0; i < stats.gc.collectors.length; i++) {\n            GarbageCollectorMXBean gcMxBean = gcMxBeans.get(i);\n            stats.gc.collectors[i] = new GarbageCollector();\n            stats.gc.collectors[i].name = GcNames.getByGcName(gcMxBean.getName(), gcMxBean.getName());\n            stats.gc.collectors[i].collectionCount = gcMxBean.getCollectionCount();\n            stats.gc.collectors[i].collectionTime = gcMxBean.getCollectionTime();\n        }\n\n        try {\n            List<BufferPoolMXBean> bufferPools = ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class);\n            stats.bufferPools = new ArrayList<>(bufferPools.size());\n            for (BufferPoolMXBean bufferPool : bufferPools) {\n                stats.bufferPools.add(new BufferPool(bufferPool.getName(), bufferPool.getCount(), bufferPool.getTotalCapacity(), bufferPool.getMemoryUsed()));\n            }\n        } catch (Exception e) {\n            // buffer pools are not available\n        }\n\n        stats.classes = new Classes();\n        stats.classes.loadedClassCount = classLoadingMXBean.getLoadedClassCount();\n        stats.classes.totalLoadedClassCount = classLoadingMXBean.getTotalLoadedClassCount();\n        stats.classes.unloadedClassCount = classLoadingMXBean.getUnloadedClassCount();\n\n        return stats;\n    }","id":11193,"modified_method":"public static JvmStats jvmStats() {\n        MemoryUsage memUsage = memoryMXBean.getHeapMemoryUsage();\n        long heapUsed = memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();\n        long heapCommitted = memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();\n        long heapMax = memUsage.getMax() < 0 ? 0 : memUsage.getMax();\n        memUsage = memoryMXBean.getNonHeapMemoryUsage();\n        long nonHeapUsed = memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();\n        long nonHeapCommitted = memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();\n        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n        List<MemoryPool> pools = new ArrayList<>();\n        for (MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) {\n            try {\n                MemoryUsage usage = memoryPoolMXBean.getUsage();\n                MemoryUsage peakUsage = memoryPoolMXBean.getPeakUsage();\n                String name = GcNames.getByMemoryPoolName(memoryPoolMXBean.getName(), null);\n                if (name == null) { // if we can't resolve it, its not interesting.... (Per Gen, Code Cache)\n                    continue;\n                }\n                pools.add(new MemoryPool(name,\n                        usage.getUsed() < 0 ? 0 : usage.getUsed(),\n                        usage.getMax() < 0 ? 0 : usage.getMax(),\n                        peakUsage.getUsed() < 0 ? 0 : peakUsage.getUsed(),\n                        peakUsage.getMax() < 0 ? 0 : peakUsage.getMax()\n                ));\n            } catch (Exception ex) {\n                /* ignore some JVMs might barf here with:\n                 * java.lang.InternalError: Memory Pool not found\n                 * we just omit the pool in that case!*/\n            }\n        }\n        MemoryPool[] memoryPools = pools.toArray(new MemoryPool[pools.size()]);\n        Mem mem = new Mem(heapCommitted, heapUsed, heapMax, nonHeapCommitted, nonHeapUsed, memoryPools);\n        Threads threads = new Threads(threadMXBean.getThreadCount(), threadMXBean.getPeakThreadCount());\n\n        List<GarbageCollectorMXBean> gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();\n        GarbageCollector[] collectors = new GarbageCollector[gcMxBeans.size()];\n        for (int i = 0; i < collectors.length; i++) {\n            GarbageCollectorMXBean gcMxBean = gcMxBeans.get(i);\n            collectors[i] = new GarbageCollector(GcNames.getByGcName(gcMxBean.getName(), gcMxBean.getName()),\n                    gcMxBean.getCollectionCount(), gcMxBean.getCollectionTime());\n        }\n        GarbageCollectors garbageCollectors = new GarbageCollectors(collectors);\n        List<BufferPool> bufferPoolsList = null;\n        try {\n            List<BufferPoolMXBean> bufferPools = ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class);\n            bufferPoolsList = new ArrayList<>(bufferPools.size());\n            for (BufferPoolMXBean bufferPool : bufferPools) {\n                bufferPoolsList.add(new BufferPool(bufferPool.getName(), bufferPool.getCount(),\n                        bufferPool.getTotalCapacity(), bufferPool.getMemoryUsed()));\n            }\n        } catch (Exception e) {\n            // buffer pools are not available\n        }\n\n        Classes classes = new Classes(classLoadingMXBean.getLoadedClassCount(), classLoadingMXBean.getTotalLoadedClassCount(),\n                classLoadingMXBean.getUnloadedClassCount());\n\n        return new JvmStats(System.currentTimeMillis(), runtimeMXBean.getUptime(), mem, threads,\n                garbageCollectors, bufferPoolsList, classes);\n    }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            collectors = new GarbageCollector[in.readVInt()];\n            for (int i = 0; i < collectors.length; i++) {\n                collectors[i] = GarbageCollector.readGarbageCollector(in);\n            }\n        }","id":11194,"modified_method":"public GarbageCollector(String name, long collectionCount, long collectionTime) {\n            this.name = name;\n            this.collectionCount = collectionCount;\n            this.collectionTime = collectionTime;\n        }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            out.writeVLong(heapCommitted);\n            out.writeVLong(heapUsed);\n            out.writeVLong(nonHeapCommitted);\n            out.writeVLong(nonHeapUsed);\n            out.writeVLong(heapMax);\n            out.writeVInt(pools.length);\n            for (MemoryPool pool : pools) {\n                pool.writeTo(out);\n            }\n        }","id":11195,"modified_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            out.writeVLong(heapCommitted);\n            out.writeVLong(heapUsed);\n            out.writeVLong(nonHeapCommitted);\n            out.writeVLong(nonHeapUsed);\n            out.writeVLong(heapMax);\n            out.writeArray(pools);\n        }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ByteSizeValue getHeapUsed() {\n            return new ByteSizeValue(heapUsed);\n        }","id":11196,"modified_method":"public BufferPool(StreamInput in) throws IOException {\n            name = in.readString();\n            count = in.readLong();\n            totalCapacity = in.readLong();\n            used = in.readLong();\n        }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        timestamp = in.readVLong();\n        if (in.readBoolean()) {\n            indices = NodeIndicesStats.readIndicesStats(in);\n        }\n        if (in.readBoolean()) {\n            os = new OsStats(in);\n        }\n        if (in.readBoolean()) {\n            process = new ProcessStats(in);\n        }\n        if (in.readBoolean()) {\n            jvm = JvmStats.readJvmStats(in);\n        }\n        if (in.readBoolean()) {\n            threadPool = ThreadPoolStats.readThreadPoolStats(in);\n        }\n        if (in.readBoolean()) {\n            fs = new FsInfo(in);\n        }\n        if (in.readBoolean()) {\n            transport = TransportStats.readTransportStats(in);\n        }\n        if (in.readBoolean()) {\n            http = HttpStats.readHttpStats(in);\n        }\n        breaker = AllCircuitBreakerStats.readOptionalAllCircuitBreakerStats(in);\n        scriptStats = in.readOptionalStreamable(ScriptStats::new);\n        discoveryStats = in.readOptionalStreamable(() -> new DiscoveryStats(null));\n        ingestStats = in.readOptionalWriteable(IngestStats::new);\n    }","id":11197,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        timestamp = in.readVLong();\n        if (in.readBoolean()) {\n            indices = NodeIndicesStats.readIndicesStats(in);\n        }\n        if (in.readBoolean()) {\n            os = new OsStats(in);\n        }\n        if (in.readBoolean()) {\n            process = new ProcessStats(in);\n        }\n        if (in.readBoolean()) {\n            jvm = new JvmStats(in);\n        }\n        if (in.readBoolean()) {\n            threadPool = ThreadPoolStats.readThreadPoolStats(in);\n        }\n        if (in.readBoolean()) {\n            fs = new FsInfo(in);\n        }\n        if (in.readBoolean()) {\n            transport = TransportStats.readTransportStats(in);\n        }\n        if (in.readBoolean()) {\n            http = HttpStats.readHttpStats(in);\n        }\n        breaker = AllCircuitBreakerStats.readOptionalAllCircuitBreakerStats(in);\n        scriptStats = in.readOptionalStreamable(ScriptStats::new);\n        discoveryStats = in.readOptionalStreamable(() -> new DiscoveryStats(null));\n        ingestStats = in.readOptionalWriteable(IngestStats::new);\n    }","commit_id":"102dac2cd9ceec3721b7f84216bdb3cc462fecdc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void run() {\n            OutputStream to = null;\n            _in = null;\n            long start = System.currentTimeMillis();\n            long written = 0;\n            try {\n                _in = new InternalGZIPInputStream(_inRaw);\n                byte buf[] = new byte[8192];\n                int read = -1;\n                while ( (read = _in.read(buf)) != -1) {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Read \" + read + \" and writing it to the browser/streams\");\n                    _out.write(buf, 0, read);\n                    _out.flush();\n                    written += read;\n                }\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Decompressed: \" + written + \", \" + _in.getTotalRead() + \"/\" + _in.getTotalExpanded());\n            } catch (IOException ioe) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Error decompressing: \" + written + \", \" + (_in != null ? _in.getTotalRead() + \"/\" + _in.getTotalExpanded() : \"\"), ioe);\n            } finally {\n                if (_log.shouldLog(Log.WARN) && (_in != null))\n                    _log.warn(\"After decompression, written=\" + written + \n                              (_in != null ?\n                                \" read=\" + _in.getTotalRead() \n                                + \", expanded=\" + _in.getTotalExpanded() + \", remaining=\" + _in.getRemaining() \n                                + \", finished=\" + _in.getFinished()\n                               : \"\"));\n                if (_out != null) try { \n                    _out.close(); \n                } catch (IOException ioe) {}\n            }\n            long end = System.currentTimeMillis();\n            double compressed = (_in != null ? _in.getTotalRead() : 0);\n            double expanded = (_in != null ? _in.getTotalExpanded() : 0);\n            double ratio = 0;\n            if (expanded > 0)\n                ratio = compressed/expanded;\n\n            _context.statManager().addRateData(\"i2ptunnel.httpCompressionRatio\", (int)(100d*ratio), end-start);\n            _context.statManager().addRateData(\"i2ptunnel.httpCompressed\", (long)compressed, end-start);\n            _context.statManager().addRateData(\"i2ptunnel.httpExpanded\", (long)expanded, end-start);\n        }","id":11198,"modified_method":"public void run() {\n            _in = null;\n            long written = 0;\n            ByteArray ba = null;\n            try {\n                _in = new InternalGZIPInputStream(_inRaw);\n                ba = _cache.acquire();\n                byte buf[] = ba.getData();\n                int read = -1;\n                while ( (read = _in.read(buf)) != -1) {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Read \" + read + \" and writing it to the browser/streams\");\n                    _out.write(buf, 0, read);\n                    _out.flush();\n                    written += read;\n                }\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Decompressed: \" + written + \", \" + _in.getTotalRead() + \"/\" + _in.getTotalExpanded());\n            } catch (IOException ioe) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Error decompressing: \" + written + \", \" + (_in != null ? _in.getTotalRead() + \"/\" + _in.getTotalExpanded() : \"\"), ioe);\n            } catch (OutOfMemoryError oom) {\n                _log.error(\"OOM in HTTP Decompressor\", oom);\n            } finally {\n                if (_log.shouldLog(Log.WARN) && (_in != null))\n                    _log.warn(\"After decompression, written=\" + written + \n                              (_in != null ?\n                                \" read=\" + _in.getTotalRead() \n                                + \", expanded=\" + _in.getTotalExpanded() + \", remaining=\" + _in.getRemaining() \n                                + \", finished=\" + _in.getFinished()\n                               : \"\"));\n                if (ba != null)\n                    _cache.release(ba);\n                if (_out != null) try { \n                    _out.close(); \n                } catch (IOException ioe) {}\n            }\n\n            double compressed = (_in != null ? _in.getTotalRead() : 0);\n            double expanded = (_in != null ? _in.getTotalExpanded() : 0);\n            if (compressed > 0 && expanded > 0) {\n                // only update the stats if we did something\n                double ratio = compressed/expanded;\n                _context.statManager().addRateData(\"i2ptunnel.httpCompressionRatio\", (int)(100d*ratio), 0);\n                _context.statManager().addRateData(\"i2ptunnel.httpCompressed\", (long)compressed, 0);\n                _context.statManager().addRateData(\"i2ptunnel.httpExpanded\", (long)expanded, 0);\n            }\n        }","commit_id":"4456048e79cde5019108db7c8406a9d8169cccc9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected void beginProcessing() throws IOException {\n        //out.flush();\n        PipedInputStream pi = new PipedInputStream();\n        PipedOutputStream po = new PipedOutputStream(pi);\n        new I2PAppThread(new Pusher(pi, out), \"HTTP decompresser\").start();\n        out = po;\n    }","id":11199,"modified_method":"protected void beginProcessing() throws IOException {\n        //out.flush();\n        PipedInputStream pi = new PipedInputStream();\n        PipedOutputStream po = new PipedOutputStream(pi);\n        new I2PAppThread(new Pusher(pi, out), \"HTTP decompressor\").start();\n        out = po;\n    }","commit_id":"4456048e79cde5019108db7c8406a9d8169cccc9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** grow (and free) the buffer as necessary */\n    private void ensureCapacity() {\n        if (_headerBuffer.getValid() + 1 >= _headerBuffer.getData().length) {\n            int newSize = (int)(_headerBuffer.getData().length * 1.5);\n            ByteArray newBuf = new ByteArray(new byte[newSize]);\n            System.arraycopy(_headerBuffer.getData(), 0, newBuf.getData(), 0, _headerBuffer.getValid());\n            newBuf.setValid(_headerBuffer.getValid());\n            newBuf.setOffset(0);\n            if (_headerBuffer.getData().length == CACHE_SIZE)\n                _cache.release(_headerBuffer);\n            _headerBuffer = newBuf;\n        }\n    }","id":11200,"modified_method":"/**\n     *  grow (and free) the buffer as necessary\n     *  @throws IOException if the headers are too big\n     */\n    private void ensureCapacity() throws IOException {\n        if (_headerBuffer.getValid() >= MAX_HEADER_SIZE)\n            throw new IOException(\"Max header size exceeded: \" + MAX_HEADER_SIZE);\n        if (_headerBuffer.getValid() + 1 >= _headerBuffer.getData().length) {\n            int newSize = (int)(_headerBuffer.getData().length * 1.5);\n            ByteArray newBuf = new ByteArray(new byte[newSize]);\n            System.arraycopy(_headerBuffer.getData(), 0, newBuf.getData(), 0, _headerBuffer.getValid());\n            newBuf.setValid(_headerBuffer.getValid());\n            newBuf.setOffset(0);\n            // if we changed the ByteArray size, don't put it back in the cache\n            if (_headerBuffer.getData().length == CACHE_SIZE)\n                _cache.release(_headerBuffer);\n            _headerBuffer = newBuf;\n        }\n    }","commit_id":"4456048e79cde5019108db7c8406a9d8169cccc9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public long getRemaining() { \n            try {\n                return super.inf.getRemaining(); \n            } catch (Exception e) {\n                return 0;\n            }\n        }","id":11201,"modified_method":"/**\n         *  From Inflater javadoc:\n         *  Returns the total number of bytes remaining in the input buffer. This can be used to find out\n         *  what bytes still remain in the input buffer after decompression has finished.\n         */\n        public long getRemaining() { \n            try {\n                return super.inf.getRemaining(); \n            } catch (Exception e) {\n                return 0;\n            }\n        }","commit_id":"4456048e79cde5019108db7c8406a9d8169cccc9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public HTTPResponseOutputStream(OutputStream raw) {\n        super(raw);\n        _context = I2PAppContext.getGlobalContext();\n        _context.statManager().createRateStat(\"i2ptunnel.httpCompressionRatio\", \"ratio of compressed size to decompressed size after transfer\", \"I2PTunnel\", new long[] { 60*1000, 30*60*1000 });\n        _context.statManager().createRateStat(\"i2ptunnel.httpCompressed\", \"compressed size transferred\", \"I2PTunnel\", new long[] { 60*1000, 30*60*1000 });\n        _context.statManager().createRateStat(\"i2ptunnel.httpExpanded\", \"size transferred after expansion\", \"I2PTunnel\", new long[] { 60*1000, 30*60*1000 });\n        _log = _context.logManager().getLog(getClass());\n        _cache = ByteCache.getInstance(8, CACHE_SIZE);\n        _headerBuffer = _cache.acquire();\n        _headerWritten = false;\n        _gzip = false;\n        _dataWritten = 0;\n        _buf1 = new byte[1];\n    }","id":11202,"modified_method":"public HTTPResponseOutputStream(OutputStream raw) {\n        super(raw);\n        _context = I2PAppContext.getGlobalContext();\n        _context.statManager().createRateStat(\"i2ptunnel.httpCompressionRatio\", \"ratio of compressed size to decompressed size after transfer\", \"I2PTunnel\", new long[] { 60*60*1000 });\n        _context.statManager().createRateStat(\"i2ptunnel.httpCompressed\", \"compressed size transferred\", \"I2PTunnel\", new long[] { 60*60*1000 });\n        _context.statManager().createRateStat(\"i2ptunnel.httpExpanded\", \"size transferred after expansion\", \"I2PTunnel\", new long[] { 60*60*1000 });\n        _log = _context.logManager().getLog(getClass());\n        _headerBuffer = _cache.acquire();\n        _buf1 = new byte[1];\n    }","commit_id":"4456048e79cde5019108db7c8406a9d8169cccc9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    protected boolean confirmRemove(final Object value) {\n      if(value instanceof ModuleReference) {\n        final ModuleReference moduleReference = (ModuleReference)value;\n        if( !myModelProperties.getUsedLanguageRemoveCondition().met(moduleReference) ) {\n          int result = Messages.showYesNoCancelDialog(\n            ProjectHelper.toIdeaProject(myProject),\n            \"<html>This language is used by model.<br>Do you really what to delete it?<br><font color=\\\"red\\\"><b>Model state will become inconsistent<\/b><\/font><\/html>\",\n            \"Delete used language\", \"&View usages\", \"&Delete anyway\", \"Ca&ncel\", Messages.getQuestionIcon());\n          switch (result) {\n            case Messages.YES:\n              findUsages(value);\n              return false;\n            case Messages.NO:\n              return true;\n            case Messages.CANCEL:\n              return false;\n          }\n        }\n      }\n      else if(value instanceof SModelReference) {\n        final SModelReference modelReference = (SModelReference)value;\n        if( !myModelProperties.getImportedModelsRemoveCondition().met((jetbrains.mps.smodel.SModelReference)modelReference) ) {\n          int result = Messages.showYesNoCancelDialog(\n            ProjectHelper.toIdeaProject(myProject),\n            \"<html>This model is used in model.<br>Do you really what to delete it?<br><font color=\\\"red\\\"><b>Model state will become inconsistent<\/b><\/font><\/html>\",\n            \"Delete imported model\", \"&View usages\", \"&Delete anyway\", \"Ca&ncel\", Messages.getQuestionIcon());\n          switch (result) {\n            case Messages.YES:\n              findUsages(value);\n              return false;\n            case Messages.NO:\n              return true;\n            case Messages.CANCEL:\n              return false;\n          }\n        }\n      }\n\n      return super.confirmRemove(value);\n    }","id":11203,"modified_method":"@Override\n    protected boolean confirmRemove(final Object value) {\n      if(value instanceof ModuleReference) {\n        final ModuleReference moduleReference = (ModuleReference)value;\n        if( !myModelProperties.getUsedLanguageRemoveCondition().met(moduleReference) ) {\n          ViewUsagesDeleteDialog viewUsagesDeleteDialog = new ViewUsagesDeleteDialog(\n            ProjectHelper.toIdeaProject(myProject), \"Delete used language\",\n            \"This language is used by model. Do you really what to delete it?\", \"Model state will become inconsistent\") {\n            @Override\n            public void doViewAction() {\n              findUsages(value);\n            }\n          };\n          viewUsagesDeleteDialog.show();\n          return viewUsagesDeleteDialog.isOK();\n        }\n      }\n      else if(value instanceof SModelReference) {\n        final SModelReference modelReference = (SModelReference)value;\n        if( !myModelProperties.getImportedModelsRemoveCondition().met((jetbrains.mps.smodel.SModelReference)modelReference) ) {\n          ViewUsagesDeleteDialog viewUsagesDeleteDialog = new ViewUsagesDeleteDialog(\n            ProjectHelper.toIdeaProject(myProject), \"Delete imported model\",\n            \"This model is used in model. Do you really what to delete it?\", \"Model state will become inconsistent\") {\n            @Override\n            public void doViewAction() {\n              findUsages(value);\n            }\n          };\n          viewUsagesDeleteDialog.show();\n          return viewUsagesDeleteDialog.isOK();\n        }\n      }\n\n      return super.confirmRemove(value);\n    }","commit_id":"5be8fa100d1739ea54e4533b603c40c3a0d723eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected boolean confirmRemove(Object value) {\n      final ModuleReference moduleReference = (ModuleReference)value;\n      if( !myModelProperties.getUsedLanguageRemoveCondition().met(moduleReference) ) {\n        int result = Messages.showYesNoCancelDialog(\n          ProjectHelper.toIdeaProject(myProject),\n          \"<html>This language is used by model.<br>Do you really what to delete it?<br><font color=\\\"red\\\"><b>Model state will become inconsistent<\/b><\/font><\/html>\",\n          \"Delete used language\", \"&View usages\", \"&Delete anyway\", \"Ca&ncel\", Messages.getQuestionIcon());\n        switch (result) {\n          case Messages.YES:\n            findUsages(value);\n            return false;\n          case Messages.NO:\n            return true;\n          case Messages.CANCEL:\n            return false;\n        }\n      }\n\n      return super.confirmRemove(value);\n    }","id":11204,"modified_method":"@Override\n    protected boolean confirmRemove(final Object value) {\n      final ModuleReference moduleReference = (ModuleReference)value;\n      if( !myModelProperties.getUsedLanguageRemoveCondition().met(moduleReference) ) {\n        ViewUsagesDeleteDialog viewUsagesDeleteDialog = new ViewUsagesDeleteDialog(\n          ProjectHelper.toIdeaProject(myProject), \"Delete used language\",\n          \"This language is used by model. Do you really what to delete it?\", \"Model state will become inconsistent\") {\n          @Override\n          public void doViewAction() {\n            findUsages(value);\n          }\n        };\n        viewUsagesDeleteDialog.show();\n        return viewUsagesDeleteDialog.isOK();\n      }\n\n      return super.confirmRemove(value);\n    }","commit_id":"5be8fa100d1739ea54e4533b603c40c3a0d723eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Constructor\n     * @param dbmgr allows ScheduleManager to access the database.\n     * @param idxmgr allows the ScheduleManager to access the indexer.\n     */\n    public ScheduleManager(DatabaseManager dbmgr, IndexManager idxmgr) {\n        databaseManager = dbmgr;\n        indexManager = idxmgr;\n    }","id":11205,"modified_method":"/**\n     * Constructor\n     * @param dbmgr allows ScheduleManager to access the database.\n     * @param idxmgr allows the ScheduleManager to access the indexer.\n     */\n    public ScheduleManager(DatabaseManager dbmgr, IndexManager idxmgr) {\n        databaseManager = dbmgr;\n        indexManager = idxmgr;\n        try {\n            scheduler = StdSchedulerFactory.getDefaultScheduler();\n        }\n        catch (SchedulerException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"62a0d4731bd18eb69d6a4a1fb2382233ed36c689","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private boolean isSupported(String indexName) {\n        if (BuilderFactory.ERRATA_TYPE.compareTo(indexName) == 0) {\n            return true;\n        }\n        else if (BuilderFactory.PACKAGES_TYPE.compareTo(indexName) == 0) {\n            return true;\n        }\n        else if (BuilderFactory.SERVER_TYPE.compareTo(indexName) == 0) {\n            return true;\n        }\n        else if (BuilderFactory.HARDWARE_DEVICE_TYPE.compareTo(indexName) == 0) {\n            return true;\n        }\n        else if (BuilderFactory.SNAPSHOT_TAG_TYPE.compareTo(indexName) == 0) {\n            return true;\n        }\n        else if (BuilderFactory.SERVER_CUSTOM_INFO_TYPE.compareTo(indexName) == 0) {\n            return true;\n        }\n        else if (BuilderFactory.DOCS_TYPE.compareTo(indexName) == 0) {\n            log.info(\"Index updates for \" + BuilderFactory.DOCS_TYPE +\n                    \" are not supported.\");\n            return false;\n        }\n        log.info(\"Unknown index: \" + indexName);\n        return false;\n    }","id":11206,"modified_method":"private boolean isSupported(String indexName) {\n        if (BuilderFactory.ERRATA_TYPE.equals(indexName) ||\n             BuilderFactory.HARDWARE_DEVICE_TYPE.equals(indexName) ||\n             BuilderFactory.PACKAGES_TYPE.equals(indexName) ||\n             BuilderFactory.SERVER_CUSTOM_INFO_TYPE.equals(indexName) ||\n             BuilderFactory.SERVER_TYPE.equals(indexName) ||\n             BuilderFactory.SNAPSHOT_TAG_TYPE.equals(indexName)) {\n            return true;\n        }\n        else if (BuilderFactory.DOCS_TYPE.equals(indexName)) {\n            log.info(\"Index updates for \" + BuilderFactory.DOCS_TYPE +\n                    \" are not supported.\");\n            return false;\n        }\n        log.info(\"Unknown index: \" + indexName);\n        return false;\n    }","commit_id":"62a0d4731bd18eb69d6a4a1fb2382233ed36c689","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void start() {\n        try {\n            Configuration config = new Configuration();\n            scheduler = StdSchedulerFactory.getDefaultScheduler();\n            long interval = config.getInt(\"search.schedule.interval\", 300000);\n            log.info(\"ScheduleManager task interval is set to \" + interval);\n            int mode = SimpleTrigger.REPEAT_INDEFINITELY;\n            if (System.getProperties().get(\"isTesting\") != null) {\n                interval = 100;\n                mode = 0;\n            }\n            pkgTrigger = createTrigger(BuilderFactory.PACKAGES_TYPE,\n                    updateIndexGroupName, mode, interval);\n            errataTrigger = createTrigger(BuilderFactory.ERRATA_TYPE,\n                    updateIndexGroupName, mode, interval);\n            systemTrigger = createTrigger(BuilderFactory.SERVER_TYPE,\n                    updateIndexGroupName, mode, interval);\n            hwDeviceTrigger = createTrigger(BuilderFactory.HARDWARE_DEVICE_TYPE,\n                    updateIndexGroupName, mode, interval);\n            snapshotTagTrigger = createTrigger(BuilderFactory.SNAPSHOT_TAG_TYPE,\n                    updateIndexGroupName, mode, interval);\n            serverCustomInfoTrigger = createTrigger(BuilderFactory.SERVER_CUSTOM_INFO_TYPE,\n                    updateIndexGroupName, mode, interval);\n\n            pkgDetail = new JobDetail(BuilderFactory.PACKAGES_TYPE,\n                    updateIndexGroupName, IndexPackagesTask.class);\n            errataDetail = new JobDetail(BuilderFactory.ERRATA_TYPE,\n                    updateIndexGroupName, IndexErrataTask.class);\n            systemDetail = new JobDetail(BuilderFactory.SERVER_TYPE,\n                    updateIndexGroupName, IndexSystemsTask.class);\n            hwDeviceDetail = new JobDetail(BuilderFactory.HARDWARE_DEVICE_TYPE,\n                    updateIndexGroupName, IndexHardwareDevicesTask.class);\n            snapshotTagDetail = new JobDetail(BuilderFactory.SNAPSHOT_TAG_TYPE,\n                    updateIndexGroupName, IndexSnapshotTagsTask.class);\n            serverCustomInfoDetail = new JobDetail(BuilderFactory.SERVER_CUSTOM_INFO_TYPE,\n                    updateIndexGroupName, IndexServerCustomInfoTask.class);\n\n            JobDataMap jobData = new JobDataMap();\n            jobData.put(\"indexManager\", indexManager);\n            jobData.put(\"databaseManager\", databaseManager);\n            jobData.put(\"configuration\", new Configuration());\n            \n            pkgDetail.setJobDataMap(jobData);\n            errataDetail.setJobDataMap(jobData);\n            systemDetail.setJobDataMap(jobData);\n            hwDeviceDetail.setJobDataMap(jobData);\n            snapshotTagDetail.setJobDataMap(jobData);\n            serverCustomInfoDetail.setJobDataMap(jobData);\n\n            scheduler.scheduleJob(pkgDetail, pkgTrigger);\n            scheduler.scheduleJob(errataDetail, errataTrigger);\n            scheduler.scheduleJob(systemDetail, systemTrigger);\n            scheduler.scheduleJob(hwDeviceDetail, hwDeviceTrigger);\n            scheduler.scheduleJob(snapshotTagDetail, snapshotTagTrigger);\n            scheduler.scheduleJob(serverCustomInfoDetail, serverCustomInfoTrigger);\n\n            scheduler.start();\n        }\n        catch (SchedulerException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":11207,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void start() {\n        try {\n            Configuration config = new Configuration();\n            \n            long interval = config.getInt(\"search.schedule.interval\", 300000);\n            log.info(\"ScheduleManager task interval is set to \" + interval);\n            int mode = SimpleTrigger.REPEAT_INDEFINITELY;\n            if (System.getProperties().get(\"isTesting\") != null) {\n                interval = 100;\n                mode = 0;\n            }\n            \n            JobDataMap jobData = new JobDataMap();\n            jobData.put(\"indexManager\", indexManager);\n            jobData.put(\"databaseManager\", databaseManager);\n            jobData.put(\"configuration\", new Configuration());\n            \n            scheduleJob(scheduler, BuilderFactory.PACKAGES_TYPE,\n                    mode, interval,\n                    IndexPackagesTask.class, jobData);\n            \n            scheduleJob(scheduler, BuilderFactory.ERRATA_TYPE,\n                    mode, interval,\n                    IndexErrataTask.class, jobData);\n            \n            scheduleJob(scheduler, BuilderFactory.SERVER_TYPE,\n                    mode, interval,\n                    IndexSystemsTask.class, jobData);\n\n            scheduleJob(scheduler, BuilderFactory.HARDWARE_DEVICE_TYPE,\n                    mode, interval,\n                    IndexHardwareDevicesTask.class, jobData);\n\n            scheduleJob(scheduler, BuilderFactory.SNAPSHOT_TAG_TYPE,\n                    mode, interval,\n                    IndexSnapshotTagsTask.class, jobData);\n\n            scheduleJob(scheduler, BuilderFactory.SERVER_CUSTOM_INFO_TYPE,\n                    mode, interval,\n                    IndexServerCustomInfoTask.class, jobData);\n\n            scheduler.start();\n        }\n        catch (SchedulerException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"62a0d4731bd18eb69d6a4a1fb2382233ed36c689","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.quotation.structure.Antiquotation\";\n  }","id":11208,"modified_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.lang.quotation.structure.Antiquotation\";\n  }","commit_id":"f86a1fa192a725a3770502ca133b7ecaeb804a9c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.quotation.structure.ListAntiquotation\";\n  }","id":11209,"modified_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.lang.quotation.structure.ListAntiquotation\";\n  }","commit_id":"f86a1fa192a725a3770502ca133b7ecaeb804a9c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.quotation.structure.Antiquotation\";\n  }","id":11210,"modified_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.lang.quotation.structure.Antiquotation\";\n  }","commit_id":"f86a1fa192a725a3770502ca133b7ecaeb804a9c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.quotation.structure.ListAntiquotation\";\n  }","id":11211,"modified_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.lang.quotation.structure.ListAntiquotation\";\n  }","commit_id":"f86a1fa192a725a3770502ca133b7ecaeb804a9c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.quotation.structure.PropertyAntiquotation\";\n  }","id":11212,"modified_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.lang.quotation.structure.PropertyAntiquotation\";\n  }","commit_id":"f86a1fa192a725a3770502ca133b7ecaeb804a9c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.quotation.structure.Quotation\";\n  }","id":11213,"modified_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.lang.quotation.structure.Quotation\";\n  }","commit_id":"f86a1fa192a725a3770502ca133b7ecaeb804a9c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.quotation.structure.ReferenceAntiquotation\";\n  }","id":11214,"modified_method":"public String getApplicableConceptFQName() {\n    return \"jetbrains.mps.lang.quotation.structure.ReferenceAntiquotation\";\n  }","commit_id":"f86a1fa192a725a3770502ca133b7ecaeb804a9c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n        @Override\n        public CallInstruction call(\n                @NotNull JetElement valueElement,\n                @NotNull ResolvedCall<?> resolvedCall,\n                @NotNull Map<PseudoValue, ReceiverValue> receiverValues,\n                @NotNull Map<PseudoValue, ValueParameterDescriptor> arguments\n        ) {\n            JetType returnType = resolvedCall.getResultingDescriptor().getReturnType();\n            CallInstruction instruction = CallInstruction.Factory.create(\n                    valueElement,\n                    getCurrentScope(),\n                    resolvedCall,\n                    receiverValues,\n                    arguments,\n                    returnType != null && KotlinBuiltIns.isNothing(returnType) ? null : valueFactory\n            );\n            add(instruction);\n            return instruction;\n        }","id":11215,"modified_method":"@NotNull\n        @Override\n        public CallInstruction call(\n                @NotNull JetElement valueElement,\n                @NotNull ResolvedCall<?> resolvedCall,\n                @NotNull Map<PseudoValue, ReceiverValue> receiverValues,\n                @NotNull Map<PseudoValue, ValueParameterDescriptor> arguments\n        ) {\n            JetType returnType = resolvedCall.getResultingDescriptor().getReturnType();\n            CallInstruction instruction = new CallInstruction(\n                    valueElement,\n                    getCurrentScope(),\n                    resolvedCall,\n                    receiverValues,\n                    arguments,\n                    returnType != null && KotlinBuiltIns.isNothing(returnType) ? null : valueFactory\n            );\n            add(instruction);\n            return instruction;\n        }","commit_id":"34cd2e0ac3a3da7f407e8d34c0956355e4f599aa","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n        @Override\n        public MergeInstruction merge(@NotNull JetExpression expression, @NotNull List<PseudoValue> inputValues) {\n            MergeInstruction instruction = MergeInstruction.Factory.create(expression, getCurrentScope(), inputValues, valueFactory);\n            add(instruction);\n            return instruction;\n        }","id":11216,"modified_method":"@NotNull\n        @Override\n        public MergeInstruction merge(@NotNull JetExpression expression, @NotNull List<PseudoValue> inputValues) {\n            MergeInstruction instruction = new MergeInstruction(expression, getCurrentScope(), inputValues, valueFactory);\n            add(instruction);\n            return instruction;\n        }","commit_id":"34cd2e0ac3a3da7f407e8d34c0956355e4f599aa","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n        private ReadValueInstruction read(\n                @NotNull JetExpression expression,\n                @Nullable ResolvedCall<?> resolvedCall,\n                @NotNull Map<PseudoValue, ReceiverValue> receiverValues\n        ) {\n            AccessTarget accessTarget = resolvedCall != null ? new AccessTarget.Call(resolvedCall) : AccessTarget.BlackBox.INSTANCE$;\n            ReadValueInstruction instruction = ReadValueInstruction.Factory.create(\n                    expression, getCurrentScope(), accessTarget, receiverValues, valueFactory\n            );\n            add(instruction);\n            return instruction;\n        }","id":11217,"modified_method":"@NotNull\n        private ReadValueInstruction read(\n                @NotNull JetExpression expression,\n                @Nullable ResolvedCall<?> resolvedCall,\n                @NotNull Map<PseudoValue, ReceiverValue> receiverValues\n        ) {\n            AccessTarget accessTarget = resolvedCall != null ? new AccessTarget.Call(resolvedCall) : AccessTarget.BlackBox.INSTANCE$;\n            ReadValueInstruction instruction = new ReadValueInstruction(\n                    expression, getCurrentScope(), accessTarget, receiverValues, valueFactory\n            );\n            add(instruction);\n            return instruction;\n        }","commit_id":"34cd2e0ac3a3da7f407e8d34c0956355e4f599aa","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n        @Override\n        public MagicInstruction magic(\n                @NotNull JetElement instructionElement,\n                @Nullable JetElement valueElement,\n                @NotNull List<PseudoValue> inputValues,\n                @NotNull Map<PseudoValue, TypePredicate> expectedTypes,\n                @NotNull MagicKind kind\n        ) {\n            MagicInstruction instruction = MagicInstruction.Factory.create(\n                    instructionElement, valueElement, getCurrentScope(), inputValues, expectedTypes, kind, valueFactory\n            );\n            add(instruction);\n            return instruction;\n        }","id":11218,"modified_method":"@NotNull\n        @Override\n        public MagicInstruction magic(\n                @NotNull JetElement instructionElement,\n                @Nullable JetElement valueElement,\n                @NotNull List<PseudoValue> inputValues,\n                @NotNull Map<PseudoValue, TypePredicate> expectedTypes,\n                @NotNull MagicKind kind\n        ) {\n            MagicInstruction instruction = new MagicInstruction(\n                    instructionElement, valueElement, getCurrentScope(), inputValues, expectedTypes, kind, valueFactory\n            );\n            add(instruction);\n            return instruction;\n        }","commit_id":"34cd2e0ac3a3da7f407e8d34c0956355e4f599aa","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Returns the chat panel corresponding to the given meta contact\n     *\n     * @param metaContact the meta contact.\n     * @return the chat panel corresponding to the given meta contact\n     */\n    public ChatPanel getContactChat(MetaContact metaContact)\n    {\n        synchronized (syncChat)\n        {\n            ChatSession chatSession = findChatSessionForDescriptor(metaContact);\n\n            if(chatSession != null)\n            {\n                return getChat(chatSession);\n            }\n            else\n            {\n                return createChat(metaContact);\n            }\n        }\n    }","id":11219,"modified_method":"/**\n     * Returns the chat panel corresponding to the given meta contact\n     *\n     * @param metaContact the meta contact.\n     * @return the chat panel corresponding to the given meta contact\n     */\n    public ChatPanel getContactChat(MetaContact metaContact)\n    {\n        synchronized (syncChat)\n        {\n            ChatPanel chatPanel = findChatPanelForDescriptor(metaContact);\n\n            return (chatPanel != null) ? chatPanel : createChat(metaContact);\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether there is an opened <tt>ChatPanel<\/tt> for a specific\n     * chat descriptor.\n     *\n     * @param descriptor the chat descriptor which is to be checked whether\n     * there is an opened <tt>ChatPanel<\/tt> for\n     * @return <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * specified chat descriptor; <tt>false<\/tt>, otherwise\n     */\n    private boolean isChatOpenedForDescriptor(Object descriptor)\n    {\n        synchronized (syncChat)\n        {\n            ChatSession chatSession\n                = findChatSessionForDescriptor(descriptor);\n\n            return ((chatSession != null) && getChat(chatSession).isShown());\n        }\n    }","id":11220,"modified_method":"/**\n     * Determines whether there is an opened <tt>ChatPanel<\/tt> for a specific\n     * chat descriptor.\n     *\n     * @param descriptor the chat descriptor which is to be checked whether\n     * there is an opened <tt>ChatPanel<\/tt> for\n     * @return <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * specified chat descriptor; <tt>false<\/tt>, otherwise\n     */\n    private boolean isChatOpenedForDescriptor(Object descriptor)\n    {\n        synchronized (syncChat)\n        {\n            ChatPanel chatPanel = findChatPanelForDescriptor(descriptor);\n\n            return ((chatPanel != null) && chatPanel.isShown());\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Finds the chat session corresponding to the given chat descriptor.\n     * \n     * @param descriptor The chat descriptor.\n     * @return The chat session corresponding to the given chat descriptor.\n     */\n    private ChatSession findChatSessionForDescriptor(Object descriptor)\n    {\n        for (ChatPanel chatPanel : chatPanels)\n        {\n            ChatSession chatSession = chatPanel.getChatSession();\n            if (chatSession.getDescriptor().equals(descriptor))\n                return chatSession;\n        }\n\n        return null;\n    }","id":11221,"modified_method":"/**\n     * Finds the <tt>ChatPanel<\/tt> corresponding to the given chat descriptor.\n     * \n     * @param descriptor the chat descriptor.\n     * @return the <tt>ChatPanel<\/tt> corresponding to the given chat descriptor\n     * if any; otherwise, <tt>null<\/tt>\n     */\n    private ChatPanel findChatPanelForDescriptor(Object descriptor)\n    {\n        for (ChatPanel chatPanel : chatPanels)\n            if (chatPanel.getChatSession().getDescriptor().equals(descriptor))\n                return chatPanel;\n        return null;\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>AdHocChatRoom<\/tt>.\n     * \n     * @param adHocChatRoom the <tt>AdHocChatRoom<\/tt>, for which the ad-hoc \n     * chat is about\n     * @return <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>AdHocChatRoom<\/tt>\n     */\n    public boolean isChatOpenedFor(AdHocChatRoom adHocChatRoom)\n    {\n        synchronized (syncChat)\n        {\n            for (ChatPanel chatPanel : chatPanels)\n            {\n                ChatSession chatSession = chatPanel.getChatSession();\n\n                Object descriptor = chatSession.getDescriptor();\n\n                if(descriptor instanceof AdHocChatRoomWrapper)\n                {\n                    AdHocChatRoomWrapper chatRoomWrapper\n                        = (AdHocChatRoomWrapper) descriptor;\n\n                    if(chatRoomWrapper.getAdHocChatRoomID()\n                            .equals(adHocChatRoom.getIdentifier())\n                        && getChat(chatSession).isShown())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n    }","id":11222,"modified_method":"/**\n     * Returns <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>AdHocChatRoom<\/tt>.\n     * \n     * @param adHocChatRoom the <tt>AdHocChatRoom<\/tt>, for which the ad-hoc \n     * chat is about\n     * @return <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>AdHocChatRoom<\/tt>\n     */\n    public boolean isChatOpenedFor(AdHocChatRoom adHocChatRoom)\n    {\n        synchronized (syncChat)\n        {\n            String adHocChatRoomID = adHocChatRoom.getIdentifier();\n\n            for (ChatPanel chatPanel : chatPanels)\n            {\n                Object descriptor = chatPanel.getChatSession().getDescriptor();\n\n                if(descriptor instanceof AdHocChatRoomWrapper)\n                {\n                    AdHocChatRoomWrapper chatRoomWrapper\n                        = (AdHocChatRoomWrapper) descriptor;\n\n                    if(chatRoomWrapper.getAdHocChatRoomID()\n                                .equals(adHocChatRoomID)\n                            && chatPanel.isShown())\n                        return true;\n                }\n            }\n            return false;\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>ChatRoom<\/tt>.\n     *\n     * @param chatRoom the <tt>ChatRoom<\/tt>, for which the chat is about\n     * @return <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>ChatRoom<\/tt>\n     */\n    public boolean isChatOpenedFor(ChatRoom chatRoom)\n    {\n        synchronized (syncChat)\n        {\n            for (ChatPanel chatPanel : chatPanels)\n            {\n                ChatSession chatSession = chatPanel.getChatSession();\n\n                Object descriptor = chatSession.getDescriptor();\n\n                if(descriptor instanceof ChatRoomWrapper)\n                {\n                    ChatRoomWrapper chatRoomWrapper\n                        = (ChatRoomWrapper) descriptor;\n\n                    if(chatRoomWrapper.getChatRoomID()\n                            .equals(chatRoom.getIdentifier())\n                        && getChat(chatSession).isShown())\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n    }","id":11223,"modified_method":"/**\n     * Returns <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>ChatRoom<\/tt>.\n     *\n     * @param chatRoom the <tt>ChatRoom<\/tt>, for which the chat is about\n     * @return <tt>true<\/tt> if there is an opened <tt>ChatPanel<\/tt> for the\n     * given <tt>ChatRoom<\/tt>\n     */\n    public boolean isChatOpenedFor(ChatRoom chatRoom)\n    {\n        synchronized (syncChat)\n        {\n            String chatRoomID = chatRoom.getIdentifier();\n\n            for (ChatPanel chatPanel : chatPanels)\n            {\n                Object descriptor = chatPanel.getChatSession().getDescriptor();\n\n                if(descriptor instanceof ChatRoomWrapper)\n                {\n                    ChatRoomWrapper chatRoomWrapper\n                        = (ChatRoomWrapper) descriptor;\n\n                    if(chatRoomWrapper.getChatRoomID().equals(chatRoomID)\n                            && chatPanel.isShown())\n                        return true;\n                }\n            }\n            return false;\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the chat panel corresponding to the given meta contact\n     *\n     * @param metaContact the meta contact.\n     * @param protocolContact the protocol specific contact\n     * @param escapedMessageID the message ID of the message that should be\n     * excluded from the history when the last one is loaded in the chat\n     * @return the chat panel corresponding to the given meta contact\n     */\n    public ChatPanel getContactChat(MetaContact metaContact,\n                                    Contact protocolContact,\n                                    String escapedMessageID)\n    {\n        synchronized (syncChat)\n        {\n            ChatSession chatSession = findChatSessionForDescriptor(metaContact);\n\n            if(chatSession != null)\n                return getChat(chatSession);\n            else\n                return createChat(  metaContact,\n                                    protocolContact,\n                                    escapedMessageID);\n        }\n    }","id":11224,"modified_method":"/**\n     * Returns the chat panel corresponding to the given meta contact\n     *\n     * @param metaContact the meta contact.\n     * @param protocolContact the protocol specific contact\n     * @param escapedMessageID the message ID of the message that should be\n     * excluded from the history when the last one is loaded in the chat\n     * @return the chat panel corresponding to the given meta contact\n     */\n    public ChatPanel getContactChat(MetaContact metaContact,\n                                    Contact protocolContact,\n                                    String escapedMessageID)\n    {\n        synchronized (syncChat)\n        {\n            ChatPanel chatPanel = findChatPanelForDescriptor(metaContact);\n\n            return\n                (chatPanel != null)\n                    ? chatPanel\n                    : createChat(\n                            metaContact,\n                            protocolContact,\n                            escapedMessageID);\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the chat panel corresponding to the given chat room.\n     *\n     * @param chatRoom the chat room, for which the chat panel is about\n     * @param escapedMessageID the message ID of the message that should be\n     * excluded from the history when the last one is loaded in the chat\n     * @return the chat panel corresponding to the given chat room\n     */\n    public ChatPanel getMultiChat(  ChatRoom chatRoom,\n                                    String escapedMessageID)\n    {\n        synchronized (syncChat)\n        {\n            ChatRoomList chatRoomList = GuiActivator.getUIService()\n                .getConferenceChatManager().getChatRoomList();\n\n            // Search in the chat room's list for a chat room that correspond\n            // to the given one.\n            ChatRoomWrapper chatRoomWrapper\n                = chatRoomList.findChatRoomWrapperFromChatRoom(chatRoom);\n\n            if (chatRoomWrapper == null)\n            {\n                ChatRoomProviderWrapper parentProvider\n                    = chatRoomList.findServerWrapperFromProvider(\n                        chatRoom.getParentProvider());\n\n                chatRoomWrapper = new ChatRoomWrapper(parentProvider, chatRoom);\n\n                chatRoomList.addChatRoom(chatRoomWrapper);\n            }\n\n            ChatSession chatSession\n                = findChatSessionForDescriptor(chatRoomWrapper);\n\n            if (chatSession != null)\n            {\n                return getChat(chatSession);\n            }\n\n            return createChat(chatRoomWrapper, escapedMessageID);\n        }\n    }","id":11225,"modified_method":"/**\n     * Returns the chat panel corresponding to the given chat room.\n     *\n     * @param chatRoom the chat room, for which the chat panel is about\n     * @param escapedMessageID the message ID of the message that should be\n     * excluded from the history when the last one is loaded in the chat\n     * @return the chat panel corresponding to the given chat room\n     */\n    public ChatPanel getMultiChat(  ChatRoom chatRoom,\n                                    String escapedMessageID)\n    {\n        synchronized (syncChat)\n        {\n            ChatRoomList chatRoomList = GuiActivator.getUIService()\n                .getConferenceChatManager().getChatRoomList();\n\n            // Search in the chat room's list for a chat room that correspond\n            // to the given one.\n            ChatRoomWrapper chatRoomWrapper\n                = chatRoomList.findChatRoomWrapperFromChatRoom(chatRoom);\n\n            if (chatRoomWrapper == null)\n            {\n                ChatRoomProviderWrapper parentProvider\n                    = chatRoomList.findServerWrapperFromProvider(\n                        chatRoom.getParentProvider());\n\n                chatRoomWrapper = new ChatRoomWrapper(parentProvider, chatRoom);\n\n                chatRoomList.addChatRoom(chatRoomWrapper);\n            }\n\n            ChatPanel chatPanel = findChatPanelForDescriptor(chatRoomWrapper);\n\n            return\n                (chatPanel != null)\n                    ? chatPanel\n                    : createChat(chatRoomWrapper, escapedMessageID);\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the chat panel corresponding to the given chat room wrapper.\n     *\n     * @param chatRoomWrapper the ad-hoc chat room wrapper, corresponding to the\n     * ad-hoc chat room for which the chat panel is about\n     * @return the chat panel corresponding to the given chat room\n     */\n    public ChatPanel getAdHocMultiChat(AdHocChatRoomWrapper chatRoomWrapper)\n    {\n        synchronized (syncChat)\n        {\n            ChatSession chatSession\n            = findChatSessionForDescriptor(chatRoomWrapper);\n\n            if(chatSession != null)\n            {\n                return getChat(chatSession);\n            }\n            else\n                return createChat(chatRoomWrapper);\n        }\n    }","id":11226,"modified_method":"/**\n     * Returns the chat panel corresponding to the given chat room wrapper.\n     *\n     * @param chatRoomWrapper the ad-hoc chat room wrapper, corresponding to the\n     * ad-hoc chat room for which the chat panel is about\n     * @return the chat panel corresponding to the given chat room\n     */\n    public ChatPanel getAdHocMultiChat(AdHocChatRoomWrapper chatRoomWrapper)\n    {\n        synchronized (syncChat)\n        {\n            ChatPanel chatPanel = findChatPanelForDescriptor(chatRoomWrapper);\n\n            return\n                (chatPanel != null) ? chatPanel : createChat(chatRoomWrapper);\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the chat panel corresponding to the given ad-hoc chat room.\n     *\n     * @param chatRoom the ad-hoc chat room, for which the chat panel is about\n     * @param escapedMessageID the message ID of the message that should be\n     * excluded from the history when the last one is loaded in the chat\n     * @return the chat panel corresponding to the given ad-hoc chat room\n     */\n    public ChatPanel getAdHocMultiChat( AdHocChatRoom     chatRoom,\n                                        String             escapedMessageID)\n    {\n        synchronized (syncChat)\n        {\n            AdHocChatRoomList chatRoomList = GuiActivator.getUIService()\n                .getConferenceChatManager().getAdHocChatRoomList();\n\n            // Search in the chat room's list for a chat room that correspond\n            // to the given one.\n            AdHocChatRoomWrapper chatRoomWrapper\n                = chatRoomList.findChatRoomWrapperFromAdHocChatRoom(chatRoom);\n\n            if (chatRoomWrapper == null)\n            {\n                AdHocChatRoomProviderWrapper parentProvider\n                    = chatRoomList.findServerWrapperFromProvider(\n                        chatRoom.getParentProvider());\n\n                chatRoomWrapper = \n                    new AdHocChatRoomWrapper(parentProvider, chatRoom);\n\n                chatRoomList.addAdHocChatRoom(chatRoomWrapper);\n            }\n\n            ChatSession chatSession\n                = findChatSessionForDescriptor(chatRoomWrapper);\n\n            if (chatSession != null)\n            {\n                return getChat(chatSession);\n            }\n\n            return createChat(chatRoomWrapper, escapedMessageID);\n        }\n    }","id":11227,"modified_method":"/**\n     * Returns the chat panel corresponding to the given ad-hoc chat room.\n     *\n     * @param chatRoom the ad-hoc chat room, for which the chat panel is about\n     * @param escapedMessageID the message ID of the message that should be\n     * excluded from the history when the last one is loaded in the chat\n     * @return the chat panel corresponding to the given ad-hoc chat room\n     */\n    public ChatPanel getAdHocMultiChat( AdHocChatRoom     chatRoom,\n                                        String             escapedMessageID)\n    {\n        synchronized (syncChat)\n        {\n            AdHocChatRoomList chatRoomList = GuiActivator.getUIService()\n                .getConferenceChatManager().getAdHocChatRoomList();\n\n            // Search in the chat room's list for a chat room that correspond\n            // to the given one.\n            AdHocChatRoomWrapper chatRoomWrapper\n                = chatRoomList.findChatRoomWrapperFromAdHocChatRoom(chatRoom);\n\n            if (chatRoomWrapper == null)\n            {\n                AdHocChatRoomProviderWrapper parentProvider\n                    = chatRoomList.findServerWrapperFromProvider(\n                        chatRoom.getParentProvider());\n\n                chatRoomWrapper = \n                    new AdHocChatRoomWrapper(parentProvider, chatRoom);\n\n                chatRoomList.addAdHocChatRoom(chatRoomWrapper);\n            }\n\n            ChatPanel chatPanel = findChatPanelForDescriptor(chatRoomWrapper);\n\n            return\n                (chatPanel != null)\n                    ? chatPanel\n                    : createChat(chatRoomWrapper, escapedMessageID);\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the chat panel corresponding to the given chat room wrapper.\n     *\n     * @param chatRoomWrapper the chat room wrapper, corresponding to the chat\n     * room for which the chat panel is about\n     * @return the chat panel corresponding to the given chat room\n     */\n    public ChatPanel getMultiChat(ChatRoomWrapper chatRoomWrapper)\n    {\n        synchronized (syncChat)\n        {\n            ChatSession chatSession\n                = findChatSessionForDescriptor(chatRoomWrapper);\n\n            if(chatSession != null)\n                return getChat(chatSession);\n            else\n                return createChat(chatRoomWrapper);\n        }\n    }","id":11228,"modified_method":"/**\n     * Returns the chat panel corresponding to the given chat room wrapper.\n     *\n     * @param chatRoomWrapper the chat room wrapper, corresponding to the chat\n     * room for which the chat panel is about\n     * @return the chat panel corresponding to the given chat room\n     */\n    public ChatPanel getMultiChat(ChatRoomWrapper chatRoomWrapper)\n    {\n        synchronized (syncChat)\n        {\n            ChatPanel chatPanel = findChatPanelForDescriptor(chatRoomWrapper);\n\n            return\n                (chatPanel != null) ? chatPanel : createChat(chatRoomWrapper);\n        }\n    }","commit_id":"ec41a24ce09275d6e288334fb3163eeff69c601c","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void testChild1_01() throws Exception {\n\t\t// tests only, if crossrefs in alternatives work\n\t\tEObject model = getModel(\"content str ref 'str'\");\n\t\tassertWithXtend(\"bug250313::Child1\", \"this.ref.metaType\", model);\n\t\tassertWithXtend(\"bug250313::Child1\", \"this.children.metaType\", model);\n\t\tassertWithXtend(\"'str'\", \"this.ref.name\", model);\n\t\tassertEquals(lexerRule, 2, convertCallCount);\n\t}","id":11229,"modified_method":"public void testChild1_01() throws Exception {\n\t\t// tests only, if crossrefs in alternatives work\n\t\tEObject model = getModel(\"content str ref 'str'\");\n\t\tassertWithXtend(\"org::eclipse::xtext::valueconverter::bug250313::impl::Child1Impl\", \"this.ref.metaType\", model);\n\t\tassertWithXtend(\"org::eclipse::xtext::valueconverter::bug250313::impl::Child1Impl\", \"this.children.metaType\", model);\n\t\tassertWithXtend(\"'str'\", \"this.ref.name\", model);\n\t\tassertEquals(lexerRule, 2, convertCallCount);\n\t}","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testChild2_01() throws Exception {\n\t\t// tests only, if crossrefs in alternatives work\n\t\tEObject model = getModel(\"content 'str' ref str\");\n\t\tassertWithXtend(\"bug250313::Child2\", \"this.ref.metaType\", model);\n\t\tassertWithXtend(\"bug250313::Child2\", \"this.children.metaType\", model);\n\t\tassertWithXtend(\"'str'\", \"this.ref.name\", model);\n\t\tassertEquals(lexerRule, 2, convertCallCount);\n\t}","id":11230,"modified_method":"public void testChild2_01() throws Exception {\n\t\t// tests only, if crossrefs in alternatives work\n\t\tEObject model = getModel(\"content 'str' ref str\");\n\t\tassertWithXtend(\"org::eclipse::xtext::valueconverter::bug250313::impl::Child2Impl\", \"this.ref.metaType\", model);\n\t\tassertWithXtend(\"org::eclipse::xtext::valueconverter::bug250313::impl::Child2Impl\", \"this.children.metaType\", model);\n\t\tassertWithXtend(\"'str'\", \"this.ref.name\", model);\n\t\tassertEquals(lexerRule, 2, convertCallCount);\n\t}","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testStuff() throws Exception {\n        Object parse = getModelAndExpect(\"foo bar\", 1);\n        assertWithXtend(\"'anotherSimpleTest::Foo'\", \"metaType.name\", parse);\n        assertWithXtend(\"'xtext::RuleCall'\", \"nameRefs.first().metaType.name\", parse);\n    }","id":11231,"modified_method":"public void testStuff() throws Exception {\n        Object parse = getModelAndExpect(\"foo bar\", 1);\n        assertWithXtend(\"'org::eclipse::xtext::metamodelreferencing::tests::anotherSimpleTest::impl::FooImpl'\", \n        \t\t\"metaType.name\", parse);\n        assertWithXtend(\"'org::eclipse::xtext::impl::RuleCallImpl'\", \"nameRefs.first().metaType.name\", parse);\n    }","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testStuff() throws Exception {\n        EObject parse = getModel(\"foo 'bar'\");\n        assertWithXtend(\"'simpleTest::Foo'\", \"metaType.name\", parse);\n        assertWithXtend(\"'otherTest::FooBar'\", \"nameRefs.first().metaType.name\", parse);\n    }","id":11232,"modified_method":"public void testStuff() throws Exception {\n        EObject parse = getModel(\"foo 'bar'\");\n        assertWithXtend(\"'org::eclipse::xtext::metamodelreferencing::tests::simpleTest::impl::FooImpl'\", \"metaType.name\", parse);\n        assertWithXtend(\"'org::eclipse::xtext::metamodelreferencing::tests::otherTest::impl::FooBarImpl'\", \"nameRefs.first().metaType.name\", parse);\n    }","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testParseError4() throws Exception {\n\t\tObject object = getModelAndExpect(\"grammar a import 'holla' foo returns y::Z : name=foo # 'foo'; bar : 'stuff'\", 5);\n\t\t//logger.debug(errors);\n\t\tassertWithXtend(\"'foo'\", \"rules.first().eAllContents.typeSelect(xtextTest::RuleCall).first().rule.name\", object);\n\t\tassertWithXtend(\"null\", \"rules.first().eAllContents.typeSelect(xtextTest::Keyword).first().name\", object);\n\t\tassertWithXtend(\"'stuff'\", \"rules.get(1).eAllContents.typeSelect(xtextTest::Keyword).first().value\", object);\n\t}","id":11233,"modified_method":"public void testParseError4() throws Exception {\n\t\tGrammar grammar = (Grammar) getModelAndExpect(\"grammar a import 'holla' foo returns y::Z : name=foo # 'foo'; bar : 'stuff'\", 5);\n\t\tAbstractRule rule = grammar.getRules().get(0);\n\t\tAssignment assignment = (Assignment) rule.getAlternatives();\n\t\tRuleCall call = (RuleCall) assignment.getTerminal();\n\t\tassertSame(rule, call.getRule());\n//\t\tassertWithXtend(\"'foo'\", \"rules.first().eAllContents().typeSelect(RuleCall).first().rule.name\", grammar);\n\t\t\n\t\tAbstractRule secondRule = grammar.getRules().get(1);\n\t\tKeyword stuff = (Keyword) secondRule.getAlternatives();\n\t\tassertEquals(\"stuff\", stuff.getValue());\n//\t\tassertWithXtend(\"'stuff'\", \"rules.get(1).eAllContents().typeSelect(Keyword).first().value\", grammar);\n\t}","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testParseError3() throws Exception {\n\t\tObject object = getModelAndExpect(\"grammar a import 'holla' foo returns y::Z : name=foo #############\", 4);\n\t\tassertWithXtend(\"'foo'\", \"rules.first().eAllContents.typeSelect(xtextTest::RuleCall).first().rule.name\", object);\n\t}","id":11234,"modified_method":"public void testParseError3() throws Exception {\n\t\tGrammar grammar = (Grammar) getModelAndExpect(\"grammar a import 'holla' foo returns y::Z : name=foo #############\", 4);\n\t\tAbstractRule rule = grammar.getRules().get(0);\n\t\tAssignment assignment = (Assignment) rule.getAlternatives();\n\t\tRuleCall call = (RuleCall) assignment.getTerminal();\n\t\tassertSame(rule, call.getRule());\n//\t\tassertWithXtend(\"'foo'\", \"rules.first().eAllContents().typeSelect(RuleCall).first().rule.name\", grammar);\n\t}","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testParseError2() throws Exception {\n\t\tObject object = getModelAndExpect(\"grammar a import 'holla' foo returns y::Z : name=foo #;\", 4);\n\t\tassertWithXtend(\"'foo'\", \"rules.first().eAllContents.typeSelect(xtextTest::RuleCall).first().rule.name\", object);\n\t}","id":11235,"modified_method":"public void testParseError2() throws Exception {\n\t\tGrammar grammar = (Grammar) getModelAndExpect(\"grammar a import 'holla' foo returns y::Z : name=foo #;\", 4);\n\t\tAbstractRule rule = grammar.getRules().get(0);\n\t\tAssignment assignment = (Assignment) rule.getAlternatives();\n\t\tRuleCall call = (RuleCall) assignment.getTerminal();\n\t\tassertSame(rule, call.getRule());\n//\t\tassertWithXtend(\"'foo'\", \"rules.first().eAllContents().typeSelect(RuleCall).first().rule.name\", grammar);\n\t}","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testParseCrossRef() throws Exception {\n\t\tGrammar model = (Grammar) getModel(\"grammar foo with org.eclipse.xtext.common.Terminals \" +\n\t\t\t\t\"generate foo 'bar' as boo \" +\n\t\t\t\t\"Model returns boo::Model : 'a' stuff+=Stuff*; \" +\n\t\t\t\t\"Stuff returns boo::Stuff : 'stuff' name=ID refersTo=[boo::Stuff];\");\n\t\tassertWithXtend(\"'boo'\", \"eAllContents.typeSelect(xtext::CrossReference).first().type.metamodel.alias\", model);\n\t\tassertWithXtend(\"'Stuff'\", \"eAllContents.typeSelect(xtext::CrossReference).first().type.classifier.name\", model);\n\t}","id":11236,"modified_method":"public void testParseCrossRef() throws Exception {\n\t\tGrammar model = (Grammar) getModel(\"grammar foo with org.eclipse.xtext.common.Terminals \" +\n\t\t\t\t\"generate foo 'bar' as boo \" +\n\t\t\t\t\"Model returns boo::Model : 'a' stuff+=Stuff*; \" +\n\t\t\t\t\"Stuff returns boo::Stuff : 'stuff' name=ID refersTo=[boo::Stuff];\");\n\t\tAbstractRule rule = model.getRules().get(1);\n\t\tGroup group = (Group) rule.getAlternatives();\n\t\tAssignment assignment = (Assignment) group.getTokens().get(2);\n\t\tCrossReference reference = (CrossReference) assignment.getTerminal();\n\t\tassertEquals(\"boo\", reference.getType().getMetamodel().getAlias());\n//\t\tassertWithXtend(\"'boo'\", \"eAllContents.typeSelect(xtext::CrossReference).first().type.metamodel.alias\", model);\n\t\tassertEquals(\"Stuff\", reference.getType().getClassifier().getName());\n//\t\tassertWithXtend(\"'Stuff'\", \"eAllContents.typeSelect(xtext::CrossReference).first().type.classifier.name\", model);\n\t}","commit_id":"a83f0a540c7ec6f9e9812f816b5d8f49746dd360","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n    * Retrieves the ETag for the Project\n    * \n    * This algorithm takes into account changes in Project Iterations as well.\n    * \n    * @param slug Project slug\n    * @return calculated EntityTag or null if project does not exist\n    */\n   public EntityTag generateTagForProject(String slug)\n   {\n      Integer projectVersion = (Integer) session.createQuery(\"select p.versionNum from HProject p where slug =:slug \" +\n      \t\t\"and status not in (:statusList)\")\n      \t\t.setParameter(\"slug\", slug)\n      \t\t.setParameterList(\"statusList\", new Object[]{OBSOLETE})\n      \t\t.uniqueResult();\n\n      if (projectVersion == null)\n         throw new NoSuchEntityException(\"Project '\" + slug + \"' not found.\");\n      ;\n\n      @SuppressWarnings(\"unchecked\")\n      List<Integer> iterationVersions = session.createQuery(\"select i.versionNum from HProjectIteration i \" +\n      \t\t\"where i.project.slug =:slug and status not in (:statusList)\")\n      \t\t.setParameter(\"slug\", slug)\n      \t\t.setParameterList(\"statusList\", new Object[]{OBSOLETE})\n      \t\t.list();\n\n      String hash = HashUtil.generateHash(projectVersion + ':' + StringUtils.join(iterationVersions, ':'));\n\n      return EntityTag.valueOf(hash);\n   }","id":11237,"modified_method":"/**\n    * Retrieves the ETag for the Project\n    * \n    * This algorithm takes into account changes in Project Iterations as well.\n    * \n    * @param slug Project slug\n    * @return calculated EntityTag\n    * @throws NoSuchEntityException if project is obsolete or does not exist\n    */\n   public EntityTag generateTagForProject(String slug)\n   {\n      Integer projectVersion = (Integer) session.createQuery(\"select p.versionNum from HProject p where slug =:slug \" +\n      \t\t\"and status not in (:statusList)\")\n      \t\t.setParameter(\"slug\", slug)\n      \t\t.setParameterList(\"statusList\", new Object[]{OBSOLETE})\n      \t\t.uniqueResult();\n\n      if (projectVersion == null)\n         throw new NoSuchEntityException(\"Project '\" + slug + \"' not found.\");\n\n      @SuppressWarnings(\"unchecked\")\n      List<Integer> iterationVersions = session.createQuery(\"select i.versionNum from HProjectIteration i \" +\n      \t\t\"where i.project.slug =:slug and status not in (:statusList)\")\n      \t\t.setParameter(\"slug\", slug)\n      \t\t.setParameterList(\"statusList\", new Object[]{OBSOLETE})\n      \t\t.list();\n\n      String hash = HashUtil.generateHash(projectVersion + ':' + StringUtils.join(iterationVersions, ':'));\n\n      return EntityTag.valueOf(hash);\n   }","commit_id":"2db427766456962c2d5adfd75ef4a08deb66edda","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Retrieves the ETag for the ProjectIteration\n    * \n    * @param projectSlug project slug\n    * @param iterationSlug iteration slug\n    * @return calculated EntityTag or null if iteration does not exist\n    */\n   public EntityTag generateETagForIteration(String projectSlug, String iterationSlug)\n   {\n      Integer iterationVersion = (Integer) session.createQuery(\"select i.versionNum from HProjectIteration i where i.slug =:islug and i.project.slug =:pslug \" +\n            \"and status not in (:statusList) and i.project.status not in (:statusList)\")\n            .setParameter(\"islug\", iterationSlug)\n            .setParameter(\"pslug\", projectSlug)\n            .setParameterList(\"statusList\", new Object[]{OBSOLETE})\n            .uniqueResult();\n\n      if (iterationVersion == null)\n         throw new NoSuchEntityException(\"Project Iteration '\" + iterationSlug + \"' not found.\");\n      ;\n\n      String hash = HashUtil.generateHash(String.valueOf(iterationVersion));\n\n      return EntityTag.valueOf(hash);\n   }","id":11238,"modified_method":"/**\n    * Retrieves the ETag for the ProjectIteration\n    * \n    * @param projectSlug project slug\n    * @param iterationSlug iteration slug\n    * @return calculated EntityTag\n    * @throw NoSuchEntityException if iteration is obsolete or does not exist\n    */\n   public EntityTag generateETagForIteration(String projectSlug, String iterationSlug)\n   {\n      Integer iterationVersion = (Integer) session.createQuery(\"select i.versionNum from HProjectIteration i where i.slug =:islug and i.project.slug =:pslug \" +\n            \"and status not in (:statusList) and i.project.status not in (:statusList)\")\n            .setParameter(\"islug\", iterationSlug)\n            .setParameter(\"pslug\", projectSlug)\n            .setParameterList(\"statusList\", new Object[]{OBSOLETE})\n            .uniqueResult();\n\n      if (iterationVersion == null)\n         throw new NoSuchEntityException(\"Project Iteration '\" + iterationSlug + \"' not found.\");\n\n      String hash = HashUtil.generateHash(String.valueOf(iterationVersion));\n\n      return EntityTag.valueOf(hash);\n   }","commit_id":"2db427766456962c2d5adfd75ef4a08deb66edda","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   @PUT\n   @Consumes( { MediaTypes.APPLICATION_ZANATA_PROJECT_ITERATION_XML, MediaTypes.APPLICATION_ZANATA_PROJECT_ITERATION_JSON, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n   public Response put(ProjectIteration project)\n   {\n\n      ResponseBuilder response;\n      EntityTag etag = null;\n      boolean changed = false;\n\n      HProject hProject = projectDAO.getBySlug(projectSlug);\n\n      if (hProject == null)\n      {\n         return Response.status(Status.NOT_FOUND).entity(\"Project '\" + projectSlug + \"' not found.\").build();\n      }\n      // Project is Obsolete\n      else if( ZanataUtil.in(hProject.getStatus(), OBSOLETE) )\n      {\n         return Response.status(Status.NOT_FOUND).entity(\"Project '\" + projectSlug + \"' is obsolete.\").build();\n      }\n      // Project is ReadOnly\n      else if( ZanataUtil.in(hProject.getStatus(), READONLY) )\n      {\n         return Response.status(Status.FORBIDDEN).entity(\"Project '\" + projectSlug + \"' is readOnly.\").build();\n      }\n\n      HProjectIteration hProjectIteration = projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n\n      if (hProjectIteration == null)\n      { // must be a create operation\n         response = request.evaluatePreconditions();\n         if (response != null)\n         {\n            return response.build();\n         }\n         hProjectIteration = new HProjectIteration();\n         hProjectIteration.setSlug(iterationSlug);\n         hProjectIteration.setProject((HIterationProject) hProject);\n         // pre-emptive entity permission check\n         // identity.checkPermission(hProject, \"add-iteration\");\n         identity.checkPermission(hProjectIteration, \"insert\");\n\n         response = Response.created(uri.getAbsolutePath());\n         changed = true;\n      }\n      // Iteration is Obsolete\n      else if( ZanataUtil.in(hProjectIteration.getStatus(), OBSOLETE) )\n      {\n         response = Response.status(Status.NOT_FOUND);\n         return response.entity(\"Obsolete Iteration.\").build();\n      }\n      // Iteration is ReadOnly\n      else if( ZanataUtil.in(hProjectIteration.getStatus(), READONLY) )\n      {\n         response = Response.status(Status.FORBIDDEN);\n         return response.entity(\"ReadOnly Iteration.\").build();\n      }\n      else\n      { // must be an update operation\n         // pre-emptive entity permission check\n         identity.checkPermission(hProjectIteration, \"update\");\n         etag = eTagUtils.generateETagForIteration(projectSlug, iterationSlug);\n         response = request.evaluatePreconditions(etag);\n         if (response != null)\n         {\n            return response.build();\n         }\n         response = Response.ok();\n      }\n\n\n      if (changed)\n      {\n         projectIterationDAO.makePersistent(hProjectIteration);\n         projectIterationDAO.flush();\n         etag = eTagUtils.generateETagForIteration(projectSlug, iterationSlug);\n      }\n      return response.tag(etag).build();\n\n   }","id":11239,"modified_method":"@Override\n   @PUT\n   @Consumes( { MediaTypes.APPLICATION_ZANATA_PROJECT_ITERATION_XML, MediaTypes.APPLICATION_ZANATA_PROJECT_ITERATION_JSON, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n   public Response put(ProjectIteration project)\n   {\n\n      ResponseBuilder response;\n      EntityTag etag = null;\n      boolean changed = false;\n\n      HProject hProject = projectDAO.getBySlug(projectSlug);\n\n      if (hProject == null)\n      {\n         return Response.status(Status.NOT_FOUND).entity(\"Project '\" + projectSlug + \"' not found.\").build();\n      }\n      // Project is Obsolete\n      else if( ZanataUtil.in(hProject.getStatus(), OBSOLETE) )\n      {\n         return Response.status(Status.NOT_FOUND).entity(\"Project '\" + projectSlug + \"' not found.\").build();\n      }\n      // Project is ReadOnly\n      else if( ZanataUtil.in(hProject.getStatus(), READONLY) )\n      {\n         return Response.status(Status.FORBIDDEN).entity(\"Project '\" + projectSlug + \"' is read-only.\").build();\n      }\n\n      HProjectIteration hProjectIteration = projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n\n      if (hProjectIteration == null)\n      { // must be a create operation\n         response = request.evaluatePreconditions();\n         if (response != null)\n         {\n            return response.build();\n         }\n         hProjectIteration = new HProjectIteration();\n         hProjectIteration.setSlug(iterationSlug);\n         hProjectIteration.setProject((HIterationProject) hProject);\n         // pre-emptive entity permission check\n         // identity.checkPermission(hProject, \"add-iteration\");\n         identity.checkPermission(hProjectIteration, \"insert\");\n\n         response = Response.created(uri.getAbsolutePath());\n         changed = true;\n      }\n      // Iteration is Obsolete\n      else if( ZanataUtil.in(hProjectIteration.getStatus(), OBSOLETE) )\n      {\n         return Response.status(Status.FORBIDDEN).entity(\"Project Iiteration '\" + projectSlug + \":\" + iterationSlug + \"' is obsolete.\").build();\n      }\n      // Iteration is ReadOnly\n      else if( ZanataUtil.in(hProjectIteration.getStatus(), READONLY) )\n      {\n         return Response.status(Status.FORBIDDEN).entity(\"Project Iteration '\" + projectSlug + \":\" + iterationSlug + \"' is read-only.\").build();\n      }\n      else\n      { // must be an update operation\n         // pre-emptive entity permission check\n         identity.checkPermission(hProjectIteration, \"update\");\n         etag = eTagUtils.generateETagForIteration(projectSlug, iterationSlug);\n         response = request.evaluatePreconditions(etag);\n         if (response != null)\n         {\n            return response.build();\n         }\n         response = Response.ok();\n      }\n\n\n      if (changed)\n      {\n         projectIterationDAO.makePersistent(hProjectIteration);\n         projectIterationDAO.flush();\n         etag = eTagUtils.generateETagForIteration(projectSlug, iterationSlug);\n      }\n      return response.tag(etag).build();\n\n   }","commit_id":"2db427766456962c2d5adfd75ef4a08deb66edda","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   @GET\n   @Produces( { MediaTypes.APPLICATION_ZANATA_PROJECT_XML, MediaTypes.APPLICATION_ZANATA_PROJECT_JSON, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n   public Response get()\n   {\n      EntityTag etag = eTagUtils.generateTagForProject(projectSlug);\n\n      ResponseBuilder response = request.evaluatePreconditions(etag);\n      if (response != null)\n      {\n         return response.build();\n      }\n\n      HProject hProject = projectDAO.getBySlug(projectSlug);\n      \n      // Obsolete projects are not exposed\n      if( ZanataUtil.in(hProject.getStatus(), OBSOLETE) )\n      {\n         return Response.status(Status.NOT_FOUND).build();\n      }\n\n      Project project = toResource(hProject, accept);\n      return Response.ok(project).tag(etag).build();\n   }","id":11240,"modified_method":"@Override\n   @GET\n   @Produces( { MediaTypes.APPLICATION_ZANATA_PROJECT_XML, MediaTypes.APPLICATION_ZANATA_PROJECT_JSON, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n   public Response get()\n   {\n      EntityTag etag = eTagUtils.generateTagForProject(projectSlug);\n\n      ResponseBuilder response = request.evaluatePreconditions(etag);\n      if (response != null)\n      {\n         return response.build();\n      }\n\n      HProject hProject = projectDAO.getBySlug(projectSlug);\n      Project project = toResource(hProject, accept);\n      return Response.ok(project).tag(etag).build();\n   }","commit_id":"2db427766456962c2d5adfd75ef4a08deb66edda","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @return 200 If the project was modified. 201 If the project was created.\n    *         404 If the project was not found, or is obsolete. 403 If the\n    *         project was not modified for some other reason (e.g. project is\n    *         ReadOnly).\n    */\n   @Override\n   @PUT\n   @Consumes( { MediaTypes.APPLICATION_ZANATA_PROJECT_XML, MediaTypes.APPLICATION_ZANATA_PROJECT_JSON, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n   public Response put(Project project)\n   {\n\n      ResponseBuilder response;\n      EntityTag etag;\n\n      HProject hProject = projectDAO.getBySlug(projectSlug);\n\n      if (hProject == null)\n      { // must be a create operation\n         response = request.evaluatePreconditions();\n         if (response != null)\n         {\n            return response.build();\n         }\n         hProject = new HIterationProject();\n         hProject.setSlug(projectSlug);\n         // pre-emptive entity permission check\n         identity.checkPermission(hProject, \"insert\");\n\n         response = Response.created(uri.getAbsolutePath());\n      }\n      // Project is Obsolete\n      else if( ZanataUtil.in(hProject.getStatus(), OBSOLETE) )\n      {\n         response = Response.status(Status.NOT_FOUND);\n         return response.entity(\"Obsolete Project.\").build();\n      }\n      // Project is ReadOnly\n      else if( ZanataUtil.in(hProject.getStatus(), READONLY) )\n      {\n         response = Response.status(Status.FORBIDDEN);\n         return response.entity(\"ReadOnly Project.\").build();\n      }\n      else\n      {  // must be an update operation\n         // pre-emptive entity permission check\n         identity.checkPermission(hProject, \"update\");\n         etag = eTagUtils.generateTagForProject(projectSlug);\n         response = request.evaluatePreconditions(etag);\n         if (response != null)\n         {\n            return response.build();\n         }\n\n         response = Response.ok();\n      }\n\n      transfer(project, hProject);\n\n      hProject = projectDAO.makePersistent(hProject);\n      projectDAO.flush();\n\n      if (identity != null && hProject.getMaintainers().isEmpty())\n      {\n         HAccount hAccount = accountDAO.getByUsername(identity.getCredentials().getUsername());\n         if (hAccount != null && hAccount.getPerson() != null)\n         {\n            hProject.getMaintainers().add(hAccount.getPerson());\n         }\n         projectDAO.flush();\n      }\n\n      etag = eTagUtils.generateTagForProject(projectSlug);\n      return response.tag(etag).build();\n\n   }","id":11241,"modified_method":"/**\n    * @return 200 If the project was modified. 201 If the project was created.\n    *         404 If the project was not found. 403 If the\n    *         project was not modified for some other reason (e.g. project is\n    *         obsolete or ReadOnly).\n    */\n   @Override\n   @PUT\n   @Consumes( { MediaTypes.APPLICATION_ZANATA_PROJECT_XML, MediaTypes.APPLICATION_ZANATA_PROJECT_JSON, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n   public Response put(Project project)\n   {\n\n      ResponseBuilder response;\n      EntityTag etag;\n\n      HProject hProject = projectDAO.getBySlug(projectSlug);\n\n      if (hProject == null)\n      { // must be a create operation\n         response = request.evaluatePreconditions();\n         if (response != null)\n         {\n            return response.build();\n         }\n         hProject = new HIterationProject();\n         hProject.setSlug(projectSlug);\n         // pre-emptive entity permission check\n         identity.checkPermission(hProject, \"insert\");\n\n         response = Response.created(uri.getAbsolutePath());\n      }\n      // Project is Obsolete\n      else if( ZanataUtil.in(hProject.getStatus(), OBSOLETE) )\n      {\n         return Response.status(Status.FORBIDDEN).entity(\"Project '\" + projectSlug + \"' is obsolete.\").build();\n      }\n      // Project is ReadOnly\n      else if( ZanataUtil.in(hProject.getStatus(), READONLY) )\n      {\n         return Response.status(Status.FORBIDDEN).entity(\"Project '\" + projectSlug + \"' is read-only.\").build();\n      }\n      else\n      {  // must be an update operation\n         // pre-emptive entity permission check\n         identity.checkPermission(hProject, \"update\");\n         etag = eTagUtils.generateTagForProject(projectSlug);\n         response = request.evaluatePreconditions(etag);\n         if (response != null)\n         {\n            return response.build();\n         }\n\n         response = Response.ok();\n      }\n\n      transfer(project, hProject);\n\n      hProject = projectDAO.makePersistent(hProject);\n      projectDAO.flush();\n\n      if (identity != null && hProject.getMaintainers().isEmpty())\n      {\n         HAccount hAccount = accountDAO.getByUsername(identity.getCredentials().getUsername());\n         if (hAccount != null && hAccount.getPerson() != null)\n         {\n            hProject.getMaintainers().add(hAccount.getPerson());\n         }\n         projectDAO.flush();\n      }\n\n      etag = eTagUtils.generateTagForProject(projectSlug);\n      return response.tag(etag).build();\n\n   }","commit_id":"2db427766456962c2d5adfd75ef4a08deb66edda","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public Object getSecuredEntity()\n   {\n      return retrieveIteration(null);\n   }","id":11242,"modified_method":"@Override\n   public Object getSecuredEntity()\n   {\n      return retrieveAndCheckIteration(false);\n   }","commit_id":"2db427766456962c2d5adfd75ef4a08deb66edda","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   @HEAD\n   public Response head()\n   {\n      HProjectIteration hProjectIteration = retrieveIteration(OPERATION_GET);\n      validateExtensions();\n      EntityTag etag = projectIterationDAO.getResourcesETag(hProjectIteration);\n      ResponseBuilder response = request.evaluatePreconditions(etag);\n      if (response != null)\n      {\n         return response.build();\n      }\n      return Response.ok().tag(etag).build();\n   }","id":11243,"modified_method":"@Override\n   @HEAD\n   public Response head()\n   {\n      HProjectIteration hProjectIteration = retrieveAndCheckIteration(false);\n      validateExtensions();\n      EntityTag etag = projectIterationDAO.getResourcesETag(hProjectIteration);\n      ResponseBuilder response = request.evaluatePreconditions(etag);\n      if (response != null)\n      {\n         return response.build();\n      }\n      return Response.ok().tag(etag).build();\n   }","commit_id":"2db427766456962c2d5adfd75ef4a08deb66edda","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n   * Unplan all issues linked to an action plan\n   */\n  private void unplanIssues(DefaultActionPlan actionPlan, UserSession userSession) {\n    // Get all issues linked to this plan (need to disable pagination and authorization check)\n    IssueQuery query = IssueQuery.builder().actionPlans(Arrays.asList(actionPlan.key())).requiredRole(null).build();\n    List<IssueDto> dtos = issueDao.selectIssues(query);\n    IssueChangeContext context = IssueChangeContext.createUser(new Date(), userSession.login());\n    List<DefaultIssue> issues = newArrayList();\n    for (IssueDto issueDto : dtos) {\n      DefaultIssue issue = issueDto.toDefaultIssue(workDurationFactory.createFromWorkingLong(issueDto.getTechnicalDebt()));\n      // Unplan issue\n      if (issueUpdater.plan(issue, null, context)) {\n        issues.add(issue);\n      }\n    }\n    // Save all issues\n    issueStorage.save(issues);\n  }","id":11244,"modified_method":"/**\n   * Unplan all issues linked to an action plan\n   */\n  private void unplanIssues(DefaultActionPlan actionPlan, UserSession userSession) {\n    // Get all issues linked to this plan (need to disable pagination and authorization check)\n    IssueQuery query = IssueQuery.builder().actionPlans(Arrays.asList(actionPlan.key())).requiredRole(null).build();\n    List<IssueDto> dtos = issueDao.selectIssues(query);\n    IssueChangeContext context = IssueChangeContext.createUser(new Date(), userSession.login());\n    List<DefaultIssue> issues = newArrayList();\n    for (IssueDto issueDto : dtos) {\n      Long debt = issueDto.getTechnicalDebt();\n      DefaultIssue issue = issueDto.toDefaultIssue(debt != null ? workDurationFactory.createFromWorkingLong(debt) : null);\n      // Unplan issue\n      if (issueUpdater.plan(issue, null, context)) {\n        issues.add(issue);\n      }\n    }\n    // Save all issues\n    issueStorage.save(issues);\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Issue findByKey(String key) {\n    IssueDto dto = issueDao.selectByKey(key);\n    return dto != null ? dto.toDefaultIssue(workDurationFactory.createFromWorkingLong(dto.getTechnicalDebt())) : null;\n  }","id":11245,"modified_method":"@CheckForNull\n  public Issue findByKey(String key) {\n    IssueDto dto = issueDao.selectByKey(key);\n    if (dto == null) {\n      return null;\n    }\n    Long debt = dto.getTechnicalDebt();\n    return dto.toDefaultIssue(debt != null ? workDurationFactory.createFromWorkingLong(debt) : null);\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"DefaultIssue findByKey(String issueKey, String requiredRole) {\n    IssueDto dto = issueDao.selectByKey(issueKey);\n    if (dto == null) {\n      throw new IllegalStateException(\"Unknown issue: \" + issueKey);\n    }\n    if (!UserSession.get().hasProjectPermission(requiredRole, dto.getRootComponentKey())) {\n      throw new IllegalStateException(\"User does not have the required role required to change the issue: \" + issueKey);\n    }\n\n    return dto.toDefaultIssue(workDurationFactory.createFromWorkingLong(dto.getTechnicalDebt()));\n  }","id":11246,"modified_method":"DefaultIssue findByKey(String issueKey, String requiredRole) {\n    IssueDto dto = issueDao.selectByKey(issueKey);\n    if (dto == null) {\n      throw new IllegalStateException(\"Unknown issue: \" + issueKey);\n    }\n    if (!UserSession.get().hasProjectPermission(requiredRole, dto.getRootComponentKey())) {\n      throw new IllegalStateException(\"User does not have the required role required to change the issue: \" + issueKey);\n    }\n\n    Long debt = dto.getTechnicalDebt();\n    return dto.toDefaultIssue(debt != null ? workDurationFactory.createFromWorkingLong(debt) : null);\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public IssueQueryResult find(IssueQuery query) {\n    LOG.debug(\"IssueQuery : {}\", query);\n    long start = System.currentTimeMillis();\n    SqlSession sqlSession = myBatis.openSession();\n    try {\n      // 1. Select the authorized ids of all the issues that match the query\n      List<IssueDto> authorizedIssues = issueDao.selectIssueIds(query, UserSession.get().userId(), sqlSession);\n\n      // 2. Sort all authorized issues\n      List<IssueDto> authorizedSortedIssues = sort(authorizedIssues, query, authorizedIssues.size());\n\n      // 3. Apply pagination\n      Paging paging = Paging.create(query.pageSize(), query.pageIndex(), authorizedSortedIssues.size());\n      Set<Long> pagedIssueIds = pagedIssueIds(authorizedSortedIssues, paging);\n\n      // 4. Load issues and their related data (rules, components, projects, comments, action plans, ...) and sort then again\n      List<IssueDto> pagedIssues = issueDao.selectByIds(pagedIssueIds, sqlSession);\n      List<IssueDto> pagedSortedIssues = sort(pagedIssues, query, authorizedIssues.size());\n\n      Map<String, DefaultIssue> issuesByKey = newHashMap();\n      List<Issue> issues = newArrayList();\n      Set<Integer> ruleIds = Sets.newHashSet();\n      Set<Long> componentIds = Sets.newHashSet();\n      Set<Long> projectIds = Sets.newHashSet();\n      Set<String> actionPlanKeys = Sets.newHashSet();\n      Set<String> users = Sets.newHashSet();\n      for (IssueDto dto : pagedSortedIssues) {\n        DefaultIssue defaultIssue = dto.toDefaultIssue(workDurationFactory.createFromWorkingLong(dto.getTechnicalDebt()));\n        issuesByKey.put(dto.getKee(), defaultIssue);\n        issues.add(defaultIssue);\n        ruleIds.add(dto.getRuleId());\n        componentIds.add(dto.getComponentId());\n        projectIds.add(dto.getRootComponentId());\n        actionPlanKeys.add(dto.getActionPlanKey());\n        if (dto.getReporter() != null) {\n          users.add(dto.getReporter());\n        }\n        if (dto.getAssignee() != null) {\n          users.add(dto.getAssignee());\n        }\n      }\n      List<DefaultIssueComment> comments = issueChangeDao.selectCommentsByIssues(sqlSession, issuesByKey.keySet());\n      for (DefaultIssueComment comment : comments) {\n        DefaultIssue issue = issuesByKey.get(comment.issueKey());\n        issue.addComment(comment);\n        if (comment.userLogin() != null) {\n          users.add(comment.userLogin());\n        }\n      }\n\n\n      return new DefaultIssueQueryResult(issues)\n        .setMaxResultsReached(authorizedIssues.size() == query.maxResults())\n        .addRules(hideRules(query) ? Collections.<Rule>emptyList() : findRules(ruleIds))\n        .addComponents(findComponents(componentIds))\n        .addProjects(findComponents(projectIds))\n        .addActionPlans(findActionPlans(actionPlanKeys))\n        .addUsers(findUsers(users))\n        .setPaging(paging);\n    } finally {\n      MyBatis.closeQuietly(sqlSession);\n      LOG.debug(\"IssueQuery execution time : {} ms\", System.currentTimeMillis() - start);\n    }\n  }","id":11247,"modified_method":"@Override\n  public IssueQueryResult find(IssueQuery query) {\n    LOG.debug(\"IssueQuery : {}\", query);\n    long start = System.currentTimeMillis();\n    SqlSession sqlSession = myBatis.openSession();\n    try {\n      // 1. Select the authorized ids of all the issues that match the query\n      List<IssueDto> authorizedIssues = issueDao.selectIssueIds(query, UserSession.get().userId(), sqlSession);\n\n      // 2. Sort all authorized issues\n      List<IssueDto> authorizedSortedIssues = sort(authorizedIssues, query, authorizedIssues.size());\n\n      // 3. Apply pagination\n      Paging paging = Paging.create(query.pageSize(), query.pageIndex(), authorizedSortedIssues.size());\n      Set<Long> pagedIssueIds = pagedIssueIds(authorizedSortedIssues, paging);\n\n      // 4. Load issues and their related data (rules, components, projects, comments, action plans, ...) and sort then again\n      List<IssueDto> pagedIssues = issueDao.selectByIds(pagedIssueIds, sqlSession);\n      List<IssueDto> pagedSortedIssues = sort(pagedIssues, query, authorizedIssues.size());\n\n      Map<String, DefaultIssue> issuesByKey = newHashMap();\n      List<Issue> issues = newArrayList();\n      Set<Integer> ruleIds = Sets.newHashSet();\n      Set<Long> componentIds = Sets.newHashSet();\n      Set<Long> projectIds = Sets.newHashSet();\n      Set<String> actionPlanKeys = Sets.newHashSet();\n      Set<String> users = Sets.newHashSet();\n      for (IssueDto dto : pagedSortedIssues) {\n        Long debt = dto.getTechnicalDebt();\n        DefaultIssue defaultIssue = dto.toDefaultIssue(debt != null ? workDurationFactory.createFromWorkingLong(debt) : null);\n        issuesByKey.put(dto.getKee(), defaultIssue);\n        issues.add(defaultIssue);\n        ruleIds.add(dto.getRuleId());\n        componentIds.add(dto.getComponentId());\n        projectIds.add(dto.getRootComponentId());\n        actionPlanKeys.add(dto.getActionPlanKey());\n        if (dto.getReporter() != null) {\n          users.add(dto.getReporter());\n        }\n        if (dto.getAssignee() != null) {\n          users.add(dto.getAssignee());\n        }\n      }\n      List<DefaultIssueComment> comments = issueChangeDao.selectCommentsByIssues(sqlSession, issuesByKey.keySet());\n      for (DefaultIssueComment comment : comments) {\n        DefaultIssue issue = issuesByKey.get(comment.issueKey());\n        issue.addComment(comment);\n        if (comment.userLogin() != null) {\n          users.add(comment.userLogin());\n        }\n      }\n\n\n      return new DefaultIssueQueryResult(issues)\n        .setMaxResultsReached(authorizedIssues.size() == query.maxResults())\n        .addRules(hideRules(query) ? Collections.<Rule>emptyList() : findRules(ruleIds))\n        .addComponents(findComponents(componentIds))\n        .addProjects(findComponents(projectIds))\n        .addActionPlans(findActionPlans(actionPlanKeys))\n        .addUsers(findUsers(users))\n        .setPaging(paging);\n    } finally {\n      MyBatis.closeQuietly(sqlSession);\n      LOG.debug(\"IssueQuery execution time : {} ms\", System.currentTimeMillis() - start);\n    }\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  private WorkDuration newValue(FieldDiffs fieldDiffs) {\n    for (Map.Entry<String, FieldDiffs.Diff> entry : fieldDiffs.diffs().entrySet()) {\n      if (entry.getKey().equals(IssueUpdater.TECHNICAL_DEBT)) {\n        Long newValue = entry.getValue().newValueLong();\n        return workDurationFactory.createFromWorkingLong(newValue);\n      }\n    }\n    return null;\n  }","id":11248,"modified_method":"@CheckForNull\n  private WorkDuration newValue(FieldDiffs fieldDiffs) {\n    for (Map.Entry<String, FieldDiffs.Diff> entry : fieldDiffs.diffs().entrySet()) {\n      if (entry.getKey().equals(IssueUpdater.TECHNICAL_DEBT)) {\n        Long newValue = entry.getValue().newValueLong();\n        if (newValue != null) {\n          return workDurationFactory.createFromWorkingLong(newValue);\n        }\n      }\n    }\n    return null;\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  private WorkDuration oldValue(FieldDiffs fieldDiffs) {\n    for (Map.Entry<String, FieldDiffs.Diff> entry : fieldDiffs.diffs().entrySet()) {\n      if (entry.getKey().equals(IssueUpdater.TECHNICAL_DEBT)) {\n        Long value = entry.getValue().oldValueLong();\n        return workDurationFactory.createFromWorkingLong(value);\n      }\n    }\n    return null;\n  }","id":11249,"modified_method":"@CheckForNull\n  private WorkDuration oldValue(FieldDiffs fieldDiffs) {\n    for (Map.Entry<String, FieldDiffs.Diff> entry : fieldDiffs.diffs().entrySet()) {\n      if (entry.getKey().equals(IssueUpdater.TECHNICAL_DEBT)) {\n        Long value = entry.getValue().oldValueLong();\n        if (value != null) {\n          return workDurationFactory.createFromWorkingLong(value);\n        }\n      }\n    }\n    return null;\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addIssuesOnDeletedComponents(Collection<DefaultIssue> issues) {\n    for (IssueDto deadDto : initialOpenIssues.selectAllIssues()) {\n      DefaultIssue dead = deadDto.toDefaultIssue(workDurationFactory.createFromWorkingLong(deadDto.getTechnicalDebt()));\n      updateUnmatchedIssue(dead, true);\n      issues.add(dead);\n    }\n    initialOpenIssues.clear();\n  }","id":11250,"modified_method":"private void addIssuesOnDeletedComponents(Collection<DefaultIssue> issues) {\n    for (IssueDto deadDto : initialOpenIssues.selectAllIssues()) {\n      Long debt = deadDto.getTechnicalDebt();\n      DefaultIssue dead = deadDto.toDefaultIssue(debt != null ? workDurationFactory.createFromWorkingLong(debt) : null);\n      updateUnmatchedIssue(dead, true);\n      issues.add(dead);\n    }\n    initialOpenIssues.clear();\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addUnmatched(Collection<IssueDto> unmatchedIssues, SourceHashHolder sourceHashHolder, Collection<DefaultIssue> issues) {\n    for (IssueDto unmatchedDto : unmatchedIssues) {\n      DefaultIssue unmatched = unmatchedDto.toDefaultIssue(workDurationFactory.createFromWorkingLong(unmatchedDto.getTechnicalDebt()));\n      if (StringUtils.isNotBlank(unmatchedDto.getReporter()) && !Issue.STATUS_CLOSED.equals(unmatchedDto.getStatus())) {\n        relocateManualIssue(unmatched, unmatchedDto, sourceHashHolder);\n      }\n      updateUnmatchedIssue(unmatched, false /* manual issues can be kept open */);\n      issues.add(unmatched);\n    }\n  }","id":11251,"modified_method":"private void addUnmatched(Collection<IssueDto> unmatchedIssues, SourceHashHolder sourceHashHolder, Collection<DefaultIssue> issues) {\n    for (IssueDto unmatchedDto : unmatchedIssues) {\n      Long debt = unmatchedDto.getTechnicalDebt();\n      DefaultIssue unmatched = unmatchedDto.toDefaultIssue(debt != null ? workDurationFactory.createFromWorkingLong(debt) : null);\n      if (StringUtils.isNotBlank(unmatchedDto.getReporter()) && !Issue.STATUS_CLOSED.equals(unmatchedDto.getStatus())) {\n        relocateManualIssue(unmatched, unmatchedDto, sourceHashHolder);\n      }\n      updateUnmatchedIssue(unmatched, false /* manual issues can be kept open */);\n      issues.add(unmatched);\n    }\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  public WorkDuration createFromWorkingLong(@Nullable Long duration) {\n    if (duration == null) {\n      return null;\n    }\n    return WorkDuration.createFromLong(duration, hoursInDay);\n  }","id":11252,"modified_method":"public WorkDuration createFromWorkingLong(Long duration) {\n    return WorkDuration.createFromLong(duration, hoursInDay);\n  }","commit_id":"83a09a40b13f600ed458f9c518b3026629bc6bc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Annotate for named entities -- note that this combines multiple NER tag sets, and some auxilliary things (like temporal tagging)\n   */\n  public Annotator ner(Properties properties) throws FileNotFoundException {\n\n    List<String> models = new ArrayList<String>();\n    String modelNames = properties.getProperty(\"ner.model\");\n    if (modelNames == null) {\n      modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n    }\n    if (modelNames.length() > 0) {\n      models.addAll(Arrays.asList(modelNames.split(\",\")));\n    }\n    if (models.isEmpty()) {\n      // Allow for no real NER model - can just use numeric classifiers or SUTime.\n      // Have to unset ner.model, so unlikely that people got here by accident.\n      System.err.println(\"WARNING: no NER models specified\");\n    }\n\n    boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                    NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                    NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n    boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                    NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                    NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n\n    boolean verbose = false;\n\n    String[] loadPaths = models.toArray(new String[models.size()]);\n\n    NERClassifierCombiner nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n        useSUTime, properties,\n        loadPaths);\n    return new NERCombinerAnnotator(nerCombiner, verbose);\n  }","id":11253,"modified_method":"/**\n   * Annotate for named entities -- note that this combines multiple NER tag sets, and some auxilliary things (like temporal tagging)\n   */\n  public Annotator ner(Properties properties) throws FileNotFoundException {\n\n    List<String> models = new ArrayList<String>();\n    String modelNames = properties.getProperty(\"ner.model\");\n    if (modelNames == null) {\n      modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n    }\n    if (modelNames.length() > 0) {\n      models.addAll(Arrays.asList(modelNames.split(\",\")));\n    }\n    if (models.isEmpty()) {\n      // Allow for no real NER model - can just use numeric classifiers or SUTime.\n      // Have to unset ner.model, so unlikely that people got here by accident.\n      System.err.println(\"WARNING: no NER models specified\");\n    }\n\n    boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                    NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                    NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n    boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                    NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                    NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n\n    boolean verbose = false;\n\n    String[] loadPaths = models.toArray(new String[models.size()]);\n\n    NERClassifierCombiner nerCombiner = new NERClassifierCombiner(applyNumericClassifiers, useSUTime, properties, loadPaths);\n\n    int nThreads = PropertiesUtils.getInt(properties, \"ner.nthreads\", PropertiesUtils.getInt(properties, \"nthreads\", 1));\n    long maxTime = PropertiesUtils.getLong(properties, \"ner.maxtime\", 0);\n\n    return new NERCombinerAnnotator(nerCombiner, verbose, nThreads, maxTime);\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Initialize using values in Properties file.\n   *\n   * @param props Properties, with the special format of column.flag used in ColumnDataClassifier\n   * @return An array of flags for each data column, with additional global flags in element [0]\n   */\n  private Flags[] setProperties(Properties props) {\n    Flags[] myFlags;\n    boolean myUsesRealValues = false;\n\n    Pattern prefix;\n    try {\n      prefix = Pattern.compile(\"([0-9]+)\\\\.(.*)\");\n    } catch (PatternSyntaxException pse) {\n      throw new RuntimeException(pse);\n    }\n\n    // if we are loading a classifier then we have to load it before we do anything\n    // else and have its Properties be the defaults that can then be overridden by\n    // other command-line arguments\n    String loadPath = props.getProperty(\"loadClassifier\");\n    if (loadPath != null) {\n      System.err.println(\"Loading classifier from \" + loadPath + \"...\");\n      ObjectInputStream ois = null;\n      try {\n        // load the classifier\n        ois = IOUtils.readStreamFromString(loadPath);\n        classifier = ErasureUtils.<LinearClassifier<String,String>>uncheckedCast(ois.readObject());\n        myFlags = (Flags[]) ois.readObject();\n        assert flags.length > 0;\n        System.err.println(\"Done.\");\n      } catch (Exception e) {\n        throw new RuntimeIOException(\"Error deserializing \" + loadPath, e);\n      } finally {\n        IOUtils.closeIgnoringExceptions(ois);\n      }\n    } else {\n      myFlags = new Flags[1];\n      myFlags[0] = new Flags();  // initialize zero column flags used for global flags; it can't be null\n    }\n\n    for (Enumeration<?> e = props.propertyNames(); e.hasMoreElements();) {\n      String key = (String) e.nextElement();\n      String val = props.getProperty(key);\n      int col = 0;  // the default (first after class)\n      // System.err.println(key + \" = \" + val);\n      Matcher matcher = prefix.matcher(key);\n      if (matcher.matches()) {\n        col = Integer.parseInt(matcher.group(1));\n        key = matcher.group(2);\n      }\n      if (col >= myFlags.length) {\n        Flags[] newFl = new Flags[col + 1];\n        System.arraycopy(myFlags, 0, newFl, 0, myFlags.length);\n        myFlags = newFl;\n      }\n      if (myFlags[col] == null) {\n        myFlags[col] = new Flags();\n      }\n\n      if (key.equals(\"useString\")) {\n        myFlags[col].useString = Boolean.parseBoolean(val);\n      } else if (key.equals(\"binnedLengths\")) {\n        if (val != null) {\n          String[] binnedLengthStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedLengths = new int[binnedLengthStrs.length];\n          for (int i = 0; i < myFlags[col].binnedLengths.length; i++) {\n            myFlags[col].binnedLengths[i] = Integer.parseInt(binnedLengthStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedLengthsStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedLengthsCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"countChars\")) {\n        myFlags[col].countChars = val.toCharArray();\n      } else if (key.equals(\"countCharsBins\")) {\n        if (val != null) {\n          String[] binnedCountStrs = val.split(\"[, ]+\");\n          myFlags[col].countCharsBins = new int[binnedCountStrs.length];\n          for (int i = 0; i < binnedCountStrs.length; i++) {\n            myFlags[col].countCharsBins[i] = Integer.parseInt(binnedCountStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValues\")) {\n        if (val != null) {\n          String[] binnedValuesStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedValues = new double[binnedValuesStrs.length];\n          for (int i = 0; i < myFlags[col].binnedValues.length; i++) {\n            myFlags[col].binnedValues[i] = Double.parseDouble(binnedValuesStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValuesNaN\")) {\n        myFlags[col].binnedValuesNaN = Double.parseDouble(val);\n      } else if (key.equals(\"binnedValuesStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedValuesCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"useNGrams\")) {\n        myFlags[col].useNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"usePrefixSuffixNGrams\")) {\n        myFlags[col].usePrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitNGrams\")) {\n        myFlags[col].useSplitNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"wordShape\")) {\n        myFlags[col].wordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"splitWordShape\")) {\n        myFlags[col].splitWordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"useSplitPrefixSuffixNGrams\")) {\n        myFlags[col].useSplitPrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercaseNGrams\")) {\n        myFlags[col].lowercaseNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercase\")) {\n        myFlags[col].lowercase = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useLowercaseSplitWords\")) {\n        myFlags[col].useLowercaseSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSum\")) {\n        myFlags[col].useSum = Boolean.parseBoolean(val);\n      } else if (key.equals(\"tolerance\")) {\n        myFlags[col].tolerance = Double.parseDouble(val);\n      } else if (key.equals(\"printFeatures\")) {\n        myFlags[col].printFeatures = val;\n      } else if (key.equals(\"printClassifier\")) {\n        myFlags[col].printClassifier = val;\n      } else if (key.equals(\"printClassifierParam\")) {\n        myFlags[col].printClassifierParam = Integer.parseInt(val);\n      } else if (key.equals(\"exitAfterTrainingFeaturization\")) {\n        myFlags[col].exitAfterTrainingFeaturization = Boolean.parseBoolean(val);\n      } else if (key.equals(\"intern\") || key.equals(\"intern2\")) {\n        myFlags[col].intern = Boolean.parseBoolean(val);\n      } else if (key.equals(\"cacheNGrams\")) {\n        myFlags[col].cacheNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useClassifierFactory\")) {\n        myFlags[col].useClassifierFactory = val;\n      } else if (key.equals(\"classifierFactoryArgs\")) {\n        myFlags[col].classifierFactoryArgs = val;\n      } else if (key.equals(\"useNB\")) {\n        myFlags[col].useNB = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useBinary\")) {\n        myFlags[col].useBinary = Boolean.parseBoolean(val);\n      } else if (key.equals(\"l1reg\")) {\n        myFlags[col].l1reg = Double.parseDouble(val);\n      } else if (key.equals(\"useAdaptL1\")) {\n        myFlags[col].useAdaptL1 = Boolean.parseBoolean(val);\n      } else if (key.equals(\"limitFeatures\")) {\n        myFlags[col].limitFeatures = Integer.parseInt(val);\n      } else if (key.equals(\"l1regmin\")) {\n        myFlags[col].l1regmin = Double.parseDouble(val);\n      } else if (key.equals(\"l1regmax\")) {\n        myFlags[col].l1regmax = Double.parseDouble(val);\n      } else if (key.equals(\"limitFeaturesLabels\")) {\n        myFlags[col].limitFeaturesLabels = val;\n      } else if (key.equals(\"featureWeightThreshold\")) {\n        myFlags[col].featureWeightThreshold = Double.parseDouble(val);\n      } else if (key.equals(\"useClassFeature\")) {\n        myFlags[col].useClassFeature = Boolean.parseBoolean(val);\n      } else if (key.equals(\"featureMinimumSupport\")) {\n        myFlags[col].featureMinimumSupport = Integer.parseInt(val);\n      } else if (key.equals(\"prior\")) {\n        if (val.equalsIgnoreCase(\"no\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.NULL.ordinal();\n        } else if (val.equalsIgnoreCase(\"huber\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.HUBER.ordinal();\n        } else if (val.equalsIgnoreCase(\"quadratic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n        } else if (val.equalsIgnoreCase(\"quartic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n        } else {\n          try {\n            myFlags[col].prior = Integer.parseInt(val);\n          } catch (NumberFormatException nfe) {\n            System.err.println(\"Unknown prior \" + val + \"; using none.\");\n          }\n        }\n      } else if (key.equals(\"sigma\")) {\n        myFlags[col].sigma = Double.parseDouble(val);\n      } else if (key.equals(\"epsilon\")) {\n        myFlags[col].epsilon = Double.parseDouble(val);\n      } else if (key.equals(\"maxNGramLeng\")) {\n        myFlags[col].maxNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minNGramLeng\")) {\n        myFlags[col].minNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"partialNGramRegexp\")) {\n        myFlags[col].partialNGramRegexp = val;\n        try {\n          myFlags[col].partialNGramPattern = Pattern.compile(myFlags[col].partialNGramRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed partialNGramPattern: \" + myFlags[col].partialNGramPattern);\n          myFlags[col].partialNGramRegexp = null;\n        }\n      } else if (key.equals(\"splitWordsRegexp\")) {\n        try {\n          myFlags[col].splitWordsPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsTokenizerRegexp\")) {\n        try {\n          myFlags[col].splitWordsTokenizerPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsTokenizerRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsIgnoreRegexp\")) {\n        String trimVal = val.trim();\n        if (trimVal.isEmpty()) {\n          myFlags[col].splitWordsIgnorePattern = null;\n        } else {\n          try {\n            myFlags[col].splitWordsIgnorePattern = Pattern.compile(trimVal);\n          } catch (PatternSyntaxException pse) {\n            System.err.println(\"Ill-formed splitWordsIgnoreRegexp: \" + trimVal);\n          }\n        }\n      } else if (key.equals(\"useSplitWords\")) {\n        myFlags[col].useSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordPairs\")) {\n        myFlags[col].useSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordPairs\")) {\n        myFlags[col].useAllSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordTriples\")) {\n        myFlags[col].useAllSplitWordTriples = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordNGrams\")) {\n        myFlags[col].useSplitWordNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"maxWordNGramLeng\")) {\n        myFlags[col].maxWordNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minWordNGramLeng\")) {\n        myFlags[col].minWordNGramLeng = Integer.parseInt(val);\n        if (myFlags[col].minWordNGramLeng < 1) {\n          System.err.println(\"minWordNGramLeng set to \" + myFlags[col].minWordNGramLeng + \", resetting to 1\");\n          myFlags[col].minWordNGramLeng = 1;\n        }\n      } else if (key.equals(\"wordNGramBoundaryRegexp\")) {\n        myFlags[col].wordNGramBoundaryRegexp = val;\n        try {\n          myFlags[col].wordNGramBoundaryPattern = Pattern.compile(myFlags[col].wordNGramBoundaryRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed wordNGramBoundary regexp: \" + myFlags[col].wordNGramBoundaryRegexp);\n          myFlags[col].wordNGramBoundaryRegexp = null;\n        }\n      } else if (key.equals(\"useSplitFirstLastWords\")) {\n        myFlags[col].useSplitFirstLastWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"loadClassifier\")) {\n        myFlags[col].loadClassifier = val;\n      } else if (key.equals(\"serializeTo\")) {\n        Flags.serializeTo = val;\n      } else if (key.equals(\"printTo\")) {\n        Flags.printTo = val;\n      } else if (key.equals(\"trainFile\")) {\n        Flags.trainFile = val;\n      } else if (key.equals(\"displayAllAnswers\")) {\n        Flags.displayAllAnswers = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFile\")) {\n        myFlags[col].testFile = val;\n      } else if (key.equals(\"trainFromSVMLight\")) {\n        Flags.trainFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFromSVMLight\")) {\n        Flags.testFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"encoding\")) {\n        Flags.encoding = val;\n      } else if (key.equals(\"printSVMLightFormatTo\")) {\n        Flags.printSVMLightFormatTo = val;\n      } else if (key.equals(\"displayedColumn\")) {\n        myFlags[col].displayedColumn = Integer.parseInt(val);\n      } else if (key.equals(\"groupingColumn\")) {\n        myFlags[col].groupingColumn = Integer.parseInt(val);\n        // System.err.println(\"Grouping column is \" + (myFlags[col].groupingColumn));\n      } else if (key.equals(\"rankingScoreColumn\")) {\n        myFlags[col].rankingScoreColumn = Integer.parseInt(val);\n        // System.err.println(\"Ranking score column is \" + (myFlags[col].rankingScoreColumn));\n      } else if (key.equals(\"rankingAccuracyClass\")) {\n        myFlags[col].rankingAccuracyClass = val;\n      } else if (key.equals(\"goldAnswerColumn\")) {\n        myFlags[col].goldAnswerColumn = Integer.parseInt(val);\n        // System.err.println(\"Gold answer column is \" + (myFlags[col].goldAnswerColumn));  // it's a nuisance to print this when used programmatically\n      } else if (key.equals(\"useQN\")) {\n        myFlags[col].useQN = Boolean.parseBoolean(val);\n      } else if (key.equals(\"QNsize\")) {\n        myFlags[col].QNsize = Integer.parseInt(val);\n      } else if (key.equals(\"featureFormat\")) {\n        myFlags[col].featureFormat = Boolean.parseBoolean(val);\n      } else if (key.equals(\"significantColumnId\")) {\n        myFlags[col].significantColumnId = Boolean.parseBoolean(val);\n      } else if (key.equals(\"justify\")) {\n        myFlags[col].justify = Boolean.parseBoolean(val);\n      }  else if (key.equals(\"realValued\")) {\n        myFlags[col].isRealValued = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].isRealValued;\n      } else if (key.equals(\"logTransform\")) {\n        myFlags[col].logTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logTransform;\n      } else if (key.equals(\"logitTransform\")) {\n        myFlags[col].logitTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logitTransform;\n      } else if (key.equals(\"sqrtTransform\")) {\n        myFlags[col].sqrtTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].sqrtTransform;\n      } else if (key.equals(\"filename\")) {\n        myFlags[col].filename = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biased\")) {\n        myFlags[col].biased = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biasedHyperplane\")) {\n        // System.err.println(\"Constraints is \" + constraints);\n        if (val != null && val.trim().length() > 0) {\n          String[] bits = val.split(\"[, ]+\");\n          myFlags[col].biasedHyperplane = new ClassicCounter<String>();\n          for (int i = 0; i < bits.length; i += 2) {\n            myFlags[col].biasedHyperplane.setCount(bits[i], Double.parseDouble(bits[i + 1]));\n          }\n        }\n        // System.err.println(\"Biased Hyperplane is \" + biasedHyperplane);\n      } else if (key.equals(\"crossValidationFolds\")) {\n        myFlags[col].crossValidationFolds = Integer.parseInt(val);\n      } else if (key.equals(\"shuffleTrainingData\")) {\n        myFlags[col].shuffleTrainingData = Boolean.parseBoolean(val);\n      } else if (key.equals(\"shuffleSeed\")) {\n        myFlags[col].shuffleSeed = Long.parseLong(val);\n      } else if ( ! key.isEmpty() && ! key.equals(\"prop\")) {\n        System.err.println(\"Unknown property: |\" + key + '|');\n      }\n    }\n    myFlags[0].usesRealValues = myUsesRealValues;\n    return myFlags;\n  }","id":11254,"modified_method":"/**\n   * Initialize using values in Properties file.\n   *\n   * @param props Properties, with the special format of column.flag used in ColumnDataClassifier\n   * @return An array of flags for each data column, with additional global flags in element [0]\n   */\n  private Flags[] setProperties(Properties props) {\n    Flags[] myFlags;\n    boolean myUsesRealValues = false;\n\n    Pattern prefix;\n    try {\n      prefix = Pattern.compile(\"([0-9]+)\\\\.(.*)\");\n    } catch (PatternSyntaxException pse) {\n      throw new RuntimeException(pse);\n    }\n\n    // if we are loading a classifier then we have to load it before we do anything\n    // else and have its Properties be the defaults that can then be overridden by\n    // other command-line arguments\n    String loadPath = props.getProperty(\"loadClassifier\");\n    if (loadPath != null) {\n      System.err.println(\"Loading classifier from \" + loadPath + \"...\");\n      ObjectInputStream ois = null;\n      try {\n        // load the classifier\n        ois = IOUtils.readStreamFromString(loadPath);\n        classifier = ErasureUtils.<LinearClassifier<String,String>>uncheckedCast(ois.readObject());\n        myFlags = (Flags[]) ois.readObject();\n        assert flags.length > 0;\n        System.err.println(\"Done.\");\n      } catch (Exception e) {\n        throw new RuntimeIOException(\"Error deserializing \" + loadPath, e);\n      } finally {\n        IOUtils.closeIgnoringExceptions(ois);\n      }\n    } else {\n      myFlags = new Flags[1];\n      myFlags[0] = new Flags();  // initialize zero column flags used for global flags; it can't be null\n    }\n\n    for (Enumeration<?> e = props.propertyNames(); e.hasMoreElements();) {\n      String key = (String) e.nextElement();\n      String val = props.getProperty(key);\n      int col = 0;  // the default (first after class)\n      // System.err.println(key + \" = \" + val);\n      Matcher matcher = prefix.matcher(key);\n      if (matcher.matches()) {\n        col = Integer.parseInt(matcher.group(1));\n        key = matcher.group(2);\n      }\n      if (col >= myFlags.length) {\n        Flags[] newFl = new Flags[col + 1];\n        System.arraycopy(myFlags, 0, newFl, 0, myFlags.length);\n        myFlags = newFl;\n      }\n      if (myFlags[col] == null) {\n        myFlags[col] = new Flags();\n      }\n\n      if (key.equals(\"useString\")) {\n        myFlags[col].useString = Boolean.parseBoolean(val);\n      } else if (key.equals(\"binnedLengths\")) {\n        if (val != null) {\n          String[] binnedLengthStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedLengths = new int[binnedLengthStrs.length];\n          for (int i = 0; i < myFlags[col].binnedLengths.length; i++) {\n            myFlags[col].binnedLengths[i] = Integer.parseInt(binnedLengthStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedLengthsStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedLengthsCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"countChars\")) {\n        myFlags[col].countChars = val.toCharArray();\n      } else if (key.equals(\"countCharsBins\")) {\n        if (val != null) {\n          String[] binnedCountStrs = val.split(\"[, ]+\");\n          myFlags[col].countCharsBins = new int[binnedCountStrs.length];\n          for (int i = 0; i < binnedCountStrs.length; i++) {\n            myFlags[col].countCharsBins[i] = Integer.parseInt(binnedCountStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValues\")) {\n        if (val != null) {\n          String[] binnedValuesStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedValues = new double[binnedValuesStrs.length];\n          for (int i = 0; i < myFlags[col].binnedValues.length; i++) {\n            myFlags[col].binnedValues[i] = Double.parseDouble(binnedValuesStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValuesNaN\")) {\n        myFlags[col].binnedValuesNaN = Double.parseDouble(val);\n      } else if (key.equals(\"binnedValuesStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedValuesCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"useNGrams\")) {\n        myFlags[col].useNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"usePrefixSuffixNGrams\")) {\n        myFlags[col].usePrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitNGrams\")) {\n        myFlags[col].useSplitNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"wordShape\")) {\n        myFlags[col].wordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"splitWordShape\")) {\n        myFlags[col].splitWordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"useSplitPrefixSuffixNGrams\")) {\n        myFlags[col].useSplitPrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercaseNGrams\")) {\n        myFlags[col].lowercaseNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercase\")) {\n        myFlags[col].lowercase = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useLowercaseSplitWords\")) {\n        myFlags[col].useLowercaseSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSum\")) {\n        myFlags[col].useSum = Boolean.parseBoolean(val);\n      } else if (key.equals(\"tolerance\")) {\n        myFlags[col].tolerance = Double.parseDouble(val);\n      } else if (key.equals(\"printFeatures\")) {\n        myFlags[col].printFeatures = val;\n      } else if (key.equals(\"printClassifier\")) {\n        myFlags[col].printClassifier = val;\n      } else if (key.equals(\"printClassifierParam\")) {\n        myFlags[col].printClassifierParam = Integer.parseInt(val);\n      } else if (key.equals(\"exitAfterTrainingFeaturization\")) {\n        myFlags[col].exitAfterTrainingFeaturization = Boolean.parseBoolean(val);\n      } else if (key.equals(\"intern\") || key.equals(\"intern2\")) {\n        myFlags[col].intern = Boolean.parseBoolean(val);\n      } else if (key.equals(\"cacheNGrams\")) {\n        myFlags[col].cacheNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useClassifierFactory\")) {\n        myFlags[col].useClassifierFactory = val;\n      } else if (key.equals(\"classifierFactoryArgs\")) {\n        myFlags[col].classifierFactoryArgs = val;\n      } else if (key.equals(\"useNB\")) {\n        myFlags[col].useNB = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useBinary\")) {\n        myFlags[col].useBinary = Boolean.parseBoolean(val);\n      } else if (key.equals(\"l1reg\")) {\n        myFlags[col].l1reg = Double.parseDouble(val);\n      } else if (key.equals(\"useAdaptL1\")) {\n        myFlags[col].useAdaptL1 = Boolean.parseBoolean(val);\n      } else if (key.equals(\"limitFeatures\")) {\n        myFlags[col].limitFeatures = Integer.parseInt(val);\n      } else if (key.equals(\"l1regmin\")) {\n        myFlags[col].l1regmin = Double.parseDouble(val);\n      } else if (key.equals(\"l1regmax\")) {\n        myFlags[col].l1regmax = Double.parseDouble(val);\n      } else if (key.equals(\"limitFeaturesLabels\")) {\n        myFlags[col].limitFeaturesLabels = val;\n      } else if (key.equals(\"featureWeightThreshold\")) {\n        myFlags[col].featureWeightThreshold = Double.parseDouble(val);\n      } else if (key.equals(\"useClassFeature\")) {\n        myFlags[col].useClassFeature = Boolean.parseBoolean(val);\n      } else if (key.equals(\"featureMinimumSupport\")) {\n        myFlags[col].featureMinimumSupport = Integer.parseInt(val);\n      } else if (key.equals(\"prior\")) {\n        if (val.equalsIgnoreCase(\"no\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.NULL.ordinal();\n        } else if (val.equalsIgnoreCase(\"huber\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.HUBER.ordinal();\n        } else if (val.equalsIgnoreCase(\"quadratic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n        } else if (val.equalsIgnoreCase(\"quartic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n        } else {\n          try {\n            myFlags[col].prior = Integer.parseInt(val);\n          } catch (NumberFormatException nfe) {\n            System.err.println(\"Unknown prior \" + val + \"; using none.\");\n          }\n        }\n      } else if (key.equals(\"sigma\")) {\n        myFlags[col].sigma = Double.parseDouble(val);\n      } else if (key.equals(\"epsilon\")) {\n        myFlags[col].epsilon = Double.parseDouble(val);\n      } else if (key.equals(\"maxNGramLeng\")) {\n        myFlags[col].maxNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minNGramLeng\")) {\n        myFlags[col].minNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"partialNGramRegexp\")) {\n        myFlags[col].partialNGramRegexp = val;\n        try {\n          myFlags[col].partialNGramPattern = Pattern.compile(myFlags[col].partialNGramRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed partialNGramPattern: \" + myFlags[col].partialNGramPattern);\n          myFlags[col].partialNGramRegexp = null;\n        }\n      } else if (key.equals(\"splitWordsRegexp\")) {\n        try {\n          myFlags[col].splitWordsPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsTokenizerRegexp\")) {\n        try {\n          myFlags[col].splitWordsTokenizerPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsTokenizerRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsIgnoreRegexp\")) {\n        String trimVal = val.trim();\n        if (trimVal.isEmpty()) {\n          myFlags[col].splitWordsIgnorePattern = null;\n        } else {\n          try {\n            myFlags[col].splitWordsIgnorePattern = Pattern.compile(trimVal);\n          } catch (PatternSyntaxException pse) {\n            System.err.println(\"Ill-formed splitWordsIgnoreRegexp: \" + trimVal);\n          }\n        }\n      } else if (key.equals(\"useSplitWords\")) {\n        myFlags[col].useSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordPairs\")) {\n        myFlags[col].useSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordPairs\")) {\n        myFlags[col].useAllSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordTriples\")) {\n        myFlags[col].useAllSplitWordTriples = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordNGrams\")) {\n        myFlags[col].useSplitWordNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"maxWordNGramLeng\")) {\n        myFlags[col].maxWordNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minWordNGramLeng\")) {\n        myFlags[col].minWordNGramLeng = Integer.parseInt(val);\n        if (myFlags[col].minWordNGramLeng < 1) {\n          System.err.println(\"minWordNGramLeng set to \" + myFlags[col].minWordNGramLeng + \", resetting to 1\");\n          myFlags[col].minWordNGramLeng = 1;\n        }\n      } else if (key.equals(\"wordNGramBoundaryRegexp\")) {\n        myFlags[col].wordNGramBoundaryRegexp = val;\n        try {\n          myFlags[col].wordNGramBoundaryPattern = Pattern.compile(myFlags[col].wordNGramBoundaryRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed wordNGramBoundary regexp: \" + myFlags[col].wordNGramBoundaryRegexp);\n          myFlags[col].wordNGramBoundaryRegexp = null;\n        }\n      } else if (key.equals(\"useSplitFirstLastWords\")) {\n        myFlags[col].useSplitFirstLastWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"loadClassifier\")) {\n        myFlags[col].loadClassifier = val;\n      } else if (key.equals(\"serializeTo\")) {\n        Flags.serializeTo = val;\n      } else if (key.equals(\"printTo\")) {\n        Flags.printTo = val;\n      } else if (key.equals(\"trainFile\")) {\n        Flags.trainFile = val;\n      } else if (key.equals(\"displayAllAnswers\")) {\n        Flags.displayAllAnswers = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFile\")) {\n        myFlags[col].testFile = val;\n      } else if (key.equals(\"trainFromSVMLight\")) {\n        Flags.trainFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFromSVMLight\")) {\n        Flags.testFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"encoding\")) {\n        Flags.encoding = val;\n      } else if (key.equals(\"printSVMLightFormatTo\")) {\n        Flags.printSVMLightFormatTo = val;\n      } else if (key.equals(\"displayedColumn\")) {\n        myFlags[col].displayedColumn = Integer.parseInt(val);\n      } else if (key.equals(\"groupingColumn\")) {\n        myFlags[col].groupingColumn = Integer.parseInt(val);\n        // System.err.println(\"Grouping column is \" + (myFlags[col].groupingColumn));\n      } else if (key.equals(\"rankingScoreColumn\")) {\n        myFlags[col].rankingScoreColumn = Integer.parseInt(val);\n        // System.err.println(\"Ranking score column is \" + (myFlags[col].rankingScoreColumn));\n      } else if (key.equals(\"rankingAccuracyClass\")) {\n        myFlags[col].rankingAccuracyClass = val;\n      } else if (key.equals(\"goldAnswerColumn\")) {\n        myFlags[col].goldAnswerColumn = Integer.parseInt(val);\n        // System.err.println(\"Gold answer column is \" + (myFlags[col].goldAnswerColumn));  // it's a nuisance to print this when used programmatically\n      } else if (key.equals(\"useQN\")) {\n        myFlags[col].useQN = Boolean.parseBoolean(val);\n      } else if (key.equals(\"QNsize\")) {\n        myFlags[col].QNsize = Integer.parseInt(val);\n      } else if (key.equals(\"featureFormat\")) {\n        myFlags[col].featureFormat = Boolean.parseBoolean(val);\n      } else if (key.equals(\"significantColumnId\")) {\n        myFlags[col].significantColumnId = Boolean.parseBoolean(val);\n      } else if (key.equals(\"justify\")) {\n        myFlags[col].justify = Boolean.parseBoolean(val);\n      }  else if (key.equals(\"realValued\")) {\n        myFlags[col].isRealValued = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].isRealValued;\n      } else if (key.equals(\"logTransform\")) {\n        myFlags[col].logTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logTransform;\n      } else if (key.equals(\"logitTransform\")) {\n        myFlags[col].logitTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logitTransform;\n      } else if (key.equals(\"sqrtTransform\")) {\n        myFlags[col].sqrtTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].sqrtTransform;\n      } else if (key.equals(\"filename\")) {\n        myFlags[col].filename = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biased\")) {\n        myFlags[col].biased = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biasedHyperplane\")) {\n        // System.err.println(\"Constraints is \" + constraints);\n        if (val != null && val.trim().length() > 0) {\n          String[] bits = val.split(\"[, ]+\");\n          myFlags[col].biasedHyperplane = new ClassicCounter<String>();\n          for (int i = 0; i < bits.length; i += 2) {\n            myFlags[col].biasedHyperplane.setCount(bits[i], Double.parseDouble(bits[i + 1]));\n          }\n        }\n        // System.err.println(\"Biased Hyperplane is \" + biasedHyperplane);\n      } else if (key.equals(\"crossValidationFolds\")) {\n        myFlags[col].crossValidationFolds = Integer.parseInt(val);\n      } else if (key.equals(\"shuffleTrainingData\")) {\n        myFlags[col].shuffleTrainingData = Boolean.parseBoolean(val);\n      } else if (key.equals(\"shuffleSeed\")) {\n        myFlags[col].shuffleSeed = Long.parseLong(val);\n      } else if (key.equals(\"csvFormat\")) {\n        myFlags[col].csvFormat=true;\n\n      } else if ( ! key.isEmpty() && ! key.equals(\"prop\")) {\n        System.err.println(\"Unknown property: |\" + key + '|');\n      }\n    }\n    myFlags[0].usesRealValues = myUsesRealValues;\n    return myFlags;\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Read a data set from a file and convert it into a Dataset object.\n   *  In test phase, returns the {@code List<String[]>} with the data columns for printing purposes.\n   *  Otherwise, returns {@code null} for the second item.\n   *\n   *  @param filename Where to read data from\n   *  @param inTestPhase Whether to return the read String[] for each data item\n   *  @return A Pair of a GeneralDataSet of Datums and a List of datums in String form.\n   */\n  private Pair<GeneralDataset<String,String>, List<String[]>> readDataset(String filename, boolean inTestPhase) {\n    Timing tim = new Timing();\n    System.err.print(\"Reading dataset from \" + filename + \" ... \");\n    GeneralDataset<String,String> dataset;\n    List<String[]> lineInfos = null;\n    if ((inTestPhase && Flags.testFromSVMLight) || (!inTestPhase && Flags.trainFromSVMLight)) {\n      List<String> lines = null;\n      if (inTestPhase) {\n        lines = new ArrayList<String>();\n      }\n      if (globalFlags.usesRealValues) {\n        dataset = RVFDataset.readSVMLightFormat(filename, lines);\n      } else {\n        dataset = Dataset.readSVMLightFormat(filename, lines);\n      }\n      if (lines != null) {\n        lineInfos = makeSVMLightLineInfos(lines);\n      }\n    } else {\n      try {\n        if (inTestPhase) {\n          lineInfos = new ArrayList<String[]>();\n        }\n        if (globalFlags.usesRealValues) {\n          dataset = new RVFDataset<String,String>();\n        } else {\n          dataset = new Dataset<String,String>();\n        }\n        int lineNo = 0;\n        int minColumns = Integer.MAX_VALUE;\n        int maxColumns = 0;\n        for (String line : ObjectBank.getLineIterator(new File(filename), Flags.encoding)) {\n          lineNo++;\n          String[] strings = tab.split(line);\n          if (strings.length < 2) {\n            throw new RuntimeException(\"Line format error at line \" + lineNo + \": \" + line);\n          }\n          if (strings.length < minColumns) {\n            minColumns = strings.length;\n          }\n          if (strings.length > maxColumns) {\n            maxColumns = strings.length;\n          }\n          if (inTestPhase) {\n            lineInfos.add(strings);\n          }\n          dataset.add(makeDatumFromStrings(strings));\n        }\n        if (lineNo > 0 && minColumns != maxColumns) {\n          System.err.println();\n          System.err.println(\"WARNING: Number of tab-separated columns in \" +\n                  filename + \" varies between \" + minColumns + \" and \" + maxColumns);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(\"Dataset could not be processed\", e);\n      }\n    }\n\n    System.err.println(\"done [\" + tim.toSecondsString() + \"s, \" + dataset.size() + \" items].\");\n    return new Pair<GeneralDataset<String,String>,List<String[]>>(dataset, lineInfos);\n  }","id":11255,"modified_method":"/** Read a data set from a file and convert it into a Dataset object.\n   *  In test phase, returns the {@code List<String[]>} with the data columns for printing purposes.\n   *  Otherwise, returns {@code null} for the second item.\n   *\n   *  @param filename Where to read data from\n   *  @param inTestPhase Whether to return the read String[] for each data item\n   *  @return A Pair of a GeneralDataSet of Datums and a List of datums in String form.\n   */\n  private Pair<GeneralDataset<String,String>, List<String[]>> readDataset(String filename, boolean inTestPhase) {\n    Timing tim = new Timing();\n    System.err.print(\"Reading dataset from \" + filename + \" ... \");\n    GeneralDataset<String,String> dataset;\n    List<String[]> lineInfos = null;\n    if ((inTestPhase && Flags.testFromSVMLight) || (!inTestPhase && Flags.trainFromSVMLight)) {\n      List<String> lines = null;\n      if (inTestPhase) {\n        lines = new ArrayList<String>();\n      }\n      if (globalFlags.usesRealValues) {\n        dataset = RVFDataset.readSVMLightFormat(filename, lines);\n      } else {\n        dataset = Dataset.readSVMLightFormat(filename, lines);\n      }\n      if (lines != null) {\n        lineInfos = makeSVMLightLineInfos(lines);\n      }\n    } else {\n      try {\n        if (inTestPhase) {\n          lineInfos = new ArrayList<String[]>();\n        }\n        if (globalFlags.usesRealValues) {\n          dataset = new RVFDataset<String,String>();\n        } else {\n          dataset = new Dataset<String,String>();\n        }\n        int lineNo = 0;\n        int minColumns = Integer.MAX_VALUE;\n        int maxColumns = 0;\n        for (String line : ObjectBank.getLineIterator(new File(filename), Flags.encoding)) {\n          lineNo++;\n          String[] strings = splitLineToFields(line);\n          if (strings.length < 2) {\n            throw new RuntimeException(\"Line format error at line \" + lineNo + \": \" + line);\n          }\n          if (strings.length < minColumns) {\n            minColumns = strings.length;\n          }\n          if (strings.length > maxColumns) {\n            maxColumns = strings.length;\n          }\n          if (inTestPhase) {\n            lineInfos.add(strings);\n          }\n          dataset.add(makeDatumFromStrings(strings));\n        }\n        if (lineNo > 0 && minColumns != maxColumns) {\n          System.err.println();\n          System.err.println(\"WARNING: Number of tab-separated columns in \" +\n                  filename + \" varies between \" + minColumns + \" and \" + maxColumns);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(\"Dataset could not be processed\", e);\n      }\n    }\n\n    System.err.println(\"done [\" + tim.toSecondsString() + \"s, \" + dataset.size() + \" items].\");\n    return new Pair<GeneralDataset<String,String>,List<String[]>>(dataset, lineInfos);\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public NERCombinerAnnotator(NERClassifierCombiner ner, boolean verbose) {\n    VERBOSE = verbose;\n    this.ner = ner;\n  }","id":11256,"modified_method":"public NERCombinerAnnotator(NERClassifierCombiner ner, boolean verbose) {\n    this(ner, verbose, 1, 0);\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public NERCombinerAnnotator(boolean verbose, String... classifiers)\n  throws IOException, ClassNotFoundException {\n    VERBOSE = verbose;\n    timerStart(\"Loading NER combiner model...\");\n    ner = new NERClassifierCombiner(classifiers);\n    timerStop();\n  }","id":11257,"modified_method":"public NERCombinerAnnotator(boolean verbose, String... classifiers) \n    throws IOException, ClassNotFoundException \n  {\n    this(new NERClassifierCombiner(classifiers), verbose);\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public NERCombinerAnnotator(boolean verbose) throws IOException, ClassNotFoundException {\n    VERBOSE = verbose;\n    timerStart(\"Loading NER combiner model...\");\n    ner = new NERClassifierCombiner(new Properties());\n    timerStop();\n  }","id":11258,"modified_method":"public NERCombinerAnnotator(boolean verbose) \n    throws IOException, ClassNotFoundException \n  {\n    this(new NERClassifierCombiner(new Properties()), verbose);\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void annotate(Annotation annotation) {\n    timerStart(\"Adding NER Combiner annotation...\");\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // classify tokens for each sentence\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        doOneSentence(annotation, sentence);\n      }\n      this.ner.finalizeAnnotation(annotation);\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n    //timerStop(\"done.\");\n  }","id":11259,"modified_method":"@Override\n  public void annotate(Annotation annotation) {\n    timerStart(\"Adding NER Combiner annotation...\");\n\n    super.annotate(annotation);\n\n    this.ner.finalizeAnnotation(annotation);\n    timerStop();\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public NERCombinerAnnotator(String name, Properties properties) {\n    this(createNERClassifierCombiner(name, properties), false);\n  }","id":11260,"modified_method":"public NERCombinerAnnotator(String name, Properties properties) {\n    this(createNERClassifierCombiner(name, properties), false, \n         PropertiesUtils.getInt(properties, name + \".nthreads\", PropertiesUtils.getInt(properties, \"nthreads\", 1)),\n         PropertiesUtils.getLong(properties, name + \".maxtime\", 0));\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public CoreMap doOneSentence(Annotation annotation, CoreMap sentence) {\n    List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n    List<CoreLabel> output = this.ner.classifySentenceWithGlobalInformation(tokens, annotation, sentence);\n    if (VERBOSE) {\n      boolean first = true;\n      System.err.print(\"NERCombinerAnnotator direct output: [\");\n      for (CoreLabel w : output) {\n        if (first) { first = false; } else { System.err.print(\", \"); }\n        System.err.print(w.toString());\n      }\n      System.err.println(']');\n    }\n\n    for (int i = 0; i < tokens.size(); ++i) {\n      // add the named entity tag to each token\n      String neTag = output.get(i).get(CoreAnnotations.NamedEntityTagAnnotation.class);\n      String normNeTag = output.get(i).get(CoreAnnotations.NormalizedNamedEntityTagAnnotation.class);\n      tokens.get(i).setNER(neTag);\n      if(normNeTag != null) tokens.get(i).set(CoreAnnotations.NormalizedNamedEntityTagAnnotation.class, normNeTag);\n      NumberSequenceClassifier.transferAnnotations(output.get(i), tokens.get(i));\n    }\n\n    if (VERBOSE) {\n      boolean first = true;\n      System.err.print(\"NERCombinerAnnotator output: [\");\n      for (CoreLabel w : tokens) {\n        if (first) { first = false; } else { System.err.print(\", \"); }\n        System.err.print(w.toShorterString(\"Word\", \"NamedEntityTag\", \"NormalizedNamedEntityTag\"));\n      }\n      System.err.println(']');\n    }\n    return sentence;\n  }","id":11261,"modified_method":"@Override\n  public void doOneSentence(Annotation annotation, CoreMap sentence) {\n    List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n    List<CoreLabel> output = this.ner.classifySentenceWithGlobalInformation(tokens, annotation, sentence);\n    if (VERBOSE) {\n      boolean first = true;\n      System.err.print(\"NERCombinerAnnotator direct output: [\");\n      for (CoreLabel w : output) {\n        if (first) { first = false; } else { System.err.print(\", \"); }\n        System.err.print(w.toString());\n      }\n      System.err.println(']');\n    }\n\n    for (int i = 0; i < tokens.size(); ++i) {\n      // add the named entity tag to each token\n      String neTag = output.get(i).get(CoreAnnotations.NamedEntityTagAnnotation.class);\n      String normNeTag = output.get(i).get(CoreAnnotations.NormalizedNamedEntityTagAnnotation.class);\n      tokens.get(i).setNER(neTag);\n      if(normNeTag != null) tokens.get(i).set(CoreAnnotations.NormalizedNamedEntityTagAnnotation.class, normNeTag);\n      NumberSequenceClassifier.transferAnnotations(output.get(i), tokens.get(i));\n    }\n\n    if (VERBOSE) {\n      boolean first = true;\n      System.err.print(\"NERCombinerAnnotator output: [\");\n      for (CoreLabel w : tokens) {\n        if (first) { first = false; } else { System.err.print(\", \"); }\n        System.err.print(w.toShorterString(\"Word\", \"NamedEntityTag\", \"NormalizedNamedEntityTag\"));\n      }\n      System.err.println(']');\n    }\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * \n   * @param args\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file\\n\", NegraPennTreeReaderFactory.class.getName());\n      System.exit(-1);\n    }\n    \n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n    \n    try {\n      TreeReader tr = trf.newTreeReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(new File(args[0]))),tlp.getEncoding()));\n      \n      Tree t;\n      while((t = tr.readTree()) != null)\n        t.pennPrint();\n      \n      tr.close();\n    \n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","id":11262,"modified_method":"/**\n   *\n   * @param args File to run on\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file%n\", NegraPennTreeReaderFactory.class.getName());\n      return;\n    }\n\n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n\n    try {\n      TreeReader tr = trf.newTreeReader(IOUtils.readerFromString(args[0], tlp.getEncoding()));\n\n      for (Tree t; (t = tr.readTree()) != null; ) {\n        t.pennPrint();\n      }\n\n      tr.close();\n\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void doOneSentence(CoreMap sentence) {\n    final List<CoreLabel> words = sentence.get(CoreAnnotations.TokensAnnotation.class);\n    if (VERBOSE) {\n      System.err.println(\"Parsing: \" + words);\n    }\n    Tree tree = null;\n    // generate the constituent tree\n    if (maxSentenceLength <= 0 || words.size() < maxSentenceLength) {\n      try {\n        final List<ParserConstraint> constraints = sentence.get(ParserAnnotations.ConstraintAnnotation.class);\n        tree = doOneSentence(constraints, words);\n      } catch (RuntimeInterruptedException e) {\n        if (VERBOSE) {\n          System.err.println(\"Took too long parsing: \" + words);\n        }\n        tree = null;\n      }\n    }\n    // tree == null may happen if the parser takes too long or if\n    // the sentence is longer than the max length\n    if (tree == null) {\n      tree = ParserUtils.xTree(words);\n    }\n\n    if (treeMap != null) {\n      tree = treeMap.apply(tree);\n    }\n\n    ParserAnnotatorUtils.fillInParseAnnotations(VERBOSE, BUILD_GRAPHS, gsf, sentence, tree);\n\n    if (saveBinaryTrees) {\n      TreeBinarizer binarizer = new TreeBinarizer(parser.getTLPParams().headFinder(), parser.treebankLanguagePack(),\n                                                  false, false, 0, false, false, 0.0, false, true, true);\n      Tree binarized = binarizer.transformTree(tree);\n      Trees.convertToCoreLabels(binarized);\n      sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, binarized);\n    }\n  }","id":11263,"modified_method":"@Override\n  protected void doOneSentence(Annotation annotation, CoreMap sentence) {\n    final List<CoreLabel> words = sentence.get(CoreAnnotations.TokensAnnotation.class);\n    if (VERBOSE) {\n      System.err.println(\"Parsing: \" + words);\n    }\n    Tree tree = null;\n    // generate the constituent tree\n    if (maxSentenceLength <= 0 || words.size() < maxSentenceLength) {\n      try {\n        final List<ParserConstraint> constraints = sentence.get(ParserAnnotations.ConstraintAnnotation.class);\n        tree = doOneSentence(constraints, words);\n      } catch (RuntimeInterruptedException e) {\n        if (VERBOSE) {\n          System.err.println(\"Took too long parsing: \" + words);\n        }\n        tree = null;\n      }\n    }\n    // tree == null may happen if the parser takes too long or if\n    // the sentence is longer than the max length\n    if (tree == null) {\n      tree = ParserUtils.xTree(words);\n    }\n\n    if (treeMap != null) {\n      tree = treeMap.apply(tree);\n    }\n\n    ParserAnnotatorUtils.fillInParseAnnotations(VERBOSE, BUILD_GRAPHS, gsf, sentence, tree);\n\n    if (saveBinaryTrees) {\n      TreeBinarizer binarizer = new TreeBinarizer(parser.getTLPParams().headFinder(), parser.treebankLanguagePack(),\n                                                  false, false, 0, false, false, 0.0, false, true, true);\n      Tree binarized = binarizer.transformTree(tree);\n      Trees.convertToCoreLabels(binarized);\n      sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, binarized);\n    }\n  }","commit_id":"a4b6c9c05ebb137a039cc025fc8fcb57c5f56b28","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * \n   * @param args\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file\\n\", NegraPennTreeReaderFactory.class.getName());\n      System.exit(-1);\n    }\n    \n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n    \n    try {\n      TreeReader tr = trf.newTreeReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(new File(args[0]))),tlp.getEncoding()));\n      \n      Tree t;\n      while((t = tr.readTree()) != null)\n        t.pennPrint();\n      \n      tr.close();\n    \n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","id":11264,"modified_method":"/**\n   *\n   * @param args File to run on\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file%n\", NegraPennTreeReaderFactory.class.getName());\n      return;\n    }\n\n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n\n    try {\n      TreeReader tr = trf.newTreeReader(IOUtils.readerFromString(args[0], tlp.getEncoding()));\n\n      for (Tree t; (t = tr.readTree()) != null; ) {\n        t.pennPrint();\n      }\n\n      tr.close();\n\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"35bf32bfe15b826479cbc8a506ac2c1db1623ef8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * \n   * @param args\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file\\n\", NegraPennTreeReaderFactory.class.getName());\n      System.exit(-1);\n    }\n    \n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n    \n    try {\n      TreeReader tr = trf.newTreeReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(new File(args[0]))),tlp.getEncoding()));\n      \n      Tree t;\n      while((t = tr.readTree()) != null)\n        t.pennPrint();\n      \n      tr.close();\n    \n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","id":11265,"modified_method":"/**\n   *\n   * @param args File to run on\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file%n\", NegraPennTreeReaderFactory.class.getName());\n      return;\n    }\n\n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n\n    try {\n      TreeReader tr = trf.newTreeReader(IOUtils.readerFromString(args[0], tlp.getEncoding()));\n\n      for (Tree t; (t = tr.readTree()) != null; ) {\n        t.pennPrint();\n      }\n\n      tr.close();\n\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"e07a703e20adc3c5659b8f8def5119addae47841","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Initialize using values in Properties file.\n   *\n   * @param props Properties, with the special format of column.flag used in ColumnDataClassifier\n   * @return An array of flags for each data column, with additional global flags in element [0]\n   */\n  private Flags[] setProperties(Properties props) {\n    Flags[] myFlags;\n    boolean myUsesRealValues = false;\n\n    Pattern prefix;\n    try {\n      prefix = Pattern.compile(\"([0-9]+)\\\\.(.*)\");\n    } catch (PatternSyntaxException pse) {\n      throw new RuntimeException(pse);\n    }\n\n    // if we are loading a classifier then we have to load it before we do anything\n    // else and have its Properties be the defaults that can then be overridden by\n    // other command-line arguments\n    String loadPath = props.getProperty(\"loadClassifier\");\n    if (loadPath != null) {\n      System.err.println(\"Loading classifier from \" + loadPath + \"...\");\n      ObjectInputStream ois = null;\n      try {\n        // load the classifier\n        ois = IOUtils.readStreamFromString(loadPath);\n        classifier = ErasureUtils.<LinearClassifier<String,String>>uncheckedCast(ois.readObject());\n        myFlags = (Flags[]) ois.readObject();\n        assert flags.length > 0;\n        System.err.println(\"Done.\");\n      } catch (Exception e) {\n        throw new RuntimeIOException(\"Error deserializing \" + loadPath, e);\n      } finally {\n        IOUtils.closeIgnoringExceptions(ois);\n      }\n    } else {\n      myFlags = new Flags[1];\n      myFlags[0] = new Flags();  // initialize zero column flags used for global flags; it can't be null\n    }\n\n    for (Enumeration<?> e = props.propertyNames(); e.hasMoreElements();) {\n      String key = (String) e.nextElement();\n      String val = props.getProperty(key);\n      int col = 0;  // the default (first after class)\n      // System.err.println(key + \" = \" + val);\n      Matcher matcher = prefix.matcher(key);\n      if (matcher.matches()) {\n        col = Integer.parseInt(matcher.group(1));\n        key = matcher.group(2);\n      }\n      if (col >= myFlags.length) {\n        Flags[] newFl = new Flags[col + 1];\n        System.arraycopy(myFlags, 0, newFl, 0, myFlags.length);\n        myFlags = newFl;\n      }\n      if (myFlags[col] == null) {\n        myFlags[col] = new Flags();\n      }\n\n      if (key.equals(\"useString\")) {\n        myFlags[col].useString = Boolean.parseBoolean(val);\n      } else if (key.equals(\"binnedLengths\")) {\n        if (val != null) {\n          String[] binnedLengthStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedLengths = new int[binnedLengthStrs.length];\n          for (int i = 0; i < myFlags[col].binnedLengths.length; i++) {\n            myFlags[col].binnedLengths[i] = Integer.parseInt(binnedLengthStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedLengthsStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedLengthsCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"countChars\")) {\n        myFlags[col].countChars = val.toCharArray();\n      } else if (key.equals(\"countCharsBins\")) {\n        if (val != null) {\n          String[] binnedCountStrs = val.split(\"[, ]+\");\n          myFlags[col].countCharsBins = new int[binnedCountStrs.length];\n          for (int i = 0; i < binnedCountStrs.length; i++) {\n            myFlags[col].countCharsBins[i] = Integer.parseInt(binnedCountStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValues\")) {\n        if (val != null) {\n          String[] binnedValuesStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedValues = new double[binnedValuesStrs.length];\n          for (int i = 0; i < myFlags[col].binnedValues.length; i++) {\n            myFlags[col].binnedValues[i] = Double.parseDouble(binnedValuesStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValuesNaN\")) {\n        myFlags[col].binnedValuesNaN = Double.parseDouble(val);\n      } else if (key.equals(\"binnedValuesStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedValuesCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"useNGrams\")) {\n        myFlags[col].useNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"usePrefixSuffixNGrams\")) {\n        myFlags[col].usePrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitNGrams\")) {\n        myFlags[col].useSplitNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"wordShape\")) {\n        myFlags[col].wordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"splitWordShape\")) {\n        myFlags[col].splitWordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"useSplitPrefixSuffixNGrams\")) {\n        myFlags[col].useSplitPrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercaseNGrams\")) {\n        myFlags[col].lowercaseNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercase\")) {\n        myFlags[col].lowercase = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useLowercaseSplitWords\")) {\n        myFlags[col].useLowercaseSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSum\")) {\n        myFlags[col].useSum = Boolean.parseBoolean(val);\n      } else if (key.equals(\"tolerance\")) {\n        myFlags[col].tolerance = Double.parseDouble(val);\n      } else if (key.equals(\"printFeatures\")) {\n        myFlags[col].printFeatures = val;\n      } else if (key.equals(\"printClassifier\")) {\n        myFlags[col].printClassifier = val;\n      } else if (key.equals(\"printClassifierParam\")) {\n        myFlags[col].printClassifierParam = Integer.parseInt(val);\n      } else if (key.equals(\"exitAfterTrainingFeaturization\")) {\n        myFlags[col].exitAfterTrainingFeaturization = Boolean.parseBoolean(val);\n      } else if (key.equals(\"intern\") || key.equals(\"intern2\")) {\n        myFlags[col].intern = Boolean.parseBoolean(val);\n      } else if (key.equals(\"cacheNGrams\")) {\n        myFlags[col].cacheNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useClassifierFactory\")) {\n        myFlags[col].useClassifierFactory = val;\n      } else if (key.equals(\"classifierFactoryArgs\")) {\n        myFlags[col].classifierFactoryArgs = val;\n      } else if (key.equals(\"useNB\")) {\n        myFlags[col].useNB = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useBinary\")) {\n        myFlags[col].useBinary = Boolean.parseBoolean(val);\n      } else if (key.equals(\"l1reg\")) {\n        myFlags[col].l1reg = Double.parseDouble(val);\n      } else if (key.equals(\"useAdaptL1\")) {\n        myFlags[col].useAdaptL1 = Boolean.parseBoolean(val);\n      } else if (key.equals(\"limitFeatures\")) {\n        myFlags[col].limitFeatures = Integer.parseInt(val);\n      } else if (key.equals(\"l1regmin\")) {\n        myFlags[col].l1regmin = Double.parseDouble(val);\n      } else if (key.equals(\"l1regmax\")) {\n        myFlags[col].l1regmax = Double.parseDouble(val);\n      } else if (key.equals(\"limitFeaturesLabels\")) {\n        myFlags[col].limitFeaturesLabels = val;\n      } else if (key.equals(\"featureWeightThreshold\")) {\n        myFlags[col].featureWeightThreshold = Double.parseDouble(val);\n      } else if (key.equals(\"useClassFeature\")) {\n        myFlags[col].useClassFeature = Boolean.parseBoolean(val);\n      } else if (key.equals(\"featureMinimumSupport\")) {\n        myFlags[col].featureMinimumSupport = Integer.parseInt(val);\n      } else if (key.equals(\"prior\")) {\n        if (val.equalsIgnoreCase(\"no\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.NULL.ordinal();\n        } else if (val.equalsIgnoreCase(\"huber\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.HUBER.ordinal();\n        } else if (val.equalsIgnoreCase(\"quadratic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n        } else if (val.equalsIgnoreCase(\"quartic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n        } else {\n          try {\n            myFlags[col].prior = Integer.parseInt(val);\n          } catch (NumberFormatException nfe) {\n            System.err.println(\"Unknown prior \" + val + \"; using none.\");\n          }\n        }\n      } else if (key.equals(\"sigma\")) {\n        myFlags[col].sigma = Double.parseDouble(val);\n      } else if (key.equals(\"epsilon\")) {\n        myFlags[col].epsilon = Double.parseDouble(val);\n      } else if (key.equals(\"maxNGramLeng\")) {\n        myFlags[col].maxNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minNGramLeng\")) {\n        myFlags[col].minNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"partialNGramRegexp\")) {\n        myFlags[col].partialNGramRegexp = val;\n        try {\n          myFlags[col].partialNGramPattern = Pattern.compile(myFlags[col].partialNGramRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed partialNGramPattern: \" + myFlags[col].partialNGramPattern);\n          myFlags[col].partialNGramRegexp = null;\n        }\n      } else if (key.equals(\"splitWordsRegexp\")) {\n        try {\n          myFlags[col].splitWordsPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsTokenizerRegexp\")) {\n        try {\n          myFlags[col].splitWordsTokenizerPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsTokenizerRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsIgnoreRegexp\")) {\n        String trimVal = val.trim();\n        if (trimVal.isEmpty()) {\n          myFlags[col].splitWordsIgnorePattern = null;\n        } else {\n          try {\n            myFlags[col].splitWordsIgnorePattern = Pattern.compile(trimVal);\n          } catch (PatternSyntaxException pse) {\n            System.err.println(\"Ill-formed splitWordsIgnoreRegexp: \" + trimVal);\n          }\n        }\n      } else if (key.equals(\"useSplitWords\")) {\n        myFlags[col].useSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordPairs\")) {\n        myFlags[col].useSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordPairs\")) {\n        myFlags[col].useAllSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordTriples\")) {\n        myFlags[col].useAllSplitWordTriples = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordNGrams\")) {\n        myFlags[col].useSplitWordNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"maxWordNGramLeng\")) {\n        myFlags[col].maxWordNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minWordNGramLeng\")) {\n        myFlags[col].minWordNGramLeng = Integer.parseInt(val);\n        if (myFlags[col].minWordNGramLeng < 1) {\n          System.err.println(\"minWordNGramLeng set to \" + myFlags[col].minWordNGramLeng + \", resetting to 1\");\n          myFlags[col].minWordNGramLeng = 1;\n        }\n      } else if (key.equals(\"wordNGramBoundaryRegexp\")) {\n        myFlags[col].wordNGramBoundaryRegexp = val;\n        try {\n          myFlags[col].wordNGramBoundaryPattern = Pattern.compile(myFlags[col].wordNGramBoundaryRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed wordNGramBoundary regexp: \" + myFlags[col].wordNGramBoundaryRegexp);\n          myFlags[col].wordNGramBoundaryRegexp = null;\n        }\n      } else if (key.equals(\"useSplitFirstLastWords\")) {\n        myFlags[col].useSplitFirstLastWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"loadClassifier\")) {\n        myFlags[col].loadClassifier = val;\n      } else if (key.equals(\"serializeTo\")) {\n        Flags.serializeTo = val;\n      } else if (key.equals(\"printTo\")) {\n        Flags.printTo = val;\n      } else if (key.equals(\"trainFile\")) {\n        Flags.trainFile = val;\n      } else if (key.equals(\"displayAllAnswers\")) {\n        Flags.displayAllAnswers = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFile\")) {\n        myFlags[col].testFile = val;\n      } else if (key.equals(\"trainFromSVMLight\")) {\n        Flags.trainFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFromSVMLight\")) {\n        Flags.testFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"encoding\")) {\n        Flags.encoding = val;\n      } else if (key.equals(\"printSVMLightFormatTo\")) {\n        Flags.printSVMLightFormatTo = val;\n      } else if (key.equals(\"displayedColumn\")) {\n        myFlags[col].displayedColumn = Integer.parseInt(val);\n      } else if (key.equals(\"groupingColumn\")) {\n        myFlags[col].groupingColumn = Integer.parseInt(val);\n        // System.err.println(\"Grouping column is \" + (myFlags[col].groupingColumn));\n      } else if (key.equals(\"rankingScoreColumn\")) {\n        myFlags[col].rankingScoreColumn = Integer.parseInt(val);\n        // System.err.println(\"Ranking score column is \" + (myFlags[col].rankingScoreColumn));\n      } else if (key.equals(\"rankingAccuracyClass\")) {\n        myFlags[col].rankingAccuracyClass = val;\n      } else if (key.equals(\"goldAnswerColumn\")) {\n        myFlags[col].goldAnswerColumn = Integer.parseInt(val);\n        // System.err.println(\"Gold answer column is \" + (myFlags[col].goldAnswerColumn));  // it's a nuisance to print this when used programmatically\n      } else if (key.equals(\"useQN\")) {\n        myFlags[col].useQN = Boolean.parseBoolean(val);\n      } else if (key.equals(\"QNsize\")) {\n        myFlags[col].QNsize = Integer.parseInt(val);\n      } else if (key.equals(\"featureFormat\")) {\n        myFlags[col].featureFormat = Boolean.parseBoolean(val);\n      } else if (key.equals(\"significantColumnId\")) {\n        myFlags[col].significantColumnId = Boolean.parseBoolean(val);\n      } else if (key.equals(\"justify\")) {\n        myFlags[col].justify = Boolean.parseBoolean(val);\n      }  else if (key.equals(\"realValued\")) {\n        myFlags[col].isRealValued = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].isRealValued;\n      } else if (key.equals(\"logTransform\")) {\n        myFlags[col].logTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logTransform;\n      } else if (key.equals(\"logitTransform\")) {\n        myFlags[col].logitTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logitTransform;\n      } else if (key.equals(\"sqrtTransform\")) {\n        myFlags[col].sqrtTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].sqrtTransform;\n      } else if (key.equals(\"filename\")) {\n        myFlags[col].filename = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biased\")) {\n        myFlags[col].biased = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biasedHyperplane\")) {\n        // System.err.println(\"Constraints is \" + constraints);\n        if (val != null && val.trim().length() > 0) {\n          String[] bits = val.split(\"[, ]+\");\n          myFlags[col].biasedHyperplane = new ClassicCounter<String>();\n          for (int i = 0; i < bits.length; i += 2) {\n            myFlags[col].biasedHyperplane.setCount(bits[i], Double.parseDouble(bits[i + 1]));\n          }\n        }\n        // System.err.println(\"Biased Hyperplane is \" + biasedHyperplane);\n      } else if (key.equals(\"crossValidationFolds\")) {\n        myFlags[col].crossValidationFolds = Integer.parseInt(val);\n      } else if (key.equals(\"shuffleTrainingData\")) {\n        myFlags[col].shuffleTrainingData = Boolean.parseBoolean(val);\n      } else if (key.equals(\"shuffleSeed\")) {\n        myFlags[col].shuffleSeed = Long.parseLong(val);\n      } else if ( ! key.isEmpty() && ! key.equals(\"prop\")) {\n        System.err.println(\"Unknown property: |\" + key + '|');\n      }\n    }\n    myFlags[0].usesRealValues = myUsesRealValues;\n    return myFlags;\n  }","id":11266,"modified_method":"/**\n   * Initialize using values in Properties file.\n   *\n   * @param props Properties, with the special format of column.flag used in ColumnDataClassifier\n   * @return An array of flags for each data column, with additional global flags in element [0]\n   */\n  private Flags[] setProperties(Properties props) {\n    Flags[] myFlags;\n    boolean myUsesRealValues = false;\n\n    Pattern prefix;\n    try {\n      prefix = Pattern.compile(\"([0-9]+)\\\\.(.*)\");\n    } catch (PatternSyntaxException pse) {\n      throw new RuntimeException(pse);\n    }\n\n    // if we are loading a classifier then we have to load it before we do anything\n    // else and have its Properties be the defaults that can then be overridden by\n    // other command-line arguments\n    String loadPath = props.getProperty(\"loadClassifier\");\n    if (loadPath != null) {\n      System.err.println(\"Loading classifier from \" + loadPath + \"...\");\n      ObjectInputStream ois = null;\n      try {\n        // load the classifier\n        ois = IOUtils.readStreamFromString(loadPath);\n        classifier = ErasureUtils.<LinearClassifier<String,String>>uncheckedCast(ois.readObject());\n        myFlags = (Flags[]) ois.readObject();\n        assert flags.length > 0;\n        System.err.println(\"Done.\");\n      } catch (Exception e) {\n        throw new RuntimeIOException(\"Error deserializing \" + loadPath, e);\n      } finally {\n        IOUtils.closeIgnoringExceptions(ois);\n      }\n    } else {\n      myFlags = new Flags[1];\n      myFlags[0] = new Flags();  // initialize zero column flags used for global flags; it can't be null\n    }\n\n    for (Enumeration<?> e = props.propertyNames(); e.hasMoreElements();) {\n      String key = (String) e.nextElement();\n      String val = props.getProperty(key);\n      int col = 0;  // the default (first after class)\n      // System.err.println(key + \" = \" + val);\n      Matcher matcher = prefix.matcher(key);\n      if (matcher.matches()) {\n        col = Integer.parseInt(matcher.group(1));\n        key = matcher.group(2);\n      }\n      if (col >= myFlags.length) {\n        Flags[] newFl = new Flags[col + 1];\n        System.arraycopy(myFlags, 0, newFl, 0, myFlags.length);\n        myFlags = newFl;\n      }\n      if (myFlags[col] == null) {\n        myFlags[col] = new Flags();\n      }\n\n      if (key.equals(\"useString\")) {\n        myFlags[col].useString = Boolean.parseBoolean(val);\n      } else if (key.equals(\"binnedLengths\")) {\n        if (val != null) {\n          String[] binnedLengthStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedLengths = new int[binnedLengthStrs.length];\n          for (int i = 0; i < myFlags[col].binnedLengths.length; i++) {\n            myFlags[col].binnedLengths[i] = Integer.parseInt(binnedLengthStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedLengthsStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedLengthsCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"countChars\")) {\n        myFlags[col].countChars = val.toCharArray();\n      } else if (key.equals(\"countCharsBins\")) {\n        if (val != null) {\n          String[] binnedCountStrs = val.split(\"[, ]+\");\n          myFlags[col].countCharsBins = new int[binnedCountStrs.length];\n          for (int i = 0; i < binnedCountStrs.length; i++) {\n            myFlags[col].countCharsBins[i] = Integer.parseInt(binnedCountStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValues\")) {\n        if (val != null) {\n          String[] binnedValuesStrs = val.split(\"[, ]+\");\n          myFlags[col].binnedValues = new double[binnedValuesStrs.length];\n          for (int i = 0; i < myFlags[col].binnedValues.length; i++) {\n            myFlags[col].binnedValues[i] = Double.parseDouble(binnedValuesStrs[i]);\n          }\n        }\n      } else if (key.equals(\"binnedValuesNaN\")) {\n        myFlags[col].binnedValuesNaN = Double.parseDouble(val);\n      } else if (key.equals(\"binnedValuesStatistics\")) {\n        if (Boolean.parseBoolean(val)) {\n          myFlags[col].binnedValuesCounter = new TwoDimensionalCounter<String,String>();\n        }\n      } else if (key.equals(\"useNGrams\")) {\n        myFlags[col].useNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"usePrefixSuffixNGrams\")) {\n        myFlags[col].usePrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitNGrams\")) {\n        myFlags[col].useSplitNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"wordShape\")) {\n        myFlags[col].wordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"splitWordShape\")) {\n        myFlags[col].splitWordShape = WordShapeClassifier.lookupShaper(val);\n      } else if (key.equals(\"useSplitPrefixSuffixNGrams\")) {\n        myFlags[col].useSplitPrefixSuffixNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercaseNGrams\")) {\n        myFlags[col].lowercaseNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"lowercase\")) {\n        myFlags[col].lowercase = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useLowercaseSplitWords\")) {\n        myFlags[col].useLowercaseSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSum\")) {\n        myFlags[col].useSum = Boolean.parseBoolean(val);\n      } else if (key.equals(\"tolerance\")) {\n        myFlags[col].tolerance = Double.parseDouble(val);\n      } else if (key.equals(\"printFeatures\")) {\n        myFlags[col].printFeatures = val;\n      } else if (key.equals(\"printClassifier\")) {\n        myFlags[col].printClassifier = val;\n      } else if (key.equals(\"printClassifierParam\")) {\n        myFlags[col].printClassifierParam = Integer.parseInt(val);\n      } else if (key.equals(\"exitAfterTrainingFeaturization\")) {\n        myFlags[col].exitAfterTrainingFeaturization = Boolean.parseBoolean(val);\n      } else if (key.equals(\"intern\") || key.equals(\"intern2\")) {\n        myFlags[col].intern = Boolean.parseBoolean(val);\n      } else if (key.equals(\"cacheNGrams\")) {\n        myFlags[col].cacheNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useClassifierFactory\")) {\n        myFlags[col].useClassifierFactory = val;\n      } else if (key.equals(\"classifierFactoryArgs\")) {\n        myFlags[col].classifierFactoryArgs = val;\n      } else if (key.equals(\"useNB\")) {\n        myFlags[col].useNB = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useBinary\")) {\n        myFlags[col].useBinary = Boolean.parseBoolean(val);\n      } else if (key.equals(\"l1reg\")) {\n        myFlags[col].l1reg = Double.parseDouble(val);\n      } else if (key.equals(\"useAdaptL1\")) {\n        myFlags[col].useAdaptL1 = Boolean.parseBoolean(val);\n      } else if (key.equals(\"limitFeatures\")) {\n        myFlags[col].limitFeatures = Integer.parseInt(val);\n      } else if (key.equals(\"l1regmin\")) {\n        myFlags[col].l1regmin = Double.parseDouble(val);\n      } else if (key.equals(\"l1regmax\")) {\n        myFlags[col].l1regmax = Double.parseDouble(val);\n      } else if (key.equals(\"limitFeaturesLabels\")) {\n        myFlags[col].limitFeaturesLabels = val;\n      } else if (key.equals(\"featureWeightThreshold\")) {\n        myFlags[col].featureWeightThreshold = Double.parseDouble(val);\n      } else if (key.equals(\"useClassFeature\")) {\n        myFlags[col].useClassFeature = Boolean.parseBoolean(val);\n      } else if (key.equals(\"featureMinimumSupport\")) {\n        myFlags[col].featureMinimumSupport = Integer.parseInt(val);\n      } else if (key.equals(\"prior\")) {\n        if (val.equalsIgnoreCase(\"no\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.NULL.ordinal();\n        } else if (val.equalsIgnoreCase(\"huber\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.HUBER.ordinal();\n        } else if (val.equalsIgnoreCase(\"quadratic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n        } else if (val.equalsIgnoreCase(\"quartic\")) {\n          myFlags[col].prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n        } else {\n          try {\n            myFlags[col].prior = Integer.parseInt(val);\n          } catch (NumberFormatException nfe) {\n            System.err.println(\"Unknown prior \" + val + \"; using none.\");\n          }\n        }\n      } else if (key.equals(\"sigma\")) {\n        myFlags[col].sigma = Double.parseDouble(val);\n      } else if (key.equals(\"epsilon\")) {\n        myFlags[col].epsilon = Double.parseDouble(val);\n      } else if (key.equals(\"maxNGramLeng\")) {\n        myFlags[col].maxNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minNGramLeng\")) {\n        myFlags[col].minNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"partialNGramRegexp\")) {\n        myFlags[col].partialNGramRegexp = val;\n        try {\n          myFlags[col].partialNGramPattern = Pattern.compile(myFlags[col].partialNGramRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed partialNGramPattern: \" + myFlags[col].partialNGramPattern);\n          myFlags[col].partialNGramRegexp = null;\n        }\n      } else if (key.equals(\"splitWordsRegexp\")) {\n        try {\n          myFlags[col].splitWordsPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsTokenizerRegexp\")) {\n        try {\n          myFlags[col].splitWordsTokenizerPattern = Pattern.compile(val);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed splitWordsTokenizerRegexp: \" + val);\n        }\n      } else if (key.equals(\"splitWordsIgnoreRegexp\")) {\n        String trimVal = val.trim();\n        if (trimVal.isEmpty()) {\n          myFlags[col].splitWordsIgnorePattern = null;\n        } else {\n          try {\n            myFlags[col].splitWordsIgnorePattern = Pattern.compile(trimVal);\n          } catch (PatternSyntaxException pse) {\n            System.err.println(\"Ill-formed splitWordsIgnoreRegexp: \" + trimVal);\n          }\n        }\n      } else if (key.equals(\"useSplitWords\")) {\n        myFlags[col].useSplitWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordPairs\")) {\n        myFlags[col].useSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordPairs\")) {\n        myFlags[col].useAllSplitWordPairs = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useAllSplitWordTriples\")) {\n        myFlags[col].useAllSplitWordTriples = Boolean.parseBoolean(val);\n      } else if (key.equals(\"useSplitWordNGrams\")) {\n        myFlags[col].useSplitWordNGrams = Boolean.parseBoolean(val);\n      } else if (key.equals(\"maxWordNGramLeng\")) {\n        myFlags[col].maxWordNGramLeng = Integer.parseInt(val);\n      } else if (key.equals(\"minWordNGramLeng\")) {\n        myFlags[col].minWordNGramLeng = Integer.parseInt(val);\n        if (myFlags[col].minWordNGramLeng < 1) {\n          System.err.println(\"minWordNGramLeng set to \" + myFlags[col].minWordNGramLeng + \", resetting to 1\");\n          myFlags[col].minWordNGramLeng = 1;\n        }\n      } else if (key.equals(\"wordNGramBoundaryRegexp\")) {\n        myFlags[col].wordNGramBoundaryRegexp = val;\n        try {\n          myFlags[col].wordNGramBoundaryPattern = Pattern.compile(myFlags[col].wordNGramBoundaryRegexp);\n        } catch (PatternSyntaxException pse) {\n          System.err.println(\"Ill-formed wordNGramBoundary regexp: \" + myFlags[col].wordNGramBoundaryRegexp);\n          myFlags[col].wordNGramBoundaryRegexp = null;\n        }\n      } else if (key.equals(\"useSplitFirstLastWords\")) {\n        myFlags[col].useSplitFirstLastWords = Boolean.parseBoolean(val);\n      } else if (key.equals(\"loadClassifier\")) {\n        myFlags[col].loadClassifier = val;\n      } else if (key.equals(\"serializeTo\")) {\n        Flags.serializeTo = val;\n      } else if (key.equals(\"printTo\")) {\n        Flags.printTo = val;\n      } else if (key.equals(\"trainFile\")) {\n        Flags.trainFile = val;\n      } else if (key.equals(\"displayAllAnswers\")) {\n        Flags.displayAllAnswers = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFile\")) {\n        myFlags[col].testFile = val;\n      } else if (key.equals(\"trainFromSVMLight\")) {\n        Flags.trainFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"testFromSVMLight\")) {\n        Flags.testFromSVMLight = Boolean.parseBoolean(val);\n      } else if (key.equals(\"encoding\")) {\n        Flags.encoding = val;\n      } else if (key.equals(\"printSVMLightFormatTo\")) {\n        Flags.printSVMLightFormatTo = val;\n      } else if (key.equals(\"displayedColumn\")) {\n        myFlags[col].displayedColumn = Integer.parseInt(val);\n      } else if (key.equals(\"groupingColumn\")) {\n        myFlags[col].groupingColumn = Integer.parseInt(val);\n        // System.err.println(\"Grouping column is \" + (myFlags[col].groupingColumn));\n      } else if (key.equals(\"rankingScoreColumn\")) {\n        myFlags[col].rankingScoreColumn = Integer.parseInt(val);\n        // System.err.println(\"Ranking score column is \" + (myFlags[col].rankingScoreColumn));\n      } else if (key.equals(\"rankingAccuracyClass\")) {\n        myFlags[col].rankingAccuracyClass = val;\n      } else if (key.equals(\"goldAnswerColumn\")) {\n        myFlags[col].goldAnswerColumn = Integer.parseInt(val);\n        // System.err.println(\"Gold answer column is \" + (myFlags[col].goldAnswerColumn));  // it's a nuisance to print this when used programmatically\n      } else if (key.equals(\"useQN\")) {\n        myFlags[col].useQN = Boolean.parseBoolean(val);\n      } else if (key.equals(\"QNsize\")) {\n        myFlags[col].QNsize = Integer.parseInt(val);\n      } else if (key.equals(\"featureFormat\")) {\n        myFlags[col].featureFormat = Boolean.parseBoolean(val);\n      } else if (key.equals(\"significantColumnId\")) {\n        myFlags[col].significantColumnId = Boolean.parseBoolean(val);\n      } else if (key.equals(\"justify\")) {\n        myFlags[col].justify = Boolean.parseBoolean(val);\n      }  else if (key.equals(\"realValued\")) {\n        myFlags[col].isRealValued = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].isRealValued;\n      } else if (key.equals(\"logTransform\")) {\n        myFlags[col].logTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logTransform;\n      } else if (key.equals(\"logitTransform\")) {\n        myFlags[col].logitTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].logitTransform;\n      } else if (key.equals(\"sqrtTransform\")) {\n        myFlags[col].sqrtTransform = Boolean.parseBoolean(val);\n        myUsesRealValues = myUsesRealValues || myFlags[col].sqrtTransform;\n      } else if (key.equals(\"filename\")) {\n        myFlags[col].filename = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biased\")) {\n        myFlags[col].biased = Boolean.parseBoolean(val);\n      } else if (key.equals(\"biasedHyperplane\")) {\n        // System.err.println(\"Constraints is \" + constraints);\n        if (val != null && val.trim().length() > 0) {\n          String[] bits = val.split(\"[, ]+\");\n          myFlags[col].biasedHyperplane = new ClassicCounter<String>();\n          for (int i = 0; i < bits.length; i += 2) {\n            myFlags[col].biasedHyperplane.setCount(bits[i], Double.parseDouble(bits[i + 1]));\n          }\n        }\n        // System.err.println(\"Biased Hyperplane is \" + biasedHyperplane);\n      } else if (key.equals(\"crossValidationFolds\")) {\n        myFlags[col].crossValidationFolds = Integer.parseInt(val);\n      } else if (key.equals(\"shuffleTrainingData\")) {\n        myFlags[col].shuffleTrainingData = Boolean.parseBoolean(val);\n      } else if (key.equals(\"shuffleSeed\")) {\n        myFlags[col].shuffleSeed = Long.parseLong(val);\n      } else if (key.equals(\"csvFormat\")) {\n        myFlags[col].csvFormat=true;\n\n      } else if ( ! key.isEmpty() && ! key.equals(\"prop\")) {\n        System.err.println(\"Unknown property: |\" + key + '|');\n      }\n    }\n    myFlags[0].usesRealValues = myUsesRealValues;\n    return myFlags;\n  }","commit_id":"6a0a1c35749fb4437eabf838834263b68902ba3b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Read a data set from a file and convert it into a Dataset object.\n   *  In test phase, returns the {@code List<String[]>} with the data columns for printing purposes.\n   *  Otherwise, returns {@code null} for the second item.\n   *\n   *  @param filename Where to read data from\n   *  @param inTestPhase Whether to return the read String[] for each data item\n   *  @return A Pair of a GeneralDataSet of Datums and a List of datums in String form.\n   */\n  private Pair<GeneralDataset<String,String>, List<String[]>> readDataset(String filename, boolean inTestPhase) {\n    Timing tim = new Timing();\n    System.err.print(\"Reading dataset from \" + filename + \" ... \");\n    GeneralDataset<String,String> dataset;\n    List<String[]> lineInfos = null;\n    if ((inTestPhase && Flags.testFromSVMLight) || (!inTestPhase && Flags.trainFromSVMLight)) {\n      List<String> lines = null;\n      if (inTestPhase) {\n        lines = new ArrayList<String>();\n      }\n      if (globalFlags.usesRealValues) {\n        dataset = RVFDataset.readSVMLightFormat(filename, lines);\n      } else {\n        dataset = Dataset.readSVMLightFormat(filename, lines);\n      }\n      if (lines != null) {\n        lineInfos = makeSVMLightLineInfos(lines);\n      }\n    } else {\n      try {\n        if (inTestPhase) {\n          lineInfos = new ArrayList<String[]>();\n        }\n        if (globalFlags.usesRealValues) {\n          dataset = new RVFDataset<String,String>();\n        } else {\n          dataset = new Dataset<String,String>();\n        }\n        int lineNo = 0;\n        int minColumns = Integer.MAX_VALUE;\n        int maxColumns = 0;\n        for (String line : ObjectBank.getLineIterator(new File(filename), Flags.encoding)) {\n          lineNo++;\n          String[] strings = tab.split(line);\n          if (strings.length < 2) {\n            throw new RuntimeException(\"Line format error at line \" + lineNo + \": \" + line);\n          }\n          if (strings.length < minColumns) {\n            minColumns = strings.length;\n          }\n          if (strings.length > maxColumns) {\n            maxColumns = strings.length;\n          }\n          if (inTestPhase) {\n            lineInfos.add(strings);\n          }\n          dataset.add(makeDatumFromStrings(strings));\n        }\n        if (lineNo > 0 && minColumns != maxColumns) {\n          System.err.println();\n          System.err.println(\"WARNING: Number of tab-separated columns in \" +\n                  filename + \" varies between \" + minColumns + \" and \" + maxColumns);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(\"Dataset could not be processed\", e);\n      }\n    }\n\n    System.err.println(\"done [\" + tim.toSecondsString() + \"s, \" + dataset.size() + \" items].\");\n    return new Pair<GeneralDataset<String,String>,List<String[]>>(dataset, lineInfos);\n  }","id":11267,"modified_method":"/** Read a data set from a file and convert it into a Dataset object.\n   *  In test phase, returns the {@code List<String[]>} with the data columns for printing purposes.\n   *  Otherwise, returns {@code null} for the second item.\n   *\n   *  @param filename Where to read data from\n   *  @param inTestPhase Whether to return the read String[] for each data item\n   *  @return A Pair of a GeneralDataSet of Datums and a List of datums in String form.\n   */\n  private Pair<GeneralDataset<String,String>, List<String[]>> readDataset(String filename, boolean inTestPhase) {\n    Timing tim = new Timing();\n    System.err.print(\"Reading dataset from \" + filename + \" ... \");\n    GeneralDataset<String,String> dataset;\n    List<String[]> lineInfos = null;\n    if ((inTestPhase && Flags.testFromSVMLight) || (!inTestPhase && Flags.trainFromSVMLight)) {\n      List<String> lines = null;\n      if (inTestPhase) {\n        lines = new ArrayList<String>();\n      }\n      if (globalFlags.usesRealValues) {\n        dataset = RVFDataset.readSVMLightFormat(filename, lines);\n      } else {\n        dataset = Dataset.readSVMLightFormat(filename, lines);\n      }\n      if (lines != null) {\n        lineInfos = makeSVMLightLineInfos(lines);\n      }\n    } else {\n      try {\n        if (inTestPhase) {\n          lineInfos = new ArrayList<String[]>();\n        }\n        if (globalFlags.usesRealValues) {\n          dataset = new RVFDataset<String,String>();\n        } else {\n          dataset = new Dataset<String,String>();\n        }\n        int lineNo = 0;\n        int minColumns = Integer.MAX_VALUE;\n        int maxColumns = 0;\n        for (String line : ObjectBank.getLineIterator(new File(filename), Flags.encoding)) {\n          lineNo++;\n          String[] strings = splitLineToFields(line);\n          if (strings.length < 2) {\n            throw new RuntimeException(\"Line format error at line \" + lineNo + \": \" + line);\n          }\n          if (strings.length < minColumns) {\n            minColumns = strings.length;\n          }\n          if (strings.length > maxColumns) {\n            maxColumns = strings.length;\n          }\n          if (inTestPhase) {\n            lineInfos.add(strings);\n          }\n          dataset.add(makeDatumFromStrings(strings));\n        }\n        if (lineNo > 0 && minColumns != maxColumns) {\n          System.err.println();\n          System.err.println(\"WARNING: Number of tab-separated columns in \" +\n                  filename + \" varies between \" + minColumns + \" and \" + maxColumns);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(\"Dataset could not be processed\", e);\n      }\n    }\n\n    System.err.println(\"done [\" + tim.toSecondsString() + \"s, \" + dataset.size() + \" items].\");\n    return new Pair<GeneralDataset<String,String>,List<String[]>>(dataset, lineInfos);\n  }","commit_id":"6a0a1c35749fb4437eabf838834263b68902ba3b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * \n   * @param args\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file\\n\", NegraPennTreeReaderFactory.class.getName());\n      System.exit(-1);\n    }\n    \n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n    \n    try {\n      TreeReader tr = trf.newTreeReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(new File(args[0]))),tlp.getEncoding()));\n      \n      Tree t;\n      while((t = tr.readTree()) != null)\n        t.pennPrint();\n      \n      tr.close();\n    \n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","id":11268,"modified_method":"/**\n   *\n   * @param args File to run on\n   */\n  public static void main(String[] args) {\n    if(args.length < 1) {\n      System.out.printf(\"Usage: java %s tree_file%n\", NegraPennTreeReaderFactory.class.getName());\n      return;\n    }\n\n    TreebankLanguagePack tlp = new NegraPennLanguagePack();\n    TreeReaderFactory trf = new NegraPennTreeReaderFactory(2,false,false,tlp);\n\n    try {\n      TreeReader tr = trf.newTreeReader(IOUtils.readerFromString(args[0], tlp.getEncoding()));\n\n      for (Tree t; (t = tr.readTree()) != null; ) {\n        t.pennPrint();\n      }\n\n      tr.close();\n\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"6a0a1c35749fb4437eabf838834263b68902ba3b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public DDLDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\n\t\t\t\"recordSetId\", \"displayDDMTemplateId\", \"formDDMTemplateId\");\n\t}","id":11269,"modified_method":"public DDLDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\n\t\t\t\"recordSetId\", \"displayDDMTemplateId\", \"formDDMTemplateId\");\n\t\tsetExportControls(new PortletDataHandlerControl[0]);\n\t}","commit_id":"62ffb632fa57202ba273ed3607c59449dd91908e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"rootFolderId\");\n\t\tsetPublishToLiveByDefault(PropsValues.DL_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","id":11270,"modified_method":"public DLDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"rootFolderId\");\n\t\tsetExportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(PropsValues.DL_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","commit_id":"62ffb632fa57202ba273ed3607c59449dd91908e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalContentPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"groupId\", \"articleId\", \"ddmTemplateKey\");\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"selected-web-content\", true, true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"referenced-content\")\n\t\t\t\t},\n\t\t\t\tJournalArticle.class.getName()));\n\t\tsetPublishToLiveByDefault(\n\t\t\tPropsValues.JOURNAL_CONTENT_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","id":11271,"modified_method":"public JournalContentPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"groupId\", \"articleId\", \"ddmTemplateKey\");\n\t\tsetExportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(\n\t\t\tPropsValues.JOURNAL_CONTENT_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","commit_id":"62ffb632fa57202ba273ed3607c59449dd91908e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PollsDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"questionId\");\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"selected-question\", true, true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"votes\", true, false, null,\n\t\t\t\t\t\tPollsVote.class.getName())\n\t\t\t\t},\n\t\t\t\tPollsQuestion.class.getName()));\n\t\tsetPublishToLiveByDefault(PropsValues.POLLS_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","id":11272,"modified_method":"public PollsDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"questionId\");\n\t\tsetExportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(PropsValues.POLLS_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","commit_id":"62ffb632fa57202ba273ed3607c59449dd91908e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected PortletPreferences doProcessImportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tportletDataContext.importPortletPermissions(\n\t\t\tPollsPermission.RESOURCE_NAME);\n\n\t\tElement questionsElement = portletDataContext.getImportDataGroupElement(\n\t\t\tPollsQuestion.class);\n\n\t\tList<Element> questionElements = questionsElement.elements();\n\n\t\tfor (Element questionElement : questionElements) {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, questionElement);\n\t\t}\n\n\t\tElement choicesElement = portletDataContext.getImportDataGroupElement(\n\t\t\tPollsChoice.class);\n\n\t\tList<Element> choiceElements = choicesElement.elements();\n\n\t\tfor (Element choiceElement : choiceElements) {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, choiceElement);\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tPollsPortletDataHandler.NAMESPACE, \"votes\")) {\n\n\t\t\tElement votesElement = portletDataContext.getImportDataGroupElement(\n\t\t\t\tPollsVote.class);\n\n\t\t\tList<Element> voteElements = votesElement.elements();\n\n\t\t\tfor (Element voteElement : voteElements) {\n\t\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\t\tportletDataContext, voteElement);\n\t\t\t}\n\t\t}\n\n\t\tlong questionId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"questionId\", StringPool.BLANK));\n\n\t\tif (questionId > 0) {\n\t\t\tMap<Long, Long> questionIds =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tPollsQuestion.class);\n\n\t\t\tquestionId = MapUtil.getLong(questionIds, questionId, questionId);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\t\"questionId\", String.valueOf(questionId));\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","id":11273,"modified_method":"@Override\n\tprotected PortletPreferences doProcessImportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tportletDataContext.importPortletPermissions(\n\t\t\tPollsPermission.RESOURCE_NAME);\n\n\t\tElement questionsElement = portletDataContext.getImportDataGroupElement(\n\t\t\tPollsQuestion.class);\n\n\t\tList<Element> questionElements = questionsElement.elements();\n\n\t\tfor (Element questionElement : questionElements) {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, questionElement);\n\t\t}\n\n\t\tElement choicesElement = portletDataContext.getImportDataGroupElement(\n\t\t\tPollsChoice.class);\n\n\t\tList<Element> choiceElements = choicesElement.elements();\n\n\t\tfor (Element choiceElement : choiceElements) {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, choiceElement);\n\t\t}\n\n\t\tElement votesElement = portletDataContext.getImportDataGroupElement(\n\t\t\tPollsVote.class);\n\n\t\tList<Element> voteElements = votesElement.elements();\n\n\t\tfor (Element voteElement : voteElements) {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, voteElement);\n\t\t}\n\n\t\tlong questionId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"questionId\", StringPool.BLANK));\n\n\t\tif (questionId > 0) {\n\t\t\tMap<Long, Long> questionIds =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tPollsQuestion.class);\n\n\t\t\tquestionId = MapUtil.getLong(questionIds, questionId, questionId);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\t\"questionId\", String.valueOf(questionId));\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","commit_id":"62ffb632fa57202ba273ed3607c59449dd91908e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public RSSPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"footerArticleValues\", \"headerArticleValues\");\n\t\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"selected-web-content\", true, true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"referenced-content\")\n\t\t\t\t},\n\t\t\t\tJournalArticle.class.getName()));\n\t\tsetPublishToLiveByDefault(PropsValues.RSS_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","id":11274,"modified_method":"public RSSPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"footerArticleValues\", \"headerArticleValues\");\n\t\tsetExportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(PropsValues.RSS_PUBLISH_TO_LIVE_BY_DEFAULT);\n\t}","commit_id":"62ffb632fa57202ba273ed3607c59449dd91908e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WikiDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"title\", \"nodeId\");\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"selected-node\", true, true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"referenced-content\")\n\t\t\t\t},\n\t\t\t\tWikiPage.class.getName()));\n\t}","id":11275,"modified_method":"public WikiDisplayPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.PORTLET_INSTANCE);\n\t\tsetDataPortletPreferences(\"title\", \"nodeId\");\n\t\tsetExportControls(new PortletDataHandlerControl[0]);\n\t}","commit_id":"62ffb632fa57202ba273ed3607c59449dd91908e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@SuppressWarnings({\"rawtypes\"})\n  public void decorate(Resource resource, DecoratorContext context) {\n    if (!ResourceUtils.isFile(resource)) {\n      return;\n    }\n\n    // Open reviews\n    ReviewQuery openReviewQuery = ReviewQuery.create().setResourceId(resource.getId()).addStatus(ReviewDto.STATUS_OPEN)\n        .addStatus(ReviewDto.STATUS_REOPENED);\n    Integer openReviewsCount = reviewDao.countByQuery(openReviewQuery);\n    context.saveMeasure(CoreMetrics.ACTIVE_REVIEWS, openReviewsCount.doubleValue());\n\n    // Unassigned reviews\n    ReviewQuery unassignedReviewQuery = ReviewQuery.copy(openReviewQuery).setNoAssignee();\n    Integer unassignedReviewsCount = reviewDao.countByQuery(unassignedReviewQuery);\n    context.saveMeasure(CoreMetrics.UNASSIGNED_REVIEWS, unassignedReviewsCount.doubleValue());\n\n    // Unplanned reviews\n    ReviewQuery plannedReviewQuery = ReviewQuery.copy(openReviewQuery).setPlanned();\n    int plannedReviewsCount = reviewDao.countByQuery(plannedReviewQuery);\n    context.saveMeasure(CoreMetrics.UNPLANNED_REVIEWS, (double) (openReviewsCount - plannedReviewsCount));\n\n    // False positive reviews\n    ReviewQuery falsePositiveReviewQuery = ReviewQuery.create().setResourceId(resource.getId())\n        .addResolution(ReviewDto.RESOLUTION_FALSE_POSITIVE);\n    Integer falsePositiveReviewsCount = reviewDao.countByQuery(falsePositiveReviewQuery);\n    context.saveMeasure(CoreMetrics.FALSE_POSITIVE_REVIEWS, falsePositiveReviewsCount.doubleValue());\n\n    // Violations without a review\n    int violationsCount = context.getViolations().size();\n    context.saveMeasure(CoreMetrics.VIOLATIONS_WITHOUT_REVIEW, (double) (violationsCount - openReviewsCount - falsePositiveReviewsCount));\n  }","id":11276,"modified_method":"@SuppressWarnings({\"rawtypes\"})\n  public void decorate(Resource resource, DecoratorContext context) {\n    if (!ResourceUtils.isPersistable(resource)) {\n      return;\n    }\n\n    // Open reviews\n    ReviewQuery openReviewQuery = ReviewQuery.create().setResourceId(resource.getId()).addStatus(ReviewDto.STATUS_OPEN)\n        .addStatus(ReviewDto.STATUS_REOPENED);\n    Double resourceOpenReviewsCount = reviewDao.countByQuery(openReviewQuery).doubleValue();\n    Double totalOpenReviewsCount = resourceOpenReviewsCount + getChildrenSum(resource, context, CoreMetrics.ACTIVE_REVIEWS);\n    context.saveMeasure(CoreMetrics.ACTIVE_REVIEWS, totalOpenReviewsCount);\n\n    // Unassigned reviews\n    ReviewQuery unassignedReviewQuery = ReviewQuery.copy(openReviewQuery).setNoAssignee();\n    Double ressourceUnassignedReviewsCount = reviewDao.countByQuery(unassignedReviewQuery).doubleValue();\n    Double totalUnassignedReviewsCount = ressourceUnassignedReviewsCount\n      + getChildrenSum(resource, context, CoreMetrics.UNASSIGNED_REVIEWS);\n    context.saveMeasure(CoreMetrics.UNASSIGNED_REVIEWS, totalUnassignedReviewsCount);\n\n    // Unplanned reviews\n    ReviewQuery plannedReviewQuery = ReviewQuery.copy(openReviewQuery).setPlanned();\n    Double resourcePlannedReviewsCount = reviewDao.countByQuery(plannedReviewQuery).doubleValue();\n    Double childrenUnplannedReviewsCount = getChildrenSum(resource, context, CoreMetrics.UNPLANNED_REVIEWS);\n    context.saveMeasure(CoreMetrics.UNPLANNED_REVIEWS, (resourceOpenReviewsCount - resourcePlannedReviewsCount)\n      + childrenUnplannedReviewsCount);\n\n    // False positive reviews\n    ReviewQuery falsePositiveReviewQuery = ReviewQuery.create().setResourceId(resource.getId())\n        .addResolution(ReviewDto.RESOLUTION_FALSE_POSITIVE);\n    Double resourceFalsePositiveReviewsCount = reviewDao.countByQuery(falsePositiveReviewQuery).doubleValue();\n    Double totalFalsePositiveReviewsCount = resourceFalsePositiveReviewsCount\n      + getChildrenSum(resource, context, CoreMetrics.FALSE_POSITIVE_REVIEWS);\n    context.saveMeasure(CoreMetrics.FALSE_POSITIVE_REVIEWS, totalFalsePositiveReviewsCount);\n\n    // Violations without a review\n    Double violationsCount = context.getMeasure(CoreMetrics.VIOLATIONS).getValue();\n    context.saveMeasure(CoreMetrics.VIOLATIONS_WITHOUT_REVIEW, violationsCount - totalOpenReviewsCount);\n  }","commit_id":"28dc9e5c031a045fa561cbddfb3fbd4b4092f6a5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldDecorateOnlyFiles() throws Exception {\n    ReviewsMeasuresDecorator decorator = new ReviewsMeasuresDecorator(null);\n    DecoratorContext context = mock(DecoratorContext.class);\n    Resource<?> resource = new Project(\"Foo\");\n    decorator.decorate(resource, context);\n    verify(context, never()).saveMeasure(any(Metric.class), anyDouble());\n  }","id":11277,"modified_method":"@Test\n  public void shouldDecorateOnlyPersistableResource() throws Exception {\n    ReviewsMeasuresDecorator decorator = new ReviewsMeasuresDecorator(null);\n    DecoratorContext context = mock(DecoratorContext.class);\n    Resource<?> resource = mock(Resource.class);\n    when(resource.getScope()).thenReturn(Scopes.BLOCK_UNIT);\n    decorator.decorate(resource, context);\n    verify(context, never()).saveMeasure(any(Metric.class), anyDouble());\n  }","commit_id":"28dc9e5c031a045fa561cbddfb3fbd4b4092f6a5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldComputeReviewMetrics() throws Exception {\n    ReviewDao reviewDao = mock(ReviewDao.class);\n    when(reviewDao.countByQuery(argThat(openReviewQueryMatcher()))).thenReturn(10);\n    when(reviewDao.countByQuery(argThat(unassignedReviewQueryMatcher()))).thenReturn(2);\n    when(reviewDao.countByQuery(argThat(plannedReviewQueryMatcher()))).thenReturn(3);\n    when(reviewDao.countByQuery(argThat(falsePositiveReviewQueryMatcher()))).thenReturn(4);\n\n    ReviewsMeasuresDecorator decorator = new ReviewsMeasuresDecorator(reviewDao);\n    Resource<?> resource = new File(\"foo\").setId(1);\n    DecoratorContext context = mock(DecoratorContext.class);\n    List<Violation> violations = mock(List.class);\n    when(violations.size()).thenReturn(35);\n    when(context.getViolations()).thenReturn(violations);\n    decorator.decorate(resource, context);\n\n    verify(context).saveMeasure(CoreMetrics.ACTIVE_REVIEWS, 10d);\n    verify(context).saveMeasure(CoreMetrics.UNASSIGNED_REVIEWS, 2d);\n    verify(context).saveMeasure(CoreMetrics.UNPLANNED_REVIEWS, 7d);\n    verify(context).saveMeasure(CoreMetrics.FALSE_POSITIVE_REVIEWS, 4d);\n    verify(context).saveMeasure(CoreMetrics.VIOLATIONS_WITHOUT_REVIEW, 21d);\n  }","id":11278,"modified_method":"@Test\n  public void shouldComputeReviewMetricsOnFile() throws Exception {\n    ReviewDao reviewDao = mock(ReviewDao.class);\n    when(reviewDao.countByQuery(argThat(openReviewQueryMatcher()))).thenReturn(10);\n    when(reviewDao.countByQuery(argThat(unassignedReviewQueryMatcher()))).thenReturn(2);\n    when(reviewDao.countByQuery(argThat(plannedReviewQueryMatcher()))).thenReturn(3);\n    when(reviewDao.countByQuery(argThat(falsePositiveReviewQueryMatcher()))).thenReturn(4);\n\n    ReviewsMeasuresDecorator decorator = new ReviewsMeasuresDecorator(reviewDao);\n    Resource<?> resource = new File(\"foo\").setId(1);\n    DecoratorContext context = mock(DecoratorContext.class);\n    when(context.getMeasure(CoreMetrics.VIOLATIONS)).thenReturn(new Measure(CoreMetrics.VIOLATIONS, 35d));\n    decorator.decorate(resource, context);\n\n    verify(context).saveMeasure(CoreMetrics.ACTIVE_REVIEWS, 10d);\n    verify(context).saveMeasure(CoreMetrics.UNASSIGNED_REVIEWS, 2d);\n    verify(context).saveMeasure(CoreMetrics.UNPLANNED_REVIEWS, 7d);\n    verify(context).saveMeasure(CoreMetrics.FALSE_POSITIVE_REVIEWS, 4d);\n    verify(context).saveMeasure(CoreMetrics.VIOLATIONS_WITHOUT_REVIEW, 35d - 10d);\n  }","commit_id":"28dc9e5c031a045fa561cbddfb3fbd4b4092f6a5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public String getTitle() {\n    return \"Reviews metrics\";\n  }","id":11279,"modified_method":"public String getTitle() {\n    return \"Review Activity\";\n  }","commit_id":"28dc9e5c031a045fa561cbddfb3fbd4b4092f6a5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void update(AnActionEvent event)\n    {\n        Presentation presentation = event.getPresentation();\n        DataContext context = event.getDataContext();\n        Project project = (Project)context.getData(DataConstants.PROJECT);\n        if (project == null)\n        {\n            presentation.setEnabled(false);\n            return;\n        }\n\n        PsiFile file = LangDataKeys.PSI_FILE.getData(context);\n        if (file == null) {\n            Editor editor = (Editor)context.getData(DataConstants.EDITOR);\n            if (editor != null)\n            {\n                file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n            }\n        }\n        if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file))\n        {\n            presentation.setEnabled(false);\n        }\n    }","id":11280,"modified_method":"public void update(AnActionEvent event)\n    {\n        Presentation presentation = event.getPresentation();\n        DataContext context = event.getDataContext();\n        Project project = PlatformDataKeys.PROJECT.getData(context);\n        if (project == null)\n        {\n            presentation.setEnabled(false);\n            return;\n        }\n\n        PsiFile file = LangDataKeys.PSI_FILE.getData(context);\n        if (file == null) {\n            Editor editor = PlatformDataKeys.EDITOR.getData(context);\n            if (editor != null)\n            {\n                file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n            }\n        }\n        if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file))\n        {\n            presentation.setEnabled(false);\n        }\n    }","commit_id":"923468c5848a891ae62854a81c3015f4f24a0887","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent event)\n    {\n        DataContext context = event.getDataContext();\n        Project project = (Project)context.getData(DataConstants.PROJECT);\n        Module module = (Module)context.getData(DataConstants.MODULE);\n        PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n        Editor editor = (Editor)context.getData(DataConstants.EDITOR);\n\n        PsiFile file = null;\n        if (editor != null)\n        {\n            file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n            if (file == null)\n            {\n                return;\n            }\n        }\n\n        (new UpdateCopyrightProcessor(project, module, file)).run();\n    }","id":11281,"modified_method":"public void actionPerformed(AnActionEvent event)\n    {\n        DataContext context = event.getDataContext();\n        Project project = PlatformDataKeys.PROJECT.getData(context);\n        assert project != null;\n        Module module = LangDataKeys.MODULE.getData(context);\n        PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n        Editor editor = PlatformDataKeys.EDITOR.getData(context);\n\n        PsiFile file = null;\n        if (editor != null)\n        {\n            file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n            if (file == null)\n            {\n                return;\n            }\n        }\n\n        new UpdateCopyrightProcessor(project, module, file).run();\n    }","commit_id":"923468c5848a891ae62854a81c3015f4f24a0887","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element element) throws InvalidDataException\n    {\n        logger.debug(\"readExternal()\");\n        List langs = element.getChildren(\"LanguageOptions\");\n        if (langs != null && langs.size() > 0)\n        {\n            //noinspection ForLoopReplaceableByForEach\n            for (int i = 0; i < langs.size(); i++)\n            {\n                Element lang = (Element)langs.get(i);\n                String name = lang.getAttributeValue(\"name\");\n                LanguageOptions opts = LanguageOptionsFactory.createOptions(name);\n                opts.readExternal(lang);\n\n                setOptions(name, opts);\n            }\n        }\n        else\n        {\n            Element root = null;\n            Element jOpts = element.getChild(\"JavaOptions\");\n            if (jOpts != null) // version 2.1.x\n            {\n                root = jOpts;\n            }\n            else // versions 0.0.1 - 2.0.x\n            {\n                Element child = element.getChild(\"option\");\n                if (child != null && child.getAttribute(\"name\") != null)\n                {\n                    root = element;\n                }\n            }\n            if (root != null)\n            {\n                String lname = StdFileTypes.JAVA.getName();\n                LanguageOptions opts = LanguageOptionsFactory.createOptions(lname);\n                opts.setFileTypeOverride(LanguageOptions.USE_TEMPLATE);\n                List children = root.getChildren(\"option\");\n                for (Object option : children)\n                {\n                    String name = ((Element)option).getAttributeValue(\"name\");\n                    String val = ((Element)option).getAttributeValue(\"value\");\n                    if (\"body\".equals(name))\n                    {\n                        //todo opts.setNotice(val);\n                    }\n                    else if (\"location\".equals(name))\n                    {\n                        opts.setFileLocation(Integer.parseInt(val));\n                    }\n                }\n\n                setOptions(lname, opts);\n            }\n        }\n\n        logger.debug(\"options=\" + this);\n    }","id":11282,"modified_method":"public void readExternal(Element element) throws InvalidDataException\n    {\n        logger.debug(\"readExternal()\");\n        List langs = element.getChildren(\"LanguageOptions\");\n        if (langs != null && langs.size() > 0)\n        {\n            //noinspection ForLoopReplaceableByForEach\n            for (int i = 0; i < langs.size(); i++)\n            {\n                Element lang = (Element)langs.get(i);\n                String name = lang.getAttributeValue(\"name\");\n              // NOTE: If any change is made here you need to update ConfigTabFactory and UpdateCopyrightFactory too.\n              LanguageOptions opts = new LanguageOptions();\n                opts.readExternal(lang);\n\n                setOptions(name, opts);\n            }\n        }\n        else\n        {\n            Element root = null;\n            Element jOpts = element.getChild(\"JavaOptions\");\n            if (jOpts != null) // version 2.1.x\n            {\n                root = jOpts;\n            }\n            else // versions 0.0.1 - 2.0.x\n            {\n                Element child = element.getChild(\"option\");\n                if (child != null && child.getAttribute(\"name\") != null)\n                {\n                    root = element;\n                }\n            }\n            if (root != null)\n            {\n                String lname = StdFileTypes.JAVA.getName();\n              // NOTE: If any change is made here you need to update ConfigTabFactory and UpdateCopyrightFactory too.\n              LanguageOptions opts = new LanguageOptions();\n                opts.setFileTypeOverride(LanguageOptions.USE_TEMPLATE);\n                List children = root.getChildren(\"option\");\n                for (Object option : children)\n                {\n                    String name = ((Element)option).getAttributeValue(\"name\");\n                    String val = ((Element)option).getAttributeValue(\"value\");\n                    if (\"body\".equals(name))\n                    {\n                        //todo opts.setNotice(val);\n                    }\n                    else if (\"location\".equals(name))\n                    {\n                        opts.setFileLocation(Integer.parseInt(val));\n                    }\n                }\n\n                setOptions(lname, opts);\n            }\n        }\n\n        logger.debug(\"options=\" + this);\n    }","commit_id":"923468c5848a891ae62854a81c3015f4f24a0887","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LanguageOptions getOptions(String name)\n    {\n        String lang = FileTypeUtil.getInstance().getFileTypeNameByName(name);\n        LanguageOptions res = options.get(lang);\n        if (res == null)\n        {\n            res = LanguageOptionsFactory.createOptions(lang);\n        }\n\n        return res;\n    }","id":11283,"modified_method":"public LanguageOptions getOptions(String name)\n    {\n        String lang = FileTypeUtil.getInstance().getFileTypeNameByName(name);\n        LanguageOptions res = options.get(lang);\n        if (res == null)\n        {\n          // NOTE: If any change is made here you need to update ConfigTabFactory and UpdateCopyrightFactory too.\n          res = new LanguageOptions();\n        }\n\n        return res;\n    }","commit_id":"923468c5848a891ae62854a81c3015f4f24a0887","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean verify(String text) throws Exception\n    {\n        VelocityEngine engine = getEngine();\n\n        VelocityContext vc = new VelocityContext();\n        vc.put(\"today\", new DateInfo());\n        StringWriter sw = new StringWriter();\n        return engine.evaluate(vc, sw, CopyrightManager.class.getName(), text);\n    }","id":11284,"modified_method":"public static void verify(String text) throws Exception\n    {\n        VelocityEngine engine = getEngine();\n\n        VelocityContext vc = new VelocityContext();\n        vc.put(\"today\", new DateInfo());\n        StringWriter sw = new StringWriter();\n        engine.evaluate(vc, sw, CopyrightManager.class.getName(), text);\n    }","commit_id":"923468c5848a891ae62854a81c3015f4f24a0887","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent event)\n    {\n        DataContext context = event.getDataContext();\n        Project project = (Project)context.getData(DataConstants.PROJECT);\n        Module module = (Module)context.getData(DataConstants.MODULE);\n        PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n        VirtualFile[] files = (VirtualFile[])context.getData(DataConstants.VIRTUAL_FILE_ARRAY);\n        Editor editor = (Editor)context.getData(DataConstants.EDITOR);\n\n        PsiFile file = null;\n        PsiDirectory dir;\n        if (editor != null)\n        {\n            file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n            if (file == null)\n            {\n                return;\n            }\n            dir = file.getContainingDirectory();\n        }\n        else\n        {\n            if (FileUtil.areFiles(files))\n            {\n                (new UpdateCopyrightProcessor(project, null, FileUtil.convertToPsiFiles(files, project))).run();\n\n                return;\n            }\n            Module modCtx = (Module)context.getData(DataConstants.MODULE_CONTEXT);\n            if (modCtx != null)\n            {\n                ModuleDlg dlg = new ModuleDlg(project, module);\n                dlg.show();\n                if (!dlg.isOK())\n                {\n                    return;\n                }\n\n                (new UpdateCopyrightProcessor(project, module)).run();\n\n                return;\n            }\n\n            PsiElement psielement = (PsiElement)context.getData(DataConstants.PSI_ELEMENT);\n            if (psielement == null)\n            {\n                return;\n            }\n\n            if (psielement instanceof PsiPackage)\n            {\n                dir = ((PsiPackage)psielement).getDirectories()[0];\n            }\n            else if (psielement instanceof PsiDirectory)\n            {\n                dir = (PsiDirectory)psielement;\n            }\n            else\n            {\n                file = psielement.getContainingFile();\n                if (file == null)\n                {\n                    return;\n                }\n                dir = file.getContainingDirectory();\n            }\n        }\n\n        RecursionDlg recDlg = new RecursionDlg(project, file != null ? file.getVirtualFile() : dir.getVirtualFile());\n        recDlg.show();\n        if (!recDlg.isOK())\n        {\n            return;\n        }\n\n        if (recDlg.isAll())\n        {\n            (new UpdateCopyrightProcessor(project, module, dir, recDlg.includeSubdirs())).run();\n        }\n\n        else\n        {\n            (new UpdateCopyrightProcessor(project, module, file)).run();\n        }\n    }","id":11285,"modified_method":"public void actionPerformed(AnActionEvent event) {\n    final DataContext context = event.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(context);\n    assert project != null;\n\n    final Module module = LangDataKeys.MODULE.getData(context);\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    final VirtualFile[] files = PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(context);\n    final Editor editor = PlatformDataKeys.EDITOR.getData(context);\n\n    PsiFile file = null;\n    PsiDirectory dir;\n    if (editor != null) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n      if (file == null) {\n        return;\n      }\n      dir = file.getContainingDirectory();\n    }\n    else {\n      if (FileUtil.areFiles(files)) {\n        new UpdateCopyrightProcessor(project, null, FileUtil.convertToPsiFiles(files, project)).run();\n        return;\n      }\n      final Module modCtx = LangDataKeys.MODULE_CONTEXT.getData(context);\n      if (modCtx != null) {\n        if (Messages.showOkCancelDialog(project, \"Update copyright for module \\'\" + modCtx.getName() + \"\\'?\", \"Update Copyright\", Messages.getQuestionIcon()) != DialogWrapper.OK_EXIT_CODE) return;\n        new UpdateCopyrightProcessor(project, module).run();\n        return;\n      }\n\n      final PsiElement psielement = LangDataKeys.PSI_ELEMENT.getData(context);\n      if (psielement == null) {\n        return;\n      }\n\n      if (psielement instanceof PsiPackage) {\n        dir = ((PsiPackage)psielement).getDirectories()[0];\n      }\n      else if (psielement instanceof PsiDirectory) {\n        dir = (PsiDirectory)psielement;\n      }\n      else {\n        file = psielement.getContainingFile();\n        if (file == null) {\n          return;\n        }\n        dir = file.getContainingDirectory();\n      }\n    }\n\n    final RecursionDlg recDlg = new RecursionDlg(project, file != null ? file.getVirtualFile() : dir.getVirtualFile());\n    recDlg.show();\n    if (!recDlg.isOK()) {\n      return;\n    }\n\n    if (recDlg.isAll()) {\n      new UpdateCopyrightProcessor(project, module, dir, recDlg.includeSubdirs()).run();\n    }\n    else {\n      new UpdateCopyrightProcessor(project, module, file).run();\n    }\n  }","commit_id":"8e01a32f1d3654345a041cb29a0aec2b2676d2b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent event)\n    {\n        Presentation presentation = event.getPresentation();\n        DataContext context = event.getDataContext();\n        Project project = (Project)context.getData(DataConstants.PROJECT);\n        if (project == null)\n        {\n            presentation.setEnabled(false);\n            return;\n        }\n\n        VirtualFile[] files = (VirtualFile[])context.getData(DataConstants.VIRTUAL_FILE_ARRAY);\n        Editor editor = (Editor)context.getData(DataConstants.EDITOR);\n        if (editor != null)\n        {\n            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n            if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file))\n            {\n                presentation.setEnabled(false);\n            }\n        }\n        else if (files != null && FileUtil.areFiles(files))\n        {\n            for (VirtualFile vfile : files)\n            {\n                PsiFile file = PsiManager.getInstance(project).findFile(vfile);\n                if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file.getVirtualFile()))\n                {\n                    presentation.setEnabled(false);\n                    return;\n                }\n            }\n\n            presentation.setEnabled(true);\n\n        }\n        else if ((files == null || files.length != 1) && context.getData(DataConstants.MODULE_CONTEXT) == null &&\n            context.getData(DataConstants.PROJECT_CONTEXT) == null)\n        {\n            PsiElement elem = (PsiElement)context.getData(DataConstants.PSI_ELEMENT);\n            if (elem == null)\n            {\n                presentation.setEnabled(false);\n                return;\n            }\n\n            if (!(elem instanceof PsiDirectory))\n            {\n                PsiFile file = elem.getContainingFile();\n                if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file.getVirtualFile()))\n                {\n                    presentation.setEnabled(false);\n\n                }\n            }\n        }\n    }","id":11286,"modified_method":"public void update(AnActionEvent event) {\n    final Presentation presentation = event.getPresentation();\n    final DataContext context = event.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(context);\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    final VirtualFile[] files = PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(context);\n    final Editor editor = PlatformDataKeys.EDITOR.getData(context);\n    if (editor != null) {\n      final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n      if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file)) {\n        presentation.setEnabled(false);\n        return;\n      }\n    }\n    else if (files != null && FileUtil.areFiles(files)) {\n      for (VirtualFile vfile : files) {\n        final PsiFile file = PsiManager.getInstance(project).findFile(vfile);\n        if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file.getVirtualFile())) {\n          presentation.setEnabled(false);\n          return;\n        }\n      }\n\n    }\n    else if ((files == null || files.length != 1) &&\n             LangDataKeys.MODULE_CONTEXT.getData(context) == null &&\n             PlatformDataKeys.PROJECT_CONTEXT.getData(context) == null) {\n      final PsiElement elem = LangDataKeys.PSI_ELEMENT.getData(context);\n      if (elem == null) {\n        presentation.setEnabled(false);\n        return;\n      }\n\n      if (!(elem instanceof PsiDirectory)) {\n        final PsiFile file = elem.getContainingFile();\n        if (file == null || !FileTypeUtil.getInstance().isSupportedFile(file.getVirtualFile())) {\n          presentation.setEnabled(false);\n          return;\n        }\n      }\n    }\n    presentation.setEnabled(true);\n  }","commit_id":"8e01a32f1d3654345a041cb29a0aec2b2676d2b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Presentation presentation = e.getPresentation();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    if (project == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n    VirtualFile file = (VirtualFile)dataContext.getData(DataConstants.VIRTUAL_FILE);\n    if (file == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    boolean isXml = StdFileTypes.XML.equals(FileTypeManager.getInstance().getFileTypeByFile(file));\n    if (!isXml) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    for (final AntBuildFile buildFile : AntConfiguration.getInstance(project).getBuildFiles()) {\n      if (file.equals(buildFile.getVirtualFile())) {\n        presentation.setEnabled(false);\n        presentation.setVisible(false);\n        return;\n      }\n    }\n\n    presentation.setEnabled(true);\n    presentation.setVisible(true);\n  }","id":11287,"modified_method":"public void update(AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Presentation presentation = e.getPresentation();\n    Project project = DataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n    VirtualFile file = DataKeys.VIRTUAL_FILE.getData(dataContext);\n    if (file == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    boolean isXml = StdFileTypes.XML.equals(FileTypeManager.getInstance().getFileTypeByFile(file));\n    if (!isXml) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    for (final AntBuildFile buildFile : AntConfiguration.getInstance(project).getBuildFiles()) {\n      if (file.equals(buildFile.getVirtualFile())) {\n        presentation.setEnabled(false);\n        presentation.setVisible(false);\n        return;\n      }\n    }\n\n    presentation.setEnabled(true);\n    presentation.setVisible(true);\n  }","commit_id":"752bddfa7e0e5bb03299a53a87095996d897a417","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent event) {\n    DataContext dataContext = event.getDataContext();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    VirtualFile file = (VirtualFile)dataContext.getData(DataConstants.VIRTUAL_FILE);\n    AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n    try {\n      antConfiguration.addBuildFile(file);\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n    catch (AntNoFileException e) {\n      Messages.showWarningDialog(project, AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\",\n                                                            e.getFile().getPresentableUrl()),\n                                          AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n  }","id":11288,"modified_method":"public void actionPerformed(AnActionEvent event) {\n    DataContext dataContext = event.getDataContext();\n    Project project = DataKeys.PROJECT.getData(dataContext);\n    VirtualFile file = DataKeys.VIRTUAL_FILE.getData(dataContext);\n    AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n    try {\n      antConfiguration.addBuildFile(file);\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n    catch (AntNoFileException e) {\n      Messages.showWarningDialog(project, AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\",\n                                                            e.getFile().getPresentableUrl()),\n                                          AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n  }","commit_id":"752bddfa7e0e5bb03299a53a87095996d897a417","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n\n    Collection<AbstractTreeNode> nodesToAdd = getNodesToAdd(dataContext, true);\n\n    if (nodesToAdd != null && !nodesToAdd.isEmpty()) {\n      Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n      FavoritesManager.getInstance(project).addRoots(myFavoritesListName, nodesToAdd);\n    }\n  }","id":11289,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n\n    Collection<AbstractTreeNode> nodesToAdd = getNodesToAdd(dataContext, true);\n\n    if (nodesToAdd != null && !nodesToAdd.isEmpty()) {\n      Project project = e.getData(DataKeys.PROJECT);\n      FavoritesManager.getInstance(project).addRoots(myFavoritesListName, nodesToAdd);\n    }\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Object collectSelectedElements(final DataContext dataContext) {\n    Object elements = retrieveData(null, dataContext.getData(DataConstantsEx.RESOURCE_BUNDLE_ARRAY));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.PSI_ELEMENT_ARRAY));\n    elements = retrieveData(elements, dataContext.getData(DataConstants.PSI_ELEMENT));\n    elements = retrieveData(elements, dataContext.getData(DataConstants.PSI_FILE));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.VIRTUAL_FILE_ARRAY));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.VIRTUAL_FILE));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.MODULE_GROUP_ARRAY));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.MODULE_CONTEXT_ARRAY));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.MODULE));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.LIBRARY_GROUP_ARRAY));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.NAMED_LIBRARY_ARRAY));\n    return elements;\n  }","id":11290,"modified_method":"private static Object collectSelectedElements(final DataContext dataContext) {\n    Object elements = retrieveData(null, dataContext.getData(DataConstantsEx.RESOURCE_BUNDLE_ARRAY));\n    elements = retrieveData(elements, DataKeys.PSI_ELEMENT_ARRAY.getData(dataContext));\n    elements = retrieveData(elements, DataKeys.PSI_ELEMENT.getData(dataContext));\n    elements = retrieveData(elements, DataKeys.PSI_FILE.getData(dataContext));\n    elements = retrieveData(elements, DataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext));\n    elements = retrieveData(elements, DataKeys.VIRTUAL_FILE.getData(dataContext));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.MODULE_GROUP_ARRAY));\n    elements = retrieveData(elements, DataKeys.MODULE_CONTEXT_ARRAY.getData(dataContext));\n    elements = retrieveData(elements, DataKeys.MODULE.getData(dataContext));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.LIBRARY_GROUP_ARRAY));\n    elements = retrieveData(elements, dataContext.getData(DataConstantsEx.NAMED_LIBRARY_ARRAY));\n    return elements;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    if (project == null) {\n      e.getPresentation().setEnabled(false);\n    }\n    else {\n      e.getPresentation().setEnabled(canCreateNodes(dataContext, e));\n    }\n  }","id":11291,"modified_method":"public void update(AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    Project project = (Project)e.getData(DataKeys.PROJECT);\n    if (project == null) {\n      e.getPresentation().setEnabled(false);\n    }\n    else {\n      e.getPresentation().setEnabled(canCreateNodes(dataContext, e));\n    }\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Collection<AbstractTreeNode> getNodesToAdd(final DataContext dataContext, final boolean inProjectView) {\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n\n    if (project == null) return null;\n\n    Module moduleContext = (Module)dataContext.getData(DataConstants.MODULE_CONTEXT);\n\n    Collection<AbstractTreeNode> nodesToAdd = null;\n    FavoriteNodeProvider[] providers = ApplicationManager.getApplication().getComponents(FavoriteNodeProvider.class);\n    for(FavoriteNodeProvider provider: providers) {\n      nodesToAdd = provider.getFavoriteNodes(dataContext, ViewSettings.DEFAULT);\n      if (nodesToAdd != null) {\n        break;\n      }\n    }\n\n    if (nodesToAdd == null) {\n      Object elements = collectSelectedElements(dataContext);\n      if (elements != null) {\n        nodesToAdd = createNodes(project, moduleContext, elements, inProjectView, ViewSettings.DEFAULT);\n      }\n    }\n    return nodesToAdd;\n  }","id":11292,"modified_method":"public static Collection<AbstractTreeNode> getNodesToAdd(final DataContext dataContext, final boolean inProjectView) {\n    Project project = DataKeys.PROJECT.getData(dataContext);\n\n    if (project == null) return null;\n\n    Module moduleContext = DataKeys.MODULE_CONTEXT.getData(dataContext);\n\n    Collection<AbstractTreeNode> nodesToAdd = null;\n    FavoriteNodeProvider[] providers = Extensions.getExtensions(FavoriteNodeProvider.EP_NAME); \n    for(FavoriteNodeProvider provider: providers) {\n      nodesToAdd = provider.getFavoriteNodes(dataContext, ViewSettings.DEFAULT);\n      if (nodesToAdd != null) {\n        break;\n      }\n    }\n\n    if (nodesToAdd == null) {\n      Object elements = collectSelectedElements(dataContext);\n      if (elements != null) {\n        nodesToAdd = createNodes(project, moduleContext, elements, inProjectView, ViewSettings.DEFAULT);\n      }\n    }\n    return nodesToAdd;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static AbstractUrl readUrlFromElement(Element element) {\n    final String type = element.getAttributeValue(ATTRIBUTE_TYPE);\n    final String urlValue = element.getAttributeValue(ATTRIBUTE_URL);\n    final String moduleName = element.getAttributeValue(ATTRIBUTE_MODULE);\n\n    for(FavoriteNodeProvider nodeProvider: ApplicationManager.getApplication().getComponents(FavoriteNodeProvider.class)) {\n      if (nodeProvider.getFavoriteTypeId().equals(type)) {\n        return new AbstractUrlFavoriteAdapter(urlValue, moduleName, nodeProvider);\n      }\n    }\n\n    for (AbstractUrl urlProvider : ourAbstractUrlProviders) {\n      AbstractUrl url = urlProvider.createUrl(type, moduleName, urlValue);\n      if (url != null) return url;\n    }\n    return null;\n  }","id":11293,"modified_method":"@Nullable\n  private static AbstractUrl readUrlFromElement(Element element) {\n    final String type = element.getAttributeValue(ATTRIBUTE_TYPE);\n    final String urlValue = element.getAttributeValue(ATTRIBUTE_URL);\n    final String moduleName = element.getAttributeValue(ATTRIBUTE_MODULE);\n\n    for(FavoriteNodeProvider nodeProvider: Extensions.getExtensions(FavoriteNodeProvider.EP_NAME)) {\n      if (nodeProvider.getFavoriteTypeId().equals(type)) {\n        return new AbstractUrlFavoriteAdapter(urlValue, moduleName, nodeProvider);\n      }\n    }\n\n    for (AbstractUrl urlProvider : ourAbstractUrlProviders) {\n      AbstractUrl url = urlProvider.createUrl(type, moduleName, urlValue);\n      if (url != null) return url;\n    }\n    return null;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static @Nullable AbstractUrl createUrlByElement(Object element) {\n    if (element instanceof SmartPsiElementPointer) element = ((SmartPsiElementPointer)element).getElement();\n                                                                                                                                               \n    for(FavoriteNodeProvider nodeProvider: ApplicationManager.getApplication().getComponents(FavoriteNodeProvider.class)) {\n      String url = nodeProvider.getElementUrl(element);\n      if (url != null) {\n        return new AbstractUrlFavoriteAdapter(url, nodeProvider.getElementModuleName(element), nodeProvider);\n      }\n    }\n\n    for (AbstractUrl urlProvider : ourAbstractUrlProviders) {\n      AbstractUrl url = urlProvider.createUrlByElement(element);\n      if (url != null) return url;\n    }\n    return null;\n  }","id":11294,"modified_method":"private static @Nullable AbstractUrl createUrlByElement(Object element) {\n    if (element instanceof SmartPsiElementPointer) element = ((SmartPsiElementPointer)element).getElement();\n                                                                                                                                               \n    for(FavoriteNodeProvider nodeProvider: Extensions.getExtensions(FavoriteNodeProvider.EP_NAME)) {\n      String url = nodeProvider.getElementUrl(element);\n      if (url != null) {\n        return new AbstractUrlFavoriteAdapter(url, nodeProvider.getElementModuleName(element), nodeProvider);\n      }\n    }\n\n    for (AbstractUrl urlProvider : ourAbstractUrlProviders) {\n      AbstractUrl url = urlProvider.createUrlByElement(element);\n      if (url != null) return url;\n    }\n    return null;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean contains(@NotNull String name, @NotNull final VirtualFile vFile){\n    final ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    final Set<Boolean> find = new HashSet<Boolean>();\n    final ContentIterator contentIterator = new ContentIterator() {\n      public boolean processFile(VirtualFile fileOrDir) {\n        if (fileOrDir == null ? vFile == null : fileOrDir.getPath().equals(vFile.getPath())) {\n          find.add(Boolean.TRUE);\n        }\n        return true;\n      }\n    };\n\n    FavoriteNodeProvider[] providers = ApplicationManager.getApplication().getComponents(FavoriteNodeProvider.class);\n\n    List<Pair<AbstractUrl, String>> urls = getFavoritesListRootUrls(name);\n    for (Pair<AbstractUrl, String> pair : urls) {\n      AbstractUrl abstractUrl = pair.getFirst();\n      if (abstractUrl == null) {\n        continue;\n      }\n      final Object[] path = abstractUrl.createPath(myProject);\n      if (path == null || path.length < 1 || path[0] == null) {\n        continue;\n      }\n      Object element = path[path.length - 1];\n      if (element instanceof SmartPsiElementPointer) {\n        final VirtualFile virtualFile = PsiUtil.getVirtualFile(((SmartPsiElementPointer)element).getElement());\n        if (virtualFile == null) continue;\n        if (vFile.getPath().equals(virtualFile.getPath())) {\n          return true;\n        }\n        if (!virtualFile.isDirectory()) {\n          continue;\n        }\n        projectFileIndex.iterateContentUnderDirectory(virtualFile, contentIterator);\n      }\n      if (element instanceof PackageElement) {\n        final PackageElement packageElement = (PackageElement)element;\n        final PsiPackage aPackage = packageElement.getPackage();\n        GlobalSearchScope scope = packageElement.getModule() != null ? GlobalSearchScope.moduleScope(packageElement.getModule()) : GlobalSearchScope.projectScope(myProject);\n        final PsiDirectory[] directories = aPackage.getDirectories(scope);\n        for (PsiDirectory directory : directories) {\n          projectFileIndex.iterateContentUnderDirectory(directory.getVirtualFile(), contentIterator);\n        }\n      }\n      if (element instanceof PsiElement) {\n        final VirtualFile virtualFile = PsiUtil.getVirtualFile((PsiElement)element);\n        if (virtualFile == null) continue;\n        if (vFile.getPath().equals(virtualFile.getPath())){\n          return true;\n        }\n        if (!virtualFile.isDirectory()){\n          continue;\n        }\n        projectFileIndex.iterateContentUnderDirectory(virtualFile, contentIterator);\n      }\n      if (element instanceof Module){\n        ModuleRootManager.getInstance((Module)element).getFileIndex().iterateContent(contentIterator);\n      }\n      if (element instanceof LibraryGroupElement){\n        final boolean inLibrary =\n          ModuleRootManager.getInstance(((LibraryGroupElement)element).getModule()).getFileIndex().isInContent(vFile) &&\n          projectFileIndex.isInLibraryClasses(vFile);\n        if (inLibrary){\n          return true;\n        }\n      }\n      if (element instanceof NamedLibraryElement){\n        NamedLibraryElement namedLibraryElement = (NamedLibraryElement)element;\n        final VirtualFile[] files = namedLibraryElement.getOrderEntry().getFiles(OrderRootType.CLASSES);\n        if (files != null && ArrayUtil.find(files, vFile) > -1){\n          return true;\n        }\n      }\n      if (element instanceof ModuleGroup){\n        ModuleGroup group = (ModuleGroup) element;\n        final Collection<Module> modules = group.modulesInGroup(myProject, true);\n        for (Module module : modules) {\n          ModuleRootManager.getInstance(module).getFileIndex().iterateContent(contentIterator);\n        }\n      }\n      if (element instanceof ResourceBundle) {\n        ResourceBundle bundle = (ResourceBundle)element;\n        final List<PropertiesFile> propertiesFiles = bundle.getPropertiesFiles(myProject);\n        for (PropertiesFile file : propertiesFiles) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile == null) continue;\n          if (vFile.getPath().equals(virtualFile.getPath())){\n            return true;\n          }\n        }\n      }\n\n      for(FavoriteNodeProvider provider: providers) {\n        if (provider.elementContainsFile(element, vFile)) {\n          return true;\n        }\n      }\n\n      if (!find.isEmpty()){\n        return true;\n      }\n    }\n    return false;\n  }","id":11295,"modified_method":"public boolean contains(@NotNull String name, @NotNull final VirtualFile vFile){\n    final ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    final Set<Boolean> find = new HashSet<Boolean>();\n    final ContentIterator contentIterator = new ContentIterator() {\n      public boolean processFile(VirtualFile fileOrDir) {\n        if (fileOrDir == null ? vFile == null : fileOrDir.getPath().equals(vFile.getPath())) {\n          find.add(Boolean.TRUE);\n        }\n        return true;\n      }\n    };\n\n    FavoriteNodeProvider[] providers = Extensions.getExtensions(FavoriteNodeProvider.EP_NAME);\n\n    List<Pair<AbstractUrl, String>> urls = getFavoritesListRootUrls(name);\n    for (Pair<AbstractUrl, String> pair : urls) {\n      AbstractUrl abstractUrl = pair.getFirst();\n      if (abstractUrl == null) {\n        continue;\n      }\n      final Object[] path = abstractUrl.createPath(myProject);\n      if (path == null || path.length < 1 || path[0] == null) {\n        continue;\n      }\n      Object element = path[path.length - 1];\n      if (element instanceof SmartPsiElementPointer) {\n        final VirtualFile virtualFile = PsiUtil.getVirtualFile(((SmartPsiElementPointer)element).getElement());\n        if (virtualFile == null) continue;\n        if (vFile.getPath().equals(virtualFile.getPath())) {\n          return true;\n        }\n        if (!virtualFile.isDirectory()) {\n          continue;\n        }\n        projectFileIndex.iterateContentUnderDirectory(virtualFile, contentIterator);\n      }\n      if (element instanceof PackageElement) {\n        final PackageElement packageElement = (PackageElement)element;\n        final PsiPackage aPackage = packageElement.getPackage();\n        GlobalSearchScope scope = packageElement.getModule() != null ? GlobalSearchScope.moduleScope(packageElement.getModule()) : GlobalSearchScope.projectScope(myProject);\n        final PsiDirectory[] directories = aPackage.getDirectories(scope);\n        for (PsiDirectory directory : directories) {\n          projectFileIndex.iterateContentUnderDirectory(directory.getVirtualFile(), contentIterator);\n        }\n      }\n      if (element instanceof PsiElement) {\n        final VirtualFile virtualFile = PsiUtil.getVirtualFile((PsiElement)element);\n        if (virtualFile == null) continue;\n        if (vFile.getPath().equals(virtualFile.getPath())){\n          return true;\n        }\n        if (!virtualFile.isDirectory()){\n          continue;\n        }\n        projectFileIndex.iterateContentUnderDirectory(virtualFile, contentIterator);\n      }\n      if (element instanceof Module){\n        ModuleRootManager.getInstance((Module)element).getFileIndex().iterateContent(contentIterator);\n      }\n      if (element instanceof LibraryGroupElement){\n        final boolean inLibrary =\n          ModuleRootManager.getInstance(((LibraryGroupElement)element).getModule()).getFileIndex().isInContent(vFile) &&\n          projectFileIndex.isInLibraryClasses(vFile);\n        if (inLibrary){\n          return true;\n        }\n      }\n      if (element instanceof NamedLibraryElement){\n        NamedLibraryElement namedLibraryElement = (NamedLibraryElement)element;\n        final VirtualFile[] files = namedLibraryElement.getOrderEntry().getFiles(OrderRootType.CLASSES);\n        if (files != null && ArrayUtil.find(files, vFile) > -1){\n          return true;\n        }\n      }\n      if (element instanceof ModuleGroup){\n        ModuleGroup group = (ModuleGroup) element;\n        final Collection<Module> modules = group.modulesInGroup(myProject, true);\n        for (Module module : modules) {\n          ModuleRootManager.getInstance(module).getFileIndex().iterateContent(contentIterator);\n        }\n      }\n      if (element instanceof ResourceBundle) {\n        ResourceBundle bundle = (ResourceBundle)element;\n        final List<PropertiesFile> propertiesFiles = bundle.getPropertiesFiles(myProject);\n        for (PropertiesFile file : propertiesFiles) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile == null) continue;\n          if (vFile.getPath().equals(virtualFile.getPath())){\n            return true;\n          }\n        }\n      }\n\n      for(FavoriteNodeProvider provider: providers) {\n        if (provider.elementContainsFile(element, vFile)) {\n          return true;\n        }\n      }\n\n      if (!find.isEmpty()){\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getLocation(){\n    Object nodeElement = myElement.getValue();\n    if (nodeElement instanceof SmartPsiElementPointer){\n      nodeElement = ((SmartPsiElementPointer)nodeElement).getElement();\n    }\n    if (nodeElement instanceof PsiElement){\n      if (nodeElement instanceof PsiClass){\n        return ClassPresentationUtil.getNameForClass((PsiClass)nodeElement, true);\n      }\n      if (nodeElement instanceof PsiDirectory){\n        return ((PsiDirectory)nodeElement).getVirtualFile().getPresentableUrl();\n      }\n      final PsiElement parent = ((PsiElement)nodeElement).getParent();\n      if (parent instanceof PsiClass){\n        return ClassPresentationUtil.getNameForClass((PsiClass)parent, true);\n      }\n      if (parent == null) return \"\";\n      final PsiFile containingFile = nodeElement instanceof PsiFile ? (PsiFile)nodeElement : parent.getContainingFile();\n      return containingFile != null ? containingFile.getVirtualFile().getPresentableUrl() : \"\";\n    }\n    if (nodeElement instanceof PackageElement){\n      final PackageElement packageElement = ((PackageElement)nodeElement);\n      final Module module = packageElement.getModule();\n      return (module != null ? (module.getName() + \":\") : \"\") + packageElement.getPackage().getQualifiedName();\n    }\n    if (nodeElement instanceof LibraryGroupElement){\n      return ((LibraryGroupElement)nodeElement).getModule().getName();\n    }\n    if (nodeElement instanceof NamedLibraryElement){\n      final NamedLibraryElement namedLibraryElement = ((NamedLibraryElement)nodeElement);\n      final LibraryGroupElement parent = namedLibraryElement.getParent();\n      return parent.getModule().getName() + \":\" + namedLibraryElement.getOrderEntry().getPresentableName();\n    }\n    final FavoriteNodeProvider[] nodeProviders = ApplicationManager.getApplication().getComponents(FavoriteNodeProvider.class);\n    for(FavoriteNodeProvider provider: nodeProviders) {\n      String location = provider.getElementLocation(nodeElement);\n      if (location != null) return location;\n    }\n    return null;\n  }","id":11296,"modified_method":"public String getLocation(){\n    Object nodeElement = myElement.getValue();\n    if (nodeElement instanceof SmartPsiElementPointer){\n      nodeElement = ((SmartPsiElementPointer)nodeElement).getElement();\n    }\n    if (nodeElement instanceof PsiElement){\n      if (nodeElement instanceof PsiClass){\n        return ClassPresentationUtil.getNameForClass((PsiClass)nodeElement, true);\n      }\n      if (nodeElement instanceof PsiDirectory){\n        return ((PsiDirectory)nodeElement).getVirtualFile().getPresentableUrl();\n      }\n      final PsiElement parent = ((PsiElement)nodeElement).getParent();\n      if (parent instanceof PsiClass){\n        return ClassPresentationUtil.getNameForClass((PsiClass)parent, true);\n      }\n      if (parent == null) return \"\";\n      final PsiFile containingFile = nodeElement instanceof PsiFile ? (PsiFile)nodeElement : parent.getContainingFile();\n      return containingFile != null ? containingFile.getVirtualFile().getPresentableUrl() : \"\";\n    }\n    if (nodeElement instanceof PackageElement){\n      final PackageElement packageElement = ((PackageElement)nodeElement);\n      final Module module = packageElement.getModule();\n      return (module != null ? (module.getName() + \":\") : \"\") + packageElement.getPackage().getQualifiedName();\n    }\n    if (nodeElement instanceof LibraryGroupElement){\n      return ((LibraryGroupElement)nodeElement).getModule().getName();\n    }\n    if (nodeElement instanceof NamedLibraryElement){\n      final NamedLibraryElement namedLibraryElement = ((NamedLibraryElement)nodeElement);\n      final LibraryGroupElement parent = namedLibraryElement.getParent();\n      return parent.getModule().getName() + \":\" + namedLibraryElement.getOrderEntry().getPresentableName();\n    }\n    final FavoriteNodeProvider[] nodeProviders = Extensions.getExtensions(FavoriteNodeProvider.EP_NAME);\n    for(FavoriteNodeProvider provider: nodeProviders) {\n      String location = provider.getElementLocation(nodeElement);\n      if (location != null) return location;\n    }\n    return null;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getChildElements(Object element) {\n    if (!(element instanceof AbstractTreeNode)) {\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n    final AbstractTreeNode favoritesTreeElement = (AbstractTreeNode)element;\n    try {\n      if (element != getRootElement()) {\n        return super.getChildElements(favoritesTreeElement);\n      }\n      Set<AbstractTreeNode> result = new HashSet<AbstractTreeNode>();\n      for (AbstractTreeNode<?> abstractTreeNode : getFavoritesRoots()) {\n        final Object val = abstractTreeNode.getValue();\n        if (val == null) {\n          continue;\n        }\n        if (val instanceof PsiElement && !((PsiElement)val).isValid()) {\n          continue;\n        }\n        if (val instanceof SmartPsiElementPointer && ((SmartPsiElementPointer)val).getElement() == null) {\n          continue;\n        }\n        if (val instanceof ResourceBundle) {\n          ResourceBundle resourceBundle = (ResourceBundle)val;\n          List<PropertiesFile> propertiesFiles = resourceBundle.getPropertiesFiles(myProject);\n          if (propertiesFiles.size() == 1) {\n            result.add(new PsiFileNode(myProject, propertiesFiles.iterator().next(), this));\n            continue;\n          }\n        }\n\n        boolean isInvalid = false;\n        for(FavoriteNodeProvider nodeProvider: ApplicationManager.getApplication().getComponents(FavoriteNodeProvider.class)) {\n          if (nodeProvider.isInvalidElement(val)) {\n            isInvalid = true;\n            break;\n          }\n        }\n        if (isInvalid) continue;\n\n        result.add(abstractTreeNode);\n      }\n      //myFavoritesRoots = result;\n      if (result.isEmpty()) {\n        result.add(getEmptyScreen());\n      }\n      return result.toArray(new Object[result.size()]);\n    }\n    catch (Exception e) {\n    }\n\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","id":11297,"modified_method":"public Object[] getChildElements(Object element) {\n    if (!(element instanceof AbstractTreeNode)) {\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n    final AbstractTreeNode favoritesTreeElement = (AbstractTreeNode)element;\n    try {\n      if (element != getRootElement()) {\n        return super.getChildElements(favoritesTreeElement);\n      }\n      Set<AbstractTreeNode> result = new HashSet<AbstractTreeNode>();\n      for (AbstractTreeNode<?> abstractTreeNode : getFavoritesRoots()) {\n        final Object val = abstractTreeNode.getValue();\n        if (val == null) {\n          continue;\n        }\n        if (val instanceof PsiElement && !((PsiElement)val).isValid()) {\n          continue;\n        }\n        if (val instanceof SmartPsiElementPointer && ((SmartPsiElementPointer)val).getElement() == null) {\n          continue;\n        }\n        if (val instanceof ResourceBundle) {\n          ResourceBundle resourceBundle = (ResourceBundle)val;\n          List<PropertiesFile> propertiesFiles = resourceBundle.getPropertiesFiles(myProject);\n          if (propertiesFiles.size() == 1) {\n            result.add(new PsiFileNode(myProject, propertiesFiles.iterator().next(), this));\n            continue;\n          }\n        }\n\n        boolean isInvalid = false;\n        for(FavoriteNodeProvider nodeProvider: Extensions.getExtensions(FavoriteNodeProvider.EP_NAME)) {\n          if (nodeProvider.isInvalidElement(val)) {\n            isInvalid = true;\n            break;\n          }\n        }\n        if (isInvalid) continue;\n\n        result.add(abstractTreeNode);\n      }\n      //myFavoritesRoots = result;\n      if (result.isEmpty()) {\n        result.add(getEmptyScreen());\n      }\n      return result.toArray(new Object[result.size()]);\n    }\n    catch (Exception e) {\n    }\n\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FavoritesViewTreeBuilder(Project project,\n                                  JTree tree,\n                                  DefaultTreeModel treeModel,\n                                  ProjectAbstractTreeStructureBase treeStructure,\n                                  final String name) {\n    super(project, tree, treeModel, treeStructure, null);\n    myListName = name;\n    final FavoriteNodeProvider[] nodeProviders = ApplicationManager.getApplication().getComponents(FavoriteNodeProvider.class);\n    setNodeDescriptorComparator(new Comparator<NodeDescriptor>(){\n      private int getWeight(NodeDescriptor descriptor) {\n        FavoritesTreeNodeDescriptor favoritesTreeNodeDescriptor = (FavoritesTreeNodeDescriptor)descriptor;\n        Object value = favoritesTreeNodeDescriptor.getElement().getValue();\n        if (value instanceof SmartPsiElementPointer){\n          value = ((SmartPsiElementPointer)value).getElement();\n        }\n        if (value instanceof ModuleGroup){\n          return 0;\n        }\n        if (value instanceof Module){\n          return 1;\n        }\n        if (value instanceof PsiDirectory || value instanceof PackageElement){\n          return 2;\n        }\n        if (value instanceof PsiFile){\n          return 4;\n        }\n        if (value instanceof PsiClass){\n          return 5;\n        }\n        if (value instanceof PsiField){\n          return 6;\n        }\n        if (value instanceof PsiMethod){\n          return 7;\n        }\n        if (value instanceof PsiElement){\n          return 8;\n        }\n        if (value instanceof LibraryGroupElement){\n          return 10;\n        }\n        if (value instanceof NamedLibraryElement){\n          return 11;\n        }\n        for(FavoriteNodeProvider provider: nodeProviders) {\n          int weight = provider.getElementWeight(value);\n          if (weight != -1) return weight;\n        }\n        return 12;\n      }\n\n      public int compare(NodeDescriptor nd1, NodeDescriptor nd2) {\n        if (nd1 instanceof FavoritesTreeNodeDescriptor && nd2 instanceof FavoritesTreeNodeDescriptor){\n          FavoritesTreeNodeDescriptor fd1 = (FavoritesTreeNodeDescriptor)nd1;\n          FavoritesTreeNodeDescriptor fd2 = (FavoritesTreeNodeDescriptor)nd2;\n          int weight1 = getWeight(fd1);\n          int weight2 = getWeight(fd2);\n          if (weight1 != weight2) {\n            return weight1 - weight2;\n          }\n          String s1 = fd1.toString();\n          String s2 = fd2.toString();\n          if (s1 == null) return s2 == null ? 0 : -1;\n          if (s2 == null) return +1;\n          if (!s1.equals(s2)) {\n            return s1.compareToIgnoreCase(s2);\n          }\n          else {\n            s1 = fd1.getLocation();\n            s2 = fd2.getLocation();\n            if (s1 == null) return s2 == null ? 0 : -1;\n            if (s2 == null) return +1;\n            return s1.compareToIgnoreCase(s2);\n          }\n        }\n        return 0;\n      }\n    });\n\n    final MessageBusConnection connection = myProject.getMessageBus().connect(this);\n    myPsiTreeChangeListener = new ProjectViewPsiTreeChangeListener() {\n      protected DefaultMutableTreeNode getRootNode() {\n        return myRootNode;\n      }\n\n      protected AbstractTreeUpdater getUpdater() {\n        return myUpdater;\n      }\n\n      protected boolean isFlattenPackages() {\n        return ((FavoritesTreeStructure)myTreeStructure).isFlattenPackages();\n      }\n\n      protected void childrenChanged(PsiElement parent) {\n        if (findNodeByElement(parent) == null){\n          getUpdater().addSubtreeToUpdate(getRootNode());\n        } else {\n          super.childrenChanged(parent);\n        }\n      }\n    };\n    connection.subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      public void rootsChanged(ModuleRootEvent event) {\n        myUpdater.addSubtreeToUpdate(myRootNode);\n      }\n    });\n    PsiManager.getInstance(myProject).addPsiTreeChangeListener(myPsiTreeChangeListener);\n    myFileStatusListener = new MyFileStatusListener();\n    FileStatusManager.getInstance(myProject).addFileStatusListener(myFileStatusListener);\n    myCopyPasteListener = new CopyPasteUtil.DefaultCopyPasteListener(myUpdater);\n    CopyPasteManager.getInstance().addContentChangedListener(myCopyPasteListener);\n\n    myFavoritesListener = new FavoritesManager.FavoritesListener() {\n      public void rootsChanged(String listName) {\n        if (myListName.equals(listName)) {\n          updateFromRoot();\n        }\n      }\n\n      public void listAdded(String listName) {\n        updateFromRoot();\n      }\n\n      public void listRemoved(String listName) {\n        updateFromRoot();\n      }\n    };\n    FavoritesManager.getInstance(myProject).addFavoritesListener(myFavoritesListener);\n    initRootNode();\n  }","id":11298,"modified_method":"public FavoritesViewTreeBuilder(Project project,\n                                  JTree tree,\n                                  DefaultTreeModel treeModel,\n                                  ProjectAbstractTreeStructureBase treeStructure,\n                                  final String name) {\n    super(project, tree, treeModel, treeStructure, null);\n    myListName = name;\n    final FavoriteNodeProvider[] nodeProviders = Extensions.getExtensions(FavoriteNodeProvider.EP_NAME);\n    setNodeDescriptorComparator(new Comparator<NodeDescriptor>(){\n      private int getWeight(NodeDescriptor descriptor) {\n        FavoritesTreeNodeDescriptor favoritesTreeNodeDescriptor = (FavoritesTreeNodeDescriptor)descriptor;\n        Object value = favoritesTreeNodeDescriptor.getElement().getValue();\n        if (value instanceof SmartPsiElementPointer){\n          value = ((SmartPsiElementPointer)value).getElement();\n        }\n        if (value instanceof ModuleGroup){\n          return 0;\n        }\n        if (value instanceof Module){\n          return 1;\n        }\n        if (value instanceof PsiDirectory || value instanceof PackageElement){\n          return 2;\n        }\n        if (value instanceof PsiFile){\n          return 4;\n        }\n        if (value instanceof PsiClass){\n          return 5;\n        }\n        if (value instanceof PsiField){\n          return 6;\n        }\n        if (value instanceof PsiMethod){\n          return 7;\n        }\n        if (value instanceof PsiElement){\n          return 8;\n        }\n        if (value instanceof LibraryGroupElement){\n          return 10;\n        }\n        if (value instanceof NamedLibraryElement){\n          return 11;\n        }\n        for(FavoriteNodeProvider provider: nodeProviders) {\n          int weight = provider.getElementWeight(value);\n          if (weight != -1) return weight;\n        }\n        return 12;\n      }\n\n      public int compare(NodeDescriptor nd1, NodeDescriptor nd2) {\n        if (nd1 instanceof FavoritesTreeNodeDescriptor && nd2 instanceof FavoritesTreeNodeDescriptor){\n          FavoritesTreeNodeDescriptor fd1 = (FavoritesTreeNodeDescriptor)nd1;\n          FavoritesTreeNodeDescriptor fd2 = (FavoritesTreeNodeDescriptor)nd2;\n          int weight1 = getWeight(fd1);\n          int weight2 = getWeight(fd2);\n          if (weight1 != weight2) {\n            return weight1 - weight2;\n          }\n          String s1 = fd1.toString();\n          String s2 = fd2.toString();\n          if (s1 == null) return s2 == null ? 0 : -1;\n          if (s2 == null) return +1;\n          if (!s1.equals(s2)) {\n            return s1.compareToIgnoreCase(s2);\n          }\n          else {\n            s1 = fd1.getLocation();\n            s2 = fd2.getLocation();\n            if (s1 == null) return s2 == null ? 0 : -1;\n            if (s2 == null) return +1;\n            return s1.compareToIgnoreCase(s2);\n          }\n        }\n        return 0;\n      }\n    });\n\n    final MessageBusConnection connection = myProject.getMessageBus().connect(this);\n    myPsiTreeChangeListener = new ProjectViewPsiTreeChangeListener() {\n      protected DefaultMutableTreeNode getRootNode() {\n        return myRootNode;\n      }\n\n      protected AbstractTreeUpdater getUpdater() {\n        return myUpdater;\n      }\n\n      protected boolean isFlattenPackages() {\n        return ((FavoritesTreeStructure)myTreeStructure).isFlattenPackages();\n      }\n\n      protected void childrenChanged(PsiElement parent) {\n        if (findNodeByElement(parent) == null){\n          getUpdater().addSubtreeToUpdate(getRootNode());\n        } else {\n          super.childrenChanged(parent);\n        }\n      }\n    };\n    connection.subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      public void rootsChanged(ModuleRootEvent event) {\n        myUpdater.addSubtreeToUpdate(myRootNode);\n      }\n    });\n    PsiManager.getInstance(myProject).addPsiTreeChangeListener(myPsiTreeChangeListener);\n    myFileStatusListener = new MyFileStatusListener();\n    FileStatusManager.getInstance(myProject).addFileStatusListener(myFileStatusListener);\n    myCopyPasteListener = new CopyPasteUtil.DefaultCopyPasteListener(myUpdater);\n    CopyPasteManager.getInstance().addContentChangedListener(myCopyPasteListener);\n\n    myFavoritesListener = new FavoritesManager.FavoritesListener() {\n      public void rootsChanged(String listName) {\n        if (myListName.equals(listName)) {\n          updateFromRoot();\n        }\n      }\n\n      public void listAdded(String listName) {\n        updateFromRoot();\n      }\n\n      public void listRemoved(String listName) {\n        updateFromRoot();\n      }\n    };\n    FavoritesManager.getInstance(myProject).addFavoritesListener(myFavoritesListener);\n    initRootNode();\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Collection<AbstractTreeNode> getFavoriteNodes(DataContext context, final ViewSettings viewSettings) {\n    Project project = (Project) context.getData(DataConstants.PROJECT);\n    if (project == null) return null;\n    Form[] forms = (Form[]) context.getData(DataConstantsEx.GUI_DESIGNER_FORM_ARRAY);\n    if (forms != null) {\n      Collection<AbstractTreeNode> result = new ArrayList<AbstractTreeNode>();\n      Set<PsiClass> bindClasses = new HashSet<PsiClass>();\n      for (Form form: forms) {\n        final PsiClass classToBind = form.getClassToBind();\n        if (classToBind != null) {\n          if (bindClasses.contains(classToBind)) continue;\n          bindClasses.add(classToBind);\n          result.add(FormNode.constructFormNode(classToBind, (Project) context.getData(DataConstants.PROJECT), viewSettings));\n        }\n      }\n      if (!result.isEmpty()) {\n        return result;\n      }\n    }\n\n    VirtualFile vFile = (VirtualFile) context.getData(DataConstants.VIRTUAL_FILE);\n    if (vFile != null) {\n      final FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(vFile);\n      if (fileType.equals(StdFileTypes.GUI_DESIGNER_FORM)) {\n        final PsiFile formFile = PsiManager.getInstance(project).findFile(vFile);\n        if (formFile == null) return null;\n        String text = formFile.getText();\n        String className;\n        try {\n          className = Utils.getBoundClassName(text);\n        }\n        catch (Exception e) {\n          return null;\n        }\n        if (className == null) return null;\n        final PsiClass classToBind = PsiManager.getInstance(project).findClass(className, GlobalSearchScope.allScope(project));\n        if (classToBind != null) {\n          Form form = new Form(classToBind);\n          final AbstractTreeNode node = new FormNode(project, form, viewSettings);\n          return Collections.singletonList(node);\n        }\n      }\n    }\n\n    return null;\n  }","id":11299,"modified_method":"@Nullable\n  public Collection<AbstractTreeNode> getFavoriteNodes(DataContext context, final ViewSettings viewSettings) {\n    Project project = DataKeys.PROJECT.getData(context);\n    if (project == null) return null;\n    Form[] forms = (Form[]) context.getData(DataConstantsEx.GUI_DESIGNER_FORM_ARRAY);\n    if (forms != null) {\n      Collection<AbstractTreeNode> result = new ArrayList<AbstractTreeNode>();\n      Set<PsiClass> bindClasses = new HashSet<PsiClass>();\n      for (Form form: forms) {\n        final PsiClass classToBind = form.getClassToBind();\n        if (classToBind != null) {\n          if (bindClasses.contains(classToBind)) continue;\n          bindClasses.add(classToBind);\n          result.add(FormNode.constructFormNode(classToBind, project, viewSettings));\n        }\n      }\n      if (!result.isEmpty()) {\n        return result;\n      }\n    }\n\n    VirtualFile vFile = DataKeys.VIRTUAL_FILE.getData(context);\n    if (vFile != null) {\n      final FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(vFile);\n      if (fileType.equals(StdFileTypes.GUI_DESIGNER_FORM)) {\n        final PsiFile formFile = PsiManager.getInstance(project).findFile(vFile);\n        if (formFile == null) return null;\n        String text = formFile.getText();\n        String className;\n        try {\n          className = Utils.getBoundClassName(text);\n        }\n        catch (Exception e) {\n          return null;\n        }\n        if (className == null) return null;\n        final PsiClass classToBind = PsiManager.getInstance(project).findClass(className, GlobalSearchScope.allScope(project));\n        if (classToBind != null) {\n          Form form = new Form(classToBind);\n          final AbstractTreeNode node = new FormNode(project, form, viewSettings);\n          return Collections.singletonList(node);\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"6c122759d381d7005fcf55226c02e4f37158f720","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiMethod searchActionMethod() {\n    final GenericAttributeValue<PsiMethod> methodValue = getMethod();\n    if (methodValue.getXmlElement() != null) {\n      return methodValue.getValue();\n    }\n\n    final List<PsiMethod> methods = getActionMethods();\n    for (final PsiMethod method : methods) {\n      if (method.getName().equals(\"execute\")) {\n        return method;\n      }\n    }\n\n    return null;\n  }","id":11300,"modified_method":"@Nullable\n  public PsiMethod searchActionMethod() {\n    final GenericAttributeValue<PsiMethod> methodValue = getMethod();\n    if (methodValue.getXmlElement() != null) {\n      return methodValue.getValue();\n    }\n\n    return ContainerUtil.find(getActionMethods(), DEFAULT_ACTION_METHOD_CONDITION);\n  }","commit_id":"ed371dc145385d6b0c448d433a89da7ca3d57f47","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static Set<InterceptorStack> getAllInterceptorStacks(@NotNull final StrutsModel strutsModel) {\n    final Set<InterceptorStack> variants = new HashSet<InterceptorStack>();\n    for (final StrutsPackage strutsPackage : strutsModel.getStrutsPackages()) {\n      final List<InterceptorStack> interceptorStackList = strutsPackage.getInterceptorStacks();\n      variants.addAll(interceptorStackList);\n    }\n\n    return variants;\n  }","id":11301,"modified_method":"private static List<InterceptorStack> getAllInterceptorStacks(@NotNull final StrutsModel strutsModel) {\n    return ContainerUtil.concat(strutsModel.getStrutsPackages(), INTERCEPTOR_STACK_COLLECTOR);\n  }","commit_id":"ed371dc145385d6b0c448d433a89da7ca3d57f47","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public InterceptorStack fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n    if (strutsModel == null) {\n      return null;\n    }\n\n    final Set<InterceptorStack> interceptorStacks = getAllInterceptorStacks(strutsModel);\n    for (final InterceptorStack interceptorStack : interceptorStacks) {\n      if (name.equals(interceptorStack.getName().getStringValue())) {\n        return interceptorStack;\n      }\n    }\n\n    return null;\n  }","id":11302,"modified_method":"public InterceptorStack fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n    if (strutsModel == null) {\n      return null;\n    }\n\n    return ContainerUtil.find(getAllInterceptorStacks(strutsModel), new Condition<InterceptorStack>() {\n      public boolean value(final InterceptorStack interceptorStack) {\n        return Comparing.equal(name, interceptorStack.getName().getStringValue());\n      }\n    });\n  }","commit_id":"ed371dc145385d6b0c448d433a89da7ca3d57f47","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public InterceptorOrStackBase fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n\n    if (strutsModel == null) {\n      return null;\n    }\n\n    final Set<InterceptorOrStackBase> interceptorOrStackBases = getAllInterceptorsAndStacks(strutsModel);\n    for (final InterceptorOrStackBase interceptorOrStackBase : interceptorOrStackBases) {\n      if (name.equals(interceptorOrStackBase.getName().getStringValue())) {\n        return interceptorOrStackBase;\n      }\n    }\n\n    return null;\n  }","id":11303,"modified_method":"public InterceptorOrStackBase fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n\n    if (strutsModel == null) {\n      return null;\n    }\n\n    return ContainerUtil.find(getAllInterceptorsAndStacks(strutsModel), new Condition<InterceptorOrStackBase>() {\n      public boolean value(final InterceptorOrStackBase interceptorOrStackBase) {\n        return Comparing.equal(interceptorOrStackBase.getName().getStringValue(), name);\n      }\n    });\n  }","commit_id":"ed371dc145385d6b0c448d433a89da7ca3d57f47","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static List<ResultType> getMergedResultTypes(@NotNull final StrutsModel strutsModel) {\n    final List<ResultType> allTypes = new ArrayList<ResultType>();\n    for (final StrutsPackage strutsPackage : strutsModel.getStrutsPackages()) {\n      allTypes.addAll(strutsPackage.getResultTypes());\n    }\n\n    return allTypes;\n  }","id":11304,"modified_method":"private static List<ResultType> getMergedResultTypes(@NotNull final StrutsModel strutsModel) {\n    return ContainerUtil.concat(strutsModel.getStrutsPackages(), RESULT_TYPE_COLLECTOR);\n\n  }","commit_id":"ed371dc145385d6b0c448d433a89da7ca3d57f47","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public ResultType fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (StringUtil.isEmpty(name)) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n    if (strutsModel == null) {\n      return null;\n    }\n\n    final List<ResultType> allTypes = getMergedResultTypes(strutsModel);\n\n    for (final ResultType allType : allTypes) {\n      final String resultTypeName = allType.getName().getStringValue();\n      if (resultTypeName != null && resultTypeName.equals(name)) {\n        return allType;\n      }\n    }\n\n    return null;\n  }","id":11305,"modified_method":"public ResultType fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (StringUtil.isEmpty(name)) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n    if (strutsModel == null) {\n      return null;\n    }\n\n    return ContainerUtil.find(getMergedResultTypes(strutsModel), new Condition<ResultType>() {\n      public boolean value(final ResultType resultType) {\n        return Comparing.equal(resultType.getName().getStringValue(), name);\n      }\n    });\n  }","commit_id":"ed371dc145385d6b0c448d433a89da7ca3d57f47","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public StrutsPackage fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n    if (strutsModel == null) {\n      return null;\n    }\n\n    final Collection<? extends StrutsPackage> packages = getVariants(context);\n    for (final StrutsPackage strutsPackage : packages) {\n      if (name.equals(strutsPackage.getName().getStringValue())) {\n        return strutsPackage;\n      }\n    }\n\n    return null;\n  }","id":11306,"modified_method":"@Nullable\n  public StrutsPackage fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    final StrutsModel strutsModel = ConverterUtil.getStrutsModel(context);\n    if (strutsModel == null) {\n      return null;\n    }\n\n    return ContainerUtil.find(getVariants(context), new Condition<StrutsPackage>() {\n      public boolean value(final StrutsPackage strutsPackage) {\n        return Comparing.equal(name, strutsPackage.getName().getStringValue());\n      }\n    });\n  }","commit_id":"ed371dc145385d6b0c448d433a89da7ca3d57f47","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public PsiElement resolve() {\n      final SpringModel model = getSpringModel();\n      if (model == null) {\n        return null;\n      }\n\n      final String beanName = myElement.getValue();\n      final SpringBeanPointer springBean = model.findBean(beanName);\n\n      return springBean == null ? null : springBean.getBeanClass();\n    }","id":11307,"modified_method":"public PsiElement resolve() {\n      final SpringModel model = getSpringModel();\n      if (model == null) {\n        return null;\n      }\n\n      final String beanName = myElement.getValue();\n      final SpringBeanPointer springBean = model.findBean(beanName);\n      if (springBean == null) {\n        return null;\n      }\n\n      return springBean.getBeanClass();\n    }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Object[] getVariants() {\n      final Set<Object> variants = new HashSet<Object>(allStrutsPackages.size());\n\n      for (final StrutsPackage allPackage : allStrutsPackages) {\n        final String packageNamespace = allPackage.searchNamespace();\n        variants.add(LookupValueFactory.createLookupValueWithHint(\n                packageNamespace.length() != 1 ? packageNamespace + \"/\" : packageNamespace,\n                StrutsIcons.PACKAGE, allPackage.getName().getStringValue()));\n      }\n\n      return variants.toArray(new Object[variants.size()]);\n    }","id":11308,"modified_method":"public Object[] getVariants() {\n      return ContainerUtil.map2Array(allStrutsPackages, Object.class, new Function<StrutsPackage, Object>() {\n        public Object fun(final StrutsPackage strutsPackage) {\n          final String packageNamespace = strutsPackage.searchNamespace();\n          return LookupValueFactory.createLookupValueWithHint(\n                  packageNamespace.length() != 1 ? packageNamespace + \"/\" : packageNamespace,\n                  StrutsIcons.PACKAGE, strutsPackage.getName().getStringValue());\n        }\n      });\n    }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public PsiMethod fromString(@Nullable @NonNls final String s, final ConvertContext context) {\n    if (s == null) {\n      return null;\n    }\n\n    final Action action = getActionElement(context);\n    for (final PsiMethod method : action.getActionMethods()) {\n      if (method.getName().equals(s)) {\n        return method;\n      }\n    }\n\n    return null;\n  }","id":11309,"modified_method":"public PsiMethod fromString(@Nullable @NonNls final String value, final ConvertContext context) {\n    if (value == null) {\n      return null;\n    }\n\n    final Action action = getActionElement(context);\n    return ContainerUtil.find(action.getActionMethods(), new Condition<PsiMethod>() {\n      public boolean value(final PsiMethod psiMethod) {\n        return psiMethod.getName().equals(value);\n      }\n    });\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Result fromString(@Nullable @NonNls final String value, final ConvertContext context) {\n    if (value == null) {\n      return null;\n    }\n\n    for (final Result result : getVariants(context)) {\n      if (value.equals(result.getName().getStringValue())) {\n        return result;\n      }\n    }\n\n    return null;\n  }","id":11310,"modified_method":"public Result fromString(@Nullable @NonNls final String value, final ConvertContext context) {\n    if (value == null) {\n      return null;\n    }\n\n    return ContainerUtil.find(getVariants(context), new Condition<Result>() {\n      public boolean value(final Result result) {\n        return Comparing.equal(result.getName().getStringValue(), value);\n      }\n    });\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public GlobalResult fromString(@Nullable @NonNls final String value, final ConvertContext context) {\n    if (value == null) {\n      return null;\n    }\n\n    for (final GlobalResult result : getVariants(context)) {\n      if (value.equals(result.getName().getStringValue())) {\n        return result;\n      }\n    }\n\n    return null;\n  }","id":11311,"modified_method":"public GlobalResult fromString(@Nullable @NonNls final String value, final ConvertContext context) {\n    if (value == null) {\n      return null;\n    }\n\n    return ContainerUtil.find(getVariants(context), new Condition<GlobalResult>() {\n      public boolean value(final GlobalResult globalResult) {\n        return Comparing.equal(value, globalResult.getName().getStringValue());\n      }\n    });\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void addNames(@NotNull final Module module, final Set<String> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel != null) {\n      final List<StrutsPackage> strutsPackageList = strutsModel.getStrutsPackages();\n      for (final StrutsPackage strutsPackage : strutsPackageList) {\n        addNewNames(strutsPackage.getActions(), result);\n      }\n    }\n  }","id":11312,"modified_method":"protected void addNames(@NotNull final Module module, final Set<String> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel == null) {\n      return;\n    }\n\n    final List<StrutsPackage> strutsPackageList = strutsModel.getStrutsPackages();\n    for (final StrutsPackage strutsPackage : strutsPackageList) {\n      addNewNames(strutsPackage.getActions(), result);\n    }\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void addItems(@NotNull final Module module, final String name, final List<NavigationItem> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel != null) {\n      final List<Action> actions = strutsModel.findActionsByName(name, null);\n      for (final Action action : actions) {\n        final NavigationItem item = createNavigationItem(action.getXmlTag(),\n                                                         action.getName().getStringValue() + \" [\" + action.getNamespace() + \"]\",\n                                                         ElementPresentationManager.getIcon(action));\n        result.add(item);\n      }\n    }\n  }","id":11313,"modified_method":"protected void addItems(@NotNull final Module module, final String name, final List<NavigationItem> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel == null) {\n      return;\n    }\n\n    final List<Action> actions = strutsModel.findActionsByName(name, null);\n    for (final Action action : actions) {\n      final NavigationItem item = createNavigationItem(action.getXmlTag(),\n                                                       action.getName().getStringValue() + \" [\" + action.getNamespace() + \"]\",\n                                                       ElementPresentationManager.getIcon(action));\n      result.add(item);\n    }\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void addNames(@NotNull final Module module, final Set<String> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel != null) {\n      final List<StrutsPackage> strutsPackageList = strutsModel.getStrutsPackages();\n      addNewNames(strutsPackageList, result);\n    }\n  }","id":11314,"modified_method":"protected void addNames(@NotNull final Module module, final Set<String> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel == null) {\n      return;\n    }\n\n    final List<StrutsPackage> strutsPackageList = strutsModel.getStrutsPackages();\n    addNewNames(strutsPackageList, result);\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void addItems(@NotNull final Module module, final String name, final List<NavigationItem> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel != null) {\n      final List<StrutsPackage> strutsPackageList = strutsModel.getStrutsPackages();\n      for (final StrutsPackage strutsPackage : strutsPackageList) {\n        if (name.equals(strutsPackage.getName().getStringValue())) {\n          final NavigationItem item = createNavigationItem(strutsPackage);\n          ContainerUtil.addIfNotNull(item, result);\n        }\n      }\n    }\n  }","id":11315,"modified_method":"protected void addItems(@NotNull final Module module, final String name, final List<NavigationItem> result) {\n    final StrutsModel strutsModel = StrutsManager.getInstance(module.getProject()).getCombinedModel(module);\n    if (strutsModel == null) {\n      return;\n    }\n\n    final List<StrutsPackage> strutsPackageList = strutsModel.getStrutsPackages();\n\n    for (final StrutsPackage strutsPackage : strutsPackageList) {\n      if (name.equals(strutsPackage.getName().getStringValue())) {\n        final NavigationItem item = createNavigationItem(strutsPackage);\n        ContainerUtil.addIfNotNull(item, result);\n      }\n    }\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public String toString(@Nullable PsiFile psiFile, final ConvertContext context) {\n    if (psiFile == null) {\n      return null;\n    }\n    final VirtualFile file = psiFile.getVirtualFile();\n    if (file == null) {\n      return null;\n    }\n    VirtualFile root = getRootForFile(file, context);\n    if (root == null) {\n      return null;\n    }\n    return VfsUtil.getRelativePath(file, root, '/');\n  }","id":11316,"modified_method":"public String toString(@Nullable PsiFile psiFile, final ConvertContext context) {\n    if (psiFile == null) {\n      return null;\n    }\n\n    final VirtualFile file = psiFile.getVirtualFile();\n    if (file == null) {\n      return null;\n    }\n\n    final VirtualFile root = getRootForFile(file, context);\n    if (root == null) {\n      return null;\n    }\n\n    return VfsUtil.getRelativePath(file, root, '/');\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Object[] getVariants() {\n      final List<String> variants = new ArrayList<String>();\n      for (final StrutsPackage strutsPackage : strutsModel.getStrutsPackages()) {\n        final String namespace = strutsPackage.searchNamespace();\n        variants.add(namespace);\n      }\n      return variants.toArray(new Object[variants.size()]);\n    }","id":11317,"modified_method":"public Object[] getVariants() {\n      return ContainerUtil.map2Array(strutsModel.getStrutsPackages(), new Function<StrutsPackage, Object>() {\n        public Object fun(final StrutsPackage strutsPackage) {\n          return strutsPackage.searchNamespace();\n        }\n      });\n    }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public StructureViewComponent(final FileEditor fileEditor,\n                                final StructureViewModel structureViewModel,\n                                final Project project) {\n    super(fileEditor, structureViewModel, project);\n    PeerFactory.getInstance().getUIHelper().installTreeSpeedSearch(getTree());\n  }","id":11318,"modified_method":"StructureViewComponent(final FileEditor fileEditor,\n                         final StructureViewModel structureViewModel,\n                         final Project project) {\n    super(fileEditor, structureViewModel, project);\n    PeerFactory.getInstance().getUIHelper().installTreeSpeedSearch(getTree());\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public TreeElement[] getChildren() {\n    final TreeElement[] elements = super.getChildren();\n    final List<StructureViewTreeElement> myList = new ArrayList<StructureViewTreeElement>(elements.length);\n    for (final TreeElement treeElement : elements) {\n      myList.add(new StructureViewTreeElement(((DomStructureTreeElement) treeElement).getElement()));\n    }\n    return myList.toArray(new StructureViewTreeElement[myList.size()]);\n  }","id":11319,"modified_method":"public TreeElement[] getChildren() {\n    return ContainerUtil.map2Array(super.getChildren(), TreeElement.class, new Function<TreeElement, TreeElement>() {\n      public TreeElement fun(final TreeElement treeElement) {\n        return new StructureViewTreeElement(((DomStructureTreeElement) treeElement).getElement());\n      }\n    });\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public StructureViewTreeElement(@NotNull final DomElement domElement) {\n    super(domElement,\n        MY_STRUCTURE_VIEW_MODE_FUNCTION,\n        DomElementsNavigationManager.getManager(domElement.getRoot().getFile().getProject()).\n            getDomElementsNavigateProvider(DomElementsNavigationManager.DEFAULT_PROVIDER_NAME));\n  }","id":11320,"modified_method":"StructureViewTreeElement(@NotNull final DomElement domElement) {\n    super(domElement,\n          MY_STRUCTURE_VIEW_MODE_FUNCTION,\n          DomElementsNavigationManager.getManager(domElement.getRoot().getFile().getProject()).\n                  getDomElementsNavigateProvider(DomElementsNavigationManager.DEFAULT_PROVIDER_NAME));\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public StructureViewTreeModel(@NotNull final XmlFile xmlFile,\n                                @NotNull final DomElement rootElement) {\n    super(xmlFile);\n    this.rootElement = rootElement;\n  }","id":11321,"modified_method":"StructureViewTreeModel(@NotNull final XmlFile xmlFile,\n                         @NotNull final DomElement rootElement) {\n    super(xmlFile);\n    this.rootElement = rootElement;\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public String[] getVersions() {\n    final List<String> versions = new ArrayList<String>();\n    for (final StrutsVersion version : StrutsVersion.values()) {\n      versions.add(version.toString());\n    }\n    return versions.toArray(new String[versions.size()]);\n  }","id":11322,"modified_method":"@NotNull\n  public String[] getVersions() {\n    return ContainerUtil.map2Array(StrutsVersion.values(), String.class,\n                                   new Function<StrutsVersion, String>() {\n                                     public String fun(final StrutsVersion strutsVersion) {\n                                       return strutsVersion.toString();\n                                     }\n                                   });\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private static StrutsVersion getVersion(final String versionName) {\n    for (final StrutsVersion version : StrutsVersion.values()) {\n      if (versionName.equals(version.toString())) {\n        return version;\n      }\n    }\n\n    throw new IllegalArgumentException(\"Invalid S2 version '\" + versionName + \"'\");\n  }","id":11323,"modified_method":"@NotNull\n  private static StrutsVersion getVersion(final String versionName) {\n    final StrutsVersion strutsVersion = ContainerUtil.find(StrutsVersion.values(), new Condition<StrutsVersion>() {\n      public boolean value(final StrutsVersion strutsVersion) {\n        return versionName.equals(strutsVersion.toString());\n      }\n    });\n\n    LOG.assertTrue(strutsVersion != null, \"Invalid S2 version '\" + versionName + \"'\");\n    return strutsVersion;\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public List<StrutsRoot> getMergedStrutsRoots() {\n    final List<DomFileElement<StrutsRoot>> elementList = getRoots();\n\n    final List<StrutsRoot> allRoots = new ArrayList<StrutsRoot>(elementList.size());\n    for (final DomFileElement<StrutsRoot> strutsRootDomFileElement : elementList) {\n      allRoots.add(strutsRootDomFileElement.getRootElement());\n    }\n\n    return allRoots;\n  }","id":11324,"modified_method":"@NotNull\n  public List<StrutsRoot> getMergedStrutsRoots() {\n    return ContainerUtil.map(getRoots(), ROOT_ELEMENT_MAPPER);\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public List<StrutsPackage> getStrutsPackages() {\n    final List<StrutsPackage> strutsPackageList = new ArrayList<StrutsPackage>();\n\n    for (final StrutsRoot strutsRoot : getMergedStrutsRoots()) {\n      strutsPackageList.addAll(strutsRoot.getPackages());\n    }\n\n    return strutsPackageList;\n  }","id":11325,"modified_method":"@NotNull\n  public List<StrutsPackage> getStrutsPackages() {\n    return ContainerUtil.concat(getMergedStrutsRoots(), STRUTS_PACKAGE_COLLECTOR);\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public ValidatorConfig fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    final Collection<? extends ValidatorConfig> validatorConfigs = getVariants(context);\n    for (final ValidatorConfig validatorConfig : validatorConfigs) {\n      if (name.equals(validatorConfig.getName().getStringValue())) {\n        return validatorConfig;\n      }\n    }\n\n    return null;\n  }","id":11326,"modified_method":"public ValidatorConfig fromString(@Nullable @NonNls final String name, final ConvertContext context) {\n    if (name == null) {\n      return null;\n    }\n\n    return ContainerUtil.find(getVariants(context), new Condition<ValidatorConfig>() {\n      public boolean value(final ValidatorConfig validatorConfig) {\n        return Comparing.equal(name, validatorConfig.getName().getStringValue());\n      }\n    });\n  }","commit_id":"1f8ba381bac6463364f3d832bed10fc67d602ec3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void run() {\n            JChannel ch=null;\n            View view;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                view=ch.getView();\n                my_addr=ch.getLocalAddress();\n                log(my_addr + \" connected in \" + total_connect_time + \" msecs (\" +\n                    view.getMembers().size() + \" members). VID=\" + view.getVid());\n\n                connected.barrier();\n\n                int num_members=0;\n                while((num_members=ch.getView().getMembers().size()) < NUM+1) {\n                    log(\"num_members=\" + num_members);\n                    Util.sleep(2000);\n                }\n                log(\"reached \" + num_members + \" members\");\n                received_all_views.barrier();\n\n                start_disconnecting.barrier();\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(my_addr + \" disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","id":11327,"modified_method":"public void run() {\n            JChannel ch=null;\n            View view;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                view=ch.getView();\n                my_addr=ch.getLocalAddress();\n                log(my_addr + \" connected in \" + total_connect_time + \" msecs (\" +\n                    view.getMembers().size() + \" members). VID=\" + view.getVid());\n\n                connected.barrier();\n\n                int num_members=0;\n                while(true) {\n                    View v=ch.getView();\n                    Vector mbrs=v != null? v.getMembers() : null;\n                    if(mbrs == null) {\n                        System.err.println(\"mbrs is null, v=\" + v);\n                    }\n                    else {\n                        num_members=mbrs.size();\n                        log(\"num_members=\" + num_members);\n                        // if(num_members >= NUM+1)\n                        // System.out.println(\"** mbrs: \" + mbrs);\n                        if(num_members == NUM+1) // all threads (NUM) plus the first channel (1)\n                            break;\n                    }\n                    Util.sleep(2000);\n                }\n                log(\"reached \" + num_members + \" members\");\n                received_all_views.barrier();\n\n                start_disconnecting.barrier();\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(my_addr + \" disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","commit_id":"22bd092de2cf05a55a91f174013cdd644b783a29","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            num_members=channel.getView().getMembers().size();\n            System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n            if(num_members == 1)\n                break;\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n    }","id":11328,"modified_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            View v=channel.getView();\n            Vector mbrs=v != null? v.getMembers() : null;\n            if(mbrs != null) {\n                num_members=mbrs.size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n                if(num_members == 1)\n                    break;\n            }\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n    }","commit_id":"e7df25f6ef1f391aae38f43658983ee10a165a33","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            JChannel ch=null;\n            View view;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                view=ch.getView();\n                my_addr=ch.getLocalAddress();\n                log(my_addr + \" connected in \" + total_connect_time + \" msecs (\" +\n                    view.getMembers().size() + \" members). VID=\" + view.getVid());\n\n                connected.barrier();\n\n                int num_members=0;\n                while((num_members=ch.getView().getMembers().size()) < NUM+1) {\n                    log(\"num_members=\" + num_members);\n                    Util.sleep(2000);\n                }\n                log(\"reached \" + num_members + \" members\");\n                received_all_views.barrier();\n\n                start_disconnecting.barrier();\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(my_addr + \" disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","id":11329,"modified_method":"public void run() {\n            JChannel ch=null;\n            View view;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                view=ch.getView();\n                my_addr=ch.getLocalAddress();\n                log(my_addr + \" connected in \" + total_connect_time + \" msecs (\" +\n                    view.getMembers().size() + \" members). VID=\" + view.getVid());\n\n                connected.barrier();\n\n                int num_members=0;\n                while(true) {\n                    View v=ch.getView();\n                    Vector mbrs=v != null? v.getMembers() : null;\n                    if(mbrs == null) {\n                        System.err.println(\"mbrs is null, v=\" + v);\n                    }\n                    else {\n                        num_members=mbrs.size();\n                        log(\"num_members=\" + num_members);\n                        // if(num_members >= NUM+1)\n                        // System.out.println(\"** mbrs: \" + mbrs);\n                        if(num_members == NUM+1) // all threads (NUM) plus the first channel (1)\n                            break;\n                    }\n                    Util.sleep(2000);\n                }\n                log(\"reached \" + num_members + \" members\");\n                received_all_views.barrier();\n\n                start_disconnecting.barrier();\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(my_addr + \" disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","commit_id":"cde6342805cff6af6162aafc5cfd37ec86ca5970","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            num_members=channel.getView().getMembers().size();\n            System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n            if(num_members == 1)\n                break;\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n    }","id":11330,"modified_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            View v=channel.getView();\n            Vector mbrs=v != null? v.getMembers() : null;\n            if(mbrs != null) {\n                num_members=mbrs.size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n                if(num_members == 1)\n                    break;\n            }\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n    }","commit_id":"c96cb91aed03063e53d078e2d4481b506a27e834","url":"https://github.com/belaban/JGroups"},{"original_method":"private void parseTransport(XMLExtendedStreamReader reader, ModelNode containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the transport add operation\n        ModelNode transport = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case STACK: {\n                    TransportResource.STACK.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                case CLUSTER: {\n                    TransportResource.CLUSTER.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                case EXECUTOR: {\n                    TransportResource.EXECUTOR.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                case LOCK_TIMEOUT: {\n                    TransportResource.LOCK_TIMEOUT.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n\n        // setup the transport address\n        ModelNode transportAddress = containerAddress.clone() ;\n        transportAddress.add(ModelKeys.TRANSPORT, ModelKeys.TRANSPORT_NAME);\n        transportAddress.protect() ;\n        transport.get(ModelDescriptionConstants.OP_ADDR).set(transportAddress);\n\n        operations.add(transport);\n    }","id":11331,"modified_method":"private void parseTransport(XMLExtendedStreamReader reader, PathAddress containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress transportAddress = containerAddress.append(ModelKeys.TRANSPORT, ModelKeys.TRANSPORT_NAME);\n        ModelNode transport = Util.createAddOperation(transportAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case STACK: {\n                    TransportResource.STACK.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                case CLUSTER: {\n                    TransportResource.CLUSTER.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                case EXECUTOR: {\n                    TransportResource.EXECUTOR.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                case LOCK_TIMEOUT: {\n                    TransportResource.LOCK_TIMEOUT.parseAndSetParameter(value, transport, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n\n        operations.add(transport);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseDistributedCache(XMLExtendedStreamReader reader, ModelNode containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case OWNERS: {\n                    DistributedCacheResource.OWNERS.parseAndSetParameter(value, cache, reader);\n                    break;\n                }\n                case VIRTUAL_NODES: {\n                    DistributedCacheResource.VIRTUAL_NODES.parseAndSetParameter(value, cache, reader);\n                    break;\n                }\n                case L1_LIFESPAN: {\n                    DistributedCacheResource.L1_LIFESPAN.parseAndSetParameter(value, cache, reader);\n                    break;\n                }\n                default: {\n                    this.parseClusteredCacheAttribute(reader, i, attribute, value, cache);\n                }\n            }\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n        if (!cache.hasDefined(ModelKeys.MODE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.MODE));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.DISTRIBUTED_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STATE_TRANSFER: {\n                    this.parseStateTransfer(reader, cache, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n                }\n            }\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n    }","id":11332,"modified_method":"private void parseDistributedCache(XMLExtendedStreamReader reader, PathAddress containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case OWNERS: {\n                    DistributedCacheResource.OWNERS.parseAndSetParameter(value, cache, reader);\n                    break;\n                }\n                case VIRTUAL_NODES: {\n                    DistributedCacheResource.VIRTUAL_NODES.parseAndSetParameter(value, cache, reader);\n                    break;\n                }\n                case L1_LIFESPAN: {\n                    DistributedCacheResource.L1_LIFESPAN.parseAndSetParameter(value, cache, reader);\n                    break;\n                }\n                default: {\n                    this.parseClusteredCacheAttribute(reader, i, attribute, value, cache);\n                }\n            }\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n        if (!cache.hasDefined(ModelKeys.MODE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.MODE));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.DISTRIBUTED_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STATE_TRANSFER: {\n                    this.parseStateTransfer(reader, cache, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n                }\n            }\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseExpiration(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the expiration add operation\n        ModelNode expirationAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone();\n        expirationAddress.add(ModelKeys.EXPIRATION, ModelKeys.EXPIRATION_NAME);\n        expirationAddress.protect();\n        ModelNode expiration = Util.getEmptyOperation(ModelDescriptionConstants.ADD, expirationAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case MAX_IDLE: {\n                    ExpirationResource.MAX_IDLE.parseAndSetParameter(value, expiration, reader);\n                    break;\n                }\n                case LIFESPAN: {\n                    ExpirationResource.LIFESPAN.parseAndSetParameter(value, expiration, reader);\n                    break;\n                }\n                case INTERVAL: {\n                    ExpirationResource.INTERVAL.parseAndSetParameter(value, expiration, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(expiration);\n    }","id":11333,"modified_method":"protected void parseExpiration(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress expirationAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.EXPIRATION, ModelKeys.EXPIRATION_NAME);\n        ModelNode expiration = Util.createAddOperation(expirationAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case MAX_IDLE: {\n                    ExpirationResource.MAX_IDLE.parseAndSetParameter(value, expiration, reader);\n                    break;\n                }\n                case LIFESPAN: {\n                    ExpirationResource.LIFESPAN.parseAndSetParameter(value, expiration, reader);\n                    break;\n                }\n                case INTERVAL: {\n                    ExpirationResource.INTERVAL.parseAndSetParameter(value, expiration, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(expiration);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addCacheNameToAddress(ModelNode cache, ModelNode containerAddress, String cacheType) {\n\n        String name = cache.get(ModelKeys.NAME).asString();\n        // setup the cache address\n        ModelNode cacheAddress = containerAddress.clone() ;\n        cacheAddress.add(cacheType, name);\n        cacheAddress.protect() ;\n        cache.get(ModelDescriptionConstants.OP_ADDR).set(cacheAddress);\n\n        // get rid of NAME now that we are finished with it\n        cache.remove(ModelKeys.NAME);\n    }","id":11334,"modified_method":"private void addCacheNameToAddress(ModelNode cache, PathAddress containerAddress, String cacheType) {\n\n        String name = cache.get(ModelKeys.NAME).asString();\n        // setup the cache address\n        PathAddress cacheAddress = containerAddress.append(cacheType, name) ;\n        cache.get(ModelDescriptionConstants.OP_ADDR).set(cacheAddress.toModelNode());\n\n        // get rid of NAME now that we are finished with it\n        cache.remove(ModelKeys.NAME);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.staxmapper.XMLElementReader#readElement(org.jboss.staxmapper.XMLExtendedStreamReader, Object)\n     */\n    @Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n\n        ModelNode subsystemAddress = new ModelNode();\n        subsystemAddress.add(ModelDescriptionConstants.SUBSYSTEM, InfinispanExtension.SUBSYSTEM_NAME);\n        subsystemAddress.protect();\n\n        ModelNode subsystem = Util.getEmptyOperation(ModelDescriptionConstants.ADD, subsystemAddress);\n\n        // command to add the subsystem\n        operations.add(subsystem);\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case CACHE_CONTAINER: {\n                    parseContainer(reader, subsystemAddress, operations);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n    }","id":11335,"modified_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.staxmapper.XMLElementReader#readElement(org.jboss.staxmapper.XMLExtendedStreamReader, Object)\n     */\n    @Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress subsystemAddress = PathAddress.pathAddress(InfinispanExtension.SUBSYSTEM_PATH);\n        ModelNode subsystem = Util.createAddOperation(subsystemAddress);\n\n        // command to add the subsystem\n        operations.add(subsystem);\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case CACHE_CONTAINER: {\n                    parseContainer(reader, subsystemAddress, operations);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseBinaryKeyedJDBCStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the binary-keyed jdbc store add operation\n        ModelNode storeAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone() ;\n        storeAddress.add(ModelKeys.BINARY_KEYED_JDBC_STORE,ModelKeys.BINARY_KEYED_JDBC_STORE_NAME) ;\n        storeAddress.protect();\n        ModelNode store = Util.getEmptyOperation(ModelDescriptionConstants.ADD, storeAddress);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case DATASOURCE: {\n                    BaseJDBCStoreResource.DATA_SOURCE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.DATASOURCE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.DATASOURCE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case BINARY_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.BINARY_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseStoreProperty(reader, store);\n                }\n            }\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","id":11336,"modified_method":"protected void parseBinaryKeyedJDBCStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress storeAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.BINARY_KEYED_JDBC_STORE, ModelKeys.BINARY_KEYED_JDBC_STORE_NAME);\n        ModelNode store = Util.createAddOperation(storeAddress);\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case DATASOURCE: {\n                    BaseJDBCStoreResource.DATA_SOURCE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.DATASOURCE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.DATASOURCE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case BINARY_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.BINARY_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseStoreProperty(reader, store);\n                }\n            }\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseRemoteStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the remote store add operation\n        ModelNode storeAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone() ;\n        storeAddress.add(ModelKeys.REMOTE_STORE,ModelKeys.REMOTE_STORE_NAME) ;\n        storeAddress.protect();\n        ModelNode store = Util.getEmptyOperation(ModelDescriptionConstants.ADD, storeAddress);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case CACHE: {\n                    RemoteStoreResource.CACHE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                case SOCKET_TIMEOUT: {\n                    RemoteStoreResource.SOCKET_TIMEOUT.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                case TCP_NO_DELAY: {\n                    RemoteStoreResource.TCP_NO_DELAY.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case REMOTE_SERVER: {\n                    this.parseRemoteServer(reader, store.get(ModelKeys.REMOTE_SERVERS).add());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseStoreProperty(reader, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.REMOTE_SERVERS)) {\n            throw ParseUtils.missingRequired(reader, Collections.singleton(Element.REMOTE_SERVER));\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","id":11337,"modified_method":"protected void parseRemoteStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress storeAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.REMOTE_STORE, ModelKeys.REMOTE_STORE_NAME);\n        ModelNode store = Util.createAddOperation(storeAddress);\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case CACHE: {\n                    RemoteStoreResource.CACHE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                case SOCKET_TIMEOUT: {\n                    RemoteStoreResource.SOCKET_TIMEOUT.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                case TCP_NO_DELAY: {\n                    RemoteStoreResource.TCP_NO_DELAY.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case REMOTE_SERVER: {\n                    this.parseRemoteServer(reader, store.get(ModelKeys.REMOTE_SERVERS).add());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseStoreProperty(reader, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.REMOTE_SERVERS)) {\n            throw ParseUtils.missingRequired(reader, Collections.singleton(Element.REMOTE_SERVER));\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseReplicatedCache(XMLExtendedStreamReader reader, ModelNode containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            this.parseClusteredCacheAttribute(reader, i, attribute, value, cache);\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n        if (!cache.hasDefined(ModelKeys.MODE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.MODE));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.REPLICATED_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STATE_TRANSFER: {\n                    this.parseStateTransfer(reader, cache, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n                }\n            }\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n    }","id":11338,"modified_method":"private void parseReplicatedCache(XMLExtendedStreamReader reader, PathAddress containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            this.parseClusteredCacheAttribute(reader, i, attribute, value, cache);\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n        if (!cache.hasDefined(ModelKeys.MODE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.MODE));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.REPLICATED_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STATE_TRANSFER: {\n                    this.parseStateTransfer(reader, cache, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n                }\n            }\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseLocking(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode lockingAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone();\n        lockingAddress.add(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME);\n        lockingAddress.protect();\n        ModelNode locking = Util.getEmptyOperation(ModelDescriptionConstants.ADD, lockingAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case ISOLATION: {\n                    LockingResource.ISOLATION.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                case STRIPING: {\n                    LockingResource.STRIPING.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                case ACQUIRE_TIMEOUT: {\n                    LockingResource.ACQUIRE_TIMEOUT.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                case CONCURRENCY_LEVEL: {\n                    LockingResource.CONCURRENCY_LEVEL.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(locking);\n    }","id":11339,"modified_method":"protected void parseLocking(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress lockingAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.LOCKING, ModelKeys.LOCKING_NAME);\n        ModelNode locking = Util.createAddOperation(lockingAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case ISOLATION: {\n                    LockingResource.ISOLATION.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                case STRIPING: {\n                    LockingResource.STRIPING.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                case ACQUIRE_TIMEOUT: {\n                    LockingResource.ACQUIRE_TIMEOUT.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                case CONCURRENCY_LEVEL: {\n                    LockingResource.CONCURRENCY_LEVEL.parseAndSetParameter(value, locking, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(locking);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseEviction(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the eviction add operation\n        ModelNode evictionAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone();\n        evictionAddress.add(ModelKeys.EVICTION, ModelKeys.EVICTION_NAME);\n        evictionAddress.protect();\n        ModelNode eviction = Util.getEmptyOperation(ModelDescriptionConstants.ADD, evictionAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case STRATEGY: {\n                    EvictionResource.EVICTION_STRATEGY.parseAndSetParameter(value, eviction, reader);\n                    break;\n                }\n                case MAX_ENTRIES: {\n                    EvictionResource.MAX_ENTRIES.parseAndSetParameter(value, eviction, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(eviction);\n    }","id":11340,"modified_method":"protected void parseEviction(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress evictionAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.EVICTION, ModelKeys.EVICTION_NAME);\n        ModelNode eviction = Util.createAddOperation(evictionAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case STRATEGY: {\n                    EvictionResource.EVICTION_STRATEGY.parseAndSetParameter(value, eviction, reader);\n                    break;\n                }\n                case MAX_ENTRIES: {\n                    EvictionResource.MAX_ENTRIES.parseAndSetParameter(value, eviction, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(eviction);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseStringKeyedJDBCStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the string-keyed jdbc store add operation\n        ModelNode storeAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone() ;\n        storeAddress.add(ModelKeys.STRING_KEYED_JDBC_STORE,ModelKeys.STRING_KEYED_JDBC_STORE_NAME) ;\n        storeAddress.protect();\n        ModelNode store = Util.getEmptyOperation(ModelDescriptionConstants.ADD, storeAddress);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case DATASOURCE: {\n                    BaseJDBCStoreResource.DATA_SOURCE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.DATASOURCE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.DATASOURCE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STRING_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.STRING_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseStoreProperty(reader, store);\n                }\n            }\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","id":11341,"modified_method":"protected void parseStringKeyedJDBCStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress storeAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.STRING_KEYED_JDBC_STORE, ModelKeys.STRING_KEYED_JDBC_STORE_NAME);\n        ModelNode store = Util.createAddOperation(storeAddress);\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case DATASOURCE: {\n                    BaseJDBCStoreResource.DATA_SOURCE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.DATASOURCE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.DATASOURCE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STRING_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.STRING_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                default: {\n                    this.parseStoreProperty(reader, store);\n                }\n            }\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseLocalCache(XMLExtendedStreamReader reader, ModelNode containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        // set the cache mode to local\n        // cache.get(ModelKeys.MODE).set(Configuration.CacheMode.LOCAL.name());\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            this.parseCacheAttribute(reader, i, attribute, value, cache);\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.LOCAL_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n\n    }","id":11342,"modified_method":"private void parseLocalCache(XMLExtendedStreamReader reader, PathAddress containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ADD, null);\n        // NOTE: this list is used to avoid lost attribute updates to the cache\n        // object once it has been added to the operations list\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        // set the cache mode to local\n        // cache.get(ModelKeys.MODE).set(Configuration.CacheMode.LOCAL.name());\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            this.parseCacheAttribute(reader, i, attribute, value, cache);\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.LOCAL_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseTransaction(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the transaction add operation\n        ModelNode transactionAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone();\n        transactionAddress.add(ModelKeys.TRANSACTION, ModelKeys.TRANSACTION_NAME);\n        transactionAddress.protect();\n        ModelNode transaction = Util.getEmptyOperation(ModelDescriptionConstants.ADD, transactionAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case STOP_TIMEOUT: {\n                    TransactionResource.STOP_TIMEOUT.parseAndSetParameter(value, transaction, reader);\n                    break;\n                }\n                case MODE: {\n                    TransactionResource.MODE.parseAndSetParameter(value, transaction, reader);\n                    break;\n                }\n                case LOCKING: {\n                    TransactionResource.LOCKING.parseAndSetParameter(value, transaction, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(transaction);\n    }","id":11343,"modified_method":"protected void parseTransaction(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress transactionAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.TRANSACTION, ModelKeys.TRANSACTION_NAME);\n        ModelNode transaction = Util.createAddOperation(transactionAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case STOP_TIMEOUT: {\n                    TransactionResource.STOP_TIMEOUT.parseAndSetParameter(value, transaction, reader);\n                    break;\n                }\n                case MODE: {\n                    TransactionResource.MODE.parseAndSetParameter(value, transaction, reader);\n                    break;\n                }\n                case LOCKING: {\n                    TransactionResource.LOCKING.parseAndSetParameter(value, transaction, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(transaction);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseFileStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the file store add operation\n        ModelNode storeAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone() ;\n        storeAddress.add(ModelKeys.FILE_STORE,ModelKeys.FILE_STORE_NAME) ;\n        storeAddress.protect();\n        ModelNode store = Util.getEmptyOperation(ModelDescriptionConstants.ADD, storeAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case RELATIVE_TO: {\n                    FileStoreResource.RELATIVE_TO.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                case PATH: {\n                    FileStoreResource.PATH.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n        this.parseStoreElements(reader, store, additionalConfigurationOperations);\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","id":11344,"modified_method":"protected void parseFileStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress storeAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.FILE_STORE, ModelKeys.FILE_STORE_NAME);\n        ModelNode store = Util.createAddOperation(storeAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case RELATIVE_TO: {\n                    FileStoreResource.RELATIVE_TO.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                case PATH: {\n                    FileStoreResource.PATH.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n        this.parseStoreElements(reader, store, additionalConfigurationOperations);\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseCustomStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the store add operation\n        ModelNode storeAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone() ;\n        storeAddress.add(ModelKeys.STORE,ModelKeys.STORE_NAME) ;\n        storeAddress.protect();\n        ModelNode store = Util.getEmptyOperation(ModelDescriptionConstants.ADD, storeAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case CLASS: {\n                    StoreResource.CLASS.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.CLASS)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.CLASS));\n        }\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n        this.parseStoreElements(reader, store, additionalConfigurationOperations);\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","id":11345,"modified_method":"protected void parseCustomStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress storeAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.STORE, ModelKeys.STORE_NAME);\n        ModelNode store = Util.createAddOperation(storeAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case CLASS: {\n                    StoreResource.CLASS.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.CLASS)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.CLASS));\n        }\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n        this.parseStoreElements(reader, store, additionalConfigurationOperations);\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseContainer(XMLExtendedStreamReader reader, ModelNode subsystemAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        ModelNode container = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        String name = null;\n        final Set<Attribute> required = EnumSet.of(Attribute.NAME);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            ParseUtils.requireNoNamespaceAttribute(reader, i);\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            required.remove(attribute);\n            switch (attribute) {\n                case NAME: {\n                    name = value;\n                    break;\n                }\n                case ALIASES: {\n                    for (String alias: reader.getListAttributeValue(i)) {\n                        container.get(ModelKeys.ALIASES).add(alias);\n                    }\n                    break;\n                }\n                case DEFAULT_CACHE: {\n                    CacheContainerResource.DEFAULT_CACHE.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case JNDI_NAME: {\n                    CacheContainerResource.JNDI_NAME.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case START: {\n                    CacheContainerResource.START.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case LISTENER_EXECUTOR: {\n                    CacheContainerResource.LISTENER_EXECUTOR.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case EVICTION_EXECUTOR: {\n                    CacheContainerResource.EVICTION_EXECUTOR.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case REPLICATION_QUEUE_EXECUTOR: {\n                    CacheContainerResource.REPLICATION_QUEUE_EXECUTOR.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case MODULE: {\n                    CacheContainerResource.CACHE_CONTAINER_MODULE.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n\n        if (!required.isEmpty()) {\n            throw ParseUtils.missingRequired(reader, required);\n        }\n\n        ModelNode containerAddress = subsystemAddress.clone() ;\n        containerAddress.add(ModelKeys.CACHE_CONTAINER, name);\n        containerAddress.protect() ;\n        container.get(ModelDescriptionConstants.OP_ADDR).set(containerAddress);\n\n        // operation to add the container\n        operations.add(container);\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case TRANSPORT: {\n                    parseTransport(reader, containerAddress, operations);\n                    break;\n                }\n                case LOCAL_CACHE: {\n                    parseLocalCache(reader, containerAddress, operations);\n                    break;\n                }\n                case INVALIDATION_CACHE: {\n                    parseInvalidationCache(reader, containerAddress, operations);\n                    break;\n                }\n                case REPLICATED_CACHE: {\n                    parseReplicatedCache(reader, containerAddress, operations);\n                    break;\n                }\n                case DISTRIBUTED_CACHE: {\n                    parseDistributedCache(reader, containerAddress, operations);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n    }","id":11346,"modified_method":"private void parseContainer(XMLExtendedStreamReader reader, PathAddress subsystemAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        ModelNode container = Util.getEmptyOperation(ADD, null);\n        String name = null;\n        final Set<Attribute> required = EnumSet.of(Attribute.NAME);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            ParseUtils.requireNoNamespaceAttribute(reader, i);\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            required.remove(attribute);\n            switch (attribute) {\n                case NAME: {\n                    name = value;\n                    break;\n                }\n                case ALIASES: {\n                    for (String alias: reader.getListAttributeValue(i)) {\n                        container.get(ModelKeys.ALIASES).add(alias);\n                    }\n                    break;\n                }\n                case DEFAULT_CACHE: {\n                    CacheContainerResource.DEFAULT_CACHE.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case JNDI_NAME: {\n                    CacheContainerResource.JNDI_NAME.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case START: {\n                    CacheContainerResource.START.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case LISTENER_EXECUTOR: {\n                    CacheContainerResource.LISTENER_EXECUTOR.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case EVICTION_EXECUTOR: {\n                    CacheContainerResource.EVICTION_EXECUTOR.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case REPLICATION_QUEUE_EXECUTOR: {\n                    CacheContainerResource.REPLICATION_QUEUE_EXECUTOR.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                case MODULE: {\n                    CacheContainerResource.CACHE_CONTAINER_MODULE.parseAndSetParameter(value, container, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n\n        if (!required.isEmpty()) {\n            throw ParseUtils.missingRequired(reader, required);\n        }\n\n        PathAddress containerAddress = subsystemAddress.append(ModelKeys.CACHE_CONTAINER, name);\n        container.get(OP_ADDR).set(containerAddress.toModelNode());\n\n        // operation to add the container\n        operations.add(container);\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case TRANSPORT: {\n                    parseTransport(reader, containerAddress, operations);\n                    break;\n                }\n                case LOCAL_CACHE: {\n                    parseLocalCache(reader, containerAddress, operations);\n                    break;\n                }\n                case INVALIDATION_CACHE: {\n                    parseInvalidationCache(reader, containerAddress, operations);\n                    break;\n                }\n                case REPLICATED_CACHE: {\n                    parseReplicatedCache(reader, containerAddress, operations);\n                    break;\n                }\n                case DISTRIBUTED_CACHE: {\n                    parseDistributedCache(reader, containerAddress, operations);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseStoreWriteBehind(XMLExtendedStreamReader reader, ModelNode store, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the write-behind add operation\n        ModelNode writeBehindAddress = store.get(ModelDescriptionConstants.OP_ADDR).clone() ;\n        writeBehindAddress.add(ModelKeys.WRITE_BEHIND,ModelKeys.WRITE_BEHIND_NAME) ;\n        writeBehindAddress.protect();\n        ModelNode writeBehind = Util.getEmptyOperation(ModelDescriptionConstants.ADD, writeBehindAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case FLUSH_LOCK_TIMEOUT: {\n                    StoreWriteBehindResource.FLUSH_LOCK_TIMEOUT.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                case MODIFICATION_QUEUE_SIZE: {\n                    StoreWriteBehindResource.MODIFICATION_QUEUE_SIZE.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                case SHUTDOWN_TIMEOUT: {\n                    StoreWriteBehindResource.SHUTDOWN_TIMEOUT.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                case THREAD_POOL_SIZE: {\n                    StoreWriteBehindResource.THREAD_POOL_SIZE.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                default:\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(writeBehind);\n    }","id":11347,"modified_method":"private void parseStoreWriteBehind(XMLExtendedStreamReader reader, ModelNode store, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress writeBehindAddress = PathAddress.pathAddress(store.get(OP_ADDR)).append(ModelKeys.WRITE_BEHIND, ModelKeys.WRITE_BEHIND_NAME);\n        ModelNode writeBehind = Util.createAddOperation(writeBehindAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case FLUSH_LOCK_TIMEOUT: {\n                    StoreWriteBehindResource.FLUSH_LOCK_TIMEOUT.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                case MODIFICATION_QUEUE_SIZE: {\n                    StoreWriteBehindResource.MODIFICATION_QUEUE_SIZE.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                case SHUTDOWN_TIMEOUT: {\n                    StoreWriteBehindResource.SHUTDOWN_TIMEOUT.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                case THREAD_POOL_SIZE: {\n                    StoreWriteBehindResource.THREAD_POOL_SIZE.parseAndSetParameter(value, writeBehind, reader);\n                    break;\n                }\n                default:\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(writeBehind);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseStateTransfer(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the state transfer add operation\n        ModelNode stateTransferAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone();\n        stateTransferAddress.add(ModelKeys.STATE_TRANSFER, ModelKeys.STATE_TRANSFER_NAME);\n        stateTransferAddress.protect();\n        ModelNode stateTransfer = Util.getEmptyOperation(ModelDescriptionConstants.ADD, stateTransferAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case ENABLED: {\n                    StateTransferResource.ENABLED.parseAndSetParameter(value, stateTransfer, reader);\n                    break;\n                }\n                case TIMEOUT: {\n                    StateTransferResource.TIMEOUT.parseAndSetParameter(value, stateTransfer, reader);\n                    break;\n                }\n                case CHUNK_SIZE: {\n                    StateTransferResource.CHUNK_SIZE.parseAndSetParameter(value, stateTransfer, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(stateTransfer);\n    }","id":11348,"modified_method":"private void parseStateTransfer(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress stateTransferAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.STATE_TRANSFER, ModelKeys.STATE_TRANSFER_NAME);\n        ModelNode stateTransfer = Util.createAddOperation(stateTransferAddress);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case ENABLED: {\n                    StateTransferResource.ENABLED.parseAndSetParameter(value, stateTransfer, reader);\n                    break;\n                }\n                case TIMEOUT: {\n                    StateTransferResource.TIMEOUT.parseAndSetParameter(value, stateTransfer, reader);\n                    break;\n                }\n                case CHUNK_SIZE: {\n                    StateTransferResource.CHUNK_SIZE.parseAndSetParameter(value, stateTransfer, reader);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n        operations.add(stateTransfer);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void parseMixedKeyedJDBCStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n        // ModelNode for the mixed-keyed jdbc store add operation\n        ModelNode storeAddress = cache.get(ModelDescriptionConstants.OP_ADDR).clone() ;\n        storeAddress.add(ModelKeys.MIXED_KEYED_JDBC_STORE,ModelKeys.MIXED_KEYED_JDBC_STORE_NAME) ;\n        storeAddress.protect();\n        ModelNode store = Util.getEmptyOperation(ModelDescriptionConstants.ADD, storeAddress);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case DATASOURCE: {\n                    BaseJDBCStoreResource.DATA_SOURCE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.DATASOURCE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.DATASOURCE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STRING_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.STRING_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case BINARY_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.BINARY_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                case PROPERTY: {\n                    parseStoreProperty(reader, store);\n                    break;\n                }\n                default:\n                    throw ParseUtils.unexpectedElement(reader);\n            }\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","id":11349,"modified_method":"protected void parseMixedKeyedJDBCStore(XMLExtendedStreamReader reader, ModelNode cache, List<ModelNode> operations) throws XMLStreamException {\n\n        PathAddress storeAddress = PathAddress.pathAddress(cache.get(OP_ADDR)).append(ModelKeys.MIXED_KEYED_JDBC_STORE, ModelKeys.MIXED_KEYED_JDBC_STORE_NAME);\n        ModelNode store = Util.createAddOperation(storeAddress);\n\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case DATASOURCE: {\n                    BaseJDBCStoreResource.DATA_SOURCE.parseAndSetParameter(value, store, reader);\n                    break;\n                }\n                default: {\n                    this.parseStoreAttribute(reader, i, attribute, value, store);\n                }\n            }\n        }\n\n        if (!store.hasDefined(ModelKeys.DATASOURCE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.DATASOURCE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case STRING_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.STRING_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case BINARY_KEYED_TABLE: {\n                    this.parseJDBCStoreTable(reader, store.get(ModelKeys.BINARY_KEYED_TABLE).setEmptyObject());\n                    break;\n                }\n                case WRITE_BEHIND: {\n                    parseStoreWriteBehind(reader, store, additionalConfigurationOperations);\n                    break;\n                }\n                case PROPERTY: {\n                    parseStoreProperty(reader, store);\n                    break;\n                }\n                default:\n                    throw ParseUtils.unexpectedElement(reader);\n            }\n        }\n        operations.add(store);\n        operations.addAll(additionalConfigurationOperations);\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseInvalidationCache(XMLExtendedStreamReader reader, ModelNode containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            this.parseClusteredCacheAttribute(reader, i, attribute, value, cache);\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n        if (!cache.hasDefined(ModelKeys.MODE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.MODE));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.INVALIDATION_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                default: {\n                    this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n                }\n            }\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n    }","id":11350,"modified_method":"private void parseInvalidationCache(XMLExtendedStreamReader reader, PathAddress containerAddress, List<ModelNode> operations) throws XMLStreamException {\n\n        // ModelNode for the cache add operation\n        ModelNode cache = Util.getEmptyOperation(ModelDescriptionConstants.ADD, null);\n        List<ModelNode> additionalConfigurationOperations = new ArrayList<ModelNode>();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            this.parseClusteredCacheAttribute(reader, i, attribute, value, cache);\n        }\n\n        if (!cache.hasDefined(ModelKeys.NAME)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.NAME));\n        }\n        if (!cache.hasDefined(ModelKeys.MODE)) {\n            throw ParseUtils.missingRequired(reader, EnumSet.of(Attribute.MODE));\n        }\n\n        // update the cache address with the cache name\n        addCacheNameToAddress(cache, containerAddress, ModelKeys.INVALIDATION_CACHE) ;\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                default: {\n                    this.parseCacheElement(reader, element, cache, additionalConfigurationOperations);\n                }\n            }\n        }\n\n        operations.add(cache);\n        // add operations to create configuration resources\n        for (ModelNode additionalOperation : additionalConfigurationOperations) {\n            operations.add(additionalOperation);\n        }\n    }","commit_id":"af1d00f4f65eccb0e1b690e04fd2d39e0a81f216","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void testEval() throws Exception {\r\n        PackageBuilder builder = new PackageBuilder();\r\n\r\n        PackageDescr packageDescr = new PackageDescr( \"p1\" );\r\n        RuleDescr ruleDescr = new RuleDescr( \"rule-1\" );\r\n        packageDescr.addRule( ruleDescr );\r\n\r\n        AndDescr lhs = new AndDescr();\r\n        ruleDescr.setLhs( lhs );\r\n\r\n        ColumnDescr column = new ColumnDescr( Cheese.class.getName(),\r\n                                              \"stilton\" );\r\n        lhs.addDescr( column );\r\n\r\n        FieldBindingDescr fieldBindingDescr = new FieldBindingDescr( \"price\",\r\n                                                                     \"x\" );\r\n        column.addDescr( fieldBindingDescr );\r\n        fieldBindingDescr = new FieldBindingDescr( \"price\",\r\n                                                   \"y\" );\r\n        column.addDescr( fieldBindingDescr );\r\n\r\n        packageDescr.addGlobal( \"map\",\r\n                                \"java.util.Map\" );\r\n\r\n        EvalDescr evalDescr = new EvalDescr( \"( ( Integer )map.get(x) ).intValue() == y.intValue()\" );\r\n        lhs.addDescr( evalDescr );\r\n\r\n        ruleDescr.setConsequence( \"modify(stilton);\" );\r\n\r\n        builder.addPackage( packageDescr );\r\n\r\n        assertLength( 0,\r\n                      builder.getErrors() );\r\n    }","id":11351,"modified_method":"public void testEval() throws Exception {\r\n        PackageBuilder builder = new PackageBuilder();\r\n\r\n        PackageDescr packageDescr = new PackageDescr( \"p1\" );\r\n        RuleDescr ruleDescr = new RuleDescr( \"rule-1\" );\r\n        packageDescr.addRule( ruleDescr );\r\n\r\n        AndDescr lhs = new AndDescr();\r\n        ruleDescr.setLhs( lhs );\r\n\r\n        ColumnDescr column = new ColumnDescr( Cheese.class.getName(),\r\n                                              \"stilton\" );\r\n        lhs.addDescr( column );\r\n\r\n        FieldBindingDescr fieldBindingDescr = new FieldBindingDescr( \"price\",\r\n                                                                     \"x\" );\r\n        column.addDescr( fieldBindingDescr );\r\n        fieldBindingDescr = new FieldBindingDescr( \"price\",\r\n                                                   \"y\" );\r\n        column.addDescr( fieldBindingDescr );\r\n\r\n        packageDescr.addGlobal( \"map\",\r\n                                \"java.util.Map\" );\r\n\r\n        EvalDescr evalDescr = new EvalDescr( \"( ( Integer )map.get(x) ).intValue() == y.intValue()\" );\r\n        lhs.addDescr( evalDescr );\r\n\r\n        ruleDescr.setConsequence( \"modify(stilton);\" );\r\n\r\n        builder.addPackage( packageDescr );                        \r\n\r\n        assertLength( 0,\r\n                      builder.getErrors() );\r\n        \r\n        Package pkg = builder.getPackage();\r\n        Rule rule = pkg.getRule( \"rule-1\" );\r\n        EvalCondition eval = (EvalCondition) rule.getLhs().getChildren().get( 1 );\r\n        CompiledInvoker invoker = (CompiledInvoker ) eval.getEvalExpression();\r\n        List list =  invoker.getMethodBytecode();\r\n    }","commit_id":"eeb76393d9c723140de90ce9def107730b23b03d","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private EvalCondition build(EvalDescr evalDescr) {\r\n\r\n        String classMethodName = \"eval\" + counter++;\r\n        evalDescr.setClassMethodName( classMethodName );\r\n\r\n        List usedDeclarations = getUsedDeclarations( evalDescr,\r\n                                                     evalDescr.getText() );\r\n\r\n        Declaration[] declarations = new Declaration[usedDeclarations.size()];\r\n        for ( int i = 0, size = usedDeclarations.size(); i < size; i++ ) {\r\n            declarations[i] = (Declaration) this.declarations.get( (String) usedDeclarations.get( i ) );\r\n        }\r\n\r\n        EvalCondition eval = new EvalCondition( declarations );\r\n\r\n        StringTemplate st = ruleGroup.getInstanceOf( \"evalMethod\" );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     evalDescr.getText() );\r\n\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n        st.setAttribute( \"text\",\r\n                         functionFixer.fix( evalDescr.getText() ) );\r\n\r\n        this.methods.add( st.toString() );\r\n\r\n        st = invokerGroup.getInstanceOf( \"evalInvoker\" );\r\n\r\n        st.setAttribute( \"package\",\r\n                         this.pkg.getName() );\r\n        st.setAttribute( \"ruleClassName\",\r\n                         ucFirst( this.ruleDescr.getClassName() ) );\r\n        st.setAttribute( \"invokerClassName\",\r\n                         ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\" );\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     evalDescr.getText() );\r\n\r\n        st.setAttribute( \"text\",\r\n                         evalDescr.getText() );\r\n\r\n        String invokerClassName = pkg.getName() + \".\" + ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\";\r\n        this.invokers.put( invokerClassName,\r\n                           st.toString() );\r\n        this.invokerLookups.put( invokerClassName,\r\n                                 eval );\r\n        this.descrLookups.put( invokerClassName,\r\n                               evalDescr );\r\n        return eval;\r\n    }","id":11352,"modified_method":"private EvalCondition build(EvalDescr evalDescr) {\r\n\r\n        String classMethodName = \"eval\" + counter++;\r\n        evalDescr.setClassMethodName( classMethodName );\r\n\r\n        List usedDeclarations = getUsedDeclarations( evalDescr,\r\n                                                     evalDescr.getText() );\r\n\r\n        Declaration[] declarations = new Declaration[usedDeclarations.size()];\r\n        for ( int i = 0, size = usedDeclarations.size(); i < size; i++ ) {\r\n            declarations[i] = (Declaration) this.declarations.get( (String) usedDeclarations.get( i ) );\r\n        }\r\n\r\n        EvalCondition eval = new EvalCondition( declarations );\r\n\r\n        StringTemplate st = ruleGroup.getInstanceOf( \"evalMethod\" );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     evalDescr.getText() );\r\n\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n        \r\n        String  evalText = functionFixer.fix( evalDescr.getText() );\r\n        st.setAttribute( \"text\",\r\n                          evalText );\r\n\r\n        this.methods.add( st.toString() );\r\n\r\n        st = invokerGroup.getInstanceOf( \"evalInvoker\" );\r\n\r\n        st.setAttribute( \"package\",\r\n                         this.pkg.getName() );\r\n        st.setAttribute( \"ruleClassName\",\r\n                         ucFirst( this.ruleDescr.getClassName() ) );\r\n        st.setAttribute( \"invokerClassName\",\r\n                         ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\" );\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     evalDescr.getText() );\r\n\r\n        st.setAttribute( \"hashCode\",\r\n                         evalText.hashCode() );\r\n\r\n        String invokerClassName = pkg.getName() + \".\" + ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\";\r\n        this.invokers.put( invokerClassName,\r\n                           st.toString() );\r\n        this.invokerLookups.put( invokerClassName,\r\n                                 eval );\r\n        this.descrLookups.put( invokerClassName,\r\n                               evalDescr );\r\n        return eval;\r\n    }","commit_id":"eeb76393d9c723140de90ce9def107730b23b03d","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public synchronized Rule build(Package pkg,\r\n                                   RuleDescr ruleDescr) {\r\n        this.pkg = pkg;\r\n        this.methods = new ArrayList();\r\n        this.invokers = new HashMap();\r\n        this.invokerLookups = new HashMap();\r\n        this.declarations = new HashMap();\r\n        this.descrLookups = new HashMap();\r\n\r\n        this.typeResolver = new ClassTypeResolver( pkg.getImports(),\r\n                                                   pkg.getPackageCompilationData().getClassLoader() );\r\n        // make an automatic import for the current package\r\n        this.typeResolver.addImport( pkg.getName() + \".*\" );\r\n\r\n        this.ruleDescr = ruleDescr;\r\n\r\n        if ( ruleDescr instanceof QueryDescr ) {\r\n            this.rule = new Query( ruleDescr.getName() );\r\n        } else {\r\n            this.rule = new Rule( ruleDescr.getName() );\r\n        }\r\n\r\n        // Assign attributes\r\n        setAttributes( rule,\r\n                       ruleDescr.getAttributes() );\r\n\r\n        // Build the left hand side\r\n        // generate invoker, methods\r\n        build( ruleDescr );\r\n\r\n        return rule;\r\n    }","id":11353,"modified_method":"public synchronized Rule build(Package pkg,\r\n                                   RuleDescr ruleDescr) {\r\n        this.pkg = pkg;\r\n        this.methods = new ArrayList();\r\n        this.invokers = new HashMap();\r\n        this.invokerLookups = new HashMap();\r\n        this.declarations = new HashMap();\r\n        this.descrLookups = new HashMap();\r\n\r\n        this.typeResolver = new ClassTypeResolver( pkg.getImports(),\r\n                                                   pkg.getPackageCompilationData().getClassLoader() );\r\n        // make an automatic import for the current package\r\n        this.typeResolver.addImport( pkg.getName() + \".*\" );\r\n        this.typeResolver.addImport( \"java.lang.*\" );\r\n\r\n        this.ruleDescr = ruleDescr;\r\n\r\n        if ( ruleDescr instanceof QueryDescr ) {\r\n            this.rule = new Query( ruleDescr.getName() );\r\n        } else {\r\n            this.rule = new Rule( ruleDescr.getName() );\r\n        }\r\n\r\n        // Assign attributes\r\n        setAttributes( rule,\r\n                       ruleDescr.getAttributes() );\r\n\r\n        // Build the left hand side\r\n        // generate invoker, methods\r\n        build( ruleDescr );\r\n\r\n        return rule;\r\n    }","commit_id":"eeb76393d9c723140de90ce9def107730b23b03d","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void build(Column column,\r\n                       ReturnValueDescr returnValueDescr) {\r\n        String classMethodName = \"returnValue\" + counter++;\r\n        returnValueDescr.setClassMethodName( classMethodName );\r\n\r\n        List usedDeclarations = getUsedDeclarations( returnValueDescr,\r\n                                                     returnValueDescr.getText() );\r\n        if ( usedDeclarations == null ) {\r\n            return;\r\n        }\r\n\r\n        Declaration[] declarations = new Declaration[usedDeclarations.size()];\r\n        for ( int i = 0, size = usedDeclarations.size(); i < size; i++ ) {\r\n            declarations[i] = (Declaration) this.declarations.get( (String) usedDeclarations.get( i ) );\r\n        }\r\n\r\n        Class clazz = ((ClassObjectType) column.getObjectType()).getClassType();\r\n        FieldExtractor extractor = getFieldExtractor( returnValueDescr,\r\n                                                      clazz,\r\n                                                      returnValueDescr.getFieldName() );\r\n        if ( extractor == null ) {\r\n            return;\r\n        }\r\n\r\n        Evaluator evaluator = getEvaluator( returnValueDescr,\r\n                                            extractor.getObjectType().getValueType(),\r\n                                            returnValueDescr.getEvaluator() );\r\n        if ( evaluator == null ) {\r\n            return;\r\n        }\r\n\r\n        ReturnValueConstraint returnValueConstraint = new ReturnValueConstraint( extractor,\r\n                                                                                 declarations,\r\n                                                                                 evaluator );\r\n        column.addConstraint( returnValueConstraint );\r\n\r\n        StringTemplate st = ruleGroup.getInstanceOf( \"returnValueMethod\" );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     returnValueDescr.getText() );\r\n\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n        st.setAttribute( \"text\",\r\n                         functionFixer.fix( returnValueDescr.getText() ) );\r\n\r\n        this.methods.add( st.toString() );\r\n\r\n        st = invokerGroup.getInstanceOf( \"returnValueInvoker\" );\r\n\r\n        st.setAttribute( \"package\",\r\n                         this.pkg.getName() );\r\n        st.setAttribute( \"ruleClassName\",\r\n                         ucFirst( this.ruleDescr.getClassName() ) );\r\n        st.setAttribute( \"invokerClassName\",\r\n                         ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\" );\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     returnValueDescr.getText() );\r\n\r\n        st.setAttribute( \"text\",\r\n                         returnValueDescr.getText() );\r\n\r\n        String invokerClassName = pkg.getName() + \".\" + ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\";\r\n        this.invokers.put( invokerClassName,\r\n                           st.toString() );\r\n        this.invokerLookups.put( invokerClassName,\r\n                                 returnValueConstraint );\r\n        this.descrLookups.put( invokerClassName,\r\n                               returnValueDescr );\r\n    }","id":11354,"modified_method":"private void build(Column column,\r\n                       ReturnValueDescr returnValueDescr) {\r\n        String classMethodName = \"returnValue\" + counter++;\r\n        returnValueDescr.setClassMethodName( classMethodName );\r\n\r\n        List usedDeclarations = getUsedDeclarations( returnValueDescr,\r\n                                                     returnValueDescr.getText() );\r\n        if ( usedDeclarations == null ) {\r\n            return;\r\n        }\r\n\r\n        Declaration[] declarations = new Declaration[usedDeclarations.size()];\r\n        for ( int i = 0, size = usedDeclarations.size(); i < size; i++ ) {\r\n            declarations[i] = (Declaration) this.declarations.get( (String) usedDeclarations.get( i ) );\r\n        }\r\n\r\n        Class clazz = ((ClassObjectType) column.getObjectType()).getClassType();\r\n        FieldExtractor extractor = getFieldExtractor( returnValueDescr,\r\n                                                      clazz,\r\n                                                      returnValueDescr.getFieldName() );\r\n        if ( extractor == null ) {\r\n            return;\r\n        }\r\n\r\n        Evaluator evaluator = getEvaluator( returnValueDescr,\r\n                                            extractor.getObjectType().getValueType(),\r\n                                            returnValueDescr.getEvaluator() );\r\n        if ( evaluator == null ) {\r\n            return;\r\n        }\r\n\r\n        ReturnValueConstraint returnValueConstraint = new ReturnValueConstraint( extractor,\r\n                                                                                 declarations,\r\n                                                                                 evaluator );\r\n        column.addConstraint( returnValueConstraint );\r\n\r\n        StringTemplate st = ruleGroup.getInstanceOf( \"returnValueMethod\" );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     returnValueDescr.getText() );\r\n\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n        \r\n        String returnValueText = functionFixer.fix( returnValueDescr.getText() );\r\n        st.setAttribute( \"text\",\r\n                         returnValueText );\r\n\r\n        this.methods.add( st.toString() );\r\n\r\n        st = invokerGroup.getInstanceOf( \"returnValueInvoker\" );\r\n\r\n        st.setAttribute( \"package\",\r\n                         this.pkg.getName() );\r\n        st.setAttribute( \"ruleClassName\",\r\n                         ucFirst( this.ruleDescr.getClassName() ) );\r\n        st.setAttribute( \"invokerClassName\",\r\n                         ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\" );\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     returnValueDescr.getText() );\r\n\r\n        st.setAttribute( \"hashCode\",\r\n                         returnValueText.hashCode() );\r\n\r\n        String invokerClassName = pkg.getName() + \".\" + ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\";\r\n        this.invokers.put( invokerClassName,\r\n                           st.toString() );\r\n        this.invokerLookups.put( invokerClassName,\r\n                                 returnValueConstraint );\r\n        this.descrLookups.put( invokerClassName,\r\n                               returnValueDescr );\r\n    }","commit_id":"eeb76393d9c723140de90ce9def107730b23b03d","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void build(Column column,\r\n                       PredicateDescr predicateDescr) {\r\n        // generate method\r\n        // generate Invoker\r\n        String classMethodName = \"predicate\" + counter++;\r\n        predicateDescr.setClassMethodName( classMethodName );\r\n\r\n        Class clazz = ((ClassObjectType) column.getObjectType()).getClassType();\r\n\r\n        FieldExtractor extractor = getFieldExtractor( predicateDescr,\r\n                                                      clazz,\r\n                                                      predicateDescr.getFieldName() );\r\n        if ( extractor == null ) {\r\n            return;\r\n        }\r\n\r\n        Declaration declaration = column.addDeclaration( predicateDescr.getDeclaration(),\r\n                                                         extractor );\r\n\r\n        this.declarations.put( declaration.getIdentifier(),\r\n                               declaration );\r\n\r\n        if ( this.notDeclarations != null ) {\r\n            this.notDeclarations.put( declaration.getIdentifier(),\r\n                                      declaration );\r\n        }\r\n\r\n        List usedDeclarations = getUsedDeclarations( predicateDescr,\r\n                                                     predicateDescr.getText() );\r\n        if ( usedDeclarations == null ) {\r\n            return;\r\n        }\r\n\r\n        // Don't include the focus declaration, that hasn't been merged into the tuple yet.\r\n        usedDeclarations.remove( predicateDescr.getDeclaration() );\r\n\r\n        Declaration[] declarations = new Declaration[usedDeclarations.size()];\r\n        for ( int i = 0, size = usedDeclarations.size(); i < size; i++ ) {\r\n            declarations[i] = (Declaration) this.declarations.get( (String) usedDeclarations.get( i ) );\r\n        }\r\n\r\n        PredicateConstraint predicateConstraint = new PredicateConstraint( declaration,\r\n                                                                           declarations );\r\n        column.addConstraint( predicateConstraint );\r\n\r\n        StringTemplate st = ruleGroup.getInstanceOf( \"predicateMethod\" );\r\n\r\n        st.setAttribute( \"declaration\",\r\n                         declaration );\r\n        st.setAttribute( \"declarationType\",\r\n                         ((ClassObjectType) declaration.getObjectType()).getClassType().getName().replace( '$',\r\n                                                                                                           '.' ) );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     predicateDescr.getText() );\r\n\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n        st.setAttribute( \"text\",\r\n                         functionFixer.fix( predicateDescr.getText() ) );\r\n\r\n        this.methods.add( st.toString() );\r\n\r\n        st = invokerGroup.getInstanceOf( \"predicateInvoker\" );\r\n\r\n        st.setAttribute( \"package\",\r\n                         this.pkg.getName() );\r\n        st.setAttribute( \"ruleClassName\",\r\n                         ucFirst( this.ruleDescr.getClassName() ) );\r\n        st.setAttribute( \"invokerClassName\",\r\n                         ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\" );\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n\r\n        st.setAttribute( \"declaration\",\r\n                         declaration );\r\n        st.setAttribute( \"declarationType\",\r\n                         ((ClassObjectType) declaration.getObjectType()).getClassType().getName().replace( '$',\r\n                                                                                                           '.' ) );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     predicateDescr.getText() );\r\n\r\n        st.setAttribute( \"text\",\r\n                         predicateDescr.getText() );\r\n\r\n        String invokerClassName = pkg.getName() + \".\" + ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\";\r\n        this.invokers.put( invokerClassName,\r\n                           st.toString() );\r\n        this.invokerLookups.put( invokerClassName,\r\n                                 predicateConstraint );\r\n        this.descrLookups.put( invokerClassName,\r\n                               predicateDescr );\r\n    }","id":11355,"modified_method":"private void build(Column column,\r\n                       PredicateDescr predicateDescr) {\r\n        // generate method\r\n        // generate Invoker\r\n        String classMethodName = \"predicate\" + counter++;\r\n        predicateDescr.setClassMethodName( classMethodName );\r\n\r\n        Class clazz = ((ClassObjectType) column.getObjectType()).getClassType();\r\n\r\n        FieldExtractor extractor = getFieldExtractor( predicateDescr,\r\n                                                      clazz,\r\n                                                      predicateDescr.getFieldName() );\r\n        if ( extractor == null ) {\r\n            return;\r\n        }\r\n\r\n        Declaration declaration = column.addDeclaration( predicateDescr.getDeclaration(),\r\n                                                         extractor );\r\n\r\n        this.declarations.put( declaration.getIdentifier(),\r\n                               declaration );\r\n\r\n        if ( this.notDeclarations != null ) {\r\n            this.notDeclarations.put( declaration.getIdentifier(),\r\n                                      declaration );\r\n        }\r\n\r\n        List usedDeclarations = getUsedDeclarations( predicateDescr,\r\n                                                     predicateDescr.getText() );\r\n        if ( usedDeclarations == null ) {\r\n            return;\r\n        }\r\n\r\n        // Don't include the focus declaration, that hasn't been merged into the tuple yet.\r\n        usedDeclarations.remove( predicateDescr.getDeclaration() );\r\n\r\n        Declaration[] declarations = new Declaration[usedDeclarations.size()];\r\n        for ( int i = 0, size = usedDeclarations.size(); i < size; i++ ) {\r\n            declarations[i] = (Declaration) this.declarations.get( (String) usedDeclarations.get( i ) );\r\n        }\r\n\r\n        PredicateConstraint predicateConstraint = new PredicateConstraint( declaration,\r\n                                                                           declarations );\r\n        column.addConstraint( predicateConstraint );\r\n\r\n        StringTemplate st = ruleGroup.getInstanceOf( \"predicateMethod\" );\r\n\r\n        st.setAttribute( \"declaration\",\r\n                         declaration );\r\n        st.setAttribute( \"declarationType\",\r\n                         ((ClassObjectType) declaration.getObjectType()).getClassType().getName().replace( '$',\r\n                                                                                                           '.' ) );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     predicateDescr.getText() );\r\n\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n        \r\n        String predicateText =  functionFixer.fix( predicateDescr.getText() );\r\n        st.setAttribute( \"text\",\r\n                         predicateText );\r\n\r\n        this.methods.add( st.toString() );\r\n\r\n        st = invokerGroup.getInstanceOf( \"predicateInvoker\" );\r\n\r\n        st.setAttribute( \"package\",\r\n                         this.pkg.getName() );\r\n        st.setAttribute( \"ruleClassName\",\r\n                         ucFirst( this.ruleDescr.getClassName() ) );\r\n        st.setAttribute( \"invokerClassName\",\r\n                         ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\" );\r\n        st.setAttribute( \"methodName\",\r\n                         classMethodName );\r\n\r\n        st.setAttribute( \"declaration\",\r\n                         declaration );\r\n        st.setAttribute( \"declarationType\",\r\n                         ((ClassObjectType) declaration.getObjectType()).getClassType().getName().replace( '$',\r\n                                                                                                           '.' ) );\r\n\r\n        setStringTemplateAttributes( st,\r\n                                     declarations,\r\n                                     predicateDescr.getText() );\r\n\r\n        st.setAttribute( \"hashCode\",\r\n                         predicateText.hashCode() );\r\n\r\n        String invokerClassName = pkg.getName() + \".\" + ruleDescr.getClassName() + ucFirst( classMethodName ) + \"Invoker\";\r\n        this.invokers.put( invokerClassName,\r\n                           st.toString() );\r\n        this.invokerLookups.put( invokerClassName,\r\n                                 predicateConstraint );\r\n        this.descrLookups.put( invokerClassName,\r\n                               predicateDescr );\r\n    }","commit_id":"eeb76393d9c723140de90ce9def107730b23b03d","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void addDynPropertyAnnotation(Annotation annotation, GrReferenceExpression referenceExpression) {\n    Module module = ProjectRootManager.getInstance(referenceExpression.getProject()).getFileIndex().getModuleForFile(referenceExpression.getContainingFile().getVirtualFile());\n    String dynamicValueTypeDefinitionText = findDynamicValueTypeDefinitionText(referenceExpression);\n\n    DynamicProperty dynamicProperty = new DynamicPropertyBase(referenceExpression.getName(), dynamicValueTypeDefinitionText, module.getName());\n    annotation.registerFix(new DynamicPropertyIntention(dynamicProperty));\n  }","id":11356,"modified_method":"private void addDynPropertyAnnotation(Annotation annotation, GrReferenceExpression referenceExpression) {\n    final PsiFile containingFile = referenceExpression.getContainingFile();\n    VirtualFile file;\n    if (containingFile != null) {\n      file = containingFile.getVirtualFile();\n      if (file == null) return;\n    } else return;\n\n    Module module = ProjectRootManager.getInstance(referenceExpression.getProject()).getFileIndex().getModuleForFile(file);\n    String dynamicValueTypeDefinitionText = findDynamicValueTypeDefinitionText(referenceExpression);\n\n    if (module == null) return;\n    DynamicProperty dynamicProperty = new DynamicPropertyBase(referenceExpression.getName(), dynamicValueTypeDefinitionText, module.getName());\n    annotation.registerFix(new DynamicPropertyIntention(dynamicProperty));\n  }","commit_id":"02af5893a3f556504bdfa356d9f9050099eb2f6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isNeedsAddDynPropertiesAnnotation(GrReferenceExpression referenceExpression) {\n    String dynamicValueTypeDefinitionText = findDynamicValueTypeDefinitionText(referenceExpression);\n    Module module = ProjectRootManager.getInstance(referenceExpression.getProject()).getFileIndex().getModuleForFile(referenceExpression.getContainingFile().getVirtualFile());\n\n    //todo [dimaskin]  fix NPE!!!\n    DynamicProperty dynamicProperty = new DynamicPropertyBase(referenceExpression.getName(), dynamicValueTypeDefinitionText, module.getName());\n    final String dynPropElement = DynamicPropertiesManager.getInstance(referenceExpression.getProject()).findConcreateDynamicProperty(dynamicProperty);\n\n    return dynPropElement == null;\n  }","id":11357,"modified_method":"private boolean isNeedsAddDynPropertiesAnnotation(GrReferenceExpression referenceExpression) {\n    String dynamicValueTypeDefinitionText = findDynamicValueTypeDefinitionText(referenceExpression);\n    final PsiFile containingFile = referenceExpression.getContainingFile();\n\n    VirtualFile file;\n    if (containingFile != null) {\n      file = containingFile.getVirtualFile();\n      if (file == null) return false;\n    } else return false;\n\n    Module module = ProjectRootManager.getInstance(referenceExpression.getProject()).getFileIndex().getModuleForFile(file);\n\n    if (module == null) return false;\n    DynamicProperty dynamicProperty = new DynamicPropertyBase(referenceExpression.getName(), dynamicValueTypeDefinitionText, module.getName());\n    final String dynPropElement = DynamicPropertiesManager.getInstance(referenceExpression.getProject()).findConcreateDynamicProperty(dynamicProperty);\n\n    return dynPropElement == null;\n  }","commit_id":"02af5893a3f556504bdfa356d9f9050099eb2f6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement[] superElements = findSuperElements(file, offset);\n    if (superElements == null || superElements.length == 0) return;\n    if (superElements.length == 1) {\n      PsiElement superElement = superElements[0].getNavigationElement();\n      OpenFileDescriptor descriptor = new OpenFileDescriptor(project, superElement.getContainingFile().getVirtualFile(), superElement.getTextOffset());\n      FileEditorManager.getInstance(project).openTextEditor(descriptor, true);\n    } else {\n      if (superElements[0] instanceof PsiMethod) {\n        boolean showMethodNames = !PsiUtil.allMethodsHaveSameSignature((PsiMethod[])superElements);\n        PsiElementListNavigator.openTargets(editor, (PsiMethod[])superElements,\n                                            CodeInsightBundle.message(\"goto.super.method.chooser.title\"),\n                                            new MethodCellRenderer(showMethodNames));\n      }\n      else {\n        NavigationUtil.getPsiElementPopup(superElements, CodeInsightBundle.message(\"goto.super.class.chooser.title\")).showInBestPositionFor(editor);\n      }\n    }\n  }","id":11358,"modified_method":"public void invoke(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement[] superElements = findSuperElements(file, offset);\n    if (superElements == null || superElements.length == 0) return;\n    if (superElements.length == 1) {\n      PsiElement superElement = superElements[0].getNavigationElement();\n      final PsiFile containingFile = superElement.getContainingFile();\n      if (containingFile == null) return;\n      final VirtualFile virtualFile = containingFile.getVirtualFile();\n      if (virtualFile == null) return;\n      OpenFileDescriptor descriptor = new OpenFileDescriptor(project, virtualFile, superElement.getTextOffset());\n      FileEditorManager.getInstance(project).openTextEditor(descriptor, true);\n    } else {\n      if (superElements[0] instanceof PsiMethod) {\n        boolean showMethodNames = !PsiUtil.allMethodsHaveSameSignature((PsiMethod[])superElements);\n        PsiElementListNavigator.openTargets(editor, (PsiMethod[])superElements,\n                                            CodeInsightBundle.message(\"goto.super.method.chooser.title\"),\n                                            new MethodCellRenderer(showMethodNames));\n      }\n      else {\n        NavigationUtil.getPsiElementPopup(superElements, CodeInsightBundle.message(\"goto.super.class.chooser.title\")).showInBestPositionFor(editor);\n      }\n    }\n  }","commit_id":"8f9536d5ab010c908a77c9b7c3c91c5ccbb308d3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public double elapsedTime(TimeUnit unit) {\n        double nanos = elapsedTimeNanos();\n        double nanosPerUnit = TimeUnit.NANOSECONDS.convert(1, unit);\n        return nanos/nanosPerUnit;\n    }","id":11359,"modified_method":"public double elapsedTime(TimeUnit unit) {\n        return convertFromNanos(elapsedTimeNanos(), unit);\n    }","commit_id":"1cd59a2f0d267592e4eaa46252525e0028456217","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public double elapsedTimeInMillis() {\n        return elapsedTime(TimeUnit.MILLISECONDS);\n    }","id":11360,"modified_method":"public double elapsedTimeInMillis() {\n        return convertFromNanos(elapsedTimeNanos(), TimeUnit.MILLISECONDS);\n    }","commit_id":"1cd59a2f0d267592e4eaa46252525e0028456217","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long getTimeoutInSeconds() {\n        return getTimeout(TimeUnit.SECONDS);\n    }","id":11361,"modified_method":"public long getTimeoutInSeconds() {\n        return m_timeoutInSeconds;\n    }","commit_id":"1cd59a2f0d267592e4eaa46252525e0028456217","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long getTimeoutInMillis() {\n        return getTimeout(TimeUnit.MILLISECONDS);\n    }","id":11362,"modified_method":"public long getTimeoutInMillis() {\n        return m_timeoutInMillis;\n    }","commit_id":"1cd59a2f0d267592e4eaa46252525e0028456217","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public TimeoutTracker(Map parameters, int defaultRetry, int defaultTimeout) {\n        m_retry = ParameterMap.getKeyedInteger(parameters, \"retry\", defaultRetry);\n\n        // make sure the timeout is a least 10 millis\n        long m_timeoutInMillis = Math.max(10, ParameterMap.getKeyedInteger(parameters, \"timeout\", defaultTimeout));\n        \n        m_timeoutInNanos = TimeUnit.NANOSECONDS.convert(m_timeoutInMillis, TimeUnit.MILLISECONDS);\n\n        m_strictTimeouts = ParameterMap.getKeyedBoolean(parameters, \"strict-timeout\", false);\n        \n        resetAttemptStartTime();\n\n    }","id":11363,"modified_method":"public TimeoutTracker(Map parameters, int defaultRetry, int defaultTimeout) {\n        m_retry = ParameterMap.getKeyedInteger(parameters, \"retry\", defaultRetry);\n\n        // make sure the timeout is a least 10 millis\n        m_timeoutInMillis = Math.max(10L, ParameterMap.getKeyedInteger(parameters, \"timeout\", defaultTimeout));\n        m_timeoutInNanos = Math.max(10000000L, TimeUnit.NANOSECONDS.convert(m_timeoutInMillis, TimeUnit.MILLISECONDS));\n        m_timeoutInSeconds = Math.max(1L, TimeUnit.SECONDS.convert(m_timeoutInMillis, TimeUnit.SECONDS));\n\n\n        m_strictTimeouts = ParameterMap.getKeyedBoolean(parameters, \"strict-timeout\", false);\n        \n        resetAttemptStartTime();\n\n    }","commit_id":"1cd59a2f0d267592e4eaa46252525e0028456217","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long elapsedTimeNanos() {\n        assertStarted();\n        long nanoTime = System.nanoTime();\n        return nanoTime - m_attemptStartTimeNanos;\n    }","id":11364,"modified_method":"public long elapsedTimeNanos() {\n        long nanoTime = System.nanoTime();\n        assertStarted();\n        return nanoTime - m_attemptStartTimeNanos;\n    }","commit_id":"1cd59a2f0d267592e4eaa46252525e0028456217","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long getTimeoutInMillis() {\n        return getTimeout(TimeUnit.MILLISECONDS);\n    }","id":11365,"modified_method":"public long getTimeoutInMillis() {\n        return m_timeoutInMillis;\n    }","commit_id":"2fd64793444501aeba9ae5b2b9aacb018c4041d0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public double elapsedTime(TimeUnit unit) {\n        double nanos = elapsedTimeNanos();\n        double nanosPerUnit = TimeUnit.NANOSECONDS.convert(1, unit);\n        return nanos/nanosPerUnit;\n    }","id":11366,"modified_method":"public double elapsedTime(TimeUnit unit) {\n        return convertFromNanos(elapsedTimeNanos(), unit);\n    }","commit_id":"2fd64793444501aeba9ae5b2b9aacb018c4041d0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long getTimeoutInSeconds() {\n        return getTimeout(TimeUnit.SECONDS);\n    }","id":11367,"modified_method":"public long getTimeoutInSeconds() {\n        return m_timeoutInSeconds;\n    }","commit_id":"2fd64793444501aeba9ae5b2b9aacb018c4041d0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public TimeoutTracker(Map parameters, int defaultRetry, int defaultTimeout) {\n        m_retry = ParameterMap.getKeyedInteger(parameters, \"retry\", defaultRetry);\n\n        // make sure the timeout is a least 10 millis\n        long m_timeoutInMillis = Math.max(10, ParameterMap.getKeyedInteger(parameters, \"timeout\", defaultTimeout));\n        \n        m_timeoutInNanos = TimeUnit.NANOSECONDS.convert(m_timeoutInMillis, TimeUnit.MILLISECONDS);\n\n        m_strictTimeouts = ParameterMap.getKeyedBoolean(parameters, \"strict-timeout\", false);\n        \n        resetAttemptStartTime();\n\n    }","id":11368,"modified_method":"public TimeoutTracker(Map parameters, int defaultRetry, int defaultTimeout) {\n        m_retry = ParameterMap.getKeyedInteger(parameters, \"retry\", defaultRetry);\n\n        // make sure the timeout is a least 10 millis\n        m_timeoutInMillis = Math.max(10L, ParameterMap.getKeyedInteger(parameters, \"timeout\", defaultTimeout));\n        m_timeoutInNanos = Math.max(10000000L, TimeUnit.NANOSECONDS.convert(m_timeoutInMillis, TimeUnit.MILLISECONDS));\n        m_timeoutInSeconds = Math.max(1L, TimeUnit.SECONDS.convert(m_timeoutInMillis, TimeUnit.SECONDS));\n\n\n        m_strictTimeouts = ParameterMap.getKeyedBoolean(parameters, \"strict-timeout\", false);\n        \n        resetAttemptStartTime();\n\n    }","commit_id":"2fd64793444501aeba9ae5b2b9aacb018c4041d0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long elapsedTimeNanos() {\n        assertStarted();\n        long nanoTime = System.nanoTime();\n        return nanoTime - m_attemptStartTimeNanos;\n    }","id":11369,"modified_method":"public long elapsedTimeNanos() {\n        long nanoTime = System.nanoTime();\n        assertStarted();\n        return nanoTime - m_attemptStartTimeNanos;\n    }","commit_id":"2fd64793444501aeba9ae5b2b9aacb018c4041d0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public double elapsedTimeInMillis() {\n        return elapsedTime(TimeUnit.MILLISECONDS);\n    }","id":11370,"modified_method":"public double elapsedTimeInMillis() {\n        return convertFromNanos(elapsedTimeNanos(), TimeUnit.MILLISECONDS);\n    }","commit_id":"2fd64793444501aeba9ae5b2b9aacb018c4041d0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long elapsedTimeNanos() {\n        assertStarted();\n        long nanoTime = System.nanoTime();\n        return nanoTime - m_attemptStartTimeNanos;\n    }","id":11371,"modified_method":"public long elapsedTimeNanos() {\n        long nanoTime = System.nanoTime();\n        assertStarted();\n        return nanoTime - m_attemptStartTimeNanos;\n    }","commit_id":"46ab3fee037e7b2e0e3920d721eb49f650a2db7b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public double elapsedTime(TimeUnit unit) {\n        double nanos = elapsedTimeNanos();\n        double nanosPerUnit = TimeUnit.NANOSECONDS.convert(1, unit);\n        return nanos/nanosPerUnit;\n    }","id":11372,"modified_method":"public double elapsedTime(TimeUnit unit) {\n        return convertFromNanos(elapsedTimeNanos(), unit);\n    }","commit_id":"46ab3fee037e7b2e0e3920d721eb49f650a2db7b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public TimeoutTracker(Map parameters, int defaultRetry, int defaultTimeout) {\n        m_retry = ParameterMap.getKeyedInteger(parameters, \"retry\", defaultRetry);\n\n        // make sure the timeout is a least 10 millis\n        long m_timeoutInMillis = Math.max(10, ParameterMap.getKeyedInteger(parameters, \"timeout\", defaultTimeout));\n        \n        m_timeoutInNanos = TimeUnit.NANOSECONDS.convert(m_timeoutInMillis, TimeUnit.MILLISECONDS);\n\n        m_strictTimeouts = ParameterMap.getKeyedBoolean(parameters, \"strict-timeout\", false);\n        \n        resetAttemptStartTime();\n\n    }","id":11373,"modified_method":"public TimeoutTracker(Map parameters, int defaultRetry, int defaultTimeout) {\n        m_retry = ParameterMap.getKeyedInteger(parameters, \"retry\", defaultRetry);\n\n        // make sure the timeout is a least 10 millis\n        m_timeoutInMillis = Math.max(10L, ParameterMap.getKeyedInteger(parameters, \"timeout\", defaultTimeout));\n        m_timeoutInNanos = Math.max(10000000L, TimeUnit.NANOSECONDS.convert(m_timeoutInMillis, TimeUnit.MILLISECONDS));\n        m_timeoutInSeconds = Math.max(1L, TimeUnit.SECONDS.convert(m_timeoutInMillis, TimeUnit.SECONDS));\n\n\n        m_strictTimeouts = ParameterMap.getKeyedBoolean(parameters, \"strict-timeout\", false);\n        \n        resetAttemptStartTime();\n\n    }","commit_id":"46ab3fee037e7b2e0e3920d721eb49f650a2db7b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long getTimeoutInSeconds() {\n        return getTimeout(TimeUnit.SECONDS);\n    }","id":11374,"modified_method":"public long getTimeoutInSeconds() {\n        return m_timeoutInSeconds;\n    }","commit_id":"46ab3fee037e7b2e0e3920d721eb49f650a2db7b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public long getTimeoutInMillis() {\n        return getTimeout(TimeUnit.MILLISECONDS);\n    }","id":11375,"modified_method":"public long getTimeoutInMillis() {\n        return m_timeoutInMillis;\n    }","commit_id":"46ab3fee037e7b2e0e3920d721eb49f650a2db7b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public double elapsedTimeInMillis() {\n        return elapsedTime(TimeUnit.MILLISECONDS);\n    }","id":11376,"modified_method":"public double elapsedTimeInMillis() {\n        return convertFromNanos(elapsedTimeNanos(), TimeUnit.MILLISECONDS);\n    }","commit_id":"46ab3fee037e7b2e0e3920d721eb49f650a2db7b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static MessageElement createMessageElement(String name, Object value, boolean useExternalKey) throws Exception {\r\n\r\n\t\tMessageElement me =  new MessageElement(new QName(name),value); \r\n\t\tif(true) {\r\n\t\t\t// We use an external key\r\n\t\t\t// the structure should be like this :\r\n\t\t\t// object:externalId/lookupField\r\n\t\t\t// where\r\n\t\t\t// object is the type of the object\r\n\t\t\t// externalId is the name of the field in the object to resolve the value\r\n\t\t\t// lookupField is the name of the field in the current object to update (is the \"__r\" version)\r\n\r\n\t\t\tint indexOfType = name.indexOf(\":\");\r\n\t\t\tif(indexOfType>0) {\r\n\t\t\t\tString type = name.substring(0, indexOfType);\r\n\t\t\t\tString extIdName=null;\r\n\t\t\t\tString lookupField=null;\r\n\t\t\t\t\r\n\t\t\t\tString rest = name.substring(indexOfType+1, name.length());\r\n\t\t\t\tint indexOfExtId = rest.indexOf(\"/\");\r\n\t\t\t\tif(indexOfExtId>0) {\r\n\t\t\t\t\textIdName = rest.substring(0, indexOfExtId);\r\n\t\t\t\t\tlookupField = rest.substring(indexOfExtId+1, rest.length());\r\n\t\t\t\t}else {\r\n\t\t\t\t\textIdName=rest;\r\n\t\t\t\t\tlookupField=extIdName;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tme= createForeignKeyElement(type, lookupField ,extIdName, value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement e = me.getAsDOM();\r\n\t\te.removeAttribute(\"xsi:type\");\r\n\t\te.removeAttribute(\"xmlns:ns1\");\r\n\t\te.removeAttribute(\"xmlns:xsd\");\r\n\t\te.removeAttribute(\"xmlns:xsi\");\r\n\r\n\t\tme = new MessageElement(e);\r\n\t\treturn me;\r\n  }","id":11377,"modified_method":"public static MessageElement createMessageElement(String name, Object value, boolean useExternalKey) throws Exception {\r\n\r\n\t\tMessageElement me =  new MessageElement(new QName(name),value); \r\n\t\tif(useExternalKey) {\r\n\t\t\t// We use an external key\r\n\t\t\t// the structure should be like this :\r\n\t\t\t// object:externalId/lookupField\r\n\t\t\t// where\r\n\t\t\t// object is the type of the object\r\n\t\t\t// externalId is the name of the field in the object to resolve the value\r\n\t\t\t// lookupField is the name of the field in the current object to update (is the \"__r\" version)\r\n\r\n\t\t\tint indexOfType = name.indexOf(\":\");\r\n\t\t\tif(indexOfType>0) {\r\n\t\t\t\tString type = name.substring(0, indexOfType);\r\n\t\t\t\tString extIdName=null;\r\n\t\t\t\tString lookupField=null;\r\n\t\t\t\t\r\n\t\t\t\tString rest = name.substring(indexOfType+1, name.length());\r\n\t\t\t\tint indexOfExtId = rest.indexOf(\"/\");\r\n\t\t\t\tif(indexOfExtId>0) {\r\n\t\t\t\t\textIdName = rest.substring(0, indexOfExtId);\r\n\t\t\t\t\tlookupField = rest.substring(indexOfExtId+1, rest.length());\r\n\t\t\t\t}else {\r\n\t\t\t\t\textIdName=rest;\r\n\t\t\t\t\tlookupField=extIdName;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tme= createForeignKeyElement(type, lookupField ,extIdName, value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tElement e = me.getAsDOM();\r\n\t\te.removeAttribute(\"xsi:type\");\r\n\t\te.removeAttribute(\"xmlns:ns1\");\r\n\t\te.removeAttribute(\"xmlns:xsd\");\r\n\t\te.removeAttribute(\"xmlns:xsi\");\r\n\r\n\t\tme = new MessageElement(e);\r\n\t\treturn me;\r\n  }","commit_id":"1dff858e98eba97b6a3a536d91e65d6c95949a9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.deleteResult = data.connection.delete(data.deleteId);\r\n\t\t\tfor (int j = 0; j < data.deleteResult.length; j++) {\r\n\t\t\t\tif (data.deleteResult[j].isSuccess()) {\r\n\r\n\t\t\t\t\tputRow(data.outputRowMeta, data.outputBuffer[j]);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.log.LineRow\",String.valueOf(getLinesInput())));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.deleteResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceDelete.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.Found.Error\"));\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t//\tJust throw the first error...\r\n\t\t\t\t\t\t///\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.deleteResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceDelete.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceDelete.PassingRowToErrorStep\"));\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceDelete001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.deleteId = new String[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceDelete.FailedToDeleted\", e.getMessage()));\r\n\t\t} finally {\r\n\t\t\tif(data.deleteResult!=null) data.deleteResult=null;\r\n\t\t}\r\n\r\n\t}","id":11378,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.deleteResult = data.connection.delete(data.deleteId);\r\n\t\t\tfor (int j = 0; j < data.deleteResult.length; j++) {\r\n\t\t\t\tif (data.deleteResult[j].isSuccess()) {\r\n\r\n\t\t\t\t\tputRow(data.outputRowMeta, data.outputBuffer[j]);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.log.LineRow\",String.valueOf(getLinesInput())));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.deleteResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceDelete.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.Found.Error\"));\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t//\tJust throw the first error...\r\n\t\t\t\t\t\t///\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.deleteResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceDelete.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceDelete.PassingRowToErrorStep\"));\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceDelete001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.deleteId = new String[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceDelete.FailedToDeleted\", e.getMessage()));\r\n\t\t} finally {\r\n\t\t\tif(data.deleteResult!=null) data.deleteResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"1dff858e98eba97b6a3a536d91e65d6c95949a9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.WriteToSalesforce\", data.iBufferPos, meta.getBatchSizeInt()));\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\tArrayList<MessageElement> insertfields = new ArrayList<MessageElement>();\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tif(!data.inputRowMeta.isNull(rowData, data.fieldnrs[i])) {\r\n\t\t\t\t\t\tinsertfields.add(SalesforceConnection.createMessageElement( meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]], meta.getUseExternalId()[i]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.set_any((MessageElement[])insertfields.toArray(new MessageElement[insertfields.size()]));\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.CallingFlushBuffer\"));\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error\", e.getMessage()));\t\r\n\t\t}\r\n\t}","id":11379,"modified_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.WriteToSalesforce\", data.iBufferPos, meta.getBatchSizeInt()));\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\tArrayList<MessageElement> insertfields = new ArrayList<MessageElement>();\r\n\t\t\t\t// Reserve for empty fields\r\n\t\t\t\tArrayList<String> fieldsToNull = new ArrayList<String>();\r\n\t\t\t\t\r\n\t\t\t\t/*for ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tif(!data.inputRowMeta.isNull(rowData, data.fieldnrs[i])) {\r\n\t\t\t\t\t\tinsertfields.add(SalesforceConnection.createMessageElement( meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]], meta.getUseExternalId()[i]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// Add fields to insert\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tif(data.inputRowMeta.isNull(rowData, data.fieldnrs[i])) {\r\n\t\t\t\t\t\t// The value is null\r\n\t\t\t\t\t\t// We need to keep track of this field\r\n\t\t\t\t\t\tfieldsToNull.add(meta.getUpdateLookup()[i]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tinsertfields.add(SalesforceConnection.createMessageElement( meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]], meta.getUseExternalId()[i]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\t\t\t\t\r\n\t\t\t\tif(insertfields.size()>0) {\r\n\t\t\t\t\tsobjPass.set_any((MessageElement[])insertfields.toArray(new MessageElement[insertfields.size()]));\r\n\t\t\t\t}\r\n\t\t\t\tif(fieldsToNull.size()>0) {\r\n\t\t\t\t\t// Set Null to fields\r\n\t\t\t\t\tsobjPass.setFieldsToNull((String[])fieldsToNull.toArray(new String[fieldsToNull.size()]));\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.CallingFlushBuffer\"));\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error\", e.getMessage()));\t\r\n\t\t}\r\n\t}","commit_id":"1dff858e98eba97b6a3a536d91e65d6c95949a9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.insert(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was inserted\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceInsert.RowInserted\", id));\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.NewRow\", newRow[0]));\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.log.LineRow\", getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceInsert.ErrorFound\")); \r\n\t\t\t\t\t\t//for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only show the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.PassingRowToErrorStep\"));\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceInsert001\");\r\n\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.FailedToInsertObject\", e.getMessage()));\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","id":11380,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.insert(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was inserted\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceInsert.RowInserted\", id));\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.NewRow\", newRow[0]));\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.log.LineRow\", getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!getStepMeta().isDoingErrorHandling())\t{\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceInsert.ErrorFound\")); \r\n\r\n\t\t\t\t\t\t// Only show the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t String errorMessage=\"\";\r\n\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Simply add this row to the error row\r\n\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.PassingRowToErrorStep\"));\r\n\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceInsert001\");\r\n\t\t\t\t\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tif (!getStepMeta().isDoingErrorHandling())\t{\r\n\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.FailedToInsertObject\", e.getMessage()));\r\n\t\t\t}\r\n\t\t\t// Simply add this row to the error row\r\n\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\r\n\t\t\tfor(int i=0; i<data.iBufferPos; i++) {\r\n\t\t\t\t\tputError(data.inputRowMeta, data.outputBuffer[i], 1, e.getMessage(), null, \"SalesforceInsert002\");\r\n\t\t\t }\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"1dff858e98eba97b6a3a536d91e65d6c95949a9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(\"Called writeToSalesForce with \" + data.iBufferPos + \" out of \" + meta.getBatchSizeInt());\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\t// Reserve for empty fields\r\n\t\t\t\tArrayList<String> fieldsToNull = new ArrayList<String>();\r\n\t\t\t\tArrayList<MessageElement> updatefields = new ArrayList<MessageElement>();\r\n\t\t\t\t\r\n\t\t\t\t// Add fields to update\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tif(data.inputRowMeta.isNull(rowData, data.fieldnrs[i])) {\r\n\t\t\t\t\t\t// The value is null\r\n\t\t\t\t\t\t// We need to keep track of this field\r\n\t\t\t\t\t\tfieldsToNull.add(meta.getUpdateLookup()[i]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tupdatefields.add(SalesforceConnection.createMessageElement(meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]], meta.getUseExternalId()[i]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\t\t\t\tif(updatefields.size()>0) {\r\n\t\t\t\t\tsobjPass.set_any((MessageElement[])updatefields.toArray(new MessageElement[updatefields.size()]));\r\n\t\t\t\t}\r\n\t\t\t\tif(fieldsToNull.size()>0) {\r\n\t\t\t\t\t// Set Null to fields\r\n\t\t\t\t\tsobjPass.setFieldsToNull((String[])fieldsToNull.toArray(new String[fieldsToNull.size()]));\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(\"Calling flush buffer from writeToSalesForce\");\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed in writeToSalesForce: \"+ e.getMessage());\t\r\n\t\t}\r\n\t}","id":11381,"modified_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(\"Called writeToSalesForce with \" + data.iBufferPos + \" out of \" + meta.getBatchSizeInt());\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\t// Reserve for empty fields\r\n\t\t\t\tArrayList<String> fieldsToNull = new ArrayList<String>();\r\n\t\t\t\tArrayList<MessageElement> updatefields = new ArrayList<MessageElement>();\r\n\t\t\t\t\r\n\t\t\t\t// Add fields to update\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tboolean valueIsNull=data.inputRowMeta.isNull(rowData, data.fieldnrs[i]);\r\n\t\t\t\t\tif(valueIsNull){\r\n\t\t\t\t\t\t// The value is null\r\n\t\t\t\t\t\t// We need to keep track of this field\r\n\t\t\t\t\t\tfieldsToNull.add(meta.getUpdateLookup()[i]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tupdatefields.add(SalesforceConnection.createMessageElement(meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]], meta.getUseExternalId()[i]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\t\t\t\tif(updatefields.size()>0) {\r\n\t\t\t\t\tsobjPass.set_any((MessageElement[])updatefields.toArray(new MessageElement[updatefields.size()]));\r\n\t\t\t\t}\r\n\t\t\t\tif(fieldsToNull.size()>0) {\r\n\t\t\t\t\t// Set Null to fields\r\n\t\t\t\t\tsobjPass.setFieldsToNull((String[])fieldsToNull.toArray(new String[fieldsToNull.size()]));\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(\"Calling flush buffer from writeToSalesForce\");\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed in writeToSalesForce: \"+ e.getMessage());\t\r\n\t\t}\r\n\t}","commit_id":"1dff858e98eba97b6a3a536d91e65d6c95949a9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.update(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was updated\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Row updated with id: \" + id);\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesUpdated();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpdate.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpdate.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only send the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpdate.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpdate001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to update object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","id":11382,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.update(data.sfBuffer);\r\n\t\t\tint nr=data.saveResult.length;\r\n\t\t\tfor (int j = 0; j < nr; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was updated\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Row updated with id: \" + id);\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesUpdated();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpdate.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!getStepMeta().isDoingErrorHandling()) {\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\r\n\t\t\t\t\t\t// Only send the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpdate.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t        \r\n\t\t\t         String errorMessage = \"\";\r\n\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpdate.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Simply add this row to the error row\r\n\t\t\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tputError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpdate001\");\r\n\t\t\t\t\t\r\n\t\t\t\t} \r\n\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tif (!getStepMeta().isDoingErrorHandling()) {\r\n\t\t\t\tthrow new KettleException(\"\\nFailed to update object, error message was: \\n\"+ e.getMessage());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Simply add this row to the error row\r\n\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\r\n\t\t\tfor(int i=0; i<data.iBufferPos; i++) {\r\n\t\t\t\t\tputError(data.inputRowMeta, data.outputBuffer[i], 1, e.getMessage(), null, \"SalesforceUpdate002\");\r\n\t\t\t }\r\n\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"1dff858e98eba97b6a3a536d91e65d6c95949a9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.upsertResult = data.connection.upsert(meta.getUpsertField(), data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.upsertResult.length; j++) {\r\n\t\t\t\tif (data.upsertResult[j].isSuccess()) {\r\n\t\t\t\t\tString id=data.upsertResult[j].getId();\r\n\t\t\t\t\tif(data.upsertResult[j].isCreated()) {\r\n\t\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ObjectCreated\", id));\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tincrementLinesUpdated(); \r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ObjectUpdated\", id));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = data.inputRowMeta.size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.NewRow\", newRow[0]));\r\n\t\t\t\t\t\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.upsertResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ErrorFound\")); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only throw the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.salesforce.soap.partner.Error err = data.upsertResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException( BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceUpsert.PassingRowToErrorStep\"));\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpsert.FailedUpsert\", e.getMessage()));\r\n\t\t} finally {\r\n\t\t\tif(data.upsertResult!=null) data.upsertResult=null;\r\n\t\t}\r\n\r\n\t}","id":11383,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.upsertResult = data.connection.upsert(meta.getUpsertField(), data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.upsertResult.length; j++) {\r\n\t\t\t\tif (data.upsertResult[j].isSuccess()) {\r\n\t\t\t\t\tString id=data.upsertResult[j].getId();\r\n\t\t\t\t\tif(data.upsertResult[j].isCreated()) {\r\n\t\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ObjectCreated\", id));\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tincrementLinesUpdated(); \r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ObjectUpdated\", id));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = data.inputRowMeta.size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.NewRow\", newRow[0]));\r\n\t\t\t\t\t\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!getStepMeta().isDoingErrorHandling()) {\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ErrorFound\")); \r\n\t\r\n\t\t\t\t\t\t// Only throw the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t    com.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[0];\r\n\t\t\t\t\t\tthrow new KettleException( BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t}\r\n\t\t\r\n\t\t\t         String errorMessage = \"\";\r\n\t\t\t         for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\t// Simply add this row to the error row\r\n\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceUpsert.PassingRowToErrorStep\"));\r\n\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpsert001\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tif (!getStepMeta().isDoingErrorHandling()) {\r\n\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpsert.FailedUpsert\", e.getMessage()));\r\n\t\t\t}\r\n\t\t\t// Simply add this row to the error row\r\n\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\r\n\t\t\tfor(int i=0; i<data.iBufferPos; i++) {\r\n\t\t\t\t\tputError(data.inputRowMeta, data.outputBuffer[i], 1, e.getMessage(), null, \"SalesforceUpsert002\");\r\n\t\t\t }\r\n\t\t} finally {\r\n\t\t\tif(data.upsertResult!=null) data.upsertResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"1dff858e98eba97b6a3a536d91e65d6c95949a9e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(7 * _causes.size() + 4);\n\n\t\tsb.append(\"{BulkException.message = \");\n\t\tsb.append(super.getMessage());\n\t\tsb.append(\"\\n\");\n\n\t\tfor (Throwable cause : _causes) {\n\t\t\tsb.append(\"{\");\n\t\t\tsb.append(cause.getClass().getName());\n\t\t\tsb.append(\":\");\n\t\t\tsb.append(cause.getMessage());\n\t\t\tsb.append(\", \");\n\t\t\tsb.append(StackTraceUtil.getStackTrace(cause));\n\t\t\tsb.append(\"}\\n\");\n\t\t}\n\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","id":11384,"modified_method":"@Override\n\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(7 * _causes.size() + 4);\n\n\t\tsb.append(\"{message = \");\n\t\tsb.append(super.getMessage());\n\t\tsb.append(\"\\n\");\n\n\t\tfor (Throwable cause : _causes) {\n\t\t\tsb.append(\"{\");\n\t\t\tsb.append(ClassUtil.getClassName(cause));\n\t\t\tsb.append(\":\");\n\t\t\tsb.append(cause.getMessage());\n\t\t\tsb.append(\", \");\n\t\t\tsb.append(StackTraceUtil.getStackTrace(cause));\n\t\t\tsb.append(\"}\\n\");\n\t\t}\n\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"d972a4e51e36241a50007a749efdd56225779795","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void verifyResourcedModel(\n\t\t\tRole role, VerifiableResourcedModel verifiableResourcedModel)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\tint total = 0;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select count(*) from \" +\n\t\t\t\t\tverifiableResourcedModel.getTableName() +\n\t\t\t\t\t\t\" where companyId = \" + role.getCompanyId());\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\tif (rs.next()) {\n\t\t\t\ttotal = rs.getInt(1);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select \" + verifiableResourcedModel.getPrimaryKeyColumnName() +\n\t\t\t\t\t\", \" + verifiableResourcedModel.getUserIdColumnName() +\n\t\t\t\t\t\t\" from \" + verifiableResourcedModel.getTableName() +\n\t\t\t\t\t\t\t\" where companyId = \" + role.getCompanyId());\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\tfor (int i = 0; rs.next(); i++) {\n\t\t\t\tlong primKey = rs.getLong(\n\t\t\t\t\tverifiableResourcedModel.getPrimaryKeyColumnName());\n\t\t\t\tlong userId = rs.getLong(\n\t\t\t\t\tverifiableResourcedModel.getUserIdColumnName());\n\n\t\t\t\tverifyResourcedModel(\n\t\t\t\t\trole.getCompanyId(),\n\t\t\t\t\tverifiableResourcedModel.getModelName(), primKey, role,\n\t\t\t\t\tuserId, i, total);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","id":11385,"modified_method":"protected void verifyResourcedModel(\n\t\t\tRole role, VerifiableResourcedModel verifiableResourcedModel)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\tint total = 0;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select count(*) from \" +\n\t\t\t\t\tverifiableResourcedModel.getTableName() +\n\t\t\t\t\t\t\" where companyId = \" + role.getCompanyId());\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\tif (rs.next()) {\n\t\t\t\ttotal = rs.getInt(1);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tStringBundler sb = new StringBundler(8);\n\n\t\t\tsb.append(\"select \");\n\t\t\tsb.append(verifiableResourcedModel.getPrimaryKeyColumnName());\n\t\t\tsb.append(\", \");\n\t\t\tsb.append(verifiableResourcedModel.getUserIdColumnName());\n\t\t\tsb.append(\" from \");\n\t\t\tsb.append(verifiableResourcedModel.getTableName());\n\t\t\tsb.append(\" where companyId = \");\n\t\t\tsb.append(role.getCompanyId());\n\n\t\t\tps = con.prepareStatement(sb.toString());\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\tfor (int i = 0; rs.next(); i++) {\n\t\t\t\tlong primKey = rs.getLong(\n\t\t\t\t\tverifiableResourcedModel.getPrimaryKeyColumnName());\n\t\t\t\tlong userId = rs.getLong(\n\t\t\t\t\tverifiableResourcedModel.getUserIdColumnName());\n\n\t\t\t\tverifyResourcedModel(\n\t\t\t\t\trole.getCompanyId(),\n\t\t\t\t\tverifiableResourcedModel.getModelName(), primKey, role,\n\t\t\t\t\tuserId, i, total);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","commit_id":"d972a4e51e36241a50007a749efdd56225779795","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@ExpectedLogs(\n\t\texpectedLogs = {\n\t\t\t@ExpectedLog(\n\t\t\t\texpectedLog =\n\t\t\t\t\t\"Unable to process runnable: Table \",\n\t\t\t\texpectedType = ExpectedType.PREFIX\n\t\t\t)\n\t\t},\n\t\tlevel = \"ERROR\", loggerClass = ThrowableAwareRunnable.class\n\t)\n\t@Test(expected = BulkException.class)\n\tpublic void testVerifyParallelUnknownModelWithUnknownPKColumnName()\n\t\tthrows Exception {\n\n\t\tint modelCount = PropsValues.VERIFY_PROCESS_CONCURRENCY_THRESHOLD;\n\n\t\tVerifiableUUIDModel[] verifiableUUIDModels =\n\t\t\tnew VerifiableUUIDModel[modelCount];\n\n\t\tfor (int i = 0; i < modelCount; i++) {\n\t\t\tverifiableUUIDModels[i] = new VerifiableUUIDModel() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getPrimaryKeyColumnName() {\n\t\t\t\t\treturn _UNKNOWN;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getTableName() {\n\t\t\t\t\treturn _UNKNOWN;\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tVerifyUUID.verify(verifiableUUIDModels);\n\t}","id":11386,"modified_method":"@ExpectedLogs(\n\t\texpectedLogs = {\n\t\t\t@ExpectedLog(\n\t\t\t\texpectedLog = \"Unable to process runnable: Table \",\n\t\t\t\texpectedType = ExpectedType.PREFIX\n\t\t\t)\n\t\t},\n\t\tlevel = \"ERROR\", loggerClass = ThrowableAwareRunnable.class\n\t)\n\t@Test(expected = BulkException.class)\n\tpublic void testVerifyParallelUnknownModelWithUnknownPKColumnName()\n\t\tthrows Exception {\n\n\t\tVerifiableUUIDModel[] verifiableUUIDModels =\n\t\t\tnew VerifiableUUIDModel[\n\t\t\t\tPropsValues.VERIFY_PROCESS_CONCURRENCY_THRESHOLD];\n\n\t\tfor (int i = 0; i < PropsValues.VERIFY_PROCESS_CONCURRENCY_THRESHOLD;\n\t\t\t\ti++) {\n\n\t\t\tverifiableUUIDModels[i] = new VerifiableUUIDModel() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getPrimaryKeyColumnName() {\n\t\t\t\t\treturn _UNKNOWN;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getTableName() {\n\t\t\t\t\treturn _UNKNOWN;\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tVerifyUUID.verify(verifiableUUIDModels);\n\t}","commit_id":"d972a4e51e36241a50007a749efdd56225779795","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void updateUUID(\n\t\t\tVerifiableUUIDModel verifiableUUIDModel, long pk)\n\t\tthrows Exception {\n\n\t\tString uuid = PortalUUIDUtil.generate();\n\n\t\tDB db = DBFactoryUtil.getDB();\n\n\t\tdb.runSQL(\n\t\t\t\"update \" + verifiableUUIDModel.getTableName() + \" set uuid_ = '\" +\n\t\t\t\tuuid + \"' where \" +\n\t\t\t\tverifiableUUIDModel.getPrimaryKeyColumnName() + \" = \" + pk);\n\t}","id":11387,"modified_method":"protected static void updateUUID(\n\t\t\tVerifiableUUIDModel verifiableUUIDModel, long primKey)\n\t\tthrows Exception {\n\n\t\tDB db = DBFactoryUtil.getDB();\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(\"update \");\n\t\tsb.append(verifiableUUIDModel.getTableName());\n\t\tsb.append(\" set uuid_ = '\");\n\t\tsb.append(PortalUUIDUtil.generate());\n\t\tsb.append(\"' where \");\n\t\tsb.append(verifiableUUIDModel.getPrimaryKeyColumnName());\n\t\tsb.append(\" = \");\n\t\tsb.append(primKey);\n\n\t\tdb.runSQL(sb.toString());\n\t}","commit_id":"890e33c574abaec2831da40d35b9c4e975bdfb86","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void verifyModel(VerifiableUUIDModel verifiableUUIDModel)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tString tableName = verifiableUUIDModel.getTableName();\n\t\t\tString pkColumnName = verifiableUUIDModel.getPrimaryKeyColumnName();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select \" + pkColumnName + \" from \" + tableName +\n\t\t\t\t\t\" where uuid_ is null or uuid_ = ''\");\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong pk = rs.getLong(pkColumnName);\n\n\t\t\t\tupdateUUID(verifiableUUIDModel, pk);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","id":11388,"modified_method":"protected static void verifyUUID(VerifiableUUIDModel verifiableUUIDModel)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select \" + verifiableUUIDModel.getPrimaryKeyColumnName() +\n\t\t\t\t\t\" from \" + verifiableUUIDModel.getTableName() +\n\t\t\t\t\t\t\" where uuid_ is null or uuid_ = ''\");\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong pk = rs.getLong(pkColumnName);\n\n\t\t\t\tupdateUUID(verifiableUUIDModel, pk);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","commit_id":"890e33c574abaec2831da40d35b9c4e975bdfb86","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void verify(VerifiableUUIDModel ... verifiableUUIDModels)\n\t\tthrows Exception {\n\n\t\tfor (VerifiableUUIDModel verifiableUUIDModel : verifiableUUIDModels) {\n\t\t\tverifyModel(verifiableUUIDModel);\n\t\t}\n\t}","id":11389,"modified_method":"public static void verify(VerifiableUUIDModel ... verifiableUUIDModels)\n\t\tthrows Exception {\n\n\t\tfor (VerifiableUUIDModel verifiableUUIDModel : verifiableUUIDModels) {\n\t\t\tverifyUUID(verifiableUUIDModel);\n\t\t}\n\t}","commit_id":"890e33c574abaec2831da40d35b9c4e975bdfb86","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n    public void before() throws Exception {\n        String importBehavior = getImportBehavior();\n        SecurityProvider securityProvider;\n        if (importBehavior != null) {\n            Map<String, String> userParams = new HashMap<String, String>();\n            userParams.put(ProtectedItemImporter.PARAM_IMPORT_BEHAVIOR, getImportBehavior());\n            ConfigurationParameters config = ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams)));\n\n            securityProvider = new SecurityProviderImpl(config);\n        } else {\n            securityProvider = new SecurityProviderImpl();\n        }\n        Jcr jcr = new Jcr();\n        jcr.with(securityProvider);\n        repo = jcr.createRepository();\n        adminSession = repo.login(new SimpleCredentials(UserConstants.DEFAULT_ADMIN_ID, UserConstants.DEFAULT_ADMIN_ID.toCharArray()));\n\n        if (!(adminSession instanceof JackrabbitSession)) {\n            throw new NotExecutableException();\n        }\n        userMgr = ((JackrabbitSession) adminSession).getUserManager();\n\n        preTestAuthorizables.clear();\n        Iterator<Authorizable> iter = userMgr.findAuthorizables(\"rep:principalName\", null);\n        while (iter.hasNext()) {\n            String id = iter.next().getID();\n            preTestAuthorizables.add(id);\n        }\n\n        // make sure the target node for group-import exists\n        Authorizable administrators = userMgr.getAuthorizable(ADMINISTRATORS);\n        if (userMgr.getAuthorizable(ADMINISTRATORS) == null) {\n            userMgr.createGroup(new PrincipalImpl(ADMINISTRATORS));\n        } else if (!administrators.isGroup()) {\n            throw new NotExecutableException(\"Expected \" + administrators.getID() + \" to be a group.\");\n        }\n        adminSession.save();\n    }","id":11390,"modified_method":"@Before\n    public void before() throws Exception {\n        ConfigurationParameters config = getConfigurationParameters();\n        if (config != null) {\n            securityProvider = new SecurityProviderImpl(config);\n        } else {\n            securityProvider = new SecurityProviderImpl();\n        }\n        Jcr jcr = new Jcr();\n        jcr.with(securityProvider);\n        repo = jcr.createRepository();\n        adminSession = repo.login(new SimpleCredentials(UserConstants.DEFAULT_ADMIN_ID, UserConstants.DEFAULT_ADMIN_ID.toCharArray()));\n\n        if (!(adminSession instanceof JackrabbitSession)) {\n            throw new NotExecutableException();\n        }\n        userMgr = ((JackrabbitSession) adminSession).getUserManager();\n\n        preTestAuthorizables.clear();\n        Iterator<Authorizable> iter = userMgr.findAuthorizables(\"rep:principalName\", null);\n        while (iter.hasNext()) {\n            String id = iter.next().getID();\n            preTestAuthorizables.add(id);\n        }\n\n        // make sure the target node for group-import exists\n        Authorizable administrators = userMgr.getAuthorizable(ADMINISTRATORS);\n        if (userMgr.getAuthorizable(ADMINISTRATORS) == null) {\n            userMgr.createGroup(new PrincipalImpl(ADMINISTRATORS));\n        } else if (!administrators.isGroup()) {\n            throw new NotExecutableException(\"Expected \" + administrators.getID() + \" to be a group.\");\n        }\n        adminSession.save();\n    }","commit_id":"5b2deafd71fea1c77b63f873716c31cbe8be9ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void testAccessControlActionExecutionForGroup() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        //a1.setGroupPrivilegeNames(Privilege.JCR_READ);\n\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>gPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        try {\n            doImport(GROUPPATH, xml);\n\n            Authorizable a = userMgr.getAuthorizable(\"g\");\n            assertNotNull(a);\n            assertTrue(a.isGroup());\n\n            AccessControlManager acMgr = jrSession.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n            assertNotNull(policies);\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof AccessControlList);\n\n            AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(1, aces.length);\n            assertEquals(\"gPrincipal\", aces[0].getPrincipal().getName());\n\n        } finally {\n            jrSession.refresh(false);\n        }\n    }","id":11391,"modified_method":"@Test\n    public void testAccessControlActionExecutionForGroup() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(Collections.singletonMap(AccessControlAction.GROUP_PRIVILEGE_NAMES, new String[] {Privilege.JCR_READ})));\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>gPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(GROUPPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"g\");\n        assertNotNull(a);\n        assertTrue(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"gPrincipal\", aces[0].getPrincipal().getName());\n    }","commit_id":"5b2deafd71fea1c77b63f873716c31cbe8be9ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void setAuthorizableActions(AuthorizableAction action) {\n        // TODO clarify how to test AuthorizableActions in Oak\n        // userMgr.setAuthorizableActions(new AuthorizableAction[] {testAction});\n    }","id":11392,"modified_method":"private void setAuthorizableActions(AuthorizableAction action) {\n        actionProvider.addAction(action);\n    }","commit_id":"5b2deafd71fea1c77b63f873716c31cbe8be9ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void testActionExecutionForUser() throws Exception {\n        TestAction testAction = new TestAction();\n        setAuthorizableActions(testAction);\n\n        // import user\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>pw<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        try {\n            doImport(USERPATH, xml);\n            assertEquals(testAction.id, \"t\");\n            assertEquals(testAction.pw, \"pw\");\n        } finally {\n            jrSession.refresh(false);\n        }\n    }","id":11393,"modified_method":"@Test\n    public void testActionExecutionForUser() throws Exception {\n        TestAction testAction = new TestAction();\n        setAuthorizableActions(testAction);\n\n        // import user\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>pw<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(USERPATH, xml);\n        assertEquals(testAction.id, \"t\");\n        assertEquals(testAction.pw, \"pw\");\n    }","commit_id":"5b2deafd71fea1c77b63f873716c31cbe8be9ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void testAccessControlActionExecutionForUser() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        //a1.setUserPrivilegeNames(Privilege.JCR_ALL);\n\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        try {\n            doImport(USERPATH, xml);\n\n            Authorizable a = userMgr.getAuthorizable(\"t\");\n            assertNotNull(a);\n            assertFalse(a.isGroup());\n\n            AccessControlManager acMgr = jrSession.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n            assertNotNull(policies);\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof AccessControlList);\n\n            AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(1, aces.length);\n            assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n\n        } finally {\n            jrSession.refresh(false);\n        }\n    }","id":11394,"modified_method":"@Test\n    public void testAccessControlActionExecutionForUser() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(Collections.singletonMap(AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {Privilege.JCR_ALL})));\n\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(USERPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"t\");\n        assertNotNull(a);\n        assertFalse(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n    }","commit_id":"5b2deafd71fea1c77b63f873716c31cbe8be9ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void testAccessControlActionExecutionForUser2() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        //a1.setUserPrivilegeNames(Privilege.JCR_ALL);\n\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        try {\n            doImport(USERPATH, xml);\n\n            Authorizable a = userMgr.getAuthorizable(\"t\");\n            assertNotNull(a);\n            assertFalse(a.isGroup());\n\n            AccessControlManager acMgr = jrSession.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n            assertNotNull(policies);\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof AccessControlList);\n\n            AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(1, aces.length);\n            assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n\n        } finally {\n            jrSession.refresh(false);\n        }\n    }","id":11395,"modified_method":"@Test\n    public void testAccessControlActionExecutionForUser2() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(Collections.singletonMap(AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {Privilege.JCR_ALL})));\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(USERPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"t\");\n        assertNotNull(a);\n        assertFalse(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n    }","commit_id":"5b2deafd71fea1c77b63f873716c31cbe8be9ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void testActionExecutionForGroup() throws Exception {\n        TestAction testAction = new TestAction();\n        setAuthorizableActions(testAction);\n\n        // import group\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>gPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        try {\n            doImport(GROUPPATH, xml);\n            assertEquals(testAction.id, \"g\");\n            assertNull(testAction.pw);\n        } finally {\n            jrSession.refresh(false);\n        }\n    }","id":11396,"modified_method":"@Test\n    public void testActionExecutionForGroup() throws Exception {\n        TestAction testAction = new TestAction();\n        setAuthorizableActions(testAction);\n\n        // import group\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>gPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(GROUPPATH, xml);\n        assertEquals(testAction.id, \"g\");\n        assertNull(testAction.pw);\n    }","commit_id":"5b2deafd71fea1c77b63f873716c31cbe8be9ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Regexp_3050481019132371337(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp\", null);\n            SPropertyOperations.set(literal, \"code\", pattern.substring(2));\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP0.matcher(pattern).matches();\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\", null);\n            SPropertyOperations.set(literal, \"text\", pattern);\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP1.matcher(pattern).matches();\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"string literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\", null);\n            SPropertyOperations.set(literal, \"text\", pattern.substring(1));\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP2.matcher(pattern).matches();\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"string literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","id":11397,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Regexp_3050481019132371337(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp\", null);\n            SPropertyOperations.set(literal, \"code\", pattern.substring(2));\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP0.matcher(pattern).matches();\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode node = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp\", _context.getCurrentTargetNode());\n            SPropertyOperations.set(node, \"name\", (pattern.endsWith(\":\") ?\n              pattern.substring(1, pattern.length() - 1) :\n              pattern.substring(1)\n            ));\n            return node;\n          }\n\n          public String getMatchingText(String pattern) {\n            if (!(_PrecompiledPatterns.REGEXP1.matcher(pattern).matches())) {\n              return \"(name:\";\n            }\n            String s = pattern;\n            if (!(s.endsWith(\":\"))) {\n              s += \":\";\n            }\n            return s;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\", null);\n            SPropertyOperations.set(literal, \"text\", pattern);\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP2.matcher(pattern).matches();\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"string literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp\", null);\n            SPropertyOperations.set(literal, \"text\", pattern.substring(1));\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP3.matcher(pattern).matches();\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"string literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"8974abe53ad21f9346577fde55ffdc307b6eb847","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_SymbolClassPart_3551998361337009320(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart\", null);\n            SPropertyOperations.set(literal, \"character\", (pattern.startsWith(\"\\\\\") ?\n              pattern.substring(1) :\n              pattern\n            ));\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP3.matcher(pattern).matches();\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","id":11398,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_SymbolClassPart_3551998361337009320(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode literal = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart\", null);\n            SPropertyOperations.set(literal, \"character\", (pattern.startsWith(\"\\\\\") ?\n              pattern.substring(1) :\n              pattern\n            ));\n            return literal;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            return _PrecompiledPatterns.REGEXP4.matcher(pattern).matches();\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"8974abe53ad21f9346577fde55ffdc307b6eb847","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void test_timezone() throws Exception {\n    DateTimeZone mskid = DateTimeZone.forID(\"Europe/Moscow\");\n    Assert.assertEquals(DateTimeZone.forID(\"Europe/Moscow\"), mskid);\n    Assert.assertEquals(DateTimeZone.forID(\"Europe/Moscow\"), mskid);\n    DateTimeZone mskoffset = DateTimeZone.forOffsetMillis(10800000);\n    Assert.assertEquals(DateTimeZone.forOffsetMillis(10800000), mskoffset);\n  }","id":11399,"modified_method":"public void test_timezone() throws Exception {\n    DateTimeZone mskid = DateTimeZone.forID(\"Europe/Moscow\");\n    DateTime dtt = DateTimeOperations.convert(System.currentTimeMillis(), mskid);\n    Assert.assertEquals(DateTimeZone.forID(\"Europe/Moscow\"), mskid);\n    Assert.assertEquals(DateTimeZone.forID(\"Europe/Moscow\"), mskid);\n    DateTimeZone mskoffset = DateTimeZone.forOffsetMillis(10800000);\n    Assert.assertEquals(DateTimeZone.forOffsetMillis(10800000), mskoffset);\n  }","commit_id":"568d25e12d8baed6f38f3a7f8bd62fe1fc63bb13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_4555537781927653006(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode conceptToAdd = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.dates.structure.DefaultTimeZoneConstant\");\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(defaultActions));\n    }\n    {\n      SNode conceptToAdd = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.dates.structure.UTCTimeZoneConstant\");\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(defaultActions));\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.dates.structure.TimeZoneIDExpression\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        Calculable calc = new Calculable() {\n          public Object calculate() {\n            DateTimeZone.getAvailableIDs();\n            List<String> result = ListSequence.fromList(new ArrayList<String>());\n            for (Object id : DateTimeZone.getAvailableIDs()) {\n              ListSequence.fromList(result).addElement(String.valueOf(id));\n            }\n            return result;\n          }\n        };\n        Iterable<String> queryResult = (Iterable)calc.calculate();\n        if (queryResult != null) {\n          for (final String item : queryResult) {\n            ListSequence.fromList(result).addElement(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n              public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n                SNode tz = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.dates.structure.TimeZoneIDExpression\", null);\n                SPropertyOperations.set(tz, \"timezone_id\", \"\" + ((item)));\n                return tz;\n              }\n\n              public String getMatchingText(String pattern) {\n                return (item);\n              }\n\n              public String getVisibleMatchingText(String pattern) {\n                return this.getMatchingText(pattern);\n              }\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }","id":11400,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_4555537781927653006(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.dates.structure.TimeZoneIDExpression\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        Calculable calc = new Calculable() {\n          public Object calculate() {\n            DateTimeZone.getAvailableIDs();\n            List<String> result = ListSequence.fromList(new ArrayList<String>());\n            for (Object id : DateTimeZone.getAvailableIDs()) {\n              ListSequence.fromList(result).addElement(String.valueOf(id));\n            }\n            return result;\n          }\n        };\n        Iterable<String> queryResult = (Iterable)calc.calculate();\n        if (queryResult != null) {\n          for (final String item : queryResult) {\n            ListSequence.fromList(result).addElement(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n              public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n                SNode tz = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.dates.structure.TimeZoneIDExpression\", null);\n                SPropertyOperations.set(tz, \"timezone_id\", \"\" + ((item)));\n                return tz;\n              }\n\n              public String getMatchingText(String pattern) {\n                return (item);\n              }\n\n              public String getVisibleMatchingText(String pattern) {\n                return this.getMatchingText(pattern);\n              }\n            });\n          }\n        }\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.dates.structure.TimeZoneOffsetExpression\");\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode tz = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.dates.structure.TimeZoneOffsetExpression\", null);\n            SPropertyOperations.set(tz, \"offsetmillis\", \"\" + (0));\n            try {\n              DateTime dt = DateTimeFormat.forPattern(\"Z\").withOffsetParsed().parseDateTime(pattern);\n              if (dt.withZoneRetainFields(DateTimeZone.UTC).getMillis() == 0L) {\n                SPropertyOperations.set(tz, \"offsetmillis\", \"\" + (dt.getZone().getStandardOffset(0L)));\n              }\n            } catch (RuntimeException ignored) {\n            }\n            return tz;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            if (strictly) {\n              return _PrecompiledPatterns.REGEXP0.matcher(pattern).matches();\n            } else {\n              return _PrecompiledPatterns.REGEXP1.matcher(pattern).matches();\n            }\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"offset time zone\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"568d25e12d8baed6f38f3a7f8bd62fe1fc63bb13","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public LogByteSizeMergePolicy newMergePolicy() {\n        CustomLogByteSizeMergePolicy mergePolicy;\n        if (asyncMerge) {\n            mergePolicy = new EnableMergeLogByteSizeMergePolicy(this);\n        } else {\n            mergePolicy = new CustomLogByteSizeMergePolicy(this);\n        }\n        mergePolicy.setMinMergeMB(minMergeSize.mbFrac());\n        mergePolicy.setMaxMergeMB(maxMergeSize.mbFrac());\n        mergePolicy.setMergeFactor(mergeFactor);\n        mergePolicy.setMaxMergeDocs(maxMergeDocs);\n        mergePolicy.setCalibrateSizeByDeletes(calibrateSizeByDeletes);\n        mergePolicy.setUseCompoundFile(compoundFormat);\n\n        policies.add(mergePolicy);\n        return mergePolicy;\n    }","id":11401,"modified_method":"@Override\n    public LogByteSizeMergePolicy newMergePolicy() {\n        CustomLogByteSizeMergePolicy mergePolicy;\n        if (asyncMerge) {\n            mergePolicy = new EnableMergeLogByteSizeMergePolicy(this);\n        } else {\n            mergePolicy = new CustomLogByteSizeMergePolicy(this);\n        }\n        mergePolicy.setMinMergeMB(minMergeSize.mbFrac());\n        mergePolicy.setMaxMergeMB(maxMergeSize.mbFrac());\n        mergePolicy.setMergeFactor(mergeFactor);\n        mergePolicy.setMaxMergeDocs(maxMergeDocs);\n        mergePolicy.setCalibrateSizeByDeletes(calibrateSizeByDeletes);\n        mergePolicy.setUseCompoundFile(compoundFormat);\n        mergePolicy.setNoCFSRatio(noCFSRatio);\n\n        policies.add(mergePolicy);\n        return mergePolicy;\n    }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            ByteSizeValue minMergeSize = settings.getAsBytesSize(INDEX_MERGE_POLICY_MIN_MERGE_SIZE, LogByteSizeMergePolicyProvider.this.minMergeSize);\n            if (!minMergeSize.equals(LogByteSizeMergePolicyProvider.this.minMergeSize)) {\n                logger.info(\"updating min_merge_size from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.minMergeSize, minMergeSize);\n                LogByteSizeMergePolicyProvider.this.minMergeSize = minMergeSize;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMinMergeMB(minMergeSize.mbFrac());\n                }\n            }\n\n            ByteSizeValue maxMergeSize = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGE_SIZE, LogByteSizeMergePolicyProvider.this.maxMergeSize);\n            if (!maxMergeSize.equals(LogByteSizeMergePolicyProvider.this.maxMergeSize)) {\n                logger.info(\"updating max_merge_size from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.maxMergeSize, maxMergeSize);\n                LogByteSizeMergePolicyProvider.this.maxMergeSize = maxMergeSize;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMaxMergeMB(maxMergeSize.mbFrac());\n                }\n            }\n\n            int maxMergeDocs = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_DOCS, LogByteSizeMergePolicyProvider.this.maxMergeDocs);\n            if (maxMergeDocs != LogByteSizeMergePolicyProvider.this.maxMergeDocs) {\n                logger.info(\"updating max_merge_docs from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.maxMergeDocs, maxMergeDocs);\n                LogByteSizeMergePolicyProvider.this.maxMergeDocs = maxMergeDocs;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMaxMergeDocs(maxMergeDocs);\n                }\n            }\n\n            int mergeFactor = settings.getAsInt(INDEX_MERGE_POLICY_MERGE_FACTOR, LogByteSizeMergePolicyProvider.this.mergeFactor);\n            if (mergeFactor != LogByteSizeMergePolicyProvider.this.mergeFactor) {\n                logger.info(\"updating merge_factor from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.mergeFactor, mergeFactor);\n                LogByteSizeMergePolicyProvider.this.mergeFactor = mergeFactor;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMergeFactor(mergeFactor);\n                }\n            }\n\n            boolean compoundFormat = settings.getAsBoolean(INDEX_COMPOUND_FORMAT, LogByteSizeMergePolicyProvider.this.compoundFormat);\n            if (compoundFormat != LogByteSizeMergePolicyProvider.this.compoundFormat) {\n                logger.info(\"updating index.compound_format from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.compoundFormat, compoundFormat);\n                LogByteSizeMergePolicyProvider.this.compoundFormat = compoundFormat;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setUseCompoundFile(compoundFormat);\n                }\n            }\n        }","id":11402,"modified_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            ByteSizeValue minMergeSize = settings.getAsBytesSize(INDEX_MERGE_POLICY_MIN_MERGE_SIZE, LogByteSizeMergePolicyProvider.this.minMergeSize);\n            if (!minMergeSize.equals(LogByteSizeMergePolicyProvider.this.minMergeSize)) {\n                logger.info(\"updating min_merge_size from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.minMergeSize, minMergeSize);\n                LogByteSizeMergePolicyProvider.this.minMergeSize = minMergeSize;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMinMergeMB(minMergeSize.mbFrac());\n                }\n            }\n\n            ByteSizeValue maxMergeSize = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGE_SIZE, LogByteSizeMergePolicyProvider.this.maxMergeSize);\n            if (!maxMergeSize.equals(LogByteSizeMergePolicyProvider.this.maxMergeSize)) {\n                logger.info(\"updating max_merge_size from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.maxMergeSize, maxMergeSize);\n                LogByteSizeMergePolicyProvider.this.maxMergeSize = maxMergeSize;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMaxMergeMB(maxMergeSize.mbFrac());\n                }\n            }\n\n            int maxMergeDocs = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_DOCS, LogByteSizeMergePolicyProvider.this.maxMergeDocs);\n            if (maxMergeDocs != LogByteSizeMergePolicyProvider.this.maxMergeDocs) {\n                logger.info(\"updating max_merge_docs from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.maxMergeDocs, maxMergeDocs);\n                LogByteSizeMergePolicyProvider.this.maxMergeDocs = maxMergeDocs;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMaxMergeDocs(maxMergeDocs);\n                }\n            }\n\n            int mergeFactor = settings.getAsInt(INDEX_MERGE_POLICY_MERGE_FACTOR, LogByteSizeMergePolicyProvider.this.mergeFactor);\n            if (mergeFactor != LogByteSizeMergePolicyProvider.this.mergeFactor) {\n                logger.info(\"updating merge_factor from [{}] to [{}]\", LogByteSizeMergePolicyProvider.this.mergeFactor, mergeFactor);\n                LogByteSizeMergePolicyProvider.this.mergeFactor = mergeFactor;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setMergeFactor(mergeFactor);\n                }\n            }\n            \n            final double noCFSRatio = parseNoCFSRatio(settings.get(INDEX_COMPOUND_FORMAT, Double.toString(LogByteSizeMergePolicyProvider.this.noCFSRatio)));\n            final boolean compoundFormat = noCFSRatio != 0.0;\n            if (noCFSRatio != LogByteSizeMergePolicyProvider.this.noCFSRatio) {\n                logger.info(\"updating index.compound_format from [{}] to [{}]\", formatNoCFSRatio(LogByteSizeMergePolicyProvider.this.noCFSRatio), formatNoCFSRatio(noCFSRatio));\n                LogByteSizeMergePolicyProvider.this.compoundFormat = compoundFormat;\n                LogByteSizeMergePolicyProvider.this.noCFSRatio = noCFSRatio;\n                for (CustomLogByteSizeMergePolicy policy : policies) {\n                    policy.setNoCFSRatio(noCFSRatio);\n                    policy.setUseCompoundFile(compoundFormat);\n                }\n            }\n\n        }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public LogByteSizeMergePolicyProvider(Store store, IndexSettingsService indexSettingsService) {\n        super(store.shardId(), store.indexSettings());\n        Preconditions.checkNotNull(store, \"Store must be provided to merge policy\");\n        this.indexSettingsService = indexSettingsService;\n\n        this.compoundFormat = indexSettings.getAsBoolean(INDEX_COMPOUND_FORMAT, store.suggestUseCompoundFile());\n        this.minMergeSize = componentSettings.getAsBytesSize(\"min_merge_size\", new ByteSizeValue((long) (LogByteSizeMergePolicy.DEFAULT_MIN_MERGE_MB * 1024 * 1024), ByteSizeUnit.BYTES));\n        this.maxMergeSize = componentSettings.getAsBytesSize(\"max_merge_size\", new ByteSizeValue((long) LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB, ByteSizeUnit.MB));\n        this.mergeFactor = componentSettings.getAsInt(\"merge_factor\", LogByteSizeMergePolicy.DEFAULT_MERGE_FACTOR);\n        this.maxMergeDocs = componentSettings.getAsInt(\"max_merge_docs\", LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_DOCS);\n        this.calibrateSizeByDeletes = componentSettings.getAsBoolean(\"calibrate_size_by_deletes\", true);\n        this.asyncMerge = indexSettings.getAsBoolean(\"index.merge.async\", true);\n        logger.debug(\"using [log_bytes_size] merge policy with merge_factor[{}], min_merge_size[{}], max_merge_size[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}], async_merge[{}]\",\n                mergeFactor, minMergeSize, maxMergeSize, maxMergeDocs, calibrateSizeByDeletes, asyncMerge);\n\n        indexSettingsService.addListener(applySettings);\n    }","id":11403,"modified_method":"@Inject\n    public LogByteSizeMergePolicyProvider(Store store, IndexSettingsService indexSettingsService) {\n        super(store);\n        Preconditions.checkNotNull(store, \"Store must be provided to merge policy\");\n        this.indexSettingsService = indexSettingsService;\n        this.minMergeSize = componentSettings.getAsBytesSize(\"min_merge_size\", new ByteSizeValue((long) (LogByteSizeMergePolicy.DEFAULT_MIN_MERGE_MB * 1024 * 1024), ByteSizeUnit.BYTES));\n        this.maxMergeSize = componentSettings.getAsBytesSize(\"max_merge_size\", new ByteSizeValue((long) LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB, ByteSizeUnit.MB));\n        this.mergeFactor = componentSettings.getAsInt(\"merge_factor\", LogByteSizeMergePolicy.DEFAULT_MERGE_FACTOR);\n        this.maxMergeDocs = componentSettings.getAsInt(\"max_merge_docs\", LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_DOCS);\n        this.calibrateSizeByDeletes = componentSettings.getAsBoolean(\"calibrate_size_by_deletes\", true);\n        this.asyncMerge = indexSettings.getAsBoolean(\"index.merge.async\", true);\n        logger.debug(\"using [log_bytes_size] merge policy with merge_factor[{}], min_merge_size[{}], max_merge_size[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}], async_merge[{}]\",\n                mergeFactor, minMergeSize, maxMergeSize, maxMergeDocs, calibrateSizeByDeletes, asyncMerge);\n\n        indexSettingsService.addListener(applySettings);\n    }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public LogDocMergePolicyProvider(Store store, IndexSettingsService indexSettingsService) {\n        super(store.shardId(), store.indexSettings());\n        Preconditions.checkNotNull(store, \"Store must be provided to merge policy\");\n        this.indexSettingsService = indexSettingsService;\n\n        this.compoundFormat = indexSettings.getAsBoolean(INDEX_COMPOUND_FORMAT, store.suggestUseCompoundFile());\n        this.minMergeDocs = componentSettings.getAsInt(\"min_merge_docs\", LogDocMergePolicy.DEFAULT_MIN_MERGE_DOCS);\n        this.maxMergeDocs = componentSettings.getAsInt(\"max_merge_docs\", LogDocMergePolicy.DEFAULT_MAX_MERGE_DOCS);\n        this.mergeFactor = componentSettings.getAsInt(\"merge_factor\", LogDocMergePolicy.DEFAULT_MERGE_FACTOR);\n        this.calibrateSizeByDeletes = componentSettings.getAsBoolean(\"calibrate_size_by_deletes\", true);\n        this.asyncMerge = indexSettings.getAsBoolean(\"index.merge.async\", true);\n        logger.debug(\"using [log_doc] merge policy with merge_factor[{}], min_merge_docs[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}], async_merge[{}]\",\n                mergeFactor, minMergeDocs, maxMergeDocs, calibrateSizeByDeletes, asyncMerge);\n\n        indexSettingsService.addListener(applySettings);\n    }","id":11404,"modified_method":"@Inject\n    public LogDocMergePolicyProvider(Store store, IndexSettingsService indexSettingsService) {\n        super(store);\n        Preconditions.checkNotNull(store, \"Store must be provided to merge policy\");\n        this.indexSettingsService = indexSettingsService;\n\n        this.minMergeDocs = componentSettings.getAsInt(\"min_merge_docs\", LogDocMergePolicy.DEFAULT_MIN_MERGE_DOCS);\n        this.maxMergeDocs = componentSettings.getAsInt(\"max_merge_docs\", LogDocMergePolicy.DEFAULT_MAX_MERGE_DOCS);\n        this.mergeFactor = componentSettings.getAsInt(\"merge_factor\", LogDocMergePolicy.DEFAULT_MERGE_FACTOR);\n        this.calibrateSizeByDeletes = componentSettings.getAsBoolean(\"calibrate_size_by_deletes\", true);\n        this.asyncMerge = indexSettings.getAsBoolean(\"index.merge.async\", true);\n        logger.debug(\"using [log_doc] merge policy with merge_factor[{}], min_merge_docs[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}], async_merge[{}]\",\n                mergeFactor, minMergeDocs, maxMergeDocs, calibrateSizeByDeletes, asyncMerge);\n\n        indexSettingsService.addListener(applySettings);\n    }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public LogDocMergePolicy newMergePolicy() {\n        CustomLogDocMergePolicy mergePolicy;\n        if (asyncMerge) {\n            mergePolicy = new EnableMergeLogDocMergePolicy(this);\n        } else {\n            mergePolicy = new CustomLogDocMergePolicy(this);\n        }\n        mergePolicy.setMinMergeDocs(minMergeDocs);\n        mergePolicy.setMaxMergeDocs(maxMergeDocs);\n        mergePolicy.setMergeFactor(mergeFactor);\n        mergePolicy.setCalibrateSizeByDeletes(calibrateSizeByDeletes);\n        mergePolicy.setUseCompoundFile(compoundFormat);\n        policies.add(mergePolicy);\n        return mergePolicy;\n    }","id":11405,"modified_method":"@Override\n    public LogDocMergePolicy newMergePolicy() {\n        CustomLogDocMergePolicy mergePolicy;\n        if (asyncMerge) {\n            mergePolicy = new EnableMergeLogDocMergePolicy(this);\n        } else {\n            mergePolicy = new CustomLogDocMergePolicy(this);\n        }\n        mergePolicy.setMinMergeDocs(minMergeDocs);\n        mergePolicy.setMaxMergeDocs(maxMergeDocs);\n        mergePolicy.setMergeFactor(mergeFactor);\n        mergePolicy.setCalibrateSizeByDeletes(calibrateSizeByDeletes);\n        mergePolicy.setUseCompoundFile(compoundFormat);\n        mergePolicy.setNoCFSRatio(noCFSRatio);\n        policies.add(mergePolicy);\n        return mergePolicy;\n    }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            int minMergeDocs = settings.getAsInt(INDEX_MERGE_POLICY_MIN_MERGE_DOCS, LogDocMergePolicyProvider.this.minMergeDocs);\n            if (minMergeDocs != LogDocMergePolicyProvider.this.minMergeDocs) {\n                logger.info(\"updating min_merge_docs from [{}] to [{}]\", LogDocMergePolicyProvider.this.minMergeDocs, minMergeDocs);\n                LogDocMergePolicyProvider.this.minMergeDocs = minMergeDocs;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setMinMergeDocs(minMergeDocs);\n                }\n            }\n\n            int maxMergeDocs = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_DOCS, LogDocMergePolicyProvider.this.maxMergeDocs);\n            if (maxMergeDocs != LogDocMergePolicyProvider.this.maxMergeDocs) {\n                logger.info(\"updating max_merge_docs from [{}] to [{}]\", LogDocMergePolicyProvider.this.maxMergeDocs, maxMergeDocs);\n                LogDocMergePolicyProvider.this.maxMergeDocs = maxMergeDocs;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setMaxMergeDocs(maxMergeDocs);\n                }\n            }\n\n            int mergeFactor = settings.getAsInt(INDEX_MERGE_POLICY_MERGE_FACTOR, LogDocMergePolicyProvider.this.mergeFactor);\n            if (mergeFactor != LogDocMergePolicyProvider.this.mergeFactor) {\n                logger.info(\"updating merge_factor from [{}] to [{}]\", LogDocMergePolicyProvider.this.mergeFactor, mergeFactor);\n                LogDocMergePolicyProvider.this.mergeFactor = mergeFactor;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setMergeFactor(mergeFactor);\n                }\n            }\n\n            boolean compoundFormat = settings.getAsBoolean(INDEX_COMPOUND_FORMAT, LogDocMergePolicyProvider.this.compoundFormat);\n            if (compoundFormat != LogDocMergePolicyProvider.this.compoundFormat) {\n                logger.info(\"updating index.compound_format from [{}] to [{}]\", LogDocMergePolicyProvider.this.compoundFormat, compoundFormat);\n                LogDocMergePolicyProvider.this.compoundFormat = compoundFormat;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setUseCompoundFile(compoundFormat);\n                }\n            }\n        }","id":11406,"modified_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            int minMergeDocs = settings.getAsInt(INDEX_MERGE_POLICY_MIN_MERGE_DOCS, LogDocMergePolicyProvider.this.minMergeDocs);\n            if (minMergeDocs != LogDocMergePolicyProvider.this.minMergeDocs) {\n                logger.info(\"updating min_merge_docs from [{}] to [{}]\", LogDocMergePolicyProvider.this.minMergeDocs, minMergeDocs);\n                LogDocMergePolicyProvider.this.minMergeDocs = minMergeDocs;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setMinMergeDocs(minMergeDocs);\n                }\n            }\n\n            int maxMergeDocs = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_DOCS, LogDocMergePolicyProvider.this.maxMergeDocs);\n            if (maxMergeDocs != LogDocMergePolicyProvider.this.maxMergeDocs) {\n                logger.info(\"updating max_merge_docs from [{}] to [{}]\", LogDocMergePolicyProvider.this.maxMergeDocs, maxMergeDocs);\n                LogDocMergePolicyProvider.this.maxMergeDocs = maxMergeDocs;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setMaxMergeDocs(maxMergeDocs);\n                }\n            }\n\n            int mergeFactor = settings.getAsInt(INDEX_MERGE_POLICY_MERGE_FACTOR, LogDocMergePolicyProvider.this.mergeFactor);\n            if (mergeFactor != LogDocMergePolicyProvider.this.mergeFactor) {\n                logger.info(\"updating merge_factor from [{}] to [{}]\", LogDocMergePolicyProvider.this.mergeFactor, mergeFactor);\n                LogDocMergePolicyProvider.this.mergeFactor = mergeFactor;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setMergeFactor(mergeFactor);\n                }\n            }\n\n            final double noCFSRatio = parseNoCFSRatio(settings.get(INDEX_COMPOUND_FORMAT, Double.toString(LogDocMergePolicyProvider.this.noCFSRatio)));\n            final boolean compoundFormat = noCFSRatio != 0.0;\n            if (noCFSRatio != LogDocMergePolicyProvider.this.noCFSRatio) {\n                logger.info(\"updating index.compound_format from [{}] to [{}]\", formatNoCFSRatio(LogDocMergePolicyProvider.this.noCFSRatio), formatNoCFSRatio(noCFSRatio));\n                LogDocMergePolicyProvider.this.compoundFormat = compoundFormat;\n                LogDocMergePolicyProvider.this.noCFSRatio = noCFSRatio;\n                for (CustomLogDocMergePolicy policy : policies) {\n                    policy.setNoCFSRatio(noCFSRatio);\n                    policy.setUseCompoundFile(compoundFormat);\n                }\n            }\n        }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            double expungeDeletesPctAllowed = settings.getAsDouble(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED, TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed);\n            if (expungeDeletesPctAllowed != TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed) {\n                logger.info(\"updating [expunge_deletes_allowed] from [{}] to [{}]\", TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed, expungeDeletesPctAllowed);\n                TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed = expungeDeletesPctAllowed;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setForceMergeDeletesPctAllowed(expungeDeletesPctAllowed);\n                }\n            }\n\n            ByteSizeValue floorSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_FLOOR_SEGMENT, TieredMergePolicyProvider.this.floorSegment);\n            if (!floorSegment.equals(TieredMergePolicyProvider.this.floorSegment)) {\n                logger.info(\"updating [floor_segment] from [{}] to [{}]\", TieredMergePolicyProvider.this.floorSegment, floorSegment);\n                TieredMergePolicyProvider.this.floorSegment = floorSegment;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setFloorSegmentMB(floorSegment.mbFrac());\n                }\n            }\n\n            int maxMergeAtOnce = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, TieredMergePolicyProvider.this.maxMergeAtOnce);\n            if (maxMergeAtOnce != TieredMergePolicyProvider.this.maxMergeAtOnce) {\n                logger.info(\"updating [max_merge_at_once] from [{}] to [{}]\", TieredMergePolicyProvider.this.maxMergeAtOnce, maxMergeAtOnce);\n                TieredMergePolicyProvider.this.maxMergeAtOnce = maxMergeAtOnce;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setMaxMergeAtOnce(maxMergeAtOnce);\n                }\n            }\n\n            int maxMergeAtOnceExplicit = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, TieredMergePolicyProvider.this.maxMergeAtOnceExplicit);\n            if (maxMergeAtOnceExplicit != TieredMergePolicyProvider.this.maxMergeAtOnceExplicit) {\n                logger.info(\"updating [max_merge_at_once_explicit] from [{}] to [{}]\", TieredMergePolicyProvider.this.maxMergeAtOnceExplicit, maxMergeAtOnceExplicit);\n                TieredMergePolicyProvider.this.maxMergeAtOnceExplicit = maxMergeAtOnceExplicit;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n                }\n            }\n\n            ByteSizeValue maxMergedSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, TieredMergePolicyProvider.this.maxMergedSegment);\n            if (!maxMergedSegment.equals(TieredMergePolicyProvider.this.maxMergedSegment)) {\n                logger.info(\"updating [max_merged_segment] from [{}] to [{}]\", TieredMergePolicyProvider.this.maxMergedSegment, maxMergedSegment);\n                TieredMergePolicyProvider.this.maxMergedSegment = maxMergedSegment;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setFloorSegmentMB(maxMergedSegment.mbFrac());\n                }\n            }\n\n            double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, TieredMergePolicyProvider.this.segmentsPerTier);\n            if (segmentsPerTier != TieredMergePolicyProvider.this.segmentsPerTier) {\n                logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", TieredMergePolicyProvider.this.segmentsPerTier, segmentsPerTier);\n                TieredMergePolicyProvider.this.segmentsPerTier = segmentsPerTier;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setSegmentsPerTier(segmentsPerTier);\n                }\n            }\n\n            double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, TieredMergePolicyProvider.this.reclaimDeletesWeight);\n            if (reclaimDeletesWeight != TieredMergePolicyProvider.this.reclaimDeletesWeight) {\n                logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", TieredMergePolicyProvider.this.reclaimDeletesWeight, reclaimDeletesWeight);\n                TieredMergePolicyProvider.this.reclaimDeletesWeight = reclaimDeletesWeight;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setReclaimDeletesWeight(reclaimDeletesWeight);\n                }\n            }\n\n            boolean compoundFormat = settings.getAsBoolean(INDEX_COMPOUND_FORMAT, TieredMergePolicyProvider.this.compoundFormat);\n            if (compoundFormat != TieredMergePolicyProvider.this.compoundFormat) {\n                logger.info(\"updating index.compound_format from [{}] to [{}]\", TieredMergePolicyProvider.this.compoundFormat, compoundFormat);\n                TieredMergePolicyProvider.this.compoundFormat = compoundFormat;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setUseCompoundFile(compoundFormat);\n                }\n            }\n\n            fixSettingsIfNeeded();\n        }","id":11407,"modified_method":"@Override\n        public void onRefreshSettings(Settings settings) {\n            double expungeDeletesPctAllowed = settings.getAsDouble(INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED, TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed);\n            if (expungeDeletesPctAllowed != TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed) {\n                logger.info(\"updating [expunge_deletes_allowed] from [{}] to [{}]\", TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed, expungeDeletesPctAllowed);\n                TieredMergePolicyProvider.this.forceMergeDeletesPctAllowed = expungeDeletesPctAllowed;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setForceMergeDeletesPctAllowed(expungeDeletesPctAllowed);\n                }\n            }\n\n            ByteSizeValue floorSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_FLOOR_SEGMENT, TieredMergePolicyProvider.this.floorSegment);\n            if (!floorSegment.equals(TieredMergePolicyProvider.this.floorSegment)) {\n                logger.info(\"updating [floor_segment] from [{}] to [{}]\", TieredMergePolicyProvider.this.floorSegment, floorSegment);\n                TieredMergePolicyProvider.this.floorSegment = floorSegment;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setFloorSegmentMB(floorSegment.mbFrac());\n                }\n            }\n\n            int maxMergeAtOnce = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, TieredMergePolicyProvider.this.maxMergeAtOnce);\n            if (maxMergeAtOnce != TieredMergePolicyProvider.this.maxMergeAtOnce) {\n                logger.info(\"updating [max_merge_at_once] from [{}] to [{}]\", TieredMergePolicyProvider.this.maxMergeAtOnce, maxMergeAtOnce);\n                TieredMergePolicyProvider.this.maxMergeAtOnce = maxMergeAtOnce;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setMaxMergeAtOnce(maxMergeAtOnce);\n                }\n            }\n\n            int maxMergeAtOnceExplicit = settings.getAsInt(INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT, TieredMergePolicyProvider.this.maxMergeAtOnceExplicit);\n            if (maxMergeAtOnceExplicit != TieredMergePolicyProvider.this.maxMergeAtOnceExplicit) {\n                logger.info(\"updating [max_merge_at_once_explicit] from [{}] to [{}]\", TieredMergePolicyProvider.this.maxMergeAtOnceExplicit, maxMergeAtOnceExplicit);\n                TieredMergePolicyProvider.this.maxMergeAtOnceExplicit = maxMergeAtOnceExplicit;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n                }\n            }\n\n            ByteSizeValue maxMergedSegment = settings.getAsBytesSize(INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT, TieredMergePolicyProvider.this.maxMergedSegment);\n            if (!maxMergedSegment.equals(TieredMergePolicyProvider.this.maxMergedSegment)) {\n                logger.info(\"updating [max_merged_segment] from [{}] to [{}]\", TieredMergePolicyProvider.this.maxMergedSegment, maxMergedSegment);\n                TieredMergePolicyProvider.this.maxMergedSegment = maxMergedSegment;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setFloorSegmentMB(maxMergedSegment.mbFrac());\n                }\n            }\n\n            double segmentsPerTier = settings.getAsDouble(INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, TieredMergePolicyProvider.this.segmentsPerTier);\n            if (segmentsPerTier != TieredMergePolicyProvider.this.segmentsPerTier) {\n                logger.info(\"updating [segments_per_tier] from [{}] to [{}]\", TieredMergePolicyProvider.this.segmentsPerTier, segmentsPerTier);\n                TieredMergePolicyProvider.this.segmentsPerTier = segmentsPerTier;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setSegmentsPerTier(segmentsPerTier);\n                }\n            }\n\n            double reclaimDeletesWeight = settings.getAsDouble(INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT, TieredMergePolicyProvider.this.reclaimDeletesWeight);\n            if (reclaimDeletesWeight != TieredMergePolicyProvider.this.reclaimDeletesWeight) {\n                logger.info(\"updating [reclaim_deletes_weight] from [{}] to [{}]\", TieredMergePolicyProvider.this.reclaimDeletesWeight, reclaimDeletesWeight);\n                TieredMergePolicyProvider.this.reclaimDeletesWeight = reclaimDeletesWeight;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setReclaimDeletesWeight(reclaimDeletesWeight);\n                }\n            }\n\n            final double noCFSRatio = parseNoCFSRatio(settings.get(INDEX_COMPOUND_FORMAT, Double.toString(TieredMergePolicyProvider.this.noCFSRatio)));\n            final boolean compoundFormat = noCFSRatio != 0.0;\n            if (noCFSRatio != TieredMergePolicyProvider.this.noCFSRatio) {\n                logger.info(\"updating index.compound_format from [{}] to [{}]\", formatNoCFSRatio(TieredMergePolicyProvider.this.noCFSRatio), formatNoCFSRatio(noCFSRatio));\n                TieredMergePolicyProvider.this.compoundFormat = compoundFormat;\n                TieredMergePolicyProvider.this.noCFSRatio = noCFSRatio;\n                for (CustomTieredMergePolicyProvider policy : policies) {\n                    policy.setNoCFSRatio(noCFSRatio);\n                    policy.setUseCompoundFile(compoundFormat);\n                }\n            }\n\n            fixSettingsIfNeeded();\n        }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public TieredMergePolicyProvider(Store store, IndexSettingsService indexSettingsService) {\n        super(store.shardId(), store.indexSettings());\n        this.indexSettingsService = indexSettingsService;\n\n        this.compoundFormat = indexSettings.getAsBoolean(INDEX_COMPOUND_FORMAT, store.suggestUseCompoundFile());\n        this.asyncMerge = indexSettings.getAsBoolean(\"index.merge.async\", true);\n        this.forceMergeDeletesPctAllowed = componentSettings.getAsDouble(\"expunge_deletes_allowed\", 10d); // percentage\n        this.floorSegment = componentSettings.getAsBytesSize(\"floor_segment\", new ByteSizeValue(2, ByteSizeUnit.MB));\n        this.maxMergeAtOnce = componentSettings.getAsInt(\"max_merge_at_once\", 10);\n        this.maxMergeAtOnceExplicit = componentSettings.getAsInt(\"max_merge_at_once_explicit\", 30);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        this.maxMergedSegment = componentSettings.getAsBytesSize(\"max_merged_segment\", componentSettings.getAsBytesSize(\"max_merge_segment\", new ByteSizeValue(5, ByteSizeUnit.GB)));\n        this.segmentsPerTier = componentSettings.getAsDouble(\"segments_per_tier\", 10.0d);\n        this.reclaimDeletesWeight = componentSettings.getAsDouble(\"reclaim_deletes_weight\", 2.0d);\n\n        fixSettingsIfNeeded();\n\n        logger.debug(\"using [tiered] merge policy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}], async_merge[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight, asyncMerge);\n\n        indexSettingsService.addListener(applySettings);\n    }","id":11408,"modified_method":"@Inject\n    public TieredMergePolicyProvider(Store store, IndexSettingsService indexSettingsService) {\n        super(store);\n        this.indexSettingsService = indexSettingsService;\n        this.asyncMerge = indexSettings.getAsBoolean(\"index.merge.async\", true);\n        this.forceMergeDeletesPctAllowed = componentSettings.getAsDouble(\"expunge_deletes_allowed\", 10d); // percentage\n        this.floorSegment = componentSettings.getAsBytesSize(\"floor_segment\", new ByteSizeValue(2, ByteSizeUnit.MB));\n        this.maxMergeAtOnce = componentSettings.getAsInt(\"max_merge_at_once\", 10);\n        this.maxMergeAtOnceExplicit = componentSettings.getAsInt(\"max_merge_at_once_explicit\", 30);\n        // TODO is this really a good default number for max_merge_segment, what happens for large indices, won't they end up with many segments?\n        this.maxMergedSegment = componentSettings.getAsBytesSize(\"max_merged_segment\", componentSettings.getAsBytesSize(\"max_merge_segment\", new ByteSizeValue(5, ByteSizeUnit.GB)));\n        this.segmentsPerTier = componentSettings.getAsDouble(\"segments_per_tier\", 10.0d);\n        this.reclaimDeletesWeight = componentSettings.getAsDouble(\"reclaim_deletes_weight\", 2.0d);\n\n        fixSettingsIfNeeded();\n\n        logger.debug(\"using [tiered] merge policy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}], async_merge[{}]\",\n                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight, asyncMerge);\n\n        indexSettingsService.addListener(applySettings);\n    }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public TieredMergePolicy newMergePolicy() {\n        CustomTieredMergePolicyProvider mergePolicy;\n        if (asyncMerge) {\n            mergePolicy = new EnableMergeTieredMergePolicyProvider(this);\n        } else {\n            mergePolicy = new CustomTieredMergePolicyProvider(this);\n        }\n        mergePolicy.setUseCompoundFile(compoundFormat);\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        return mergePolicy;\n    }","id":11409,"modified_method":"@Override\n    public TieredMergePolicy newMergePolicy() {\n        CustomTieredMergePolicyProvider mergePolicy;\n        if (asyncMerge) {\n            mergePolicy = new EnableMergeTieredMergePolicyProvider(this);\n        } else {\n            mergePolicy = new CustomTieredMergePolicyProvider(this);\n        }\n        mergePolicy.setUseCompoundFile(compoundFormat);\n        mergePolicy.setNoCFSRatio(noCFSRatio);\n        mergePolicy.setForceMergeDeletesPctAllowed(forceMergeDeletesPctAllowed);\n        mergePolicy.setFloorSegmentMB(floorSegment.mbFrac());\n        mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce);\n        mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit);\n        mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.mbFrac());\n        mergePolicy.setSegmentsPerTier(segmentsPerTier);\n        mergePolicy.setReclaimDeletesWeight(reclaimDeletesWeight);\n        return mergePolicy;\n    }","commit_id":"8e33e0e69d73f14cc02abd286d767ba83e171cee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\r\n            creature.tap(game);\r\n            ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect();\r\n            effect.setTargetPointer(new FixedTarget(creature.getId()));\r\n            game.addEffect(effect, source);\r\n        }\r\n        return true;\r\n    }","id":11410,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        List<Permanent> doNotUntapNextUntapStep = new ArrayList<>();\r\n        for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\r\n            creature.tap(game);\r\n            doNotUntapNextUntapStep.add(creature);\r\n        }\r\n        if (!doNotUntapNextUntapStep.isEmpty()) {\r\n            ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"This creature\");\r\n            effect.setTargetPointer(new FixedTargets(doNotUntapNextUntapStep, game));\r\n            game.addEffect(effect, source);\r\n        }\r\n        return true;\r\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        for (Permanent creature: game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\n            creature.tap(game);\n            ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect();\n            effect.setTargetPointer(new FixedTarget(creature.getId()));\n            game.addEffect(effect, source);                \n        }\n        return true;\n    }","id":11411,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        List<Permanent> doNotUntapNextUntapStep = new ArrayList<>();\n        for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\n            creature.tap(game);\n            doNotUntapNextUntapStep.add(creature);\n        }\n        if (!doNotUntapNextUntapStep.isEmpty()) {\n            ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"This creature\");\n            effect.setTargetPointer(new FixedTargets(doNotUntapNextUntapStep, game));\n            game.addEffect(effect, source);\n        }\n        return true;\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        // the check for turn number is needed if multiple effects are added to prevent untap in next untap step of controller\n        // if we don't check for turn number, every untap step of a turn only one effect would be used instead of correctly only one time\n        // to skip the untap effect.\n\n        // Discard effect if it's related to a previous turn\n        if (validForTurnNum > 0 && validForTurnNum < game.getTurnNum()) {\n            discard();\n            return false;\n        }\n        // remember the turn of the untap step the effect has to be applied\n        if (GameEvent.EventType.UNTAP_STEP.equals(event.getType())) {\n            UUID controllerId = null;\n            for (UUID targetId : getTargetPointer().getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(targetId);\n                if (permanent != null) {\n                    controllerId = permanent.getControllerId();\n                }\n            }\n            if (controllerId == null) { // no more targets on the battlefield, effect can be discarded\n                discard();\n                return false;\n            }\n\n            if (game.getActivePlayerId().equals(controllerId)) {\n                if (validForTurnNum == game.getTurnNum()) { // the turn has a second untap step but the effect is already related to the first untap step\n                    discard();\n                    return false;\n                }\n                validForTurnNum = game.getTurnNum();\n            }\n        }\n\n        if (game.getTurn().getStepType() == PhaseStep.UNTAP && event.getType() == EventType.UNTAP) {\n            if (targetPointer.getTargets(game, source).contains(event.getTargetId())) {\n                Permanent permanent = game.getPermanent(event.getTargetId());\n                if (permanent != null && game.getActivePlayerId().equals(permanent.getControllerId())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":11412,"modified_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        // the check if a permanent untap pahse is already handled is needed if multiple effects are added to prevent untap in next untap step of controller\n        // if we don't check it for every untap step of a turn only one effect would be consumed instead of all be valid for the next untap step\n        if (GameEvent.EventType.UNTAP_STEP.equals(event.getType())) {\n            boolean allHandled = true;\n            for (UUID targetId : getTargetPointer().getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(targetId);\n                if (permanent != null) {\n                    if (game.getActivePlayerId().equals(permanent.getControllerId())\n                            || (game.getActivePlayerId().equals(onlyIfControlledByPlayer))) { // if effect works only for specific player, all permanents have to be set to handled in that players untap step\n                        if (!handledTargetsDuringTurn.containsKey(targetId)) {\n                            // it's the untep step of the current controller and the effect was not handled for this target yet, so do it now\n                            handledTargetsDuringTurn.put(targetId, false);\n                            allHandled = false;\n                        } else if (!handledTargetsDuringTurn.get(targetId)) {\n                            // if it was already ready to be handled on an previous Untap step set it to done if not already so\n                            handledTargetsDuringTurn.put(targetId, true);\n                        }\n                    } else {\n                        allHandled = false;\n                    }\n                }\n            }\n            if (allHandled) {\n                discard();\n            }\n        }\n\n        if (game.getTurn().getStepType() == PhaseStep.UNTAP && event.getType() == EventType.UNTAP) {\n            if (handledTargetsDuringTurn.containsKey(event.getTargetId())\n                    && !handledTargetsDuringTurn.get(event.getTargetId())\n                    && getTargetPointer().getTargets(game, source).contains(event.getTargetId())) {\n                Permanent permanent = game.getPermanent(event.getTargetId());\n                if (permanent != null && game.getActivePlayerId().equals(permanent.getControllerId())) {\n                    handledTargetsDuringTurn.put(event.getTargetId(), true);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"public DontUntapInControllersNextUntapStepTargetEffect(final DontUntapInControllersNextUntapStepTargetEffect effect) {\n        super(effect);\n        this.validForTurnNum = effect.validForTurnNum;\n        this.targetName = effect.targetName;\n\n    }","id":11413,"modified_method":"public DontUntapInControllersNextUntapStepTargetEffect(final DontUntapInControllersNextUntapStepTargetEffect effect) {\n        super(effect);\n        this.targetName = effect.targetName;\n        this.handledTargetsDuringTurn.putAll(effect.handledTargetsDuringTurn);\n        this.onlyIfControlledByPlayer = effect.onlyIfControlledByPlayer;\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"public DontUntapInControllersNextUntapStepTargetEffect(String targetName) {\n        this();\n        this.targetName = targetName;\n    }","id":11414,"modified_method":"public DontUntapInControllersNextUntapStepTargetEffect(String targetName) {\n        this(targetName, null);\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Attention: This effect won't work with targets controlled by different\n     * controllers If this is needed, the validForTurnNum has to be saved per\n     * controller.\n     *\n     */\n    public DontUntapInControllersNextUntapStepTargetEffect() {\n        super(Duration.Custom, Outcome.Detriment, false, true);\n    }","id":11415,"modified_method":"/**\n     * Attention: This effect won't work with targets controlled by different\n     * controllers If this is needed, the validForTurnNum has to be saved per\n     * controller.\n     *\n     */\n    public DontUntapInControllersNextUntapStepTargetEffect() {\n        this(\"\");\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n        if (player != null) {\r\n            for (Permanent permanent : game.getBattlefield().getAllActivePermanents(filter, player.getId(), game)) {\r\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect();\r\n                effect.setTargetPointer(new FixedTarget(permanent.getId()));\r\n                game.addEffect(effect, source);                      \r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":11416,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n        if (player != null) {\r\n            List<Permanent> doNotUntapNextUntapStep = new ArrayList<>();\r\n            for (Permanent permanent : game.getBattlefield().getAllActivePermanents(filter, player.getId(), game)) {\r\n                doNotUntapNextUntapStep.add(permanent);\r\n            }\r\n            if (!doNotUntapNextUntapStep.isEmpty()) {\r\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"This creature\");\r\n                effect.setTargetPointer(new FixedTargets(doNotUntapNextUntapStep, game));\r\n                game.addEffect(effect, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent land = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\n        Permanent targetCreature = game.getPermanent(source.getFirstTarget());\n        if (land != null && targetCreature != null) {\n            if (land.hasSubtype(\"Island\")) {\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"that creature\");\n                effect.setTargetPointer(new FixedTarget(targetCreature, game));\n                game.addEffect(effect, source);\n            }\n        }\n        return true;\n    }","id":11417,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent land = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\n        Permanent targetCreature = game.getPermanent(source.getFirstTarget());\n        if (land != null && targetCreature != null && land.hasSubtype(\"Island\")) {\n            ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"that creature\");\n            effect.setTargetPointer(new FixedTarget(targetCreature, game));\n            game.addEffect(effect, source);\n        }\n        return true;\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"public LorthosTheTidemaker(UUID ownerId) {\r\n        super(ownerId, 53, \"Lorthos, the Tidemaker\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{5}{U}{U}{U}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Octopus\");\r\n\r\n        this.power = new MageInt(8);\r\n        this.toughness = new MageInt(8);\r\n\r\n        // Whenever Lorthos, the Tidemaker attacks, you may pay {8}. If you do, tap up to eight target permanents. Those permanents don't untap during their controllers' next untap steps.\r\n        AttacksTriggeredAbility ability = new AttacksTriggeredAbility(new LorthosTheTideMakerEffect(), true);\r\n        ability.addTarget(new TargetPermanent(0, 8, filter, false));\r\n        this.addAbility(ability);\r\n    }","id":11418,"modified_method":"public LorthosTheTidemaker(UUID ownerId) {\r\n        super(ownerId, 53, \"Lorthos, the Tidemaker\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{5}{U}{U}{U}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Octopus\");\r\n\r\n        this.power = new MageInt(8);\r\n        this.toughness = new MageInt(8);\r\n\r\n        // Whenever Lorthos, the Tidemaker attacks, you may pay {8}. If you do, tap up to eight target permanents. Those permanents don't untap during their controllers' next untap steps.\r\n        DoIfCostPaid effect = new DoIfCostPaid(new TapTargetEffect(), new GenericManaCost(8), \"Pay {8} to tap up to 8 target permanents? (They don't untap during their controllers' next untap steps)\");\r\n        AttacksTriggeredAbility ability = new AttacksTriggeredAbility(effect, false);\r\n        Effect effect2 = new DontUntapInControllersNextUntapStepTargetEffect();\r\n        effect2.setText(\"Those permanents don't untap during their controllers' next untap steps\");\r\n        effect.addEffect(effect2);\r\n        ability.addTarget(new TargetPermanent(0, 8, filter, false));\r\n        this.addAbility(ability);\r\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(getTargetPointer().getFirst(game, source));\r\n        if (player != null) {\r\n            for (Permanent creature: game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {\r\n                creature.tap(game);\r\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"This creature\");\r\n                effect.setTargetPointer(new FixedTarget(creature.getId()));\r\n                game.addEffect(effect, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":11419,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(getTargetPointer().getFirst(game, source));\r\n        if (player != null) {\r\n            List<Permanent> doNotUntapNextUntapStep = new ArrayList<>();\r\n            for (Permanent creature : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {\r\n                doNotUntapNextUntapStep.add(creature);\r\n            }\r\n            if (!doNotUntapNextUntapStep.isEmpty()) {\r\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"This creature\");\r\n                effect.setTargetPointer(new FixedTargets(doNotUntapNextUntapStep, game));\r\n                game.addEffect(effect, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getFirstTarget());\n        if (player != null) {\n            for (Permanent creature: game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {\n                creature.tap(game);\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect();\n                effect.setTargetPointer(new FixedTarget(creature.getId()));\n                game.addEffect(effect, source);                \n            }\n            return true;\n        }\n        return false;\n    }","id":11420,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getFirstTarget());\n        if (player != null) {\n            List<Permanent> doNotUntapNextUntapStep = new ArrayList<>();\n            for (Permanent creature : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {\n                creature.tap(game);\n                doNotUntapNextUntapStep.add(creature);\n            }\n            if (!doNotUntapNextUntapStep.isEmpty()) {\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"\", player.getId());\n                effect.setText(\"those creatures don't untap during that player's next untap step\");\n                effect.setTargetPointer(new FixedTargets(doNotUntapNextUntapStep, game));\n                game.addEffect(effect, source);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            for (Permanent permanent :game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\r\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect();\r\n                effect.setTargetPointer(new FixedTarget(permanent.getId()));\r\n                game.addEffect(effect, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":11421,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            List<Permanent> doNotUntapNextUntapStep = new ArrayList<>();\r\n            for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\r\n                doNotUntapNextUntapStep.add(permanent);\r\n            }\r\n            if (!doNotUntapNextUntapStep.isEmpty()) {\r\n                ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"This creature\");\r\n                effect.setTargetPointer(new FixedTargets(doNotUntapNextUntapStep, game));\r\n                game.addEffect(effect, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Map<Integer, Set<String>> attackerMap = null;\r\n        Object object = game.getState().getValue(\"blockedAttackers\" + source.getSourceId());\r\n        if (object != null && object instanceof Map) {\r\n            attackerMap = (Map<Integer, Set<String>>) object;\r\n            for (Set<String> attackerSet :attackerMap.values()) {\r\n                for (Permanent creature : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                    if (attackerSet.contains(CardUtil.getCardZoneString(null, creature.getId(), game))) {\r\n                        // tap creature and add the not untap effect\r\n                        creature.tap(game);\r\n                        ContinuousEffect effect  = new DontUntapInControllersNextUntapStepTargetEffect();\r\n                        effect.setTargetPointer(new FixedTarget(creature.getId()));\r\n                        game.addEffect(effect, source);\r\n                        game.informPlayers(new StringBuilder(\"Triton Tactics: \").append(creature.getName()).append(\" doesn't untap during its controller's next untap step\").toString());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (attackerMap != null) {\r\n            attackerMap.clear();\r\n        }\r\n\r\n        return true;\r\n    }","id":11422,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Map<Integer, Set<String>> attackerMap = null;\r\n        Object object = game.getState().getValue(\"blockedAttackers\" + source.getSourceId());\r\n        if (object != null && object instanceof Map) {\r\n            attackerMap = (Map<Integer, Set<String>>) object;\r\n            for (Set<String> attackerSet : attackerMap.values()) {\r\n                List<Permanent> doNotUntapNextUntapStep = new ArrayList<>();\r\n                for (Permanent creature : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                    if (attackerSet.contains(CardUtil.getCardZoneString(null, creature.getId(), game))) {\r\n                        // tap creature and add the not untap effect\r\n                        creature.tap(game);\r\n                        doNotUntapNextUntapStep.add(creature);\r\n                        game.informPlayers(new StringBuilder(\"Triton Tactics: \").append(creature.getName()).append(\" doesn't untap during its controller's next untap step\").toString());\r\n                    }\r\n                }\r\n                if (!doNotUntapNextUntapStep.isEmpty()) {\r\n                    ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect(\"This creature\");\r\n                    effect.setTargetPointer(new FixedTargets(doNotUntapNextUntapStep, game));\r\n                    game.addEffect(effect, source);\r\n                }\r\n            }\r\n        }\r\n        if (attackerMap != null) {\r\n            attackerMap.clear();\r\n        }\r\n\r\n        return true;\r\n    }","commit_id":"272f68b530b59d42a751089be4f7928af994e178","url":"https://github.com/magefree/mage"},{"original_method":"public Long dispatchCreateCmd(BaseAsyncCreateCmd cmd, Map<String, String> params) {\n        setupParameters(cmd, params);\n\n        Implementation impl = cmd.getClass().getAnnotation(Implementation.class);\n        String methodName = impl.createMethod();\n        Object mgr = _mgmtServer;\n        switch (impl.manager()) {\n        case AccountManager:\n            mgr = _accountMgr;\n            break;\n        case AgentManager:\n            mgr = _agentMgr;\n            break;\n        case ConfigManager:\n            mgr = _configMgr;\n            break;\n        case ConsoleProxyManager:\n            mgr = _consoleProxyMgr;\n            break;\n        case NetworkGroupManager:\n            mgr = _networkGroupMgr;\n            break;\n        case NetworkManager:\n            mgr = _networkMgr;\n            break;\n        case SnapshotManager:\n            mgr = _snapshotMgr;\n            break;\n        case StorageManager:\n            mgr = _storageMgr;\n            break;\n        case TemplateManager:\n            mgr = _templateMgr;\n            break;\n        case UserVmManager:\n            mgr = _userVmMgr;\n            break;\n        }\n\n        try {\n            Method method = mgr.getClass().getMethod(methodName, cmd.getClass());\n            Object dbObject = method.invoke(mgr, cmd);\n\n            Method getIdMethod = dbObject.getClass().getMethod(\"getId\");\n            Object id = getIdMethod.invoke(dbObject);\n            \n            return (Long)id;\n        } catch (NoSuchMethodException nsme) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), nsme);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", unable to find implementation.\");\n        } catch (InvocationTargetException ite) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), ite);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalAccessException iae) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iae);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalArgumentException iArgEx) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iArgEx);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        }\n    }","id":11423,"modified_method":"public Long dispatchCreateCmd(BaseAsyncCreateCmd cmd, Map<String, String> params) {\n        setupParameters(cmd, params);\n\n        Implementation impl = cmd.getClass().getAnnotation(Implementation.class);\n        if (impl == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute create command \" + cmd.getClass().getName() + \", no implementation specified.\");\n        }\n\n        String methodName = impl.createMethod();\n        Object mgr = _mgmtServer;\n        switch (impl.manager()) {\n        case AccountManager:\n            mgr = _accountMgr;\n            break;\n        case AgentManager:\n            mgr = _agentMgr;\n            break;\n        case ConfigManager:\n            mgr = _configMgr;\n            break;\n        case ConsoleProxyManager:\n            mgr = _consoleProxyMgr;\n            break;\n        case NetworkGroupManager:\n            mgr = _networkGroupMgr;\n            break;\n        case NetworkManager:\n            mgr = _networkMgr;\n            break;\n        case SnapshotManager:\n            mgr = _snapshotMgr;\n            break;\n        case StorageManager:\n            mgr = _storageMgr;\n            break;\n        case TemplateManager:\n            mgr = _templateMgr;\n            break;\n        case UserVmManager:\n            mgr = _userVmMgr;\n            break;\n        }\n\n        try {\n            Method method = mgr.getClass().getMethod(methodName, cmd.getClass());\n            Object dbObject = method.invoke(mgr, cmd);\n\n            Method getIdMethod = dbObject.getClass().getMethod(\"getId\");\n            Object id = getIdMethod.invoke(dbObject);\n            \n            return (Long)id;\n        } catch (NoSuchMethodException nsme) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), nsme);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", unable to find implementation.\");\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause instanceof InvalidParameterValueException) {\n                throw new ServerApiException(BaseCmd.PARAM_ERROR, cause.getMessage());\n            } else if (cause instanceof PermissionDeniedException) {\n                throw new ServerApiException(BaseCmd.ACCOUNT_ERROR, cause.getMessage());\n            }\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), ite);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalAccessException iae) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iae);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalArgumentException iArgEx) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iArgEx);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (Exception ex) {\n            s_logger.error(\"Unhandled exception invoking method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), ex);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        }\n    }","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"public void dispatch(BaseCmd cmd, Map<String, String> params) {\n        setupParameters(cmd, params);\n\n        Implementation impl = cmd.getClass().getAnnotation(Implementation.class);\n        if (impl == null) {\n            throw new CloudRuntimeException(\"Unable to execute command \" + cmd.getClass().getName() + \", no implementation specified.\");\n        }\n\n        String methodName = impl.method();\n        Object mgr = _mgmtServer;\n        switch (impl.manager()) {\n        case AccountManager:\n            mgr = _accountMgr;\n            break;\n        case AgentManager:\n            mgr = _agentMgr;\n            break;\n        case ConfigManager:\n            mgr = _configMgr;\n            break;\n        case ConsoleProxyManager:\n            mgr = _consoleProxyMgr;\n            break;\n        case NetworkGroupManager:\n            mgr = _networkGroupMgr;\n            break;\n        case NetworkManager:\n            mgr = _networkMgr;\n            break;\n        case SnapshotManager:\n            mgr = _snapshotMgr;\n            break;\n        case StorageManager:\n            mgr = _storageMgr;\n            break;\n        case TemplateManager:\n            mgr = _templateMgr;\n            break;\n        case UserVmManager:\n            mgr = _userVmMgr;\n            break;\n        }\n\n        try {\n            Method method = mgr.getClass().getMethod(methodName, cmd.getClass());\n            Object result = method.invoke(mgr, cmd);\n            cmd.setResponseObject(result);\n        } catch (NoSuchMethodException nsme) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), nsme);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", unable to find implementation.\");\n        } catch (InvocationTargetException ite) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), ite);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalAccessException iae) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iae);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalArgumentException iArgEx) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iArgEx);\n            throw new CloudRuntimeException(\"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        }\n    }","id":11424,"modified_method":"public void dispatch(BaseCmd cmd, Map<String, String> params) {\n        setupParameters(cmd, params);\n\n        Implementation impl = cmd.getClass().getAnnotation(Implementation.class);\n        if (impl == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute command \" + cmd.getClass().getName() + \", no implementation specified.\");\n        }\n\n        String methodName = impl.method();\n        Object mgr = _mgmtServer;\n        switch (impl.manager()) {\n        case AccountManager:\n            mgr = _accountMgr;\n            break;\n        case AgentManager:\n            mgr = _agentMgr;\n            break;\n        case ConfigManager:\n            mgr = _configMgr;\n            break;\n        case ConsoleProxyManager:\n            mgr = _consoleProxyMgr;\n            break;\n        case NetworkGroupManager:\n            mgr = _networkGroupMgr;\n            break;\n        case NetworkManager:\n            mgr = _networkMgr;\n            break;\n        case SnapshotManager:\n            mgr = _snapshotMgr;\n            break;\n        case StorageManager:\n            mgr = _storageMgr;\n            break;\n        case TemplateManager:\n            mgr = _templateMgr;\n            break;\n        case UserVmManager:\n            mgr = _userVmMgr;\n            break;\n        }\n\n        try {\n            Method method = mgr.getClass().getMethod(methodName, cmd.getClass());\n            Object result = method.invoke(mgr, cmd);\n            cmd.setResponseObject(result);\n        } catch (NoSuchMethodException nsme) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), nsme);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", unable to find implementation.\");\n        } catch (InvocationTargetException ite) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), ite);\n            Throwable cause = ite.getCause();\n            if (cause instanceof InvalidParameterValueException) {\n                throw new ServerApiException(BaseCmd.PARAM_ERROR, cause.getMessage());\n            } else if (cause instanceof PermissionDeniedException) {\n                throw new ServerApiException(BaseCmd.ACCOUNT_ERROR, cause.getMessage());\n            }\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalAccessException iae) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iae);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (IllegalArgumentException iArgEx) {\n            s_logger.warn(\"Exception executing method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), iArgEx);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        } catch (Exception ex) {\n            s_logger.error(\"Unhandled exception invoking method \" + methodName + \" for command \" + cmd.getClass().getSimpleName(), ex);\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Unable to execute method \" + methodName + \" for command \" + cmd.getClass().getSimpleName() + \", internal error in the implementation.\");\n        }\n    }","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"public static String toSerializedString(ResponseObject result) {\n        if (result != null) {\n            Gson gson = new GsonBuilder().excludeFieldsWithModifiers(Modifier.TRANSIENT).create();\n            StringBuilder sb = new StringBuilder();\n\n            sb.append(\"{ \\\"\" + result.getResponseName() + \"\\\" : \");\n            if (result instanceof ListResponse) {\n                List<? extends ResponseObject> responses = ((ListResponse)result).getResponses();\n                if ((responses != null) && !responses.isEmpty()) {\n                    int count = responses.size();\n                    String jsonStr = gson.toJson(responses.get(0));\n                    sb.append(\"{ \\\"\" + responses.get(0).getResponseName() + \"\\\" : [  \" + jsonStr);\n                    for (int i = 1; i < count; i++) {\n                        jsonStr = gson.toJson(responses.get(i));\n                        sb.append(\", \" + jsonStr);\n                    }\n                    sb.append(\" ] }\");\n                } else {\n                    sb.append(\"{ }\");\n                }\n            } else {\n                // FIXME:  nested objects?\n                String jsonStr = gson.toJson(result);\n                if ((jsonStr != null) && !\"\".equals(jsonStr)) {\n                    sb.append(jsonStr);\n                } else {\n                    sb.append(\"{ }\");\n                }\n            }\n            sb.append(\" }\");\n            return sb.toString();\n        }\n        return null;\n    }","id":11425,"modified_method":"public static String toSerializedString(ResponseObject result) {\n        if (result != null) {\n            Gson gson = GsonHelper.getBuilder().excludeFieldsWithModifiers(Modifier.TRANSIENT).create();\n            StringBuilder sb = new StringBuilder();\n\n            sb.append(\"{ \\\"\" + result.getResponseName() + \"\\\" : \");\n            if (result instanceof ListResponse) {\n                List<? extends ResponseObject> responses = ((ListResponse)result).getResponses();\n                if ((responses != null) && !responses.isEmpty()) {\n                    int count = responses.size();\n                    String jsonStr = gson.toJson(responses.get(0));\n                    sb.append(\"{ \\\"\" + responses.get(0).getResponseName() + \"\\\" : [  \" + jsonStr);\n                    for (int i = 1; i < count; i++) {\n                        jsonStr = gson.toJson(responses.get(i));\n                        sb.append(\", \" + jsonStr);\n                    }\n                    sb.append(\" ] }\");\n                } else {\n                    sb.append(\"{ }\");\n                }\n            } else {\n                // FIXME:  nested objects?\n                String jsonStr = gson.toJson(result);\n                if ((jsonStr != null) && !\"\".equals(jsonStr)) {\n                    sb.append(jsonStr);\n                } else {\n                    sb.append(\"{ }\");\n                }\n            }\n            sb.append(\" }\");\n            return sb.toString();\n        }\n        return null;\n    }","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"private Runnable getExecutorRunnable(final AsyncJobManager mgr, final AsyncJobVO job) {\n        return new Runnable() {\n            public void run() {\n                long jobId = 0;\n\n                Transaction txn = Transaction.open(Transaction.CLOUD_DB);\n                try {\n                    jobId = job.getId();\n                    NDC.push(\"job-\" + jobId);\n\n                    if(s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Executing \" + job.getCmd() + \" for job-\" + jobId);\n                    }\n\n                    Class<?> cmdClass = Class.forName(job.getCmd());\n                    BaseAsyncCmd cmdObj = (BaseAsyncCmd)cmdClass.newInstance();\n                    cmdObj.setAsyncJobManager(mgr);\n                    cmdObj.setJob(job);\n\n                    Type mapType = new TypeToken<Map<String, String>>() {}.getType();\n                    Gson gson = GsonHelper.getBuilder().create();\n                    Map<String, String> params = gson.fromJson(job.getCmdInfo(), mapType);\n\n                    // whenever we deserialize, the UserContext needs to be updated\n                    String userIdStr = params.get(\"ctxUserId\");\n                    String acctIdStr = params.get(\"ctxAccountId\");\n                    Long userId = null;\n                    Account accountObject = null;\n\n                    if (userIdStr != null) {\n                        userId = Long.parseLong(userIdStr);\n                    }\n\n                    if (acctIdStr != null) {\n                        accountObject = _accountDao.findById(Long.parseLong(acctIdStr));\n                    }\n\n                    UserContext.registerContext(userId, accountObject, null, null, null, null, false);\n\n                    // dispatch could ultimately queue the job\n                    _dispatcher.dispatch(cmdObj, params);\n\n                    // serialize this to the async job table\n                    completeAsyncJob(jobId, AsyncJobResult.STATUS_SUCCEEDED, 0, cmdObj.getResponse());\n\n                    // FIXME:  things might need to be queued as part of synchronization here, so they just have to be re-dispatched from the queue\n                    //         mechanism...\n                    if (job.getSyncSource() != null) {\n                        _queueMgr.purgeItem(job.getSyncSource().getId());\n                        checkQueue(job.getSyncSource().getQueueId());\n                    }\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Done executing \" + job.getCmd() + \" for job-\" + jobId);\n                    \n                } catch(Throwable e) {\n                    if (e instanceof AsyncCommandQueued) {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"job \" + job.getCmd() + \" for job-\" + jobId + \" was queued, processing the queue.\");\n                        }\n                        checkQueue(((AsyncCommandQueued)e).getQueue().getId());\n                    } else {\n                        s_logger.error(\"Unexpected exception while executing \" + job.getCmd(), e);\n\n                        //FIXME:  need to clean up any queue that happened as part of the dispatching and move on to the next item in the queue\n                        try {\n                            if (job.getSyncSource() != null) {\n                                _queueMgr.purgeItem(job.getSyncSource().getId());\n                                checkQueue(job.getSyncSource().getQueueId());\n                            }\n                        } catch(Throwable ex) {\n                            s_logger.fatal(\"Exception on exception, log it for record\", ex);\n                        }\n                    }\n                } finally {\n                    StackMaid.current().exitCleanup();\n                    txn.close();\n                    NDC.pop();\n                }\n                \n                // leave no trace out after execution for security reason\n//                BaseAsyncJobExecutor.setCurrentExecutor(null);\n            }\n        };\n    }","id":11426,"modified_method":"private Runnable getExecutorRunnable(final AsyncJobManager mgr, final AsyncJobVO job) {\n        return new Runnable() {\n            public void run() {\n                long jobId = 0;\n\n                Transaction txn = Transaction.open(Transaction.CLOUD_DB);\n                try {\n                    jobId = job.getId();\n                    NDC.push(\"job-\" + jobId);\n\n                    if(s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Executing \" + job.getCmd() + \" for job-\" + jobId);\n                    }\n\n                    Class<?> cmdClass = Class.forName(job.getCmd());\n                    BaseAsyncCmd cmdObj = (BaseAsyncCmd)cmdClass.newInstance();\n                    cmdObj.setAsyncJobManager(mgr);\n                    cmdObj.setJob(job);\n\n                    Type mapType = new TypeToken<Map<String, String>>() {}.getType();\n                    Gson gson = GsonHelper.getBuilder().create();\n                    Map<String, String> params = gson.fromJson(job.getCmdInfo(), mapType);\n\n                    // whenever we deserialize, the UserContext needs to be updated\n                    String userIdStr = params.get(\"ctxUserId\");\n                    String acctIdStr = params.get(\"ctxAccountId\");\n                    Long userId = null;\n                    Account accountObject = null;\n\n                    if (userIdStr != null) {\n                        userId = Long.parseLong(userIdStr);\n                    }\n\n                    if (acctIdStr != null) {\n                        accountObject = _accountDao.findById(Long.parseLong(acctIdStr));\n                    }\n\n                    UserContext.registerContext(userId, accountObject, null, null, null, null, false);\n\n                    // dispatch could ultimately queue the job\n                    _dispatcher.dispatch(cmdObj, params);\n\n                    // serialize this to the async job table\n                    completeAsyncJob(jobId, AsyncJobResult.STATUS_SUCCEEDED, 0, cmdObj.getResponse());\n\n                    // commands might need to be queued as part of synchronization here, so they just have to be re-dispatched from the queue mechanism...\n                    if (job.getSyncSource() != null) {\n                        _queueMgr.purgeItem(job.getSyncSource().getId());\n                        checkQueue(job.getSyncSource().getQueueId());\n                    }\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Done executing \" + job.getCmd() + \" for job-\" + jobId);\n                    \n                } catch(Throwable e) {\n                    if (e instanceof AsyncCommandQueued) {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"job \" + job.getCmd() + \" for job-\" + jobId + \" was queued, processing the queue.\");\n                        }\n                        checkQueue(((AsyncCommandQueued)e).getQueue().getId());\n                    } else {\n                        if (!(e instanceof ServerApiException)) {\n                            s_logger.error(\"Unexpected exception while executing \" + job.getCmd(), e);\n                        }\n\n                        // FIXME:  setting resultCode to BaseCmd.INTERNAL_ERROR is not right, usually executors have their exception handling\n                        //         and we need to preserve that as much as possible here\n                        completeAsyncJob(jobId, AsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, e.getMessage());\n\n                        // need to clean up any queue that happened as part of the dispatching and move on to the next item in the queue\n                        try {\n                            if (job.getSyncSource() != null) {\n                                _queueMgr.purgeItem(job.getSyncSource().getId());\n                                checkQueue(job.getSyncSource().getQueueId());\n                            }\n                        } catch(Throwable ex) {\n                            s_logger.fatal(\"Exception on exception, log it for record\", ex);\n                        }\n                    }\n                } finally {\n                    StackMaid.current().exitCleanup();\n                    txn.close();\n                    NDC.pop();\n                }\n            }\n        };\n    }","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"public String getJobResult() {\n        return jobResult;\n    }","id":11427,"modified_method":"public ResponseObject getJobResult() {\n        return jobResult;\n    }","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @SuppressWarnings(\"unchecked\")\r\n    public ResponseObject getResponse() {\n        List<AsyncJobVO> jobs = (List<AsyncJobVO>)getResponseObject();\n\n        ListResponse response = new ListResponse();\n        List<AsyncJobResponse> jobResponses = new ArrayList<AsyncJobResponse>();\n        for (AsyncJobVO job : jobs) {\n            AsyncJobResponse jobResponse = new AsyncJobResponse();\n            jobResponse.setAccountId(job.getAccountId());\n            jobResponse.setCmd(job.getCmd());\n            jobResponse.setCreated(job.getCreated());\n            jobResponse.setId(job.getId());\n            jobResponse.setJobInstanceId(job.getInstanceId());\n            jobResponse.setJobInstanceType(job.getInstanceType());\n            jobResponse.setJobProcStatus(job.getProcessStatus());\n            jobResponse.setJobResult(job.getResult());\n            jobResponse.setJobResultCode(job.getResultCode());\n            jobResponse.setJobStatus(job.getStatus());\n            jobResponse.setUserId(job.getUserId());\n\n            jobResponse.setResponseName(\"asyncjobs\");\n            jobResponses.add(jobResponse);\n        }\n\n        response.setResponses(jobResponses);\n        response.setResponseName(getName());\n        return response;\r\n    }","id":11428,"modified_method":"@Override @SuppressWarnings(\"unchecked\")\r\n    public ResponseObject getResponse() {\n        List<AsyncJobVO> jobs = (List<AsyncJobVO>)getResponseObject();\n\n        ListResponse response = new ListResponse();\n        List<AsyncJobResponse> jobResponses = new ArrayList<AsyncJobResponse>();\n        for (AsyncJobVO job : jobs) {\n            AsyncJobResponse jobResponse = new AsyncJobResponse();\n            jobResponse.setAccountId(job.getAccountId());\n            jobResponse.setCmd(job.getCmd());\n            jobResponse.setCreated(job.getCreated());\n            jobResponse.setId(job.getId());\n            jobResponse.setJobInstanceId(job.getInstanceId());\n            jobResponse.setJobInstanceType(job.getInstanceType());\n            jobResponse.setJobProcStatus(job.getProcessStatus());\n            jobResponse.setJobResult((ResponseObject)SerializerHelper.fromSerializedString(job.getResult()));\n            jobResponse.setJobResultCode(job.getResultCode());\n            jobResponse.setJobStatus(job.getStatus());\n            jobResponse.setUserId(job.getUserId());\n\n            jobResponse.setResponseName(\"asyncjobs\");\n            jobResponses.add(jobResponse);\n        }\n\n        response.setResponses(jobResponses);\n        response.setResponseName(getName());\n        return response;\r\n    }","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ResponseObject getResponse() {\n        AsyncJobResult result = (AsyncJobResult)getResponseObject();\n\n        AsyncJobResponse response = new AsyncJobResponse();\n        response.setId(result.getJobId());\n        response.setJobStatus(result.getJobStatus());\n        response.setJobProcStatus(result.getProcessStatus());\n        response.setJobResultCode(result.getResultCode());\n        response.setJobResult(result.getResult());\n\n        Object resultObject = result.getResultObject();\n        if (resultObject != null) {\n            Class<?> clz = resultObject.getClass();\n            if(clz.isPrimitive() || clz.getSuperclass() == Number.class || clz == String.class || clz == Date.class) {\n                response.setJobResultType(\"text\");\n            } else {\n                response.setJobResultType(\"object\");\n            }\n        }\n\n        /*\n        Object resultObject = result.getResultObject();\n        if (resultObject != null) {\n\n            Class<?> clz = resultObject.getClass();\n            if(clz.isPrimitive() || clz.getSuperclass() == Number.class || clz == String.class || clz == Date.class) {\n                returnValues.add(new Pair<String, Object>(BaseCmd.Properties.JOB_RESULT_TYPE.getName(), \"text\"));\n                SerializerHelper.appendPairList(returnValues, resultObject, BaseCmd.Properties.JOB_RESULT.getName());\n            } else {\n                returnValues.add(new Pair<String, Object>(BaseCmd.Properties.JOB_RESULT_TYPE.getName(), \"object\"));\n\n                if(result.getCmdOriginator() != null && !result.getCmdOriginator().isEmpty()) {\n                    List<Pair<String, Object>> resultValues = new ArrayList<Pair<String, Object>>();\n                    if (resultObject instanceof NetworkGroupResultObject) {\n                        serializeNetworkGroupResults(resultValues, (NetworkGroupResultObject)resultObject);\n                    } else {\n                        SerializerHelper.appendPairList(resultValues, resultObject, BaseCmd.Properties.JOB_RESULT.getName());\n                    }\n                    returnValues.add(new Pair<String, Object>(result.getCmdOriginator(), new Object[] { resultValues } ));\n                }\n            }\n        } \n        */\n\n        response.setResponseName(getName());\n        return response;\n    }","id":11429,"modified_method":"@Override\n    public ResponseObject getResponse() {\n        AsyncJobResult result = (AsyncJobResult)getResponseObject();\n\n        AsyncJobResponse response = new AsyncJobResponse();\n        response.setId(result.getJobId());\n        response.setJobStatus(result.getJobStatus());\n        response.setJobProcStatus(result.getProcessStatus());\n        response.setJobResultCode(result.getResultCode());\n        response.setJobResult((ResponseObject)SerializerHelper.fromSerializedString(result.getResult()));\n\n        Object resultObject = result.getResultObject();\n        if (resultObject != null) {\n            Class<?> clz = resultObject.getClass();\n            if(clz.isPrimitive() || clz.getSuperclass() == Number.class || clz == String.class || clz == Date.class) {\n                response.setJobResultType(\"text\");\n            } else {\n                response.setJobResultType(\"object\");\n            }\n        }\n\n        /*\n        Object resultObject = result.getResultObject();\n        if (resultObject != null) {\n\n            Class<?> clz = resultObject.getClass();\n            if(clz.isPrimitive() || clz.getSuperclass() == Number.class || clz == String.class || clz == Date.class) {\n                returnValues.add(new Pair<String, Object>(BaseCmd.Properties.JOB_RESULT_TYPE.getName(), \"text\"));\n                SerializerHelper.appendPairList(returnValues, resultObject, BaseCmd.Properties.JOB_RESULT.getName());\n            } else {\n                returnValues.add(new Pair<String, Object>(BaseCmd.Properties.JOB_RESULT_TYPE.getName(), \"object\"));\n\n                if(result.getCmdOriginator() != null && !result.getCmdOriginator().isEmpty()) {\n                    List<Pair<String, Object>> resultValues = new ArrayList<Pair<String, Object>>();\n                    if (resultObject instanceof NetworkGroupResultObject) {\n                        serializeNetworkGroupResults(resultValues, (NetworkGroupResultObject)resultObject);\n                    } else {\n                        SerializerHelper.appendPairList(resultValues, resultObject, BaseCmd.Properties.JOB_RESULT.getName());\n                    }\n                    returnValues.add(new Pair<String, Object>(result.getCmdOriginator(), new Object[] { resultValues } ));\n                }\n            }\n        } \n        */\n\n        response.setResponseName(getName());\n        return response;\n    }","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"public static Object fromSerializedString(String result) {\n\t\ttry {\n\t\t\tif(result != null && !result.isEmpty()) {\n\t\t\t\tint seperatorPos = result.indexOf('/');\n\t\t\t\tif(seperatorPos < 0)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\tString clzName = result.substring(0, seperatorPos);\n\t\t\t\tString content = result.substring(seperatorPos + 1);\n\t\t\t\tClass<?> clz;\n\t\t\t\ttry {\n\t\t\t\t\tclz = Class.forName(clzName);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t    \tGson gson = GsonHelper.getBuilder().create();\n\t\t    \treturn gson.fromJson(content, clz);\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch(RuntimeException e) {\n\t\t\ts_logger.error(\"Caught runtime exception when doing GSON deserialization on: \" + result);\n\t\t\tthrow e; \n\t\t}\n\t}","id":11430,"modified_method":"public static Object fromSerializedString(String result) {\n\t\ttry {\n\t\t\tif(result != null && !result.isEmpty()) {\n\t\t\t    String[] serializedParts = result.split(\"/\");\n//\t\t\t\tint seperatorPos = result.indexOf('/');\n//\t\t\t\tif(seperatorPos < 0)\n//\t\t\t\t\treturn null;\n\n\t\t\t    if (serializedParts.length < 2) {\n\t\t\t        return null;\n\t\t\t    }\n\n//\t\t\t\tString clzName = result.substring(0, seperatorPos);\n//\t\t\t\tString content = result.substring(seperatorPos + 1);\n                String clzName = serializedParts[0];\n                String nameField = null;\n                String content = null;\n                if (serializedParts.length == 2) {\n                    content = serializedParts[1];\n                } else {\n                    nameField = serializedParts[1];\n                    content = serializedParts[2];\n                }\n\n\t\t\t\tClass<?> clz;\n\t\t\t\ttry {\n\t\t\t\t\tclz = Class.forName(clzName);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t    \tGson gson = GsonHelper.getBuilder().create();\n\t\t    \tObject obj = gson.fromJson(content, clz);\n\t\t    \tif (nameField != null) {\n\t\t    \t    ((ResponseObject)obj).setResponseName(nameField);\n\t\t    \t}\n\t\t    \treturn obj;\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch(RuntimeException e) {\n\t\t\ts_logger.error(\"Caught runtime exception when doing GSON deserialization on: \" + result);\n\t\t\tthrow e; \n\t\t}\n\t}","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"public static String toSerializedStringOld(Object result) {\n\t\tif(result != null) {\n\t\t\tClass<?> clz = result.getClass();\n\t    \tGson gson = GsonHelper.getBuilder().create();\n\t    \t\n\t\t\treturn clz.getName() + \"/\" + gson.toJson(result); \n\t\t} \n\t\treturn null;\n\t}","id":11431,"modified_method":"public static String toSerializedStringOld(Object result) {\n\t\tif(result != null) {\n\t\t\tClass<?> clz = result.getClass();\n\t    \tGson gson = GsonHelper.getBuilder().create();\n\n\t    \tif (result instanceof ResponseObject) {\n\t            return clz.getName() + \"/\" + ((ResponseObject)result).getResponseName() + \"/\" + gson.toJson(result); \n\t    \t} else {\n\t            return clz.getName() + \"/\" + gson.toJson(result); \n\t    \t}\n\t\t} \n\t\treturn null;\n\t}","commit_id":"62257d4021f6c381df669e685e4b31a279b80090","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n\t * Handle the current metadata. I.e. do something with it: transition to a splitfile, look up a manifest, etc.\n\t * LOCKING: Synchronized as it changes so many variables; if we want to write the structure to disk, we don't\n\t * want this running at the same time.\n\t * @throws FetchException\n\t * @throws MetadataParseException\n\t * @throws ArchiveFailureException\n\t * @throws ArchiveRestartException\n\t */\n\tprivate synchronized void handleMetadata(final ObjectContainer container, final ClientContext context) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 2);\n\t\t\t// ,1's are probably redundant\n\t\t\tcontainer.activate(metadata, 100);\n\t\t\tcontainer.activate(metaStrings, Integer.MAX_VALUE);\n\t\t\tcontainer.activate(thisKey, 5);\n\t\t\tcontainer.activate(ctx, 2); // for event producer and allowed mime types\n\t\t\tif(ah != null)\n\t\t\t\tah.activateForExecution(container);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(actx, 5);\n\t\t\tcontainer.activate(clientMetadata, 5);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t\tcontainer.activate(returnBucket, 5);\n\t\t}\n\t\tif(uri == null) throw new NullPointerException(); // paranoia\n\t\tsynchronized(this) {\n\t\t\tif(cancelled)\n\t\t\t\treturn;\n\t\t\t// So a SingleKeyListener isn't created.\n\t\t\tfinished = true;\n\t\t}\n\t\twhile(true) {\n\t\t\tif(metadata.isSimpleManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is simple manifest\");\n\t\t\t\tString name;\n\t\t\t\tif(metaStrings.isEmpty())\n\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\telse name = removeMetaString();\n\t\t\t\t// Since metadata is a document, we just replace metadata here\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Next meta-string: \"+name+\" length \"+name.length()+\" for \"+this);\n\t\t\t\tif(name == null) {\n\t\t\t\t\tif(!persistent) {\n\t\t\t\t\t\tmetadata = metadata.getDefaultDocument();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMetadata newMeta = metadata.grabDefaultDocument();\n\t\t\t\t\t\tmetadata.removeFrom(container);\n\t\t\t\t\t\tmetadata = newMeta;\n\t\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\t\tcontainer.store(metaStrings);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\t} else {\n\t\t\t\t\tif(!persistent) {\n\t\t\t\t\t\tmetadata = metadata.getDocument(name);\n\t\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMetadata newMeta = metadata.grabDocument(name);\n\t\t\t\t\t\tmetadata.removeFrom(container);\n\t\t\t\t\t\tmetadata = newMeta;\n\t\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\t\tcontainer.store(metaStrings);\n\t\t\t\t\t\tcontainer.store(thisKey);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_IN_ARCHIVE, \"can't find \"+name);\n\t\t\t\t}\n\t\t\t\tcontinue; // loop\n\t\t\t} else if(metadata.isArchiveManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive manifest (type=\"+metadata.getArchiveType()+\" codec=\"+metadata.getCompressionCodec()+')');\n\t\t\t\tif(metaStrings.isEmpty() && ctx.returnZIPManifests) {\n\t\t\t\t\t// Just return the archive, whole.\n\t\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\t\tif(persistent) container.store(metadata);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// First we need the archive metadata.\n\t\t\t\t// Then parse it. Then we may need to fetch something from inside the archive.\n\t\t\t\t// It's more efficient to keep the existing ah if we can, and it is vital in\n\t\t\t\t// the case of binary blobs.\n\t\t\t\tif(ah == null || !ah.getKey().equals(thisKey))\n\t\t\t\t\tah = context.archiveManager.makeHandler(thisKey, metadata.getArchiveType(), metadata.getCompressionCodec(),\n\t\t\t\t\t\t\t(parent instanceof ClientGetter ? ((ClientGetter)parent).collectingBinaryBlob() : false), persistent);\n\t\t\t\tarchiveMetadata = metadata;\n\t\t\t\tmetadata = null; // Copied to archiveMetadata, so do not need to clear it\n\t\t\t\t// ah is set. This means we are currently handling an archive.\n\t\t\t\tBucket metadataBucket;\n\t\t\t\tmetadataBucket = ah.getMetadata(actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(metadataBucket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmetadata = Metadata.construct(metadataBucket);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t\t}\n\t\t\t\t\tif(persistent) container.store(this);\n\t\t\t\t} else {\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(false, archiveMetadata, ArchiveManager.METADATA_NAME, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tmetadata = Metadata.construct(data);\n\t\t\t\t\t\t\t\twrapHandleMetadata(true, container, context);\n\t\t\t\t\t\t\t} catch (MetadataParseException e) {\n\t\t\t\t\t\t\t\t// Invalid metadata\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"No metadata in container! Cannot happen as ArchiveManager should synthesise some!\"), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context); // will result in this function being called again\n\t\t\t\t\tif(persistent) container.store(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if(metadata.isArchiveInternalRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive-internal redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata());\n\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && clientMetadata.getMIMETypeNoParams() != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(clientMetadata.getMIMETypeNoParams())) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t// Fetch it from the archive\n\t\t\t\tif(ah == null)\n\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Archive redirect not in an archive manifest\");\n\t\t\t\tString filename = metadata.getZIPInternalName();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+filename);\n\t\t\t\tBucket dataBucket = ah.get(filename, actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(dataBucket != null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\tfinal Bucket out;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\tBucketTools.copy(dataBucket, out);\n\t\t\t\t\t\t\tdataBucket.free();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout = dataBucket;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\t// Return the data\n\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching archive (thisKey=\"+thisKey+ ')');\n\t\t\t\t\t// Metadata cannot contain pointers to files which don't exist.\n\t\t\t\t\t// We enforce this in ArchiveHandler.\n\t\t\t\t\t// Therefore, the archive needs to be fetched.\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(true, archiveMetadata, filename, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\t\t\tBucket out;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\t\t\tBucketTools.copy(data, out);\n\t\t\t\t\t\t\t\t\tdata.free();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout = data;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Return the data\n\t\t\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.NOT_IN_ARCHIVE), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context);\n\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\t// Will call back into this function when it has been fetched.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(metadata.isMultiLevelMetadata()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is multi-level metadata\");\n\t\t\t\t// Fetch on a second SingleFileFetcher, like with archives.\n\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(this, metadata, new MultiLevelMetadataCallback(), ctx, container, context);\n\t\t\t\t// Clear our own metadata so it can be garbage collected, it will be replaced by whatever is fetched.\n\t\t\t\t// The new fetcher has our metadata so we don't need to removeMetadata().\n\t\t\t\tthis.metadata = null;\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\tif(persistent) container.store(f);\n\t\t\t\tf.wrapHandleMetadata(true, container, context);\n\t\t\t\tif(persistent) container.deactivate(f, 1);\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSingleFileRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is single-file redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.ARCHIVE_TYPE.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\tif(persistent) container.store(metadata);\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (redirect)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null && \n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Simple redirect\n\t\t\t\t// Just create a new SingleFileFetcher\n\t\t\t\t// Which will then fetch the target URI, and call the rcd.success\n\t\t\t\t// Hopefully!\n\t\t\t\tFreenetURI newURI = metadata.getSingleTarget();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to \"+newURI);\n\t\t\t\tClientKey redirectedKey;\n\t\t\t\ttry {\n\t\t\t\t\tBaseClientKey k = BaseClientKey.getBaseKey(newURI);\n\t\t\t\t\tif(k instanceof ClientKey)\n\t\t\t\t\t\tredirectedKey = (ClientKey) k;\n\t\t\t\t\telse\n\t\t\t\t\t\t// FIXME do we want to allow redirects to USKs?\n\t\t\t\t\t\t// Without redirects to USKs, all SSK and CHKs are static.\n\t\t\t\t\t\t// This may be a desirable property.\n\t\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Redirect to a USK\");\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_URI, e);\n\t\t\t\t}\n\t\t\t\tArrayList<String> newMetaStrings = newURI.listMetaStrings();\n\t\t\t\t\n\t\t\t\t// Move any new meta strings to beginning of our list of remaining meta strings\n\t\t\t\twhile(!newMetaStrings.isEmpty()) {\n\t\t\t\t\tString o = newMetaStrings.remove(newMetaStrings.size()-1);\n\t\t\t\t\tmetaStrings.add(0, o);\n\t\t\t\t\taddedMetaStrings++;\n\t\t\t\t}\n\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(parent, rcb, clientMetadata, redirectedKey, metaStrings, this.uri, addedMetaStrings, ctx, actx, ah, archiveMetadata, maxRetries, recursionLevel, false, token, true, returnBucket, isFinal, container, context);\n\t\t\t\tif((redirectedKey instanceof ClientCHK) && !((ClientCHK)redirectedKey).isMetadata())\n\t\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCOMPRESSOR_TYPE codec = metadata.getCompressionCodec();\n\t\t\t\t\tf.addDecompressor(codec);\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, f, container);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(metaStrings);\n\t\t\t\t\tcontainer.store(f); // Store *before* scheduling to avoid activation problems.\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tf.schedule(container, context);\n\t\t\t\t// All done! No longer our problem!\n\t\t\t\tremoveMetadata(container);\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSplitfile()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching splitfile\");\n\t\t\t\t\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\t\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.ARCHIVE_TYPE.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.store(metadata);\n\t\t\t\t\t\tcontainer.store(clientMetadata);\n\t\t\t\t\t}\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (splitfile)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tlong len = metadata.uncompressedDataLength();\n\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, len, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Splitfile (possibly compressed)\n\t\t\t\t\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCOMPRESSOR_TYPE codec = metadata.getCompressionCodec();\n\t\t\t\t\taddDecompressor(codec);\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.store(decompressors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isFinal && !ctx.ignoreTooManyPathComponents) {\n\t\t\t\t\tif(!metaStrings.isEmpty()) {\n\t\t\t\t\t\t// Some meta-strings left\n\t\t\t\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t\t\t\t// Should this be an error?\n\t\t\t\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t\t\t\t// report to user\n\t\t\t\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, metadata.uncompressedDataLength(), (rcb == parent), clientMetadata.getMIMEType(), tryURI), this, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Just in case...\n\t\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not finished: rcb=\"+rcb+\" for \"+this); \n\t\t\t\t\n\t\t\t\tlong len = metadata.dataLength();\n\t\t\t\tif(metadata.uncompressedDataLength() > len)\n\t\t\t\t\tlen = metadata.uncompressedDataLength();\n\t\t\t\t\n\t\t\t\tif((len > ctx.maxOutputLength) ||\n\t\t\t\t\t\t(len > ctx.maxTempLength)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tboolean compressed = metadata.isCompressed();\n\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\tthrow new FetchException(FetchException.TOO_BIG, len, isFinal && decompressors.size() <= (compressed ? 1 : 0), clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSplitFileFetcher sf = new SplitFileFetcher(metadata, rcb, parent, ctx, \n\t\t\t\t\t\tdecompressors, clientMetadata, actx, recursionLevel, returnBucket, token, container, context);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(sf); // Avoid problems caused by storing a deactivated sf\n\t\t\t\t\tif(!container.ext().isActive(parent)) {\n\t\t\t\t\t\tcontainer.activate(parent, 1);\n\t\t\t\t\t\tLogger.error(this, \"Not active: \"+parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, sf, container);\n\t\t\t\ttry {\n\t\t\t\t\tsf.schedule(container, context);\n\t\t\t\t} catch (KeyListenerConstructionException e) {\n\t\t\t\t\tonFailure(e.getFetchException(), false, container, context);\n\t\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\t// Clear our own metadata, we won't need it any more.\n\t\t\t\t// Note that SplitFileFetcher() above will have used the keys from the metadata,\n\t\t\t\t// and will have removed them from it so they don't get removed here.\n\t\t\t\t// Lack of garbage collection in db4o is a PITA!\n\t\t\t\t// For multi-level metadata etc see above.\n\t\t\t\tremoveMetadata(container);\n\t\t\t\t\n\t\t\t\t// SplitFile will now run.\n\t\t\t\t// Then it will return data to rcd.\n\t\t\t\t// We are now out of the loop. Yay!\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"Don't know what to do with metadata: \"+metadata);\n\t\t\t\tremoveMetadata(container);\n\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA);\n\t\t\t}\n\t\t}\n\t}","id":11432,"modified_method":"/**\n\t * Handle the current metadata. I.e. do something with it: transition to a splitfile, look up a manifest, etc.\n\t * LOCKING: Synchronized as it changes so many variables; if we want to write the structure to disk, we don't\n\t * want this running at the same time.\n\t * @throws FetchException\n\t * @throws MetadataParseException\n\t * @throws ArchiveFailureException\n\t * @throws ArchiveRestartException\n\t */\n\tprivate synchronized void handleMetadata(final ObjectContainer container, final ClientContext context) throws FetchException, MetadataParseException, ArchiveFailureException, ArchiveRestartException {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 2);\n\t\t\t// ,1's are probably redundant\n\t\t\tcontainer.activate(metadata, 100);\n\t\t\tcontainer.activate(metaStrings, Integer.MAX_VALUE);\n\t\t\tcontainer.activate(thisKey, 5);\n\t\t\tcontainer.activate(ctx, 2); // for event producer and allowed mime types\n\t\t\tif(ah != null)\n\t\t\t\tah.activateForExecution(container);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(actx, 5);\n\t\t\tcontainer.activate(clientMetadata, 5);\n\t\t\tcontainer.activate(rcb, 1);\n\t\t\tcontainer.activate(returnBucket, 5);\n\t\t}\n\t\tif(uri == null) {\n\t\t\tif(container != null) {\n\t\t\t\tif(container.ext().isActive(this))\n\t\t\t\t\tthrow new NullPointerException(\"SFI \"+this+\" is active and uri is null!\");\n\t\t\t\telse\n\t\t\t\t\tthrow new NullPointerException(\"SFI \"+this+\" is not active!\");\n\t\t\t} else\n\t\t\t\tthrow new NullPointerException(\"uri = null on transient SFI?? \"+this);\n\t\t}\n\t\tsynchronized(this) {\n\t\t\tif(cancelled)\n\t\t\t\treturn;\n\t\t\t// So a SingleKeyListener isn't created.\n\t\t\tfinished = true;\n\t\t}\n\t\twhile(true) {\n\t\t\tif(metadata.isSimpleManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is simple manifest\");\n\t\t\t\tString name;\n\t\t\t\tif(metaStrings.isEmpty())\n\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\telse name = removeMetaString();\n\t\t\t\t// Since metadata is a document, we just replace metadata here\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Next meta-string: \"+name+\" length \"+name.length()+\" for \"+this);\n\t\t\t\tif(name == null) {\n\t\t\t\t\tif(!persistent) {\n\t\t\t\t\t\tmetadata = metadata.getDefaultDocument();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMetadata newMeta = metadata.grabDefaultDocument();\n\t\t\t\t\t\tmetadata.removeFrom(container);\n\t\t\t\t\t\tmetadata = newMeta;\n\t\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\t\tcontainer.store(metaStrings);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_ENOUGH_PATH_COMPONENTS, -1, false, null, uri.addMetaStrings(new String[] { \"\" }));\n\t\t\t\t} else {\n\t\t\t\t\tif(!persistent) {\n\t\t\t\t\t\tmetadata = metadata.getDocument(name);\n\t\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMetadata newMeta = metadata.grabDocument(name);\n\t\t\t\t\t\tmetadata.removeFrom(container);\n\t\t\t\t\t\tmetadata = newMeta;\n\t\t\t\t\t\tthisKey = thisKey.pushMetaString(name);\n\t\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\t\tcontainer.store(metaStrings);\n\t\t\t\t\t\tcontainer.store(thisKey);\n\t\t\t\t\t}\n\t\t\t\t\tif(metadata == null)\n\t\t\t\t\t\tthrow new FetchException(FetchException.NOT_IN_ARCHIVE, \"can't find \"+name);\n\t\t\t\t}\n\t\t\t\tcontinue; // loop\n\t\t\t} else if(metadata.isArchiveManifest()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive manifest (type=\"+metadata.getArchiveType()+\" codec=\"+metadata.getCompressionCodec()+')');\n\t\t\t\tif(metaStrings.isEmpty() && ctx.returnZIPManifests) {\n\t\t\t\t\t// Just return the archive, whole.\n\t\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\t\tif(persistent) container.store(metadata);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// First we need the archive metadata.\n\t\t\t\t// Then parse it. Then we may need to fetch something from inside the archive.\n\t\t\t\t// It's more efficient to keep the existing ah if we can, and it is vital in\n\t\t\t\t// the case of binary blobs.\n\t\t\t\tif(ah == null || !ah.getKey().equals(thisKey))\n\t\t\t\t\tah = context.archiveManager.makeHandler(thisKey, metadata.getArchiveType(), metadata.getCompressionCodec(),\n\t\t\t\t\t\t\t(parent instanceof ClientGetter ? ((ClientGetter)parent).collectingBinaryBlob() : false), persistent);\n\t\t\t\tarchiveMetadata = metadata;\n\t\t\t\tmetadata = null; // Copied to archiveMetadata, so do not need to clear it\n\t\t\t\t// ah is set. This means we are currently handling an archive.\n\t\t\t\tBucket metadataBucket;\n\t\t\t\tmetadataBucket = ah.getMetadata(actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(metadataBucket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmetadata = Metadata.construct(metadataBucket);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t\t}\n\t\t\t\t\tif(persistent) container.store(this);\n\t\t\t\t} else {\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(false, archiveMetadata, ArchiveManager.METADATA_NAME, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"gotBucket on \"+SingleFileFetcher.this+\" persistent=\"+persistent);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tmetadata = Metadata.construct(data);\n\t\t\t\t\t\t\t\twrapHandleMetadata(true, container, context);\n\t\t\t\t\t\t\t} catch (MetadataParseException e) {\n\t\t\t\t\t\t\t\t// Invalid metadata\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Bucket error?\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, \"No metadata in container! Cannot happen as ArchiveManager should synthesise some!\"), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context); // will result in this function being called again\n\t\t\t\t\tif(persistent) container.store(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if(metadata.isArchiveInternalRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is archive-internal redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata());\n\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && clientMetadata.getMIMETypeNoParams() != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(clientMetadata.getMIMETypeNoParams())) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t// Fetch it from the archive\n\t\t\t\tif(ah == null)\n\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Archive redirect not in an archive manifest\");\n\t\t\t\tString filename = metadata.getZIPInternalName();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+filename);\n\t\t\t\tBucket dataBucket = ah.get(filename, actx, null, recursionLevel+1, true, context.archiveManager);\n\t\t\t\tif(dataBucket != null) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\tfinal Bucket out;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\tBucketTools.copy(dataBucket, out);\n\t\t\t\t\t\t\tdataBucket.free();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout = dataBucket;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\t// Return the data\n\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching archive (thisKey=\"+thisKey+ ')');\n\t\t\t\t\t// Metadata cannot contain pointers to files which don't exist.\n\t\t\t\t\t// We enforce this in ArchiveHandler.\n\t\t\t\t\t// Therefore, the archive needs to be fetched.\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(true, archiveMetadata, filename, new ArchiveExtractCallback() {\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning data\");\n\t\t\t\t\t\t\tBucket out;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Data will not be freed until client is finished with it.\n\t\t\t\t\t\t\t\tif(returnBucket != null) {\n\t\t\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\t\tout = returnBucket;\n\t\t\t\t\t\t\t\t\tBucketTools.copy(data, out);\n\t\t\t\t\t\t\t\t\tdata.free();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout = data;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR), false, container, context);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Return the data\n\t\t\t\t\t\t\tonSuccess(new FetchResult(clientMetadata, out), container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void notInArchive(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.NOT_IN_ARCHIVE), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveRestartException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onFailed(ArchiveFailureException e, ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(e), false, container, context);\n\t\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, container, context);\n\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\t// Will call back into this function when it has been fetched.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(metadata.isMultiLevelMetadata()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is multi-level metadata\");\n\t\t\t\t// Fetch on a second SingleFileFetcher, like with archives.\n\t\t\t\tmetadata.setSimpleRedirect();\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(this, metadata, new MultiLevelMetadataCallback(), ctx, container, context);\n\t\t\t\t// Clear our own metadata so it can be garbage collected, it will be replaced by whatever is fetched.\n\t\t\t\t// The new fetcher has our metadata so we don't need to removeMetadata().\n\t\t\t\tthis.metadata = null;\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\tif(persistent) container.store(f);\n\t\t\t\tf.wrapHandleMetadata(true, container, context);\n\t\t\t\tif(persistent) container.deactivate(f, 1);\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSingleFileRedirect()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Is single-file redirect\");\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.ARCHIVE_TYPE.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\tif(persistent) container.store(metadata);\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (redirect)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null && \n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, -1, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Simple redirect\n\t\t\t\t// Just create a new SingleFileFetcher\n\t\t\t\t// Which will then fetch the target URI, and call the rcd.success\n\t\t\t\t// Hopefully!\n\t\t\t\tFreenetURI newURI = metadata.getSingleTarget();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to \"+newURI);\n\t\t\t\tClientKey redirectedKey;\n\t\t\t\ttry {\n\t\t\t\t\tBaseClientKey k = BaseClientKey.getBaseKey(newURI);\n\t\t\t\t\tif(k instanceof ClientKey)\n\t\t\t\t\t\tredirectedKey = (ClientKey) k;\n\t\t\t\t\telse\n\t\t\t\t\t\t// FIXME do we want to allow redirects to USKs?\n\t\t\t\t\t\t// Without redirects to USKs, all SSK and CHKs are static.\n\t\t\t\t\t\t// This may be a desirable property.\n\t\t\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA, \"Redirect to a USK\");\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_URI, e);\n\t\t\t\t}\n\t\t\t\tArrayList<String> newMetaStrings = newURI.listMetaStrings();\n\t\t\t\t\n\t\t\t\t// Move any new meta strings to beginning of our list of remaining meta strings\n\t\t\t\twhile(!newMetaStrings.isEmpty()) {\n\t\t\t\t\tString o = newMetaStrings.remove(newMetaStrings.size()-1);\n\t\t\t\t\tmetaStrings.add(0, o);\n\t\t\t\t\taddedMetaStrings++;\n\t\t\t\t}\n\n\t\t\t\tfinal SingleFileFetcher f = new SingleFileFetcher(parent, rcb, clientMetadata, redirectedKey, metaStrings, this.uri, addedMetaStrings, ctx, actx, ah, archiveMetadata, maxRetries, recursionLevel, false, token, true, returnBucket, isFinal, container, context);\n\t\t\t\tif((redirectedKey instanceof ClientCHK) && !((ClientCHK)redirectedKey).isMetadata())\n\t\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCOMPRESSOR_TYPE codec = metadata.getCompressionCodec();\n\t\t\t\t\tf.addDecompressor(codec);\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, f, container);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(metaStrings);\n\t\t\t\t\tcontainer.store(f); // Store *before* scheduling to avoid activation problems.\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tf.schedule(container, context);\n\t\t\t\t// All done! No longer our problem!\n\t\t\t\tremoveMetadata(container);\n\t\t\t\treturn;\n\t\t\t} else if(metadata.isSplitfile()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetching splitfile\");\n\t\t\t\t\n\t\t\t\tclientMetadata.mergeNoOverwrite(metadata.getClientMetadata()); // even splitfiles can have mime types!\n\t\t\t\tif(persistent) container.store(clientMetadata);\n\t\t\t\tString mime = clientMetadata.getMIMEType();\n\t\t\t\tif(mime != null) rcb.onExpectedMIME(mime, container);\n\t\t\t\t\n\t\t\t\tString mimeType = clientMetadata.getMIMETypeNoParams();\n\t\t\t\tif(mimeType != null && ArchiveManager.ARCHIVE_TYPE.isUsableArchiveType(mimeType) && metaStrings.size() > 0) {\n\t\t\t\t\t// Looks like an implicit archive, handle as such\n\t\t\t\t\tmetadata.setArchiveManifest();\n\t\t\t\t\t// Pick up MIME type from inside archive\n\t\t\t\t\tclientMetadata.clear();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tcontainer.store(metadata);\n\t\t\t\t\t\tcontainer.store(clientMetadata);\n\t\t\t\t\t}\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Handling implicit container... (splitfile)\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(metaStrings.isEmpty() && isFinal && mimeType != null && ctx.allowedMIMETypes != null &&\n\t\t\t\t\t\t!ctx.allowedMIMETypes.contains(mimeType)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tlong len = metadata.uncompressedDataLength();\n\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\tthrow new FetchException(FetchException.WRONG_MIME_TYPE, len, false, clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Splitfile (possibly compressed)\n\t\t\t\t\n\t\t\t\tif(metadata.isCompressed()) {\n\t\t\t\t\tCOMPRESSOR_TYPE codec = metadata.getCompressionCodec();\n\t\t\t\t\taddDecompressor(codec);\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.store(decompressors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isFinal && !ctx.ignoreTooManyPathComponents) {\n\t\t\t\t\tif(!metaStrings.isEmpty()) {\n\t\t\t\t\t\t// Some meta-strings left\n\t\t\t\t\t\tif(addedMetaStrings > 0) {\n\t\t\t\t\t\t\t// Should this be an error?\n\t\t\t\t\t\t\t// It would be useful to be able to fetch the data ...\n\t\t\t\t\t\t\t// On the other hand such inserts could cause unpredictable results?\n\t\t\t\t\t\t\t// Would be useful to make a redirect to the key we actually fetched.\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.INVALID_METADATA, \"Invalid metadata: too many path components in redirects\", thisKey), this, container, context);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TOO_MANY_PATH_COMPONENTS\n\t\t\t\t\t\t\t// report to user\n\t\t\t\t\t\t\tFreenetURI tryURI = uri;\n\t\t\t\t\t\t\ttryURI = tryURI.dropLastMetaStrings(metaStrings.size());\n\t\t\t\t\t\t\trcb.onFailure(new FetchException(FetchException.TOO_MANY_PATH_COMPONENTS, metadata.uncompressedDataLength(), (rcb == parent), clientMetadata.getMIMEType(), tryURI), this, container, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Just in case...\n\t\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not finished: rcb=\"+rcb+\" for \"+this); \n\t\t\t\t\n\t\t\t\tlong len = metadata.dataLength();\n\t\t\t\tif(metadata.uncompressedDataLength() > len)\n\t\t\t\t\tlen = metadata.uncompressedDataLength();\n\t\t\t\t\n\t\t\t\tif((len > ctx.maxOutputLength) ||\n\t\t\t\t\t\t(len > ctx.maxTempLength)) {\n\t\t\t\t\t// Just in case...\n\t\t\t\t\tboolean compressed = metadata.isCompressed();\n\t\t\t\t\tremoveMetadata(container);\n\t\t\t\t\tthrow new FetchException(FetchException.TOO_BIG, len, isFinal && decompressors.size() <= (compressed ? 1 : 0), clientMetadata.getMIMEType());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSplitFileFetcher sf = new SplitFileFetcher(metadata, rcb, parent, ctx, \n\t\t\t\t\t\tdecompressors, clientMetadata, actx, recursionLevel, returnBucket, token, container, context);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(sf); // Avoid problems caused by storing a deactivated sf\n\t\t\t\t\tif(!container.ext().isActive(parent)) {\n\t\t\t\t\t\tcontainer.activate(parent, 1);\n\t\t\t\t\t\tLogger.error(this, \"Not active: \"+parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparent.onTransition(this, sf, container);\n\t\t\t\ttry {\n\t\t\t\t\tsf.schedule(container, context);\n\t\t\t\t} catch (KeyListenerConstructionException e) {\n\t\t\t\t\tonFailure(e.getFetchException(), false, container, context);\n\t\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(persistent) container.deactivate(sf, 1);\n\t\t\t\trcb.onBlockSetFinished(this, container, context);\n\t\t\t\t// Clear our own metadata, we won't need it any more.\n\t\t\t\t// Note that SplitFileFetcher() above will have used the keys from the metadata,\n\t\t\t\t// and will have removed them from it so they don't get removed here.\n\t\t\t\t// Lack of garbage collection in db4o is a PITA!\n\t\t\t\t// For multi-level metadata etc see above.\n\t\t\t\tremoveMetadata(container);\n\t\t\t\t\n\t\t\t\t// SplitFile will now run.\n\t\t\t\t// Then it will return data to rcd.\n\t\t\t\t// We are now out of the loop. Yay!\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"Don't know what to do with metadata: \"+metadata);\n\t\t\t\tremoveMetadata(container);\n\t\t\t\tthrow new FetchException(FetchException.UNKNOWN_METADATA);\n\t\t\t}\n\t\t}\n\t}","commit_id":"9c901888480728e722a54ef518318e6335afa9f7","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Invoke the following private method\n     * <code>DefaultLifecycleExecutor#getMojoDescriptor(String, MavenSession, MavenProject, String, boolean, boolean)<\/code>\n     *\n     * @param task not null\n     * @param session not null\n     * @param project not null\n     * @param invokedVia not null\n     * @param canUsePrefix not null\n     * @param isOptionalMojo not null\n     * @return MojoDescriptor for the task\n     * @throws MojoFailureException if any\n     * @see DefaultLifecycleExecutor#getMojoDescriptor(String, MavenSession, MavenProject, String, boolean, boolean)\n     */\n    private MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project,\n                                              String invokedVia, boolean canUsePrefix, boolean isOptionalMojo )\n        throws MojoFailureException\n    {\n        try\n        {\n            DefaultLifecycleExecutor lifecycleExecutor =\n                (DefaultLifecycleExecutor) session.lookup( LifecycleExecutor.ROLE );\n\n            Method m =\n                lifecycleExecutor.getClass().getDeclaredMethod(\n                                                                \"getMojoDescriptor\",\n                                                                new Class[] { String.class, MavenSession.class,\n                                                                    MavenProject.class, String.class,\n                                                                    Boolean.TYPE, Boolean.TYPE } );\n            m.setAccessible( true );\n            return (MojoDescriptor) m.invoke( lifecycleExecutor, new Object[] { task, session, project,\n                invokedVia, Boolean.valueOf( canUsePrefix ), Boolean.valueOf( isOptionalMojo ) } );\n        }\n        catch ( SecurityException e )\n        {\n            throw new MojoFailureException( \"SecurityException: \" + e.getMessage() );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new MojoFailureException( \"IllegalArgumentException: \" + e.getMessage() );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MojoFailureException( \"ComponentLookupException: \" + e.getMessage() );\n        }\n        catch ( NoSuchMethodException e )\n        {\n            throw new MojoFailureException( \"NoSuchMethodException: \" + e.getMessage() );\n        }\n        catch ( IllegalAccessException e )\n        {\n            throw new MojoFailureException( \"IllegalAccessException: \" + e.getMessage() );\n        }\n        catch ( InvocationTargetException e )\n        {\n            throw new MojoFailureException( \"InvocationTargetException: \" + e.getMessage() );\n        }\n    }","id":11433,"modified_method":"/**\n     * Invoke the following private method\n     * <code>DefaultLifecycleExecutor#getMojoDescriptor(String, MavenSession, MavenProject, String, boolean, boolean)<\/code>\n     *\n     * @param task not null\n     * @param session not null\n     * @param project not null\n     * @param invokedVia not null\n     * @param canUsePrefix not null\n     * @param isOptionalMojo not null\n     * @return MojoDescriptor for the task\n     * @throws MojoFailureException if any can not invoke the method\n     * @throws MojoExecutionException if no descriptor was found for <code>task<\/code>\n     * @see DefaultLifecycleExecutor#getMojoDescriptor(String, MavenSession, MavenProject, String, boolean, boolean)\n     */\n    private MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project,\n                                              String invokedVia, boolean canUsePrefix, boolean isOptionalMojo )\n        throws MojoFailureException, MojoExecutionException\n    {\n        try\n        {\n            DefaultLifecycleExecutor lifecycleExecutor =\n                (DefaultLifecycleExecutor) session.lookup( LifecycleExecutor.ROLE );\n\n            Method m =\n                lifecycleExecutor.getClass().getDeclaredMethod(\n                                                                \"getMojoDescriptor\",\n                                                                new Class[] { String.class, MavenSession.class,\n                                                                    MavenProject.class, String.class,\n                                                                    Boolean.TYPE, Boolean.TYPE } );\n            m.setAccessible( true );\n            MojoDescriptor mojoDescriptor = (MojoDescriptor) m.invoke( lifecycleExecutor, new Object[] { task, session, project,\n                invokedVia, Boolean.valueOf( canUsePrefix ), Boolean.valueOf( isOptionalMojo ) } );\n            if ( mojoDescriptor == null )\n            {\n                throw new MojoExecutionException( \"No MOJO exists for '\" + task + \"'.\" );\n            }\n            return mojoDescriptor;\n        }\n        catch ( SecurityException e )\n        {\n            throw new MojoFailureException( \"SecurityException: \" + e.getMessage() );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new MojoFailureException( \"IllegalArgumentException: \" + e.getMessage() );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MojoFailureException( \"ComponentLookupException: \" + e.getMessage() );\n        }\n        catch ( NoSuchMethodException e )\n        {\n            throw new MojoFailureException( \"NoSuchMethodException: \" + e.getMessage() );\n        }\n        catch ( IllegalAccessException e )\n        {\n            throw new MojoFailureException( \"IllegalAccessException: \" + e.getMessage() );\n        }\n        catch ( InvocationTargetException e )\n        {\n            Throwable cause = e.getCause();\n\n            if ( cause instanceof BuildFailureException )\n            {\n                throw new MojoFailureException( \"BuildFailureException: \" + cause.getMessage() );\n            }\n            else if ( cause instanceof LifecycleExecutionException )\n            {\n                throw new MojoFailureException( \"LifecycleExecutionException: \" + cause.getMessage() );\n            }\n            else if ( cause instanceof PluginNotFoundException )\n            {\n                throw new MojoFailureException( \"PluginNotFoundException: \" + cause.getMessage() );\n            }\n\n            throw new MojoFailureException( \"InvocationTargetException: \" + e.getMessage() );\n        }\n    }","commit_id":"bd83fb0ed58cc70f5e66799522e542f15980e9cc","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Describe the <code>cmd<\/code> parameter\n     *\n     * @param descriptionBuffer not null\n     * @return <code>true<\/code> if it implies to describe a plugin, <code>false<\/code> otherwise.\n     * @throws MojoFailureException if any\n     */\n    private boolean describeCommand( StringBuffer descriptionBuffer )\n        throws MojoFailureException\n    {\n        if ( cmd.indexOf( \":\" ) == -1 )\n        {\n            // phase\n            try\n            {\n                DefaultLifecycleExecutor lifecycleExecutor =\n                    (DefaultLifecycleExecutor) session.lookup( LifecycleExecutor.ROLE );\n\n                Lifecycle lifecycle = (Lifecycle) lifecycleExecutor.getPhaseToLifecycleMap().get( cmd );\n\n                LifecycleMapping lifecycleMapping =\n                    (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, project.getPackaging() );\n                if ( lifecycle.getDefaultPhases() == null )\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a phase corresponding to this plugin:\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        if ( !key.equals( cmd ) )\n                        {\n                            continue;\n                        }\n\n                        if ( lifecycleMapping.getPhases( \"default\" ).get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycleMapping.getPhases( \"default\" ).get( key ) ).append( \"\\n\" );\n                        }\n                    }\n\n                    descriptionBuffer.append( \"\\n\" );\n                    descriptionBuffer.append(\n                                              \"It is a part of the lifecycle for the POM packaging '\"\n                                                  + project.getPackaging() + \"'. This lifecycle includes the following phases:\" ).append( \"\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \");\n                        String value = (String) lifecycleMapping.getPhases( \"default\" ).get( key );\n                        if ( value != null )\n                        {\n                            for ( StringTokenizer tok = new StringTokenizer( value, \",\" ); tok.hasMoreTokens(); )\n                            {\n                                descriptionBuffer.append( tok.nextToken().trim() );\n\n                                if (!tok.hasMoreTokens())\n                                {\n                                    descriptionBuffer.append( \"\\n\" );\n                                }\n                                else\n                                {\n                                    descriptionBuffer.append( \", \" );\n                                }\n                            }\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n                else\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a lifecycle with the following phases: \" ).append( \"\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \");\n                        if ( lifecycle.getDefaultPhases().get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycle.getDefaultPhases().get( key ) ).append( \"\\n\" );\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new MojoFailureException( \"ComponentLookupException: \" + e.getMessage() );\n            }\n            catch ( LifecycleExecutionException e )\n            {\n                throw new MojoFailureException( \"LifecycleExecutionException: \" + e.getMessage() );\n            }\n\n            return false;\n        }\n\n        // goals\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( cmd, session, project, cmd, true, false );\n\n        descriptionBuffer.append(  \"'\" + cmd + \"' is a plugin\" ).append( \".\\n\" );\n        plugin = mojoDescriptor.getPluginDescriptor().getId();\n\n        return true;\n    }","id":11434,"modified_method":"/**\n     * Describe the <code>cmd<\/code> parameter\n     *\n     * @param descriptionBuffer not null\n     * @return <code>true<\/code> if it implies to describe a plugin, <code>false<\/code> otherwise.\n     * @throws MojoFailureException if any reflection exceptions occur or missing components.\n     * @throws MojoExecutionException if any\n     */\n    private boolean describeCommand( StringBuffer descriptionBuffer )\n        throws MojoFailureException, MojoExecutionException\n    {\n        if ( cmd.indexOf( \":\" ) == -1 )\n        {\n            // phase\n            try\n            {\n                DefaultLifecycleExecutor lifecycleExecutor =\n                    (DefaultLifecycleExecutor) session.lookup( LifecycleExecutor.ROLE );\n\n                Lifecycle lifecycle = (Lifecycle) lifecycleExecutor.getPhaseToLifecycleMap().get( cmd );\n\n                LifecycleMapping lifecycleMapping =\n                    (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, project.getPackaging() );\n                if ( lifecycle.getDefaultPhases() == null )\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a phase corresponding to this plugin:\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        if ( !key.equals( cmd ) )\n                        {\n                            continue;\n                        }\n\n                        if ( lifecycleMapping.getPhases( \"default\" ).get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycleMapping.getPhases( \"default\" ).get( key ) ).append( \"\\n\" );\n                        }\n                    }\n\n                    descriptionBuffer.append( \"\\n\" );\n                    descriptionBuffer.append(\n                                              \"It is a part of the lifecycle for the POM packaging '\"\n                                                  + project.getPackaging() + \"'. This lifecycle includes the following phases:\" ).append( \"\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \");\n                        String value = (String) lifecycleMapping.getPhases( \"default\" ).get( key );\n                        if ( value != null )\n                        {\n                            for ( StringTokenizer tok = new StringTokenizer( value, \",\" ); tok.hasMoreTokens(); )\n                            {\n                                descriptionBuffer.append( tok.nextToken().trim() );\n\n                                if (!tok.hasMoreTokens())\n                                {\n                                    descriptionBuffer.append( \"\\n\" );\n                                }\n                                else\n                                {\n                                    descriptionBuffer.append( \", \" );\n                                }\n                            }\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n                else\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a lifecycle with the following phases: \" ).append( \"\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \");\n                        if ( lifecycle.getDefaultPhases().get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycle.getDefaultPhases().get( key ) ).append( \"\\n\" );\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new MojoFailureException( \"ComponentLookupException: \" + e.getMessage() );\n            }\n            catch ( LifecycleExecutionException e )\n            {\n                throw new MojoFailureException( \"LifecycleExecutionException: \" + e.getMessage() );\n            }\n\n            return false;\n        }\n\n        // goals\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( cmd, session, project, cmd, true, false );\n\n        descriptionBuffer.append(  \"'\" + cmd + \"' is a plugin\" ).append( \".\\n\" );\n        plugin = mojoDescriptor.getPluginDescriptor().getId();\n\n        return true;\n    }","commit_id":"bd83fb0ed58cc70f5e66799522e542f15980e9cc","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method to write the mojo description into the output file\n     *\n     * @param descriptionBuffer contains the description to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeDescription( StringBuffer descriptionBuffer )\n        throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n\n                out = WriterFactory.newPlatformWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n\n                out.flush();\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                if ( out != null )\n                {\n                    try\n                    {\n                        out.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        if ( getLog().isDebugEnabled() )\n                        {\n                            getLog().debug( \"Error closing file output.\", e );\n                        }\n                    }\n                }\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Wrote descriptions to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( descriptionBuffer.toString() );\n            }\n        }\n    }","id":11435,"modified_method":"/**\n     * Method to write the mojo description into the output file\n     *\n     * @param descriptionBuffer contains the description to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeDescription( StringBuffer descriptionBuffer )\n        throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n\n                out = WriterFactory.newPlatformWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n\n                out.flush();\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                IOUtil.close( out );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Wrote descriptions to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( descriptionBuffer.toString() );\n            }\n        }\n    }","commit_id":"bd83fb0ed58cc70f5e66799522e542f15980e9cc","url":"https://github.com/apache/maven-plugins"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public TransactionalObject getTransactionalObject(String serviceName, Object id) {\n        if (transaction.getState() != Transaction.State.ACTIVE) {\n            throw new TransactionNotActiveException(\"No transaction is found while accessing \" +\n                    \"transactional object -> \" + serviceName + \"[\" + id + \"]!\");\n        }\n        TransactionalObjectKey key = new TransactionalObjectKey(serviceName, id);\n        TransactionalObject obj = txnObjectMap.get(key);\n        if (obj == null) {\n            final Object service = nodeEngine.getService(serviceName);\n            if (service instanceof TransactionalService) {\n                nodeEngine.getProxyService().initializeDistributedObject(serviceName, id);\n                obj = ((TransactionalService) service).createTransactionalObject(id, transaction);\n                txnObjectMap.put(key, obj);\n            } else {\n                throw new IllegalArgumentException(\"Service[\" + serviceName + \"] is not transactional!\");\n            }\n        }\n        return obj;\n\n    }","id":11436,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public TransactionalObject getTransactionalObject(String serviceName, Object id) {\n        if (transaction.getState() != Transaction.State.ACTIVE) {\n            throw new TransactionNotActiveException(\"No transaction is found while accessing \" +\n                    \"transactional object -> \" + serviceName + \"[\" + id + \"]!\");\n        }\n        TransactionalObjectKey key = new TransactionalObjectKey(serviceName, id);\n        TransactionalObject obj = txnObjectMap.get(key);\n        if (obj == null) {\n            final Object service = nodeEngine.getService(serviceName);\n            if (service instanceof TransactionalService) {\n                nodeEngine.getProxyService().initializeDistributedObject(serviceName, id);\n                obj = ((TransactionalService) service).createTransactionalObject(id, transaction);\n                txnObjectMap.put(key, obj);\n            } else {\n                if (service == null) {\n                    if (!nodeEngine.isActive()) {\n                        throw new HazelcastInstanceNotActiveException();\n                    }\n                    throw new IllegalArgumentException(\"Unknown Service[\" + serviceName + \"]!\");\n                }\n                throw new IllegalArgumentException(\"Service[\" + serviceName + \"] is not transactional!\");\n            }\n        }\n        return obj;\n\n    }","commit_id":"89f7ab3e12da5cc652a5b56395fb7624db1ae63d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void deliver(VoltMessage message) {\n        if (message instanceof CoalescedHeartbeatMessage) {\n            demuxCoalescedHeartbeatMessage((CoalescedHeartbeatMessage)message);\n            return;\n        }\n        ClientResponseImpl toSend = null;\n        InFlightTxnState state = null;\n        synchronized (m_initiator) {\n            // update the state of seen txnids for each executor\n            if (message instanceof HeartbeatResponseMessage) {\n                HeartbeatResponseMessage hrm = (HeartbeatResponseMessage) message;\n                m_safetyState.updateLastSeenTxnIdFromExecutorBySiteId(\n                        hrm.getExecHSId(), hrm.getLastReceivedTxnId(), hrm.isBlocked());\n                return;\n            }\n\n            // only valid messages are this and heartbeatresponse\n            assert(message instanceof InitiateResponseMessage);\n            final InitiateResponseMessage r = (InitiateResponseMessage) message;\n\n            state = m_pendingTxns.get(r.getTxnId());\n\n            assert(m_hsId == r.getInitiatorHSId());\n\n            // if this is a dummy response, make sure the m_pendingTxns list thinks\n            // the site has been removed from the list\n            if (r.isRecovering()) {\n                toSend = state.addFailedOrRecoveringResponse(r.getCoordinatorHSId());\n            }\n            // otherwise update the InFlightTxnState with the response\n            else {\n                toSend = state.addResponse(r.getCoordinatorHSId(), r.getClientResponseData());\n            }\n\n            if (state.hasAllResponses()) {\n                m_initiator.reduceBackpressure(state.messageSize);\n                m_pendingTxns.remove(r.getTxnId());\n\n                // TODO make this send an error message on failure\n                assert(state.hasSentResponse());\n            }\n        }\n        //Stop moving the response send into the initiator locked section. It isn't necessary,\n        //and several other locks need to be acquired in the network subsystem. Bad voodoo.\n        //addResponse returning non-null means send the response to the client\n        if (toSend != null) {\n            // the next bit is usually a noop, unless we're sampling responses for test\n            if (!state.isReadOnly)\n                ResponseSampler.offerResponse(this.getHSId(), state.txnId, state.invocation, toSend);\n            // queue the response to be sent to the client\n            enqueueResponse(toSend, state);\n        }\n    }","id":11437,"modified_method":"@Override\n    public void deliver(VoltMessage message) {\n        if (message instanceof CoalescedHeartbeatMessage) {\n            demuxCoalescedHeartbeatMessage((CoalescedHeartbeatMessage)message);\n            return;\n        }\n        ClientResponseImpl toSend = null;\n        InFlightTxnState state = null;\n        synchronized (m_initiator) {\n            // update the state of seen txnids for each executor\n            if (message instanceof HeartbeatResponseMessage) {\n                HeartbeatResponseMessage hrm = (HeartbeatResponseMessage) message;\n                m_safetyState.updateLastSeenTxnIdFromExecutorBySiteId(\n                        hrm.getExecHSId(), hrm.getLastReceivedTxnId(), hrm.isBlocked());\n                return;\n            }\n\n            // only valid messages are this and heartbeatresponse\n            assert(message instanceof InitiateResponseMessage);\n            final InitiateResponseMessage r = (InitiateResponseMessage) message;\n\n            state = m_pendingTxns.get(r.getTxnId());\n\n            assert(m_hsId == r.getInitiatorHSId());\n\n            // if this is a dummy response, make sure the m_pendingTxns list thinks\n            // the site has been removed from the list\n            if (r.isRecovering()) {\n                toSend = state.addFailedOrRecoveringResponse(r.getCoordinatorHSId());\n            }\n            // otherwise update the InFlightTxnState with the response\n            else {\n            \tSystem.out.printf(\"!!!!! message class: %s\\n\", message.getClass().getName());\n                toSend = state.addResponse(r.getCoordinatorHSId(), r.getClientResponseData());\n            }\n\n            if (state.hasAllResponses()) {\n                m_initiator.reduceBackpressure(state.messageSize);\n                m_pendingTxns.remove(r.getTxnId());\n\n                // TODO make this send an error message on failure\n                assert(state.hasSentResponse());\n            }\n        }\n        //Stop moving the response send into the initiator locked section. It isn't necessary,\n        //and several other locks need to be acquired in the network subsystem. Bad voodoo.\n        //addResponse returning non-null means send the response to the client\n        if (toSend != null) {\n            // the next bit is usually a noop, unless we're sampling responses for test\n            if (!state.isReadOnly)\n                ResponseSampler.offerResponse(this.getHSId(), state.txnId, state.invocation, toSend);\n            // queue the response to be sent to the client\n            enqueueResponse(toSend, state);\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public ClientResponseImpl addResponse(long coordinatorHSId, ClientResponseImpl r) {\n        // ensure response to send isn't null\n        if (responseToSend == null) responseToSend = r;\n\n        // remove this coordinator from the outstanding list\n        if (outstandingCoordinators != null)\n            outstandingCoordinators.remove(coordinatorHSId);\n\n        outstandingResponses--;\n\n        VoltTable[] currResults = r.getResults();\n\n        // Check that the replica results are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        if (resultsForComparison != null) {\n            VoltTable[] curr_results = r.getResults();\n            if (resultsForComparison.length != curr_results.length)\n            {\n                String msg = \"Mismatched result count received for transaction ID: \" + txnId;\n                msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                msg += \"\\n  from execution site: \" + coordinatorHSId;\n                msg += \"\\n  Expected number of results: \" + resultsForComparison.length;\n                msg += \"\\n  Mismatched number of results: \" + curr_results.length;\n                // die die die\n                VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n                throw new RuntimeException(msg); // gets called only by test code\n            }\n            for (int i = 0; i < resultsForComparison.length; ++i)\n            {\n                if (!curr_results[i].hasSameContents(resultsForComparison[i]))\n                {\n                    String msg = \"Mismatched results received for transaction ID: \" + txnId;\n                    msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                    msg += \"\\n  from execution site: \" + coordinatorHSId;\n                    msg += \"\\n  Expected results: \" + resultsForComparison[i].toString();\n                    msg += \"\\n  Mismatched results: \" + curr_results[i].toString();\n                    // die die die\n                    VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n                    throw new RuntimeException(msg); // gets called only by test code\n                }\n            }\n        }\n        // store these results for any future results to compare to\n        else if (outstandingResponses > 0) {\n            resultsForComparison = new VoltTable[currResults.length];\n            // Create shallow copies of all the VoltTables to avoid\n            // race conditions with the ByteBuffer metadata\n            for (int i = 0; i < currResults.length; ++i)\n            {\n                if (currResults[i] == null) {\n                    resultsForComparison[i] = null;\n                }\n                else {\n                    resultsForComparison[i] = PrivateVoltTableFactory.createVoltTableFromBuffer(\n                            currResults[i].getTableDataReference(), true);\n                }\n            }\n        }\n\n        // decide if it's safe to send a response to the client\n        if (isReadOnly && (!hasSentResponse)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n        else if ((!isReadOnly) && (outstandingResponses == 0)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n\n        // if this is a post-send read or a pre-send write\n        return null;\n    }","id":11438,"modified_method":"public ClientResponseImpl addResponse(long coordinatorHSId, ClientResponseImpl r) {\n        // ensure response to send isn't null\n        if (responseToSend == null) responseToSend = r;\n\n        // remove this coordinator from the outstanding list\n        if (outstandingCoordinators != null)\n            outstandingCoordinators.remove(coordinatorHSId);\n\n        outstandingResponses--;\n\n        VoltTable[] currResults = r.getResults();\n\n        // Check that the replica results are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        // ENG-3288 - Allow read-only transactions to have mismatched results (but log a\n        // warning) so that LIMIT queries without ORDER BY clauses work.\n        if (resultsForComparison != null) {\n            VoltTable[] curr_results = r.getResults();\n            if (resultsForComparison.length != curr_results.length)\n            {\n                String msg = \"Mismatched result count received for transaction ID: \" + txnId;\n                msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                msg += \"\\n  from execution site: \" + coordinatorHSId;\n                msg += \"\\n  Expected number of results: \" + resultsForComparison.length;\n                msg += \"\\n  Mismatched number of results: \" + curr_results.length;\n                msg += \"\\n  Read-only: \" + new Boolean(isReadOnly).toString();\n                if (isReadOnly) {\n                \thostLog.warn(msg);\n                }\n                else {\n\t                // die die die\n\t                VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n\t                throw new RuntimeException(msg); // gets called only by test code\n                }\n            }\n            for (int i = 0; i < resultsForComparison.length; ++i)\n            {\n                if (!curr_results[i].hasSameContents(resultsForComparison[i]))\n                {\n                    String msg = \"Mismatched results received for transaction ID: \" + txnId;\n                    msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                    msg += \"\\n  from execution site: \" + coordinatorHSId;\n                    msg += \"\\n  Expected results: \" + resultsForComparison[i].toString();\n                    msg += \"\\n  Mismatched results: \" + curr_results[i].toString();\n                    msg += \"\\n  Read-only: \" + new Boolean(isReadOnly).toString();\n                    if (isReadOnly) {\n                    \thostLog.warn(msg);\n                    }\n                    else {\n\t                    // die die die\n\t                    VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n\t                    throw new RuntimeException(msg); // gets called only by test code\n                    }\n                }\n            }\n        }\n        // store these results for any future results to compare to\n        else if (outstandingResponses > 0) {\n            resultsForComparison = new VoltTable[currResults.length];\n            // Create shallow copies of all the VoltTables to avoid\n            // race conditions with the ByteBuffer metadata\n            for (int i = 0; i < currResults.length; ++i)\n            {\n                if (currResults[i] == null) {\n                    resultsForComparison[i] = null;\n                }\n                else {\n                    resultsForComparison[i] = PrivateVoltTableFactory.createVoltTableFromBuffer(\n                            currResults[i].getTableDataReference(), true);\n                }\n            }\n        }\n\n        // decide if it's safe to send a response to the client\n        if (isReadOnly && (!hasSentResponse)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n        else if ((!isReadOnly) && (outstandingResponses == 0)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n\n        // if this is a post-send read or a pre-send write\n        return null;\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public MultiPartitionParticipantTxnState(Mailbox mbox, ExecutionSite site,\n                                             TransactionInfoBaseMessage notice)\n    {\n        super(mbox, site, notice);\n        m_hsId = site.getSiteId();\n        m_nonCoordinatingSites = null;\n        m_isCoordinator = false;\n\n        //Check to make sure we are the coordinator, it is possible to get an intiate task\n        //where we aren't the coordinator because we are a replica of the coordinator.\n        if (notice instanceof InitiateTaskMessage) {\n            // keep this around for DR purposes\n            m_invocation = ((InitiateTaskMessage) notice).getStoredProcedureInvocation();\n\n            if (notice.getCoordinatorHSId() == m_hsId) {\n                m_isCoordinator = true;\n                m_task = (InitiateTaskMessage) notice;\n                m_durabilityFlag = m_task.getDurabilityFlagIfItExists();\n                SiteTracker tracker = site.getSiteTracker();\n                // Add this check for tests which use a mock execution site\n                if (tracker != null) {\n                    m_nonCoordinatingSites = tracker.getAllSitesExcluding(m_hsId);\n                }\n                m_readyWorkUnits.add(new WorkUnit(tracker, m_task,\n                                                  null, m_hsId,\n                                                  null, false));\n            } else {\n                m_durabilityFlag = ((InitiateTaskMessage)notice).getDurabilityFlagIfItExists();\n                m_task = null;\n            }\n        }\n        else {\n            m_task = null;\n            m_durabilityFlag = null;\n            m_invocation = null;\n        }\n    }","id":11439,"modified_method":"public MultiPartitionParticipantTxnState(Mailbox mbox, ExecutionSite site,\n                                             TransactionInfoBaseMessage notice)\n    {\n        super(mbox, site, notice);\n        m_hsId = site.getSiteId();\n        m_nonCoordinatingSites = null;\n        m_isCoordinator = false;\n\n        //Check to make sure we are the coordinator, it is possible to get an intiate task\n        //where we aren't the coordinator because we are a replica of the coordinator.\n        if (notice instanceof InitiateTaskMessage) {\n            // keep this around for DR purposes\n            m_invocation = ((InitiateTaskMessage) notice).getStoredProcedureInvocation();\n\n            if (notice.getCoordinatorHSId() == m_hsId) {\n                m_isCoordinator = true;\n                m_task = (InitiateTaskMessage) notice;\n                m_durabilityFlag = m_task.getDurabilityFlagIfItExists();\n                SiteTracker tracker = site.getSiteTracker();\n                // Add this check for tests which use a mock execution site\n                if (tracker != null) {\n                    m_nonCoordinatingSites = tracker.getAllSitesExcluding(m_hsId);\n                }\n                m_readyWorkUnits.add(new WorkUnit(tracker, m_task,\n                                                  null, m_hsId,\n                                                  null, false, m_isReadOnly));\n            } else {\n                m_durabilityFlag = ((InitiateTaskMessage)notice).getDurabilityFlagIfItExists();\n                m_task = null;\n            }\n        }\n        else {\n            m_task = null;\n            m_durabilityFlag = null;\n            m_invocation = null;\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void setupProcedureResume(boolean isFinal, int[] dependencies) {\n        assert(dependencies != null);\n        assert(dependencies.length > 0);\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), null, dependencies,\n                                  m_hsId, m_nonCoordinatingSites, true);\n        if (isFinal)\n            w.nonTransactional = true;\n        for (int depId : dependencies) {\n            if (m_missingDependencies == null) {\n                m_missingDependencies = new HashMap<Integer, WorkUnit>();\n            }\n            // We are missing the dependency: record this fact\n            assert(!m_missingDependencies.containsKey(depId));\n            m_missingDependencies.put(depId, w);\n        }\n        if (m_stackFrameDropWUs == null)\n            m_stackFrameDropWUs = new ArrayList<WorkUnit>();\n        for (WorkUnit sfd : m_stackFrameDropWUs)\n            sfd.m_stackCount++;\n        m_stackFrameDropWUs.add(w);\n\n        // Find any stack frame drop work marked ready in the ready set,\n        // and if it's not really ready, take it out.\n        for (WorkUnit wu : m_readyWorkUnits) {\n            if (wu.shouldResumeProcedure()) {\n                if (wu.m_stackCount > 0)\n                    m_readyWorkUnits.remove(wu);\n            }\n        }\n    }","id":11440,"modified_method":"@Override\n    public void setupProcedureResume(boolean isFinal, int[] dependencies) {\n        assert(dependencies != null);\n        assert(dependencies.length > 0);\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), null, dependencies,\n                                  m_hsId, m_nonCoordinatingSites, true, m_isReadOnly);\n        if (isFinal)\n            w.nonTransactional = true;\n        for (int depId : dependencies) {\n            if (m_missingDependencies == null) {\n                m_missingDependencies = new HashMap<Integer, WorkUnit>();\n            }\n            // We are missing the dependency: record this fact\n            assert(!m_missingDependencies.containsKey(depId));\n            m_missingDependencies.put(depId, w);\n        }\n        if (m_stackFrameDropWUs == null)\n            m_stackFrameDropWUs = new ArrayList<WorkUnit>();\n        for (WorkUnit sfd : m_stackFrameDropWUs)\n            sfd.m_stackCount++;\n        m_stackFrameDropWUs.add(w);\n\n        // Find any stack frame drop work marked ready in the ready set,\n        // and if it's not really ready, take it out.\n        for (WorkUnit wu : m_readyWorkUnits) {\n            if (wu.shouldResumeProcedure()) {\n                if (wu.m_stackCount > 0)\n                    m_readyWorkUnits.remove(wu);\n            }\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void createLocalFragmentWork(FragmentTaskMessage task, boolean nonTransactional) {\n        if (task.getFragmentCount() <= 0) return;\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), task,\n                                  task.getAllUnorderedInputDepIds(),\n                                  m_hsId, m_nonCoordinatingSites, false);\n        w.nonTransactional = nonTransactional;\n\n        for (int i = 0; i < task.getFragmentCount(); i++) {\n            ArrayList<Integer> inputDepIds = task.getInputDepIds(i);\n            if (inputDepIds == null) continue;\n            for (int inputDepId : inputDepIds) {\n                if (m_missingDependencies == null)\n                    m_missingDependencies = new HashMap<Integer, WorkUnit>();\n                assert(!m_missingDependencies.containsKey(inputDepId));\n                m_missingDependencies.put(inputDepId, w);\n            }\n        }\n\n        if (w.allDependenciesSatisfied())\n            m_readyWorkUnits.add(w);\n    }","id":11441,"modified_method":"@Override\n    public void createLocalFragmentWork(FragmentTaskMessage task, boolean nonTransactional) {\n        if (task.getFragmentCount() <= 0) return;\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), task,\n                                  task.getAllUnorderedInputDepIds(),\n                                  m_hsId, m_nonCoordinatingSites, false, m_isReadOnly);\n        w.nonTransactional = nonTransactional;\n\n        for (int i = 0; i < task.getFragmentCount(); i++) {\n            ArrayList<Integer> inputDepIds = task.getInputDepIds(i);\n            if (inputDepIds == null) continue;\n            for (int inputDepId : inputDepIds) {\n                if (m_missingDependencies == null)\n                    m_missingDependencies = new HashMap<Integer, WorkUnit>();\n                assert(!m_missingDependencies.containsKey(inputDepId));\n                m_missingDependencies.put(inputDepId, w);\n            }\n        }\n\n        if (w.allDependenciesSatisfied())\n            m_readyWorkUnits.add(w);\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Call a single partition proc that returns a table with\n     * one row, but with different values at different replicas.\n     */\n    public void testMismatchValueDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_VALUES);\n            fail();\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","id":11442,"modified_method":"/**\n     * Call a single partition proc that returns a table with\n     * one row, but with different values at different replicas.\n     */\n    public void testMismatchValueDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_VALUES);\n            fail(\"R/W value mismatch didn't fail?!\");\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void setUp()\n    {\n        try {\n            VoltProjectBuilder builder = new VoltProjectBuilder();\n            builder.addLiteralSchema(SCHEMA);\n            builder.addPartitionInfo(\"kv\", \"key\");\n            builder.addStmtProcedure(\"Select\", \"select * from kv;\", null);\n            builder.addProcedures(NonDeterministicSPProc.class);\n\n            cluster = new LocalCluster(\"det1.jar\", 1, 2, 1, BackendTarget.NATIVE_EE_JNI);\n            cluster.overrideAnyRequestForValgrind();\n            cluster.compile(builder);\n\n            cluster.setHasLocalServer(false);\n\n            client = ClientFactory.createClient();\n\n            cluster.startUp();\n\n            for (String s : cluster.getListenerAddresses()) {\n                client.createConnection(s);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail();\n        }\n    }","id":11443,"modified_method":"@Override\n    public void setUp()\n    {\n        try {\n            VoltProjectBuilder builder = new VoltProjectBuilder();\n            builder.addLiteralSchema(SCHEMA);\n            builder.addPartitionInfo(\"kv\", \"key\");\n            builder.addProcedures(NonDeterministicSPProc.class,\n            \t\t\t\t\t  NonDeterministic_RO_MP.class,\n            \t\t\t\t\t  NonDeterministic_RO_SP.class);\n\n            cluster = new LocalCluster(\"det1.jar\", 1, 2, 1, BackendTarget.NATIVE_EE_JNI);\n            cluster.overrideAnyRequestForValgrind();\n            assertTrue(\"Catalog compilation failed\", cluster.compile(builder));\n\n            cluster.setHasLocalServer(false);\n\n            client = ClientFactory.createClient();\n\n            cluster.startUp();\n\n            for (String s : cluster.getListenerAddresses()) {\n                client.createConnection(s);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail();\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Call a single-partition proc that returns a different number\n     * of identical rows from two different replicas.\n     */\n    public void testDifferentResultLengthDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_LENGTH);\n            fail();\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","id":11444,"modified_method":"/**\n     * Call a single-partition proc that returns a different number\n     * of identical rows from two different replicas.\n     */\n    public void testDifferentResultLengthDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_LENGTH);\n            fail(\"R/W length mismatch didn't fail?!\");\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testReplicaDependencyWithMismatchedResults()\n    {\n        VoltTable.ColumnInfo[] cols2 =\n        { new VoltTable.ColumnInfo(\"age\", VoltType.INTEGER) };\n\n        VoltTable t3 = new VoltTable(cols2, 1);\n        t3.addRow(11);\n\n        setUpSites(2, 2, 1);\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[] { 1, 2, 3}, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        boolean threw = false;\n        try\n        {\n            w.putDependency(multi_dep, 1, t3, st);\n        }\n        catch (RuntimeException e)\n        {\n            threw = true;\n        }\n        assertTrue(threw);\n    }","id":11445,"modified_method":"public void testReplicaDependencyWithMismatchedResults()\n    {\n        VoltTable.ColumnInfo[] cols2 =\n        { new VoltTable.ColumnInfo(\"age\", VoltType.INTEGER) };\n\n        VoltTable t3 = new VoltTable(cols2, 1);\n        t3.addRow(11);\n\n        setUpSites(2, 2, 1);\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[] { 1, 2, 3}, false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        boolean threw = false;\n        try\n        {\n            w.putDependency(multi_dep, 1, t3, st);\n        }\n        catch (RuntimeException e)\n        {\n            threw = true;\n        }\n        assertTrue(threw);\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testNoDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{}, 0, null, false);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(work, w.getPayload());\n        assertNull(w.getDependencies());\n        assertNull(w.getDependency(0));\n\n        w = new WorkUnit(m_voltdb.getSiteTracker(), work, null,\n                         0, null, false);\n        assertTrue(w.allDependenciesSatisfied());\n    }","id":11446,"modified_method":"public void testNoDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{}, 0, null, false, false);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(work, w.getPayload());\n        assertNull(w.getDependencies());\n        assertNull(w.getDependency(0));\n\n        w = new WorkUnit(m_voltdb.getSiteTracker(), work, null,\n                         0, null, false, false);\n        assertTrue(w.allDependenciesSatisfied());\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDependenciesWithReplicasAndFailure()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                      CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 3)},\n                                      false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.removeSite(CoreUtils.getHSIdFromHostAndSite( 1, 3));\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","id":11447,"modified_method":"public void testDependenciesWithReplicasAndFailure()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                      CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 3)},\n                                      false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.removeSite(CoreUtils.getHSIdFromHostAndSite( 1, 3));\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{CoreUtils.getHSIdFromHostAndSite(0, 1)}, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(multi_dep).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite(0, 1), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","id":11448,"modified_method":"public void testDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{CoreUtils.getHSIdFromHostAndSite(0, 1)}, false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(multi_dep).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite(0, 1), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testBadPutDependencyNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, 5 }, 0L,\n                                  new long[]{1}, false);\n\n        // Put a dependency that does not exist\n        try {\n            w.putDependency(0, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency with a null value\n        try {\n            w.putDependency(4, 0, null, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency twice\n        w.putDependency(4, 0, t1, st);\n        try {\n            w.putDependency(4, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n    }","id":11449,"modified_method":"public void testBadPutDependencyNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, 5 }, 0L,\n                                  new long[]{1}, false, false);\n\n        // Put a dependency that does not exist\n        try {\n            w.putDependency(0, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency with a null value\n        try {\n            w.putDependency(4, 0, null, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency twice\n        w.putDependency(4, 0, t1, st);\n        try {\n            w.putDependency(4, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDependenciesWithReplicas()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                        CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 3)}, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 3), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","id":11450,"modified_method":"public void testDependenciesWithReplicas()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                        CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 3)}, false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 3), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"WorkUnit(SiteTracker siteTracker, VoltMessage payload,\n             int[] dependencyIds, long HSId,\n             long[] nonCoordinatingHSIds,\n             boolean shouldResumeProcedure)\n    {\n        this.m_payload = payload;\n        m_shouldResumeProcedure = shouldResumeProcedure;\n        if (payload != null && payload instanceof FragmentTaskMessage)\n        {\n            m_taskType = ((FragmentTaskMessage) payload).getFragmentTaskType();\n        }\n\n        if (dependencyIds != null && dependencyIds.length > 0) {\n            m_dependencies = new HashMap<Integer, DependencyTracker>();\n            for (int dependency : dependencyIds) {\n                int depsToExpect = 1;\n                HashSet<Long> expected_sites = new HashSet<Long>();\n                expected_sites.add(HSId);\n                if ((dependency & DtxnConstants.MULTIPARTITION_DEPENDENCY) != 0) {\n                    depsToExpect = siteTracker.getAllSites().size();\n                    for (Long hs_id : nonCoordinatingHSIds)\n                    {\n                        expected_sites.add(hs_id);\n                    }\n                }\n                m_dependencies.put(dependency,\n                                   new DependencyTracker(dependency,\n                                                         depsToExpect,\n                                                         expected_sites));\n            }\n        }\n    }","id":11451,"modified_method":"WorkUnit(SiteTracker siteTracker, VoltMessage payload,\n             int[] dependencyIds, long HSId,\n             long[] nonCoordinatingHSIds,\n             boolean shouldResumeProcedure,\n             boolean isReadOnly)\n    {\n        this.m_payload = payload;\n        m_shouldResumeProcedure = shouldResumeProcedure;\n        m_isReadOnly = isReadOnly;\n        if (payload != null && payload instanceof FragmentTaskMessage)\n        {\n            m_taskType = ((FragmentTaskMessage) payload).getFragmentTaskType();\n        }\n\n        if (dependencyIds != null && dependencyIds.length > 0) {\n            m_dependencies = new HashMap<Integer, DependencyTracker>();\n            for (int dependency : dependencyIds) {\n                int depsToExpect = 1;\n                HashSet<Long> expected_sites = new HashSet<Long>();\n                expected_sites.add(HSId);\n                if ((dependency & DtxnConstants.MULTIPARTITION_DEPENDENCY) != 0) {\n                    depsToExpect = siteTracker.getAllSites().size();\n                    for (Long hs_id : nonCoordinatingHSIds)\n                    {\n                        expected_sites.add(hs_id);\n                    }\n                }\n                m_dependencies.put(dependency,\n                                   new DependencyTracker(dependency,\n                                                         depsToExpect,\n                                                         expected_sites));\n            }\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void putDependency(int dependencyId, long HSId, VoltTable payload, SiteTracker st) {\n        assert payload != null;\n        assert m_dependencies != null;\n        assert m_dependencies.containsKey(dependencyId);\n        assert m_dependencies.get(dependencyId) != null;\n\n        int partition = 0;\n        try {\n            partition = st.getPartitionForSite(HSId);\n        } catch (NullPointerException e) {\n            System.out.println(\"NPE on site \" + HSId);\n            throw e;\n        }\n        long map_id = partition;\n        if (m_taskType == FragmentTaskMessage.SYS_PROC_PER_SITE)\n        {\n            map_id = HSId;\n        }\n\n        // Check that the replica fragments are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        boolean duplicate_okay =\n            m_dependencies.get(dependencyId).addResult(HSId, map_id, payload);\n        if (!duplicate_okay)\n        {\n            String msg = \"Mismatched results received for partition: \" + partition;\n            msg += \"\\n  from execution site: \" + HSId;\n            msg += \"\\n  Original results: \" + m_dependencies.get(dependencyId).getResult(map_id).toString();\n            msg += \"\\n  Mismatched results: \" + payload.toString();\n            // die die die (German: the the the)\n            VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n            throw new RuntimeException(msg); // gets called only by test code\n        }\n    }","id":11452,"modified_method":"void putDependency(int dependencyId, long HSId, VoltTable payload, SiteTracker st) {\n        assert payload != null;\n        assert m_dependencies != null;\n        assert m_dependencies.containsKey(dependencyId);\n        assert m_dependencies.get(dependencyId) != null;\n\n        int partition = 0;\n        try {\n            partition = st.getPartitionForSite(HSId);\n        } catch (NullPointerException e) {\n            System.out.println(\"NPE on site \" + HSId);\n            throw e;\n        }\n        long map_id = partition;\n        if (m_taskType == FragmentTaskMessage.SYS_PROC_PER_SITE)\n        {\n            map_id = HSId;\n        }\n\n        // Check that the replica fragments are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        // ENG-3288 - Allow read-only transactions to have mismatched results (but log a\n        // warning) so that LIMIT queries without ORDER BY clauses work.\n        boolean duplicate_okay =\n            m_dependencies.get(dependencyId).addResult(HSId, map_id, payload);\n        if (!duplicate_okay)\n        {\n            String msg = \"Mismatched results received for partition: \" + partition;\n            msg += \"\\n  from execution site: \" + HSId;\n            msg += \"\\n  Original results: \" + m_dependencies.get(dependencyId).getResult(map_id).toString();\n            msg += \"\\n  Mismatched results: \" + payload.toString();\n            msg += \"\\n  Read-only: \" + new Boolean(m_isReadOnly).toString();\n            if (m_isReadOnly) {\n            \thostLog.warn(msg);\n            }\n            else {\n\t            // die die die (German: the the the)\n\t            VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n\t            throw new RuntimeException(msg); // gets called only by test code\n            }\n        }\n    }","commit_id":"d45c803d803801bbf9dac765ee2863349f076a39","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void deliver(VoltMessage message) {\n        if (message instanceof CoalescedHeartbeatMessage) {\n            demuxCoalescedHeartbeatMessage((CoalescedHeartbeatMessage)message);\n            return;\n        }\n        ClientResponseImpl toSend = null;\n        InFlightTxnState state = null;\n        synchronized (m_initiator) {\n            // update the state of seen txnids for each executor\n            if (message instanceof HeartbeatResponseMessage) {\n                HeartbeatResponseMessage hrm = (HeartbeatResponseMessage) message;\n                m_safetyState.updateLastSeenTxnIdFromExecutorBySiteId(\n                        hrm.getExecHSId(), hrm.getLastReceivedTxnId(), hrm.isBlocked());\n                return;\n            }\n\n            // only valid messages are this and heartbeatresponse\n            assert(message instanceof InitiateResponseMessage);\n            final InitiateResponseMessage r = (InitiateResponseMessage) message;\n\n            state = m_pendingTxns.get(r.getTxnId());\n\n            assert(m_hsId == r.getInitiatorHSId());\n\n            // if this is a dummy response, make sure the m_pendingTxns list thinks\n            // the site has been removed from the list\n            if (r.isRecovering()) {\n                toSend = state.addFailedOrRecoveringResponse(r.getCoordinatorHSId());\n            }\n            // otherwise update the InFlightTxnState with the response\n            else {\n                toSend = state.addResponse(r.getCoordinatorHSId(), r.getClientResponseData());\n            }\n\n            if (state.hasAllResponses()) {\n                m_initiator.reduceBackpressure(state.messageSize);\n                m_pendingTxns.remove(r.getTxnId());\n\n                // TODO make this send an error message on failure\n                assert(state.hasSentResponse());\n            }\n        }\n        //Stop moving the response send into the initiator locked section. It isn't necessary,\n        //and several other locks need to be acquired in the network subsystem. Bad voodoo.\n        //addResponse returning non-null means send the response to the client\n        if (toSend != null) {\n            // the next bit is usually a noop, unless we're sampling responses for test\n            if (!state.isReadOnly)\n                ResponseSampler.offerResponse(this.getHSId(), state.txnId, state.invocation, toSend);\n            // queue the response to be sent to the client\n            enqueueResponse(toSend, state);\n        }\n    }","id":11453,"modified_method":"@Override\n    public void deliver(VoltMessage message) {\n        if (message instanceof CoalescedHeartbeatMessage) {\n            demuxCoalescedHeartbeatMessage((CoalescedHeartbeatMessage)message);\n            return;\n        }\n        ClientResponseImpl toSend = null;\n        InFlightTxnState state = null;\n        synchronized (m_initiator) {\n            // update the state of seen txnids for each executor\n            if (message instanceof HeartbeatResponseMessage) {\n                HeartbeatResponseMessage hrm = (HeartbeatResponseMessage) message;\n                m_safetyState.updateLastSeenTxnIdFromExecutorBySiteId(\n                        hrm.getExecHSId(), hrm.getLastReceivedTxnId(), hrm.isBlocked());\n                return;\n            }\n\n            // only valid messages are this and heartbeatresponse\n            assert(message instanceof InitiateResponseMessage);\n            final InitiateResponseMessage r = (InitiateResponseMessage) message;\n\n            state = m_pendingTxns.get(r.getTxnId());\n\n            assert(m_hsId == r.getInitiatorHSId());\n\n            // if this is a dummy response, make sure the m_pendingTxns list thinks\n            // the site has been removed from the list\n            if (r.isRecovering()) {\n                toSend = state.addFailedOrRecoveringResponse(r.getCoordinatorHSId());\n            }\n            // otherwise update the InFlightTxnState with the response\n            else {\n            \tSystem.out.printf(\"!!!!! message class: %s\\n\", message.getClass().getName());\n                toSend = state.addResponse(r.getCoordinatorHSId(), r.getClientResponseData());\n            }\n\n            if (state.hasAllResponses()) {\n                m_initiator.reduceBackpressure(state.messageSize);\n                m_pendingTxns.remove(r.getTxnId());\n\n                // TODO make this send an error message on failure\n                assert(state.hasSentResponse());\n            }\n        }\n        //Stop moving the response send into the initiator locked section. It isn't necessary,\n        //and several other locks need to be acquired in the network subsystem. Bad voodoo.\n        //addResponse returning non-null means send the response to the client\n        if (toSend != null) {\n            // the next bit is usually a noop, unless we're sampling responses for test\n            if (!state.isReadOnly)\n                ResponseSampler.offerResponse(this.getHSId(), state.txnId, state.invocation, toSend);\n            // queue the response to be sent to the client\n            enqueueResponse(toSend, state);\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public ClientResponseImpl addResponse(long coordinatorHSId, ClientResponseImpl r) {\n        // ensure response to send isn't null\n        if (responseToSend == null) responseToSend = r;\n\n        // remove this coordinator from the outstanding list\n        if (outstandingCoordinators != null)\n            outstandingCoordinators.remove(coordinatorHSId);\n\n        outstandingResponses--;\n\n        VoltTable[] currResults = r.getResults();\n\n        // Check that the replica results are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        if (resultsForComparison != null) {\n            VoltTable[] curr_results = r.getResults();\n            if (resultsForComparison.length != curr_results.length)\n            {\n                String msg = \"Mismatched result count received for transaction ID: \" + txnId;\n                msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                msg += \"\\n  from execution site: \" + coordinatorHSId;\n                msg += \"\\n  Expected number of results: \" + resultsForComparison.length;\n                msg += \"\\n  Mismatched number of results: \" + curr_results.length;\n                // die die die\n                VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n                throw new RuntimeException(msg); // gets called only by test code\n            }\n            for (int i = 0; i < resultsForComparison.length; ++i)\n            {\n                if (!curr_results[i].hasSameContents(resultsForComparison[i]))\n                {\n                    String msg = \"Mismatched results received for transaction ID: \" + txnId;\n                    msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                    msg += \"\\n  from execution site: \" + coordinatorHSId;\n                    msg += \"\\n  Expected results: \" + resultsForComparison[i].toString();\n                    msg += \"\\n  Mismatched results: \" + curr_results[i].toString();\n                    // die die die\n                    VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n                    throw new RuntimeException(msg); // gets called only by test code\n                }\n            }\n        }\n        // store these results for any future results to compare to\n        else if (outstandingResponses > 0) {\n            resultsForComparison = new VoltTable[currResults.length];\n            // Create shallow copies of all the VoltTables to avoid\n            // race conditions with the ByteBuffer metadata\n            for (int i = 0; i < currResults.length; ++i)\n            {\n                if (currResults[i] == null) {\n                    resultsForComparison[i] = null;\n                }\n                else {\n                    resultsForComparison[i] = PrivateVoltTableFactory.createVoltTableFromBuffer(\n                            currResults[i].getTableDataReference(), true);\n                }\n            }\n        }\n\n        // decide if it's safe to send a response to the client\n        if (isReadOnly && (!hasSentResponse)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n        else if ((!isReadOnly) && (outstandingResponses == 0)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n\n        // if this is a post-send read or a pre-send write\n        return null;\n    }","id":11454,"modified_method":"public ClientResponseImpl addResponse(long coordinatorHSId, ClientResponseImpl r) {\n        // ensure response to send isn't null\n        if (responseToSend == null) responseToSend = r;\n\n        // remove this coordinator from the outstanding list\n        if (outstandingCoordinators != null)\n            outstandingCoordinators.remove(coordinatorHSId);\n\n        outstandingResponses--;\n\n        VoltTable[] currResults = r.getResults();\n\n        // Check that the replica results are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        // ENG-3288 - Allow read-only transactions to have mismatched results (but log a\n        // warning) so that LIMIT queries without ORDER BY clauses work.\n        if (resultsForComparison != null) {\n            VoltTable[] curr_results = r.getResults();\n            if (resultsForComparison.length != curr_results.length)\n            {\n                String msg = \"Mismatched result count received for transaction ID: \" + txnId;\n                msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                msg += \"\\n  from execution site: \" + coordinatorHSId;\n                msg += \"\\n  Expected number of results: \" + resultsForComparison.length;\n                msg += \"\\n  Mismatched number of results: \" + curr_results.length;\n                msg += \"\\n  Read-only: \" + new Boolean(isReadOnly).toString();\n                if (isReadOnly) {\n                \thostLog.warn(msg);\n                }\n                else {\n\t                // die die die\n\t                VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n\t                throw new RuntimeException(msg); // gets called only by test code\n                }\n            }\n            for (int i = 0; i < resultsForComparison.length; ++i)\n            {\n                if (!curr_results[i].hasSameContents(resultsForComparison[i]))\n                {\n                    String msg = \"Mismatched results received for transaction ID: \" + txnId;\n                    msg += \"\\n  while executing stored procedure: \" + invocation.getProcName();\n                    msg += \"\\n  from execution site: \" + coordinatorHSId;\n                    msg += \"\\n  Expected results: \" + resultsForComparison[i].toString();\n                    msg += \"\\n  Mismatched results: \" + curr_results[i].toString();\n                    msg += \"\\n  Read-only: \" + new Boolean(isReadOnly).toString();\n                    if (isReadOnly) {\n                    \thostLog.warn(msg);\n                    }\n                    else {\n\t                    // die die die\n\t                    VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n\t                    throw new RuntimeException(msg); // gets called only by test code\n                    }\n                }\n            }\n        }\n        // store these results for any future results to compare to\n        else if (outstandingResponses > 0) {\n            resultsForComparison = new VoltTable[currResults.length];\n            // Create shallow copies of all the VoltTables to avoid\n            // race conditions with the ByteBuffer metadata\n            for (int i = 0; i < currResults.length; ++i)\n            {\n                if (currResults[i] == null) {\n                    resultsForComparison[i] = null;\n                }\n                else {\n                    resultsForComparison[i] = PrivateVoltTableFactory.createVoltTableFromBuffer(\n                            currResults[i].getTableDataReference(), true);\n                }\n            }\n        }\n\n        // decide if it's safe to send a response to the client\n        if (isReadOnly && (!hasSentResponse)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n        else if ((!isReadOnly) && (outstandingResponses == 0)) {\n            hasSentResponse = true;\n            return responseToSend;\n        }\n\n        // if this is a post-send read or a pre-send write\n        return null;\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void setupProcedureResume(boolean isFinal, int[] dependencies) {\n        assert(dependencies != null);\n        assert(dependencies.length > 0);\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), null, dependencies,\n                                  m_hsId, m_nonCoordinatingSites, true);\n        if (isFinal)\n            w.nonTransactional = true;\n        for (int depId : dependencies) {\n            if (m_missingDependencies == null) {\n                m_missingDependencies = new HashMap<Integer, WorkUnit>();\n            }\n            // We are missing the dependency: record this fact\n            assert(!m_missingDependencies.containsKey(depId));\n            m_missingDependencies.put(depId, w);\n        }\n        if (m_stackFrameDropWUs == null)\n            m_stackFrameDropWUs = new ArrayList<WorkUnit>();\n        for (WorkUnit sfd : m_stackFrameDropWUs)\n            sfd.m_stackCount++;\n        m_stackFrameDropWUs.add(w);\n\n        // Find any stack frame drop work marked ready in the ready set,\n        // and if it's not really ready, take it out.\n        for (WorkUnit wu : m_readyWorkUnits) {\n            if (wu.shouldResumeProcedure()) {\n                if (wu.m_stackCount > 0)\n                    m_readyWorkUnits.remove(wu);\n            }\n        }\n    }","id":11455,"modified_method":"@Override\n    public void setupProcedureResume(boolean isFinal, int[] dependencies) {\n        assert(dependencies != null);\n        assert(dependencies.length > 0);\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), null, dependencies,\n                                  m_hsId, m_nonCoordinatingSites, true, m_isReadOnly);\n        if (isFinal)\n            w.nonTransactional = true;\n        for (int depId : dependencies) {\n            if (m_missingDependencies == null) {\n                m_missingDependencies = new HashMap<Integer, WorkUnit>();\n            }\n            // We are missing the dependency: record this fact\n            assert(!m_missingDependencies.containsKey(depId));\n            m_missingDependencies.put(depId, w);\n        }\n        if (m_stackFrameDropWUs == null)\n            m_stackFrameDropWUs = new ArrayList<WorkUnit>();\n        for (WorkUnit sfd : m_stackFrameDropWUs)\n            sfd.m_stackCount++;\n        m_stackFrameDropWUs.add(w);\n\n        // Find any stack frame drop work marked ready in the ready set,\n        // and if it's not really ready, take it out.\n        for (WorkUnit wu : m_readyWorkUnits) {\n            if (wu.shouldResumeProcedure()) {\n                if (wu.m_stackCount > 0)\n                    m_readyWorkUnits.remove(wu);\n            }\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public MultiPartitionParticipantTxnState(Mailbox mbox, ExecutionSite site,\n                                             TransactionInfoBaseMessage notice)\n    {\n        super(mbox, site, notice);\n        m_hsId = site.getSiteId();\n        m_nonCoordinatingSites = null;\n        m_isCoordinator = false;\n        //Check to make sure we are the coordinator, it is possible to get an intiate task\n        //where we aren't the coordinator because we are a replica of the coordinator.\n        if (notice instanceof InitiateTaskMessage)\n        {\n            // keep this around for DR purposes\n            m_invocation = ((InitiateTaskMessage) notice).getStoredProcedureInvocation();\n\n            if (notice.getCoordinatorHSId() == m_hsId) {\n                m_isCoordinator = true;\n                m_task = (InitiateTaskMessage) notice;\n                m_durabilityFlag = m_task.getDurabilityFlagIfItExists();\n                SiteTracker tracker = site.getSiteTracker();\n                // Add this check for tests which use a mock execution site\n                if (tracker != null) {\n                    m_nonCoordinatingSites = tracker.getAllSitesExcluding(m_hsId);\n                }\n                m_readyWorkUnits.add(new WorkUnit(tracker, m_task,\n                                                  null, m_hsId,\n                                                  null, false));\n            } else {\n                m_durabilityFlag = ((InitiateTaskMessage)notice).getDurabilityFlagIfItExists();\n                m_task = null;\n            }\n        } else {\n            m_task = null;\n            m_durabilityFlag = null;\n            m_invocation = null;\n        }\n    }","id":11456,"modified_method":"public MultiPartitionParticipantTxnState(Mailbox mbox, ExecutionSite site,\n                                             TransactionInfoBaseMessage notice)\n    {\n        super(mbox, site, notice);\n        m_hsId = site.getSiteId();\n        m_nonCoordinatingSites = null;\n        m_isCoordinator = false;\n        //Check to make sure we are the coordinator, it is possible to get an intiate task\n        //where we aren't the coordinator because we are a replica of the coordinator.\n        if (notice instanceof InitiateTaskMessage)\n        {\n            // keep this around for DR purposes\n            m_invocation = ((InitiateTaskMessage) notice).getStoredProcedureInvocation();\n\n            if (notice.getCoordinatorHSId() == m_hsId) {\n                m_isCoordinator = true;\n                m_task = (InitiateTaskMessage) notice;\n                m_durabilityFlag = m_task.getDurabilityFlagIfItExists();\n                SiteTracker tracker = site.getSiteTracker();\n                // Add this check for tests which use a mock execution site\n                if (tracker != null) {\n                    m_nonCoordinatingSites = tracker.getAllSitesExcluding(m_hsId);\n                }\n                m_readyWorkUnits.add(new WorkUnit(tracker, m_task,\n                                                  null, m_hsId,\n                                                  null, false, m_isReadOnly));\n            } else {\n                m_durabilityFlag = ((InitiateTaskMessage)notice).getDurabilityFlagIfItExists();\n                m_task = null;\n            }\n        } else {\n            m_task = null;\n            m_durabilityFlag = null;\n            m_invocation = null;\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void createLocalFragmentWorkDependencies(FragmentTaskMessage task, boolean nonTransactional)\n    {\n        if (task.getFragmentCount() <= 0) return;\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), task,\n                                  task.getAllUnorderedInputDepIds(),\n                                  m_hsId, m_nonCoordinatingSites, false);\n        w.nonTransactional = nonTransactional;\n\n        for (int i = 0; i < task.getFragmentCount(); i++) {\n            ArrayList<Integer> inputDepIds = task.getInputDepIds(i);\n            if (inputDepIds == null) continue;\n            for (int inputDepId : inputDepIds) {\n                if (m_missingDependencies == null)\n                    m_missingDependencies = new HashMap<Integer, WorkUnit>();\n                assert(!m_missingDependencies.containsKey(inputDepId));\n                m_missingDependencies.put(inputDepId, w);\n            }\n        }\n\n        if (w.allDependenciesSatisfied())\n            m_readyWorkUnits.add(w);\n    }","id":11457,"modified_method":"private void createLocalFragmentWorkDependencies(FragmentTaskMessage task, boolean nonTransactional)\n    {\n        if (task.getFragmentCount() <= 0) return;\n\n        WorkUnit w = new WorkUnit(m_site.getSiteTracker(), task,\n                                  task.getAllUnorderedInputDepIds(),\n                                  m_hsId, m_nonCoordinatingSites, false, m_isReadOnly);\n        w.nonTransactional = nonTransactional;\n\n        for (int i = 0; i < task.getFragmentCount(); i++) {\n            ArrayList<Integer> inputDepIds = task.getInputDepIds(i);\n            if (inputDepIds == null) continue;\n            for (int inputDepId : inputDepIds) {\n                if (m_missingDependencies == null)\n                    m_missingDependencies = new HashMap<Integer, WorkUnit>();\n                assert(!m_missingDependencies.containsKey(inputDepId));\n                m_missingDependencies.put(inputDepId, w);\n            }\n        }\n\n        if (w.allDependenciesSatisfied())\n            m_readyWorkUnits.add(w);\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void setUp()\n    {\n        try {\n            VoltProjectBuilder builder = new VoltProjectBuilder();\n            builder.addLiteralSchema(SCHEMA);\n            builder.addPartitionInfo(\"kv\", \"key\");\n            builder.addStmtProcedure(\"Select\", \"select * from kv;\", null);\n            builder.addProcedures(NonDeterministicSPProc.class);\n\n            cluster = new LocalCluster(\"det1.jar\", 1, 2, 1, BackendTarget.NATIVE_EE_JNI);\n            cluster.overrideAnyRequestForValgrind();\n            cluster.compile(builder);\n\n            cluster.setHasLocalServer(false);\n\n            client = ClientFactory.createClient();\n\n            cluster.startUp();\n\n            for (String s : cluster.getListenerAddresses()) {\n                client.createConnection(s);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail();\n        }\n    }","id":11458,"modified_method":"@Override\n    public void setUp()\n    {\n        try {\n            VoltProjectBuilder builder = new VoltProjectBuilder();\n            builder.addLiteralSchema(SCHEMA);\n            builder.addPartitionInfo(\"kv\", \"key\");\n            builder.addProcedures(NonDeterministicSPProc.class,\n            \t\t\t\t\t  NonDeterministic_RO_MP.class,\n            \t\t\t\t\t  NonDeterministic_RO_SP.class);\n\n            cluster = new LocalCluster(\"det1.jar\", 1, 2, 1, BackendTarget.NATIVE_EE_JNI);\n            cluster.overrideAnyRequestForValgrind();\n            assertTrue(\"Catalog compilation failed\", cluster.compile(builder));\n\n            cluster.setHasLocalServer(false);\n\n            client = ClientFactory.createClient();\n\n            cluster.startUp();\n\n            for (String s : cluster.getListenerAddresses()) {\n                client.createConnection(s);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail();\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Call a single partition proc that returns a table with\n     * one row, but with different values at different replicas.\n     */\n    public void testMismatchValueDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_VALUES);\n            fail();\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","id":11459,"modified_method":"/**\n     * Call a single partition proc that returns a table with\n     * one row, but with different values at different replicas.\n     */\n    public void testMismatchValueDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_VALUES);\n            fail(\"R/W value mismatch didn't fail?!\");\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Call a single-partition proc that returns a different number\n     * of identical rows from two different replicas.\n     */\n    public void testDifferentResultLengthDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_LENGTH);\n            fail();\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","id":11460,"modified_method":"/**\n     * Call a single-partition proc that returns a different number\n     * of identical rows from two different replicas.\n     */\n    public void testDifferentResultLengthDeath() throws Exception {\n        try {\n            client.callProcedure(\n                    \"NonDeterministicSPProc\",\n                    0,\n                    NonDeterministicSPProc.MISMATCH_LENGTH);\n            fail(\"R/W length mismatch didn't fail?!\");\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().contains(\"Connection to database\"));\n            // success!\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDependenciesWithReplicasAndFailure()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                      CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 3)},\n                                      false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.removeSite(CoreUtils.getHSIdFromHostAndSite( 1, 3));\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","id":11461,"modified_method":"public void testDependenciesWithReplicasAndFailure()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                      CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                      CoreUtils.getHSIdFromHostAndSite( 1, 3)},\n                                      false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.removeSite(CoreUtils.getHSIdFromHostAndSite( 1, 3));\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDependenciesWithReplicas()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                        CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 3)}, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 3), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","id":11462,"modified_method":"public void testDependenciesWithReplicas()\n    {\n        setUpSites(2, 2, 2);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{\n                                        CoreUtils.getHSIdFromHostAndSite( 0, 1),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 2),\n                                        CoreUtils.getHSIdFromHostAndSite( 1, 3)}, false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 0, 1), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 2), t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite( 1, 3), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(1, w.getDependency(4).size());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(2, w.getDependency(multi_dep).size());\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testBadPutDependencyNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, 5 }, 0L,\n                                  new long[]{1}, false);\n\n        // Put a dependency that does not exist\n        try {\n            w.putDependency(0, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency with a null value\n        try {\n            w.putDependency(4, 0, null, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency twice\n        w.putDependency(4, 0, t1, st);\n        try {\n            w.putDependency(4, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n    }","id":11463,"modified_method":"public void testBadPutDependencyNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, 5 }, 0L,\n                                  new long[]{1}, false, false);\n\n        // Put a dependency that does not exist\n        try {\n            w.putDependency(0, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency with a null value\n        try {\n            w.putDependency(4, 0, null, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n\n        // Put a dependency twice\n        w.putDependency(4, 0, t1, st);\n        try {\n            w.putDependency(4, 0, t1, st);\n            fail(\"assertion expected\");\n        } catch (AssertionError e) {}\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testReplicaDependencyWithMismatchedResults()\n    {\n        VoltTable.ColumnInfo[] cols2 =\n        { new VoltTable.ColumnInfo(\"age\", VoltType.INTEGER) };\n\n        VoltTable t3 = new VoltTable(cols2, 1);\n        t3.addRow(11);\n\n        setUpSites(2, 2, 1);\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[] { 1, 2, 3}, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        boolean threw = false;\n        try\n        {\n            w.putDependency(multi_dep, 1, t3, st);\n        }\n        catch (RuntimeException e)\n        {\n            threw = true;\n        }\n        assertTrue(threw);\n    }","id":11464,"modified_method":"public void testReplicaDependencyWithMismatchedResults()\n    {\n        VoltTable.ColumnInfo[] cols2 =\n        { new VoltTable.ColumnInfo(\"age\", VoltType.INTEGER) };\n\n        VoltTable t3 = new VoltTable(cols2, 1);\n        t3.addRow(11);\n\n        setUpSites(2, 2, 1);\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[] { 1, 2, 3}, false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(5).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        boolean threw = false;\n        try\n        {\n            w.putDependency(multi_dep, 1, t3, st);\n        }\n        catch (RuntimeException e)\n        {\n            threw = true;\n        }\n        assertTrue(threw);\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testNoDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{}, 0, null, false);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(work, w.getPayload());\n        assertNull(w.getDependencies());\n        assertNull(w.getDependency(0));\n\n        w = new WorkUnit(m_voltdb.getSiteTracker(), work, null,\n                         0, null, false);\n        assertTrue(w.allDependenciesSatisfied());\n    }","id":11465,"modified_method":"public void testNoDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{}, 0, null, false, false);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(work, w.getPayload());\n        assertNull(w.getDependencies());\n        assertNull(w.getDependency(0));\n\n        w = new WorkUnit(m_voltdb.getSiteTracker(), work, null,\n                         0, null, false, false);\n        assertTrue(w.allDependenciesSatisfied());\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{CoreUtils.getHSIdFromHostAndSite(0, 1)}, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(multi_dep).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite(0, 1), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","id":11466,"modified_method":"public void testDependenciesNoReplicas() {\n        setUpSites(1, 2, 1);\n        System.out.println(m_voltdb.getCatalogContext().catalog.serialize());\n        int multi_dep = 5 | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n        WorkUnit w = new WorkUnit(m_voltdb.getSiteTracker(),\n                                  work, new int[]{ 4, multi_dep }, 0L,\n                                  new long[]{CoreUtils.getHSIdFromHostAndSite(0, 1)}, false, false);\n        assertFalse(w.allDependenciesSatisfied());\n        assertEquals(w.getDependency(4).size(), 0);\n        assertEquals(w.getDependency(multi_dep).size(), 0);\n        w.putDependency(4, 0, t1, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, 0, t2, st);\n        assertFalse(w.allDependenciesSatisfied());\n        w.putDependency(multi_dep, CoreUtils.getHSIdFromHostAndSite(0, 1), t2, st);\n        assertTrue(w.allDependenciesSatisfied());\n        assertEquals(t1, w.getDependency(4).get(0));\n        assertEquals(t2, w.getDependency(multi_dep).get(0));\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"WorkUnit(SiteTracker siteTracker, VoltMessage payload,\n             int[] dependencyIds, long HSId,\n             long[] nonCoordinatingHSIds,\n             boolean shouldResumeProcedure)\n    {\n        this.m_payload = payload;\n        m_shouldResumeProcedure = shouldResumeProcedure;\n        if (payload != null && payload instanceof FragmentTaskMessage)\n        {\n            m_taskType = ((FragmentTaskMessage) payload).getFragmentTaskType();\n        }\n\n        if (dependencyIds != null && dependencyIds.length > 0) {\n            m_dependencies = new HashMap<Integer, DependencyTracker>();\n            for (int dependency : dependencyIds) {\n                int depsToExpect = 1;\n                HashSet<Long> expected_sites = new HashSet<Long>();\n                expected_sites.add(HSId);\n                if ((dependency & DtxnConstants.MULTIPARTITION_DEPENDENCY) != 0) {\n                    depsToExpect = siteTracker.getAllSites().size();\n                    for (Long hs_id : nonCoordinatingHSIds)\n                    {\n                        expected_sites.add(hs_id);\n                    }\n                }\n                m_dependencies.put(dependency,\n                                   new DependencyTracker(dependency,\n                                                         depsToExpect,\n                                                         expected_sites));\n            }\n        }\n    }","id":11467,"modified_method":"WorkUnit(SiteTracker siteTracker, VoltMessage payload,\n             int[] dependencyIds, long HSId,\n             long[] nonCoordinatingHSIds,\n             boolean shouldResumeProcedure,\n             boolean isReadOnly)\n    {\n        this.m_payload = payload;\n        m_shouldResumeProcedure = shouldResumeProcedure;\n        m_isReadOnly = isReadOnly;\n        if (payload != null && payload instanceof FragmentTaskMessage)\n        {\n            m_taskType = ((FragmentTaskMessage) payload).getFragmentTaskType();\n        }\n\n        if (dependencyIds != null && dependencyIds.length > 0) {\n            m_dependencies = new HashMap<Integer, DependencyTracker>();\n            for (int dependency : dependencyIds) {\n                int depsToExpect = 1;\n                HashSet<Long> expected_sites = new HashSet<Long>();\n                expected_sites.add(HSId);\n                if ((dependency & DtxnConstants.MULTIPARTITION_DEPENDENCY) != 0) {\n                    depsToExpect = siteTracker.getAllSites().size();\n                    for (Long hs_id : nonCoordinatingHSIds)\n                    {\n                        expected_sites.add(hs_id);\n                    }\n                }\n                m_dependencies.put(dependency,\n                                   new DependencyTracker(dependency,\n                                                         depsToExpect,\n                                                         expected_sites));\n            }\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void putDependency(int dependencyId, long HSId, VoltTable payload, SiteTracker st) {\n        assert payload != null;\n        assert m_dependencies != null;\n        assert m_dependencies.containsKey(dependencyId);\n        assert m_dependencies.get(dependencyId) != null;\n\n        int partition = 0;\n        try {\n            partition = st.getPartitionForSite(HSId);\n        } catch (NullPointerException e) {\n            System.out.println(\"NPE on site \" + HSId);\n            throw e;\n        }\n        long map_id = partition;\n        if (m_taskType == FragmentTaskMessage.SYS_PROC_PER_SITE)\n        {\n            map_id = HSId;\n        }\n\n        // Check that the replica fragments are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        boolean duplicate_okay =\n            m_dependencies.get(dependencyId).addResult(HSId, map_id, payload);\n        if (!duplicate_okay)\n        {\n            String msg = \"Mismatched results received for partition: \" + partition;\n            msg += \"\\n  from execution site: \" + HSId;\n            msg += \"\\n  Original results: \" + m_dependencies.get(dependencyId).getResult(map_id).toString();\n            msg += \"\\n  Mismatched results: \" + payload.toString();\n            // die die die (German: the the the)\n            VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n            throw new RuntimeException(msg); // gets called only by test code\n        }\n    }","id":11468,"modified_method":"void putDependency(int dependencyId, long HSId, VoltTable payload, SiteTracker st) {\n        assert payload != null;\n        assert m_dependencies != null;\n        assert m_dependencies.containsKey(dependencyId);\n        assert m_dependencies.get(dependencyId) != null;\n\n        int partition = 0;\n        try {\n            partition = st.getPartitionForSite(HSId);\n        } catch (NullPointerException e) {\n            System.out.println(\"NPE on site \" + HSId);\n            throw e;\n        }\n        long map_id = partition;\n        if (m_taskType == FragmentTaskMessage.SYS_PROC_PER_SITE)\n        {\n            map_id = HSId;\n        }\n\n        // Check that the replica fragments are the same (non-deterministic SQL)\n        // (Note that this applies for k > 0)\n        // If not same, kill entire cluster and hide the bodies.\n        // In all seriousness, we have no valid way to recover from a non-deterministic event\n        // The safest thing is to make the user aware and stop doing potentially corrupt work.\n        // ENG-3288 - Allow read-only transactions to have mismatched results (but log a\n        // warning) so that LIMIT queries without ORDER BY clauses work.\n        boolean duplicate_okay =\n            m_dependencies.get(dependencyId).addResult(HSId, map_id, payload);\n        if (!duplicate_okay)\n        {\n            String msg = \"Mismatched results received for partition: \" + partition;\n            msg += \"\\n  from execution site: \" + HSId;\n            msg += \"\\n  Original results: \" + m_dependencies.get(dependencyId).getResult(map_id).toString();\n            msg += \"\\n  Mismatched results: \" + payload.toString();\n            msg += \"\\n  Read-only: \" + new Boolean(m_isReadOnly).toString();\n            if (m_isReadOnly) {\n            \thostLog.warn(msg);\n            }\n            else {\n\t            // die die die (German: the the the)\n\t            VoltDB.crashGlobalVoltDB(msg, false, null); // kills process\n\t            throw new RuntimeException(msg); // gets called only by test code\n            }\n        }\n    }","commit_id":"40909a4cae83cf465c9ea3fab8a8fa0f3dd2e651","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private String getDefaultResponseRange(String url) {\n        if (url == null || url.equals(DEFAULT_URL)) {\n            return \"100-499\";\n        }\n        return \"100-399\";\n    }","id":11469,"modified_method":"private String determineDefaultResponseRange(String url) {\n        if (url == null || url.equals(DEFAULT_URL)) {\n            return \"100-499\";\n        }\n        return \"100-399\";\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getUrl(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"url\", DEFAULT_URL);\n    }","id":11470,"modified_method":"private String determineUrl(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"url\", DEFAULT_URL);\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponseText(final Map<String, String> parameters) {\n        String responseText = ParameterMap.getKeyedString(parameters, \"response-text\", null);\n        if (responseText == null) {\n            //try depricated parameter\n            responseText = ParameterMap.getKeyedString(parameters, \"response text\", null);\n        }\n        return responseText;\n    }","id":11471,"modified_method":"private String determineResponseText(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response-text\", null);\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected int[] getPorts(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","id":11472,"modified_method":"protected int[] determinePorts(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getHeader(final Map<String, String> parameters, String key) {\n        return ParameterMap.getKeyedString(parameters, key, null);\n    }","id":11473,"modified_method":"private String determineHttpHeader(final Map<String, String> parameters, String key) {\n        return ParameterMap.getKeyedString(parameters, key, null);\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private boolean isVerbose(final Map<String, String> parameters) {\n        final String verbose = ParameterMap.getKeyedString(parameters, \"verbose\", null);\n        return (verbose != null && verbose.equalsIgnoreCase(\"true\")) ? true : false;\n    }","id":11474,"modified_method":"private boolean determineVerbosity(final Map<String, String> parameters) {\n        final String verbose = ParameterMap.getKeyedString(parameters, \"verbose\", null);\n        return (verbose != null && verbose.equalsIgnoreCase(\"true\")) ? true : false;\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getUserAgent(final Map<String, String> parameters) {\n        String agent = ParameterMap.getKeyedString(parameters, \"user-agent\", null);\n        if (agent == null || \"\".equals(agent)) {\n            return \"OpenNMS HttpMonitor\";\n        }\n        return agent;\n    }","id":11475,"modified_method":"private String determineUserAgent(final Map<String, String> parameters) {\n        String agent = ParameterMap.getKeyedString(parameters, \"user-agent\", null);\n        if (isBlank(agent)) {\n            return \"OpenNMS HttpMonitor\";\n        }\n        return agent;\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponse(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response\", getDefaultResponseRange(getUrl(parameters)));\n    }","id":11476,"modified_method":"private String determineResponse(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response\", determineDefaultResponseRange(determineUrl(parameters)));\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected String getBasicAuthentication(final Map<String, String> parameters) {\n        String credentials = ParameterMap.getKeyedString(parameters, \"basic-authentication\", null);\n        if (credentials != null && !\"\".equals(credentials)) {\n            return new String(Base64.encodeBase64(credentials.getBytes()));\n        } else {\n            String user = ParameterMap.getKeyedString(parameters, \"user\", null);\n            if (user == null || \"\".equals(user)) {\n                return null;\n            }\n            \n            String passwd = ParameterMap.getKeyedString(parameters, \"password\", \"\");\n            \n            return new String(Base64.encodeBase64((user+\":\"+passwd).getBytes()));\n        }\n    }","id":11477,"modified_method":"String determineBasicAuthentication(final Map<String, String> parameters) {\n        String credentials = ParameterMap.getKeyedString(parameters, \"basic-authentication\", null);\n\n        if (isNotBlank(credentials)) {\n            credentials = new String(Base64.encodeBase64(credentials.getBytes()));\n        } else {\n            \n            String user = ParameterMap.getKeyedString(parameters, \"user\", null);\n            \n            if (isBlank(user)) {\n                credentials = null;\n            } else {\n                String passwd = ParameterMap.getKeyedString(parameters, \"password\", \"\");\n                credentials = new String(Base64.encodeBase64((user+\":\"+passwd).getBytes()));\n            }\n        }\n        \n        return credentials;\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for HTTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port(s) (by default TCP\n     * ports 80, 8080, 8888). If the connection request is successful, an HTTP 'GET' command is\n     * sent to the interface. The response is parsed and a return code extracted and verified.\n     * Provided that the interface's response is valid we set the service status to\n     * SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, and others) to be used for this poll.\n     * @return The availability of the interface and if a transition event should be suppressed.\n     *  \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        //\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        \n        String cmd = buildCommand(iface, parameters);\n\n        // Cycle through the port list\n        //\n        int serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n        String reason = null;\n        Double responseTime = null;\n        int currentPort = -1;\n\n        for (int portIndex = 0; portIndex < getPorts(parameters).length && serviceStatus != PollStatus.SERVICE_AVAILABLE; portIndex++) {\n            currentPort = getPorts(parameters)[portIndex];\n\n            TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"Port = \" + currentPort + \", Address = \" + getIpv4Addr(iface) + \", \" + tracker);\n            }\n\n            for(tracker.reset(); tracker.shouldRetry() && serviceStatus != PollStatus.SERVICE_AVAILABLE; tracker.nextAttempt()) {\n                Socket socket = null;\n                try {\n                    tracker.startAttempt();\n                    \n                    socket = createSocket(iface, currentPort, tracker.getSoTimeout());\n                    socket.connect(new InetSocketAddress(getIpv4Addr(iface), currentPort), tracker.getConnectionTimeout());\n                    socket = wrapSocket(socket);\n                    log().debug(\"HttpMonitor: connected to host: \" + getIpv4Addr(iface) + \" on port: \" + currentPort);\n\n                    // We're connected, so upgrade status to unresponsive\n                    serviceStatus = PollStatus.SERVICE_UNRESPONSIVE;\n\n                    //\n                    // Issue HTTP 'GET' command and check the return code in the response\n                    //\n                    socket.getOutputStream().write(cmd.getBytes());\n\n                    //\n                    // Get a buffered input stream that will read a line\n                    // at a time\n                    //\n                    BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    String line = lineRdr.readLine();\n                    \n                    if (line == null) {\n                        continue;\n                    }\n\n                    responseTime = tracker.elapsedTimeInMillis();\n                    \n                    if (log().isDebugEnabled()) {\n                        log().debug(\"poll: response= \" + line);\n                        log().debug(\"poll: responseTime= \" + responseTime + \"ms\");\n                    }\n\n                    if (line.startsWith(\"HTTP/\")) {\n                        StringTokenizer t = new StringTokenizer(line);\n                        t.nextToken();\n\n                        int serverResponseValue = -1;\n                        try {\n                            serverResponseValue = Integer.parseInt(t.nextToken());\n                        } catch (NumberFormatException nfE) {\n                            log().info(\"Error converting response code from host = \" + getIpv4Addr(iface) + \", response = \" + line);\n                        }\n                        \n                        if (SnmpPeerFactory.matchNumericListOrRange(String.valueOf(serverResponseValue), getResponse(parameters))) {\n                            serviceStatus = PollStatus.SERVICE_AVAILABLE;\n                        } else {\n                            serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n                            StringBuffer sb = new StringBuffer();\n                            sb.append(\"HTTP response value: \");\n                            sb.append(serverResponseValue);\n                            sb.append(\". Expecting: \");\n                            sb.append(getResponse(parameters));\n                            sb.append(\".\");\n                            reason = sb.toString();\n                        }\n                    }\n\n                    if (serviceStatus == PollStatus.SERVICE_AVAILABLE && getResponseText(parameters) != null && getResponseText(parameters).length() > 0) {\n                        // This loop will rip through the rest of the Response Header\n                        //\n                        do {\n                            line = lineRdr.readLine();\n                            \n                            if (isVerbose(parameters)) {\n                                log().debug(\"\\theader: \"+line);\n                            }\n\n                        } while (line != null && line.length() != 0);\n                        if (line == null) {\n                            continue;\n                        }\n\n                        // Now lets rip through the Entity-Body (i.e., content) looking\n                        // for the required text.\n                        //\n                        boolean bResponseTextFound = false;\n                        int nullCount = 0;\n                        do {\n                            line = lineRdr.readLine();\n                            \n                            if (isVerbose(parameters)) {\n                                log().debug(\"\\tbody: \"+line);\n                            }\n                            \n                            if (line != null) {\n                                if (getResponseText(parameters).charAt(0) == '~') {\n                                    if (line.matches(getResponseText(parameters).substring(1))) {\n                                        bResponseTextFound = true;\n                                    }\n                                } else {\n                                    int responseIndex = line.indexOf(getResponseText(parameters));\n                                    if (responseIndex != -1) {\n                                        bResponseTextFound = true;\n                                    }\n                                }\n                            } else {\n                                nullCount++;\n                            }\n                            \n                        } while (nullCount < 2 && !bResponseTextFound);\n\n                        // Set the status back to failed\n                        //\n                        if (!bResponseTextFound) {\n                            serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n                            reason = \"Matching text: [\"+getResponseText(parameters)+\"] not found in body of HTTP response\";\n                        }\n                    }\n                } catch (NoRouteToHostException e) {\n                    log().warn(\"checkStatus: No route to host exception for address \" + getIpv4Addr(iface) + \": \" + e.getMessage());\n                    portIndex = getPorts(parameters).length; // Will cause outer for(;;) to terminate\n                    reason = \"No route to host exception\";\n                    \n                    // don't break in case 'strict timeouts are enabled'\n                    //break; \n                } catch (InterruptedIOException e) {\n                    // Ignore\n                    log().info(\"checkStatus: did not connect to host with \" + tracker);\n                    reason = \"HTTP connection timeout\";\n                } catch (ConnectException e) {\n                    // Connection Refused. Continue to retry.\n                    log().warn(\"Connection exception for \" + getIpv4Addr(iface) + \":\" + getPorts(parameters)[portIndex] + \":\"+ e.getMessage());\n                    reason = \"HTTP connection exception on port: \"+getPorts(parameters)[portIndex]+\": \"+e.getMessage();\n                } catch (IOException e) {\n                    // Ignore\n                    //\n                    e.fillInStackTrace();\n                    log().warn(\"IOException while polling address \" + getIpv4Addr(iface), e);\n                    reason = \"IOException while polling address: \"+getIpv4Addr(iface)+\": \"+e.getMessage();\n                } finally {\n                    try {\n                        // Close the socket\n                        if (socket != null) {\n                            socket.close();\n                        }\n                    } catch (IOException e) {\n                        e.fillInStackTrace();\n                        log().warn(\"Error closing socket connection\", e);\n                    }\n                }\n\n            } // end for (attempts)\n        } // end for (ports)\n\n        // Add the 'qualifier' parm to the parameter map. This parm will\n        // contain the port on which the service was found if AVAILABLE or\n        // will contain a comma delimited list of the port(s) which were\n        // tried if the service is UNAVAILABLE\n        //\n        if (serviceStatus == PollStatus.SERVICE_UNAVAILABLE) {\n            //\n            // Build port string\n            //\n            StringBuffer testedPorts = new StringBuffer();\n            for (int i = 0; i < getPorts(parameters).length; i++) {\n                if (i == 0) {\n                    testedPorts.append(getPorts(parameters)[0]);\n                } else {\n                    testedPorts.append(',').append(getPorts(parameters)[i]);\n                }\n            }\n\n            // Add to parameter map\n            parameters.put(\"qualifier\", testedPorts.toString());\n            reason += \"/Ports: \"+testedPorts.toString();\n            log().debug(\"checkStatus: Reason: \\\"\"+reason+\"\\\"\");\n            return PollStatus.unavailable(reason);\n\n        } else if (serviceStatus == PollStatus.SERVICE_AVAILABLE) {\n            parameters.put(\"qualifier\", Integer.toString(currentPort));\n            return PollStatus.available(responseTime);\n        } else {\n            return PollStatus.get(serviceStatus, reason);\n        }\n\n    }","id":11478,"modified_method":"/**\n     * Poll the specified address for HTTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port(s) (by default TCP\n     * ports 80, 8080, 8888). If the connection request is successful, an HTTP 'GET' command is\n     * sent to the interface. The response is parsed and a return code extracted and verified.\n     * Provided that the interface's response is valid we set the service status to\n     * SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, and others) to be used for this poll.\n     * @return The availability of the interface and if a transition event should be suppressed.\n     *  \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Cycle through the port list\n        //\n        int currentPort = -1;\n        HttpMonitorClient httpClient = new HttpMonitorClient(iface, new TreeMap<String, String>(parameters));\n\n        for (int portIndex = 0; portIndex < determinePorts(httpClient.getParameters()).length && httpClient.getPollStatus() != PollStatus.SERVICE_AVAILABLE; portIndex++) {\n            currentPort = determinePorts(httpClient.getParameters())[portIndex];\n\n            httpClient.setTimeoutTracker(new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT));\n            log().debug(\"Port = \" + currentPort + \", Address = \" + ((InetAddress) iface.getAddress()) + \", \" + httpClient.getTimeoutTracker());\n            \n            httpClient.setCurrentPort(currentPort);\n\n            for(httpClient.getTimeoutTracker().reset();\n                httpClient.getTimeoutTracker().shouldRetry() && httpClient.getPollStatus() != PollStatus.SERVICE_AVAILABLE; \n                httpClient.getTimeoutTracker().nextAttempt()) {\n                \n                try {\n                    httpClient.getTimeoutTracker().startAttempt();                    \n                    httpClient.connect();\n                    log().debug(\"HttpMonitor: connected to host: \" + ((InetAddress) iface.getAddress()) + \" on port: \" + currentPort);\n\n                    httpClient.sendHttpCommand();\n                    \n                    if (httpClient.isEndOfStream()) {\n                        continue;\n                    }\n\n                    httpClient.setResponseTime(httpClient.getTimeoutTracker().elapsedTimeInMillis());\n                    logResponseTimes(httpClient.getResponseTime(), httpClient.getCurrentLine());\n\n                    if (httpClient.getPollStatus() == PollStatus.SERVICE_AVAILABLE && StringUtils.isNotBlank(httpClient.getResponseText())) {\n                        httpClient.setPollStatus(PollStatus.SERVICE_UNAVAILABLE);\n                        httpClient.readLinedMatching();\n                        \n                        if (httpClient.isEndOfStream()) {\n                            continue;\n                        }\n\n                        httpClient.read();\n\n                        if (!httpClient.isResponseTextFound()) {\n                            String message = \"Matching text: [\"+httpClient.getResponseText()+\"] not found in body of HTTP response\";\n                            log().debug(message);\n                            httpClient.setReason(\"Matching text: [\"+httpClient.getResponseText()+\"] not found in body of HTTP response\");\n                        }\n                    }\n                    \n                } catch (NoRouteToHostException e) {\n                    log().warn(\"checkStatus: No route to host exception for address \" + ((InetAddress) iface.getAddress()) + \": \" + e.getMessage());\n                    portIndex = determinePorts(httpClient.getParameters()).length; // Will cause outer for(;;) to terminate\n                    httpClient.setReason(\"No route to host exception\");\n                } catch (InterruptedIOException e) {\n                    log().info(\"checkStatus: did not connect to host with \" + httpClient.getTimeoutTracker().toString());\n                    httpClient.setReason(\"HTTP connection timeout\");\n                } catch (ConnectException e) {\n                    log().warn(\"Connection exception for \" + ((InetAddress) iface.getAddress()) + \":\" + determinePorts(httpClient.getParameters())[portIndex] + \":\"+ e.getMessage());\n                    httpClient.setReason(\"HTTP connection exception on port: \"+determinePorts(httpClient.getParameters())[portIndex]+\": \"+e.getMessage());\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log().warn(\"IOException while polling address \" + ((InetAddress) iface.getAddress()), e);\n                    httpClient.setReason(\"IOException while polling address: \"+((InetAddress) iface.getAddress())+\": \"+e.getMessage());\n                } finally {\n                    httpClient.closeConnection();\n                }\n\n            } // end for (attempts)\n        } // end for (ports)\n        return httpClient.determinePollStatusResponse();\n\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String buildCommand(final NetworkInterface iface, final Map<String, String> parameters) {\n        \n        /*\n         * Sorting this map just in case the poller gets changed and the Map\n         * is no longer a TreeMap.\n         */\n        Map<String, String> sortedParameters = new TreeMap<String, String>(parameters);\n        // Following a successful poll 'currentPort' will contain the port on\n        // the remote host that was successfully queried\n        //\n        String cmd = \"GET \" + getUrl(parameters) + \" HTTP/1.1\\r\\n\";\n        cmd += \"Connection: CLOSE \\r\\n\";\n\n        if (getVirtualHost(parameters) != null) {\n            cmd = cmd + \"Host: \" + getVirtualHost(parameters) +\"\\r\\n\";\n        } else {\n            cmd += \"Host: \" + getIpv4Addr(iface).getHostName() +\"\\r\\n\";\n        }\n        \n        cmd += \"User-Agent: \"+getUserAgent(parameters) +\"\\r\\n\";\n        \n        if (getBasicAuthentication(parameters) != null) {\n            cmd += \"Authorization: Basic \"+getBasicAuthentication(parameters) +\"\\r\\n\";\n        }\n\n        for (Iterator<String> it = sortedParameters.keySet().iterator(); it.hasNext();) {\n            String parmKey = (String) it.next();\n            if (parmKey.matches(\"header[0-9]+$\")) {\n                cmd += getHeader(parameters, parmKey)+\"\\r\\n\";\n            }\n        }\n        \n        cmd = cmd + \"\\r\\n\";\n        log().debug(\"checkStatus: cmd:\\n\" + cmd);\n        return cmd;\n    }","id":11479,"modified_method":"private String determineVirtualHost(NetworkInterface iface, final Map<String, String> parameters) {\n        boolean res = ParameterMap.getKeyedBoolean(parameters, \"resolve-ip\", false);\n        String virtualHost = ParameterMap.getKeyedString(parameters, \"host-name\", null);\n\n        \n        if (isBlank(virtualHost)) {\n            if (res) {\n                virtualHost = ((InetAddress) iface.getAddress()).getCanonicalHostName();\n            } else {\n                virtualHost = ((InetAddress) iface.getAddress()).getHostAddress();\n            }\n        }\n        return virtualHost;\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMatchingTextInResponse() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"surfing\");\n        m.put(p.getKey(), p.getValue());\n        \n        /*\n         * Adding this parameter because we get a redirect on www.opennms.org\n         */\n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.com\");\n        m.put(p.getKey(), p.getValue());\n\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"consulting\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nliteral text check: \\\"consulting\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]onsulting.*\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nregex check: \\\".*[Cc]consulting.*\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","id":11480,"modified_method":"public void testMatchingTextInResponse() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.com\", \"HTTP\");\n\n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.org\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Main_Page\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"opennmsrulz\");\n        m.put(p.getKey(), p.getValue());\n\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"New and Noteworthy\");\n        m.put(p.getKey(), p.getValue());\n        \n        MockUtil.println(\"\\nliteral text check: \\\"New and Noteworthy\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Tt]ry [Oo]ut [Oo]penNMS.*\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nregex check: \\\".*[Tt]ry [Oo]ut [Oo]penNMS.*\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPollInValidVirtualDomain() throws UnknownHostException {\n\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"1000\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"host name\");\n        p.setValue(\"opennms.com\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/solutions/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]onsulting.*\");\n        m.put(p.getKey(), p.getValue());\n\n        //Try on opennms.org\n        monitor.poll(svc, m);        \n        \n    }","id":11481,"modified_method":"public void testPollInValidVirtualDomain() throws UnknownHostException {\n\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"1000\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"host name\");\n        p.setValue(\"opennms.com\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/solutions/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]blahblah.*\");\n        m.put(p.getKey(), p.getValue());\n\n        //Try on opennms.org\n        PollStatus status = monitor.poll(svc, m);\n        assertEquals(\"poll status not available\", PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        \n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBase64Encoding() {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        HttpMonitor monitor = new HttpMonitor();\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"Aladdin:open sesame\");\n        m.put(p.getKey(), p.getValue());\n        assertEquals(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\", monitor.getBasicAuthentication(m));\n        assertFalse( \"QWxhZGRpbjpvcZVuIHNlc2FtZQ==\".equals(monitor.getBasicAuthentication(m)));\n    }","id":11482,"modified_method":"public void testBase64Encoding() {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        HttpMonitor monitor = new HttpMonitor();\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"Aladdin:open sesame\");\n        m.put(p.getKey(), p.getValue());\n        assertEquals(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\", monitor.determineBasicAuthentication(m));\n        assertFalse( \"QWxhZGRpbjpvcZVuIHNlc2FtZQ==\".equals(monitor.determineBasicAuthentication(m)));\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBasicAuthenticationWithHttps() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpsMonitor();\n        MonitoredService svc = getMonitoredService(1, \"localhost\", \"HTTPS\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"443\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/opennms/event/list\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"admin:admin\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","id":11483,"modified_method":"public void _testBasicAuthenticationWithHttps() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpsMonitor();\n        MonitoredService svc = getMonitoredService(1, \"blah.opennms.com\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"443\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Main_Page\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"zzzz:zzzz\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBasicAuthentication() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(1, \"localhost\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"8080\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/opennms/event/list\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"admin:admin\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","id":11484,"modified_method":"public void testBasicAuthentication() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(1, \"prism.library.cornell.edu\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/control/authBasic/authTest/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"test:this\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n        \n        p.setKey(\"basic-authentication\");\n        p.setValue(\"test:that\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        \n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testWithUrl() throws UnknownHostException {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"url\");\n        //found I needed the trailing \"/\" on this url\n        p.setValue(\"/wiki/\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"OpenNMS\");\n        m.put(p.getKey(), p.getValue());\n        \n        //be sure to uncomment this when not running interactively\n//        p.setKey(\"verbose\");\n//        p.setValue(\"true\");\n//        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","id":11485,"modified_method":"public void testWithUrl() throws UnknownHostException {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.org\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Enterprise_grade\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"thousands\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testResponseRange() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-299\");\n        m.put(p.getKey(), p.getValue());\n        \n        PollStatus status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"100,200,302,400-500\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"*\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n    }","id":11486,"modified_method":"public void testResponseRange() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-199\");\n        m.put(p.getKey(), p.getValue());\n        \n        PollStatus status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"100,200,302,400-500\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"*\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected int[] getPorts(Map parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","id":11487,"modified_method":"protected int[] determinePorts(Map parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","commit_id":"cb6b277c4244b982cb2241ce10814070213f670a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponseText(final Map<String, String> parameters) {\n        String responseText = ParameterMap.getKeyedString(parameters, \"response-text\", null);\n        if (responseText == null) {\n            //try depricated parameter\n            responseText = ParameterMap.getKeyedString(parameters, \"response text\", null);\n        }\n        return responseText;\n    }","id":11488,"modified_method":"private String determineResponseText(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response-text\", null);\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected int[] getPorts(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","id":11489,"modified_method":"protected int[] determinePorts(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getHeader(final Map<String, String> parameters, String key) {\n        return ParameterMap.getKeyedString(parameters, key, null);\n    }","id":11490,"modified_method":"private String determineHttpHeader(final Map<String, String> parameters, String key) {\n        return ParameterMap.getKeyedString(parameters, key, null);\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getUrl(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"url\", DEFAULT_URL);\n    }","id":11491,"modified_method":"private String determineUrl(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"url\", DEFAULT_URL);\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponse(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response\", getDefaultResponseRange(getUrl(parameters)));\n    }","id":11492,"modified_method":"private String determineResponse(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response\", determineDefaultResponseRange(determineUrl(parameters)));\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for HTTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port(s) (by default TCP\n     * ports 80, 8080, 8888). If the connection request is successful, an HTTP 'GET' command is\n     * sent to the interface. The response is parsed and a return code extracted and verified.\n     * Provided that the interface's response is valid we set the service status to\n     * SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, and others) to be used for this poll.\n     * @return The availability of the interface and if a transition event should be suppressed.\n     *  \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        //\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        \n        String cmd = buildCommand(iface, parameters);\n\n        // Cycle through the port list\n        //\n        int serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n        String reason = null;\n        Double responseTime = null;\n        int currentPort = -1;\n\n        for (int portIndex = 0; portIndex < getPorts(parameters).length && serviceStatus != PollStatus.SERVICE_AVAILABLE; portIndex++) {\n            currentPort = getPorts(parameters)[portIndex];\n\n            TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"Port = \" + currentPort + \", Address = \" + getIpv4Addr(iface) + \", \" + tracker);\n            }\n\n            for(tracker.reset(); tracker.shouldRetry() && serviceStatus != PollStatus.SERVICE_AVAILABLE; tracker.nextAttempt()) {\n                Socket socket = null;\n                try {\n                    tracker.startAttempt();\n                    \n                    socket = createSocket(iface, currentPort, tracker.getSoTimeout());\n                    socket.connect(new InetSocketAddress(getIpv4Addr(iface), currentPort), tracker.getConnectionTimeout());\n                    socket = wrapSocket(socket);\n                    log().debug(\"HttpMonitor: connected to host: \" + getIpv4Addr(iface) + \" on port: \" + currentPort);\n\n                    // We're connected, so upgrade status to unresponsive\n                    serviceStatus = PollStatus.SERVICE_UNRESPONSIVE;\n\n                    //\n                    // Issue HTTP 'GET' command and check the return code in the response\n                    //\n                    socket.getOutputStream().write(cmd.getBytes());\n\n                    //\n                    // Get a buffered input stream that will read a line\n                    // at a time\n                    //\n                    BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    String line = lineRdr.readLine();\n                    \n                    if (line == null) {\n                        continue;\n                    }\n\n                    responseTime = tracker.elapsedTimeInMillis();\n                    \n                    if (log().isDebugEnabled()) {\n                        log().debug(\"poll: response= \" + line);\n                        log().debug(\"poll: responseTime= \" + responseTime + \"ms\");\n                    }\n\n                    if (line.startsWith(\"HTTP/\")) {\n                        StringTokenizer t = new StringTokenizer(line);\n                        t.nextToken();\n\n                        int serverResponseValue = -1;\n                        try {\n                            serverResponseValue = Integer.parseInt(t.nextToken());\n                        } catch (NumberFormatException nfE) {\n                            log().info(\"Error converting response code from host = \" + getIpv4Addr(iface) + \", response = \" + line);\n                        }\n                        \n                        if (SnmpPeerFactory.matchNumericListOrRange(String.valueOf(serverResponseValue), getResponse(parameters))) {\n                            serviceStatus = PollStatus.SERVICE_AVAILABLE;\n                        } else {\n                            serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n                            StringBuffer sb = new StringBuffer();\n                            sb.append(\"HTTP response value: \");\n                            sb.append(serverResponseValue);\n                            sb.append(\". Expecting: \");\n                            sb.append(getResponse(parameters));\n                            sb.append(\".\");\n                            reason = sb.toString();\n                        }\n                    }\n\n                    if (serviceStatus == PollStatus.SERVICE_AVAILABLE && getResponseText(parameters) != null && getResponseText(parameters).length() > 0) {\n                        // This loop will rip through the rest of the Response Header\n                        //\n                        do {\n                            line = lineRdr.readLine();\n                            \n                            if (isVerbose(parameters)) {\n                                log().debug(\"\\theader: \"+line);\n                            }\n\n                        } while (line != null && line.length() != 0);\n                        if (line == null) {\n                            continue;\n                        }\n\n                        // Now lets rip through the Entity-Body (i.e., content) looking\n                        // for the required text.\n                        //\n                        boolean bResponseTextFound = false;\n                        int nullCount = 0;\n                        do {\n                            line = lineRdr.readLine();\n                            \n                            if (isVerbose(parameters)) {\n                                log().debug(\"\\tbody: \"+line);\n                            }\n                            \n                            if (line != null) {\n                                if (getResponseText(parameters).charAt(0) == '~') {\n                                    if (line.matches(getResponseText(parameters).substring(1))) {\n                                        bResponseTextFound = true;\n                                    }\n                                } else {\n                                    int responseIndex = line.indexOf(getResponseText(parameters));\n                                    if (responseIndex != -1) {\n                                        bResponseTextFound = true;\n                                    }\n                                }\n                            } else {\n                                nullCount++;\n                            }\n                            \n                        } while (nullCount < 2 && !bResponseTextFound);\n\n                        // Set the status back to failed\n                        //\n                        if (!bResponseTextFound) {\n                            serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n                            reason = \"Matching text: [\"+getResponseText(parameters)+\"] not found in body of HTTP response\";\n                        }\n                    }\n                } catch (NoRouteToHostException e) {\n                    log().warn(\"checkStatus: No route to host exception for address \" + getIpv4Addr(iface) + \": \" + e.getMessage());\n                    portIndex = getPorts(parameters).length; // Will cause outer for(;;) to terminate\n                    reason = \"No route to host exception\";\n                    \n                    // don't break in case 'strict timeouts are enabled'\n                    //break; \n                } catch (InterruptedIOException e) {\n                    // Ignore\n                    log().info(\"checkStatus: did not connect to host with \" + tracker);\n                    reason = \"HTTP connection timeout\";\n                } catch (ConnectException e) {\n                    // Connection Refused. Continue to retry.\n                    log().warn(\"Connection exception for \" + getIpv4Addr(iface) + \":\" + getPorts(parameters)[portIndex] + \":\"+ e.getMessage());\n                    reason = \"HTTP connection exception on port: \"+getPorts(parameters)[portIndex]+\": \"+e.getMessage();\n                } catch (IOException e) {\n                    // Ignore\n                    //\n                    e.fillInStackTrace();\n                    log().warn(\"IOException while polling address \" + getIpv4Addr(iface), e);\n                    reason = \"IOException while polling address: \"+getIpv4Addr(iface)+\": \"+e.getMessage();\n                } finally {\n                    try {\n                        // Close the socket\n                        if (socket != null) {\n                            socket.close();\n                        }\n                    } catch (IOException e) {\n                        e.fillInStackTrace();\n                        log().warn(\"Error closing socket connection\", e);\n                    }\n                }\n\n            } // end for (attempts)\n        } // end for (ports)\n\n        // Add the 'qualifier' parm to the parameter map. This parm will\n        // contain the port on which the service was found if AVAILABLE or\n        // will contain a comma delimited list of the port(s) which were\n        // tried if the service is UNAVAILABLE\n        //\n        if (serviceStatus == PollStatus.SERVICE_UNAVAILABLE) {\n            //\n            // Build port string\n            //\n            StringBuffer testedPorts = new StringBuffer();\n            for (int i = 0; i < getPorts(parameters).length; i++) {\n                if (i == 0) {\n                    testedPorts.append(getPorts(parameters)[0]);\n                } else {\n                    testedPorts.append(',').append(getPorts(parameters)[i]);\n                }\n            }\n\n            // Add to parameter map\n            parameters.put(\"qualifier\", testedPorts.toString());\n            reason += \"/Ports: \"+testedPorts.toString();\n            log().debug(\"checkStatus: Reason: \\\"\"+reason+\"\\\"\");\n            return PollStatus.unavailable(reason);\n\n        } else if (serviceStatus == PollStatus.SERVICE_AVAILABLE) {\n            parameters.put(\"qualifier\", Integer.toString(currentPort));\n            return PollStatus.available(responseTime);\n        } else {\n            return PollStatus.get(serviceStatus, reason);\n        }\n\n    }","id":11493,"modified_method":"/**\n     * Poll the specified address for HTTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port(s) (by default TCP\n     * ports 80, 8080, 8888). If the connection request is successful, an HTTP 'GET' command is\n     * sent to the interface. The response is parsed and a return code extracted and verified.\n     * Provided that the interface's response is valid we set the service status to\n     * SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, and others) to be used for this poll.\n     * @return The availability of the interface and if a transition event should be suppressed.\n     *  \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Cycle through the port list\n        //\n        int currentPort = -1;\n        HttpMonitorClient httpClient = new HttpMonitorClient(iface, new TreeMap<String, String>(parameters));\n\n        for (int portIndex = 0; portIndex < determinePorts(httpClient.getParameters()).length && httpClient.getPollStatus() != PollStatus.SERVICE_AVAILABLE; portIndex++) {\n            currentPort = determinePorts(httpClient.getParameters())[portIndex];\n\n            httpClient.setTimeoutTracker(new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT));\n            log().debug(\"Port = \" + currentPort + \", Address = \" + ((InetAddress) iface.getAddress()) + \", \" + httpClient.getTimeoutTracker());\n            \n            httpClient.setCurrentPort(currentPort);\n\n            for(httpClient.getTimeoutTracker().reset();\n                httpClient.getTimeoutTracker().shouldRetry() && httpClient.getPollStatus() != PollStatus.SERVICE_AVAILABLE; \n                httpClient.getTimeoutTracker().nextAttempt()) {\n                \n                try {\n                    httpClient.getTimeoutTracker().startAttempt();                    \n                    httpClient.connect();\n                    log().debug(\"HttpMonitor: connected to host: \" + ((InetAddress) iface.getAddress()) + \" on port: \" + currentPort);\n\n                    httpClient.sendHttpCommand();\n                    \n                    if (httpClient.isEndOfStream()) {\n                        continue;\n                    }\n\n                    httpClient.setResponseTime(httpClient.getTimeoutTracker().elapsedTimeInMillis());\n                    logResponseTimes(httpClient.getResponseTime(), httpClient.getCurrentLine());\n\n                    if (httpClient.getPollStatus() == PollStatus.SERVICE_AVAILABLE && StringUtils.isNotBlank(httpClient.getResponseText())) {\n                        httpClient.setPollStatus(PollStatus.SERVICE_UNAVAILABLE);\n                        httpClient.readLinedMatching();\n                        \n                        if (httpClient.isEndOfStream()) {\n                            continue;\n                        }\n\n                        httpClient.read();\n\n                        if (!httpClient.isResponseTextFound()) {\n                            String message = \"Matching text: [\"+httpClient.getResponseText()+\"] not found in body of HTTP response\";\n                            log().debug(message);\n                            httpClient.setReason(\"Matching text: [\"+httpClient.getResponseText()+\"] not found in body of HTTP response\");\n                        }\n                    }\n                    \n                } catch (NoRouteToHostException e) {\n                    log().warn(\"checkStatus: No route to host exception for address \" + ((InetAddress) iface.getAddress()) + \": \" + e.getMessage());\n                    portIndex = determinePorts(httpClient.getParameters()).length; // Will cause outer for(;;) to terminate\n                    httpClient.setReason(\"No route to host exception\");\n                } catch (InterruptedIOException e) {\n                    log().info(\"checkStatus: did not connect to host with \" + httpClient.getTimeoutTracker().toString());\n                    httpClient.setReason(\"HTTP connection timeout\");\n                } catch (ConnectException e) {\n                    log().warn(\"Connection exception for \" + ((InetAddress) iface.getAddress()) + \":\" + determinePorts(httpClient.getParameters())[portIndex] + \":\"+ e.getMessage());\n                    httpClient.setReason(\"HTTP connection exception on port: \"+determinePorts(httpClient.getParameters())[portIndex]+\": \"+e.getMessage());\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log().warn(\"IOException while polling address \" + ((InetAddress) iface.getAddress()), e);\n                    httpClient.setReason(\"IOException while polling address: \"+((InetAddress) iface.getAddress())+\": \"+e.getMessage());\n                } finally {\n                    httpClient.closeConnection();\n                }\n\n            } // end for (attempts)\n        } // end for (ports)\n        return httpClient.determinePollStatusResponse();\n\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected String getBasicAuthentication(final Map<String, String> parameters) {\n        String credentials = ParameterMap.getKeyedString(parameters, \"basic-authentication\", null);\n        if (credentials != null && !\"\".equals(credentials)) {\n            return new String(Base64.encodeBase64(credentials.getBytes()));\n        } else {\n            String user = ParameterMap.getKeyedString(parameters, \"user\", null);\n            if (user == null || \"\".equals(user)) {\n                return null;\n            }\n            \n            String passwd = ParameterMap.getKeyedString(parameters, \"password\", \"\");\n            \n            return new String(Base64.encodeBase64((user+\":\"+passwd).getBytes()));\n        }\n    }","id":11494,"modified_method":"String determineBasicAuthentication(final Map<String, String> parameters) {\n        String credentials = ParameterMap.getKeyedString(parameters, \"basic-authentication\", null);\n\n        if (isNotBlank(credentials)) {\n            credentials = new String(Base64.encodeBase64(credentials.getBytes()));\n        } else {\n            \n            String user = ParameterMap.getKeyedString(parameters, \"user\", null);\n            \n            if (isBlank(user)) {\n                credentials = null;\n            } else {\n                String passwd = ParameterMap.getKeyedString(parameters, \"password\", \"\");\n                credentials = new String(Base64.encodeBase64((user+\":\"+passwd).getBytes()));\n            }\n        }\n        \n        return credentials;\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String buildCommand(final NetworkInterface iface, final Map<String, String> parameters) {\n        \n        /*\n         * Sorting this map just in case the poller gets changed and the Map\n         * is no longer a TreeMap.\n         */\n        Map<String, String> sortedParameters = new TreeMap<String, String>(parameters);\n        // Following a successful poll 'currentPort' will contain the port on\n        // the remote host that was successfully queried\n        //\n        String cmd = \"GET \" + getUrl(parameters) + \" HTTP/1.1\\r\\n\";\n        cmd += \"Connection: CLOSE \\r\\n\";\n\n        if (getVirtualHost(parameters) != null) {\n            cmd = cmd + \"Host: \" + getVirtualHost(parameters) +\"\\r\\n\";\n        } else {\n            cmd += \"Host: \" + getIpv4Addr(iface).getHostName() +\"\\r\\n\";\n        }\n        \n        cmd += \"User-Agent: \"+getUserAgent(parameters) +\"\\r\\n\";\n        \n        if (getBasicAuthentication(parameters) != null) {\n            cmd += \"Authorization: Basic \"+getBasicAuthentication(parameters) +\"\\r\\n\";\n        }\n\n        for (Iterator<String> it = sortedParameters.keySet().iterator(); it.hasNext();) {\n            String parmKey = (String) it.next();\n            if (parmKey.matches(\"header[0-9]+$\")) {\n                cmd += getHeader(parameters, parmKey)+\"\\r\\n\";\n            }\n        }\n        \n        cmd = cmd + \"\\r\\n\";\n        log().debug(\"checkStatus: cmd:\\n\" + cmd);\n        return cmd;\n    }","id":11495,"modified_method":"private String determineVirtualHost(NetworkInterface iface, final Map<String, String> parameters) {\n        boolean res = ParameterMap.getKeyedBoolean(parameters, \"resolve-ip\", false);\n        String virtualHost = ParameterMap.getKeyedString(parameters, \"host-name\", null);\n\n        \n        if (isBlank(virtualHost)) {\n            if (res) {\n                virtualHost = ((InetAddress) iface.getAddress()).getCanonicalHostName();\n            } else {\n                virtualHost = ((InetAddress) iface.getAddress()).getHostAddress();\n            }\n        }\n        return virtualHost;\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getUserAgent(final Map<String, String> parameters) {\n        String agent = ParameterMap.getKeyedString(parameters, \"user-agent\", null);\n        if (agent == null || \"\".equals(agent)) {\n            return \"OpenNMS HttpMonitor\";\n        }\n        return agent;\n    }","id":11496,"modified_method":"private String determineUserAgent(final Map<String, String> parameters) {\n        String agent = ParameterMap.getKeyedString(parameters, \"user-agent\", null);\n        if (isBlank(agent)) {\n            return \"OpenNMS HttpMonitor\";\n        }\n        return agent;\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getDefaultResponseRange(String url) {\n        if (url == null || url.equals(DEFAULT_URL)) {\n            return \"100-499\";\n        }\n        return \"100-399\";\n    }","id":11497,"modified_method":"private String determineDefaultResponseRange(String url) {\n        if (url == null || url.equals(DEFAULT_URL)) {\n            return \"100-499\";\n        }\n        return \"100-399\";\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private boolean isVerbose(final Map<String, String> parameters) {\n        final String verbose = ParameterMap.getKeyedString(parameters, \"verbose\", null);\n        return (verbose != null && verbose.equalsIgnoreCase(\"true\")) ? true : false;\n    }","id":11498,"modified_method":"private boolean determineVerbosity(final Map<String, String> parameters) {\n        final String verbose = ParameterMap.getKeyedString(parameters, \"verbose\", null);\n        return (verbose != null && verbose.equalsIgnoreCase(\"true\")) ? true : false;\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMatchingTextInResponse() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"surfing\");\n        m.put(p.getKey(), p.getValue());\n        \n        /*\n         * Adding this parameter because we get a redirect on www.opennms.org\n         */\n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.com\");\n        m.put(p.getKey(), p.getValue());\n\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"consulting\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nliteral text check: \\\"consulting\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]onsulting.*\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nregex check: \\\".*[Cc]consulting.*\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","id":11499,"modified_method":"public void testMatchingTextInResponse() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.com\", \"HTTP\");\n\n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.org\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Main_Page\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"opennmsrulz\");\n        m.put(p.getKey(), p.getValue());\n\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"New and Noteworthy\");\n        m.put(p.getKey(), p.getValue());\n        \n        MockUtil.println(\"\\nliteral text check: \\\"New and Noteworthy\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Tt]ry [Oo]ut [Oo]penNMS.*\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nregex check: \\\".*[Tt]ry [Oo]ut [Oo]penNMS.*\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBasicAuthentication() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(1, \"localhost\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"8080\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/opennms/event/list\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"admin:admin\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","id":11500,"modified_method":"public void testBasicAuthentication() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(1, \"prism.library.cornell.edu\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/control/authBasic/authTest/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"test:this\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n        \n        p.setKey(\"basic-authentication\");\n        p.setValue(\"test:that\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        \n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testWithUrl() throws UnknownHostException {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"url\");\n        //found I needed the trailing \"/\" on this url\n        p.setValue(\"/wiki/\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"OpenNMS\");\n        m.put(p.getKey(), p.getValue());\n        \n        //be sure to uncomment this when not running interactively\n//        p.setKey(\"verbose\");\n//        p.setValue(\"true\");\n//        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","id":11501,"modified_method":"public void testWithUrl() throws UnknownHostException {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.org\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Enterprise_grade\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"thousands\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBasicAuthenticationWithHttps() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpsMonitor();\n        MonitoredService svc = getMonitoredService(1, \"localhost\", \"HTTPS\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"443\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/opennms/event/list\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"admin:admin\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","id":11502,"modified_method":"public void _testBasicAuthenticationWithHttps() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpsMonitor();\n        MonitoredService svc = getMonitoredService(1, \"blah.opennms.com\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"443\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Main_Page\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"zzzz:zzzz\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testResponseRange() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-299\");\n        m.put(p.getKey(), p.getValue());\n        \n        PollStatus status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"100,200,302,400-500\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"*\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n    }","id":11503,"modified_method":"public void testResponseRange() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-199\");\n        m.put(p.getKey(), p.getValue());\n        \n        PollStatus status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"100,200,302,400-500\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"*\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPollInValidVirtualDomain() throws UnknownHostException {\n\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"1000\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"host name\");\n        p.setValue(\"opennms.com\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/solutions/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]onsulting.*\");\n        m.put(p.getKey(), p.getValue());\n\n        //Try on opennms.org\n        monitor.poll(svc, m);        \n        \n    }","id":11504,"modified_method":"public void testPollInValidVirtualDomain() throws UnknownHostException {\n\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"1000\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"host name\");\n        p.setValue(\"opennms.com\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/solutions/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]blahblah.*\");\n        m.put(p.getKey(), p.getValue());\n\n        //Try on opennms.org\n        PollStatus status = monitor.poll(svc, m);\n        assertEquals(\"poll status not available\", PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        \n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBase64Encoding() {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        HttpMonitor monitor = new HttpMonitor();\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"Aladdin:open sesame\");\n        m.put(p.getKey(), p.getValue());\n        assertEquals(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\", monitor.getBasicAuthentication(m));\n        assertFalse( \"QWxhZGRpbjpvcZVuIHNlc2FtZQ==\".equals(monitor.getBasicAuthentication(m)));\n    }","id":11505,"modified_method":"public void testBase64Encoding() {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        HttpMonitor monitor = new HttpMonitor();\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"Aladdin:open sesame\");\n        m.put(p.getKey(), p.getValue());\n        assertEquals(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\", monitor.determineBasicAuthentication(m));\n        assertFalse( \"QWxhZGRpbjpvcZVuIHNlc2FtZQ==\".equals(monitor.determineBasicAuthentication(m)));\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected int[] getPorts(Map parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","id":11506,"modified_method":"protected int[] determinePorts(Map parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","commit_id":"118fc533ea271cedd61d25284e2655e23a937c13","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected String getBasicAuthentication(final Map<String, String> parameters) {\n        String credentials = ParameterMap.getKeyedString(parameters, \"basic-authentication\", null);\n        if (credentials != null && !\"\".equals(credentials)) {\n            return new String(Base64.encodeBase64(credentials.getBytes()));\n        } else {\n            String user = ParameterMap.getKeyedString(parameters, \"user\", null);\n            if (user == null || \"\".equals(user)) {\n                return null;\n            }\n            \n            String passwd = ParameterMap.getKeyedString(parameters, \"password\", \"\");\n            \n            return new String(Base64.encodeBase64((user+\":\"+passwd).getBytes()));\n        }\n    }","id":11507,"modified_method":"String determineBasicAuthentication(final Map<String, String> parameters) {\n        String credentials = ParameterMap.getKeyedString(parameters, \"basic-authentication\", null);\n\n        if (isNotBlank(credentials)) {\n            credentials = new String(Base64.encodeBase64(credentials.getBytes()));\n        } else {\n            \n            String user = ParameterMap.getKeyedString(parameters, \"user\", null);\n            \n            if (isBlank(user)) {\n                credentials = null;\n            } else {\n                String passwd = ParameterMap.getKeyedString(parameters, \"password\", \"\");\n                credentials = new String(Base64.encodeBase64((user+\":\"+passwd).getBytes()));\n            }\n        }\n        \n        return credentials;\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getHeader(final Map<String, String> parameters, String key) {\n        return ParameterMap.getKeyedString(parameters, key, null);\n    }","id":11508,"modified_method":"private String determineHttpHeader(final Map<String, String> parameters, String key) {\n        return ParameterMap.getKeyedString(parameters, key, null);\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for HTTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port(s) (by default TCP\n     * ports 80, 8080, 8888). If the connection request is successful, an HTTP 'GET' command is\n     * sent to the interface. The response is parsed and a return code extracted and verified.\n     * Provided that the interface's response is valid we set the service status to\n     * SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, and others) to be used for this poll.\n     * @return The availability of the interface and if a transition event should be suppressed.\n     *  \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        //\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        \n        String cmd = buildCommand(iface, parameters);\n\n        // Cycle through the port list\n        //\n        int serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n        String reason = null;\n        Double responseTime = null;\n        int currentPort = -1;\n\n        for (int portIndex = 0; portIndex < getPorts(parameters).length && serviceStatus != PollStatus.SERVICE_AVAILABLE; portIndex++) {\n            currentPort = getPorts(parameters)[portIndex];\n\n            TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"Port = \" + currentPort + \", Address = \" + getIpv4Addr(iface) + \", \" + tracker);\n            }\n\n            for(tracker.reset(); tracker.shouldRetry() && serviceStatus != PollStatus.SERVICE_AVAILABLE; tracker.nextAttempt()) {\n                Socket socket = null;\n                try {\n                    tracker.startAttempt();\n                    \n                    socket = createSocket(iface, currentPort, tracker.getSoTimeout());\n                    socket.connect(new InetSocketAddress(getIpv4Addr(iface), currentPort), tracker.getConnectionTimeout());\n                    socket = wrapSocket(socket);\n                    log().debug(\"HttpMonitor: connected to host: \" + getIpv4Addr(iface) + \" on port: \" + currentPort);\n\n                    // We're connected, so upgrade status to unresponsive\n                    serviceStatus = PollStatus.SERVICE_UNRESPONSIVE;\n\n                    //\n                    // Issue HTTP 'GET' command and check the return code in the response\n                    //\n                    socket.getOutputStream().write(cmd.getBytes());\n\n                    //\n                    // Get a buffered input stream that will read a line\n                    // at a time\n                    //\n                    BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    String line = lineRdr.readLine();\n                    \n                    if (line == null) {\n                        continue;\n                    }\n\n                    responseTime = tracker.elapsedTimeInMillis();\n                    \n                    if (log().isDebugEnabled()) {\n                        log().debug(\"poll: response= \" + line);\n                        log().debug(\"poll: responseTime= \" + responseTime + \"ms\");\n                    }\n\n                    if (line.startsWith(\"HTTP/\")) {\n                        StringTokenizer t = new StringTokenizer(line);\n                        t.nextToken();\n\n                        int serverResponseValue = -1;\n                        try {\n                            serverResponseValue = Integer.parseInt(t.nextToken());\n                        } catch (NumberFormatException nfE) {\n                            log().info(\"Error converting response code from host = \" + getIpv4Addr(iface) + \", response = \" + line);\n                        }\n                        \n                        if (SnmpPeerFactory.matchNumericListOrRange(String.valueOf(serverResponseValue), getResponse(parameters))) {\n                            serviceStatus = PollStatus.SERVICE_AVAILABLE;\n                        } else {\n                            serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n                            StringBuffer sb = new StringBuffer();\n                            sb.append(\"HTTP response value: \");\n                            sb.append(serverResponseValue);\n                            sb.append(\". Expecting: \");\n                            sb.append(getResponse(parameters));\n                            sb.append(\".\");\n                            reason = sb.toString();\n                        }\n                    }\n\n                    if (serviceStatus == PollStatus.SERVICE_AVAILABLE && getResponseText(parameters) != null && getResponseText(parameters).length() > 0) {\n                        // This loop will rip through the rest of the Response Header\n                        //\n                        do {\n                            line = lineRdr.readLine();\n                            \n                            if (isVerbose(parameters)) {\n                                log().debug(\"\\theader: \"+line);\n                            }\n\n                        } while (line != null && line.length() != 0);\n                        if (line == null) {\n                            continue;\n                        }\n\n                        // Now lets rip through the Entity-Body (i.e., content) looking\n                        // for the required text.\n                        //\n                        boolean bResponseTextFound = false;\n                        int nullCount = 0;\n                        do {\n                            line = lineRdr.readLine();\n                            \n                            if (isVerbose(parameters)) {\n                                log().debug(\"\\tbody: \"+line);\n                            }\n                            \n                            if (line != null) {\n                                if (getResponseText(parameters).charAt(0) == '~') {\n                                    if (line.matches(getResponseText(parameters).substring(1))) {\n                                        bResponseTextFound = true;\n                                    }\n                                } else {\n                                    int responseIndex = line.indexOf(getResponseText(parameters));\n                                    if (responseIndex != -1) {\n                                        bResponseTextFound = true;\n                                    }\n                                }\n                            } else {\n                                nullCount++;\n                            }\n                            \n                        } while (nullCount < 2 && !bResponseTextFound);\n\n                        // Set the status back to failed\n                        //\n                        if (!bResponseTextFound) {\n                            serviceStatus = PollStatus.SERVICE_UNAVAILABLE;\n                            reason = \"Matching text: [\"+getResponseText(parameters)+\"] not found in body of HTTP response\";\n                        }\n                    }\n                } catch (NoRouteToHostException e) {\n                    log().warn(\"checkStatus: No route to host exception for address \" + getIpv4Addr(iface) + \": \" + e.getMessage());\n                    portIndex = getPorts(parameters).length; // Will cause outer for(;;) to terminate\n                    reason = \"No route to host exception\";\n                    \n                    // don't break in case 'strict timeouts are enabled'\n                    //break; \n                } catch (InterruptedIOException e) {\n                    // Ignore\n                    log().info(\"checkStatus: did not connect to host with \" + tracker);\n                    reason = \"HTTP connection timeout\";\n                } catch (ConnectException e) {\n                    // Connection Refused. Continue to retry.\n                    log().warn(\"Connection exception for \" + getIpv4Addr(iface) + \":\" + getPorts(parameters)[portIndex] + \":\"+ e.getMessage());\n                    reason = \"HTTP connection exception on port: \"+getPorts(parameters)[portIndex]+\": \"+e.getMessage();\n                } catch (IOException e) {\n                    // Ignore\n                    //\n                    e.fillInStackTrace();\n                    log().warn(\"IOException while polling address \" + getIpv4Addr(iface), e);\n                    reason = \"IOException while polling address: \"+getIpv4Addr(iface)+\": \"+e.getMessage();\n                } finally {\n                    try {\n                        // Close the socket\n                        if (socket != null) {\n                            socket.close();\n                        }\n                    } catch (IOException e) {\n                        e.fillInStackTrace();\n                        log().warn(\"Error closing socket connection\", e);\n                    }\n                }\n\n            } // end for (attempts)\n        } // end for (ports)\n\n        // Add the 'qualifier' parm to the parameter map. This parm will\n        // contain the port on which the service was found if AVAILABLE or\n        // will contain a comma delimited list of the port(s) which were\n        // tried if the service is UNAVAILABLE\n        //\n        if (serviceStatus == PollStatus.SERVICE_UNAVAILABLE) {\n            //\n            // Build port string\n            //\n            StringBuffer testedPorts = new StringBuffer();\n            for (int i = 0; i < getPorts(parameters).length; i++) {\n                if (i == 0) {\n                    testedPorts.append(getPorts(parameters)[0]);\n                } else {\n                    testedPorts.append(',').append(getPorts(parameters)[i]);\n                }\n            }\n\n            // Add to parameter map\n            parameters.put(\"qualifier\", testedPorts.toString());\n            reason += \"/Ports: \"+testedPorts.toString();\n            log().debug(\"checkStatus: Reason: \\\"\"+reason+\"\\\"\");\n            return PollStatus.unavailable(reason);\n\n        } else if (serviceStatus == PollStatus.SERVICE_AVAILABLE) {\n            parameters.put(\"qualifier\", Integer.toString(currentPort));\n            return PollStatus.available(responseTime);\n        } else {\n            return PollStatus.get(serviceStatus, reason);\n        }\n\n    }","id":11509,"modified_method":"/**\n     * Poll the specified address for HTTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port(s) (by default TCP\n     * ports 80, 8080, 8888). If the connection request is successful, an HTTP 'GET' command is\n     * sent to the interface. The response is parsed and a return code extracted and verified.\n     * Provided that the interface's response is valid we set the service status to\n     * SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, and others) to be used for this poll.\n     * @return The availability of the interface and if a transition event should be suppressed.\n     *  \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Cycle through the port list\n        //\n        int currentPort = -1;\n        HttpMonitorClient httpClient = new HttpMonitorClient(iface, new TreeMap<String, String>(parameters));\n\n        for (int portIndex = 0; portIndex < determinePorts(httpClient.getParameters()).length && httpClient.getPollStatus() != PollStatus.SERVICE_AVAILABLE; portIndex++) {\n            currentPort = determinePorts(httpClient.getParameters())[portIndex];\n\n            httpClient.setTimeoutTracker(new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT));\n            log().debug(\"Port = \" + currentPort + \", Address = \" + ((InetAddress) iface.getAddress()) + \", \" + httpClient.getTimeoutTracker());\n            \n            httpClient.setCurrentPort(currentPort);\n\n            for(httpClient.getTimeoutTracker().reset();\n                httpClient.getTimeoutTracker().shouldRetry() && httpClient.getPollStatus() != PollStatus.SERVICE_AVAILABLE; \n                httpClient.getTimeoutTracker().nextAttempt()) {\n                \n                try {\n                    httpClient.getTimeoutTracker().startAttempt();                    \n                    httpClient.connect();\n                    log().debug(\"HttpMonitor: connected to host: \" + ((InetAddress) iface.getAddress()) + \" on port: \" + currentPort);\n\n                    httpClient.sendHttpCommand();\n                    \n                    if (httpClient.isEndOfStream()) {\n                        continue;\n                    }\n\n                    httpClient.setResponseTime(httpClient.getTimeoutTracker().elapsedTimeInMillis());\n                    logResponseTimes(httpClient.getResponseTime(), httpClient.getCurrentLine());\n\n                    if (httpClient.getPollStatus() == PollStatus.SERVICE_AVAILABLE && StringUtils.isNotBlank(httpClient.getResponseText())) {\n                        httpClient.setPollStatus(PollStatus.SERVICE_UNAVAILABLE);\n                        httpClient.readLinedMatching();\n                        \n                        if (httpClient.isEndOfStream()) {\n                            continue;\n                        }\n\n                        httpClient.read();\n\n                        if (!httpClient.isResponseTextFound()) {\n                            String message = \"Matching text: [\"+httpClient.getResponseText()+\"] not found in body of HTTP response\";\n                            log().debug(message);\n                            httpClient.setReason(\"Matching text: [\"+httpClient.getResponseText()+\"] not found in body of HTTP response\");\n                        }\n                    }\n                    \n                } catch (NoRouteToHostException e) {\n                    log().warn(\"checkStatus: No route to host exception for address \" + ((InetAddress) iface.getAddress()) + \": \" + e.getMessage());\n                    portIndex = determinePorts(httpClient.getParameters()).length; // Will cause outer for(;;) to terminate\n                    httpClient.setReason(\"No route to host exception\");\n                } catch (InterruptedIOException e) {\n                    log().info(\"checkStatus: did not connect to host with \" + httpClient.getTimeoutTracker().toString());\n                    httpClient.setReason(\"HTTP connection timeout\");\n                } catch (ConnectException e) {\n                    log().warn(\"Connection exception for \" + ((InetAddress) iface.getAddress()) + \":\" + determinePorts(httpClient.getParameters())[portIndex] + \":\"+ e.getMessage());\n                    httpClient.setReason(\"HTTP connection exception on port: \"+determinePorts(httpClient.getParameters())[portIndex]+\": \"+e.getMessage());\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log().warn(\"IOException while polling address \" + ((InetAddress) iface.getAddress()), e);\n                    httpClient.setReason(\"IOException while polling address: \"+((InetAddress) iface.getAddress())+\": \"+e.getMessage());\n                } finally {\n                    httpClient.closeConnection();\n                }\n\n            } // end for (attempts)\n        } // end for (ports)\n        return httpClient.determinePollStatusResponse();\n\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getUserAgent(final Map<String, String> parameters) {\n        String agent = ParameterMap.getKeyedString(parameters, \"user-agent\", null);\n        if (agent == null || \"\".equals(agent)) {\n            return \"OpenNMS HttpMonitor\";\n        }\n        return agent;\n    }","id":11510,"modified_method":"private String determineUserAgent(final Map<String, String> parameters) {\n        String agent = ParameterMap.getKeyedString(parameters, \"user-agent\", null);\n        if (isBlank(agent)) {\n            return \"OpenNMS HttpMonitor\";\n        }\n        return agent;\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getDefaultResponseRange(String url) {\n        if (url == null || url.equals(DEFAULT_URL)) {\n            return \"100-499\";\n        }\n        return \"100-399\";\n    }","id":11511,"modified_method":"private String determineDefaultResponseRange(String url) {\n        if (url == null || url.equals(DEFAULT_URL)) {\n            return \"100-499\";\n        }\n        return \"100-399\";\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getUrl(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"url\", DEFAULT_URL);\n    }","id":11512,"modified_method":"private String determineUrl(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"url\", DEFAULT_URL);\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponse(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response\", getDefaultResponseRange(getUrl(parameters)));\n    }","id":11513,"modified_method":"private String determineResponse(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response\", determineDefaultResponseRange(determineUrl(parameters)));\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected int[] getPorts(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","id":11514,"modified_method":"protected int[] determinePorts(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private boolean isVerbose(final Map<String, String> parameters) {\n        final String verbose = ParameterMap.getKeyedString(parameters, \"verbose\", null);\n        return (verbose != null && verbose.equalsIgnoreCase(\"true\")) ? true : false;\n    }","id":11515,"modified_method":"private boolean determineVerbosity(final Map<String, String> parameters) {\n        final String verbose = ParameterMap.getKeyedString(parameters, \"verbose\", null);\n        return (verbose != null && verbose.equalsIgnoreCase(\"true\")) ? true : false;\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String buildCommand(final NetworkInterface iface, final Map<String, String> parameters) {\n        \n        /*\n         * Sorting this map just in case the poller gets changed and the Map\n         * is no longer a TreeMap.\n         */\n        Map<String, String> sortedParameters = new TreeMap<String, String>(parameters);\n        // Following a successful poll 'currentPort' will contain the port on\n        // the remote host that was successfully queried\n        //\n        String cmd = \"GET \" + getUrl(parameters) + \" HTTP/1.1\\r\\n\";\n        cmd += \"Connection: CLOSE \\r\\n\";\n\n        if (getVirtualHost(parameters) != null) {\n            cmd = cmd + \"Host: \" + getVirtualHost(parameters) +\"\\r\\n\";\n        } else {\n            cmd += \"Host: \" + getIpv4Addr(iface).getHostName() +\"\\r\\n\";\n        }\n        \n        cmd += \"User-Agent: \"+getUserAgent(parameters) +\"\\r\\n\";\n        \n        if (getBasicAuthentication(parameters) != null) {\n            cmd += \"Authorization: Basic \"+getBasicAuthentication(parameters) +\"\\r\\n\";\n        }\n\n        for (Iterator<String> it = sortedParameters.keySet().iterator(); it.hasNext();) {\n            String parmKey = (String) it.next();\n            if (parmKey.matches(\"header[0-9]+$\")) {\n                cmd += getHeader(parameters, parmKey)+\"\\r\\n\";\n            }\n        }\n        \n        cmd = cmd + \"\\r\\n\";\n        log().debug(\"checkStatus: cmd:\\n\" + cmd);\n        return cmd;\n    }","id":11516,"modified_method":"private String determineVirtualHost(NetworkInterface iface, final Map<String, String> parameters) {\n        boolean res = ParameterMap.getKeyedBoolean(parameters, \"resolve-ip\", false);\n        String virtualHost = ParameterMap.getKeyedString(parameters, \"host-name\", null);\n\n        \n        if (isBlank(virtualHost)) {\n            if (res) {\n                virtualHost = ((InetAddress) iface.getAddress()).getCanonicalHostName();\n            } else {\n                virtualHost = ((InetAddress) iface.getAddress()).getHostAddress();\n            }\n        }\n        return virtualHost;\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponseText(final Map<String, String> parameters) {\n        String responseText = ParameterMap.getKeyedString(parameters, \"response-text\", null);\n        if (responseText == null) {\n            //try depricated parameter\n            responseText = ParameterMap.getKeyedString(parameters, \"response text\", null);\n        }\n        return responseText;\n    }","id":11517,"modified_method":"private String determineResponseText(final Map<String, String> parameters) {\n        return ParameterMap.getKeyedString(parameters, \"response-text\", null);\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBase64Encoding() {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        HttpMonitor monitor = new HttpMonitor();\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"Aladdin:open sesame\");\n        m.put(p.getKey(), p.getValue());\n        assertEquals(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\", monitor.getBasicAuthentication(m));\n        assertFalse( \"QWxhZGRpbjpvcZVuIHNlc2FtZQ==\".equals(monitor.getBasicAuthentication(m)));\n    }","id":11518,"modified_method":"public void testBase64Encoding() {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        HttpMonitor monitor = new HttpMonitor();\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"Aladdin:open sesame\");\n        m.put(p.getKey(), p.getValue());\n        assertEquals(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\", monitor.determineBasicAuthentication(m));\n        assertFalse( \"QWxhZGRpbjpvcZVuIHNlc2FtZQ==\".equals(monitor.determineBasicAuthentication(m)));\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPollInValidVirtualDomain() throws UnknownHostException {\n\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"1000\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"host name\");\n        p.setValue(\"opennms.com\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/solutions/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]onsulting.*\");\n        m.put(p.getKey(), p.getValue());\n\n        //Try on opennms.org\n        monitor.poll(svc, m);        \n        \n    }","id":11519,"modified_method":"public void testPollInValidVirtualDomain() throws UnknownHostException {\n\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"1000\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"host name\");\n        p.setValue(\"opennms.com\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/solutions/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]blahblah.*\");\n        m.put(p.getKey(), p.getValue());\n\n        //Try on opennms.org\n        PollStatus status = monitor.poll(svc, m);\n        assertEquals(\"poll status not available\", PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        \n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMatchingTextInResponse() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"surfing\");\n        m.put(p.getKey(), p.getValue());\n        \n        /*\n         * Adding this parameter because we get a redirect on www.opennms.org\n         */\n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.com\");\n        m.put(p.getKey(), p.getValue());\n\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"consulting\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nliteral text check: \\\"consulting\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Cc]onsulting.*\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nregex check: \\\".*[Cc]consulting.*\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","id":11520,"modified_method":"public void testMatchingTextInResponse() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.com\", \"HTTP\");\n\n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.org\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Main_Page\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"opennmsrulz\");\n        m.put(p.getKey(), p.getValue());\n\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"New and Noteworthy\");\n        m.put(p.getKey(), p.getValue());\n        \n        MockUtil.println(\"\\nliteral text check: \\\"New and Noteworthy\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response-text\");\n        p.setValue(\"~.*[Tt]ry [Oo]ut [Oo]penNMS.*\");\n        m.put(p.getKey(), p.getValue());\n\n        MockUtil.println(\"\\nregex check: \\\".*[Tt]ry [Oo]ut [Oo]penNMS.*\\\"\");\n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testResponseRange() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-299\");\n        m.put(p.getKey(), p.getValue());\n        \n        PollStatus status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"100,200,302,400-500\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"*\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n    }","id":11521,"modified_method":"public void testResponseRange() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-199\");\n        m.put(p.getKey(), p.getValue());\n        \n        PollStatus status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"100,200,302,400-500\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n        p.setKey(\"response\");\n        p.setValue(\"*\");\n        m.put(p.getKey(), p.getValue());\n        \n        monitor = new HttpMonitor();\n        status = monitor.poll(svc, m);        \n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testWithUrl() throws UnknownHostException {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"url\");\n        //found I needed the trailing \"/\" on this url\n        p.setValue(\"/wiki/\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"OpenNMS\");\n        m.put(p.getKey(), p.getValue());\n        \n        //be sure to uncomment this when not running interactively\n//        p.setKey(\"verbose\");\n//        p.setValue(\"true\");\n//        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","id":11522,"modified_method":"public void testWithUrl() throws UnknownHostException {\n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(3, \"www.opennms.org\", \"HTTP\");\n        \n        p.setKey(\"host-name\");\n        p.setValue(\"www.opennms.org\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Enterprise_grade\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-499\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response-text\");\n        p.setValue(\"thousands\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBasicAuthenticationWithHttps() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpsMonitor();\n        MonitoredService svc = getMonitoredService(1, \"localhost\", \"HTTPS\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"443\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/opennms/event/list\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"admin:admin\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","id":11523,"modified_method":"public void _testBasicAuthenticationWithHttps() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpsMonitor();\n        MonitoredService svc = getMonitoredService(1, \"blah.opennms.com\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"443\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/index.php/Main_Page\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"zzzz:zzzz\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testBasicAuthentication() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(1, \"localhost\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"8080\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"1\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n                \n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/opennms/event/list\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"admin:admin\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n    }","id":11524,"modified_method":"public void testBasicAuthentication() throws UnknownHostException {\n        \n        if (m_runTests == false) return;\n        \n        Map<String, String> m = Collections.synchronizedMap(new TreeMap<String, String>());\n        Parameter p = new Parameter();\n        PollStatus status = null;\n        \n        ServiceMonitor monitor = new HttpMonitor();\n        MonitoredService svc = getMonitoredService(1, \"prism.library.cornell.edu\", \"HTTP\");\n        \n        p.setKey(\"port\");\n        p.setValue(\"80\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"retry\");\n        p.setValue(\"0\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"timeout\");\n        p.setValue(\"2000\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"response\");\n        p.setValue(\"100-302\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"verbose\");\n        p.setValue(\"true\");\n        m.put(p.getKey(), p.getValue());\n        \n        p.setKey(\"url\");\n        p.setValue(\"/control/authBasic/authTest/\");\n        m.put(p.getKey(), p.getValue());\n\n        p.setKey(\"basic-authentication\");\n        p.setValue(\"test:this\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_AVAILABLE, status.getStatusCode());\n        assertNull(status.getReason());\n        \n        \n        p.setKey(\"basic-authentication\");\n        p.setValue(\"test:that\");\n        m.put(p.getKey(), p.getValue());\n        \n        status = monitor.poll(svc, m);\n        MockUtil.println(\"Reason: \"+status.getReason());\n        assertEquals(PollStatus.SERVICE_UNAVAILABLE, status.getStatusCode());\n        assertNotNull(status.getReason());\n\n        \n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected int[] getPorts(Map parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","id":11525,"modified_method":"protected int[] determinePorts(Map parameters) {\n        return ParameterMap.getKeyedIntegerArray(parameters, \"port\", DEFAULT_PORTS);\n    }","commit_id":"ea58c012672f980aeea7420f03b7b5d13bf57bd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Initialize servlet and JSP configuration on the first invocation of this\n     * method. All other invocations are ignored. This method is synchronized to\n     * ensure only the first invocation performs the initialization.\n     * \n     * <p>\n     * Call this method in the <code>init<\/code> method of your servlet or\n     * JSP. It will read the servlet initialization parameters from the\n     * <code>ServletConfig<\/code> and <code>ServletContext<\/code> and\n     * OpenNMS configuration files.\n     * <\/p>\n     * \n     * <p>\n     * If this method finds the property <code>opennms.db.poolman<\/code> in\n     * the <code>ServletContext<\/code>, it will create an instance of the\n     * classname specified there to use as the <code>DbConnectionManager<\/code>.\n     * <\/p>\n     * \n     * @param context\n     *            the <code>ServletContext<\/code> instance in which your\n     *            servlet is running\n     */\n    public synchronized static void init(ServletContext context) throws ServletException {\n        if (context == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        // all ThreadCategory instances in the WebUI should use this as their\n        // category prefix\n        ThreadCategory.setPrefix(\"OpenNMS.WEB\");\n\n        if (factory == null) {\n            try {\n                // read the OpenNMS properties\n                Properties properties = new Properties(System.getProperties());\n                properties.load(context.getResourceAsStream(\"/WEB-INF/configuration.properties\"));\n\n                Enumeration initParamNames = context.getInitParameterNames();\n                while (initParamNames.hasMoreElements()) {\n                    String name = (String) initParamNames.nextElement();\n                    properties.put(name, context.getInitParameter(name));\n                }\n\n                String homeDir = properties.getProperty(\"opennms.home\");\n\n                if (homeDir == null) {\n                    throw new ServletException(\"The opennms.home context parameter must be set.\");\n                }\n\n                Vault.setProperties(properties);\n                Vault.setHomeDir(homeDir);\n\n                // initialize Log4J for use inside the webapp\n                org.apache.log4j.LogManager.resetConfiguration();\n                PropertyConfigurator.configure(homeDir + \"/etc/log4j.properties\");\n\n                // get the database parameters from the bluebird properties\n                String dbUrl = properties.getProperty(\"opennms.db.url\");\n                String dbDriver = properties.getProperty(\"opennms.db.driver\");\n                String username = properties.getProperty(\"opennms.db.user\");\n                String password = properties.getProperty(\"opennms.db.password\");\n\n                // set the database connection pool manager (if one is set in\n                // the context)\n                String dbMgrClass = properties.getProperty(\"opennms.db.poolman\");\n\n                if (dbMgrClass != null) {\n                    Class clazz = Class.forName(dbMgrClass);\n                    factory = (DbConnectionFactory) clazz.newInstance();\n                    factory.init(dbUrl, dbDriver, username, password);\n                    Vault.setDbConnectionFactory(factory);\n                }\n            } catch (ClassNotFoundException e) {\n                throw new ServletException(\"Could not find the opennms.db.poolman class\", e);\n            } catch (InstantiationException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (IllegalAccessException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (SQLException e) {\n                throw new ServletException(\"Could not initialize a database connection pool\", e);\n            } catch (IOException e) {\n                throw new ServletException(\"Could not load configuration.properties\", e);\n            }\n        }\n    }","id":11526,"modified_method":"/**\n     * Initialize servlet and JSP configuration on the first invocation of this\n     * method. All other invocations are ignored. This method is synchronized to\n     * ensure only the first invocation performs the initialization.\n     * \n     * <p>\n     * Call this method in the <code>init<\/code> method of your servlet or\n     * JSP. It will read the servlet initialization parameters from the\n     * <code>ServletConfig<\/code> and <code>ServletContext<\/code> and\n     * OpenNMS configuration files.\n     * <\/p>\n     * \n     * <p>\n     * If this method finds the property <code>opennms.db.poolman<\/code> in\n     * the <code>ServletContext<\/code>, it will create an instance of the\n     * classname specified there to use as the <code>DbConnectionManager<\/code>.\n     * <\/p>\n     * \n     * @param context\n     *            the <code>ServletContext<\/code> instance in which your\n     *            servlet is running\n     */\n    public synchronized static void init(ServletContext context) throws ServletException {\n        if (context == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        // all ThreadCategory instances in the WebUI should use this as their\n        // category prefix\n        ThreadCategory.setPrefix(\"OpenNMS.WEB\");\n\n        if (factory == null) {\n            try {\n                String propertiesResource = \"/WEB-INF/configuration.properties\";\n                // read the OpenNMS properties\n                Properties properties = new Properties(System.getProperties());\n                InputStream configurationStream = context.getResourceAsStream(propertiesResource);\n                if (configurationStream == null) {\n                    throw new ServletException(\"Could not load properties from resource \\'\" + propertiesResource + \"\\'\");\n                }\n                properties.load(configurationStream);\n                configurationStream.close();\n\n                Enumeration initParamNames = context.getInitParameterNames();\n                while (initParamNames.hasMoreElements()) {\n                    String name = (String) initParamNames.nextElement();\n                    properties.put(name, context.getInitParameter(name));\n                }\n\n                String homeDir = properties.getProperty(\"opennms.home\");\n\n                if (homeDir == null) {\n                    throw new ServletException(\"The opennms.home context parameter must be set.\");\n                }\n\n                Vault.setProperties(properties);\n                Vault.setHomeDir(homeDir);\n\n                // initialize Log4J for use inside the webapp\n                org.apache.log4j.LogManager.resetConfiguration();\n                PropertyConfigurator.configure(homeDir + \"/etc/log4j.properties\");\n\n                // get the database parameters from the bluebird properties\n                String dbUrl = properties.getProperty(\"opennms.db.url\");\n                String dbDriver = properties.getProperty(\"opennms.db.driver\");\n                String username = properties.getProperty(\"opennms.db.user\");\n                String password = properties.getProperty(\"opennms.db.password\");\n\n                // set the database connection pool manager (if one is set in\n                // the context)\n                String dbMgrClass = properties.getProperty(\"opennms.db.poolman\");\n\n                if (dbMgrClass != null) {\n                    Class clazz = Class.forName(dbMgrClass);\n                    factory = (DbConnectionFactory) clazz.newInstance();\n                    factory.init(dbUrl, dbDriver, username, password);\n                    Vault.setDbConnectionFactory(factory);\n                }\n            } catch (ClassNotFoundException e) {\n                throw new ServletException(\"Could not find the opennms.db.poolman class\", e);\n            } catch (InstantiationException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (IllegalAccessException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (SQLException e) {\n                throw new ServletException(\"Could not initialize a database connection pool\", e);\n            } catch (IOException e) {\n                throw new ServletException(\"Could not load configuration.properties\", e);\n            }\n        }\n    }","commit_id":"b0aaa92751c50841e1525cbe05302195f9bd0bed","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Initialize servlet and JSP configuration on the first invocation of this\n     * method. All other invocations are ignored. This method is synchronized to\n     * ensure only the first invocation performs the initialization.\n     * \n     * <p>\n     * Call this method in the <code>init<\/code> method of your servlet or\n     * JSP. It will read the servlet initialization parameters from the\n     * <code>ServletConfig<\/code> and <code>ServletContext<\/code> and\n     * OpenNMS configuration files.\n     * <\/p>\n     * \n     * <p>\n     * If this method finds the property <code>opennms.db.poolman<\/code> in\n     * the <code>ServletContext<\/code>, it will create an instance of the\n     * classname specified there to use as the <code>DbConnectionManager<\/code>.\n     * <\/p>\n     * \n     * @param context\n     *            the <code>ServletContext<\/code> instance in which your\n     *            servlet is running\n     */\n    public synchronized static void init(ServletContext context) throws ServletException {\n        if (context == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        // all ThreadCategory instances in the WebUI should use this as their\n        // category prefix\n        ThreadCategory.setPrefix(\"OpenNMS.WEB\");\n\n        if (factory == null) {\n            try {\n                // read the OpenNMS properties\n                Properties properties = new Properties(System.getProperties());\n                properties.load(context.getResourceAsStream(\"/WEB-INF/configuration.properties\"));\n\n                Enumeration initParamNames = context.getInitParameterNames();\n                while (initParamNames.hasMoreElements()) {\n                    String name = (String) initParamNames.nextElement();\n                    properties.put(name, context.getInitParameter(name));\n                }\n\n                String homeDir = properties.getProperty(\"opennms.home\");\n\n                if (homeDir == null) {\n                    throw new ServletException(\"The opennms.home context parameter must be set.\");\n                }\n\n                Vault.setProperties(properties);\n                Vault.setHomeDir(homeDir);\n\n                // initialize Log4J for use inside the webapp\n                org.apache.log4j.LogManager.resetConfiguration();\n                PropertyConfigurator.configure(homeDir + \"/etc/log4j.properties\");\n\n                // get the database parameters from the bluebird properties\n                String dbUrl = properties.getProperty(\"opennms.db.url\");\n                String dbDriver = properties.getProperty(\"opennms.db.driver\");\n                String username = properties.getProperty(\"opennms.db.user\");\n                String password = properties.getProperty(\"opennms.db.password\");\n\n                // set the database connection pool manager (if one is set in\n                // the context)\n                String dbMgrClass = properties.getProperty(\"opennms.db.poolman\");\n\n                if (dbMgrClass != null) {\n                    Class clazz = Class.forName(dbMgrClass);\n                    factory = (DbConnectionFactory) clazz.newInstance();\n                    factory.init(dbUrl, dbDriver, username, password);\n                    Vault.setDbConnectionFactory(factory);\n                }\n            } catch (ClassNotFoundException e) {\n                throw new ServletException(\"Could not find the opennms.db.poolman class\", e);\n            } catch (InstantiationException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (IllegalAccessException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (SQLException e) {\n                throw new ServletException(\"Could not initialize a database connection pool\", e);\n            } catch (IOException e) {\n                throw new ServletException(\"Could not load configuration.properties\", e);\n            }\n        }\n    }","id":11527,"modified_method":"/**\n     * Initialize servlet and JSP configuration on the first invocation of this\n     * method. All other invocations are ignored. This method is synchronized to\n     * ensure only the first invocation performs the initialization.\n     * \n     * <p>\n     * Call this method in the <code>init<\/code> method of your servlet or\n     * JSP. It will read the servlet initialization parameters from the\n     * <code>ServletConfig<\/code> and <code>ServletContext<\/code> and\n     * OpenNMS configuration files.\n     * <\/p>\n     * \n     * <p>\n     * If this method finds the property <code>opennms.db.poolman<\/code> in\n     * the <code>ServletContext<\/code>, it will create an instance of the\n     * classname specified there to use as the <code>DbConnectionManager<\/code>.\n     * <\/p>\n     * \n     * @param context\n     *            the <code>ServletContext<\/code> instance in which your\n     *            servlet is running\n     */\n    public synchronized static void init(ServletContext context) throws ServletException {\n        if (context == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        // all ThreadCategory instances in the WebUI should use this as their\n        // category prefix\n        ThreadCategory.setPrefix(\"OpenNMS.WEB\");\n\n        if (factory == null) {\n            try {\n                String propertiesResource = \"/WEB-INF/configuration.properties\";\n                // read the OpenNMS properties\n                Properties properties = new Properties(System.getProperties());\n                InputStream configurationStream = context.getResourceAsStream(propertiesResource);\n                if (configurationStream == null) {\n                    throw new ServletException(\"Could not load properties from resource \\'\" + propertiesResource + \"\\'\");\n                }\n                properties.load(configurationStream);\n                configurationStream.close();\n\n                Enumeration initParamNames = context.getInitParameterNames();\n                while (initParamNames.hasMoreElements()) {\n                    String name = (String) initParamNames.nextElement();\n                    properties.put(name, context.getInitParameter(name));\n                }\n\n                String homeDir = properties.getProperty(\"opennms.home\");\n\n                if (homeDir == null) {\n                    throw new ServletException(\"The opennms.home context parameter must be set.\");\n                }\n\n                Vault.setProperties(properties);\n                Vault.setHomeDir(homeDir);\n\n                // initialize Log4J for use inside the webapp\n                org.apache.log4j.LogManager.resetConfiguration();\n                PropertyConfigurator.configure(homeDir + \"/etc/log4j.properties\");\n\n                // get the database parameters from the bluebird properties\n                String dbUrl = properties.getProperty(\"opennms.db.url\");\n                String dbDriver = properties.getProperty(\"opennms.db.driver\");\n                String username = properties.getProperty(\"opennms.db.user\");\n                String password = properties.getProperty(\"opennms.db.password\");\n\n                // set the database connection pool manager (if one is set in\n                // the context)\n                String dbMgrClass = properties.getProperty(\"opennms.db.poolman\");\n\n                if (dbMgrClass != null) {\n                    Class clazz = Class.forName(dbMgrClass);\n                    factory = (DbConnectionFactory) clazz.newInstance();\n                    factory.init(dbUrl, dbDriver, username, password);\n                    Vault.setDbConnectionFactory(factory);\n                }\n            } catch (ClassNotFoundException e) {\n                throw new ServletException(\"Could not find the opennms.db.poolman class\", e);\n            } catch (InstantiationException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (IllegalAccessException e) {\n                throw new ServletException(\"Could not instantiate the opennms.db.poolman class\", e);\n            } catch (SQLException e) {\n                throw new ServletException(\"Could not initialize a database connection pool\", e);\n            } catch (IOException e) {\n                throw new ServletException(\"Could not load configuration.properties\", e);\n            }\n        }\n    }","commit_id":"081777553091f3a83fc18665e7137e397e6c6a1b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@CheckingMethod\n  public static void checkAppliedCorrectly_generic(final TypeCheckingContext typeCheckingContext, final SNode op) {\n    if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138411891628l, \"jetbrains.mps.lang.smodel.structure.SNodeOperation\"))) {\n      // don't check - it is red anyway \n      return;\n    }\n    final SNode leftExpression = SNodeOperation_Behavior.call_getLeftExpression_1213877508894(op);\n    SNode LeftType = TypeChecker.getInstance().getTypeOf(leftExpression);\n    boolean isGood = false;\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToModel_1262430001741492322\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a4a0(), false)) {\n        isGood = true;\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToConcept_1262430001741498358\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a5a0())) {\n        isGood = true;\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToSConcept_8828148184963745087\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a6a0())) {\n        isGood = true;\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToNode_1262430001741498076\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a7a0(), false)) {\n        isGood = true;\n      }\n    }\n    // =========== \n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToLink_1262430001741498352\", new Object[]{})) {\n      SNode linkAccess = SNodeOperations.as(SNodeOperation_Behavior.call_getLeftExpressionOperation_1213877508946(op), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 4024382256428848843l, \"jetbrains.mps.lang.smodel.structure.ILinkAccess\"));\n      if (linkAccess != null) {\n        isGood = BehaviorReflection.invokeVirtual(Boolean.TYPE, linkAccess, \"virtual_isSingularCardinality_4024382256428848847\", new Object[]{});\n        if (isGood) {\n          // some of ops applicable to 'link' require left-expr to be a concept \n          if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToConcept_1262430001741498358\", new Object[]{}) && !(BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToNode_1262430001741498076\", new Object[]{}))) {\n            isGood = TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a0b0b0b0j0a());\n          }\n        }\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToLinkList_1262430001741498382\", new Object[]{})) {\n      SNode linkAccess = SNodeOperations.as(SNodeOperation_Behavior.call_getLeftExpressionOperation_1213877508946(op), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 4024382256428848843l, \"jetbrains.mps.lang.smodel.structure.ILinkAccess\"));\n      if (linkAccess != null) {\n        isGood = !(BehaviorReflection.invokeVirtual(Boolean.TYPE, linkAccess, \"virtual_isSingularCardinality_4024382256428848847\", new Object[]{}));\n      }\n    }\n    // =========== \n    SNode leftOperation = SNodeOperation_Behavior.call_getLeftExpressionOperation_1213877508946(op);\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToSimpleProperty_1262430001741498100\", new Object[]{})) {\n      if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(leftOperation)), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\"))) {\n        SNode propertyDecl = SLinkOperations.getTarget(SNodeOperations.cast(leftOperation, MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\")), MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, 1138056395725l, \"property\"));\n        if (DataTypeDeclaration_Behavior.call_isSimple_1220268671473(SLinkOperations.getTarget(propertyDecl, MetaAdapterFactory.getReferenceLink(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489288299l, 1082985295845l, \"dataType\")))) {\n          isGood = true;\n        }\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_applicableToEnumProperty_1262430001741498259\", new Object[]{})) {\n      if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(leftOperation)), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\"))) {\n        SNode propertyDecl = SLinkOperations.getTarget(SNodeOperations.cast(leftOperation, MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\")), MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, 1138056395725l, \"property\"));\n        if (DataTypeDeclaration_Behavior.call_isEnum_1220268692373(SLinkOperations.getTarget(propertyDecl, MetaAdapterFactory.getReferenceLink(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489288299l, 1082985295845l, \"dataType\")))) {\n          isGood = true;\n        }\n      }\n    }\n    if (!(isGood)) {\n      MessageTarget errorTarget = new NodeMessageTarget();\n      IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(op, \"operation is not applicable to \" + LeftType, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1186067417054\", null, errorTarget);\n    }\n  }","id":11528,"modified_method":"@CheckingMethod\n  public static void checkAppliedCorrectly_generic(final TypeCheckingContext typeCheckingContext, final SNode op) {\n    if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138411891628l, \"jetbrains.mps.lang.smodel.structure.SNodeOperation\"))) {\n      // don't check - it is red anyway \n      return;\n    }\n    final SNode leftExpression = SNodeOperation_Behavior.call_getLeftExpression_1213877508894(op);\n    SNode LeftType = TypeChecker.getInstance().getTypeOf(leftExpression);\n    boolean isGood = false;\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToModel_1262430001741492322\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a4a0(), false)) {\n        isGood = true;\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToConcept_1262430001741498358\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a5a0())) {\n        isGood = true;\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToSConcept_8828148184963745087\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a6a0())) {\n        isGood = true;\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToNode_1262430001741498076\", new Object[]{})) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a7a0(), false)) {\n        isGood = true;\n      }\n    }\n    // =========== \n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToLink_1262430001741498352\", new Object[]{})) {\n      SNode linkAccess = SNodeOperations.as(SNodeOperation_Behavior.call_getLeftExpressionOperation_1213877508946(op), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 4024382256428848843l, \"jetbrains.mps.lang.smodel.structure.ILinkAccess\"));\n      if (linkAccess != null) {\n        isGood = BehaviorReflection.invokeVirtual(Boolean.TYPE, linkAccess, \"virtual_isSingularCardinality_4024382256428848847\", new Object[]{});\n        if (isGood) {\n          // some of ops applicable to 'link' require left-expr to be a concept \n          if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToConcept_1262430001741498358\", new Object[]{}) && !(BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToNode_1262430001741498076\", new Object[]{}))) {\n            isGood = TypeChecker.getInstance().getSubtypingManager().isSubtype(LeftType, _quotation_createNode_yxkngc_b0a0a0b0b0b0j0a());\n          }\n        }\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToLinkList_1262430001741498382\", new Object[]{})) {\n      SNode linkAccess = SNodeOperations.as(SNodeOperation_Behavior.call_getLeftExpressionOperation_1213877508946(op), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 4024382256428848843l, \"jetbrains.mps.lang.smodel.structure.ILinkAccess\"));\n      if (linkAccess != null) {\n        isGood = !(BehaviorReflection.invokeVirtual(Boolean.TYPE, linkAccess, \"virtual_isSingularCardinality_4024382256428848847\", new Object[]{}));\n      }\n    }\n    // =========== \n    SNode leftOperation = SNodeOperation_Behavior.call_getLeftExpressionOperation_1213877508946(op);\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToSimpleProperty_1262430001741498100\", new Object[]{})) {\n      if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(leftOperation)), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\"))) {\n        SNode propertyDecl = SLinkOperations.getTarget(SNodeOperations.cast(leftOperation, MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\")), MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, 1138056395725l, \"property\"));\n        if (DataTypeDeclaration_Behavior.call_isSimple_1220268671473(SLinkOperations.getTarget(propertyDecl, MetaAdapterFactory.getReferenceLink(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489288299l, 1082985295845l, \"dataType\")))) {\n          isGood = true;\n        }\n      }\n    }\n    if (BehaviorReflection.invokeVirtualStatic(Boolean.TYPE, SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_applicableToEnumProperty_1262430001741498259\", new Object[]{})) {\n      if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(leftOperation)), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\"))) {\n        SNode propertyDecl = SLinkOperations.getTarget(SNodeOperations.cast(leftOperation, MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, \"jetbrains.mps.lang.smodel.structure.SPropertyAccess\")), MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1138056022639l, 1138056395725l, \"property\"));\n        if (DataTypeDeclaration_Behavior.call_isEnum_1220268692373(SLinkOperations.getTarget(propertyDecl, MetaAdapterFactory.getReferenceLink(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489288299l, 1082985295845l, \"dataType\")))) {\n          isGood = true;\n        }\n      }\n    }\n    if (!(isGood)) {\n      MessageTarget errorTarget = new NodeMessageTarget();\n      IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(op, \"operation is not applicable to \" + LeftType, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1186067417054\", null, errorTarget);\n    }\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@CheckingMethod\n  public static boolean checkOpParameters_generic(final TypeCheckingContext typeCheckingContext, SNode op) {\n    boolean noProblem = true;\n    List<SNode> applicableParmConcepts = BehaviorReflection.invokeVirtualStatic((Class<List<SNode>>) ((Class) Object.class), SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(op))), \"virtual_getApplicableParameter_3044950653914717056\", new Object[]{});\n    for (SNode parm : ListSequence.fromList(SLinkOperations.getChildren(op, MetaAdapterFactory.getContainmentLink(new UUID(8675788371017092295l, -9098312342032910879l), 1138411891628l, 1144104376918l, \"parameter\")))) {\n      if (!(ListSequence.fromList(applicableParmConcepts).contains(SNodeOperations.getConceptDeclaration(parm)))) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(parm, \"not applicable here\", \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1178302007667\", null, errorTarget);\n        }\n        noProblem = false;\n      }\n    }\n    return noProblem;\n  }","id":11529,"modified_method":"@CheckingMethod\n  public static boolean checkOpParameters_generic(final TypeCheckingContext typeCheckingContext, SNode op) {\n    boolean noProblem = true;\n    List<SNode> applicableParmConcepts = BehaviorReflection.invokeVirtualStatic((Class<List<SNode>>) ((Class) Object.class), SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(op)), \"virtual_getApplicableParameter_3044950653914717056\", new Object[]{});\n    for (SNode parm : ListSequence.fromList(SLinkOperations.getChildren(op, MetaAdapterFactory.getContainmentLink(new UUID(8675788371017092295l, -9098312342032910879l), 1138411891628l, 1144104376918l, \"parameter\")))) {\n      if (!(ListSequence.fromList(applicableParmConcepts).contains(SNodeOperations.getConceptDeclaration(parm)))) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(parm, \"not applicable here\", \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1178302007667\", null, errorTarget);\n        }\n        noProblem = false;\n      }\n    }\n    return noProblem;\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_bc8hh4_a0d0b(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SConceptType\", null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_2, MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1172420572800l, 1180481110358l, \"conceptDeclaraton\"), (SNode) parameter_1);\n    return quotedNode_2;\n  }","id":11530,"modified_method":"private static SNode _quotation_createNode_bc8hh4_a0a0b0c0b(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null, null, false);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SConceptTypeSConcept\", null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_3, MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 6677504323281689838l, 6677504323281689839l, \"conceptDeclaraton\"), (SNode) parameter_1);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-8968771020793164004l, -7182180101671965361l), 1151688443754l, 1151688676805l, \"elementType\"), quotedNode_3);\n    return quotedNode_2;\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_bc8hh4_a0e0b(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null, null, false);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SConceptType\", null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_3, MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1172420572800l, 1180481110358l, \"conceptDeclaraton\"), (SNode) parameter_1);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-8968771020793164004l, -7182180101671965361l), 1151688443754l, 1151688676805l, \"elementType\"), quotedNode_3);\n    return quotedNode_2;\n  }","id":11531,"modified_method":"private static SNode _quotation_createNode_bc8hh4_a0a0a0c0b(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null, null, false);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SConceptType\", null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_3, MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1172420572800l, 1180481110358l, \"conceptDeclaraton\"), (SNode) parameter_1);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-8968771020793164004l, -7182180101671965361l), 1151688443754l, 1151688676805l, \"elementType\"), quotedNode_3);\n    return quotedNode_2;\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode node, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(new UUID(8675788371017092295l, -9098312342032910879l), 1181952871644l, 1182506816063l, \"smodel\")) != null) {\n      {\n        SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(new UUID(8675788371017092295l, -9098312342032910879l), 1181952871644l, 1182506816063l, \"smodel\"));\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1207683989238\", 0, null);\n        typeCheckingContext.createLessThanInequality((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1207683989240\", true), (SNode) _quotation_createNode_bc8hh4_a0a0a0b(), false, true, _info_12389875345);\n      }\n    }\n    SNode leftExpression = SNodeOperation_Behavior.call_getLeftExpression_1213877508894(node);\n    final SNode C_typevar_1225542306711 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = leftExpression;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"8012235072071559152\", 0, null);\n      typeCheckingContext.createGreaterThanInequality((SNode) _quotation_createNode_bc8hh4_a0d0b(typeCheckingContext.getRepresentative(C_typevar_1225542306711)), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1225542311993\", false), false, true, _info_12389875345);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = node;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1225542362833\", 0, null);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1225542362835\", true), (SNode) _quotation_createNode_bc8hh4_a0e0b(typeCheckingContext.getRepresentative(C_typevar_1225542306711)), _info_12389875345);\n    }\n  }","id":11532,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (SLinkOperations.getTarget(operation, MetaAdapterFactory.getContainmentLink(new UUID(8675788371017092295l, -9098312342032910879l), 1181952871644l, 1182506816063l, \"smodel\")) != null) {\n      {\n        SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(operation, MetaAdapterFactory.getContainmentLink(new UUID(8675788371017092295l, -9098312342032910879l), 1181952871644l, 1182506816063l, \"smodel\"));\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1207683989238\", 0, null);\n        typeCheckingContext.createLessThanInequality((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1207683989240\", true), (SNode) _quotation_createNode_bc8hh4_a0a0a0b(), false, true, _info_12389875345);\n      }\n    }\n    SNode leftExpression = SNodeOperation_Behavior.call_getLeftExpression_1213877508894(operation);\n    {\n      final SNode operandType = typeCheckingContext.typeOf(SNodeOperation_Behavior.call_getLeftExpression_1213877508894(operation), \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716673649\", true);\n      typeCheckingContext.whenConcrete(operandType, new Runnable() {\n        public void run() {\n          if (SNodeOperations.isInstanceOf(typeCheckingContext.getExpandedNode(operandType), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1172420572800l, \"jetbrains.mps.lang.smodel.structure.SConceptType\"))) {\n            {\n              SNode _nodeToCheck_1029348928467 = operation;\n              EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716684434\", 0, null);\n              typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716684445\", true), (SNode) _quotation_createNode_bc8hh4_a0a0a0c0b(SLinkOperations.getTarget(SNodeOperations.cast(typeCheckingContext.getExpandedNode(operandType), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 1172420572800l, \"jetbrains.mps.lang.smodel.structure.SConceptType\")), MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 1172420572800l, 1180481110358l, \"conceptDeclaraton\"))), _info_12389875345);\n            }\n          }\n          if (SNodeOperations.isInstanceOf(typeCheckingContext.getExpandedNode(operandType), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 6677504323281689838l, \"jetbrains.mps.lang.smodel.structure.SConceptTypeSConcept\"))) {\n            {\n              SNode _nodeToCheck_1029348928467 = operation;\n              EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716673635\", 0, null);\n              typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716673647\", true), (SNode) _quotation_createNode_bc8hh4_a0a0b0c0b(SLinkOperations.getTarget(SNodeOperations.cast(typeCheckingContext.getExpandedNode(operandType), MetaAdapterFactory.getConcept(new UUID(8675788371017092295l, -9098312342032910879l), 6677504323281689838l, \"jetbrains.mps.lang.smodel.structure.SConceptTypeSConcept\")), MetaAdapterFactory.getReferenceLink(new UUID(8675788371017092295l, -9098312342032910879l), 6677504323281689838l, 6677504323281689839l, \"conceptDeclaraton\"))), _info_12389875345);\n            }\n          }\n        }\n      }, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716673631\", false, false);\n    }\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_ds5n1i_a0a0b() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SConceptType\", null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-8968771020793164004l, -7182180101671965361l), 1151688443754l, 1151688676805l, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":11533,"modified_method":"private static SNode _quotation_createNode_ds5n1i_a0a0a0b(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-8968771020793164004l, -7182180101671965361l), 1151688443754l, 1151688676805l, \"elementType\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1217023680304\", 0, null);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1217023680306\", true), (SNode) _quotation_createNode_ds5n1i_a0a0b(), _info_12389875345);\n    }\n  }","id":11534,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    {\n      final SNode operandType = typeCheckingContext.typeOf(SNodeOperation_Behavior.call_getLeftExpression_1213877508894(operation), \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716094702\", true);\n      typeCheckingContext.whenConcrete(operandType, new Runnable() {\n        public void run() {\n          {\n            SNode _nodeToCheck_1029348928467 = operation;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1217023680304\", 0, null);\n            typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"1217023680306\", true), (SNode) _quotation_createNode_ds5n1i_a0a0a0b(SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(SNodeOperations.getConceptDeclaration(typeCheckingContext.getExpandedNode(operandType))))), _info_12389875345);\n          }\n        }\n      }, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997715516800\", false, false);\n    }\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"654553635095414171\", 0, null);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"654553635095414176\", true), (SNode) _quotation_createNode_xa2sjl_a0a0b(), _info_12389875345);\n    }\n  }","id":11535,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    {\n      final SNode operandType = typeCheckingContext.typeOf(SNodeOperation_Behavior.call_getLeftExpression_1213877508894(operation), \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716669096\", true);\n      typeCheckingContext.whenConcrete(operandType, new Runnable() {\n        public void run() {\n          {\n            SNode _nodeToCheck_1029348928467 = operation;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716669082\", 0, null);\n            typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716669094\", true), (SNode) _quotation_createNode_xa2sjl_a0a0a0b(SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(SNodeOperations.getConceptDeclaration(typeCheckingContext.getExpandedNode(operandType))))), _info_12389875345);\n          }\n        }\n      }, \"r:00000000-0000-4000-0000-011c895902fe(jetbrains.mps.lang.smodel.typesystem)\", \"7453996997716669078\", false, false);\n    }\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_xa2sjl_a0a0b() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SConceptType\", null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-8968771020793164004l, -7182180101671965361l), 1151688443754l, 1151688676805l, \"elementType\"), quotedNode_2);\n    return quotedNode_1;\n  }","id":11536,"modified_method":"private static SNode _quotation_createNode_xa2sjl_a0a0a0b(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(new UUID(-8968771020793164004l, -7182180101671965361l), 1151688443754l, 1151688676805l, \"elementType\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","commit_id":"6d696ea392d31bc1c585944abb67db6a17e6930f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {\n        try {\n            String originalDirectory = client.printWorkingDirectory();\n\n            boolean success = false;\n            try {\n                // maybe the full directory already exsits\n                success = client.changeWorkingDirectory(directory);\n                if (!success) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Trying to build remote directory: \" + directory);\n                    }\n                    success = client.makeDirectory(directory);\n                    if (!success) {\n                        // we are here if the server side doesn't create intermediate folders so create the folder one by one\n                        buildDirectoryChunks(directory);\n                    }\n                }\n            } finally {\n                // change back to original directory\n                client.changeWorkingDirectory(originalDirectory);\n            }\n\n            return success;\n        } catch (IOException e) {\n            throw new RemoteFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        }\n    }","id":11537,"modified_method":"public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {\n        try {\n            String originalDirectory = client.printWorkingDirectory();\n\n            boolean success = false;\n            try {\n                // maybe the full directory already exsits\n                success = client.changeWorkingDirectory(directory);\n                if (!success) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Trying to build remote directory: \" + directory);\n                    }\n                    success = client.makeDirectory(directory);\n                    if (!success) {\n                        // we are here if the server side doesn't create intermediate folders so create the folder one by one\n                        success = buildDirectoryChunks(directory);\n                    }\n                }\n            } finally {\n                // change back to original directory\n                if (originalDirectory != null) {\n                    client.changeWorkingDirectory(originalDirectory);\n                }\n            }\n\n            return success;\n        } catch (IOException e) {\n            throw new RemoteFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        }\n    }","commit_id":"6de0ef444508d35271e4bc1e812768e0ce013222","url":"https://github.com/apache/camel"},{"original_method":"private boolean buildDirectoryChunks(String dirName) throws IOException {\n        final StringBuilder sb = new StringBuilder(dirName.length());\n        final String[] dirs = dirName.split(\"\\\\/\");\n\n        boolean success = false;\n        for (String dir : dirs) {\n            sb.append(dir).append('/');\n            String directory = sb.toString();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Trying to build remote directory: \" + directory);\n            }\n\n            success = client.makeDirectory(directory);\n        }\n\n        return success;\n    }","id":11538,"modified_method":"private boolean buildDirectoryChunks(String dirName) throws IOException {\n        final StringBuilder sb = new StringBuilder(dirName.length());\n        final String[] dirs = dirName.split(\"\\\\/\");\n\n        boolean success = false;\n        for (String dir : dirs) {\n            sb.append(dir).append('/');\n            String directory = sb.toString();\n\n            // do not try to build root / folder\n            if (!directory.equals(\"/\")) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Trying to build remote directory by chunk: \" + directory);\n                }\n\n                success = client.makeDirectory(directory);\n            }\n        }\n\n        return success;\n    }","commit_id":"6de0ef444508d35271e4bc1e812768e0ce013222","url":"https://github.com/apache/camel"},{"original_method":"protected void initFtpServer() throws Exception {\n        ftpServer = new FtpServer();\n\n        // setup user management to read our users.properties and use clear text passwords\n        PropertiesUserManager uman = new PropertiesUserManager();\n        uman.setFile(new File(\"./src/test/resources/users.properties\").getAbsoluteFile());\n        uman.setPasswordEncryptor(new ClearTextPasswordEncryptor());\n        uman.setAdminName(\"admin\");\n        uman.configure();\n        ftpServer.setUserManager(uman);\n\n        if (port < 21000) {\n            throw new IllegalArgumentException(\"Port number is not initialized in an expected range: \" + getPort());\n        }\n        ftpServer.getListener(\"default\").setPort(port);\n    }","id":11539,"modified_method":"protected void initFtpServer() throws Exception {\n        if (port < 21000) {\n            throw new IllegalArgumentException(\"Port number is not initialized in an expected range: \" + getPort());\n        }\n\n        FtpServerFactory serverFactory = new FtpServerFactory();\n\n        // setup user management to read our users.properties and use clear text passwords\n        File file = new File(\"./src/test/resources/users.properties\").getAbsoluteFile();\n        UserManager uman = new PropertiesUserManager(new ClearTextPasswordEncryptor(), file, \"admin\");\n        serverFactory.setUserManager(uman);\n\n        NativeFileSystemFactory fsf = new NativeFileSystemFactory();\n        fsf.setCreateHome(true);\n        serverFactory.setFileSystem(fsf);\n\n        ListenerFactory factory = new ListenerFactory();\n        factory.setPort(port);\n        serverFactory.addListener(\"default\", factory.createListener());\n\n        ftpServer = serverFactory.createServer();\n    }","commit_id":"6de0ef444508d35271e4bc1e812768e0ce013222","url":"https://github.com/apache/camel"},{"original_method":"private boolean buildDirectoryChunks(String dirName) throws IOException, SftpException {\n        final StringBuilder sb = new StringBuilder(dirName.length());\n        final String[] dirs = dirName.split(\"\\\\/\");\n\n        boolean success = false;\n        for (String dir : dirs) {\n            sb.append(dir).append('/');\n            String directory = sb.toString();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Trying to build remote directory: \" + directory);\n            }\n\n            try {\n                channel.mkdir(directory);\n                success = true;\n            } catch (SftpException e) {\n                // ignore keep trying to create the rest of the path\n            }\n        }\n\n        return success;\n    }","id":11540,"modified_method":"private boolean buildDirectoryChunks(String dirName) throws IOException, SftpException {\n        final StringBuilder sb = new StringBuilder(dirName.length());\n        final String[] dirs = dirName.split(\"\\\\/\");\n\n        boolean success = false;\n        for (String dir : dirs) {\n            sb.append(dir).append('/');\n            String directory = sb.toString();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Trying to build remote directory by chunk: \" + directory);\n            }\n\n            // do not try to build root / folder\n            if (!directory.equals(\"/\")) {\n                try {\n                    channel.mkdir(directory);\n                    success = true;\n                } catch (SftpException e) {\n                    // ignore keep trying to create the rest of the path\n                }\n            }\n        }\n\n        return success;\n    }","commit_id":"6de0ef444508d35271e4bc1e812768e0ce013222","url":"https://github.com/apache/camel"},{"original_method":"public FtpEndpoint() {\n        this.operations = new FtpOperations();\n    }","id":11541,"modified_method":"public FtpEndpoint() {\n        FtpOperations operations = new FtpOperations();\n        operations.setEndpoint(this);\n        this.operations = operations;\n    }","commit_id":"3d4ba8bd497e9b46dc52d81c6feebf3cfedd6e5a","url":"https://github.com/apache/camel"},{"original_method":"public SftpEndpoint() {\n        this.operations = new SftpOperations();\n    }","id":11542,"modified_method":"public SftpEndpoint() {\n        SftpOperations operations = new SftpOperations();\n        operations.setEndpoint(this);\n        this.operations = operations;\n    }","commit_id":"3d4ba8bd497e9b46dc52d81c6feebf3cfedd6e5a","url":"https://github.com/apache/camel"},{"original_method":"protected void initFtpServer() throws Exception {\n        ftpServer = new FtpServer();\n\n        // setup user management to read our users.properties and use clear text passwords\n        PropertiesUserManager uman = new PropertiesUserManager();\n        uman.setFile(new File(\"./src/test/resources/users.properties\").getAbsoluteFile());\n        uman.setPasswordEncryptor(new ClearTextPasswordEncryptor());\n        uman.setAdminName(\"admin\");\n        uman.configure();\n        ftpServer.setUserManager(uman);\n\n        ftpServer.getListener(\"default\").setPort(20123);\n    }","id":11543,"modified_method":"protected void initFtpServer() throws Exception {\n        FtpServerFactory serverFactory = new FtpServerFactory();\n\n        // setup user management to read our users.properties and use clear text passwords\n        File file = new File(\"./src/test/resources/users.properties\").getAbsoluteFile();\n        UserManager uman = new PropertiesUserManager(new ClearTextPasswordEncryptor(), file, \"admin\");\n        serverFactory.setUserManager(uman);\n\n        NativeFileSystemFactory fsf = new NativeFileSystemFactory();\n        fsf.setCreateHome(true);\n        serverFactory.setFileSystem(fsf);\n\n        ListenerFactory factory = new ListenerFactory();\n        factory.setPort(20123);\n        serverFactory.addListener(\"default\", factory.createListener());\n\n        ftpServer = serverFactory.createServer();\n    }","commit_id":"3d4ba8bd497e9b46dc52d81c6feebf3cfedd6e5a","url":"https://github.com/apache/camel"},{"original_method":"protected void initFtpServer() throws Exception {\n        ftpServer = new FtpServer();\n\n        // setup user management to read our users.properties and use clear text passwords\n        PropertiesUserManager uman = new PropertiesUserManager();\n        uman.setFile(new File(\"./src/test/resources/users.properties\").getAbsoluteFile());\n        uman.setPasswordEncryptor(new ClearTextPasswordEncryptor());\n        uman.setAdminName(\"admin\");\n        uman.configure();\n        ftpServer.setUserManager(uman);\n\n        ftpServer.getListener(\"default\").setPort(20125);\n    }","id":11544,"modified_method":"protected void initFtpServer() throws Exception {\n        FtpServerFactory serverFactory = new FtpServerFactory();\n\n        // setup user management to read our users.properties and use clear text passwords\n        File file = new File(\"./src/test/resources/users.properties\").getAbsoluteFile();\n        UserManager uman = new PropertiesUserManager(new ClearTextPasswordEncryptor(), file, \"admin\");\n        serverFactory.setUserManager(uman);\n\n        NativeFileSystemFactory fsf = new NativeFileSystemFactory();\n        fsf.setCreateHome(true);\n        serverFactory.setFileSystem(fsf);\n\n        ListenerFactory factory = new ListenerFactory();\n        factory.setPort(20125);\n        serverFactory.addListener(\"default\", factory.createListener());\n\n        ftpServer = serverFactory.createServer();\n    }","commit_id":"3d4ba8bd497e9b46dc52d81c6feebf3cfedd6e5a","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWithObject() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(\"Hi Claus how are you? Its a nice day.\\nGive my regards to the family Ibsen.\");\n\n        MyPerson person = new MyPerson();\n        person.setFamilyName(\"Ibsen\");\n        person.setGivenName(\"Claus\");\n\n        template.requestBody(\"direct:in\", person);\n\n        mock.assertIsSatisfied();\n    }","id":11545,"modified_method":"@Test\n    public void testWithObject() throws Exception {\n        String msg = String.format(\"Hi Claus how are you? Its a nice day.%sGive my regards to the family Ibsen.\",\n                System.lineSeparator());\n\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(msg);\n\n        MyPerson person = new MyPerson();\n        person.setFamilyName(\"Ibsen\");\n        person.setGivenName(\"Claus\");\n\n        template.requestBody(\"direct:in\", person);\n\n        mock.assertIsSatisfied();\n    }","commit_id":"efa976884cb8659788ad4cbd1d46e19577d1cb8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testVelocityLetter() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(\"Dear Ibsen, Claus\\n\\nThanks for the order of Camel in Action.\\n\\nRegards Camel Riders Bookstore\\nPS: Next beer is on me, James\");\n\n        template.send(\"direct:a\", createLetter());\n\n        mock.assertIsSatisfied();\n        \n        mock.reset();\n        \n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(\"Dear Ibsen, Claus\\n\\nThanks for the order of Camel in Action.\\n\\nRegards Apache Camel Riders Bookstore\\nPS: Next beer is on me, James\");\n\n        template.send(\"direct:a\", createLetter());\n\n        mock.assertIsSatisfied();\n    }","id":11546,"modified_method":"@Test\n    public void testVelocityLetter() throws Exception {\n        String msg = String.format(\"Dear Ibsen, Claus%s%sThanks for the order of Camel in Action.%s%sRegards Camel Riders Bookstore%sPS: Next beer is on me, James\",\n                System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator());\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(msg);\n\n        template.send(\"direct:a\", createLetter());\n\n        mock.assertIsSatisfied();\n        \n        mock.reset();\n\n        String msg2 = String.format(\"Dear Ibsen, Claus%s%sThanks for the order of Camel in Action.%s%sRegards Apache Camel Riders Bookstore%sPS: Next beer is on me, James\",\n                System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator());\n        mock.expectedBodiesReceived(msg2);\n\n        template.send(\"direct:a\", createLetter());\n\n        mock.assertIsSatisfied();\n    }","commit_id":"efa976884cb8659788ad4cbd1d46e19577d1cb8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testVelocityLetter() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(\"Dear Ibsen, Claus\\n\\nThanks for the order of Camel in Action.\\n\\nRegards Camel Riders Bookstore\\nPS: Next beer is on me, James\");\n\n        template.send(\"direct:a\", createLetter());\n\n        mock.assertIsSatisfied();\n    }","id":11547,"modified_method":"@Test\n    public void testVelocityLetter() throws Exception {\n        String msg = String.format(\"Dear Ibsen, Claus%s%sThanks for the order of Camel in Action.%s%sRegards Camel Riders Bookstore%sPS: Next beer is on me, James\",\n                System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator());\n\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(msg);\n\n        template.send(\"direct:a\", createLetter());\n\n        mock.assertIsSatisfied();\n    }","commit_id":"efa976884cb8659788ad4cbd1d46e19577d1cb8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testVelocityLetter() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(\"Dear Ibsen, Claus\\n\\nThanks for the order of Camel in Action.\\n\\nRegards Camel Riders Bookstore\\nPS: Next beer is on me, James\");\n\n        template.send(\"direct:a\", createLetter(\"org/apache/camel/component/velocity/letter.vm\"));\n\n        mock.assertIsSatisfied();\n        \n        mock.reset();\n        \n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(\"Dear Ibsen, Claus\\n\\nThanks for the order of Camel in Action.\\n\\nRegards Apache Camel Riders Bookstore\\nPS: Next beer is on me, James\");\n\n        template.send(\"direct:a\", createLetter(\"org/apache/camel/component/velocity/letter2.vm\"));\n\n        mock.assertIsSatisfied();\n    }","id":11548,"modified_method":"@Test\n    public void testVelocityLetter() throws Exception {\n        String msg = String.format(\"Dear Ibsen, Claus%s%sThanks for the order of Camel in Action.%s%sRegards Camel Riders Bookstore%sPS: Next beer is on me, James\",\n                System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator());\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(msg);\n\n        template.send(\"direct:a\", createLetter(\"org/apache/camel/component/velocity/letter.vm\"));\n\n        mock.assertIsSatisfied();\n        \n        mock.reset();\n\n        String msg2 = String.format(\"Dear Ibsen, Claus%s%sThanks for the order of Camel in Action.%s%sRegards Apache Camel Riders Bookstore%sPS: Next beer is on me, James\",\n                System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator(), System.lineSeparator());\n        mock.expectedBodiesReceived(msg2);\n\n        template.send(\"direct:a\", createLetter(\"org/apache/camel/component/velocity/letter2.vm\"));\n\n        mock.assertIsSatisfied();\n    }","commit_id":"efa976884cb8659788ad4cbd1d46e19577d1cb8b","url":"https://github.com/apache/camel"},{"original_method":"public static void main (String[] args) {\r\n        final JFrame frame = new JFrame();\r\n        frame.setLayout(new BorderLayout());\r\n        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\r\n        final Arrow arrow = new Arrow();\r\n        frame.add(arrow, BorderLayout.CENTER);\r\n        frame.setSize(640, 480);\r\n        frame.setResizable(false);\r\n        frame.setVisible(true);\r\n        frame.getContentPane().addMouseMotionListener(new MouseMotionListener() {\r\n            public void mouseMoved (MouseEvent e) {\r\n                arrow.setArrowLocation(320, 240, e.getX(), e.getY());\r\n            }\r\n\r\n            public void mouseDragged (MouseEvent e) {\r\n            }\r\n        });\r\n    }","id":11549,"modified_method":"public static void main(String[] args) {\r\n        final JFrame frame = new JFrame();\r\n        frame.setLayout(new BorderLayout());\r\n        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\r\n        final Arrow arrow = new Arrow();\r\n        frame.add(arrow, BorderLayout.CENTER);\r\n        frame.setSize(640, 480);\r\n        frame.setResizable(false);\r\n        frame.setVisible(true);\r\n        frame.getContentPane().addMouseMotionListener(new MouseMotionListener() {\r\n            @Override\r\n            public void mouseMoved(MouseEvent e) {\r\n                arrow.setArrowLocation(320, 240, e.getX(), e.getY());\r\n            }\r\n\r\n            @Override\r\n            public void mouseDragged(MouseEvent e) {\r\n            }\r\n        });\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"private void initComponents() {\r\n        initPopupMenuTriggerOrder();\r\n        setBackground(new Color(0, 0, 0, 100));\r\n        //setLayout(new GridBagLayout());\r\n        setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));\r\n        setOpaque(false);\r\n\r\n        JPanel container = new JPanel();\r\n\r\n        container.setPreferredSize(new Dimension(100, 30));\r\n        container.setMinimumSize(new Dimension(20, 20));\r\n        container.setMaximumSize(new Dimension(2000, 100));\r\n        container.setLayout(new GridBagLayout());\r\n        container.setOpaque(false);\r\n\r\n        JPanel jPanel = new JPanel();\r\n\r\n        textArea = new MageTextArea();\r\n        textArea.setText(\"<Empty>\");\r\n\r\n        jPanel.setOpaque(false);\r\n        jPanel.setBackground(new Color(0, 0, 0, 80));\r\n        jPanel.add(textArea);\r\n        add(jPanel);\r\n\r\n        add(container);\r\n\r\n        btnSpecial = new JButton(\"Special\");\r\n        btnSpecial.setVisible(false);\r\n        container.add(btnSpecial);\r\n        btnLeft = new JButton(\"OK\");\r\n        btnLeft.setVisible(false);\r\n        container.add(btnLeft);\r\n        btnRight = new JButton(\"Cancel\");\r\n        btnRight.setVisible(false);\r\n        container.add(btnRight);\r\n        btnUndo = new JButton(\"Undo\");\r\n        btnUndo.setVisible(false);\r\n        container.add(btnUndo);\r\n\r\n        MouseListener checkPopupAdapter = new MouseAdapter() {\r\n            @Override\r\n            public void mousePressed(MouseEvent me) {\r\n                checkPopupMenu(me);\r\n            }\r\n\r\n            @Override\r\n            public void mouseReleased(MouseEvent me) {\r\n                checkPopupMenu(me);\r\n            }\r\n\r\n        };\r\n\r\n        btnLeft.addMouseListener(checkPopupAdapter);\r\n        btnLeft.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkLeft != null) {\r\n                    clickButton(linkLeft);\r\n                }\r\n            }\r\n        });\r\n\r\n        btnRight.addMouseListener(checkPopupAdapter);\r\n        btnRight.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkRight != null) {\r\n                    clickButton(linkRight);\r\n                }\r\n            }\r\n        });\r\n\r\n        btnSpecial.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkSpecial != null) {\r\n                    {\r\n//                        if (evt.getActionCommand().equals(\"automatic\")) {\r\n//                            showPopupMenu(evt);\r\n//                        } else {\r\n                        clickButton(linkSpecial);\r\n//                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        btnUndo.addActionListener(new java.awt.event.ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkUndo != null) {\r\n                    {\r\n                        Thread worker = new Thread() {\r\n                            @Override\r\n                            public void run() {\r\n                                SwingUtilities.invokeLater(new Runnable() {\r\n                                    @Override\r\n                                    public void run() {\r\n                                        linkUndo.doClick();\r\n                                    }\r\n                                });\r\n                            }\r\n                        };\r\n                        worker.start();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // sets a darker background and higher simiss time fur tooltip in the feedback / helper panel\r\n        textArea.addMouseListener(new MouseAdapter() {\r\n\r\n            @Override\r\n            public void mouseEntered(MouseEvent me) {\r\n                ToolTipManager.sharedInstance().setDismissDelay(100000);\r\n                UIManager.put(\"info\", Color.DARK_GRAY);\r\n            }\r\n\r\n            @Override\r\n            public void mouseExited(MouseEvent me) {\r\n                ToolTipManager.sharedInstance().setDismissDelay(defaultDismissTimeout);\r\n                UIManager.put(\"info\", tooltipBackground);\r\n            }\r\n        });\r\n    }","id":11550,"modified_method":"private void initComponents() {\r\n        initPopupMenuTriggerOrder();\r\n        setBackground(new Color(0, 0, 0, 100));\r\n        //setLayout(new GridBagLayout());\r\n        setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));\r\n        setOpaque(false);\r\n\r\n        JPanel container = new JPanel();\r\n\r\n        container.setPreferredSize(new Dimension(100, 30));\r\n        container.setMinimumSize(new Dimension(20, 20));\r\n        container.setMaximumSize(new Dimension(2000, 100));\r\n        container.setLayout(new GridBagLayout());\r\n        container.setOpaque(false);\r\n\r\n        JPanel jPanel = new JPanel();\r\n\r\n        textArea = new MageTextArea();\r\n        textArea.setText(\"<Empty>\");\r\n\r\n        jPanel.setOpaque(false);\r\n        jPanel.setBackground(new Color(0, 0, 0, 80));\r\n        jPanel.add(textArea);\r\n        add(jPanel);\r\n\r\n        add(container);\r\n\r\n        btnSpecial = new JButton(\"Special\");\r\n        btnSpecial.setVisible(false);\r\n        container.add(btnSpecial);\r\n        btnLeft = new JButton(\"OK\");\r\n        btnLeft.setVisible(false);\r\n        container.add(btnLeft);\r\n        btnRight = new JButton(\"Cancel\");\r\n        btnRight.setVisible(false);\r\n        container.add(btnRight);\r\n        btnUndo = new JButton(\"Undo\");\r\n        btnUndo.setVisible(false);\r\n        container.add(btnUndo);\r\n\r\n        MouseListener checkPopupAdapter = new MouseAdapter() {\r\n            @Override\r\n            public void mousePressed(MouseEvent me) {\r\n                checkPopupMenu(me);\r\n            }\r\n\r\n            @Override\r\n            public void mouseReleased(MouseEvent me) {\r\n                checkPopupMenu(me);\r\n            }\r\n\r\n        };\r\n\r\n        btnLeft.addMouseListener(checkPopupAdapter);\r\n        btnLeft.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkLeft != null) {\r\n                    clickButton(linkLeft);\r\n                }\r\n            }\r\n        });\r\n\r\n        btnRight.addMouseListener(checkPopupAdapter);\r\n        btnRight.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkRight != null) {\r\n                    clickButton(linkRight);\r\n                }\r\n            }\r\n        });\r\n\r\n        btnSpecial.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkSpecial != null) {\r\n                    clickButton(linkSpecial);\r\n                }\r\n            }\r\n        });\r\n\r\n        btnUndo.addActionListener(new java.awt.event.ActionListener() {\r\n            @Override\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                if (linkUndo != null) {\r\n                    {\r\n                        Thread worker = new Thread() {\r\n                            @Override\r\n                            public void run() {\r\n                                SwingUtilities.invokeLater(new Runnable() {\r\n                                    @Override\r\n                                    public void run() {\r\n                                        linkUndo.doClick();\r\n                                    }\r\n                                });\r\n                            }\r\n                        };\r\n                        worker.start();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // sets a darker background and higher simiss time fur tooltip in the feedback / helper panel\r\n        textArea.addMouseListener(new MouseAdapter() {\r\n\r\n            @Override\r\n            public void mouseEntered(MouseEvent me) {\r\n                ToolTipManager.sharedInstance().setDismissDelay(100000);\r\n                UIManager.put(\"info\", Color.DARK_GRAY);\r\n            }\r\n\r\n            @Override\r\n            public void mouseExited(MouseEvent me) {\r\n                ToolTipManager.sharedInstance().setDismissDelay(defaultDismissTimeout);\r\n                UIManager.put(\"info\", tooltipBackground);\r\n            }\r\n        });\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"protected void waitForResponse(Game game) {\r\n        response.clear();\r\n        log.debug(\"Waiting response from player: \" + getId());\r\n        game.resumeTimer(getTurnControlledBy());\r\n        synchronized (response) {\r\n            try {\r\n                response.wait();\r\n                log.debug(\"Got response from player: \" + getId());\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            } finally {\r\n                game.pauseTimer(getTurnControlledBy());\r\n            }\r\n        }\r\n    }","id":11551,"modified_method":"protected void waitForResponse(Game game) {\r\n        response.clear();\r\n        logger.debug(\"Waiting response from player: \" + getId());\r\n        game.resumeTimer(getTurnControlledBy());\r\n        synchronized (response) {\r\n            try {\r\n                response.wait();\r\n                logger.debug(\"Got response from player: \" + getId());\r\n            } catch (InterruptedException ex) {\r\n                logger.error(\"Response error for player \" + getName() + \" gameId: \" + game.getId(), ex);\r\n            } finally {\r\n                game.pauseTimer(getTurnControlledBy());\r\n            }\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public int announceXCost(int min, int max, String message, Game game, Ability ability, VariableCost variableCost) {\r\n        int xValue = 0;\r\n        updateGameStatePriority(\"announceXCost\", game);\r\n        game.fireGetAmountEvent(playerId, message, min, max);\r\n        waitForIntegerResponse(game);\r\n        if (response != null && response.getInteger() != null) {\r\n            xValue = response.getInteger();\r\n        }\r\n        return xValue;\r\n    }","id":11552,"modified_method":"@Override\r\n    public int announceXCost(int min, int max, String message, Game game, Ability ability, VariableCost variableCost) {\r\n        int xValue = 0;\r\n        updateGameStatePriority(\"announceXCost\", game);\r\n        do {\r\n            game.fireGetAmountEvent(playerId, message, min, max);\r\n            waitForResponse(game);\r\n        } while (response.getInteger() == null && !abort);\r\n        if (response != null && response.getInteger() != null) {\r\n            xValue = response.getInteger();\r\n        }\r\n        return xValue;\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean choosePile(Outcome outcome, String message, List<? extends Card> pile1, List<? extends Card> pile2, Game game) {\r\n        updateGameStatePriority(\"choosePile\", game);\r\n        game.fireChoosePileEvent(playerId, message, pile1, pile2);\r\n        waitForBooleanResponse(game);\r\n        if (!abort) {\r\n            return response.getBoolean();\r\n        }\r\n        return false;\r\n    }","id":11553,"modified_method":"@Override\r\n    public boolean choosePile(Outcome outcome, String message, List<? extends Card> pile1, List<? extends Card> pile2, Game game) {\r\n        updateGameStatePriority(\"choosePile\", game);\r\n        do {\r\n            game.fireChoosePileEvent(playerId, message, pile1, pile2);\r\n            waitForResponse(game);\r\n        } while (response.getBoolean() == null && !abort);\r\n        if (!abort) {\r\n            return response.getBoolean();\r\n        }\r\n        return false;\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void setResponseUUID(UUID responseUUID) {\r\n        synchronized (response) {\r\n            response.setUUID(responseUUID);\r\n            response.notify();\r\n            log.debug(\"Got response UUID from player: \" + getId());\r\n        }\r\n    }","id":11554,"modified_method":"@Override\r\n    public void setResponseUUID(UUID responseUUID) {\r\n        synchronized (response) {\r\n            response.setUUID(responseUUID);\r\n            response.notify();\r\n            logger.debug(\"Got response UUID from player: \" + getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public int getAmount(int min, int max, String message, Game game) {\r\n        updateGameStatePriority(\"getAmount\", game);\r\n        game.fireGetAmountEvent(playerId, message, min, max);\r\n        waitForIntegerResponse(game);\r\n        if (response != null && response.getInteger() != null) {\r\n            return response.getInteger();\r\n        } else {\r\n            return 0;\r\n        }\r\n    }","id":11555,"modified_method":"@Override\r\n    public int getAmount(int min, int max, String message, Game game) {\r\n        updateGameStatePriority(\"getAmount\", game);\r\n        do {\r\n            game.fireGetAmountEvent(playerId, message, min, max);\r\n            waitForResponse(game);\r\n        } while (response.getInteger() == null && !abort);\r\n        if (response != null && response.getInteger() != null) {\r\n            return response.getInteger();\r\n        } else {\r\n            return 0;\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void skip() {\r\n        synchronized (response) {\r\n            response.setInteger(0);\r\n            response.notify();\r\n            log.debug(\"Got skip action from player: \" + getId());\r\n        }\r\n    }","id":11556,"modified_method":"@Override\r\n    public void skip() {\r\n        synchronized (response) {\r\n            response.setInteger(0);\r\n            response.notify();\r\n            logger.debug(\"Got skip action from player: \" + getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean chooseUse(Outcome outcome, String message, Ability source, Game game) {\r\n        if (source != null) {\r\n            Boolean answer = requestAutoAnswerId.get(source.getOriginalId() + \"#\" + message);\r\n            if (answer != null) {\r\n                return answer;\r\n            } else {\r\n                answer = requestAutoAnswerText.get(message);\r\n                if (answer != null) {\r\n                    return answer;\r\n                }\r\n            }\r\n        }\r\n        updateGameStatePriority(\"chooseUse\", game);\r\n        game.fireAskPlayerEvent(playerId, new MessageToClient(message, getRelatedObjectName(source, game)), source);\r\n        waitForBooleanResponse(game);\r\n        if (!abort) {\r\n            return response.getBoolean();\r\n        }\r\n        return false;\r\n    }","id":11557,"modified_method":"@Override\r\n    public boolean chooseUse(Outcome outcome, String message, Ability source, Game game) {\r\n        if (source != null) {\r\n            Boolean answer = requestAutoAnswerId.get(source.getOriginalId() + \"#\" + message);\r\n            if (answer != null) {\r\n                return answer;\r\n            } else {\r\n                answer = requestAutoAnswerText.get(message);\r\n                if (answer != null) {\r\n                    return answer;\r\n                }\r\n            }\r\n        }\r\n        updateGameStatePriority(\"chooseUse\", game);\r\n        do {\r\n            game.fireAskPlayerEvent(playerId, new MessageToClient(message, getRelatedObjectName(source, game)), source);\r\n            waitForResponse(game);\r\n        } while (response.getBoolean() == null && !abort);\r\n        if (!abort) {\r\n            return response.getBoolean();\r\n        }\r\n        return false;\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"protected void updateGameStatePriority(String methodName, Game game) {\r\n        if (game.getState().getPriorityPlayerId() != null) { // don't do it if priority was set to null before (e.g. discard in cleanaup)\r\n            log.debug(\"Setting game priority to \" + getId() + \" [\" + methodName + \"]\");\r\n            game.getState().setPriorityPlayerId(getId());\r\n        }\r\n    }","id":11558,"modified_method":"protected void updateGameStatePriority(String methodName, Game game) {\r\n        if (game.getState().getPriorityPlayerId() != null) { // don't do it if priority was set to null before (e.g. discard in cleanaup)\r\n            logger.debug(\"Setting game priority to \" + getId() + \" [\" + methodName + \"]\");\r\n            game.getState().setPriorityPlayerId(getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"private boolean suppressAbilityPicker(ActivatedAbility ability) {\r\n        if (this.getUserData().isShowAbilityPickerForced()) {\r\n            if (ability instanceof PlayLandAbility) {\r\n                return true;\r\n            }\r\n            if (!ability.getSourceId().equals(getCastSourceIdWithAlternateMana()) && ability.getManaCostsToPay().convertedManaCost() > 0) {\r\n                return true;\r\n            }\r\n            if (ability instanceof ManaAbility) {\r\n                return true;\r\n            }\r\n            // if ability has no mana costs you have to pick it from ability picker\r\n            return false;\r\n        }\r\n        return true;\r\n    }","id":11559,"modified_method":"private boolean suppressAbilityPicker(ActivatedAbility ability) {\r\n        if (this.getUserData().isShowAbilityPickerForced()) {\r\n            if (ability instanceof PlayLandAbility) {\r\n                return true;\r\n            }\r\n            if (!ability.getSourceId().equals(getCastSourceIdWithAlternateMana()) && ability.getManaCostsToPay().convertedManaCost() > 0) {\r\n                return true;\r\n            }\r\n            return ability instanceof ManaAbility;\r\n        }\r\n        return true;\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void abort() {\r\n        abort = true;\r\n        synchronized (response) {\r\n            response.notify();\r\n            log.debug(\"Got cancel action from player: \" + getId());\r\n        }\r\n    }","id":11560,"modified_method":"@Override\r\n    public void abort() {\r\n        abort = true;\r\n        synchronized (response) {\r\n            response.notify();\r\n            logger.debug(\"Got cancel action from player: \" + getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean chooseMulligan(Game game) {\r\n        updateGameStatePriority(\"chooseMulligan\", game);\r\n        int nextHandSize = game.mulliganDownTo(playerId);\r\n        game.fireAskPlayerEvent(playerId, new MessageToClient(\"Mulligan \"\r\n                + (getHand().size() > nextHandSize ? \"down to \" : \"for free, draw \")\r\n                + nextHandSize + (nextHandSize == 1 ? \" card?\" : \" cards?\")), null);\r\n        waitForBooleanResponse(game);\r\n        if (!abort) {\r\n            return response.getBoolean();\r\n        }\r\n        return false;\r\n    }","id":11561,"modified_method":"@Override\r\n    public boolean chooseMulligan(Game game) {\r\n        updateGameStatePriority(\"chooseMulligan\", game);\r\n        int nextHandSize = game.mulliganDownTo(playerId);\r\n        do {\r\n            game.fireAskPlayerEvent(playerId, new MessageToClient(\"Mulligan \"\r\n                    + (getHand().size() > nextHandSize ? \"down to \" : \"for free, draw \")\r\n                    + nextHandSize + (nextHandSize == 1 ? \" card?\" : \" cards?\")), null);\r\n            waitForResponse(game);\r\n        } while (response.getBoolean() == null && !abort);\r\n        if (!abort) {\r\n            return response.getBoolean();\r\n        }\r\n        return false;\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public int chooseReplacementEffect(Map<String, String> rEffects, Game game) {\r\n        updateGameStatePriority(\"chooseEffect\", game);\r\n        if (rEffects.size() == 1) {\r\n            return 0;\r\n        }\r\n        if (!autoSelectReplacementEffects.isEmpty()) {\r\n            for (String autoKey : autoSelectReplacementEffects) {\r\n                int count = 0;\r\n                for (String effectKey : rEffects.keySet()) {\r\n                    if (effectKey.equals(autoKey)) {\r\n                        return count;\r\n                    }\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n\r\n        replacementEffectChoice.getChoices().clear();\r\n        replacementEffectChoice.setKeyChoices(rEffects);\r\n\r\n        while (!abort) {\r\n            game.fireChooseChoiceEvent(playerId, replacementEffectChoice);\r\n            waitForResponse(game);\r\n            log.debug(\"Choose effect: \" + response.getString());\r\n            if (response.getString() != null) {\r\n                if (response.getString().startsWith(\"#\")) {\r\n                    autoSelectReplacementEffects.add(response.getString().substring(1));\r\n                    replacementEffectChoice.setChoiceByKey(response.getString().substring(1));\r\n                } else {\r\n                    replacementEffectChoice.setChoiceByKey(response.getString());\r\n                }\r\n                if (replacementEffectChoice.getChoiceKey() != null) {\r\n                    int index = 0;\r\n                    for (String key : rEffects.keySet()) {\r\n                        if (replacementEffectChoice.getChoiceKey().equals(key)) {\r\n                            return index;\r\n                        }\r\n                        index++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }","id":11562,"modified_method":"@Override\r\n    public int chooseReplacementEffect(Map<String, String> rEffects, Game game) {\r\n        updateGameStatePriority(\"chooseEffect\", game);\r\n        if (rEffects.size() == 1) {\r\n            return 0;\r\n        }\r\n        if (!autoSelectReplacementEffects.isEmpty()) {\r\n            for (String autoKey : autoSelectReplacementEffects) {\r\n                int count = 0;\r\n                for (String effectKey : rEffects.keySet()) {\r\n                    if (effectKey.equals(autoKey)) {\r\n                        return count;\r\n                    }\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n\r\n        replacementEffectChoice.getChoices().clear();\r\n        replacementEffectChoice.setKeyChoices(rEffects);\r\n\r\n        while (!abort) {\r\n            game.fireChooseChoiceEvent(playerId, replacementEffectChoice);\r\n            waitForResponse(game);\r\n            logger.debug(\"Choose effect: \" + response.getString());\r\n            if (response.getString() != null) {\r\n                if (response.getString().startsWith(\"#\")) {\r\n                    autoSelectReplacementEffects.add(response.getString().substring(1));\r\n                    replacementEffectChoice.setChoiceByKey(response.getString().substring(1));\r\n                } else {\r\n                    replacementEffectChoice.setChoiceByKey(response.getString());\r\n                }\r\n                if (replacementEffectChoice.getChoiceKey() != null) {\r\n                    int index = 0;\r\n                    for (String key : rEffects.keySet()) {\r\n                        if (replacementEffectChoice.getChoiceKey().equals(key)) {\r\n                            return index;\r\n                        }\r\n                        index++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void setResponseString(String responseString) {\r\n        synchronized (response) {\r\n            response.setString(responseString);\r\n            response.notify();\r\n            log.debug(\"Got response string from player: \" + getId());\r\n        }\r\n    }","id":11563,"modified_method":"@Override\r\n    public void setResponseString(String responseString) {\r\n        synchronized (response) {\r\n            response.setString(responseString);\r\n            response.notify();\r\n            logger.debug(\"Got response string from player: \" + getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void setResponseBoolean(Boolean responseBoolean) {\r\n        synchronized (response) {\r\n            response.setBoolean(responseBoolean);\r\n            response.notify();\r\n            log.debug(\"Got response boolean from player: \" + getId());\r\n        }\r\n    }","id":11564,"modified_method":"@Override\r\n    public void setResponseBoolean(Boolean responseBoolean) {\r\n        synchronized (response) {\r\n            response.setBoolean(responseBoolean);\r\n            response.notify();\r\n            logger.debug(\"Got response boolean from player: \" + getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"/**\r\n     * Gets the amount of mana the player want to spent for a x spell\r\n     *\r\n     * @param min\r\n     * @param max\r\n     * @param message\r\n     * @param game\r\n     * @param ability\r\n     * @return\r\n     */\r\n    @Override\r\n    public int announceXMana(int min, int max, String message, Game game, Ability ability) {\r\n        int xValue = 0;\r\n        updateGameStatePriority(\"announceXMana\", game);\r\n        game.fireGetAmountEvent(playerId, message, min, max);\r\n        waitForIntegerResponse(game);\r\n        if (response != null && response.getInteger() != null) {\r\n            xValue = response.getInteger();\r\n        }\r\n        return xValue;\r\n    }","id":11565,"modified_method":"/**\r\n     * Gets the amount of mana the player want to spent for a x spell\r\n     *\r\n     * @param min\r\n     * @param max\r\n     * @param message\r\n     * @param game\r\n     * @param ability\r\n     * @return\r\n     */\r\n    @Override\r\n    public int announceXMana(int min, int max, String message, Game game, Ability ability) {\r\n        int xValue = 0;\r\n        updateGameStatePriority(\"announceXMana\", game);\r\n        do {\r\n            game.fireGetAmountEvent(playerId, message, min, max);\r\n            waitForResponse(game);\r\n        } while (response.getInteger() == null && !abort);\r\n        if (response != null && response.getInteger() != null) {\r\n            xValue = response.getInteger();\r\n        }\r\n        return xValue;\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void setResponseManaType(UUID manaTypePlayerId, ManaType manaType) {\r\n        synchronized (response) {\r\n            response.setManaType(manaType);\r\n            response.setResponseManaTypePlayerId(manaTypePlayerId);\r\n            response.notify();\r\n            log.debug(\"Got response mana type from player: \" + getId());\r\n        }\r\n    }","id":11566,"modified_method":"@Override\r\n    public void setResponseManaType(UUID manaTypePlayerId, ManaType manaType) {\r\n        synchronized (response) {\r\n            response.setManaType(manaType);\r\n            response.setResponseManaTypePlayerId(manaTypePlayerId);\r\n            response.notify();\r\n            logger.debug(\"Got response mana type from player: \" + getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void setResponseInteger(Integer responseInteger) {\r\n        synchronized (response) {\r\n            response.setInteger(responseInteger);\r\n            response.notify();\r\n            log.debug(\"Got response integer from player: \" + getId());\r\n        }\r\n    }","id":11567,"modified_method":"@Override\r\n    public void setResponseInteger(Integer responseInteger) {\r\n        synchronized (response) {\r\n            response.setInteger(responseInteger);\r\n            response.notify();\r\n            logger.debug(\"Got response integer from player: \" + getId());\r\n        }\r\n    }","commit_id":"39e62095e4ed6e83b6977ceffc9b3de39314a5d6","url":"https://github.com/magefree/mage"},{"original_method":"private BucketSearchResult splitBucket(List<Long> path, int keyIndex, K keyToInsert) throws IOException {\n    long pageIndex = path.get(path.size() - 1);\n    OCacheEntry bucketEntry = diskCache.load(fileId, pageIndex, false);\n    OCachePointer bucketPointer = bucketEntry.getCachePointer();\n\n    bucketPointer.acquireExclusiveLock();\n    try {\n      OSBTreeBonsaiBucket<K, V> bucketToSplit = new OSBTreeBonsaiBucket<K, V>(bucketPointer.getDataPointer(), keySerializer,\n          valueSerializer, getTrackMode());\n\n      final boolean splitLeaf = bucketToSplit.isLeaf();\n      final int bucketSize = bucketToSplit.size();\n\n      int indexToSplit = bucketSize >>> 1;\n      final K separationKey = bucketToSplit.getKey(indexToSplit);\n      final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> rightEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n          indexToSplit);\n\n      final int startRightIndex = splitLeaf ? indexToSplit : indexToSplit + 1;\n\n      for (int i = startRightIndex; i < bucketSize; i++)\n        rightEntries.add(bucketToSplit.getEntry(i));\n\n      if (pageIndex != rootIndex) {\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        OCachePointer rightBucketPointer = rightBucketEntry.getCachePointer();\n\n        rightBucketPointer.acquireExclusiveLock();\n\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightBucketPointer.getDataPointer(), splitLeaf,\n              keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          bucketToSplit.shrink(indexToSplit);\n\n          if (splitLeaf) {\n            long rightSiblingPageIndex = bucketToSplit.getRightSibling();\n\n            newRightBucket.setRightSibling(rightSiblingPageIndex);\n            newRightBucket.setLeftSibling(pageIndex);\n\n            bucketToSplit.setRightSibling(rightBucketEntry.getPageIndex());\n\n            if (rightSiblingPageIndex >= 0) {\n              final OCacheEntry rightSiblingBucketEntry = diskCache.load(fileId, rightSiblingPageIndex, false);\n              final OCachePointer rightSiblingPointer = rightSiblingBucketEntry.getCachePointer();\n\n              rightSiblingPointer.acquireExclusiveLock();\n              OSBTreeBonsaiBucket<K, V> rightSiblingBucket = new OSBTreeBonsaiBucket<K, V>(rightSiblingPointer.getDataPointer(),\n                  keySerializer, valueSerializer, getTrackMode());\n              try {\n                rightSiblingBucket.setLeftSibling(rightBucketEntry.getPageIndex());\n                logPageChanges(rightSiblingBucket, fileId, rightSiblingPageIndex, false);\n\n                rightSiblingBucketEntry.markDirty();\n              } finally {\n                rightSiblingPointer.releaseExclusiveLock();\n                diskCache.release(rightSiblingBucketEntry);\n              }\n            }\n          }\n\n          long parentIndex = path.get(path.size() - 2);\n          OCacheEntry parentCacheEntry = diskCache.load(fileId, parentIndex, false);\n          OCachePointer parentPointer = parentCacheEntry.getCachePointer();\n\n          parentPointer.acquireExclusiveLock();\n          try {\n            OSBTreeBonsaiBucket<K, V> parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(), keySerializer,\n                valueSerializer, getTrackMode());\n            OSBTreeBonsaiBucket.SBTreeEntry<K, V> parentEntry = new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(pageIndex,\n                rightBucketEntry.getPageIndex(), separationKey, null);\n\n            int insertionIndex = parentBucket.find(separationKey);\n            assert insertionIndex < 0;\n\n            insertionIndex = -insertionIndex - 1;\n            while (!parentBucket.addEntry(insertionIndex, parentEntry, true)) {\n              parentPointer.releaseExclusiveLock();\n              diskCache.release(parentCacheEntry);\n\n              BucketSearchResult bucketSearchResult = splitBucket(path.subList(0, path.size() - 1), insertionIndex, separationKey);\n\n              parentIndex = bucketSearchResult.getLastPathItem();\n              parentCacheEntry = diskCache.load(fileId, parentIndex, false);\n              parentPointer = parentCacheEntry.getCachePointer();\n\n              parentPointer.acquireExclusiveLock();\n\n              insertionIndex = bucketSearchResult.itemIndex;\n\n              parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(), keySerializer, valueSerializer,\n                  getTrackMode());\n            }\n\n            logPageChanges(parentBucket, fileId, parentIndex, false);\n          } finally {\n            parentCacheEntry.markDirty();\n            parentPointer.releaseExclusiveLock();\n\n            diskCache.release(parentCacheEntry);\n          }\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n        } finally {\n          rightBucketEntry.markDirty();\n          rightBucketPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        logPageChanges(bucketToSplit, fileId, pageIndex, false);\n        ArrayList<Long> resultPath = new ArrayList<Long>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(pageIndex);\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketEntry.getPageIndex());\n        if (splitLeaf) {\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n        }\n\n        resultPath.add(rightBucketEntry.getPageIndex());\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n\n      } else {\n        long treeSize = bucketToSplit.getTreeSize();\n\n        final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> leftEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n            indexToSplit);\n\n        for (int i = 0; i < indexToSplit; i++)\n          leftEntries.add(bucketToSplit.getEntry(i));\n\n        OCacheEntry leftBucketEntry = diskCache.allocateNewPage(fileId);\n        OCachePointer leftBucketPointer = leftBucketEntry.getCachePointer();\n\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        leftBucketPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newLeftBucket = new OSBTreeBonsaiBucket<K, V>(leftBucketPointer.getDataPointer(), splitLeaf,\n              keySerializer, valueSerializer, getTrackMode());\n          newLeftBucket.addAll(leftEntries);\n\n          if (splitLeaf)\n            newLeftBucket.setRightSibling(rightBucketEntry.getPageIndex());\n\n          logPageChanges(newLeftBucket, fileId, leftBucketEntry.getPageIndex(), true);\n          leftBucketEntry.markDirty();\n        } finally {\n          leftBucketPointer.releaseExclusiveLock();\n          diskCache.release(leftBucketEntry);\n        }\n\n        OCachePointer rightBucketPointer = rightBucketEntry.getCachePointer();\n        rightBucketPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightBucketPointer.getDataPointer(), splitLeaf,\n              keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          if (splitLeaf)\n            newRightBucket.setLeftSibling(leftBucketEntry.getPageIndex());\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n          rightBucketEntry.markDirty();\n        } finally {\n          rightBucketPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        bucketToSplit = new OSBTreeBonsaiBucket<K, V>(bucketPointer.getDataPointer(), false, keySerializer, valueSerializer,\n            getTrackMode());\n        bucketToSplit.setTreeSize(treeSize);\n\n        bucketToSplit.addEntry(0,\n            new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(leftBucketEntry.getPageIndex(), rightBucketEntry.getPageIndex(),\n                separationKey, null), true);\n\n        logPageChanges(bucketToSplit, fileId, pageIndex, false);\n        ArrayList<Long> resultPath = new ArrayList<Long>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(leftBucketEntry.getPageIndex());\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketEntry.getPageIndex());\n\n        if (splitLeaf)\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n      }\n\n    } finally {\n      bucketEntry.markDirty();\n      bucketPointer.releaseExclusiveLock();\n      diskCache.release(bucketEntry);\n    }\n  }","id":11568,"modified_method":"private BucketSearchResult splitBucket(List<OBonsaiBucketPointer> path, int keyIndex, K keyToInsert) throws IOException {\n    final OBonsaiBucketPointer bucketPointer = path.get(path.size() - 1);\n    OCacheEntry bucketEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n    OCachePointer pointer = bucketEntry.getCachePointer();\n\n    pointer.acquireExclusiveLock();\n    try {\n      OSBTreeBonsaiBucket<K, V> bucketToSplit = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(),\n          bucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n\n      final boolean splitLeaf = bucketToSplit.isLeaf();\n      final int bucketSize = bucketToSplit.size();\n\n      int indexToSplit = bucketSize >>> 1;\n      final K separationKey = bucketToSplit.getKey(indexToSplit);\n      final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> rightEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n          indexToSplit);\n\n      final int startRightIndex = splitLeaf ? indexToSplit : indexToSplit + 1;\n\n      for (int i = startRightIndex; i < bucketSize; i++)\n        rightEntries.add(bucketToSplit.getEntry(i));\n\n      if (!bucketPointer.equals(rootBucketPointer)) {\n        // TODO\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        final OBonsaiBucketPointer rightBucketPointer = new OBonsaiBucketPointer(rightBucketEntry.getPageIndex());\n\n        OCachePointer rightPointer = rightBucketEntry.getCachePointer();\n\n        rightPointer.acquireExclusiveLock();\n\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightPointer.getDataPointer(),\n              rightBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          bucketToSplit.shrink(indexToSplit);\n\n          if (splitLeaf) {\n            OBonsaiBucketPointer rightSiblingBucketPointer = bucketToSplit.getRightSibling();\n\n            newRightBucket.setRightSibling(rightSiblingBucketPointer);\n            newRightBucket.setLeftSibling(bucketPointer);\n\n            bucketToSplit.setRightSibling(rightBucketPointer);\n\n            if (rightSiblingBucketPointer.isValid()) {\n              final OCacheEntry rightSiblingBucketEntry = diskCache.load(fileId, rightSiblingBucketPointer.getPageIndex(), false);\n              final OCachePointer rightSiblingPointer = rightSiblingBucketEntry.getCachePointer();\n\n              rightSiblingPointer.acquireExclusiveLock();\n              OSBTreeBonsaiBucket<K, V> rightSiblingBucket = new OSBTreeBonsaiBucket<K, V>(rightSiblingPointer.getDataPointer(),\n                  rightSiblingBucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n              try {\n                rightSiblingBucket.setLeftSibling(rightBucketPointer);\n                logPageChanges(rightSiblingBucket, fileId, rightSiblingBucketPointer.getPageIndex(), false);\n\n                rightSiblingBucketEntry.markDirty();\n              } finally {\n                rightSiblingPointer.releaseExclusiveLock();\n                diskCache.release(rightSiblingBucketEntry);\n              }\n            }\n          }\n\n          OBonsaiBucketPointer parentBucketPointer = path.get(path.size() - 2);\n          OCacheEntry parentCacheEntry = diskCache.load(fileId, parentBucketPointer.getPageIndex(), false);\n          OCachePointer parentPointer = parentCacheEntry.getCachePointer();\n\n          parentPointer.acquireExclusiveLock();\n          try {\n            OSBTreeBonsaiBucket<K, V> parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(),\n                parentBucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n            OSBTreeBonsaiBucket.SBTreeEntry<K, V> parentEntry = new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(bucketPointer,\n                rightBucketPointer, separationKey, null);\n\n            int insertionIndex = parentBucket.find(separationKey);\n            assert insertionIndex < 0;\n\n            insertionIndex = -insertionIndex - 1;\n            while (!parentBucket.addEntry(insertionIndex, parentEntry, true)) {\n              parentPointer.releaseExclusiveLock();\n              diskCache.release(parentCacheEntry);\n\n              BucketSearchResult bucketSearchResult = splitBucket(path.subList(0, path.size() - 1), insertionIndex, separationKey);\n\n              parentBucketPointer = bucketSearchResult.getLastPathItem();\n              parentCacheEntry = diskCache.load(fileId, parentBucketPointer.getPageIndex(), false);\n              parentPointer = parentCacheEntry.getCachePointer();\n\n              parentPointer.acquireExclusiveLock();\n\n              insertionIndex = bucketSearchResult.itemIndex;\n\n              parentBucket = new OSBTreeBonsaiBucket<K, V>(parentPointer.getDataPointer(), parentBucketPointer.getPageOffset(),\n                  keySerializer, valueSerializer, getTrackMode());\n            }\n\n            logPageChanges(parentBucket, fileId, parentBucketPointer.getPageIndex(), false);\n          } finally {\n            parentCacheEntry.markDirty();\n            parentPointer.releaseExclusiveLock();\n\n            diskCache.release(parentCacheEntry);\n          }\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n        } finally {\n          rightBucketEntry.markDirty();\n          rightPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        logPageChanges(bucketToSplit, fileId, bucketPointer.getPageIndex(), false);\n        ArrayList<OBonsaiBucketPointer> resultPath = new ArrayList<OBonsaiBucketPointer>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(bucketPointer);\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketPointer);\n        if (splitLeaf) {\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n        }\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n\n      } else {\n        long treeSize = bucketToSplit.getTreeSize();\n\n        final List<OSBTreeBonsaiBucket.SBTreeEntry<K, V>> leftEntries = new ArrayList<OSBTreeBonsaiBucket.SBTreeEntry<K, V>>(\n            indexToSplit);\n\n        for (int i = 0; i < indexToSplit; i++)\n          leftEntries.add(bucketToSplit.getEntry(i));\n\n        // TODO\n        OCacheEntry leftBucketEntry = diskCache.allocateNewPage(fileId);\n        OBonsaiBucketPointer leftBucketPointer = new OBonsaiBucketPointer(leftBucketEntry.getPageIndex());\n        OCachePointer leftPointer = leftBucketEntry.getCachePointer();\n\n        // TODO\n        OCacheEntry rightBucketEntry = diskCache.allocateNewPage(fileId);\n        OBonsaiBucketPointer rightBucketPointer = new OBonsaiBucketPointer(rightBucketEntry.getPageIndex());\n        leftPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newLeftBucket = new OSBTreeBonsaiBucket<K, V>(leftPointer.getDataPointer(),\n              leftBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newLeftBucket.addAll(leftEntries);\n\n          if (splitLeaf)\n            newLeftBucket.setRightSibling(rightBucketPointer);\n\n          logPageChanges(newLeftBucket, fileId, leftBucketEntry.getPageIndex(), true);\n          leftBucketEntry.markDirty();\n        } finally {\n          leftPointer.releaseExclusiveLock();\n          diskCache.release(leftBucketEntry);\n        }\n\n        OCachePointer rightPointer = rightBucketEntry.getCachePointer();\n        rightPointer.acquireExclusiveLock();\n        try {\n          OSBTreeBonsaiBucket<K, V> newRightBucket = new OSBTreeBonsaiBucket<K, V>(rightPointer.getDataPointer(),\n              rightBucketPointer.getPageOffset(), splitLeaf, keySerializer, valueSerializer, getTrackMode());\n          newRightBucket.addAll(rightEntries);\n\n          if (splitLeaf)\n            newRightBucket.setLeftSibling(leftBucketPointer);\n\n          logPageChanges(newRightBucket, fileId, rightBucketEntry.getPageIndex(), true);\n          rightBucketEntry.markDirty();\n        } finally {\n          rightPointer.releaseExclusiveLock();\n          diskCache.release(rightBucketEntry);\n        }\n\n        bucketToSplit = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), bucketPointer.getPageOffset(), false,\n            keySerializer, valueSerializer, getTrackMode());\n        bucketToSplit.setTreeSize(treeSize);\n\n        bucketToSplit.addEntry(0, new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(leftBucketPointer, rightBucketPointer, separationKey,\n            null), true);\n\n        logPageChanges(bucketToSplit, fileId, bucketPointer.getPageIndex(), false);\n        ArrayList<OBonsaiBucketPointer> resultPath = new ArrayList<OBonsaiBucketPointer>(path.subList(0, path.size() - 1));\n\n        if (comparator.compare(keyToInsert, separationKey) < 0) {\n          resultPath.add(leftBucketPointer);\n          return new BucketSearchResult(keyIndex, resultPath);\n        }\n\n        resultPath.add(rightBucketPointer);\n\n        if (splitLeaf)\n          return new BucketSearchResult(keyIndex - indexToSplit, resultPath);\n\n        return new BucketSearchResult(keyIndex - indexToSplit - 1, resultPath);\n      }\n\n    } finally {\n      bucketEntry.markDirty();\n      pointer.releaseExclusiveLock();\n      diskCache.release(bucketEntry);\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private BucketSearchResult findBucket(K key, PartialSearchMode partialSearchMode) throws IOException {\n    long pageIndex = rootIndex;\n    final ArrayList<Long> path = new ArrayList<Long>();\n\n    if (!(keySize == 1 || ((OCompositeKey) key).getKeys().size() == keySize || partialSearchMode.equals(PartialSearchMode.NONE))) {\n      final OCompositeKey fullKey = new OCompositeKey((Comparable<? super K>) key);\n      int itemsToAdd = keySize - fullKey.getKeys().size();\n\n      final Comparable<?> keyItem;\n      if (partialSearchMode.equals(PartialSearchMode.HIGHEST_BOUNDARY))\n        keyItem = ALWAYS_GREATER_KEY;\n      else\n        keyItem = ALWAYS_LESS_KEY;\n\n      for (int i = 0; i < itemsToAdd; i++)\n        fullKey.addKey(keyItem);\n\n      key = (K) fullKey;\n    }\n\n    while (true) {\n      path.add(pageIndex);\n      final OCacheEntry bucketEntry = diskCache.load(fileId, pageIndex, false);\n      final OCachePointer bucketPointer = bucketEntry.getCachePointer();\n\n      final OSBTreeBonsaiBucket.SBTreeEntry<K, V> entry;\n      try {\n        final OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(bucketPointer.getDataPointer(), keySerializer,\n            valueSerializer, ODurablePage.TrackMode.NONE);\n        final int index = keyBucket.find(key);\n\n        if (keyBucket.isLeaf())\n          return new BucketSearchResult(index, path);\n\n        if (index >= 0)\n          entry = keyBucket.getEntry(index);\n        else {\n          final int insertionIndex = -index - 1;\n          if (insertionIndex >= keyBucket.size())\n            entry = keyBucket.getEntry(insertionIndex - 1);\n          else\n            entry = keyBucket.getEntry(insertionIndex);\n        }\n\n      } finally {\n        diskCache.release(bucketEntry);\n      }\n\n      if (comparator.compare(key, entry.key) >= 0)\n        pageIndex = entry.rightChild;\n      else\n        pageIndex = entry.leftChild;\n    }\n  }","id":11569,"modified_method":"private BucketSearchResult findBucket(K key, PartialSearchMode partialSearchMode) throws IOException {\n    OBonsaiBucketPointer bucketPointer = rootBucketPointer;\n    final ArrayList<OBonsaiBucketPointer> path = new ArrayList<OBonsaiBucketPointer>();\n\n    if (!(keySize == 1 || ((OCompositeKey) key).getKeys().size() == keySize || partialSearchMode.equals(PartialSearchMode.NONE))) {\n      final OCompositeKey fullKey = new OCompositeKey((Comparable<? super K>) key);\n      int itemsToAdd = keySize - fullKey.getKeys().size();\n\n      final Comparable<?> keyItem;\n      if (partialSearchMode.equals(PartialSearchMode.HIGHEST_BOUNDARY))\n        keyItem = ALWAYS_GREATER_KEY;\n      else\n        keyItem = ALWAYS_LESS_KEY;\n\n      for (int i = 0; i < itemsToAdd; i++)\n        fullKey.addKey(keyItem);\n\n      key = (K) fullKey;\n    }\n\n    while (true) {\n      path.add(bucketPointer);\n      final OCacheEntry bucketEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n      final OCachePointer pointer = bucketEntry.getCachePointer();\n\n      final OSBTreeBonsaiBucket.SBTreeEntry<K, V> entry;\n      try {\n        final OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(),\n            bucketPointer.getPageOffset(), keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n        final int index = keyBucket.find(key);\n\n        if (keyBucket.isLeaf())\n          return new BucketSearchResult(index, path);\n\n        if (index >= 0)\n          entry = keyBucket.getEntry(index);\n        else {\n          final int insertionIndex = -index - 1;\n          if (insertionIndex >= keyBucket.size())\n            entry = keyBucket.getEntry(insertionIndex - 1);\n          else\n            entry = keyBucket.getEntry(insertionIndex);\n        }\n\n      } finally {\n        diskCache.release(bucketEntry);\n      }\n\n      if (comparator.compare(key, entry.key) >= 0)\n        bucketPointer = entry.rightChild;\n      else\n        bucketPointer = entry.leftChild;\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void put(K key, V value) {\n    acquireExclusiveLock();\n    final OStorageTransaction transaction = storage.getStorageTransaction();\n    try {\n      startDurableOperation(transaction);\n\n      BucketSearchResult bucketSearchResult = findBucket(key, PartialSearchMode.NONE);\n\n      OCacheEntry keyBucketCacheEntry = diskCache.load(fileId, bucketSearchResult.getLastPathItem(), false);\n      OCachePointer keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n\n      keyBucketPointer.acquireExclusiveLock();\n      OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(), keySerializer,\n          valueSerializer, getTrackMode());\n\n      if (bucketSearchResult.itemIndex >= 0) {\n        while (!keyBucket.updateValue(bucketSearchResult.itemIndex, value)) {\n          keyBucketPointer.releaseExclusiveLock();\n          diskCache.release(keyBucketCacheEntry);\n\n          bucketSearchResult = splitBucket(bucketSearchResult.path, bucketSearchResult.itemIndex, key);\n\n          keyBucketCacheEntry = diskCache.load(fileId, bucketSearchResult.getLastPathItem(), false);\n          keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n          keyBucketPointer.acquireExclusiveLock();\n\n          keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(), keySerializer, valueSerializer,\n              getTrackMode());\n        }\n\n        logPageChanges(keyBucket, fileId, bucketSearchResult.getLastPathItem(), false);\n      } else {\n        int insertionIndex = -bucketSearchResult.itemIndex - 1;\n\n        while (!keyBucket.addEntry(insertionIndex, new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(-1, -1, key, value), true)) {\n          keyBucketPointer.releaseExclusiveLock();\n          diskCache.release(keyBucketCacheEntry);\n\n          bucketSearchResult = splitBucket(bucketSearchResult.path, insertionIndex, key);\n\n          insertionIndex = bucketSearchResult.itemIndex;\n\n          keyBucketCacheEntry = diskCache.load(fileId, bucketSearchResult.getLastPathItem(), false);\n          keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n          keyBucketPointer.acquireExclusiveLock();\n\n          keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(), keySerializer, valueSerializer,\n              getTrackMode());\n        }\n\n        logPageChanges(keyBucket, fileId, bucketSearchResult.getLastPathItem(), false);\n      }\n\n      keyBucketCacheEntry.markDirty();\n      keyBucketPointer.releaseExclusiveLock();\n      diskCache.release(keyBucketCacheEntry);\n\n      if (bucketSearchResult.itemIndex < 0)\n        setSize(size() + 1);\n\n      endDurableOperation(transaction, false);\n    } catch (IOException e) {\n      rollback(transaction);\n      throw new OSBTreeException(\"Error during index update with key \" + key + \" and value \" + value, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","id":11570,"modified_method":"public void put(K key, V value) {\n    acquireExclusiveLock();\n    final OStorageTransaction transaction = storage.getStorageTransaction();\n    try {\n      startDurableOperation(transaction);\n\n      BucketSearchResult bucketSearchResult = findBucket(key, PartialSearchMode.NONE);\n      OBonsaiBucketPointer bucketPointer = bucketSearchResult.getLastPathItem();\n\n      OCacheEntry keyBucketCacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n      OCachePointer keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n\n      keyBucketPointer.acquireExclusiveLock();\n      OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(),\n          bucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n\n      if (bucketSearchResult.itemIndex >= 0) {\n        while (!keyBucket.updateValue(bucketSearchResult.itemIndex, value)) {\n          keyBucketPointer.releaseExclusiveLock();\n          diskCache.release(keyBucketCacheEntry);\n\n          bucketSearchResult = splitBucket(bucketSearchResult.path, bucketSearchResult.itemIndex, key);\n          bucketPointer = bucketSearchResult.getLastPathItem();\n\n          keyBucketCacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n          keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n          keyBucketPointer.acquireExclusiveLock();\n\n          keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(), bucketPointer.getPageOffset(),\n              keySerializer, valueSerializer, getTrackMode());\n        }\n\n        logPageChanges(keyBucket, fileId, bucketSearchResult.getLastPathItem().getPageIndex(), false);\n      } else {\n        int insertionIndex = -bucketSearchResult.itemIndex - 1;\n\n        while (!keyBucket.addEntry(insertionIndex, new OSBTreeBonsaiBucket.SBTreeEntry<K, V>(OBonsaiBucketPointer.NULL,\n            OBonsaiBucketPointer.NULL, key, value), true)) {\n          keyBucketPointer.releaseExclusiveLock();\n          diskCache.release(keyBucketCacheEntry);\n\n          bucketSearchResult = splitBucket(bucketSearchResult.path, insertionIndex, key);\n          bucketPointer = bucketSearchResult.getLastPathItem();\n\n          insertionIndex = bucketSearchResult.itemIndex;\n\n          keyBucketCacheEntry = diskCache.load(fileId, bucketSearchResult.getLastPathItem().getPageIndex(), false);\n          keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n          keyBucketPointer.acquireExclusiveLock();\n\n          keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(), bucketPointer.getPageOffset(),\n              keySerializer, valueSerializer, getTrackMode());\n        }\n\n        logPageChanges(keyBucket, fileId, bucketPointer.getPageIndex(), false);\n      }\n\n      keyBucketCacheEntry.markDirty();\n      keyBucketPointer.releaseExclusiveLock();\n      diskCache.release(keyBucketCacheEntry);\n\n      if (bucketSearchResult.itemIndex < 0)\n        setSize(size() + 1);\n\n      endDurableOperation(transaction, false);\n    } catch (IOException e) {\n      rollback(transaction);\n      throw new OSBTreeException(\"Error during index update with key \" + key + \" and value \" + value, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void setSize(long size) throws IOException {\n    OCacheEntry rootCacheEntry = diskCache.load(fileId, rootIndex, false);\n\n    OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n    rootPointer.acquireExclusiveLock();\n    try {\n      OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(), keySerializer,\n          valueSerializer, getTrackMode());\n      rootBucket.setTreeSize(size);\n\n      logPageChanges(rootBucket, fileId, rootIndex, false);\n      rootCacheEntry.markDirty();\n    } finally {\n      rootPointer.releaseExclusiveLock();\n      diskCache.release(rootCacheEntry);\n    }\n  }","id":11571,"modified_method":"private void setSize(long size) throws IOException {\n    OCacheEntry rootCacheEntry = diskCache.load(fileId, rootBucketPointer.getPageIndex(), false);\n\n    OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n    rootPointer.acquireExclusiveLock();\n    try {\n      OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(),\n          rootBucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n      rootBucket.setTreeSize(size);\n\n      logPageChanges(rootBucket, fileId, rootBucketPointer.getPageIndex(), false);\n      rootCacheEntry.markDirty();\n    } finally {\n      rootPointer.releaseExclusiveLock();\n      diskCache.release(rootCacheEntry);\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public V get(K key) {\n    acquireSharedLock();\n    try {\n      BucketSearchResult bucketSearchResult = findBucket(key, PartialSearchMode.NONE);\n      if (bucketSearchResult.itemIndex < 0)\n        return null;\n\n      long pageIndex = bucketSearchResult.getLastPathItem();\n      OCacheEntry keyBucketCacheEntry = diskCache.load(fileId, pageIndex, false);\n      OCachePointer keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n      try {\n        OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(), keySerializer,\n            valueSerializer, ODurablePage.TrackMode.NONE);\n        return keyBucket.getEntry(bucketSearchResult.itemIndex).value;\n      } finally {\n        diskCache.release(keyBucketCacheEntry);\n      }\n\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during retrieving  of sbtree with name \" + name, e);\n    } finally {\n      releaseSharedLock();\n    }\n  }","id":11572,"modified_method":"public V get(K key) {\n    acquireSharedLock();\n    try {\n      BucketSearchResult bucketSearchResult = findBucket(key, PartialSearchMode.NONE);\n      if (bucketSearchResult.itemIndex < 0)\n        return null;\n\n      OBonsaiBucketPointer bucketPointer = bucketSearchResult.getLastPathItem();\n\n      OCacheEntry keyBucketCacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n      OCachePointer keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n      try {\n        OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(),\n            bucketPointer.getPageOffset(), keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n        return keyBucket.getEntry(bucketSearchResult.itemIndex).value;\n      } finally {\n        diskCache.release(keyBucketCacheEntry);\n      }\n\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during retrieving  of sbtree with name \" + name, e);\n    } finally {\n      releaseSharedLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long getLastPathItem() {\n      return path.get(path.size() - 1);\n    }","id":11573,"modified_method":"public OBonsaiBucketPointer getLastPathItem() {\n      return path.get(path.size() - 1);\n    }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public V remove(K key) {\n    acquireExclusiveLock();\n    OStorageTransaction transaction = storage.getStorageTransaction();\n    try {\n      startDurableOperation(transaction);\n\n      BucketSearchResult bucketSearchResult = findBucket(key, PartialSearchMode.NONE);\n      if (bucketSearchResult.itemIndex < 0)\n        return null;\n\n      OCacheEntry keyBucketCacheEntry = diskCache.load(fileId, bucketSearchResult.getLastPathItem(), false);\n      OCachePointer keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n\n      keyBucketPointer.acquireExclusiveLock();\n      try {\n        OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(), keySerializer,\n            valueSerializer, getTrackMode());\n\n        final V removed = keyBucket.getEntry(bucketSearchResult.itemIndex).value;\n\n        keyBucket.remove(bucketSearchResult.itemIndex);\n\n        logPageChanges(keyBucket, fileId, keyBucketCacheEntry.getPageIndex(), false);\n        keyBucketCacheEntry.markDirty();\n\n        endDurableOperation(transaction, false);\n        return removed;\n      } finally {\n        keyBucketPointer.releaseExclusiveLock();\n        diskCache.release(keyBucketCacheEntry);\n        setSize(size() - 1);\n      }\n\n    } catch (IOException e) {\n      rollback(transaction);\n\n      throw new OSBTreeException(\"Error during removing key \" + key + \" from sbtree \" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","id":11574,"modified_method":"public V remove(K key) {\n    acquireExclusiveLock();\n    OStorageTransaction transaction = storage.getStorageTransaction();\n    try {\n      startDurableOperation(transaction);\n\n      BucketSearchResult bucketSearchResult = findBucket(key, PartialSearchMode.NONE);\n      if (bucketSearchResult.itemIndex < 0)\n        return null;\n\n      OBonsaiBucketPointer bucketPointer = bucketSearchResult.getLastPathItem();\n\n      OCacheEntry keyBucketCacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n      OCachePointer keyBucketPointer = keyBucketCacheEntry.getCachePointer();\n\n      keyBucketPointer.acquireExclusiveLock();\n      try {\n        OSBTreeBonsaiBucket<K, V> keyBucket = new OSBTreeBonsaiBucket<K, V>(keyBucketPointer.getDataPointer(),\n            bucketPointer.getPageOffset(), keySerializer, valueSerializer, getTrackMode());\n\n        final V removed = keyBucket.getEntry(bucketSearchResult.itemIndex).value;\n\n        keyBucket.remove(bucketSearchResult.itemIndex);\n\n        logPageChanges(keyBucket, fileId, keyBucketCacheEntry.getPageIndex(), false);\n        keyBucketCacheEntry.markDirty();\n\n        endDurableOperation(transaction, false);\n        return removed;\n      } finally {\n        keyBucketPointer.releaseExclusiveLock();\n        diskCache.release(keyBucketCacheEntry);\n        setSize(size() - 1);\n      }\n\n    } catch (IOException e) {\n      rollback(transaction);\n\n      throw new OSBTreeException(\"Error during removing key \" + key + \" from sbtree \" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long size() {\n    acquireSharedLock();\n    try {\n      OCacheEntry rootCacheEntry = diskCache.load(fileId, rootIndex, false);\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n\n      try {\n        OSBTreeBonsaiBucket rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(), keySerializer,\n            valueSerializer, ODurablePage.TrackMode.NONE);\n        return rootBucket.getTreeSize();\n      } finally {\n        diskCache.release(rootCacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during retrieving of size of index \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","id":11575,"modified_method":"public long size() {\n    acquireSharedLock();\n    try {\n      OCacheEntry rootCacheEntry = diskCache.load(fileId, rootBucketPointer.getPageIndex(), false);\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n\n      try {\n        OSBTreeBonsaiBucket rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(),\n            rootBucketPointer.getPageOffset(), keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n        return rootBucket.getTreeSize();\n      } finally {\n        diskCache.release(rootCacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during retrieving of size of index \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void loadEntriesMinor(K key, boolean inclusive, RangeResultListener<K, V> listener) {\n    acquireSharedLock();\n    try {\n      final PartialSearchMode partialSearchMode;\n      if (inclusive)\n        partialSearchMode = PartialSearchMode.HIGHEST_BOUNDARY;\n      else\n        partialSearchMode = PartialSearchMode.LOWEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResult = findBucket(key, partialSearchMode);\n\n      long pageIndex = bucketSearchResult.getLastPathItem();\n      int index;\n      if (bucketSearchResult.itemIndex >= 0) {\n        index = inclusive ? bucketSearchResult.itemIndex : bucketSearchResult.itemIndex - 1;\n      } else {\n        index = -bucketSearchResult.itemIndex - 2;\n      }\n\n      boolean firstBucket = true;\n      resultsLoop: while (true) {\n        long nextPageIndex = -1;\n        OCacheEntry cacheEntry = diskCache.load(fileId, pageIndex, false);\n        final OCachePointer pointer = cacheEntry.getCachePointer();\n        try {\n          OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), keySerializer,\n              valueSerializer, ODurablePage.TrackMode.NONE);\n          if (!firstBucket)\n            index = bucket.size() - 1;\n\n          for (int i = index; i >= 0; i--) {\n            if (!listener.addResult(bucket.getEntry(i)))\n              break resultsLoop;\n          }\n\n          if (bucket.getLeftSibling() >= 0)\n            nextPageIndex = bucket.getLeftSibling();\n          else\n            break;\n\n        } finally {\n          diskCache.release(cacheEntry);\n        }\n\n        pageIndex = nextPageIndex;\n        firstBucket = false;\n      }\n    } catch (IOException ioe) {\n      throw new OSBTreeException(\"Error during fetch of minor values for key \" + key + \" in sbtree \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","id":11576,"modified_method":"public void loadEntriesMinor(K key, boolean inclusive, RangeResultListener<K, V> listener) {\n    acquireSharedLock();\n    try {\n      final PartialSearchMode partialSearchMode;\n      if (inclusive)\n        partialSearchMode = PartialSearchMode.HIGHEST_BOUNDARY;\n      else\n        partialSearchMode = PartialSearchMode.LOWEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResult = findBucket(key, partialSearchMode);\n\n      OBonsaiBucketPointer bucketPointer = bucketSearchResult.getLastPathItem();\n      int index;\n      if (bucketSearchResult.itemIndex >= 0) {\n        index = inclusive ? bucketSearchResult.itemIndex : bucketSearchResult.itemIndex - 1;\n      } else {\n        index = -bucketSearchResult.itemIndex - 2;\n      }\n\n      boolean firstBucket = true;\n      do {\n        OCacheEntry cacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n        final OCachePointer pointer = cacheEntry.getCachePointer();\n        try {\n          OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), bucketPointer.getPageOffset(),\n              keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n          if (!firstBucket)\n            index = bucket.size() - 1;\n\n          for (int i = index; i >= 0; i--) {\n            if (!listener.addResult(bucket.getEntry(i)))\n              return;\n          }\n\n          bucketPointer = bucket.getLeftSibling();\n\n          firstBucket = false;\n\n        } finally {\n          diskCache.release(cacheEntry);\n        }\n      } while (bucketPointer.getPageIndex() >= 0);\n    } catch (IOException ioe) {\n      throw new OSBTreeException(\"Error during fetch of minor values for key \" + key + \" in sbtree \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void loadEntriesMajor(K key, boolean inclusive, RangeResultListener<K, V> listener) {\n    acquireSharedLock();\n    try {\n      final PartialSearchMode partialSearchMode;\n      if (inclusive)\n        partialSearchMode = PartialSearchMode.LOWEST_BOUNDARY;\n      else\n        partialSearchMode = PartialSearchMode.HIGHEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResult = findBucket(key, partialSearchMode);\n      long pageIndex = bucketSearchResult.getLastPathItem();\n      int index;\n      if (bucketSearchResult.itemIndex >= 0) {\n        index = inclusive ? bucketSearchResult.itemIndex : bucketSearchResult.itemIndex + 1;\n      } else {\n        index = -bucketSearchResult.itemIndex - 1;\n      }\n\n      resultsLoop: while (true) {\n        long nextPageIndex = -1;\n        final OCacheEntry cacheEntry = diskCache.load(fileId, pageIndex, false);\n        final OCachePointer pointer = cacheEntry.getCachePointer();\n        try {\n          OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), keySerializer,\n              valueSerializer, ODurablePage.TrackMode.NONE);\n          int bucketSize = bucket.size();\n          for (int i = index; i < bucketSize; i++) {\n            if (!listener.addResult(bucket.getEntry(i)))\n              break resultsLoop;\n          }\n\n          if (bucket.getRightSibling() >= 0)\n            nextPageIndex = bucket.getRightSibling();\n          else\n            break;\n        } finally {\n          diskCache.release(cacheEntry);\n        }\n\n        pageIndex = nextPageIndex;\n        index = 0;\n      }\n\n    } catch (IOException ioe) {\n      throw new OSBTreeException(\"Error during fetch of major values for key \" + key + \" in sbtree \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","id":11577,"modified_method":"public void loadEntriesMajor(K key, boolean inclusive, RangeResultListener<K, V> listener) {\n    acquireSharedLock();\n    try {\n      final PartialSearchMode partialSearchMode;\n      if (inclusive)\n        partialSearchMode = PartialSearchMode.LOWEST_BOUNDARY;\n      else\n        partialSearchMode = PartialSearchMode.HIGHEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResult = findBucket(key, partialSearchMode);\n      OBonsaiBucketPointer bucketPointer = bucketSearchResult.getLastPathItem();\n\n      int index;\n      if (bucketSearchResult.itemIndex >= 0) {\n        index = inclusive ? bucketSearchResult.itemIndex : bucketSearchResult.itemIndex + 1;\n      } else {\n        index = -bucketSearchResult.itemIndex - 1;\n      }\n\n      do {\n        final OCacheEntry cacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n        final OCachePointer pointer = cacheEntry.getCachePointer();\n        try {\n          OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), bucketPointer.getPageOffset(),\n              keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n          int bucketSize = bucket.size();\n          for (int i = index; i < bucketSize; i++) {\n            if (!listener.addResult(bucket.getEntry(i)))\n              return;\n          }\n\n          bucketPointer = bucket.getRightSibling();\n          index = 0;\n        } finally {\n          diskCache.release(cacheEntry);\n        }\n\n      } while (bucketPointer.getPageIndex() >= 0);\n\n    } catch (IOException ioe) {\n      throw new OSBTreeException(\"Error during fetch of major values for key \" + key + \" in sbtree \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void clear() {\n    acquireExclusiveLock();\n    OStorageTransaction transaction = storage.getStorageTransaction();\n    try {\n      startDurableOperation(transaction);\n\n      diskCache.truncateFile(fileId);\n\n      OCacheEntry cacheEntry = diskCache.load(fileId, rootIndex, false);\n      OCachePointer rootPointer = cacheEntry.getCachePointer();\n      rootPointer.acquireExclusiveLock();\n      try {\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(), true, keySerializer,\n            valueSerializer, getTrackMode());\n\n        rootBucket.setKeySerializerId(keySerializer.getId());\n        rootBucket.setValueSerializerId(valueSerializer.getId());\n        rootBucket.setTreeSize(0);\n\n        logPageChanges(rootBucket, fileId, rootIndex, true);\n        cacheEntry.markDirty();\n      } finally {\n        rootPointer.releaseExclusiveLock();\n        diskCache.release(cacheEntry);\n      }\n\n      endDurableOperation(transaction, false);\n    } catch (IOException e) {\n      rollback(transaction);\n\n      throw new OSBTreeException(\"Error during clear of sbtree with name \" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","id":11578,"modified_method":"public void clear() {\n    acquireExclusiveLock();\n    OStorageTransaction transaction = storage.getStorageTransaction();\n    try {\n      startDurableOperation(transaction);\n\n      diskCache.truncateFile(fileId);\n\n      OCacheEntry cacheEntry = diskCache.load(fileId, rootBucketPointer.getPageIndex(), false);\n      OCachePointer rootPointer = cacheEntry.getCachePointer();\n      rootPointer.acquireExclusiveLock();\n      try {\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(),\n            rootBucketPointer.getPageOffset(), true, keySerializer, valueSerializer, getTrackMode());\n\n        rootBucket.setKeySerializerId(keySerializer.getId());\n        rootBucket.setValueSerializerId(valueSerializer.getId());\n        rootBucket.setTreeSize(0);\n\n        logPageChanges(rootBucket, fileId, rootBucketPointer.getPageIndex(), true);\n        cacheEntry.markDirty();\n      } finally {\n        rootPointer.releaseExclusiveLock();\n        diskCache.release(cacheEntry);\n      }\n\n      endDurableOperation(transaction, false);\n    } catch (IOException e) {\n      rollback(transaction);\n\n      throw new OSBTreeException(\"Error during clear of sbtree with name \" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private PagePathItemUnit(long pageIndex, int itemIndex) {\n      this.pageIndex = pageIndex;\n      this.itemIndex = itemIndex;\n    }","id":11579,"modified_method":"private PagePathItemUnit(long pageIndex, int itemIndex) {\n      this.bucketPointer = new OBonsaiBucketPointer(pageIndex);\n      this.itemIndex = itemIndex;\n    }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public K firstKey() {\n    acquireSharedLock();\n    try {\n      LinkedList<PagePathItemUnit> path = new LinkedList<PagePathItemUnit>();\n\n      long bucketIndex = rootIndex;\n\n      OCacheEntry cacheEntry = diskCache.load(fileId, bucketIndex, false);\n      OCachePointer cachePointer = cacheEntry.getCachePointer();\n      int itemIndex = 0;\n\n      OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(), keySerializer,\n          valueSerializer, ODurablePage.TrackMode.NONE);\n      try {\n        while (true) {\n          if (!bucket.isLeaf()) {\n            if (bucket.isEmpty() || itemIndex >= bucket.size()) {\n              if (!path.isEmpty()) {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketIndex = pagePathItemUnit.pageIndex;\n                itemIndex = pagePathItemUnit.itemIndex + 1;\n              } else\n                return null;\n            } else {\n              OSBTreeBonsaiBucket.SBTreeEntry<K, V> entry = bucket.getEntry(itemIndex);\n\n              path.add(new PagePathItemUnit(bucketIndex, itemIndex));\n\n              bucketIndex = entry.leftChild;\n              itemIndex = 0;\n            }\n          } else {\n            if (bucket.isEmpty()) {\n              if (!path.isEmpty()) {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketIndex = pagePathItemUnit.pageIndex;\n                itemIndex = pagePathItemUnit.itemIndex + 1;\n              } else\n                return null;\n            } else {\n              return bucket.getKey(0);\n            }\n          }\n\n          diskCache.release(cacheEntry);\n          cacheEntry = diskCache.load(fileId, bucketIndex, false);\n          cachePointer = cacheEntry.getCachePointer();\n\n          bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(), keySerializer, valueSerializer,\n              ODurablePage.TrackMode.NONE);\n        }\n      } finally {\n        diskCache.release(cacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during finding first key in sbtree [\" + name + \"]\");\n    } finally {\n      releaseSharedLock();\n    }\n  }","id":11580,"modified_method":"public K firstKey() {\n    acquireSharedLock();\n    try {\n      LinkedList<PagePathItemUnit> path = new LinkedList<PagePathItemUnit>();\n\n      OBonsaiBucketPointer bucketPointer = rootBucketPointer;\n\n      OCacheEntry cacheEntry = diskCache.load(fileId, rootBucketPointer.getPageIndex(), false);\n      OCachePointer cachePointer = cacheEntry.getCachePointer();\n      int itemIndex = 0;\n\n      OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(),\n          bucketPointer.getPageOffset(), keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n      try {\n        while (true) {\n          if (bucket.isLeaf()) {\n            if (bucket.isEmpty()) {\n              if (path.isEmpty()) {\n                return null;\n              } else {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketPointer = pagePathItemUnit.bucketPointer;\n                itemIndex = pagePathItemUnit.itemIndex + 1;\n              }\n            } else {\n              return bucket.getKey(0);\n            }\n          } else {\n            if (bucket.isEmpty() || itemIndex >= bucket.size()) {\n              if (path.isEmpty()) {\n                return null;\n              } else {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketPointer = pagePathItemUnit.bucketPointer;\n                itemIndex = pagePathItemUnit.itemIndex + 1;\n              }\n            } else {\n              OSBTreeBonsaiBucket.SBTreeEntry<K, V> entry = bucket.getEntry(itemIndex);\n\n              path.add(new PagePathItemUnit(bucketPointer, itemIndex));\n\n              bucketPointer = entry.leftChild;\n              itemIndex = 0;\n            }\n          }\n\n          diskCache.release(cacheEntry);\n          cacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n          cachePointer = cacheEntry.getCachePointer();\n\n          bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(), bucketPointer.getPageOffset(), keySerializer,\n              valueSerializer, ODurablePage.TrackMode.NONE);\n        }\n      } finally {\n        diskCache.release(cacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during finding first key in sbtree [\" + name + \"]\");\n    } finally {\n      releaseSharedLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public K lastKey() {\n    acquireSharedLock();\n    try {\n      LinkedList<PagePathItemUnit> path = new LinkedList<PagePathItemUnit>();\n\n      long bucketIndex = rootIndex;\n\n      OCacheEntry cacheEntry = diskCache.load(fileId, bucketIndex, false);\n      OCachePointer cachePointer = cacheEntry.getCachePointer();\n      OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(), keySerializer,\n          valueSerializer, ODurablePage.TrackMode.NONE);\n\n      int itemIndex = bucket.size() - 1;\n      try {\n        while (true) {\n          if (!bucket.isLeaf()) {\n            if (itemIndex < 0) {\n              if (!path.isEmpty()) {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketIndex = pagePathItemUnit.pageIndex;\n                itemIndex = pagePathItemUnit.itemIndex - 1;\n              } else\n                return null;\n            } else {\n              OSBTreeBonsaiBucket.SBTreeEntry<K, V> entry = bucket.getEntry(itemIndex);\n\n              path.add(new PagePathItemUnit(bucketIndex, itemIndex));\n\n              bucketIndex = entry.rightChild;\n              itemIndex = OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES + 1;\n            }\n          } else {\n            if (bucket.isEmpty()) {\n              if (!path.isEmpty()) {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketIndex = pagePathItemUnit.pageIndex;\n                itemIndex = pagePathItemUnit.itemIndex - 1;\n              } else\n                return null;\n            } else {\n              return bucket.getKey(bucket.size() - 1);\n            }\n          }\n\n          diskCache.release(cacheEntry);\n          cacheEntry = diskCache.load(fileId, bucketIndex, false);\n          cachePointer = cacheEntry.getCachePointer();\n\n          bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(), keySerializer, valueSerializer,\n              ODurablePage.TrackMode.NONE);\n          if (itemIndex == OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES + 1)\n            itemIndex = bucket.size() - 1;\n        }\n      } finally {\n        diskCache.release(cacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during finding first key in sbtree [\" + name + \"]\");\n    } finally {\n      releaseSharedLock();\n    }\n  }","id":11581,"modified_method":"public K lastKey() {\n    acquireSharedLock();\n    try {\n      LinkedList<PagePathItemUnit> path = new LinkedList<PagePathItemUnit>();\n\n      OBonsaiBucketPointer bucketPointer = rootBucketPointer;\n\n      OCacheEntry cacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n      OCachePointer cachePointer = cacheEntry.getCachePointer();\n      OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(),\n          bucketPointer.getPageOffset(), keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n\n      int itemIndex = bucket.size() - 1;\n      try {\n        while (true) {\n          if (bucket.isLeaf()) {\n            if (bucket.isEmpty()) {\n              if (path.isEmpty()) {\n                return null;\n              } else {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketPointer = pagePathItemUnit.bucketPointer;\n                itemIndex = pagePathItemUnit.itemIndex - 1;\n              }\n            } else {\n              return bucket.getKey(bucket.size() - 1);\n            }\n          } else {\n            if (itemIndex < 0) {\n              if (!path.isEmpty()) {\n                PagePathItemUnit pagePathItemUnit = path.removeLast();\n\n                bucketPointer = pagePathItemUnit.bucketPointer;\n                itemIndex = pagePathItemUnit.itemIndex - 1;\n              } else\n                return null;\n            } else {\n              OSBTreeBonsaiBucket.SBTreeEntry<K, V> entry = bucket.getEntry(itemIndex);\n\n              path.add(new PagePathItemUnit(bucketPointer, itemIndex));\n\n              bucketPointer = entry.rightChild;\n              itemIndex = OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES + 1;\n            }\n          }\n\n          diskCache.release(cacheEntry);\n          cacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n          cachePointer = cacheEntry.getCachePointer();\n\n          bucket = new OSBTreeBonsaiBucket<K, V>(cachePointer.getDataPointer(), bucketPointer.getPageOffset(), keySerializer,\n              valueSerializer, ODurablePage.TrackMode.NONE);\n          if (itemIndex == OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES + 1)\n            itemIndex = bucket.size() - 1;\n        }\n      } finally {\n        diskCache.release(cacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Error during finding first key in sbtree [\" + name + \"]\");\n    } finally {\n      releaseSharedLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void loadEntriesBetween(K keyFrom, boolean fromInclusive, K keyTo, boolean toInclusive, RangeResultListener<K, V> listener) {\n    acquireSharedLock();\n    try {\n      PartialSearchMode partialSearchModeFrom;\n      if (fromInclusive)\n        partialSearchModeFrom = PartialSearchMode.LOWEST_BOUNDARY;\n      else\n        partialSearchModeFrom = PartialSearchMode.HIGHEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResultFrom = findBucket(keyFrom, partialSearchModeFrom);\n\n      long pageIndexFrom = bucketSearchResultFrom.getLastPathItem();\n\n      int indexFrom;\n      if (bucketSearchResultFrom.itemIndex >= 0) {\n        indexFrom = fromInclusive ? bucketSearchResultFrom.itemIndex : bucketSearchResultFrom.itemIndex + 1;\n      } else {\n        indexFrom = -bucketSearchResultFrom.itemIndex - 1;\n      }\n\n      PartialSearchMode partialSearchModeTo;\n      if (toInclusive)\n        partialSearchModeTo = PartialSearchMode.HIGHEST_BOUNDARY;\n      else\n        partialSearchModeTo = PartialSearchMode.LOWEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResultTo = findBucket(keyTo, partialSearchModeTo);\n      long pageIndexTo = bucketSearchResultTo.getLastPathItem();\n\n      int indexTo;\n      if (bucketSearchResultTo.itemIndex >= 0) {\n        indexTo = toInclusive ? bucketSearchResultTo.itemIndex : bucketSearchResultTo.itemIndex - 1;\n      } else {\n        indexTo = -bucketSearchResultTo.itemIndex - 2;\n      }\n\n      int startIndex = indexFrom;\n      int endIndex;\n      long pageIndex = pageIndexFrom;\n\n      resultsLoop: while (true) {\n        long nextPageIndex = -1;\n\n        final OCacheEntry cacheEntry = diskCache.load(fileId, pageIndex, false);\n        final OCachePointer pointer = cacheEntry.getCachePointer();\n        try {\n          OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), keySerializer,\n              valueSerializer, ODurablePage.TrackMode.NONE);\n          if (pageIndex != pageIndexTo)\n            endIndex = bucket.size() - 1;\n          else\n            endIndex = indexTo;\n\n          for (int i = startIndex; i <= endIndex; i++) {\n            if (!listener.addResult(bucket.getEntry(i)))\n              break resultsLoop;\n          }\n\n          if (pageIndex == pageIndexTo)\n            break;\n\n          if (bucket.getRightSibling() >= 0)\n            nextPageIndex = bucket.getRightSibling();\n          else\n            break;\n\n        } finally {\n          diskCache.release(cacheEntry);\n        }\n\n        pageIndex = nextPageIndex;\n        startIndex = 0;\n      }\n\n    } catch (IOException ioe) {\n      throw new OSBTreeException(\"Error during fetch of values between key \" + keyFrom + \" and key \" + keyTo + \" in sbtree \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","id":11582,"modified_method":"public void loadEntriesBetween(K keyFrom, boolean fromInclusive, K keyTo, boolean toInclusive, RangeResultListener<K, V> listener) {\n    acquireSharedLock();\n    try {\n      PartialSearchMode partialSearchModeFrom;\n      if (fromInclusive)\n        partialSearchModeFrom = PartialSearchMode.LOWEST_BOUNDARY;\n      else\n        partialSearchModeFrom = PartialSearchMode.HIGHEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResultFrom = findBucket(keyFrom, partialSearchModeFrom);\n\n      OBonsaiBucketPointer bucketPointerFrom = bucketSearchResultFrom.getLastPathItem();\n\n      int indexFrom;\n      if (bucketSearchResultFrom.itemIndex >= 0) {\n        indexFrom = fromInclusive ? bucketSearchResultFrom.itemIndex : bucketSearchResultFrom.itemIndex + 1;\n      } else {\n        indexFrom = -bucketSearchResultFrom.itemIndex - 1;\n      }\n\n      PartialSearchMode partialSearchModeTo;\n      if (toInclusive)\n        partialSearchModeTo = PartialSearchMode.HIGHEST_BOUNDARY;\n      else\n        partialSearchModeTo = PartialSearchMode.LOWEST_BOUNDARY;\n\n      BucketSearchResult bucketSearchResultTo = findBucket(keyTo, partialSearchModeTo);\n      OBonsaiBucketPointer bucketPointerTo = bucketSearchResultTo.getLastPathItem();\n\n      int indexTo;\n      if (bucketSearchResultTo.itemIndex >= 0) {\n        indexTo = toInclusive ? bucketSearchResultTo.itemIndex : bucketSearchResultTo.itemIndex - 1;\n      } else {\n        indexTo = -bucketSearchResultTo.itemIndex - 2;\n      }\n\n      int startIndex = indexFrom;\n      int endIndex;\n      OBonsaiBucketPointer bucketPointer = bucketPointerFrom;\n\n      resultsLoop: while (true) {\n\n        final OCacheEntry cacheEntry = diskCache.load(fileId, bucketPointer.getPageIndex(), false);\n        final OCachePointer pointer = cacheEntry.getCachePointer();\n        try {\n          OSBTreeBonsaiBucket<K, V> bucket = new OSBTreeBonsaiBucket<K, V>(pointer.getDataPointer(), bucketPointer.getPageOffset(),\n              keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n          if (!bucketPointer.equals(bucketPointerTo))\n            endIndex = bucket.size() - 1;\n          else\n            endIndex = indexTo;\n\n          for (int i = startIndex; i <= endIndex; i++) {\n            if (!listener.addResult(bucket.getEntry(i)))\n              break resultsLoop;\n          }\n\n          if (bucketPointer.equals(bucketPointerTo))\n            break;\n\n          bucketPointer = bucket.getRightSibling();\n          if (bucketPointer.getPageIndex() < 0)\n            break;\n\n        } finally {\n          diskCache.release(cacheEntry);\n        }\n\n        startIndex = 0;\n      }\n\n    } catch (IOException ioe) {\n      throw new OSBTreeException(\"Error during fetch of values between key \" + keyFrom + \" and key \" + keyTo + \" in sbtree \" + name);\n    } finally {\n      releaseSharedLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void create(String name, long rootIndex, OBinarySerializer<K> keySerializer, OBinarySerializer<V> valueSerializer,\n      OStorageLocalAbstract storageLocal) {\n    acquireExclusiveLock();\n    try {\n      this.storage = storageLocal;\n\n      this.diskCache = storage.getDiskCache();\n\n      this.name = name;\n      this.keySerializer = keySerializer;\n      this.valueSerializer = valueSerializer;\n\n      fileId = diskCache.openFile(name + dataFileExtension);\n\n      initDurableComponent(storageLocal);\n\n      OCacheEntry rootCacheEntry;\n      if (rootIndex < 0)\n        rootCacheEntry = diskCache.allocateNewPage(fileId);\n      else\n        rootCacheEntry = diskCache.load(fileId, rootIndex, false);\n\n      this.rootIndex = rootCacheEntry.getPageIndex();\n\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n\n      rootPointer.acquireExclusiveLock();\n      try {\n        super.startDurableOperation(null);\n\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(), true, keySerializer,\n            valueSerializer, getTrackMode());\n        rootBucket.setKeySerializerId(keySerializer.getId());\n        rootBucket.setValueSerializerId(valueSerializer.getId());\n        rootBucket.setTreeSize(0);\n\n        super.logPageChanges(rootBucket, fileId, this.rootIndex, true);\n        rootCacheEntry.markDirty();\n      } finally {\n        rootPointer.releaseExclusiveLock();\n        diskCache.release(rootCacheEntry);\n      }\n\n      super.endDurableOperation(null, false);\n    } catch (IOException e) {\n      try {\n        super.endDurableOperation(null, true);\n      } catch (IOException e1) {\n        OLogManager.instance().error(this, \"Error during sbtree data rollback\", e1);\n      }\n      throw new OSBTreeException(\"Error creation of sbtree with name\" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","id":11583,"modified_method":"public void create(String name, long rootIndex, OBinarySerializer<K> keySerializer, OBinarySerializer<V> valueSerializer,\n      OStorageLocalAbstract storageLocal) {\n    acquireExclusiveLock();\n    try {\n      this.storage = storageLocal;\n\n      this.diskCache = storage.getDiskCache();\n\n      this.name = name;\n      this.keySerializer = keySerializer;\n      this.valueSerializer = valueSerializer;\n\n      fileId = diskCache.openFile(name + dataFileExtension);\n\n      initDurableComponent(storageLocal);\n\n      OCacheEntry rootCacheEntry;\n      if (rootIndex < 0)\n        rootCacheEntry = diskCache.allocateNewPage(fileId);\n      else\n        rootCacheEntry = diskCache.load(fileId, rootIndex, false);\n\n      rootBucketPointer = new OBonsaiBucketPointer(rootCacheEntry.getPageIndex());\n\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n\n      rootPointer.acquireExclusiveLock();\n      try {\n        super.startDurableOperation(null);\n\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(),\n            rootBucketPointer.getPageOffset(), true, keySerializer, valueSerializer, getTrackMode());\n        rootBucket.setKeySerializerId(keySerializer.getId());\n        rootBucket.setValueSerializerId(valueSerializer.getId());\n        rootBucket.setTreeSize(0);\n\n        super.logPageChanges(rootBucket, fileId, rootBucketPointer.getPageIndex(), true);\n        rootCacheEntry.markDirty();\n      } finally {\n        rootPointer.releaseExclusiveLock();\n        diskCache.release(rootCacheEntry);\n      }\n\n      super.endDurableOperation(null, false);\n    } catch (IOException e) {\n      try {\n        super.endDurableOperation(null, true);\n      } catch (IOException e1) {\n        OLogManager.instance().error(this, \"Error during sbtree data rollback\", e1);\n      }\n      throw new OSBTreeException(\"Error creation of sbtree with name\" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private BucketSearchResult(int itemIndex, ArrayList<Long> path) {\n      this.itemIndex = itemIndex;\n      this.path = path;\n    }","id":11584,"modified_method":"private BucketSearchResult(int itemIndex, ArrayList<OBonsaiBucketPointer> path) {\n      this.itemIndex = itemIndex;\n      this.path = path;\n    }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void load(String name, long rootIndex, OStorageLocalAbstract storageLocal) {\n    acquireExclusiveLock();\n    try {\n      this.storage = storageLocal;\n      this.rootIndex = rootIndex;\n\n      diskCache = storage.getDiskCache();\n\n      this.name = name;\n\n      fileId = diskCache.openFile(name + dataFileExtension);\n\n      OCacheEntry rootCacheEntry = diskCache.load(fileId, this.rootIndex, false);\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n      try {\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(), keySerializer,\n            valueSerializer, ODurablePage.TrackMode.NONE);\n        keySerializer = (OBinarySerializer<K>) OBinarySerializerFactory.INSTANCE.getObjectSerializer(rootBucket\n            .getKeySerializerId());\n        valueSerializer = (OBinarySerializer<V>) OBinarySerializerFactory.INSTANCE.getObjectSerializer(rootBucket\n            .getValueSerializerId());\n      } finally {\n        diskCache.release(rootCacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Exception during loading of sbtree \" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","id":11585,"modified_method":"public void load(String name, OBonsaiBucketPointer rootBucketPointer, OStorageLocalAbstract storageLocal) {\n    acquireExclusiveLock();\n    try {\n      this.storage = storageLocal;\n      this.rootBucketPointer = rootBucketPointer;\n\n      diskCache = storage.getDiskCache();\n\n      this.name = name;\n\n      fileId = diskCache.openFile(name + dataFileExtension);\n\n      OCacheEntry rootCacheEntry = diskCache.load(fileId, this.rootBucketPointer.getPageIndex(), false);\n      OCachePointer rootPointer = rootCacheEntry.getCachePointer();\n      try {\n        OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<K, V>(rootPointer.getDataPointer(),\n            this.rootBucketPointer.getPageOffset(), keySerializer, valueSerializer, ODurablePage.TrackMode.NONE);\n        keySerializer = (OBinarySerializer<K>) OBinarySerializerFactory.INSTANCE.getObjectSerializer(rootBucket\n            .getKeySerializerId());\n        valueSerializer = (OBinarySerializer<V>) OBinarySerializerFactory.INSTANCE.getObjectSerializer(rootBucket\n            .getValueSerializerId());\n      } finally {\n        diskCache.release(rootCacheEntry);\n      }\n    } catch (IOException e) {\n      throw new OSBTreeException(\"Exception during loading of sbtree \" + name, e);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long getRightSibling() {\n    return getLongValue(offset + RIGHT_SIBLING_OFFSET);\n  }","id":11586,"modified_method":"public OBonsaiBucketPointer getRightSibling() {\n    // TODO\n    return new OBonsaiBucketPointer(getLongValue(offset + RIGHT_SIBLING_OFFSET));\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean updateValue(int index, V value) throws IOException {\n    if (valueSerializer.isFixedLength()) {\n      int entryPosition = getIntValue(offset + index * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n      entryPosition += keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      byte[] serializedValue = new byte[valueSerializer.getFixedLength()];\n      valueSerializer.serializeNative(value, serializedValue, 0);\n\n      setBinaryValue(offset + entryPosition, serializedValue);\n      return true;\n    }\n\n    final int entryPosition = getIntValue(offset + index * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    int entreeSize = keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n    entreeSize += valueSerializer.getObjectSize(value);\n\n    checkEntreeSize(entreeSize);\n\n    final K key = getKey(index);\n    remove(index);\n    return addEntry(index, new SBTreeEntry<K, V>(-1, -1, key, value), false);\n  }","id":11587,"modified_method":"public boolean updateValue(int index, V value) throws IOException {\n    if (valueSerializer.isFixedLength()) {\n      int entryPosition = getIntValue(offset + index * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n      entryPosition += keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      byte[] serializedValue = new byte[valueSerializer.getFixedLength()];\n      valueSerializer.serializeNative(value, serializedValue, 0);\n\n      setBinaryValue(offset + entryPosition, serializedValue);\n      return true;\n    }\n\n    final int entryPosition = getIntValue(offset + index * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    int entreeSize = keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n    entreeSize += valueSerializer.getObjectSize(value);\n\n    checkEntreeSize(entreeSize);\n\n    final K key = getKey(index);\n    remove(index);\n    return addEntry(index, new SBTreeEntry<K, V>(OBonsaiBucketPointer.NULL, OBonsaiBucketPointer.NULL, key, value), false);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSBTreeBonsaiBucket(long cachePointer, boolean isLeaf, OBinarySerializer<K> keySerializer,\n      OBinarySerializer<V> valueSerializer, TrackMode trackMode) throws IOException {\n    super(cachePointer, trackMode);\n\n    this.isLeaf = isLeaf;\n    this.keySerializer = keySerializer;\n    this.valueSerializer = valueSerializer;\n\n    setIntValue(offset + FREE_POINTER_OFFSET, MAX_BUCKET_SIZE_BYTES);\n    setIntValue(offset + SIZE_OFFSET, 0);\n\n    setByteValue(offset + IS_LEAF_OFFSET, (byte) (isLeaf ? 1 : 0));\n    setLongValue(offset + LEFT_SIBLING_OFFSET, -1);\n    setLongValue(offset + RIGHT_SIBLING_OFFSET, -1);\n\n    setLongValue(offset + TREE_SIZE_OFFSET, 0);\n\n    setByteValue(offset + KEY_SERIALIZER_OFFSET, (byte) -1);\n    setByteValue(offset + VALUE_SERIALIZER_OFFSET, (byte) -1);\n  }","id":11588,"modified_method":"public OSBTreeBonsaiBucket(long cachePointer, int pageOffset, boolean isLeaf, OBinarySerializer<K> keySerializer,\n      OBinarySerializer<V> valueSerializer, TrackMode trackMode) throws IOException {\n    super(cachePointer, trackMode);\n\n    this.offset = pageOffset;\n    this.isLeaf = isLeaf;\n    this.keySerializer = keySerializer;\n    this.valueSerializer = valueSerializer;\n\n    setIntValue(offset + FREE_POINTER_OFFSET, MAX_BUCKET_SIZE_BYTES);\n    setIntValue(offset + SIZE_OFFSET, 0);\n\n    setByteValue(offset + IS_LEAF_OFFSET, (byte) (isLeaf ? 1 : 0));\n    setLongValue(offset + LEFT_SIBLING_OFFSET, -1);\n    setLongValue(offset + RIGHT_SIBLING_OFFSET, -1);\n\n    setLongValue(offset + TREE_SIZE_OFFSET, 0);\n\n    setByteValue(offset + KEY_SERIALIZER_OFFSET, (byte) -1);\n    setByteValue(offset + VALUE_SERIALIZER_OFFSET, (byte) -1);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSBTreeBonsaiBucket(long cachePointer, OBinarySerializer<K> keySerializer, OBinarySerializer<V> valueSerializer,\n      TrackMode trackMode) {\n    super(cachePointer, trackMode);\n\n    this.isLeaf = getByteValue(offset + IS_LEAF_OFFSET) > 0;\n    this.keySerializer = keySerializer;\n    this.valueSerializer = valueSerializer;\n  }","id":11589,"modified_method":"public OSBTreeBonsaiBucket(long cachePointer, int pageOffset, OBinarySerializer<K> keySerializer,\n      OBinarySerializer<V> valueSerializer, TrackMode trackMode) {\n    super(cachePointer, trackMode);\n\n    this.offset = pageOffset;\n    this.isLeaf = getByteValue(offset + IS_LEAF_OFFSET) > 0;\n    this.keySerializer = keySerializer;\n    this.valueSerializer = valueSerializer;\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long getLeftSibling() {\n    return getLongValue(offset + LEFT_SIBLING_OFFSET);\n  }","id":11590,"modified_method":"public OBonsaiBucketPointer getLeftSibling() {\n    // TODO\n    return new OBonsaiBucketPointer(getLongValue(offset + LEFT_SIBLING_OFFSET));\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o)\n        return true;\n      if (o == null || getClass() != o.getClass())\n        return false;\n\n      SBTreeEntry that = (SBTreeEntry) o;\n\n      if (leftChild != that.leftChild)\n        return false;\n      if (rightChild != that.rightChild)\n        return false;\n      if (!key.equals(that.key))\n        return false;\n      if (value != null ? !value.equals(that.value) : that.value != null)\n        return false;\n\n      return true;\n    }","id":11591,"modified_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o)\n        return true;\n      if (o == null || getClass() != o.getClass())\n        return false;\n\n      SBTreeEntry that = (SBTreeEntry) o;\n\n      if (!leftChild.equals(that.leftChild))\n        return false;\n      if (!rightChild.equals(that.rightChild))\n        return false;\n      if (!key.equals(that.key))\n        return false;\n      if (value != null ? !value.equals(that.value) : that.value != null)\n        return false;\n\n      return true;\n    }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void setRightSibling(long pageIndex) throws IOException {\n    setLongValue(offset + RIGHT_SIBLING_OFFSET, pageIndex);\n  }","id":11592,"modified_method":"public void setRightSibling(OBonsaiBucketPointer pointer) throws IOException {\n    // TODO\n    setLongValue(offset + RIGHT_SIBLING_OFFSET, pointer.getPageIndex());\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public SBTreeEntry<K, V> getEntry(int entryIndex) {\n    int entryPosition = getIntValue(offset + entryIndex * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    if (isLeaf) {\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n      entryPosition += keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      V value = valueSerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(-1, -1, key, value);\n    } else {\n      long leftChild = getLongValue(offset + entryPosition);\n      entryPosition += OLongSerializer.LONG_SIZE;\n\n      long rightChild = getLongValue(offset + entryPosition);\n      entryPosition += OLongSerializer.LONG_SIZE;\n\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(leftChild, rightChild, key, null);\n    }\n  }","id":11593,"modified_method":"public SBTreeEntry<K, V> getEntry(int entryIndex) {\n    int entryPosition = getIntValue(offset + entryIndex * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);\n\n    if (isLeaf) {\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n      entryPosition += keySerializer.getObjectSizeInDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      V value = valueSerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(OBonsaiBucketPointer.NULL, OBonsaiBucketPointer.NULL, key, value);\n    } else {\n      // TODO\n      OBonsaiBucketPointer leftChild = new OBonsaiBucketPointer(getLongValue(offset + entryPosition));\n      entryPosition += OLongSerializer.LONG_SIZE;\n\n      // TODO\n      OBonsaiBucketPointer rightChild = new OBonsaiBucketPointer(getLongValue(offset + entryPosition));\n      entryPosition += OLongSerializer.LONG_SIZE;\n\n      K key = keySerializer.deserializeFromDirectMemory(directMemory, pagePointer + offset + entryPosition);\n\n      return new SBTreeEntry<K, V>(leftChild, rightChild, key, null);\n    }\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public int hashCode() {\n      int result = (int) (leftChild ^ (leftChild >>> 32));\n      result = 31 * result + (int) (rightChild ^ (rightChild >>> 32));\n      result = 31 * result + key.hashCode();\n      result = 31 * result + (value != null ? value.hashCode() : 0);\n      return result;\n    }","id":11594,"modified_method":"@Override\n    public int hashCode() {\n      int result = leftChild.hashCode();\n      result = 31 * result + rightChild.hashCode();\n      result = 31 * result + key.hashCode();\n      result = 31 * result + (value != null ? value.hashCode() : 0);\n      return result;\n    }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean addEntry(int index, SBTreeEntry<K, V> treeEntry, boolean updateNeighbors) throws IOException {\n    final int keySize = keySerializer.getObjectSize(treeEntry.key);\n    int valueSize = 0;\n    int entrySize = keySize;\n\n    if (isLeaf) {\n      if (valueSerializer.isFixedLength())\n        valueSize = valueSerializer.getFixedLength();\n      else\n        valueSize = valueSerializer.getObjectSize(treeEntry.value);\n\n      entrySize += valueSize;\n\n      checkEntreeSize(entrySize);\n    } else\n      entrySize += 2 * OLongSerializer.LONG_SIZE;\n\n    int size = size();\n    int freePointer = getIntValue(offset + FREE_POINTER_OFFSET);\n    if (freePointer - entrySize < (size + 1) * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET)\n      return false;\n\n    if (index <= size - 1) {\n      copyData(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, offset + POSITIONS_ARRAY_OFFSET + (index + 1)\n          * OIntegerSerializer.INT_SIZE, (size - index) * OIntegerSerializer.INT_SIZE);\n    }\n\n    freePointer -= entrySize;\n\n    setIntValue(offset + FREE_POINTER_OFFSET, freePointer);\n    setIntValue(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, freePointer);\n    setIntValue(offset + SIZE_OFFSET, size + 1);\n\n    if (isLeaf) {\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n\n      setBinaryValue(offset + freePointer, serializedKey);\n      freePointer += keySize;\n\n      byte[] serializedValue = new byte[valueSize];\n      valueSerializer.serializeNative(treeEntry.value, serializedValue, 0);\n      setBinaryValue(offset + freePointer, serializedValue);\n\n    } else {\n      setLongValue(offset + freePointer, treeEntry.leftChild);\n      freePointer += OLongSerializer.LONG_SIZE;\n\n      setLongValue(offset + freePointer, treeEntry.rightChild);\n      freePointer += OLongSerializer.LONG_SIZE;\n\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n      setBinaryValue(offset + freePointer, serializedKey);\n\n      size++;\n\n      if (updateNeighbors && size > 1) {\n        if (index < size - 1) {\n          final int nextEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index + 1) * OIntegerSerializer.INT_SIZE);\n          setLongValue(offset + nextEntryPosition, treeEntry.rightChild);\n        }\n\n        if (index > 0) {\n          final int prevEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index - 1) * OIntegerSerializer.INT_SIZE);\n          setLongValue(offset + prevEntryPosition + OLongSerializer.LONG_SIZE, treeEntry.leftChild);\n        }\n      }\n    }\n\n    return true;\n  }","id":11595,"modified_method":"public boolean addEntry(int index, SBTreeEntry<K, V> treeEntry, boolean updateNeighbors) throws IOException {\n    final int keySize = keySerializer.getObjectSize(treeEntry.key);\n    int valueSize = 0;\n    int entrySize = keySize;\n\n    if (isLeaf) {\n      if (valueSerializer.isFixedLength())\n        valueSize = valueSerializer.getFixedLength();\n      else\n        valueSize = valueSerializer.getObjectSize(treeEntry.value);\n\n      entrySize += valueSize;\n\n      checkEntreeSize(entrySize);\n    } else\n      entrySize += 2 * OLongSerializer.LONG_SIZE;\n\n    int size = size();\n    int freePointer = getIntValue(offset + FREE_POINTER_OFFSET);\n    if (freePointer - entrySize < (size + 1) * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET)\n      return false;\n\n    if (index <= size - 1) {\n      copyData(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, offset + POSITIONS_ARRAY_OFFSET + (index + 1)\n          * OIntegerSerializer.INT_SIZE, (size - index) * OIntegerSerializer.INT_SIZE);\n    }\n\n    freePointer -= entrySize;\n\n    setIntValue(offset + FREE_POINTER_OFFSET, freePointer);\n    setIntValue(offset + POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE, freePointer);\n    setIntValue(offset + SIZE_OFFSET, size + 1);\n\n    if (isLeaf) {\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n\n      setBinaryValue(offset + freePointer, serializedKey);\n      freePointer += keySize;\n\n      byte[] serializedValue = new byte[valueSize];\n      valueSerializer.serializeNative(treeEntry.value, serializedValue, 0);\n      setBinaryValue(offset + freePointer, serializedValue);\n\n    } else {\n      // TODO\n      setLongValue(offset + freePointer, treeEntry.leftChild.getPageIndex());\n      freePointer += OLongSerializer.LONG_SIZE;\n\n      // TODO\n      setLongValue(offset + freePointer, treeEntry.rightChild.getPageIndex());\n      freePointer += OLongSerializer.LONG_SIZE;\n\n      byte[] serializedKey = new byte[keySize];\n      keySerializer.serializeNative(treeEntry.key, serializedKey, 0);\n      setBinaryValue(offset + freePointer, serializedKey);\n\n      size++;\n\n      if (updateNeighbors && size > 1) {\n        if (index < size - 1) {\n          final int nextEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index + 1) * OIntegerSerializer.INT_SIZE);\n          // TODO\n          setLongValue(offset + nextEntryPosition, treeEntry.rightChild.getPageIndex());\n        }\n\n        if (index > 0) {\n          final int prevEntryPosition = getIntValue(offset + POSITIONS_ARRAY_OFFSET + (index - 1) * OIntegerSerializer.INT_SIZE);\n          // TODO\n          setLongValue(offset + prevEntryPosition + OLongSerializer.LONG_SIZE, treeEntry.leftChild.getPageIndex());\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSetRightSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    treeBucket.setRightSibling(123);\n    Assert.assertEquals(treeBucket.getRightSibling(), 123);\n\n    directMemory.free(pointer);\n  }","id":11596,"modified_method":"public void testSetRightSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    final OBonsaiBucketPointer p = new OBonsaiBucketPointer(123);\n    treeBucket.setRightSibling(p);\n    Assert.assertEquals(treeBucket.getRightSibling(), p);\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSetLeftSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    treeBucket.setLeftSibling(123);\n    Assert.assertEquals(treeBucket.getLeftSibling(), 123);\n\n    directMemory.free(pointer);\n  }","id":11597,"modified_method":"public void testSetLeftSibling() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    final OBonsaiBucketPointer p = new OBonsaiBucketPointer(123);\n    treeBucket.setLeftSibling(p);\n    Assert.assertEquals(treeBucket.getLeftSibling(), p);\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testInitialization() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertTrue(treeBucket.isLeaf());\n\n    treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE,\n        ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertTrue(treeBucket.isLeaf());\n    Assert.assertEquals(treeBucket.getLeftSibling(), -1);\n    Assert.assertEquals(treeBucket.getRightSibling(), -1);\n\n    directMemory.free(pointer);\n  }","id":11598,"modified_method":"public void testInitialization() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertTrue(treeBucket.isLeaf());\n\n    treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE,\n        ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertTrue(treeBucket.isLeaf());\n    Assert.assertFalse(treeBucket.getLeftSibling().isValid());\n    Assert.assertFalse(treeBucket.getRightSibling().isValid());\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testRemove() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testRemove seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, key, new ORecordId(index,\n          OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    int itemsToDelete = originalSize / 2;\n    for (int i = 0; i < itemsToDelete; i++) {\n      treeBucket.remove(treeBucket.size() - 1);\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize - itemsToDelete);\n\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    Iterator<Long> keysIterator = keys.iterator();\n\n    index = 0;\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, key, new ORecordId(index,\n          OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, keyIndexEntry.getKey(),\n          new ORecordId(keyIndexEntry.getValue(), OClusterPositionFactory.INSTANCE.valueOf(keyIndexEntry.getValue()))));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","id":11599,"modified_method":"public void testRemove() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testRemove seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, key, new ORecordId(index, OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    int itemsToDelete = originalSize / 2;\n    for (int i = 0; i < itemsToDelete; i++) {\n      treeBucket.remove(treeBucket.size() - 1);\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize - itemsToDelete);\n\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    Iterator<Long> keysIterator = keys.iterator();\n\n    index = 0;\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, key, new ORecordId(index, OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, keyIndexEntry.getKey(), new ORecordId(keyIndexEntry.getValue(),\n              OClusterPositionFactory.INSTANCE.valueOf(keyIndexEntry.getValue()))));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testUpdateValue() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testUpdateValue seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, key, new ORecordId(index,\n          OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(keyIndexMap.size(), treeBucket.size());\n\n    for (int i = 0; i < treeBucket.size(); i++)\n      treeBucket.updateValue(i, new ORecordId(i + 5, OClusterPositionFactory.INSTANCE.valueOf(i + 5)));\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, keyIndexEntry.getKey(),\n          new ORecordId(keyIndexEntry.getValue() + 5, OClusterPositionFactory.INSTANCE.valueOf(keyIndexEntry.getValue() + 5))));\n      Assert.assertEquals(keyIndexEntry.getKey(), treeBucket.getKey(keyIndexEntry.getValue()));\n    }\n\n    directMemory.free(pointer);\n  }","id":11600,"modified_method":"public void testUpdateValue() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testUpdateValue seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, key, new ORecordId(index, OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(keyIndexMap.size(), treeBucket.size());\n\n    for (int i = 0; i < treeBucket.size(); i++)\n      treeBucket.updateValue(i, new ORecordId(i + 5, OClusterPositionFactory.INSTANCE.valueOf(i + 5)));\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, keyIndexEntry.getKey(), new ORecordId(keyIndexEntry.getValue() + 5,\n              OClusterPositionFactory.INSTANCE.valueOf(keyIndexEntry.getValue() + 5))));\n      Assert.assertEquals(keyIndexEntry.getKey(), treeBucket.getKey(keyIndexEntry.getValue()));\n    }\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testShrink() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testShrink seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, key, new ORecordId(index,\n          OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    treeBucket.shrink(treeBucket.size() / 2);\n    Assert.assertEquals(treeBucket.size(), index / 2);\n\n    index = 0;\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n\n    Iterator<Long> keysIterator = keys.iterator();\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, key, new ORecordId(index,\n          OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, keyIndexEntry.getKey(),\n          new ORecordId(keyIndexEntry.getValue(), OClusterPositionFactory.INSTANCE.valueOf(keyIndexEntry.getValue()))));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","id":11601,"modified_method":"public void testShrink() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testShrink seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, key, new ORecordId(index, OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    treeBucket.shrink(treeBucket.size() / 2);\n    Assert.assertEquals(treeBucket.size(), index / 2);\n\n    index = 0;\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n\n    Iterator<Long> keysIterator = keys.iterator();\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, key, new ORecordId(index, OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, keyIndexEntry.getKey(), new ORecordId(keyIndexEntry.getValue(),\n              OClusterPositionFactory.INSTANCE.valueOf(keyIndexEntry.getValue()))));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSearch() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testSearch seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(-1, -1, key, new ORecordId(index,\n          OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(treeBucket.size(), keyIndexMap.size());\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    directMemory.free(pointer);\n  }","id":11602,"modified_method":"public void testSearch() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testSearch seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, true,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(OBonsaiBucketPointer.NULL,\n          OBonsaiBucketPointer.NULL, key, new ORecordId(index, OClusterPositionFactory.INSTANCE.valueOf(index))), true))\n        break;\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(treeBucket.size(), keyIndexMap.size());\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSearch() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testSearch seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(random.nextInt(Integer.MAX_VALUE),\n          random.nextInt(Integer.MAX_VALUE), key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(treeBucket.size(), keyIndexMap.size());\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    long prevRight = -1;\n    for (int i = 0; i < treeBucket.size(); i++) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevRight > 0)\n        Assert.assertEquals(entry.leftChild, prevRight);\n\n      prevRight = entry.rightChild;\n    }\n\n    long prevLeft = -1;\n    for (int i = treeBucket.size() - 1; i >= 0; i--) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevLeft > 0)\n        Assert.assertEquals(entry.rightChild, prevLeft);\n\n      prevLeft = entry.leftChild;\n    }\n\n    directMemory.free(pointer);\n  }","id":11603,"modified_method":"public void testSearch() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testSearch seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(random.nextInt(Integer.MAX_VALUE)),\n              new OBonsaiBucketPointer(random.nextInt(Integer.MAX_VALUE)), key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    Assert.assertEquals(treeBucket.size(), keyIndexMap.size());\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    OBonsaiBucketPointer prevRight = OBonsaiBucketPointer.NULL;\n    for (int i = 0; i < treeBucket.size(); i++) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevRight.getPageIndex() > 0)\n        Assert.assertEquals(entry.leftChild, prevRight);\n\n      prevRight = entry.rightChild;\n    }\n\n    OBonsaiBucketPointer prevLeft = OBonsaiBucketPointer.NULL;\n    for (int i = treeBucket.size() - 1; i >= 0; i--) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(i);\n\n      if (prevLeft.getPageIndex() > 0)\n        Assert.assertEquals(entry.rightChild, prevLeft);\n\n      prevLeft = entry.leftChild;\n    }\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testInitialization() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertFalse(treeBucket.isLeaf());\n\n    treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE,\n        ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertFalse(treeBucket.isLeaf());\n    Assert.assertEquals(treeBucket.getLeftSibling(), -1);\n    Assert.assertEquals(treeBucket.getRightSibling(), -1);\n\n    directMemory.free(pointer);\n  }","id":11604,"modified_method":"public void testInitialization() throws Exception {\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertFalse(treeBucket.isLeaf());\n\n    treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE,\n        ODurablePage.TrackMode.FULL);\n    Assert.assertEquals(treeBucket.size(), 0);\n    Assert.assertFalse(treeBucket.isLeaf());\n    Assert.assertEquals(treeBucket.getLeftSibling().getPageIndex(), -1);\n    Assert.assertEquals(treeBucket.getRightSibling().getPageIndex(), -1);\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testShrink() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testShrink seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(index, index + 1, key, null), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    treeBucket.shrink(treeBucket.size() / 2);\n    Assert.assertEquals(treeBucket.size(), index / 2);\n\n    index = 0;\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n\n    Iterator<Long> keysIterator = keys.iterator();\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(keyIndexEntry.getValue(), keyIndexEntry.getValue() + 1,\n              keyIndexEntry.getKey(), null));\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(index, index + 1, key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(keyIndexEntry.getValue(), keyIndexEntry.getValue() + 1,\n              keyIndexEntry.getKey(), null));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","id":11605,"modified_method":"public void testShrink() throws Exception {\n    long seed = System.currentTimeMillis();\n    System.out.println(\"testShrink seed : \" + seed);\n\n    TreeSet<Long> keys = new TreeSet<Long>();\n    Random random = new Random(seed);\n\n    while (keys.size() < 2 * OSBTreeBonsaiBucket.MAX_BUCKET_SIZE_BYTES / OLongSerializer.LONG_SIZE) {\n      keys.add(random.nextLong());\n    }\n\n    long pointer = directMemory.allocate(OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024);\n    OSBTreeBonsaiBucket<Long, OIdentifiable> treeBucket = new OSBTreeBonsaiBucket<Long, OIdentifiable>(pointer, 0, false,\n        OLongSerializer.INSTANCE, OLinkSerializer.INSTANCE, ODurablePage.TrackMode.FULL);\n\n    int index = 0;\n    for (Long key : keys) {\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(index),\n          new OBonsaiBucketPointer(index + 1), key, null), true))\n        break;\n\n      index++;\n    }\n\n    int originalSize = treeBucket.size();\n\n    treeBucket.shrink(treeBucket.size() / 2);\n    Assert.assertEquals(treeBucket.size(), index / 2);\n\n    index = 0;\n    final Map<Long, Integer> keyIndexMap = new HashMap<Long, Integer>();\n\n    Iterator<Long> keysIterator = keys.iterator();\n    while (keysIterator.hasNext() && index < treeBucket.size()) {\n      Long key = keysIterator.next();\n      keyIndexMap.put(key, index);\n      index++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      int bucketIndex = treeBucket.find(keyIndexEntry.getKey());\n      Assert.assertEquals(bucketIndex, (int) keyIndexEntry.getValue());\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(keyIndexEntry.getValue()),\n              new OBonsaiBucketPointer(keyIndexEntry.getValue() + 1), keyIndexEntry.getKey(), null));\n    }\n\n    int keysToAdd = originalSize - treeBucket.size();\n    int addedKeys = 0;\n    while (keysIterator.hasNext() && index < originalSize) {\n      Long key = keysIterator.next();\n\n      if (!treeBucket.addEntry(index, new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(index),\n          new OBonsaiBucketPointer(index + 1), key, null), true))\n        break;\n\n      keyIndexMap.put(key, index);\n      index++;\n      addedKeys++;\n    }\n\n    for (Map.Entry<Long, Integer> keyIndexEntry : keyIndexMap.entrySet()) {\n      OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable> entry = treeBucket.getEntry(keyIndexEntry.getValue());\n\n      Assert.assertEquals(entry,\n          new OSBTreeBonsaiBucket.SBTreeEntry<Long, OIdentifiable>(new OBonsaiBucketPointer(keyIndexEntry.getValue()),\n              new OBonsaiBucketPointer(keyIndexEntry.getValue() + 1), keyIndexEntry.getKey(), null));\n    }\n\n    Assert.assertEquals(treeBucket.size(), originalSize);\n    Assert.assertEquals(addedKeys, keysToAdd);\n\n    directMemory.free(pointer);\n  }","commit_id":"2d3689f75cbad4a02faaa7dea8b468129ed2c8c5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n\n      toolbar.addLeftWidget(commands_.vcsDiff().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsAddFiles().createToolbarButton());\n      toolbar.addLeftWidget(commands_.vcsRemoveFiles().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsRevert().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsPull().createToolbarButton());\n//      toolbar.addLeftWidget(commands_.vcsCommit().createToolbarButton());\n\n      toolbar.addLeftSeparator();\n      toolbar.addRightWidget(commands_.vcsRefresh().createToolbarButton());\n\n      return toolbar;\n   }","id":11606,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n\n      toolbar.addLeftWidget(commands_.vcsDiff().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsAddFiles().createToolbarButton());\n      toolbar.addLeftWidget(commands_.vcsRemoveFiles().createToolbarButton());\n      toolbar.addLeftWidget(commands_.vcsRevert().createToolbarButton());\n      toolbar.addLeftSeparator();\n      \n      toolbar.addLeftWidget(commands_.vcsCommit().createToolbarButton());\n      \n      toolbar.addLeftSeparator();\n      \n      ToolbarPopupMenu moreMenu = new ToolbarPopupMenu();\n\n      moreMenu.addItem(commands_.vcsShowHistory().createMenuItem(false));\n      moreMenu.addSeparator();\n      moreMenu.addItem(commands_.vcsPull().createMenuItem(false));\n      moreMenu.addSeparator();\n      moreMenu.addItem(commands_.showShellDialog().createMenuItem(false));\n\n      toolbar.addLeftWidget(new ToolbarButton(\n          \"More\",\n          StandardIcons.INSTANCE.more_actions(),\n          moreMenu));\n\n      toolbar.addLeftSeparator();\n      toolbar.addRightWidget(commands_.vcsRefresh().createToolbarButton());\n\n      return toolbar;\n   }","commit_id":"6f231b8f51fd5afdc1cc3fc6d8f8984095c33fa6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showContextMenu(final int clientX, final int clientY)\n   {\n      final ToolbarPopupMenu menu = new ToolbarPopupMenu();\n      \n      menu.addItem(commands_.vcsDiff().createMenuItem(false));\n      menu.addSeparator();\n      menu.addItem(commands_.vcsAddFiles().createMenuItem(false));\n      menu.addItem(commands_.vcsRemoveFiles().createMenuItem(false));\n      menu.addSeparator();\n      menu.addItem(commands_.vcsRevert().createMenuItem(false));\n      menu.addSeparator();\n      menu.addItem(commands_.vcsOpen().createMenuItem(false));\n    \n      menu.setPopupPositionAndShow(new PositionCallback() {\n         @Override\n         public void setPosition(int offsetWidth, int offsetHeight)\n         {\n            menu.setPopupPosition(clientX, clientY);     \n         }\n      });\n   }","id":11607,"modified_method":"@Override\n   public void showContextMenu(final int clientX, final int clientY)\n   {\n      final ToolbarPopupMenu menu = new ToolbarPopupMenu();\n      \n      menu.addItem(commands_.vcsDiff().createMenuItem(false));\n      menu.addSeparator();\n      menu.addItem(commands_.vcsAddFiles().createMenuItem(false));\n      menu.addItem(commands_.vcsRemoveFiles().createMenuItem(false));\n      menu.addItem(commands_.vcsRevert().createMenuItem(false));\n      menu.addSeparator();\n      menu.addItem(commands_.vcsOpen().createMenuItem(false));\n    \n      menu.setPopupPositionAndShow(new PositionCallback() {\n         @Override\n         public void setPosition(int offsetWidth, int offsetHeight)\n         {\n            menu.setPopupPosition(clientX, clientY);     \n         }\n      });\n   }","commit_id":"6f231b8f51fd5afdc1cc3fc6d8f8984095c33fa6","url":"https://github.com/rstudio/rstudio"},{"original_method":"private Toolbar createToolbar()\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n      \n      toolbar.addLeftWidget(commands_.printSourceDoc().createToolbarButton());  \n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n      toolbar.addLeftWidget(commands_.goToFunctionDefinition().createToolbarButton());\n      \n      Label readOnlyLabel = new Label(\"(Read-only)\");\n      readOnlyLabel.addStyleName(RES.styles().readOnly());\n      toolbar.addRightWidget(readOnlyLabel);\n    \n      return toolbar;\n   }","id":11608,"modified_method":"private Toolbar createToolbar()\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n      \n      toolbar.addLeftWidget(commands_.printSourceDoc().createToolbarButton()); \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n     \n      ImageResource icon = ThemeResources.INSTANCE.codeTransform();\n\n      ToolbarPopupMenu menu = new ToolbarPopupMenu();\n      menu.addItem(commands_.goToHelp().createMenuItem(false));\n      menu.addItem(commands_.goToFunctionDefinition().createMenuItem(false));\n      ToolbarButton codeTools = new ToolbarButton(\"\", icon, menu);\n      codeTools.setTitle(\"Code Tools\");\n      toolbar.addLeftWidget(codeTools);\n      \n      Label readOnlyLabel = new Label(\"(Read-only)\");\n      readOnlyLabel.addStyleName(RES.styles().readOnly());\n      toolbar.addRightWidget(readOnlyLabel);\n    \n      return toolbar;\n   }","commit_id":"b1433aaaa1ed1b965896c2e41455ed617b879c11","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void configureTable()\n   {\n      Column<StatusAndPath, Boolean> stagedColumn = new Column<StatusAndPath, Boolean>(new AbstractCell<Boolean>()\n      {\n         @Override\n         public void render(Context context, Boolean value, SafeHtmlBuilder sb)\n         {\n         }\n      })\n      {\n         @Override\n         public Boolean getValue(StatusAndPath object)\n         {\n            return object.getStatus().charAt(1) == ' ';\n         }\n      };\n\n      stagedColumn.setSortable(true);\n      stagedColumn.setHorizontalAlignment(Column.ALIGN_CENTER);\n      table_.addColumn(stagedColumn, \"Staged\");\n\n      Column<StatusAndPath, String> statusColumn = new Column<StatusAndPath, String>(\n            new TextCell(new StatusRenderer()))\n      {\n         @Override\n         public String getValue(StatusAndPath object)\n         {\n            return object.getStatus();\n         }\n      };\n      statusColumn.setSortable(true);\n      statusColumn.setHorizontalAlignment(Column.ALIGN_CENTER);\n      table_.addColumn(statusColumn, \"Status\");\n\n      TextColumn<StatusAndPath> pathColumn = new TextColumn<StatusAndPath>()\n      {\n         @Override\n         public String getValue(StatusAndPath object)\n         {\n            return object.getPath();\n         }\n      };\n      pathColumn.setSortable(true);\n      table_.addColumn(pathColumn, \"Path\");\n   }","id":11609,"modified_method":"private void configureTable()\n   {\n      Column<StatusAndPath, Boolean> stagedColumn = new Column<StatusAndPath, Boolean>(new AbstractCell<Boolean>()\n      {\n         @Override\n         public void render(Context context, Boolean value, SafeHtmlBuilder sb)\n         {\n         }\n      })\n      {\n         @Override\n         public Boolean getValue(StatusAndPath object)\n         {\n            return object.getStatus().charAt(1) == ' ';\n         }\n      };\n\n      stagedColumn.setSortable(true);\n      stagedColumn.setHorizontalAlignment(Column.ALIGN_CENTER);\n      table_.addColumn(stagedColumn, \"Staged\");\n      table_.setColumnWidth(stagedColumn, \"45px\");\n\n      Column<StatusAndPath, String> statusColumn = new Column<StatusAndPath, String>(\n            new TextCell(new StatusRenderer()))\n      {\n         @Override\n         public String getValue(StatusAndPath object)\n         {\n            return object.getStatus();\n         }\n      };\n      statusColumn.setSortable(true);\n      statusColumn.setHorizontalAlignment(Column.ALIGN_CENTER);\n      table_.addColumn(statusColumn, \"Status\");\n      table_.setColumnWidth(statusColumn, \"40px\");\n\n      TextColumn<StatusAndPath> pathColumn = new TextColumn<StatusAndPath>()\n      {\n         @Override\n         public String getValue(StatusAndPath object)\n         {\n            return object.getPath();\n         }\n      };\n      pathColumn.setSortable(true);\n      table_.addColumn(pathColumn, \"Path\");\n   }","commit_id":"3459fdc90d9d254edaeb780ad9febfbea0b4f484","url":"https://github.com/rstudio/rstudio"},{"original_method":"private String descForStatus(String str)\n      {\n         return \"hey that's cool\";\n      }","id":11610,"modified_method":"private String descForStatus(String str)\n      {\n         // TODO: Provide a suitable tooltip value for status\n         return \"\";\n      }","commit_id":"3459fdc90d9d254edaeb780ad9febfbea0b4f484","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.vcsDiff().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsStage().createToolbarButton());\n      toolbar.addLeftWidget(commands_.vcsUnstage().createToolbarButton());\n      toolbar.addLeftWidget(commands_.vcsRevert().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsCommit().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsShowHistory().createToolbarButton());\n\n      toolbar.addRightWidget(commands_.vcsRefresh().createToolbarButton());\n      return toolbar;\n   }","id":11611,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      ToolbarPopupMenu moreMenu = new ToolbarPopupMenu();\n      moreMenu.addItem(commands_.vcsIgnore().createMenuItem(false));\n      moreMenu.addSeparator();\n      moreMenu.addItem(commands_.vcsPull().createMenuItem(false));\n      moreMenu.addItem(commands_.vcsPush().createMenuItem(false));\n      moreMenu.addSeparator();\n      moreMenu.addItem(commands_.vcsShowHistory().createMenuItem(false));\n\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.vcsDiff().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsRevert().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.vcsCommit().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(new ToolbarButton(\n            \"More\",\n            StandardIcons.INSTANCE.more_actions(),\n            moreMenu));\n\n      toolbar.addRightWidget(commands_.vcsRefresh().createToolbarButton());\n      return toolbar;\n   }","commit_id":"3459fdc90d9d254edaeb780ad9febfbea0b4f484","url":"https://github.com/rstudio/rstudio"},{"original_method":"public boolean gradientCheck(int numOfChecks, int numOfRandomChecks, double[] x) {\n    double epsilon = 1e-5;\n    double diffThreshold = 0.01;\n    double diffPctThreshold = 0.1;\n    double twoEpsilon = epsilon * 2;\n    int xLen = x.length;\n    // System.err.println(\"\\n\\n\\ncalling derivativeAt\");\n    derivativeAt(x);\n    double[] savedDeriv = new double[xLen];\n    System.arraycopy(derivative, 0, savedDeriv, 0, derivative.length); \n    double oldX, plusVal, minusVal, appDeriv, calcDeriv, diff, pct = 0;\n    int interval = Math.max(1, x.length / numOfChecks);\n    Set<Integer> indicesToCheck = new HashSet<Integer>();\n    for (int paramIndex = 0; paramIndex < xLen; paramIndex+=interval) {\n      indicesToCheck.add(paramIndex);\n    }\n    for (int i = xLen-1; i >= 0 && i > xLen-numOfChecks; i--) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 1; i < xLen && i < numOfChecks; i++) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 0; i < numOfRandomChecks; i++) {\n      indicesToCheck.add(generator.nextInt(xLen));\n    }\n    boolean returnVal = true;\n    for (int paramIndex: indicesToCheck) {\n      oldX = x[paramIndex];\n      x[paramIndex] = oldX + epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt1\");\n      plusVal = valueAt(x);\n      x[paramIndex] = oldX - epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt2\");\n      minusVal = valueAt(x);\n      appDeriv = (plusVal - minusVal) / twoEpsilon;\n      calcDeriv = savedDeriv[paramIndex];\n      diff = Math.abs(appDeriv - calcDeriv);\n      pct = diff / Math.min(Math.abs(appDeriv), Math.abs(calcDeriv));\n      if (diff > diffThreshold && pct > diffPctThreshold) {\n        System.err.printf(\"Grad fail at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct); \n        returnVal= false;\n      } else {\n        System.err.printf(\"Grad good at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n      }\n      x[paramIndex] = oldX;\n    }\n    if (returnVal){\n      System.err.printf(\"ALL gradients passed. Yay!\\n\");\n      \n    }\n    return returnVal;\n  }","id":11612,"modified_method":"public boolean gradientCheck(int numOfChecks, int numOfRandomChecks, double[] x) {\n    double epsilon = 1e-5;\n    double diffThreshold = 0.01;\n    double diffPctThreshold = 0.1;\n    double twoEpsilon = epsilon * 2;\n    int xLen = x.length;\n    // System.err.println(\"\\n\\n\\ncalling derivativeAt\");\n    derivativeAt(x);\n    double[] savedDeriv = new double[xLen];\n    System.arraycopy(derivative, 0, savedDeriv, 0, derivative.length);\n    int interval = Math.max(1, x.length / numOfChecks);\n    Set<Integer> indicesToCheck = new HashSet<Integer>();\n    for (int paramIndex = 0; paramIndex < xLen; paramIndex+=interval) {\n      indicesToCheck.add(paramIndex);\n    }\n    for (int i = xLen-1; i >= 0 && i > xLen-numOfChecks; i--) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 1; i < xLen && i < numOfChecks; i++) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 0; i < numOfRandomChecks; i++) {\n      indicesToCheck.add(generator.nextInt(xLen));\n    }\n    boolean returnVal = true;\n    for (int paramIndex: indicesToCheck) {\n      double oldX = x[paramIndex];\n      x[paramIndex] = oldX + epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt1\");\n      double plusVal = valueAt(x);\n      x[paramIndex] = oldX - epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt2\");\n      double minusVal = valueAt(x);\n      double appDeriv = (plusVal - minusVal) / twoEpsilon;\n      double calcDeriv = savedDeriv[paramIndex];\n      double diff = Math.abs(appDeriv - calcDeriv);\n      double pct = diff / Math.min(Math.abs(appDeriv), Math.abs(calcDeriv));\n      if (diff > diffThreshold && pct > diffPctThreshold) {\n        System.err.printf(\"Grad fail at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n        returnVal= false;\n      } else {\n        System.err.printf(\"Grad good at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n      }\n      x[paramIndex] = oldX;\n    }\n    if (returnVal){\n      System.err.printf(\"ALL gradients passed. Yay!\\n\");\n\n    }\n    return returnVal;\n  }","commit_id":"22034cc9a0256bfb589bd9e6947b53cf9d0cae1d","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean gradientCheck(int numOfChecks, int numOfRandomChecks, double[] x) {\n    double epsilon = 1e-5;\n    double diffThreshold = 0.01;\n    double diffPctThreshold = 0.1;\n    double twoEpsilon = epsilon * 2;\n    int xLen = x.length;\n    // System.err.println(\"\\n\\n\\ncalling derivativeAt\");\n    derivativeAt(x);\n    double[] savedDeriv = new double[xLen];\n    System.arraycopy(derivative, 0, savedDeriv, 0, derivative.length); \n    double oldX, plusVal, minusVal, appDeriv, calcDeriv, diff, pct = 0;\n    int interval = Math.max(1, x.length / numOfChecks);\n    Set<Integer> indicesToCheck = new HashSet<Integer>();\n    for (int paramIndex = 0; paramIndex < xLen; paramIndex+=interval) {\n      indicesToCheck.add(paramIndex);\n    }\n    for (int i = xLen-1; i >= 0 && i > xLen-numOfChecks; i--) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 1; i < xLen && i < numOfChecks; i++) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 0; i < numOfRandomChecks; i++) {\n      indicesToCheck.add(generator.nextInt(xLen));\n    }\n    boolean returnVal = true;\n    for (int paramIndex: indicesToCheck) {\n      oldX = x[paramIndex];\n      x[paramIndex] = oldX + epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt1\");\n      plusVal = valueAt(x);\n      x[paramIndex] = oldX - epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt2\");\n      minusVal = valueAt(x);\n      appDeriv = (plusVal - minusVal) / twoEpsilon;\n      calcDeriv = savedDeriv[paramIndex];\n      diff = Math.abs(appDeriv - calcDeriv);\n      pct = diff / Math.min(Math.abs(appDeriv), Math.abs(calcDeriv));\n      if (diff > diffThreshold && pct > diffPctThreshold) {\n        System.err.printf(\"Grad fail at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct); \n        returnVal= false;\n      } else {\n        System.err.printf(\"Grad good at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n      }\n      x[paramIndex] = oldX;\n    }\n    if (returnVal){\n      System.err.printf(\"ALL gradients passed. Yay!\\n\");\n      \n    }\n    return returnVal;\n  }","id":11613,"modified_method":"public boolean gradientCheck(int numOfChecks, int numOfRandomChecks, double[] x) {\n    double epsilon = 1e-5;\n    double diffThreshold = 0.01;\n    double diffPctThreshold = 0.1;\n    double twoEpsilon = epsilon * 2;\n    int xLen = x.length;\n    // System.err.println(\"\\n\\n\\ncalling derivativeAt\");\n    derivativeAt(x);\n    double[] savedDeriv = new double[xLen];\n    System.arraycopy(derivative, 0, savedDeriv, 0, derivative.length);\n    int interval = Math.max(1, x.length / numOfChecks);\n    Set<Integer> indicesToCheck = new HashSet<Integer>();\n    for (int paramIndex = 0; paramIndex < xLen; paramIndex+=interval) {\n      indicesToCheck.add(paramIndex);\n    }\n    for (int i = xLen-1; i >= 0 && i > xLen-numOfChecks; i--) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 1; i < xLen && i < numOfChecks; i++) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 0; i < numOfRandomChecks; i++) {\n      indicesToCheck.add(generator.nextInt(xLen));\n    }\n    boolean returnVal = true;\n    for (int paramIndex: indicesToCheck) {\n      double oldX = x[paramIndex];\n      x[paramIndex] = oldX + epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt1\");\n      double plusVal = valueAt(x);\n      x[paramIndex] = oldX - epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt2\");\n      double minusVal = valueAt(x);\n      double appDeriv = (plusVal - minusVal) / twoEpsilon;\n      double calcDeriv = savedDeriv[paramIndex];\n      double diff = Math.abs(appDeriv - calcDeriv);\n      double pct = diff / Math.min(Math.abs(appDeriv), Math.abs(calcDeriv));\n      if (diff > diffThreshold && pct > diffPctThreshold) {\n        System.err.printf(\"Grad fail at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n        returnVal= false;\n      } else {\n        System.err.printf(\"Grad good at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n      }\n      x[paramIndex] = oldX;\n    }\n    if (returnVal){\n      System.err.printf(\"ALL gradients passed. Yay!\\n\");\n\n    }\n    return returnVal;\n  }","commit_id":"db280fe7b968460b22cb69215ebf5dc2fc48fb98","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean gradientCheck(int numOfChecks, int numOfRandomChecks, double[] x) {\n    double epsilon = 1e-5;\n    double diffThreshold = 0.01;\n    double diffPctThreshold = 0.1;\n    double twoEpsilon = epsilon * 2;\n    int xLen = x.length;\n    // System.err.println(\"\\n\\n\\ncalling derivativeAt\");\n    derivativeAt(x);\n    double[] savedDeriv = new double[xLen];\n    System.arraycopy(derivative, 0, savedDeriv, 0, derivative.length); \n    double oldX, plusVal, minusVal, appDeriv, calcDeriv, diff, pct = 0;\n    int interval = Math.max(1, x.length / numOfChecks);\n    Set<Integer> indicesToCheck = new HashSet<Integer>();\n    for (int paramIndex = 0; paramIndex < xLen; paramIndex+=interval) {\n      indicesToCheck.add(paramIndex);\n    }\n    for (int i = xLen-1; i >= 0 && i > xLen-numOfChecks; i--) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 1; i < xLen && i < numOfChecks; i++) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 0; i < numOfRandomChecks; i++) {\n      indicesToCheck.add(generator.nextInt(xLen));\n    }\n    boolean returnVal = true;\n    for (int paramIndex: indicesToCheck) {\n      oldX = x[paramIndex];\n      x[paramIndex] = oldX + epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt1\");\n      plusVal = valueAt(x);\n      x[paramIndex] = oldX - epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt2\");\n      minusVal = valueAt(x);\n      appDeriv = (plusVal - minusVal) / twoEpsilon;\n      calcDeriv = savedDeriv[paramIndex];\n      diff = Math.abs(appDeriv - calcDeriv);\n      pct = diff / Math.min(Math.abs(appDeriv), Math.abs(calcDeriv));\n      if (diff > diffThreshold && pct > diffPctThreshold) {\n        System.err.printf(\"Grad fail at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct); \n        returnVal= false;\n      } else {\n        System.err.printf(\"Grad good at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n      }\n      x[paramIndex] = oldX;\n    }\n    if (returnVal){\n      System.err.printf(\"ALL gradients passed. Yay!\\n\");\n      \n    }\n    return returnVal;\n  }","id":11614,"modified_method":"public boolean gradientCheck(int numOfChecks, int numOfRandomChecks, double[] x) {\n    double epsilon = 1e-5;\n    double diffThreshold = 0.01;\n    double diffPctThreshold = 0.1;\n    double twoEpsilon = epsilon * 2;\n    int xLen = x.length;\n    // System.err.println(\"\\n\\n\\ncalling derivativeAt\");\n    derivativeAt(x);\n    double[] savedDeriv = new double[xLen];\n    System.arraycopy(derivative, 0, savedDeriv, 0, derivative.length);\n    int interval = Math.max(1, x.length / numOfChecks);\n    Set<Integer> indicesToCheck = new HashSet<Integer>();\n    for (int paramIndex = 0; paramIndex < xLen; paramIndex+=interval) {\n      indicesToCheck.add(paramIndex);\n    }\n    for (int i = xLen-1; i >= 0 && i > xLen-numOfChecks; i--) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 1; i < xLen && i < numOfChecks; i++) {\n      indicesToCheck.add(i);\n    }\n    for (int i = 0; i < numOfRandomChecks; i++) {\n      indicesToCheck.add(generator.nextInt(xLen));\n    }\n    boolean returnVal = true;\n    for (int paramIndex: indicesToCheck) {\n      double oldX = x[paramIndex];\n      x[paramIndex] = oldX + epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt1\");\n      double plusVal = valueAt(x);\n      x[paramIndex] = oldX - epsilon;\n      // System.err.println(\"\\n\\n\\ncalling valueAt2\");\n      double minusVal = valueAt(x);\n      double appDeriv = (plusVal - minusVal) / twoEpsilon;\n      double calcDeriv = savedDeriv[paramIndex];\n      double diff = Math.abs(appDeriv - calcDeriv);\n      double pct = diff / Math.min(Math.abs(appDeriv), Math.abs(calcDeriv));\n      if (diff > diffThreshold && pct > diffPctThreshold) {\n        System.err.printf(\"Grad fail at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n        returnVal= false;\n      } else {\n        System.err.printf(\"Grad good at %2d, appGrad=%9.7f, calcGrad=%9.7f, diff=%9.7f, pct=%9.7f\\n\", paramIndex,appDeriv,calcDeriv,diff,pct);\n      }\n      x[paramIndex] = oldX;\n    }\n    if (returnVal){\n      System.err.printf(\"ALL gradients passed. Yay!\\n\");\n\n    }\n    return returnVal;\n  }","commit_id":"5de5f8d8ef8cffcd69839806643ed11338e8b93c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n\t\tpublic ISerState createPush(SerializerPDA pda, AbstractElement token) {\n\t\t\treturn delegate.createPush(pda, original(token));\n\t\t}","id":11615,"modified_method":"@Override\n\t\tpublic ISerState createPush(SerializerPDA pda, AbstractElement token) {\n\t\t\tAbstractElement original = original(token);\n\t\t\tISerState state = pushs.get(original);\n\t\t\tif (state == null) {\n\t\t\t\tstate = delegate.createPush(pda, original);\n\t\t\t\tpushs.put(original, state);\n\t\t\t}\n\t\t\treturn state;\n\t\t}","commit_id":"b9ec8bcbba7624bb21cb44019f97f370502395bb","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic ISerState createPop(SerializerPDA pda, AbstractElement token) {\n\t\t\treturn delegate.createPop(pda, original(token));\n\t\t}","id":11616,"modified_method":"@Override\n\t\tpublic ISerState createPop(SerializerPDA pda, AbstractElement token) {\n\t\t\tAbstractElement original = original(token);\n\t\t\tISerState state = pops.get(original);\n\t\t\tif (state == null) {\n\t\t\t\tstate = delegate.createPop(pda, original);\n\t\t\t\tpops.put(original, state);\n\t\t\t}\n\t\t\treturn state;\n\t\t}","commit_id":"b9ec8bcbba7624bb21cb44019f97f370502395bb","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic ISerState createState(SerializerPDA nfa, AbstractElement token) {\n\t\t\treturn delegate.createState(nfa, original(token));\n\t\t}","id":11617,"modified_method":"@Override\n\t\tpublic ISerState createState(SerializerPDA nfa, AbstractElement token) {\n\t\t\tAbstractElement original = original(token);\n\t\t\tISerState state = states.get(original);\n\t\t\tif (state == null) {\n\t\t\t\tstate = delegate.createState(nfa, original);\n\t\t\t\tstates.put(original, state);\n\t\t\t}\n\t\t\treturn state;\n\t\t}","commit_id":"b9ec8bcbba7624bb21cb44019f97f370502395bb","url":"https://github.com/eclipse/xtext"},{"original_method":"protected AbstractElement original(AbstractElement ele) {\n\t\t\treturn ele != null ? OriginalElement.findInEmfObject(ele).getOriginal() : null;\n\t\t}","id":11618,"modified_method":"protected AbstractElement original(AbstractElement ele) {\n\t\t\tif (ele == null)\n\t\t\t\treturn null;\n\t\t\tAbstractElement original = OriginalElement.findInEmfObject(ele).getOriginal();\n\t\t\tif (original == null) {\n\t\t\t\tString name = new GrammarElementTitleSwitch().showQualified().showAssignments().apply(ele);\n\t\t\t\tthrow new IllegalStateException(\"no original grammar element found for  \" + name);\n\t\t\t}\n\t\t\treturn original;\n\t\t}","commit_id":"b9ec8bcbba7624bb21cb44019f97f370502395bb","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic void setFollowers(SerializerPDA nfa, ISerState owner, Iterable<ISerState> followers) {\n\t\t\tdelegate.setFollowers(nfa, owner, followers);\n\t\t}","id":11619,"modified_method":"@Override\n\t\tpublic void setFollowers(SerializerPDA nfa, ISerState owner, Iterable<ISerState> followers) {\n\t\t\tSet<ISerState> all = Sets.newLinkedHashSet(owner.getFollowers());\n\t\t\tIterables.addAll(all, followers);\n\t\t\tdelegate.setFollowers(nfa, owner, all);\n\t\t}","commit_id":"b9ec8bcbba7624bb21cb44019f97f370502395bb","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof HierarchicalUriComponents)) {\n\t\t\treturn false;\n\t\t}\n\t\tHierarchicalUriComponents other = (HierarchicalUriComponents) obj;\n\t\tif (ObjectUtils.nullSafeEquals(getScheme(), other.getScheme())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ObjectUtils.nullSafeEquals(getUserInfo(), other.getUserInfo())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ObjectUtils.nullSafeEquals(getHost(), other.getHost())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.port != other.port) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.path.equals(other.path)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.queryParams.equals(other.queryParams)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ObjectUtils.nullSafeEquals(getFragment(), other.getFragment())) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","id":11620,"modified_method":"@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof HierarchicalUriComponents)) {\n\t\t\treturn false;\n\t\t}\n\t\tHierarchicalUriComponents other = (HierarchicalUriComponents) obj;\n\t\tboolean rtn = true;\n\t\trtn &= ObjectUtils.nullSafeEquals(getScheme(), other.getScheme());\n\t\trtn &= ObjectUtils.nullSafeEquals(getUserInfo(), other.getUserInfo());\n\t\trtn &= ObjectUtils.nullSafeEquals(getHost(), other.getHost());\n\t\trtn &= getPort() == other.getPort();\n\t\trtn &= this.path.equals(other.path);\n\t\trtn &= this.queryParams.equals(other.queryParams);\n\t\trtn &= ObjectUtils.nullSafeEquals(getFragment(), other.getFragment());\n\t\treturn rtn;\n\t}","commit_id":"5b7969e726edf9080e999730f53f6d449172279d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof OpaqueUriComponents)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tOpaqueUriComponents other = (OpaqueUriComponents) obj;\n\n\t\tif (ObjectUtils.nullSafeEquals(getScheme(), other.getScheme())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ObjectUtils.nullSafeEquals(this.ssp, other.ssp)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ObjectUtils.nullSafeEquals(getFragment(), other.getFragment())) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":11621,"modified_method":"@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof OpaqueUriComponents)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tOpaqueUriComponents other = (OpaqueUriComponents) obj;\n\t\tboolean rtn = true;\n\t\trtn &= ObjectUtils.nullSafeEquals(getScheme(), other.getScheme());\n\t\trtn &= ObjectUtils.nullSafeEquals(this.ssp, other.ssp);\n\t\trtn &= ObjectUtils.nullSafeEquals(getFragment(), other.getFragment());\n\t\treturn rtn;\n\t}","commit_id":"5b7969e726edf9080e999730f53f6d449172279d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void makeADeletion() {\n    if (getState() == PQNode.State.FULL || getState() == PQNode.State.EMPTY) {\n      return;\n    } else {\n      if (myMakeAFromH) {\n        for (PQNode child : ListSequence.fromList(getChildren())) {\n          if (child.getState() == PQNode.State.PARTIAL) {\n            if (child == myFirstAChild || child == mySecondAChild) {\n              child.makeHDeletion();\n            } else {\n              child.makeEmpty();\n            }\n          }\n        }\n      } else {\n        for (PQNode child : ListSequence.fromList(getChildren())) {\n          if (child == myFirstAChild) {\n            child.makeADeletion();\n          } else {\n            child.makeEmpty();\n          }\n        }\n      }\n    }\n  }","id":11622,"modified_method":"public void makeADeletion() {\n    if (getState() == PQNode.State.FULL || getState() == PQNode.State.EMPTY) {\n      return;\n    } else {\n      if (myMakeAFromH) {\n        for (PQNode child : ListSequence.fromList(getChildren())) {\n          if (child.getState() == PQNode.State.PARTIAL) {\n            if (child == myFirstAChild || child == mySecondAChild) {\n              child.makeHDeletion();\n            } else {\n              child.makeEmpty();\n            }\n          }\n        }\n      } else {\n        Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();\n        while (childItr.hasNext()) {\n          PQNode child = childItr.next();\n          if (child == myFirstAChild) {\n            child.makeADeletion();\n          } else {\n            if (child.makeEmpty() == null) {\n              childItr.remove();\n            }\n          }\n\n        }\n        for (PQNode child : ListSequence.fromList(getChildren())) {\n          if (child == myFirstAChild) {\n            child.makeADeletion();\n          } else {\n            child.makeEmpty();\n          }\n        }\n      }\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PQNode processAsPertinentRoot(List<PQNode> children, Node nextGraphNode) {\n    ListSequence.fromList(this.getChildren()).removeWhere(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() != PQNode.State.EMPTY;\n      }\n    });\n    children = ListSequence.fromList(children).removeWhere(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() == PQNode.State.EMPTY;\n      }\n    });\n    List<PQNode> partialChildren = ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() == PQNode.State.PARTIAL;\n      }\n    }).toListSequence();\n    int numPartialChildren = ListSequence.fromList(partialChildren).count();\n    PQNode newComponent = new QNode();\n    PNode nextNode = new PNode();\n    newComponent.addLastChild(nextNode);\n    for (PQNode partialChild : ListSequence.fromList(partialChildren)) {\n      SetSequence.fromSet(newComponent.getGraphNodes()).addSequence(SetSequence.fromSet(partialChild.getGraphNodes()));\n    }\n    List<PQNode> fullChildren = ListSequence.fromList(new ArrayList<PQNode>());\n    this.addLastChild(newComponent);\n    if (numPartialChildren > 2) {\n      return null;\n    }\n    if (numPartialChildren == 0) {\n      fullChildren = ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      }).toListSequence();\n    }\n    if (numPartialChildren == 1) {\n      PQNode partialChild = ListSequence.fromList(partialChildren).getElement(0);\n      List<PQNode> firstEmptySegment = ListSequence.fromList(new ArrayList<PQNode>());\n      boolean endFirstSegment = false;\n      for (PQNode child : ListSequence.fromList(partialChild.getChildren())) {\n        if (child.getState() == PQNode.State.FULL) {\n          endFirstSegment = true;\n        } else {\n          if (endFirstSegment) {\n            newComponent.addLastChild(child);\n          } else {\n            ListSequence.fromList(firstEmptySegment).addElement(child);\n          }\n        }\n      }\n      for (PQNode child : ListSequence.fromList(firstEmptySegment).reversedList()) {\n        newComponent.addFirstChild(child);\n      }\n      ListSequence.fromList(fullChildren).addSequence(ListSequence.fromList(partialChild.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      }).toListSequence());\n      ListSequence.fromList(fullChildren).addSequence(ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      }).toListSequence());\n    }\n    if (numPartialChildren == 2) {\n      PQNode partialChild0 = ListSequence.fromList(partialChildren).getElement(0);\n      List<PQNode> emptyNodes = ListSequence.fromList(partialChild0.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.EMPTY;\n        }\n      }).toListSequence();\n      emptyNodes = ListSequence.fromList(emptyNodes).reversedList();\n      for (PQNode child : ListSequence.fromList(emptyNodes)) {\n        newComponent.addFirstChild(child);\n      }\n      PQNode partialChild1 = ListSequence.fromList(partialChildren).getElement(1);\n      ((QNode) partialChild1).reverse();\n      emptyNodes = ListSequence.fromList(partialChild1.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.EMPTY;\n        }\n      }).toListSequence();\n      for (PQNode child : ListSequence.fromList(emptyNodes)) {\n        newComponent.addLastChild(child);\n      }\n      ListSequence.fromList(fullChildren).addSequence(ListSequence.fromList(partialChild0.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      }).toListSequence());\n      ListSequence.fromList(fullChildren).addSequence(ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      }).toListSequence());\n      ListSequence.fromList(fullChildren).addSequence(ListSequence.fromList(partialChild1.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      }).toListSequence());\n    }\n    List<Edge> edgesOrder = ListSequence.fromList(new LinkedList<Edge>());\n    SetSequence.fromSet(newComponent.getGraphNodes()).addSequence(SetSequence.fromSet(this.getGraphNodes()));\n    for (PQNode child : ListSequence.fromList(fullChildren)) {\n      SetSequence.fromSet(newComponent.getGraphNodes()).addSequence(SetSequence.fromSet(child.getGraphNodesInSubtree(edgesOrder)));\n    }\n    NodeWithInEdgeOrder node = null;\n    for (NodeWithInEdgeOrder graphNode : SetSequence.fromSet(newComponent.getGraphNodes())) {\n      if (graphNode.getNode() == nextGraphNode) {\n        node = graphNode;\n      }\n    }\n    nextNode.addGraphNode(node);\n    nextNode.getGraphNode().setInEdgesOrder(edgesOrder);\n    return nextNode;\n  }","id":11623,"modified_method":"public PQNode processAsPertinentRoot(List<PQNode> children, Node nextGraphNode) {\n    ListSequence.fromList(this.getChildren()).removeWhere(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() != PQNode.State.EMPTY;\n      }\n    });\n    children = ListSequence.fromList(children).removeWhere(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() == PQNode.State.EMPTY;\n      }\n    });\n    List<PQNode> partialChildren = ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() == PQNode.State.PARTIAL;\n      }\n    }).toListSequence();\n    int numPartialChildren = ListSequence.fromList(partialChildren).count();\n    QNode newComponent = new QNode();\n    PNode nextNode = new PNode(nextGraphNode, null);\n    newComponent.addLastChild(nextNode);\n    EdgesOrder edgesOrder = newComponent.getEdgesOrder();\n    this.addLastChild(newComponent);\n    if (numPartialChildren > 2) {\n      throw new RuntimeException(\"can not make reduction: pertinent root has more than two partial children\");\n    }\n    if (numPartialChildren == 0) {\n      for (PQNode child : ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      })) {\n        child.collectEdgesOrderInSubtree(edgesOrder);\n      }\n    }\n    if (numPartialChildren == 1) {\n      PQNode partialChild = ListSequence.fromList(partialChildren).first();\n      List<PQNode> firstEmptySegment = ListSequence.fromList(new ArrayList<PQNode>());\n      boolean endFirstSegment = false;\n      for (PQNode child : ListSequence.fromList(partialChild.getChildren())) {\n        if (child.getState() == PQNode.State.FULL) {\n          endFirstSegment = true;\n        } else {\n          if (endFirstSegment) {\n            newComponent.addLastChild(child);\n          } else {\n            ListSequence.fromList(firstEmptySegment).addElement(child);\n          }\n        }\n      }\n      for (PQNode child : ListSequence.fromList(firstEmptySegment).reversedList()) {\n        newComponent.addFirstChild(child);\n      }\n      newComponent.getEdgesOrder().merge(partialChild.getEdgesOrder());\n      for (PQNode child : ListSequence.fromList(partialChild.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      })) {\n        child.collectEdgesOrderInSubtree(edgesOrder);\n      }\n      for (PQNode child : ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      })) {\n        child.collectEdgesOrderInSubtree(edgesOrder);\n      }\n    }\n    if (numPartialChildren == 2) {\n      PQNode partialChild0 = ListSequence.fromList(partialChildren).getElement(0);\n      List<PQNode> emptyNodes = ListSequence.fromList(partialChild0.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.EMPTY;\n        }\n      }).toListSequence();\n      emptyNodes = ListSequence.fromList(emptyNodes).reversedList();\n      for (PQNode child : ListSequence.fromList(emptyNodes)) {\n        newComponent.addFirstChild(child);\n      }\n      PQNode partialChild1 = ListSequence.fromList(partialChildren).getElement(1);\n      ((QNode) partialChild1).reverse();\n      emptyNodes = ListSequence.fromList(partialChild1.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.EMPTY;\n        }\n      }).toListSequence();\n      for (PQNode child : ListSequence.fromList(emptyNodes)) {\n        newComponent.addLastChild(child);\n      }\n      newComponent.getEdgesOrder().merge(partialChild0.getEdgesOrder());\n      for (PQNode child : ListSequence.fromList(partialChild0.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      })) {\n        child.collectEdgesOrderInSubtree(edgesOrder);\n      }\n      for (PQNode child : ListSequence.fromList(children).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      })) {\n        child.collectEdgesOrderInSubtree(edgesOrder);\n      }\n      newComponent.getEdgesOrder().merge(partialChild1.getEdgesOrder());\n      for (PQNode child : ListSequence.fromList(partialChild1.getChildren()).where(new IWhereFilter<PQNode>() {\n        public boolean accept(PQNode it) {\n          return it.getState() == PQNode.State.FULL;\n        }\n      })) {\n        child.collectEdgesOrderInSubtree(edgesOrder);\n      }\n    }\n    return nextNode;\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void computeAValue() {\n    super.computeAValue();\n    if (getState() != PQNode.State.PARTIAL) {\n      myAValue = 0;\n      return;\n    }\n    List<PQNode> partialChildren = ListSequence.fromList(getChildren()).where(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() == PQNode.State.PARTIAL;\n      }\n    }).toListSequence();\n    int valueFromA = 0;\n    PQNode aChild = null;\n    for (PQNode child : ListSequence.fromList(partialChildren)) {\n      int curValue = child.getNumFullLeaves() - child.getAValue();\n      if (valueFromA < curValue) {\n        valueFromA = curValue;\n        aChild = child;\n      }\n    }\n    valueFromA = getNumFullLeaves() - valueFromA;\n    int firstHMax = 0;\n    int secondHMax = 0;\n    PQNode firstHChild = null;\n    PQNode secondHChild = null;\n    int numPartialFullLeaves = 0;\n    for (PQNode child : ListSequence.fromList(partialChildren)) {\n      numPartialFullLeaves += child.getNumFullLeaves();\n      int curValue = child.getNumFullLeaves() - child.getHValue();\n      if (curValue > firstHMax) {\n        secondHMax = firstHMax;\n        secondHChild = firstHChild;\n        firstHMax = curValue;\n        firstHChild = child;\n      } else {\n        if (curValue > secondHMax) {\n          secondHMax = curValue;\n          secondHChild = child;\n        }\n      }\n    }\n    int valueFromH = numPartialFullLeaves - firstHMax - secondHMax;\n    if (valueFromA < valueFromH) {\n      myMakeAFromH = false;\n      myAValue = valueFromA;\n      myFirstAChild = aChild;\n      mySecondAChild = null;\n    } else {\n      myMakeAFromH = true;\n      myAValue = valueFromH;\n      myFirstAChild = firstHChild;\n      mySecondAChild = secondHChild;\n    }\n    if (myAValue > INF) {\n      myAValue = INF;\n    }\n  }","id":11624,"modified_method":"public void computeAValue() {\n    super.computeAValue();\n    if (getState() != PQNode.State.PARTIAL) {\n      myAValue = 0;\n      return;\n    }\n    List<PQNode> partialChildren = ListSequence.fromList(getChildren()).where(new IWhereFilter<PQNode>() {\n      public boolean accept(PQNode it) {\n        return it.getState() == PQNode.State.PARTIAL;\n      }\n    }).toListSequence();\n    int valueFromA = 0;\n    PQNode aChild = null;\n    for (PQNode child : ListSequence.fromList(partialChildren)) {\n      int curValue = child.getNumFullLeaves() - child.getAValue();\n      if (valueFromA < curValue) {\n        valueFromA = curValue;\n        aChild = child;\n      }\n    }\n    valueFromA = getNumFullLeaves() - valueFromA;\n    int firstHMax = 0;\n    int secondHMax = 0;\n    PQNode firstHChild = null;\n    PQNode secondHChild = null;\n    int numPartialFullLeaves = 0;\n    for (PQNode child : ListSequence.fromList(partialChildren)) {\n      numPartialFullLeaves += child.getNumFullLeaves();\n      int curValue = child.getNumFullLeaves() - child.getHValue();\n      if (curValue > firstHMax) {\n        secondHMax = firstHMax;\n        secondHChild = firstHChild;\n        firstHMax = curValue;\n        firstHChild = child;\n      } else {\n        if (curValue > secondHMax) {\n          secondHMax = curValue;\n          secondHChild = child;\n        }\n      }\n    }\n    int valueFromH = numPartialFullLeaves - firstHMax - secondHMax;\n    if (valueFromA <= valueFromH) {\n      myMakeAFromH = false;\n      myAValue = valueFromA;\n      myFirstAChild = aChild;\n      mySecondAChild = null;\n    } else {\n      myMakeAFromH = true;\n      myAValue = valueFromH;\n      myFirstAChild = firstHChild;\n      mySecondAChild = secondHChild;\n    }\n    if (myAValue > INF) {\n      myAValue = INF;\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PQNode makeReduction(boolean isRealPertinentRoot) {\n    int numFull = 0;\n    int numPartial = 0;\n    int numChildren = ListSequence.fromList(getChildren()).count();\n    for (PQNode node : ListSequence.fromList(getChildren())) {\n      if (node.getState() == PQNode.State.FULL) {\n        numFull++;\n      }\n      if (node.getState() == PQNode.State.PARTIAL) {\n        numPartial++;\n      }\n    }\n    if (numFull == numChildren) {\n      return doP1Pattern();\n    } else if (numPartial == 0) {\n      return doP3Pattern();\n    } else if (numPartial == 1) {\n      return doP5Pattern();\n    }\n    return null;\n  }","id":11625,"modified_method":"public PQNode makeReduction(boolean isRealPertinentRoot) {\n    int numFull = 0;\n    int numPartial = 0;\n    int numChildren = ListSequence.fromList(getChildren()).count();\n    QNode replacement = null;\n    for (PQNode node : ListSequence.fromList(getChildren())) {\n      if (node.getState() == PQNode.State.FULL) {\n        numFull++;\n      }\n      if (node.getState() == PQNode.State.PARTIAL) {\n        replacement = ((QNode) node);\n        numPartial++;\n      }\n    }\n    if (numPartial > 1) {\n      throw new RuntimeException(\"can not make reduction: P-node has more than one partial child\");\n    }\n    if (numFull == numChildren) {\n      setState(PQNode.State.FULL);\n      return this;\n    } else {\n      if (replacement == null) {\n        replacement = new QNode();\n        replacement.setState(PQNode.State.PARTIAL);\n      }\n      splitNodes(replacement);\n      return replacement;\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PQNode() {\n    myChildren = ListSequence.fromList(new ArrayList<PQNode>());\n    myState = null;\n    myParent = null;\n    myGraphNodes = SetSequence.fromSet(new HashSet<NodeWithInEdgeOrder>());\n  }","id":11626,"modified_method":"public PQNode() {\n    myChildren = ListSequence.fromList(new ArrayList<PQNode>());\n    myState = null;\n    myParent = null;\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NodeWithInEdgeOrder getGraphNode() {\n    return SetSequence.fromSet(getGraphNodes()).first();\n  }","id":11627,"modified_method":"public Node getGraphNode() {\n    return null;\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String toString(int offset) {\n    StringBuilder builder = new StringBuilder();\n    String spaces = \"\";\n    for (int i = 0; i < offset; i++) {\n      spaces += \" \";\n    }\n    builder.append(spaces + \"node \" + getType() + \" nodes: \" + myGraphNodes + \" state = \" + getState() + \"\\n\");\n    if (ListSequence.fromList(getChildren()).count() > 0) {\n      builder.append(spaces + \"children: \\n\");\n      for (PQNode child : ListSequence.fromList(getChildren())) {\n        builder.append(child.toString(offset + 2));\n      }\n    }\n    return builder.toString();\n  }","id":11628,"modified_method":"public String toString(int offset) {\n    StringBuilder builder = new StringBuilder();\n    String spaces = \"\";\n    for (int i = 0; i < offset; i++) {\n      spaces += \" \";\n    }\n    builder.append(spaces + \"node \" + getType() + \" state = \" + getState() + \"\\n\");\n    builder.append(getGraphInfo(spaces) + \"\\n\");\n    if (ListSequence.fromList(getChildren()).count() > 0) {\n      builder.append(spaces + \"children: \\n\");\n      for (PQNode child : ListSequence.fromList(getChildren())) {\n        builder.append(child.toString(offset + 2));\n      }\n    }\n    return builder.toString();\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addGraphNode(NodeWithInEdgeOrder node) {\n    SetSequence.fromSet(myGraphNodes).addElement(node);\n  }","id":11629,"modified_method":"public void addGraphNode(Node node) {\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void makeEmpty() {\n    if (getState() == PQNode.State.EMPTY) {\n      return;\n    }\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      child.makeEmpty();\n    }\n    setState(PQNode.State.EMPTY);\n  }","id":11630,"modified_method":"protected PQNode makeEmpty() {\n    if (getState() == PQNode.State.EMPTY) {\n      return this;\n    }\n    if (ListSequence.fromList(getChildren()).count() == 0) {\n      if (getState() == PQNode.State.FULL) {\n        return null;\n      } else {\n        return this;\n      }\n    } else {\n      Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();\n      while (childItr.hasNext()) {\n        if (childItr.next().makeEmpty() == null) {\n          childItr.remove();\n        }\n      }\n      setState(PQNode.State.EMPTY);\n      if (ListSequence.fromList(getChildren()).count() == 0) {\n        return null;\n      } else {\n        return this;\n      }\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EmbeddedGraph testPlanarity(Graph graph, Map<Node, Integer> stNumbering) {\n    System.out.println(\"GRAPH!!! \" + graph);\n    System.out.println(stNumbering);\n    myInEdgeOrder = new NodeMap<List<Edge>>(graph);\n    Map<Node, NodeWithInEdgeOrder> nodeMap = new NodeMap<NodeWithInEdgeOrder>(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      MapSequence.fromMap(nodeMap).put(node, new NodeWithInEdgeOrder(node));\n    }\n    Node[] nodeOrder = new Node[graph.getNumNodes()];\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      nodeOrder[MapSequence.fromMap(stNumbering).get(node)] = node;\n    }\n    PQTree graphTree = new PQTree();\n    PQNode curPQNode = new PNode();\n    curPQNode.addGraphNode(new NodeWithInEdgeOrder(nodeOrder[0]));\n    graphTree.setRoot(curPQNode);\n    for (int i = 0; i < nodeOrder.length - 1; i++) {\n      Node curGraphNode = nodeOrder[i];\n      // add leaves for edges starting from current graph node \n      for (Edge edge : ListSequence.fromList(curGraphNode.getOutEdges())) {\n        Leaf edgeLeaf = new Leaf(graphTree);\n        edgeLeaf.setData(edge);\n        edgeLeaf.addGraphNode(MapSequence.fromMap(nodeMap).get(edge.getTarget()));\n        curPQNode.addLastChild(edgeLeaf);\n      }\n      System.out.println(graphTree);\n      // modify tree \n      Node nextGraphNode = nodeOrder[i + 1];\n      Set<Leaf> nextLeaves = this.findLeavesForGraphNode(nextGraphNode, graphTree);\n      // we should not do any reduction for last node \n      if (i < nodeOrder.length - 2) {\n        curPQNode = graphTree.modifyTree(nextLeaves);\n        if (SetSequence.fromSet(nextLeaves).count() > 1) {\n          System.out.println(\"tree have been changed:\");\n          System.out.println(graphTree);\n        }\n        MapSequence.fromMap(myInEdgeOrder).put(nextGraphNode, curPQNode.getGraphNode().getInEdgesOrder());\n      } else {\n        MapSequence.fromMap(myInEdgeOrder).put(nextGraphNode, ListSequence.fromList(new LinkedList<Edge>()));\n        getLastEdgeOrder(graphTree.getRoot(), MapSequence.fromMap(myInEdgeOrder).get(nextGraphNode));\n        MapSequence.fromMap(nodeMap).get(nextGraphNode).setInEdgesOrder(MapSequence.fromMap(myInEdgeOrder).get(nextGraphNode));\n      }\n      for (int j = 0; j <= i + 1; j++) {\n        System.out.println(nodeOrder[j] + \": \" + MapSequence.fromMap(nodeMap).get(nodeOrder[j]).getInEdgesOrder());\n      }\n      for (Leaf leaf : SetSequence.fromSet(nextLeaves)) {\n        ListSequence.fromList(graphTree.getLeaves()).removeElement(leaf);\n      }\n    }\n    System.out.println(\"FINAL EDGE ORDER:\");\n    for (int i = 0; i < nodeOrder.length; i++) {\n      Node node = nodeOrder[i];\n      MapSequence.fromMap(myInEdgeOrder).put(node, MapSequence.fromMap(nodeMap).get(node).getInEdgesOrder());\n      System.out.println(node + \": \");\n      System.out.println(MapSequence.fromMap(myInEdgeOrder).get(node));\n    }\n    EmbeddedGraph embeddedGraph = createEmbeddedGraphNew(graph, myInEdgeOrder, nodeOrder);\n    System.out.println(embeddedGraph);\n    System.out.println(\"bad edges:\");\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      if (!(MapSequence.fromMap(embeddedGraph.getAdjacentFacesMap()).containsKey(edge))) {\n        System.out.println(edge);\n      }\n    }\n    return embeddedGraph;\n  }","id":11631,"modified_method":"public EmbeddedGraph testPlanarity(Graph graph, Map<Node, Integer> stNumbering) {\n    if (SHOW_LOG > 0) {\n      System.out.println(\"GRAPH!!! \" + graph);\n      System.out.println(stNumbering);\n    }\n    myInEdgeOrder = new NodeMap<List<Edge>>(graph);\n    Node[] nodeOrder = new Node[graph.getNumNodes()];\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      nodeOrder[MapSequence.fromMap(stNumbering).get(node)] = node;\n    }\n    PQTree graphTree = new PQTree();\n    PQNode curPQNode = new PNode(nodeOrder[0], null);\n    graphTree.setRoot(curPQNode);\n    for (int i = 0; i < nodeOrder.length - 1; i++) {\n      Node curGraphNode = nodeOrder[i];\n      // add leaves for edges starting from current graph node \n      for (Edge edge : ListSequence.fromList(curGraphNode.getOutEdges())) {\n        PNode node = new PNode(edge.getTarget(), edge);\n        curPQNode.addLastChild(node);\n      }\n      Node nextGraphNode = nodeOrder[i + 1];\n      if (SHOW_LOG > 0) {\n        System.out.println(graphTree);\n        System.out.println(\"next node is: \" + nextGraphNode);\n      }\n      if (i < nodeOrder.length - 1) {\n        curPQNode = graphTree.modifyTree(nextGraphNode);\n      } else {\n        MapSequence.fromMap(myInEdgeOrder).put(nextGraphNode, ListSequence.fromList(new LinkedList<Edge>()));\n        getLastEdgeOrder(graphTree.getRoot(), MapSequence.fromMap(myInEdgeOrder).get(nextGraphNode));\n      }\n    }\n    EdgesOrder order = ((QNode) ListSequence.fromList(graphTree.getRoot().getChildren()).first()).getEdgesOrder();\n    if (PQPlanarityTest.SHOW_LOG > 0) {\n      System.out.println(graphTree);\n      for (int i = nodeOrder.length - 1; i >= 0; i--) {\n        Node node = nodeOrder[i];\n        System.out.print(\"node \" + node + \":\");\n        System.out.print(\" in edges: \" + order.getInEdgesOrder(node));\n        System.out.println(\" out edges: \" + order.getOutEdgesOrder(node));\n      }\n    }\n    EmbeddedGraph embeddedGraph = createEmbeddedGraph(graph, order, Arrays.asList(nodeOrder));\n    if (PQPlanarityTest.SHOW_LOG > 0) {\n      System.out.println(embeddedGraph);\n      System.out.println(\"bad edges:\");\n      for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n        if (!(MapSequence.fromMap(embeddedGraph.getAdjacentFacesMap()).containsKey(edge))) {\n          System.out.println(edge);\n        }\n      }\n    }\n    return embeddedGraph;\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void getLastEdgeOrder(PQNode node, List<Edge> edgeList) {\n    if (node instanceof Leaf) {\n      Leaf leaf = (Leaf) node;\n      ListSequence.fromList(edgeList).addElement(((Edge) leaf.getData()));\n    } else {\n      for (PQNode child : ListSequence.fromList(node.getChildren())) {\n        getLastEdgeOrder(child, edgeList);\n      }\n    }\n  }","id":11632,"modified_method":"public void getLastEdgeOrder(PQNode node, List<Edge> edgeList) {\n    if (ListSequence.fromList(node.getChildren()).count() == 0) {\n      ListSequence.fromList(edgeList).addElement(((PNode) node).getEdge());\n    } else {\n      for (PQNode child : ListSequence.fromList(node.getChildren())) {\n        getLastEdgeOrder(child, edgeList);\n      }\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EmbeddedGraph createEmbeddedGraph(Graph graph, Map<Node, List<Edge>> myInEdgeOrder, Node[] nodeOrder) {\n    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);\n    Map<Face, Node> leftEnd = MapSequence.fromMap(new HashMap<Face, Node>());\n    Map<Face, Node> rightEnd = MapSequence.fromMap(new HashMap<Face, Node>());\n    Node lastNode = nodeOrder[nodeOrder.length - 1];\n    Face outerFace = new Face(graph);\n    embeddedGraph.addFace(outerFace);\n    embeddedGraph.setOuterFace(outerFace);\n    MapSequence.fromMap(leftEnd).put(outerFace, lastNode);\n    MapSequence.fromMap(rightEnd).put(outerFace, lastNode);\n    // first node in st-numbering has no incoming edges \n    for (int i = nodeOrder.length - 1; i > 0; i--) {\n      Node node = nodeOrder[i];\n      Edge prevEdge = null;\n      for (Edge edge : ListSequence.fromList(MapSequence.fromMap(myInEdgeOrder).get(node))) {\n        if (prevEdge != null) {\n          Face newFace = new Face(graph);\n          embeddedGraph.addFace(newFace);\n          embeddedGraph.addLastDart(newFace, new Dart(prevEdge, node));\n          embeddedGraph.addFirstDart(newFace, new Dart(edge, edge.getSource()));\n          MapSequence.fromMap(leftEnd).put(newFace, prevEdge.getSource());\n          MapSequence.fromMap(rightEnd).put(newFace, edge.getSource());\n        }\n        prevEdge = edge;\n      }\n      Edge firstEdge = ListSequence.fromList(MapSequence.fromMap(myInEdgeOrder).get(node)).first();\n      Face leftFace = null;\n      for (Face face : SetSequence.fromSet(MapSequence.fromMap(rightEnd).keySet())) {\n        if (MapSequence.fromMap(rightEnd).get(face) == node) {\n          leftFace = face;\n        }\n      }\n      embeddedGraph.addFirstDart(leftFace, new Dart(firstEdge, firstEdge.getSource()));\n      MapSequence.fromMap(rightEnd).put(leftFace, firstEdge.getSource());\n      if (MapSequence.fromMap(leftEnd).get(leftFace) == MapSequence.fromMap(rightEnd).get(leftFace)) {\n        MapSequence.fromMap(leftEnd).removeKey(leftFace);\n        MapSequence.fromMap(rightEnd).removeKey(leftFace);\n      }\n      Edge lastEdge = ListSequence.fromList(MapSequence.fromMap(myInEdgeOrder).get(node)).last();\n      Face rightFace = null;\n      for (Face face : SetSequence.fromSet(MapSequence.fromMap(leftEnd).keySet())) {\n        if (MapSequence.fromMap(leftEnd).get(face) == node) {\n          rightFace = face;\n        }\n      }\n      embeddedGraph.addLastDart(rightFace, new Dart(lastEdge, node));\n      MapSequence.fromMap(leftEnd).put(rightFace, lastEdge.getSource());\n      if (MapSequence.fromMap(leftEnd).get(rightFace) == MapSequence.fromMap(rightEnd).get(rightFace)) {\n        MapSequence.fromMap(leftEnd).removeKey(rightFace);\n        MapSequence.fromMap(rightEnd).removeKey(rightFace);\n      }\n    }\n    return embeddedGraph;\n  }","id":11633,"modified_method":"public EmbeddedGraph createEmbeddedGraph(Graph graph, EdgesOrder order, List<Node> nodeOrder) {\n    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);\n    Node last = ListSequence.fromList(nodeOrder).last();\n    Face outerFace = order.findFace(graph, last, ListSequence.fromList(order.getInEdgesOrder(last)).first(), false);\n    embeddedGraph.addFace(outerFace);\n    embeddedGraph.setOuterFace(outerFace);\n    for (Node node : ListSequence.fromList(nodeOrder).reversedList()) {\n      Iterator<Edge> edgeItr = ListSequence.fromList(order.getInEdgesOrder(node)).iterator();\n      // last edge should not be processed \n      while (edgeItr.hasNext()) {\n        Edge edge = edgeItr.next();\n        embeddedGraph.addFace(order.findFace(graph, node, edge, true));\n      }\n    }\n    return embeddedGraph;\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PQTree() {\n    myLeaves = ListSequence.fromList(new ArrayList<Leaf>());\n    myRoot = null;\n  }","id":11634,"modified_method":"public PQTree() {\n    myRoot = null;\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void makeReducible() {\n    myNumFullLeaves = MapSequence.fromMap(new HashMap<PQNode, Integer>());\n    int numFullLeavesInTree = 0;\n    for (Leaf leaf : ListSequence.fromList(myLeaves)) {\n      if (leaf.getState() == PQNode.State.FULL) {\n        numFullLeavesInTree++;\n      }\n    }\n    PQNode pertinentRoot = findPertinentRoot(myRoot, numFullLeavesInTree);\n    if (pertinentRoot.getState() == PQNode.State.PARTIAL) {\n      pertinentRoot.computeHValue();\n      pertinentRoot.computeAValue();\n      if (pertinentRoot.getHValue() < pertinentRoot.getAValue()) {\n        pertinentRoot.makeHDeletion();\n      } else {\n        pertinentRoot.makeADeletion();\n      }\n    }\n  }","id":11635,"modified_method":"public void makeReducible() {\n    PQNode pertinentRoot = findPertinentRoot(myRoot);\n    pertinentRoot.computeHValue();\n    pertinentRoot.computeAValue();\n    if (pertinentRoot.getHValue() < pertinentRoot.getAValue()) {\n      pertinentRoot.makeHDeletion();\n    } else {\n      pertinentRoot.makeADeletion();\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"private PQNode arrange(PQNode node, boolean isRealPertinentRoot) {\n    // this boolean value is for Q3 case only \n    if (!(MapSequence.fromMap(myNumFullLeaves).containsKey(node)) || MapSequence.fromMap(myNumFullLeaves).get(node) == 0) {\n      node.setState(PQNode.State.EMPTY);\n      return node;\n    }\n    List<PQNode> children = node.getChildren();\n    ListIterator<PQNode> childItr = children.listIterator();\n    while (childItr.hasNext()) {\n      PQNode child = childItr.next();\n      PQNode newChild = arrange(child, false);\n      if (newChild == null) {\n        return null;\n      }\n      childItr.set(newChild);\n    }\n    return node.makeReduction(isRealPertinentRoot);\n  }","id":11636,"modified_method":"private PQNode arrange(PQNode node, boolean isRealPertinentRoot) {\n    // this boolean value is for Q3 case only \n    if (node.getNumFullLeaves() == 0) {\n      node.setState(PQNode.State.EMPTY);\n      return node;\n    }\n    List<PQNode> children = node.getChildren();\n    ListIterator<PQNode> childItr = children.listIterator();\n    while (childItr.hasNext()) {\n      PQNode child = childItr.next();\n      PQNode newChild = arrange(child, false);\n      childItr.set(newChild);\n    }\n    return node.makeReduction(isRealPertinentRoot);\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PQNode findPertinentRoot(PQNode node, int numAllFullLeaves) {\n    if (node instanceof Leaf) {\n      if (node.getState() == PQNode.State.FULL) {\n        MapSequence.fromMap(myNumFullLeaves).put(node, 1);\n      } else {\n        MapSequence.fromMap(myNumFullLeaves).put(node, 0);\n      }\n    } else {\n      int numFullLeaves = 0;\n      boolean hasPartial = false;\n      int numEmptyChildren = 0;\n      for (PQNode child : ListSequence.fromList(node.getChildren())) {\n        PQNode pertinentRoot = findPertinentRoot(child, numAllFullLeaves);\n        if (pertinentRoot != null) {\n          return pertinentRoot;\n        }\n        numFullLeaves += MapSequence.fromMap(myNumFullLeaves).get(child);\n        if (child.getState() == PQNode.State.PARTIAL) {\n          hasPartial = true;\n        }\n        if (child.getState() == PQNode.State.EMPTY) {\n          numEmptyChildren++;\n        }\n      }\n      if (hasPartial) {\n        node.setState(PQNode.State.PARTIAL);\n      } else {\n        if (numEmptyChildren == 0) {\n          node.setState(PQNode.State.FULL);\n        } else if (numEmptyChildren == ListSequence.fromList(node.getChildren()).count()) {\n          node.setState(PQNode.State.EMPTY);\n        } else {\n          node.setState(PQNode.State.PARTIAL);\n        }\n      }\n      MapSequence.fromMap(myNumFullLeaves).put(node, numFullLeaves);\n    }\n    node.setNumFullLeaves(MapSequence.fromMap(myNumFullLeaves).get(node));\n    if (MapSequence.fromMap(myNumFullLeaves).get(node) == numAllFullLeaves) {\n      return node;\n    } else {\n      return null;\n    }\n  }","id":11637,"modified_method":"public PQNode findPertinentRoot(PQNode node) {\n    if (node.isLeaf()) {\n      if (node.getGraphNode() == myNodeToMerge) {\n        node.setState(PQNode.State.FULL);\n        node.setNumFullLeaves(1);\n      } else {\n        node.setState(PQNode.State.EMPTY);\n        node.setNumFullLeaves(0);\n      }\n      return node;\n    } else {\n      PQNode pertinentRootCandidate = null;\n      int numFullChildren = 0;\n      int numEmptyChildren = 0;\n      int numPartialChildren = 0;\n      int numFullLeaves = 0;\n      for (PQNode child : ListSequence.fromList(node.getChildren())) {\n        PQNode childPertinentRoot = findPertinentRoot(child);\n        numFullLeaves += child.getNumFullLeaves();\n        if (child.getState() == PQNode.State.EMPTY) {\n          numEmptyChildren++;\n        } else {\n          pertinentRootCandidate = childPertinentRoot;\n          if (child.getState() == PQNode.State.FULL) {\n            numFullChildren++;\n          }\n          if (child.getState() == PQNode.State.PARTIAL) {\n            numPartialChildren++;\n          }\n        }\n      }\n      node.setNumFullLeaves(numFullLeaves);\n      if (numPartialChildren > 0) {\n        node.setState(PQNode.State.PARTIAL);\n      } else {\n        int numChildren = ListSequence.fromList(node.getChildren()).count();\n        if (numFullChildren == numChildren) {\n          node.setState(PQNode.State.FULL);\n        } else if (numEmptyChildren == numChildren) {\n          node.setState(PQNode.State.EMPTY);\n        } else {\n          node.setState(PQNode.State.PARTIAL);\n        }\n      }\n      if (numPartialChildren + numFullChildren == 1) {\n        return pertinentRootCandidate;\n      } else {\n        return node;\n      }\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void makeADeletion() {\n    if (getState() != PQNode.State.PARTIAL) {\n      return;\n    }\n    if (myMakeAFromH) {\n      boolean insideHSegment = false;\n      for (PQNode child : ListSequence.fromList(getChildren())) {\n        if (child == myFirstAChild || child == mySecondAChild) {\n          insideHSegment = !(insideHSegment);\n          child.makeHDeletion();\n        } else {\n          if (!(insideHSegment)) {\n            child.makeEmpty();\n          }\n        }\n      }\n    } else {\n      for (PQNode child : ListSequence.fromList(getChildren())) {\n        if (child == myFirstAChild) {\n          child.makeADeletion();\n        } else {\n          child.makeEmpty();\n        }\n      }\n    }\n  }","id":11638,"modified_method":"public void makeADeletion() {\n    if (getState() != PQNode.State.PARTIAL) {\n      return;\n    }\n    if (myMakeAFromH) {\n      boolean insideHSegment = false;\n      Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();\n      while (childItr.hasNext()) {\n        PQNode child = childItr.next();\n        if (child == myFirstAChild || child == mySecondAChild) {\n          insideHSegment = !(insideHSegment);\n          child.makeHDeletion();\n        } else {\n          if (!(insideHSegment)) {\n            if (child.makeEmpty() == null) {\n              childItr.remove();\n            }\n          }\n        }\n      }\n    } else {\n      Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();\n      while (childItr.hasNext()) {\n        PQNode child = childItr.next();\n        if (child == myFirstAChild) {\n          child.makeADeletion();\n        } else {\n          if (child.makeEmpty() == null) {\n            childItr.remove();\n          }\n        }\n      }\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"private QNode createCandidate(PQNode.State initialState, Set<QNode> nodesToRevert) {\n    PQNode.State curState = initialState;\n    QNode candidate = new QNode();\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      if (child.getState() != PQNode.State.PARTIAL) {\n        candidate.addLastChild(child);\n        curState = child.getState();\n      } else {\n        Iterator<PQNode> partialChildIrt;\n        if (curState == PQNode.State.EMPTY) {\n          partialChildIrt = ListSequence.fromList(child.getChildren()).iterator();\n        } else {\n          SetSequence.fromSet(nodesToRevert).addElement(((QNode) child));\n          partialChildIrt = ListSequence.fromList(child.getChildren()).reversedList().iterator();\n        }\n        while (partialChildIrt.hasNext()) {\n          candidate.addLastChild(partialChildIrt.next());\n        }\n        curState = ListSequence.fromList(candidate.getChildren()).last().getState();\n      }\n    }\n    return candidate;\n  }","id":11639,"modified_method":"private QNode createCandidate(PQNode.State initialState) {\n    PQNode.State curState = initialState;\n    QNode candidate = new QNode();\n    candidate.getEdgesOrder().merge(getEdgesOrder());\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      if (child.getState() != PQNode.State.PARTIAL) {\n        candidate.addLastChild(child);\n        curState = child.getState();\n      } else {\n        Iterator<PQNode> partialChildIrt;\n        if (curState == PQNode.State.EMPTY) {\n          candidate.getEdgesOrder().merge(child.getEdgesOrder());\n          partialChildIrt = ListSequence.fromList(child.getChildren()).iterator();\n        } else {\n          child.getEdgesOrder().reverse();\n          candidate.getEdgesOrder().merge(child.getEdgesOrder());\n          partialChildIrt = ListSequence.fromList(child.getChildren()).reversedList().iterator();\n        }\n        while (partialChildIrt.hasNext()) {\n          candidate.addLastChild(partialChildIrt.next());\n        }\n        curState = ListSequence.fromList(candidate.getChildren()).last().getState();\n      }\n    }\n    return candidate;\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PQNode processPartialCandidate(PQNode.State initialState, boolean isPertinentRoot) {\n    Set<QNode> nodesToRevert = SetSequence.fromSet(new HashSet<QNode>());\n    QNode candidate = createCandidate(initialState, nodesToRevert);\n    if (checkCandidate(candidate, isPertinentRoot)) {\n      candidate.setParent(this.getParent());\n      SetSequence.fromSet(candidate.getGraphNodes()).addSequence(SetSequence.fromSet(this.getGraphNodes()));\n      for (QNode node : SetSequence.fromSet(nodesToRevert)) {\n        node.reverse();\n      }\n      // in q-node first should go empty children, and then full children \n      if (ListSequence.fromList(candidate.getChildren()).first().getState() == PQNode.State.FULL) {\n        candidate.reverse();\n      }\n      candidate.setState(PQNode.State.PARTIAL);\n      return candidate;\n    } else {\n      return null;\n    }\n  }","id":11640,"modified_method":"public PQNode processPartialCandidate(PQNode.State initialState, boolean isPertinentRoot) {\n    QNode candidate = createCandidate(initialState);\n    if (checkCandidate(candidate, isPertinentRoot)) {\n      candidate.setParent(this.getParent());\n      // in q-node first should go empty children, and then full children \n      if (ListSequence.fromList(candidate.getChildren()).first().getState() == PQNode.State.FULL) {\n        candidate.reverse();\n      }\n      candidate.setState(PQNode.State.PARTIAL);\n      return candidate;\n    } else {\n      return null;\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void computeAValue() {\n    super.computeAValue();\n    if (getState() != PQNode.State.PARTIAL) {\n      myAValue = 0;\n      return;\n    }\n    int valueFromA = 0;\n    PQNode aChild = null;\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      int curValue = child.getNumFullLeaves() - child.getAValue();\n      if (valueFromA < curValue) {\n        valueFromA = curValue;\n        aChild = child;\n      }\n    }\n    valueFromA = getNumFullLeaves() - valueFromA;\n    int valueFromH = INF;\n    PQNode firstChild = null;\n    PQNode lastChild = null;\n    PQNode curFirst = null;\n    boolean insideHSegment = false;\n    int numFullLeavesInSegment = 0;\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      if (insideHSegment) {\n        if (child.getState() == PQNode.State.FULL) {\n          numFullLeavesInSegment += child.getNumFullLeaves();\n        } else {\n          int aValue = getNumFullLeaves() - numFullLeavesInSegment - (curFirst.getNumFullLeaves() - curFirst.getHValue()) - (child.getNumFullLeaves() - child.getHValue());\n          if (aValue < valueFromH) {\n            firstChild = curFirst;\n            lastChild = child;\n            valueFromH = aValue;\n          }\n          numFullLeavesInSegment = 0;\n          if (child.getState() == PQNode.State.PARTIAL) {\n            curFirst = child;\n          } else {\n            insideHSegment = false;\n          }\n        }\n      } else {\n        if (child.getState() != PQNode.State.EMPTY) {\n          curFirst = child;\n          insideHSegment = true;\n        }\n      }\n    }\n    // last segment wasn't checked by previous cycle \n    PQNode last = ListSequence.fromList(getChildren()).last();\n    if (insideHSegment && curFirst != last) {\n      int aValue = getNumFullLeaves() - numFullLeavesInSegment - curFirst.getAValue() - last.getAValue();\n      if (aValue < valueFromH) {\n        firstChild = curFirst;\n        lastChild = last;\n        valueFromH = aValue;\n      }\n    }\n    if (valueFromA < valueFromH) {\n      myMakeAFromH = false;\n      myAValue = valueFromA;\n      myFirstAChild = aChild;\n      mySecondAChild = null;\n    } else {\n      myMakeAFromH = true;\n      myAValue = valueFromH;\n      myFirstAChild = firstChild;\n      mySecondAChild = lastChild;\n    }\n    if (myAValue > INF) {\n      myAValue = INF;\n    }\n  }","id":11641,"modified_method":"public void computeAValue() {\n    super.computeAValue();\n    if (getState() != PQNode.State.PARTIAL) {\n      myAValue = 0;\n      return;\n    }\n    int valueFromA = 0;\n    PQNode aChild = null;\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      int curValue = child.getNumFullLeaves() - child.getAValue();\n      if (valueFromA < curValue) {\n        valueFromA = curValue;\n        aChild = child;\n      }\n    }\n    valueFromA = getNumFullLeaves() - valueFromA;\n    int valueFromH = INF;\n    PQNode firstChild = null;\n    PQNode lastChild = null;\n    PQNode curFirst = null;\n    boolean insideHSegment = false;\n    int numFullLeavesInSegment = 0;\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      if (insideHSegment) {\n        if (child.getState() == PQNode.State.FULL) {\n          numFullLeavesInSegment += child.getNumFullLeaves();\n        } else {\n          int aValue = getNumFullLeaves() - numFullLeavesInSegment - (curFirst.getNumFullLeaves() - curFirst.getHValue()) - (child.getNumFullLeaves() - child.getHValue());\n          if (aValue < valueFromH) {\n            firstChild = curFirst;\n            lastChild = child;\n            valueFromH = aValue;\n          }\n          numFullLeavesInSegment = 0;\n          if (child.getState() == PQNode.State.PARTIAL) {\n            curFirst = child;\n          } else {\n            insideHSegment = false;\n          }\n        }\n      } else {\n        if (child.getState() != PQNode.State.EMPTY) {\n          curFirst = child;\n          insideHSegment = true;\n        }\n      }\n    }\n    // last segment wasn't checked by previous cycle \n    PQNode last = ListSequence.fromList(getChildren()).last();\n    if (insideHSegment && curFirst != last) {\n      int aValue = getNumFullLeaves() - numFullLeavesInSegment - curFirst.getAValue() - last.getAValue();\n      if (aValue < valueFromH) {\n        firstChild = curFirst;\n        lastChild = last;\n        valueFromH = aValue;\n      }\n    }\n    if (valueFromA <= valueFromH) {\n      myMakeAFromH = false;\n      myAValue = valueFromA;\n      myFirstAChild = aChild;\n      mySecondAChild = null;\n    } else {\n      myMakeAFromH = true;\n      myAValue = valueFromH;\n      myFirstAChild = firstChild;\n      mySecondAChild = lastChild;\n    }\n    if (myAValue > INF) {\n      myAValue = INF;\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void makeHDeletion() {\n    if (getState() != PQNode.State.PARTIAL) {\n      return;\n    }\n    boolean isToDelete;\n    if (myMakeHLeft) {\n      isToDelete = false;\n    } else {\n      isToDelete = true;\n    }\n    for (PQNode child : ListSequence.fromList(getChildren())) {\n      if (child == myHChild) {\n        child.makeHDeletion();\n        isToDelete = !(isToDelete);\n      } else {\n        if (isToDelete) {\n          child.makeEmpty();\n        }\n      }\n    }\n  }","id":11642,"modified_method":"public void makeHDeletion() {\n    if (getState() != PQNode.State.PARTIAL) {\n      return;\n    }\n    boolean isToDelete;\n    if (myMakeHLeft) {\n      isToDelete = false;\n    } else {\n      isToDelete = true;\n    }\n    Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();\n    while (childItr.hasNext()) {\n      PQNode child = childItr.next();\n      if (child == myHChild) {\n        child.makeHDeletion();\n        isToDelete = !(isToDelete);\n      } else {\n        if (isToDelete) {\n          if (child.makeEmpty() == null) {\n            childItr.remove();\n          }\n        }\n      }\n    }\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void reverse() {\n    myChildren = ListSequence.fromList(myChildren).reversedList();\n    Set<Node> parentNodes = SetSequence.fromSet(new HashSet<Node>());\n    SetSequence.fromSet(parentNodes).addSequence(SetSequence.fromSet(getParent().getGraphNodes()).select(new ISelector<NodeWithInEdgeOrder, Node>() {\n      public Node select(NodeWithInEdgeOrder it) {\n        return it.getNode();\n      }\n    }));\n    for (NodeWithInEdgeOrder graphNode : SetSequence.fromSet(getGraphNodes())) {\n      if (!(SetSequence.fromSet(parentNodes).contains(graphNode.getNode()))) {\n        graphNode.reverse();\n      }\n    }\n  }","id":11643,"modified_method":"public void reverse() {\n    myChildren = ListSequence.fromList(myChildren).reversedList();\n    getEdgesOrder().reverse();\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public QNode() {\n  }","id":11644,"modified_method":"public QNode() {\n    super();\n    myEdgesOrder = new EdgesOrder();\n  }","commit_id":"f5454d295b00f9889a0971fbff7d208c3832f9ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String formatMinutesDuration(int minutes) {\n\t\tif (minutes < 60) {\n\t\t\treturn String.valueOf(minutes);\n\t\t} else {\n\t\t\tString min;\n\t\t\tif (minutes % 60 < 10) {\n\t\t\t\tmin = \"0\" + (minutes % 60);\n\t\t\t} else {\n\t\t\t\tmin = (minutes % 60) + \"\";\n\t\t\t}\n\t\t\tint hours = minutes / 60;\n\t\t\treturn hours + \":\" + min;\n\t\t}\n\t}","id":11645,"modified_method":"public static String formatMinutesDuration(int minutes) {\n\t\tif (minutes < 60) {\n\t\t\treturn String.valueOf(minutes);\n\t\t} else {\n\t\t\tint min = minutes % 60;\n\t\t\tint hours = minutes / 60;\n\t\t\treturn String.format(\"%02d:%02d\", hours, min);\n\t\t}\n\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private View getView(final int position) {\n\t\t\tfinal View view = LayoutInflater.from(linearLayout.getContext())\n\t\t\t\t\t.inflate(R.layout.open_time_list_item, null, false);\n\n\t\t\tImageView clockIconImageView = (ImageView) view.findViewById(R.id.clockIconImageView);\n\t\t\tclockIconImageView.setImageDrawable(clockDrawable);\n\n\t\t\tTextView daysTextView = (TextView) view.findViewById(R.id.daysTextView);\n\t\t\tLinearLayout timeListContainer = (LinearLayout) view.findViewById(R.id.timeListContainer);\n\n\t\t\tif (openingHours.getRules().get(position) instanceof BasicOpeningHourRule) {\n\t\t\t\tfinal OpeningHoursParser.BasicOpeningHourRule rule =\n\t\t\t\t\t\t(BasicOpeningHourRule) openingHours.getRules().get(position);\n\t\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\t\trule.appendDaysString(stringBuilder);\n\n\t\t\t\tdaysTextView.setText(stringBuilder.toString());\n\t\t\t\tdaysTextView.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tOpeningHoursDaysDialogFragment fragment =\n\t\t\t\t\t\t\t\tOpeningHoursDaysDialogFragment.createInstance(rule, position);\n\t\t\t\t\t\tfragment.show(getChildFragmentManager(), \"OpenTimeDialogFragment\");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tTIntArrayList startTimes = rule.getStartTimes();\n\t\t\t\tTIntArrayList endTimes = rule.getEndTimes();\n\t\t\t\tfor (int i = 0; i < startTimes.size(); i++) {\n\t\t\t\t\tView timeFromToLayout = LayoutInflater.from(linearLayout.getContext())\n\t\t\t\t\t\t\t.inflate(R.layout.time_from_to_layout, timeListContainer, false);\n\t\t\t\t\tTextView openingTextView =\n\t\t\t\t\t\t\t(TextView) timeFromToLayout.findViewById(R.id.openingTextView);\n\t\t\t\t\topeningTextView.setText(Algorithms.formatMinutesDuration(startTimes.get(i)));\n\n\t\t\t\t\tTextView closingTextView =\n\t\t\t\t\t\t\t(TextView) timeFromToLayout.findViewById(R.id.closingTextView);\n\t\t\t\t\tclosingTextView.setText(Algorithms.formatMinutesDuration(endTimes.get(i)));\n\n\t\t\t\t\topeningTextView.setTag(i);\n\t\t\t\t\topeningTextView.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tint index = (int) v.getTag();\n\t\t\t\t\t\t\tOpeningHoursHoursDialogFragment.createInstance(rule, position, true, index)\n\t\t\t\t\t\t\t\t\t.show(getChildFragmentManager(), \"OpeningHoursHoursDialogFragment\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tclosingTextView.setTag(i);\n\t\t\t\t\tclosingTextView.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tint index = (int) v.getTag();\n\t\t\t\t\t\t\tOpeningHoursHoursDialogFragment.createInstance(rule, position, false, index)\n\t\t\t\t\t\t\t\t\t.show(getChildFragmentManager(), \"OpeningHoursHoursDialogFragment\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ttimeListContainer.addView(timeFromToLayout);\n\t\t\t\t}\n\t\t\t} else if (openingHours.getRules().get(position) instanceof OpeningHoursParser.UnparseableRule) {\n\t\t\t\tdaysTextView.setText(openingHours.getRules().get(position).toRuleString(false));\n\t\t\t\ttimeListContainer.removeAllViews();\n\t\t\t}\n\n\t\t\tImageButton deleteItemImageButton = (ImageButton) view.findViewById(R.id.deleteItemImageButton);\n\t\t\tdeleteItemImageButton.setImageDrawable(deleteDrawable);\n\t\t\tdeleteItemImageButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\topeningHours.getRules().remove(position);\n\t\t\t\t\tupdateViews();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn view;\n\t\t}","id":11646,"modified_method":"private View getView(final int position) {\n\t\t\tfinal View view = LayoutInflater.from(linearLayout.getContext())\n\t\t\t\t\t.inflate(R.layout.open_time_list_item, null, false);\n\n\t\t\tImageView clockIconImageView = (ImageView) view.findViewById(R.id.clockIconImageView);\n\t\t\tclockIconImageView.setImageDrawable(clockDrawable);\n\n\t\t\tTextView daysTextView = (TextView) view.findViewById(R.id.daysTextView);\n\t\t\tLinearLayout timeListContainer = (LinearLayout) view.findViewById(R.id.timeListContainer);\n\n\t\t\tImageButton deleteItemImageButton = (ImageButton) view.findViewById(R.id.deleteItemImageButton);\n\n\t\t\tif (openingHours.getRules().get(position) instanceof BasicOpeningHourRule) {\n\t\t\t\tfinal OpeningHoursParser.BasicOpeningHourRule rule =\n\t\t\t\t\t\t(BasicOpeningHourRule) openingHours.getRules().get(position);\n\t\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\t\trule.appendDaysString(stringBuilder);\n\n\t\t\t\tdaysTextView.setText(stringBuilder.toString());\n\t\t\t\tdaysTextView.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tOpeningHoursDaysDialogFragment fragment =\n\t\t\t\t\t\t\t\tOpeningHoursDaysDialogFragment.createInstance(rule, position);\n\t\t\t\t\t\tfragment.show(getChildFragmentManager(), \"OpenTimeDialogFragment\");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tfinal TIntArrayList startTimes = rule.getStartTimes();\n\t\t\t\tfinal TIntArrayList endTimes = rule.getEndTimes();\n\t\t\t\tfor (int i = 0; i < startTimes.size(); i++) {\n\t\t\t\t\tView timeFromToLayout = LayoutInflater.from(linearLayout.getContext())\n\t\t\t\t\t\t\t.inflate(R.layout.time_from_to_layout, timeListContainer, false);\n\t\t\t\t\tTextView openingTextView =\n\t\t\t\t\t\t\t(TextView) timeFromToLayout.findViewById(R.id.openingTextView);\n\t\t\t\t\topeningTextView.setText(Algorithms.formatMinutesDuration(startTimes.get(i)));\n\n\t\t\t\t\tTextView closingTextView =\n\t\t\t\t\t\t\t(TextView) timeFromToLayout.findViewById(R.id.closingTextView);\n\t\t\t\t\tclosingTextView.setText(Algorithms.formatMinutesDuration(endTimes.get(i)));\n\n\t\t\t\t\topeningTextView.setTag(i);\n\t\t\t\t\topeningTextView.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tint index = (int) v.getTag();\n\t\t\t\t\t\t\tOpeningHoursHoursDialogFragment.createInstance(rule, position, true, index)\n\t\t\t\t\t\t\t\t\t.show(getChildFragmentManager(), \"OpeningHoursHoursDialogFragment\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tclosingTextView.setTag(i);\n\t\t\t\t\tclosingTextView.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tint index = (int) v.getTag();\n\t\t\t\t\t\t\tOpeningHoursHoursDialogFragment.createInstance(rule, position, false, index)\n\t\t\t\t\t\t\t\t\t.show(getChildFragmentManager(), \"OpeningHoursHoursDialogFragment\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tImageButton deleteTimespanImageButton = (ImageButton) timeFromToLayout\n\t\t\t\t\t\t\t.findViewById(R.id.deleteTimespanImageButton);\n\t\t\t\t\tdeleteTimespanImageButton.setImageDrawable(deleteDrawable);\n\t\t\t\t\tfinal int timespanPosition = i;\n\t\t\t\t\tdeleteTimespanImageButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tif (startTimes.size() == 1) {\n\t\t\t\t\t\t\t\topeningHours.getRules().remove(position);\n\t\t\t\t\t\t\t\tupdateViews();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trule.deleteTimeRange(timespanPosition);\n\t\t\t\t\t\t\t\tupdateViews();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ttimeListContainer.addView(timeFromToLayout);\n\t\t\t\t}\n\n\t\t\t\tdeleteItemImageButton.setVisibility(View.GONE);\n\t\t\t} else if (openingHours.getRules().get(position) instanceof OpeningHoursParser.UnparseableRule) {\n\t\t\t\tdaysTextView.setText(openingHours.getRules().get(position).toRuleString(false));\n\t\t\t\ttimeListContainer.removeAllViews();\n\n\t\t\t\tdeleteItemImageButton.setVisibility(View.VISIBLE);\n\t\t\t\tdeleteItemImageButton.setImageDrawable(deleteDrawable);\n\t\t\t\tdeleteItemImageButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\topeningHours.getRules().remove(position);\n\t\t\t\t\t\tupdateViews();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn view;\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * get a single start time\n\t\t * @return a single start time\n\t\t */\n\t\tpublic int getStartTime() {\n\t\t\tif(startTimes.length == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn startTimes[0];\n\t\t}","id":11647,"modified_method":"/**\n\t\t * get a single start time\n\t\t * @return a single start time\n\t\t */\n\t\tpublic int getStartTime() {\n\t\t\tif(startTimes.size() == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn startTimes.get(0);\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * Check if this rule says the feature is open at time \"cal\"\n\t\t * @param cal the time to check\n\t\t * @return true if this rule contains the day to check and the start and end times denote it's open\n\t\t * @return true if this rule contains the previous day and an endTime>startTime such that the time to check falls before the endtime\n\t\t * @return false in all other cases, also if only day is wrong\n\t\t */\n\t\t@Override\n\t\tpublic boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {\n\t\t\tint i = cal.get(Calendar.DAY_OF_WEEK);\n\t\t\tint d = (i + 5) % 7;\n\t\t\tint p = d - 1;\n\t\t\tif (p < 0) {\n\t\t\t\tp += 7;\n\t\t\t}\n\t\t\tint time = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE); // Time in minutes\n\t\t\tfor (i = 0; i < startTimes.length; i++) {\n\t\t\t\tint startTime = this.startTimes[i];\n\t\t\t\tint endTime = this.endTimes[i];\n\t\t\t\tif (startTime < endTime || endTime == -1) {\n\t\t\t\t\t// one day working like 10:00-20:00 (not 20:00-04:00)\n\t\t\t\t\tif (days[d] && !checkPrevious) {\n\t\t\t\t\t\tif (time >= startTime && (endTime == -1 || time <= endTime)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// opening_hours includes day wrap like\n\t\t\t\t\t// \"We 20:00-03:00\" or \"We 07:00-07:00\"\n\t\t\t\t\tif (time >= startTime && days[d] && !checkPrevious) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (time < endTime && days[p] && checkPrevious) {\n\t\t\t\t\t\t// check in previous day\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}","id":11648,"modified_method":"/**\n\t\t * Check if this rule says the feature is open at time \"cal\"\n\t\t * @param cal the time to check\n\t\t * @return true if this rule contains the day to check and the start and end times denote it's open\n\t\t * @return true if this rule contains the previous day and an endTime>startTime such that the time to check falls before the endtime\n\t\t * @return false in all other cases, also if only day is wrong\n\t\t */\n\t\t@Override\n\t\tpublic boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {\n\t\t\tint i = cal.get(Calendar.DAY_OF_WEEK);\n\t\t\tint d = (i + 5) % 7;\n\t\t\tint p = d - 1;\n\t\t\tif (p < 0) {\n\t\t\t\tp += 7;\n\t\t\t}\n\t\t\tint time = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE); // Time in minutes\n\t\t\tfor (i = 0; i < startTimes.size(); i++) {\n\t\t\t\tint startTime = this.startTimes.get(i);\n\t\t\t\tint endTime = this.endTimes.get(i);\n\t\t\t\tif (startTime < endTime || endTime == -1) {\n\t\t\t\t\t// one day working like 10:00-20:00 (not 20:00-04:00)\n\t\t\t\t\tif (days[d] && !checkPrevious) {\n\t\t\t\t\t\tif (time >= startTime && (endTime == -1 || time <= endTime)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// opening_hours includes day wrap like\n\t\t\t\t\t// \"We 20:00-03:00\" or \"We 07:00-07:00\"\n\t\t\t\t\tif (time >= startTime && days[d] && !checkPrevious) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (time < endTime && days[p] && checkPrevious) {\n\t\t\t\t\t\t// check in previous day\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * get a single end time\n\t\t * @return a single end time\n\t\t */\n\t\tpublic int getEndTime() {\n\t\t\tif(endTimes.length == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn endTimes[0];\n\t\t}","id":11649,"modified_method":"/**\n\t\t * get a single end time\n\t\t * @return a single end time\n\t\t */\n\t\tpublic int getEndTime() {\n\t\t\tif(endTimes.size() == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn endTimes.get(0);\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * Set single end time. If position exceeds index of last item by one\n\t\t * then new value will be added.\n\t\t * If value is between 0 and last index, then value in the position p will be overwritten\n\t\t * with new one.\n\t\t * Else exception will be thrown.\n\t\t * @param s - value\n\t\t * @param position - position to add\n\t\t */\n\t\tpublic void setEndTime(int s, int position) {\n\t\t\tif (position > endTimes.length) {\n\t\t\t\tthrow new IllegalArgumentException(\"It is possible to create only 1 new position.\" +\n\t\t\t\t\t\t\" Size=\" + endTimes.length + \", position=\" + position);\n\t\t\t} else if (position == endTimes.length) {\n\t\t\t\tendTimes = addValueToArray(endTimes, s);\n\t\t\t\tstartTimes = addValueToArray(startTimes, 0);\n\t\t\t} else {\n\t\t\t\tendTimes[position] = s;\n\t\t\t}\n\t\t}","id":11650,"modified_method":"/**\n\t\t * Set single end time. If position exceeds index of last item by one\n\t\t * then new value will be added.\n\t\t * If value is between 0 and last index, then value in the position p will be overwritten\n\t\t * with new one.\n\t\t * Else exception will be thrown.\n\t\t * @param s - value\n\t\t * @param position - position to add\n\t\t */\n\t\tpublic void setEndTime(int s, int position) {\n\t\t\tif (position == startTimes.size()) {\n\t\t\t\tendTimes.add(s);\n\t\t\t\tstartTimes.add(0);\n\t\t\t} else {\n\t\t\t\tendTimes.set(position, s);\n\t\t\t}\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic String toRuleString(boolean avoidMonths) {\n\t\t\tStringBuilder b = new StringBuilder(25);\n\t\t\t// Month\n\t\t\tboolean dash  = false;\n\t\t\tboolean first = true;\n\t\t\tif (!avoidMonths) {\n\t\t\t\tfor (int i = 0; i < 12; i++) {\n\t\t\t\t\tif (months[i]) {\n\t\t\t\t\t\tif (i > 0 && months[i - 1] && i < 11 && months[i + 1]) {\n\t\t\t\t\t\t\tif (!dash) {\n\t\t\t\t\t\t\t\tdash = true;\n\t\t\t\t\t\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else if (!dash) {\n\t\t\t\t\t\t\tb.append(\", \"); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb.append(monthsStr[i]);\n\t\t\t\t\t\tdash = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b.length() != 0) {\n\t\t\t\t\tb.append(\": \");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Day\n\t\t\tboolean open24_7 = true;\n\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\tif (!days[i]) {\n\t\t\t\t\topen24_7 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tappendDaysString(b);\n\t\t\t// Time\n\t\t\tif (startTimes == null || startTimes.length == 0){\n\t\t\t\tb.append(\" off \");\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i<startTimes.length; i++) {\n\t\t\t\t\tint startTime = startTimes[i];\n\t\t\t\t\tint endTime = endTimes[i];\n\t\t\t\t\tif (open24_7 && startTime == 0 && endTime / 60 == 24) {\n\t\t\t\t\t\treturn \"24/7\";\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\tint stHour = startTime / 60;\n\t\t\t\t\tint stTime = startTime - stHour * 60;\n\t\t\t\t\tint enHour = endTime / 60;\n\t\t\t\t\tint enTime = endTime - enHour * 60;\n\t\t\t\t\tformatTime(stHour, stTime, b);\n\t\t\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\t\t\tformatTime(enHour, enTime, b);\n\t\t\t\t\tb.append(\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b.substring(0, b.length()-1);\n\t\t}","id":11651,"modified_method":"@Override\n\t\tpublic String toRuleString(boolean avoidMonths) {\n\t\t\tStringBuilder b = new StringBuilder(25);\n\t\t\t// Month\n\t\t\tboolean dash  = false;\n\t\t\tboolean first = true;\n\t\t\tif (!avoidMonths) {\n\t\t\t\tfor (int i = 0; i < 12; i++) {\n\t\t\t\t\tif (months[i]) {\n\t\t\t\t\t\tif (i > 0 && months[i - 1] && i < 11 && months[i + 1]) {\n\t\t\t\t\t\t\tif (!dash) {\n\t\t\t\t\t\t\t\tdash = true;\n\t\t\t\t\t\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else if (!dash) {\n\t\t\t\t\t\t\tb.append(\", \"); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb.append(monthsStr[i]);\n\t\t\t\t\t\tdash = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b.length() != 0) {\n\t\t\t\t\tb.append(\": \");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Day\n\t\t\tboolean open24_7 = true;\n\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\tif (!days[i]) {\n\t\t\t\t\topen24_7 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tappendDaysString(b);\n\t\t\t// Time\n\t\t\tif (startTimes == null || startTimes.size() == 0){\n\t\t\t\tb.append(\" off \");\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i<startTimes.size(); i++) {\n\t\t\t\t\tint startTime = startTimes.get(i);\n\t\t\t\t\tint endTime = endTimes.get(i);\n\t\t\t\t\tif (open24_7 && startTime == 0 && endTime / 60 == 24) {\n\t\t\t\t\t\treturn \"24/7\";\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\tint stHour = startTime / 60;\n\t\t\t\t\tint stTime = startTime - stHour * 60;\n\t\t\t\t\tint enHour = endTime / 60;\n\t\t\t\t\tint enTime = endTime - enHour * 60;\n\t\t\t\t\tformatTime(stHour, stTime, b);\n\t\t\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\t\t\tformatTime(enHour, enTime, b);\n\t\t\t\t\tb.append(\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b.substring(0, b.length()-1);\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * Set single start time. If position exceeds index of last item by one\n\t\t * then new value will be added.\n\t\t * If value is between 0 and last index, then value in the position p will be overwritten\n\t\t * with new one.\n\t\t * Else exception will be thrown.\n\t\t * @param s - value\n\t\t * @param position - position to add\n\t\t */\n\t\tpublic void setStartTime(int s, int position) {\n\t\t\tif (position > startTimes.length) {\n\t\t\t\tthrow new IllegalArgumentException(\"It is possible to only create 1 new \" +\n\t\t\t\t\t\t\"position. Size=\" + startTimes.length + \", position=\" + position);\n\t\t\t} else if (position == startTimes.length) {\n\t\t\t\tstartTimes = addValueToArray(startTimes, s);\n\t\t\t\tendTimes = addValueToArray(endTimes, 0);\n\t\t\t} else {\n\t\t\t\tstartTimes[position] = s;\n\t\t\t}\n\t\t}","id":11652,"modified_method":"/**\n\t\t * Set single start time. If position exceeds index of last item by one\n\t\t * then new value will be added.\n\t\t * If value is between 0 and last index, then value in the position p will be overwritten\n\t\t * with new one.\n\t\t * Else exception will be thrown.\n\t\t * @param s - value\n\t\t * @param position - position to add\n\t\t */\n\t\tpublic void setStartTime(int s, int position) {\n\t\t\tif (position == startTimes.size()) {\n\t\t\t\tstartTimes.add(s);\n\t\t\t\tendTimes.add(0);\n\t\t\t} else {\n\t\t\t\tstartTimes.set(position, s);\n\t\t\t}\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * get a single start time in position\n\t\t * @param position position to get value from\n\t\t * @return a single start time\n\t\t */\n\t\tpublic int getStartTime(int position) {\n\t\t\treturn startTimes[position];\n\t\t}","id":11653,"modified_method":"/**\n\t\t * get a single start time in position\n\t\t * @param position position to get value from\n\t\t * @return a single start time\n\t\t */\n\t\tpublic int getStartTime(int position) {\n\t\t\treturn startTimes.get(position);\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * Add a time range (startTime-endTime) to this rule\n\t\t * @param startTime startTime to add\n\t\t * @param endTime endTime to add\n\t\t */\n\t\tpublic void addTimeRange(int startTime, int endTime) {\n\t\t\tint l = startTimes.length;\n\t\t\tint[] newStartTimes = new int[l + 1];\n\t\t\tint[] newEndTimes   = new int[l + 1];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tnewStartTimes[i] = startTimes[i];\n\t\t\t\tnewEndTimes[i]   = endTimes[i];\n\t\t\t}\n\t\t\tnewStartTimes[l] = startTime;\n\t\t\tnewEndTimes[l]   = endTime;\n\n\t\t\tstartTimes = newStartTimes;\n\t\t\tendTimes   = newEndTimes;\n\t\t}","id":11654,"modified_method":"/**\n\t\t * Add a time range (startTime-endTime) to this rule\n\t\t * @param startTime startTime to add\n\t\t * @param endTime endTime to add\n\t\t */\n\t\tpublic void addTimeRange(int startTime, int endTime) {\n\t\t\tstartTimes.add(startTime);\n\t\t\tendTimes.add(endTime);\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * set a single start time, erase all previously added start times\n\t\t * @param s startTime to set\n\t\t */\n\t\tpublic void setStartTime(int s) {\n\t\t\tstartTimes = new int[]{s};\n\t\t\tif(endTimes.length != 1) {\n\t\t\t\tendTimes = new int[]{0};\n\t\t\t}\n\t\t}","id":11655,"modified_method":"/**\n\t\t * set a single start time, erase all previously added start times\n\t\t * @param s startTime to set\n\t\t */\n\t\tpublic void setStartTime(int s) {\n\t\t\tsetSingleValueForArrayList(startTimes, s);\n\t\t\tif(endTimes.size() != 1) {\n\t\t\t\tsetSingleValueForArrayList(endTimes, 0);\n\t\t\t}\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * get a single end time in position\n\t\t * @param position position to get value from\n\t\t * @return a single end time\n\t\t */\n\t\tpublic int getEndTime(int position) {\n\t\t\treturn endTimes[position];\n\t\t}","id":11656,"modified_method":"/**\n\t\t * get a single end time in position\n\t\t * @param position position to get value from\n\t\t * @return a single end time\n\t\t */\n\t\tpublic int getEndTime(int position) {\n\t\t\treturn endTimes.get(position);\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t\t * set a single end time, erase all previously added end times\n\t\t * @param e endTime to set\n\t\t */\n\t\tpublic void setEndTime(int e) {\n\t\t\tendTimes = new int[]{e};\n\t\t\tif(startTimes.length != 1) {\n\t\t\t\tstartTimes = new int[]{0};\n\t\t\t}\n\t\t}","id":11657,"modified_method":"/**\n\t\t * set a single end time, erase all previously added end times\n\t\t * @param e endTime to set\n\t\t */\n\t\tpublic void setEndTime(int e) {\n\t\t\tsetSingleValueForArrayList(endTimes, e);\n\t\t\tif(startTimes.size() != 1) {\n\t\t\t\tsetSingleValueForArrayList(startTimes, 0);\n\t\t\t}\n\t\t}","commit_id":"072e23cd2da6c2008012ca5861e76fef0cc2fdeb","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private static List<ConfigItem> generateConfig(CreateIpAliasCommand cmd) {\n        LinkedList<ConfigItem> cfg = new LinkedList<>();\n\n        List<IpAliasTO> ipAliasTOs = cmd.getIpAliasList();\n        String args = \"\";\n        for (IpAliasTO ipaliasto : ipAliasTOs) {\n            args = args + ipaliasto.getAlias_count() + \":\" + ipaliasto.getRouterip() + \":\" + ipaliasto.getNetmask() + \"-\";\n        }\n\n        cfg.add(new ScriptConfigItem(VRScripts.IPALIAS_CREATE, args));\n        return cfg;\n    }","id":11658,"modified_method":"private static List<ConfigItem> generateConfig(CreateIpAliasCommand cmd) {\n        LinkedList<ConfigItem> cfg = new LinkedList<>();\n\n        List<IpAliasTO> ipAliasTOs = cmd.getIpAliasList();\n        StringBuilder args = new StringBuilder();\n        for (IpAliasTO ipaliasto : ipAliasTOs) {\n            args.append(ipaliasto.getAlias_count());\n            args.append(':');\n            args.append(ipaliasto.getRouterip());\n            args.append(':');\n            args.append(ipaliasto.getNetmask());\n            args.append('-');\n        }\n        cfg.add(new ScriptConfigItem(VRScripts.IPALIAS_CREATE, args.toString()));\n        return cfg;\n    }","commit_id":"70e68be4f32538b7965e916cce1f51334fadbbd5","url":"https://github.com/apache/cloudstack"},{"original_method":"private static List<ConfigItem> generateConfig(VmDataCommand cmd) {\n        LinkedList<ConfigItem> cfg = new LinkedList<>();\n        Map<String, List<String[]>> data = new HashMap<String, List<String[]>>();\n        data.put(cmd.getVmIpAddress(), cmd.getVmData());\n\n        String json = new Gson().toJson(data);\n\n        json = Base64.encodeBase64String(json.getBytes());\n\n        String args = \"-d \" + json;\n\n        cfg.add(new ScriptConfigItem(VRScripts.VMDATA, args));\n        return cfg;\n    }","id":11659,"modified_method":"private static List<ConfigItem> generateConfig(VmDataCommand cmd) {\n        LinkedList<ConfigItem> cfg = new LinkedList<>();\n        Map<String, List<String[]>> data = new HashMap<String, List<String[]>>();\n        data.put(cmd.getVmIpAddress(), cmd.getVmData());\n\n        String json = new Gson().toJson(data);\n        String encoded;\n        try {\n            encoded = Base64.encodeBase64String(json.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalArgumentException(\"Unable retrieve UTF-8 encoded data from vmdata\");\n        }\n\n        String args = \"-d \" + encoded;\n\n        cfg.add(new ScriptConfigItem(VRScripts.VMDATA, args));\n        return cfg;\n    }","commit_id":"70e68be4f32538b7965e916cce1f51334fadbbd5","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tif (activityType != FriendsActivityKeys.ADD_FRIEND) {\n\t\t\treturn new Object[0];\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tUser creatorUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getUserId());\n\t\tUser receiverUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getReceiverUserId());\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(HtmlUtil.escapeURL(creatorUser.getScreenName()));\n\t\tsb.append(\"/profile\\\">\");\n\t\tsb.append(creatorUserName);\n\t\tsb.append(\"<\/a>\");\n\n\t\tString creatorUserNameURL = sb.toString();\n\n\t\tsb = new StringBundler(8);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(HtmlUtil.escapeURL(receiverUser.getScreenName()));\n\t\tsb.append(\"/profile\\\">\");\n\t\tsb.append(receiverUserName);\n\t\tsb.append(\"<\/a>\");\n\n\t\tString receiverUserNameURL = sb.toString();\n\n\t\treturn new Object[] {creatorUserNameURL, receiverUserNameURL};\n\t}","id":11660,"modified_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tif (activityType != FriendsActivityKeys.ADD_FRIEND) {\n\t\t\treturn new Object[0];\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tUser creatorUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getUserId());\n\t\tUser receiverUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getReceiverUserId());\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(HtmlUtil.escapeURL(creatorUser.getScreenName()));\n\t\tsb.append(\"/profile\");\n\n\t\tString creatorUserNameURL = wrapLink(sb.toString(), creatorUserName);\n\n\t\tsb = new StringBundler(5);\n\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(HtmlUtil.escapeURL(receiverUser.getScreenName()));\n\t\tsb.append(\"/profile\");\n\n\t\tString receiverUserNameURL = wrapLink(sb.toString(), receiverUserName);\n\n\t\treturn new Object[] {creatorUserNameURL, receiverUserNameURL};\n\t}","commit_id":"39736372fbd47205551e4f8ae56017ab55fb8e1e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tJSONObject extraData = null;\n\n\t\tif (Validator.isNotNull(activity.getExtraData())) {\n\t\t\textraData = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivity.getExtraData());\n\t\t}\n\n\t\tString link = getLink(activity, themeDisplay);\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\" target=\\\"_blank\\\">\");\n\n\t\tif (activityType == JIRAActivityKeys.ADD_CHANGE) {\n\t\t\tsb.append(\n\t\t\t\tinterpretJIRAChangeItems(\n\t\t\t\t\textraData.getJSONArray(\"jiraChangeItems\"), themeDisplay));\n\t\t}\n\t\telse if (activityType == JIRAActivityKeys.ADD_COMMENT) {\n\t\t\tlong jiraActionId = extraData.getLong(\"jiraActionId\");\n\n\t\t\tJIRAAction jiraAction = JIRAActionLocalServiceUtil.getJIRAAction(\n\t\t\t\tjiraActionId);\n\n\t\t\tsb.append(HtmlUtil.escape(jiraAction.getBody()));\n\t\t}\n\t\telse if (activityType == JIRAActivityKeys.ADD_ISSUE) {\n\t\t\tJIRAIssue jiraIssue = JIRAIssueLocalServiceUtil.getJIRAIssue(\n\t\t\t\tactivity.getClassPK());\n\n\t\t\tsb.append(HtmlUtil.escape(jiraIssue.getSummary()));\n\t\t}\n\n\t\tsb.append(\"<\/a>\");\n\n\t\treturn sb.toString();\n\t}","id":11661,"modified_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tJSONObject extraData = null;\n\n\t\tif (Validator.isNotNull(activity.getExtraData())) {\n\t\t\textraData = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivity.getExtraData());\n\t\t}\n\n\t\tString link = getLink(activity, themeDisplay);\n\n\t\tString text = StringPool.BLANK;\n\n\t\tif (activityType == JIRAActivityKeys.ADD_CHANGE) {\n\t\t\ttext = interpretJIRAChangeItems(\n\t\t\t\textraData.getJSONArray(\"jiraChangeItems\"), themeDisplay);\n\t\t}\n\t\telse if (activityType == JIRAActivityKeys.ADD_COMMENT) {\n\t\t\tlong jiraActionId = extraData.getLong(\"jiraActionId\");\n\n\t\t\tJIRAAction jiraAction = JIRAActionLocalServiceUtil.getJIRAAction(\n\t\t\t\tjiraActionId);\n\n\t\t\ttext = HtmlUtil.escape(jiraAction.getBody());\n\t\t}\n\t\telse if (activityType == JIRAActivityKeys.ADD_ISSUE) {\n\t\t\tJIRAIssue jiraIssue = JIRAIssueLocalServiceUtil.getJIRAIssue(\n\t\t\t\tactivity.getClassPK());\n\n\t\t\ttext = HtmlUtil.escape(jiraIssue.getSummary());\n\t\t}\n\n\t\treturn wrapLink(link, text);\n\t}","commit_id":"39736372fbd47205551e4f8ae56017ab55fb8e1e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tif (activityType != MembersActivityKeys.ADD_MEMBER) {\n\t\t\treturn new Object[0];\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\");\n\t\tsb.append(creatorUserName);\n\t\tsb.append(\"<\/a>\");\n\n\t\tString creatorUserNameURL = sb.toString();\n\n\t\tOrganization organization =\n\t\t\tOrganizationLocalServiceUtil.getOrganization(activity.getClassPK());\n\n\t\tGroup group = organization.getGroup();\n\n\t\tsb = new StringBundler(7);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(group.getFriendlyURL());\n\t\tsb.append(\"/profile\\\">\");\n\t\tsb.append(HtmlUtil.escape(organization.getName()));\n\t\tsb.append(\"<\/a>\");\n\n\t\tString organizationNameURL = sb.toString();\n\n\t\treturn new Object[] {creatorUserNameURL, organizationNameURL};\n\t}","id":11662,"modified_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tif (activityType != MembersActivityKeys.ADD_MEMBER) {\n\t\t\treturn new Object[0];\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tString creatorUserNameURL = wrapLink(\n\t\t\tgetLink(activity, themeDisplay), creatorUserName);\n\n\t\tOrganization organization =\n\t\t\tOrganizationLocalServiceUtil.getOrganization(activity.getClassPK());\n\n\t\tGroup group = organization.getGroup();\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(group.getFriendlyURL());\n\t\tsb.append(\"/profile\");\n\n\t\tString organizationNameURL = wrapLink(\n\t\t\tsb.toString(), HtmlUtil.escape(organization.getName()));\n\n\t\treturn new Object[] {creatorUserNameURL, organizationNameURL};\n\t}","commit_id":"39736372fbd47205551e4f8ae56017ab55fb8e1e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\t\tthrows Exception {\n\n\t\tString link = getLink(activity, themeDisplay);\n\n\t\tSVNRevision svnRevision = SVNRevisionLocalServiceUtil.getSVNRevision(\n\t\t\tactivity.getClassPK());\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\" target=\\\"_blank\\\">\");\n\t\tsb.append(HtmlUtil.escape(svnRevision.getComments()));\n\t\tsb.append(\"<\/a>\");\n\n\t\treturn sb.toString();\n\t}","id":11663,"modified_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\t\tthrows Exception {\n\n\t\tString link = getLink(activity, themeDisplay);\n\n\t\tSVNRevision svnRevision = SVNRevisionLocalServiceUtil.getSVNRevision(\n\t\t\tactivity.getClassPK());\n\n\t\treturn wrapLink(link, HtmlUtil.escape(svnRevision.getComments()));\n\t}","commit_id":"39736372fbd47205551e4f8ae56017ab55fb8e1e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tUser creatorUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getUserId());\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(HtmlUtil.escapeURL(creatorUser.getScreenName()));\n\t\tsb.append(\"/profile\\\">\");\n\t\tsb.append(creatorUserName);\n\t\tsb.append(\"<\/a>\");\n\n\t\tString creatorUserNameURL = sb.toString();\n\n\t\treturn new Object[] {creatorUserNameURL};\n\t}","id":11664,"modified_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tUser creatorUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getUserId());\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(themeDisplay.getPortalURL());\n\t\tsb.append(themeDisplay.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(HtmlUtil.escapeURL(creatorUser.getScreenName()));\n\t\tsb.append(\"/profile\");\n\n\t\tString creatorUserNameURL = wrapLink(sb.toString(), creatorUserName);\n\n\t\treturn new Object[] {creatorUserNameURL};\n\t}","commit_id":"39736372fbd47205551e4f8ae56017ab55fb8e1e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tUser creatorUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getUserId());\n\n\t\tJSONObject extraData = JSONFactoryUtil.createJSONObject(\n\t\t\tactivity.getExtraData());\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tsb.append(\"<a href=\\\"http://twitter.com/\");\n\t\tsb.append(HtmlUtil.escapeURL(creatorUser.getContact().getTwitterSn()));\n\t\tsb.append(\"/statuses/\");\n\t\tsb.append(activity.getClassPK());\n\t\tsb.append(\"\\\" target=\\\"_blank\\\">\");\n\t\tsb.append(HtmlUtil.escape(extraData.getString(\"text\")));\n\t\tsb.append(\"<\/a>\");\n\n\t\treturn sb.toString();\n\t}","id":11665,"modified_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tUser creatorUser = UserLocalServiceUtil.getUserById(\n\t\t\tactivity.getUserId());\n\n\t\tJSONObject extraData = JSONFactoryUtil.createJSONObject(\n\t\t\tactivity.getExtraData());\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(\"http://twitter.com/\");\n\t\tsb.append(HtmlUtil.escapeURL(creatorUser.getContact().getTwitterSn()));\n\t\tsb.append(\"/statuses/\");\n\t\tsb.append(activity.getClassPK());\n\n\t\treturn wrapLink(\n\t\t\tsb.toString(), HtmlUtil.escape(extraData.getString(\"text\")));\n\t}","commit_id":"39736372fbd47205551e4f8ae56017ab55fb8e1e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString link = getLink(activity, themeDisplay);\n\n\t\tWallEntry wallEntry = WallEntryLocalServiceUtil.getWallEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString entryComments = getValue(\n\t\t\tactivity.getExtraData(), \"comments\", wallEntry.getComments());\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\");\n\t\tsb.append(entryComments);\n\t\tsb.append(\"<\/a>\");\n\n\t\treturn sb.toString();\n\t}","id":11666,"modified_method":"@Override\n\tprotected String getBody(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tWallEntry wallEntry = WallEntryLocalServiceUtil.getWallEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString entryComments = getValue(\n\t\t\tactivity.getExtraData(), \"comments\", wallEntry.getComments());\n\n\t\tString link = getLink(activity, themeDisplay);\n\n\t\treturn wrapLink(link, entryComments);\n\t}","commit_id":"39736372fbd47205551e4f8ae56017ab55fb8e1e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public String getUserName(long userId, ThemeDisplay themeDisplay) {\n\t\ttry {\n\t\t\tif (userId <= 0) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\tif (user.getUserId() == themeDisplay.getUserId()) {\n\t\t\t\treturn user.getFirstName();\n\t\t\t}\n\n\t\t\tString userName = user.getFullName();\n\n\t\t\tGroup group = user.getGroup();\n\n\t\t\tif (group.getGroupId() == themeDisplay.getScopeGroupId()) {\n\t\t\t\treturn userName;\n\t\t\t}\n\n\t\t\tString userDisplayURL = user.getDisplayURL(themeDisplay);\n\n\t\t\tuserName =\n\t\t\t\t\"<a class=\\\"user\\\" href=\\\"\" + userDisplayURL + \"\\\">\" +\n\t\t\t\t\tuserName + \"<\/a>\";\n\n\t\t\treturn userName;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","id":11667,"modified_method":"protected String getUserName(long userId, ThemeDisplay themeDisplay) {\n\t\ttry {\n\t\t\tif (userId <= 0) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\tif (user.getUserId() == themeDisplay.getUserId()) {\n\t\t\t\treturn user.getFirstName();\n\t\t\t}\n\n\t\t\tString userName = user.getFullName();\n\n\t\t\tGroup group = user.getGroup();\n\n\t\t\tif (group.getGroupId() == themeDisplay.getScopeGroupId()) {\n\t\t\t\treturn userName;\n\t\t\t}\n\n\t\t\tString userDisplayURL = user.getDisplayURL(themeDisplay);\n\n\t\t\tuserName =\n\t\t\t\t\"<a class=\\\"user\\\" href=\\\"\" + userDisplayURL + \"\\\">\" +\n\t\t\t\t\tuserName + \"<\/a>\";\n\n\t\t\treturn userName;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getGroupName(long groupId, ThemeDisplay themeDisplay) {\n\t\ttry {\n\t\t\tif (groupId <= 0) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tString groupName = group.getDescriptiveName();\n\n\t\t\tif ((group.getGroupId() == themeDisplay.getScopeGroupId()) ||\n\t\t\t\t!group.hasPublicLayouts()) {\n\n\t\t\t\treturn groupName;\n\t\t\t}\n\n\t\t\tString groupDisplayURL =\n\t\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\t\"/my_places/view?groupId=\" +  group.getGroupId() +\n\t\t\t\t\t\t\"&privateLayout=0\";\n\n\t\t\tgroupName =\n\t\t\t\t\"<a class=\\\"group\\\" href=\\\"\" + groupDisplayURL + \"\\\">\" +\n\t\t\t\t\tgroupName + \"<\/a>\";\n\n\t\t\treturn groupName;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","id":11668,"modified_method":"protected String getGroupName(long groupId, ThemeDisplay themeDisplay) {\n\t\ttry {\n\t\t\tif (groupId <= 0) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tString groupName = group.getDescriptiveName();\n\n\t\t\tif ((group.getGroupId() == themeDisplay.getScopeGroupId()) ||\n\t\t\t\t!group.hasPublicLayouts()) {\n\n\t\t\t\treturn groupName;\n\t\t\t}\n\n\t\t\tString groupDisplayURL =\n\t\t\t\tthemeDisplay.getPortalURL() + themeDisplay.getPathMain() +\n\t\t\t\t\t\"/my_places/view?groupId=\" +  group.getGroupId() +\n\t\t\t\t\t\t\"&privateLayout=0\";\n\n\t\t\tgroupName =\n\t\t\t\t\"<a class=\\\"group\\\" href=\\\"\" + groupDisplayURL + \"\\\">\" +\n\t\t\t\t\tgroupName + \"<\/a>\";\n\n\t\t\treturn groupName;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String cleanContent(String content) {\n\t\treturn StringUtil.shorten(HtmlUtil.extractText(content), 200);\n\t}","id":11669,"modified_method":"protected String cleanContent(String content) {\n\t\treturn StringUtil.shorten(HtmlUtil.extractText(content), 200);\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BlogsEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\tJSONObject extraData = null;\n\n\t\tif (Validator.isNotNull(activity.getExtraData())) {\n\t\t\textraData = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivity.getExtraData());\n\t\t}\n\n\t\t// Link\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/blogs/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == BlogsActivityKeys.ADD_COMMENT) {\n\t\t\ttitlePattern = \"activity-blogs-add-comment\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\ttitlePattern = \"activity-blogs-add-entry\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(entry.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString entryTitle = sb.toString();\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, entryTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":11670,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BlogsEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\tJSONObject extraData = null;\n\n\t\tif (Validator.isNotNull(activity.getExtraData())) {\n\t\t\textraData = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivity.getExtraData());\n\t\t}\n\n\t\t// Link\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/blogs/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == BlogsActivityKeys.ADD_COMMENT) {\n\t\t\ttitlePattern = \"activity-blogs-add-comment\";\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\ttitlePattern = \"activity-blogs-add-entry\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tString entryTitle = wrapLink(link, cleanContent(entry.getTitle()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, entryTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!CalEventPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tCalEvent event = CalEventLocalServiceUtil.getEvent(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/calendar/find_event?eventId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == CalendarActivityKeys.ADD_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-add-event\";\n\t\t}\n\t\telse if (activityType == CalendarActivityKeys.UPDATE_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-update-event\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(event.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString eventTitle = sb.toString();\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, eventTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":11671,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!CalEventPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tCalEvent event = CalEventLocalServiceUtil.getEvent(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/calendar/find_event?eventId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == CalendarActivityKeys.ADD_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-add-event\";\n\t\t}\n\t\telse if (activityType == CalendarActivityKeys.UPDATE_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-update-event\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tString eventTitle = wrapLink(link, cleanContent(event.getTitle()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, eventTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tDLFileEntry fileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tif (!DLFileEntryPermission.contains(\n\t\t\t\tpermissionChecker, fileEntry, ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/get_file?folderId=\" +\n\t\t\t\t\tfileEntry.getFolderId() + \"&name=\" + fileEntry.getName();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == DLActivityKeys.ADD_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-add-file\";\n\t\t}\n\t\telse if (activityType == DLActivityKeys.UPDATE_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-update-file\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(fileEntry.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString fileTitle = sb.toString();\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, fileTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":11672,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tDLFileEntry fileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tif (!DLFileEntryPermission.contains(\n\t\t\t\tpermissionChecker, fileEntry, ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/get_file?folderId=\" +\n\t\t\t\t\tfileEntry.getFolderId() + \"&name=\" + fileEntry.getName();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == DLActivityKeys.ADD_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-add-file\";\n\t\t}\n\t\telse if (activityType == DLActivityKeys.UPDATE_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-update-file\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tString fileTitle = wrapLink(link, cleanContent(fileEntry.getTitle()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, fileTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tString fileEntryLink =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/find_file_entry?fileEntryId=\" +\n\t\t\t\t\tfileEntry.getFileEntryId();\n\n\t\tsb.append(wrapLink(fileEntryLink, \"view-document\", themeDisplay));\n\t\tsb.append(StringPool.SPACE);\n\n\t\tString folderLink =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/find_folder?folderId=\" +\n\t\t\t\t\tfileEntry.getFolderId();\n\n\t\tsb.append(wrapLink(folderLink, \"go-to-folder\", themeDisplay));\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!MBMessagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tMBMessage message = MBMessageLocalServiceUtil.getMessage(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/message_boards/find_message?messageId=\" +\n\t\t\t\t\tmessage.getMessageId();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == MBActivityKeys.ADD_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-add-message\";\n\t\t}\n\t\telse if (activityType == MBActivityKeys.REPLY_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(message.getSubject()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString messageSubject = sb.toString();\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, messageSubject\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":11673,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!MBMessagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tMBMessage message = MBMessageLocalServiceUtil.getMessage(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/message_boards/find_message?messageId=\" +\n\t\t\t\t\tmessage.getMessageId();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == MBActivityKeys.ADD_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-add-message\";\n\t\t}\n\t\telse if (activityType == MBActivityKeys.REPLY_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tString messageSubject = wrapLink(\n\t\t\tlink, cleanContent(message.getSubject()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, messageSubject\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString categoryLink =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/message_boards/find_category?categoryId=\" +\n\t\t\t\t\tmessage.getCategoryId();\n\n\t\tString body = wrapLink(categoryLink, \"go-to-category\", themeDisplay);\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!WikiPagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/wiki/find_page?pageResourcePrimKey=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == WikiActivityKeys.ADD_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-add-page\";\n\t\t}\n\t\telse if (activityType == WikiActivityKeys.UPDATE_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-update-page\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(pageResource.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString pageTitle = sb.toString();\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, pageTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":11674,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!WikiPagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/wiki/find_page?pageResourcePrimKey=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == WikiActivityKeys.ADD_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-add-page\";\n\t\t}\n\t\telse if (activityType == WikiActivityKeys.UPDATE_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-update-page\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tString pageTitle = wrapLink(\n\t\t\tlink, cleanContent(pageResource.getTitle()));\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, pageTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"3b9a9f06e013ad3700ca372dade65e9e85f68d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testConcurrentIncrement() throws Exception {\n\t\tString classPath = ClassPathUtil.getJVMClassPath(true);\n\n\t\tif (PropsValues.JDBC_DEFAULT_LIFERAY_POOL_PROVIDER.equals(\"hikaricp\")) {\n\t\t\tString jarName = PropsUtil.get(\n\t\t\t\tPropsKeys.SETUP_LIFERAY_POOL_PROVIDER_JAR_NAME,\n\t\t\t\tnew Filter(\"hikaricp\"));\n\n\t\t\tPath path = Paths.get(PropsValues.LIFERAY_LIB_PORTAL_DIR, jarName);\n\n\t\t\tpath = path.toAbsolutePath();\n\n\t\t\tclassPath = classPath.concat(File.pathSeparator).concat(\n\t\t\t\tpath.toString());\n\t\t}\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setArguments(\n\t\t\tArrays.asList(\"-Xmx1024m\", \"-XX:MaxPermSize=200m\"));\n\t\tbuilder.setBootstrapClassPath(classPath);\n\t\tbuilder.setReactClassLoader(PortalClassLoaderUtil.getClassLoader());\n\t\tbuilder.setRuntimeClassPath(classPath);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tList<Future<Long[]>> futuresList = new ArrayList<>();\n\n\t\tfor (int i = 0; i < _PROCESS_COUNT; i++) {\n\t\t\tProcessCallable<Long[]> processCallable =\n\t\t\t\tnew IncrementProcessCallable(\n\t\t\t\t\t\"Increment Process-\" + i, _COUNTER_NAME, _INCREMENT_COUNT);\n\n\t\t\tProcessChannel<Long[]> processChannel = ProcessExecutorUtil.execute(\n\t\t\t\tprocessConfig, processCallable);\n\n\t\t\tFuture<Long[]> futures =\n\t\t\t\tprocessChannel.getProcessNoticeableFuture();\n\n\t\t\tfuturesList.add(futures);\n\t\t}\n\n\t\tint total = _PROCESS_COUNT * _INCREMENT_COUNT;\n\n\t\tList<Long> ids = new ArrayList<>(total);\n\n\t\tfor (Future<Long[]> futures : futuresList) {\n\t\t\tids.addAll(Arrays.asList(futures.get()));\n\t\t}\n\n\t\tAssert.assertEquals(total, ids.size());\n\n\t\tCollections.sort(ids);\n\n\t\tfor (int i = 0; i < total; i++) {\n\t\t\tLong id = ids.get(i);\n\n\t\t\tAssert.assertEquals(i + 1, id.intValue());\n\t\t}\n\t}","id":11675,"modified_method":"@Test\n\tpublic void testConcurrentIncrement() throws Exception {\n\t\tString classPath = ClassPathUtil.getJVMClassPath(true);\n\n\t\tif (PropsValues.JDBC_DEFAULT_LIFERAY_POOL_PROVIDER.equals(\"hikaricp\")) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(classPath);\n\t\t\tsb.append(File.pathSeparator);\n\t\t\tsb.append(PropsValues.LIFERAY_LIB_PORTAL_DIR);\n\t\t\tsb.append(File.separator);\n\t\t\tsb.append(\n\t\t\t\tPropsUtil.get(\n\t\t\t\t\tPropsKeys.SETUP_LIFERAY_POOL_PROVIDER_JAR_NAME,\n\t\t\t\t\tnew Filter(\"hikaricp\")));\n\n\t\t\tclassPath = sb.toString();\n\t\t}\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setArguments(\n\t\t\tArrays.asList(\"-Xmx1024m\", \"-XX:MaxPermSize=200m\"));\n\t\tbuilder.setBootstrapClassPath(classPath);\n\t\tbuilder.setReactClassLoader(PortalClassLoaderUtil.getClassLoader());\n\t\tbuilder.setRuntimeClassPath(classPath);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tList<Future<Long[]>> futuresList = new ArrayList<>();\n\n\t\tfor (int i = 0; i < _PROCESS_COUNT; i++) {\n\t\t\tProcessCallable<Long[]> processCallable =\n\t\t\t\tnew IncrementProcessCallable(\n\t\t\t\t\t\"Increment Process-\" + i, _COUNTER_NAME, _INCREMENT_COUNT);\n\n\t\t\tProcessChannel<Long[]> processChannel = ProcessExecutorUtil.execute(\n\t\t\t\tprocessConfig, processCallable);\n\n\t\t\tFuture<Long[]> futures =\n\t\t\t\tprocessChannel.getProcessNoticeableFuture();\n\n\t\t\tfuturesList.add(futures);\n\t\t}\n\n\t\tint total = _PROCESS_COUNT * _INCREMENT_COUNT;\n\n\t\tList<Long> ids = new ArrayList<>(total);\n\n\t\tfor (Future<Long[]> futures : futuresList) {\n\t\t\tids.addAll(Arrays.asList(futures.get()));\n\t\t}\n\n\t\tAssert.assertEquals(total, ids.size());\n\n\t\tCollections.sort(ids);\n\n\t\tfor (int i = 0; i < total; i++) {\n\t\t\tLong id = ids.get(i);\n\n\t\t\tAssert.assertEquals(i + 1, id.intValue());\n\t\t}\n\t}","commit_id":"31b226a01541d5249cef50eb5c02a1dc8d3f0d3d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String exportLinksToLayout(\n\t\t\tPortletDataContext portletDataContext, String content)\n\t\tthrows Exception {\n\n\t\tList<String> oldLinksToLayout = new ArrayList<String>();\n\t\tList<String> newLinksToLayout = new ArrayList<String>();\n\n\t\tMatcher matcher = _exportLinksToLayoutPattern.matcher(content);\n\n\t\twhile (matcher.find()) {\n\t\t\tlong layoutId = GetterUtil.getLong(matcher.group(1));\n\n\t\t\tString type = matcher.group(2);\n\n\t\t\tboolean privateLayout = type.startsWith(\"private\");\n\n\t\t\ttry {\n\t\t\t\tLayout layout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), privateLayout,\n\t\t\t\t\tlayoutId);\n\n\t\t\t\tString oldLinkToLayout = matcher.group(0);\n\n\t\t\t\tString newLinkToLayout = StringUtil.replace(\n\t\t\t\t\toldLinkToLayout, type,\n\t\t\t\t\ttype.concat(StringPool.AT.concat(layout.getFriendlyURL())));\n\n\t\t\t\toldLinksToLayout.add(oldLinkToLayout);\n\t\t\t\tnewLinksToLayout.add(newLinkToLayout);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to get layout with id \" + layoutId +\n\t\t\t\t\t\t\t\" in group \" + portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\te);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcontent = StringUtil.replace(\n\t\t\tcontent, ArrayUtil.toStringArray(oldLinksToLayout.toArray()),\n\t\t\tArrayUtil.toStringArray(newLinksToLayout.toArray()));\n\n\t\treturn content;\n\t}","id":11676,"modified_method":"protected static String exportLinksToLayout(\n\t\t\tPortletDataContext portletDataContext, String content)\n\t\tthrows Exception {\n\n\t\tList<String> oldLinksToLayout = new ArrayList<String>();\n\t\tList<String> newLinksToLayout = new ArrayList<String>();\n\n\t\tMatcher matcher = _exportLinksToLayoutPattern.matcher(content);\n\n\t\twhile (matcher.find()) {\n\t\t\tlong layoutId = GetterUtil.getLong(matcher.group(1));\n\n\t\t\tString type = matcher.group(2);\n\n\t\t\tboolean privateLayout = type.startsWith(\"private\");\n\n\t\t\ttry {\n\t\t\t\tLayout layout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), privateLayout,\n\t\t\t\t\tlayoutId);\n\n\t\t\t\tString oldLinkToLayout = matcher.group(0);\n\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(type);\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(layout.getUuid());\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(layout.getFriendlyURL());\n\n\t\t\t\tString newLinkToLayout = StringUtil.replace(\n\t\t\t\t\toldLinkToLayout, type, sb.toString());\n\n\t\t\t\toldLinksToLayout.add(oldLinkToLayout);\n\t\t\t\tnewLinksToLayout.add(newLinkToLayout);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to get layout with id \" + layoutId +\n\t\t\t\t\t\t\t\" in group \" + portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\te);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcontent = StringUtil.replace(\n\t\t\tcontent, ArrayUtil.toStringArray(oldLinksToLayout.toArray()),\n\t\t\tArrayUtil.toStringArray(newLinksToLayout.toArray()));\n\n\t\treturn content;\n\t}","commit_id":"16d37fcdd2110976d23a4f799fc52a931e6da4eb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String importLinksToLayout(\n\t\t\tPortletDataContext portletDataContext, String content)\n\t\tthrows Exception {\n\n\t\tList<String> oldLinksToLayout = new ArrayList<String>();\n\t\tList<String> newLinksToLayout = new ArrayList<String>();\n\n\t\tMatcher matcher = _importLinksToLayoutPattern.matcher(content);\n\n\t\twhile (matcher.find()) {\n\t\t\tString oldLayoutId = matcher.group(1);\n\n\t\t\tString newLayoutId = oldLayoutId;\n\n\t\t\tString type = matcher.group(2);\n\n\t\t\tboolean privateLayout = type.startsWith(\"private\");\n\n\t\t\tString friendlyURL = matcher.group(3);\n\n\t\t\ttry {\n\t\t\t\tLayout layout = LayoutUtil.fetchByG_P_F(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), privateLayout,\n\t\t\t\t\tfriendlyURL);\n\n\t\t\t\tnewLayoutId = String.valueOf(layout.getLayoutId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to get layout with friendly URL \" +\n\t\t\t\t\t\t\tfriendlyURL + \" in group \" +\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\te);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString oldLinkToLayout = matcher.group(0);\n\n\t\t\tString newLinkToLayout = StringUtil.replace(\n\t\t\t\toldLinkToLayout,\n\t\t\t\tnew String[] {StringPool.AT.concat(friendlyURL), oldLayoutId},\n\t\t\t\tnew String[] {StringPool.BLANK, newLayoutId});\n\n\t\t\toldLinksToLayout.add(oldLinkToLayout);\n\t\t\tnewLinksToLayout.add(newLinkToLayout);\n\t\t}\n\n\t\tcontent = StringUtil.replace(\n\t\t\tcontent, ArrayUtil.toStringArray(oldLinksToLayout.toArray()),\n\t\t\tArrayUtil.toStringArray(newLinksToLayout.toArray()));\n\n\t\treturn content;\n\t}","id":11677,"modified_method":"protected static String importLinksToLayout(\n\t\t\tPortletDataContext portletDataContext, String content)\n\t\tthrows Exception {\n\n\t\tList<String> oldLinksToLayout = new ArrayList<String>();\n\t\tList<String> newLinksToLayout = new ArrayList<String>();\n\n\t\tMatcher matcher = _importLinksToLayoutPattern.matcher(content);\n\n\t\twhile (matcher.find()) {\n\t\t\tString oldLayoutId = matcher.group(1);\n\n\t\t\tString newLayoutId = oldLayoutId;\n\n\t\t\tString type = matcher.group(2);\n\n\t\t\tboolean privateLayout = type.startsWith(\"private\");\n\n\t\t\tString layoutUuid = matcher.group(3);\n\n\t\t\tString friendlyURL = matcher.group(4);\n\n\t\t\ttry {\n\t\t\t\tLayout layout = LayoutUtil.fetchByUUID_G(\n\t\t\t\t\tlayoutUuid, portletDataContext.getScopeGroupId());\n\n\t\t\t\tif (layout == null) {\n\t\t\t\t\tlayout = LayoutUtil.fetchByG_P_F(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), privateLayout,\n\t\t\t\t\t\tfriendlyURL);\n\t\t\t\t}\n\n\t\t\t\tif (layout == null) {\n\t\t\t\t\tlayout = LayoutUtil.fetchByG_P_L(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), privateLayout,\n\t\t\t\t\t\tLong.valueOf(oldLayoutId));\n\t\t\t\t}\n\n\t\t\t\tif (layout == null) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"Unable to get layout with UUID \" + layoutUuid +\n\t\t\t\t\t\t\t\t\", friendly URL \" +\tfriendlyURL + \", or \" +\n\t\t\t\t\t\t\t\t\"layoutId \" + oldLayoutId + \" in group \" +\n\t\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewLayoutId = String.valueOf(layout.getLayoutId());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SystemException e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to get layout in group \" +\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString oldLinkToLayout = matcher.group(0);\n\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tsb.append(StringPool.AT);\n\t\t\tsb.append(layoutUuid);\n\t\t\tsb.append(StringPool.AT);\n\t\t\tsb.append(friendlyURL);\n\n\t\t\tString newLinkToLayout = StringUtil.replace(\n\t\t\t\toldLinkToLayout,\n\t\t\t\tnew String[] {sb.toString(), oldLayoutId},\n\t\t\t\tnew String[] {StringPool.BLANK, newLayoutId});\n\n\t\t\toldLinksToLayout.add(oldLinkToLayout);\n\t\t\tnewLinksToLayout.add(newLinkToLayout);\n\t\t}\n\n\t\tcontent = StringUtil.replace(\n\t\t\tcontent, ArrayUtil.toStringArray(oldLinksToLayout.toArray()),\n\t\t\tArrayUtil.toStringArray(newLinksToLayout.toArray()));\n\n\t\treturn content;\n\t}","commit_id":"16d37fcdd2110976d23a4f799fc52a931e6da4eb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Dialect getDialect(DataSource dataSource) {\n\t\tString dialectKey = null;\n\t\tDialect dialect = null;\n\n\t\tConnection connection = null;\n\n\t\ttry {\n\t\t\tconnection = dataSource.getConnection();\n\n\t\t\tDatabaseMetaData databaseMetaData = connection.getMetaData();\n\n\t\t\tString dbName = databaseMetaData.getDatabaseProductName();\n\t\t\tint dbMajorVersion = databaseMetaData.getDatabaseMajorVersion();\n\n\t\t\tdialectKey = dbName.concat(StringPool.COLON).concat(\n\t\t\t\tString.valueOf(dbMajorVersion));\n\n\t\t\tdialect = _dialects.get(dialectKey);\n\n\t\t\tif (dialect != null) {\n\t\t\t\treturn dialect;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Determine dialect for \" + dbName + \" \" + dbMajorVersion);\n\t\t\t}\n\n\t\t\tif (dbName.startsWith(\"HSQL\")) {\n\t\t\t\tdialect = new HSQLDialect();\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\tStringBundler sb = new StringBundler(6);\n\n\t\t\t\t\tsb.append(\"Liferay is configured to use Hypersonic as \");\n\t\t\t\t\tsb.append(\"its database. Do NOT use Hypersonic in \");\n\t\t\t\t\tsb.append(\"production. Hypersonic is an embedded \");\n\t\t\t\t\tsb.append(\"database useful for development and demo'ing \");\n\t\t\t\t\tsb.append(\"purposes. The database settings can be \");\n\t\t\t\t\tsb.append(\"changed in portal-ext.properties.\");\n\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (dbName.equals(\"ASE\") && (dbMajorVersion >= 15)) {\n\t\t\t\tdialect = new SybaseASE157Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"DB2\") && (dbMajorVersion >= 9)) {\n\t\t\t\tdialect = new DB2Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"Microsoft\") && (dbMajorVersion == 9)) {\n\t\t\t\tdialect = new SQLServer2005Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"Microsoft\") && (dbMajorVersion == 10)) {\n\t\t\t\tdialect = new SQLServer2008Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"Oracle\") && (dbMajorVersion >= 10)) {\n\t\t\t\tdialect = new Oracle10gDialect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdialect = DialectFactory.buildDialect(\n\t\t\t\t\tnew Properties(), connection);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString msg = GetterUtil.getString(e.getMessage());\n\n\t\t\tif (msg.contains(\"explicitly set for database: DB2\")) {\n\t\t\t\tdialect = new DB2400Dialect();\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"DB2400Dialect was dynamically chosen as the \" +\n\t\t\t\t\t\t\t\"Hibernate dialect for DB2. This can be \" +\n\t\t\t\t\t\t\t\t\"overriden in portal.properties\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(connection);\n\t\t}\n\n\t\tif (dialect == null) {\n\t\t\tthrow new RuntimeException(\"No dialect found\");\n\t\t}\n\t\telse if (dialectKey != null) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Found dialect \" + dialect.getClass().getName());\n\t\t\t}\n\n\t\t\t_dialects.put(dialectKey, dialect);\n\t\t}\n\n\t\treturn dialect;\n\t}","id":11678,"modified_method":"public static Dialect getDialect(DataSource dataSource) {\n\t\tString dialectKey = null;\n\t\tDialect dialect = null;\n\n\t\tConnection connection = null;\n\n\t\ttry {\n\t\t\tconnection = dataSource.getConnection();\n\n\t\t\tDatabaseMetaData databaseMetaData = connection.getMetaData();\n\n\t\t\tString dbName = databaseMetaData.getDatabaseProductName();\n\t\t\tint dbMajorVersion = databaseMetaData.getDatabaseMajorVersion();\n\t\t\tint dbMinorVersion = databaseMetaData.getDatabaseMinorVersion();\n\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(dbName);\n\t\t\tsb.append(StringPool.COLON);\n\t\t\tsb.append(dbMajorVersion);\n\t\t\tsb.append(StringPool.COLON);\n\t\t\tsb.append(dbMinorVersion);\n\n\t\t\tdialectKey = sb.toString();\n\n\t\t\tdialect = _dialects.get(dialectKey);\n\n\t\t\tif (dialect != null) {\n\t\t\t\treturn dialect;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Determine dialect for \" + dbName + \" \" + dbMajorVersion +\n\t\t\t\t\t\t\".\" + dbMinorVersion);\n\t\t\t}\n\n\t\t\tif (dbName.startsWith(\"HSQL\")) {\n\t\t\t\tdialect = new HSQLDialect();\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\t\tsb.append(\"Liferay is configured to use Hypersonic as \");\n\t\t\t\t\tsb.append(\"its database. Do NOT use Hypersonic in \");\n\t\t\t\t\tsb.append(\"production. Hypersonic is an embedded \");\n\t\t\t\t\tsb.append(\"database useful for development and demo'ing \");\n\t\t\t\t\tsb.append(\"purposes. The database settings can be \");\n\t\t\t\t\tsb.append(\"changed in portal-ext.properties.\");\n\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (dbName.equals(\"ASE\") && (dbMajorVersion >= 15)) {\n\t\t\t\tdialect = new SybaseASE157Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"DB2\") && (dbMajorVersion >= 9)) {\n\t\t\t\tdialect = new DB2Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"Microsoft\") && (dbMajorVersion == 9)) {\n\t\t\t\tdialect = new SQLServer2005Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"Microsoft\") && (dbMajorVersion == 10)) {\n\t\t\t\tdialect = new SQLServer2008Dialect();\n\t\t\t}\n\t\t\telse if (dbName.startsWith(\"Oracle\") && (dbMajorVersion >= 10)) {\n\t\t\t\tdialect = new Oracle10gDialect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdialect = DialectFactory.buildDialect(\n\t\t\t\t\tnew Properties(), connection);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString msg = GetterUtil.getString(e.getMessage());\n\n\t\t\tif (msg.contains(\"explicitly set for database: DB2\")) {\n\t\t\t\tdialect = new DB2400Dialect();\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"DB2400Dialect was dynamically chosen as the \" +\n\t\t\t\t\t\t\t\"Hibernate dialect for DB2. This can be \" +\n\t\t\t\t\t\t\t\t\"overriden in portal.properties\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(connection);\n\t\t}\n\n\t\tif (dialect == null) {\n\t\t\tthrow new RuntimeException(\"No dialect found\");\n\t\t}\n\t\telse if (dialectKey != null) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Found dialect \" + dialect.getClass().getName());\n\t\t\t}\n\n\t\t\t_dialects.put(dialectKey, dialect);\n\t\t}\n\n\t\treturn dialect;\n\t}","commit_id":"04f9179bcbf5e498de407cd42214dcb8f6840767","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"submit\", selectDir,\n\t\t                NodeL10n.getBase().getString(\"ConfigToadlet.selectDirectory\")});\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"hidden\", \"filename\", path});\n\t\tformNode.addChild(persist);\n\t}","id":11679,"modified_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"submit\", selectDir,\n\t\t                NodeL10n.getBase().getString(\"ConfigToadlet.selectDirectory\")});\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"hidden\", filenameField(), path});\n\t\tformNode.addChild(persist);\n\t}","commit_id":"e40aef553213c1a0c264d3351086ca90ef2faa93","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"submit\", selectDir,\n\t\t\t\tNodeL10n.getBase().getString(\"QueueToadlet.download\")});\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"hidden\", \"path\", path});\n\t\tformNode.addChild(persist);\n\t}","id":11680,"modified_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"submit\", selectDir,\n\t\t\t\tNodeL10n.getBase().getString(\"QueueToadlet.download\")});\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"hidden\", filenameField(), path});\n\t\tformNode.addChild(persist);\n\t}","commit_id":"e40aef553213c1a0c264d3351086ca90ef2faa93","url":"https://github.com/freenet/fred"},{"original_method":"protected void createSelectDirectoryButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectDir, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", \"filename\", absolutePath});\n\t\tnode.addChild(persistence);\n\t}","id":11681,"modified_method":"protected void createSelectDirectoryButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectDir, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", filenameField(), absolutePath});\n\t\tnode.addChild(persistence);\n\t}","commit_id":"e40aef553213c1a0c264d3351086ca90ef2faa93","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodPOST (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException {\n\t\trenderPage(persistenceFields(readPOST(request)), request.getPartAsStringFailsafe(\"path\", 4096), ctx);\n\t}","id":11682,"modified_method":"public void handleMethodPOST (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException, RedirectException {\n\t\trenderPage(persistenceFields(readPOST(request)), request.getPartAsStringFailsafe(\"path\", maxPOSTSize),\n\t\t           ctx, selectedValue(request));\n\t}","commit_id":"e40aef553213c1a0c264d3351086ca90ef2faa93","url":"https://github.com/freenet/fred"},{"original_method":"private void renderPage (Hashtable<String, String> fieldPairs, String path, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException {\n\t\tHTMLNode persistenceFields = renderPersistenceFields(fieldPairs);\n\n\t\tif (path.length() == 0) {\n\t\t\t//Path not specified, fall back to default.\n\t\t\tpath = startingDir();\n\t\t}\n\n\t\tFile currentPath = new File(path).getCanonicalFile();\n\t\t//For use in error messages.\n\t\tString attemptedPath = currentPath == null ? \"null\" : currentPath.getAbsolutePath();\n\n\t\tPageMaker pageMaker = ctx.getPageMaker();\n\n\t\tif (currentPath != null && !allowedDir(currentPath)) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageMaker.getInfobox(\"infobox-error\",  \"Forbidden\", page.content, \"access-denied\", true).\n\t\t\t        addChild(\"#\", l10n(\"dirAccessDenied\"));\n\n\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTMLNode pageNode;\n\n\t\tif (currentPath != null && currentPath.exists() && currentPath.isDirectory() && currentPath.canRead()) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tFile[] files = currentPath.listFiles();\n\t\t\t\n\t\t\tif (files == null) {\n\t\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(files, new Comparator<File>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(File firstFile, File secondFile) {\n\t\t\t\t\t/* Put directories above files, sorting each alphabetically and\n\t\t\t\t\t * case-insensitively.\n\t\t\t\t\t */\n\t\t\t\t\tif (firstFile.isDirectory() && !secondFile.isDirectory()) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!firstFile.isDirectory() && secondFile.isDirectory()) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn firstFile.getName().compareToIgnoreCase(secondFile.getName());\n\t\t\t\t}\n\t\t\t});\n\t\t\tHTMLNode listingTable = listingDiv.addChild(\"table\");\n\t\t\tHTMLNode headerRow = listingTable.addChild(\"tr\");\n\t\t\theaderRow.addChild(\"th\");\n\t\t\theaderRow.addChild(\"th\", l10n(\"fileHeader\"));\n\t\t\theaderRow.addChild(\"th\", l10n(\"sizeHeader\"));\n\t\t\t/* add filesystem roots (fsck windows) */\n\t\t\tfor (File currentRoot : File.listRoots()) {\n\t\t\t\tif (allowedDir(currentRoot)) {\n\t\t\t\tHTMLNode rootRow = listingTable.addChild(\"tr\");\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkCellNode = rootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkFormNode = ctx.addFormChild(rootLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(rootLinkFormNode, currentRoot.getCanonicalPath(),\n\t\t\t\t\t        currentRoot.getAbsolutePath(), persistenceFields);\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* add back link */\n\t\t\tif (currentPath.getParent() != null) {\n\t\t\t\tif (allowedDir(currentPath.getParentFile())) {\n\t\t\t\tHTMLNode backlinkRow = listingTable.addChild(\"tr\");\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkCellNode = backlinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkFormNode = ctx.addFormChild(backLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(backLinkFormNode, \"..\", currentPath.getParent(), persistenceFields);\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (File currentFile : files) {\n\t\t\t\tHTMLNode fileRow = listingTable.addChild(\"tr\");\n\t\t\t\tif (currentFile.isDirectory()) {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t// Select directory\n\t\t\t\t\t\tif (allowedDir(currentFile)) {\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, postTo(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\n\t\t\t\t\t\t\tcreateSelectDirectoryButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t\t        persistenceFields);\n\n\t\t\t\t\t\t// Change directory\n\t\t\t\t\t\tHTMLNode directoryCellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode directoryFormNode = ctx.addFormChild(directoryCellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\t\tcreateChangeDirButton(directoryFormNode, currentFile.getName(),\n\t\t\t\t\t\t\t        currentFile.getAbsolutePath(), persistenceFields);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t}\n\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t} else {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t//Select file\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, postTo(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\tcreateSelectFileButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t        persistenceFields);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfileRow.addChild(\"td\", currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\", attemptedPath));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tlistingDiv.addChild(\"#\", l10n(\"dirCannotBeRead\", \"path\", attemptedPath));\n\t\t\tHTMLNode ulNode = listingDiv.addChild(\"ul\");\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathExist\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathIsDir\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathReadable\"));\n\t\t}\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t}","id":11683,"modified_method":"/**\n\t * Presents a file selection screen, or a something has been selected notes its directory and redirects to the\n\t * POST target.\n\t * @param fieldPairs fields which are to be persisted between views\n\t * @param path current path to display\n\t * @param ctx context used for rendering\n\t * @param filename a filename if a file or directory is selected, NULL if not.\n\t * @throws ToadletContextClosedException\n\t * @throws IOException\n\t * @throws RedirectException\n\t */\n\tprivate void renderPage (Hashtable<String, String> fieldPairs, String path, final ToadletContext ctx, String filename)\n\t        throws ToadletContextClosedException, IOException, RedirectException {\n\t\tHTMLNode persistenceFields = renderPersistenceFields(fieldPairs);\n\n\t\tif (filename != null) {\n\t\t\tFile file = new File(filename);\n\t\t\tif (file.isDirectory()) lastSuccessful = file.getAbsoluteFile();\n\t\t\telse lastSuccessful = file.getParentFile().getAbsoluteFile();\n\n\t\t\ttry {\n\t\t\t\tSystem.out.println(postTo());\n\t\t\t\tthrow new RedirectException(postTo());\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tsendErrorPage(ctx, 500, NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\"),\n\t\t\t\t              e.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tif (path.length() == 0) {\n\t\t\tif (lastSuccessful != null && lastSuccessful.isDirectory() && allowedDir(lastSuccessful)) {\n\t\t\t\tpath = lastSuccessful.getAbsolutePath();\n\t\t\t} else {\n\t\t\t\tpath = startingDir();\n\t\t\t}\n\t\t}\n\n\t\tFile currentPath = new File(path).getCanonicalFile();\n\t\t//For use in error messages.\n\t\tString attemptedPath = currentPath == null ? \"null\" : currentPath.getAbsolutePath();\n\n\t\tPageMaker pageMaker = ctx.getPageMaker();\n\n\t\tif (currentPath != null && !allowedDir(currentPath)) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageMaker.getInfobox(\"infobox-error\",  \"Forbidden\", page.content, \"access-denied\", true).\n\t\t\t        addChild(\"#\", l10n(\"dirAccessDenied\"));\n\n\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTMLNode pageNode;\n\n\t\tif (currentPath != null && currentPath.exists() && currentPath.isDirectory() && currentPath.canRead()) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tFile[] files = currentPath.listFiles();\n\t\t\t\n\t\t\tif (files == null) {\n\t\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(files, new Comparator<File>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(File firstFile, File secondFile) {\n\t\t\t\t\t/* Put directories above files, sorting each alphabetically and\n\t\t\t\t\t * case-insensitively.\n\t\t\t\t\t */\n\t\t\t\t\tif (firstFile.isDirectory() && !secondFile.isDirectory()) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!firstFile.isDirectory() && secondFile.isDirectory()) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn firstFile.getName().compareToIgnoreCase(secondFile.getName());\n\t\t\t\t}\n\t\t\t});\n\t\t\tHTMLNode listingTable = listingDiv.addChild(\"table\");\n\t\t\tHTMLNode headerRow = listingTable.addChild(\"tr\");\n\t\t\theaderRow.addChild(\"th\");\n\t\t\theaderRow.addChild(\"th\", l10n(\"fileHeader\"));\n\t\t\theaderRow.addChild(\"th\", l10n(\"sizeHeader\"));\n\t\t\t/* add filesystem roots (fsck windows) */\n\t\t\tfor (File currentRoot : File.listRoots()) {\n\t\t\t\tif (allowedDir(currentRoot)) {\n\t\t\t\tHTMLNode rootRow = listingTable.addChild(\"tr\");\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkCellNode = rootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkFormNode = ctx.addFormChild(rootLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(rootLinkFormNode, currentRoot.getCanonicalPath(),\n\t\t\t\t\t        currentRoot.getAbsolutePath(), persistenceFields);\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* add back link */\n\t\t\tif (currentPath.getParent() != null) {\n\t\t\t\tif (allowedDir(currentPath.getParentFile())) {\n\t\t\t\tHTMLNode backlinkRow = listingTable.addChild(\"tr\");\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkCellNode = backlinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkFormNode = ctx.addFormChild(backLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(backLinkFormNode, \"..\", currentPath.getParent(), persistenceFields);\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (File currentFile : files) {\n\t\t\t\tHTMLNode fileRow = listingTable.addChild(\"tr\");\n\t\t\t\tif (currentFile.isDirectory()) {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t// Select directory\n\t\t\t\t\t\tif (allowedDir(currentFile)) {\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\n\t\t\t\t\t\t\tcreateSelectDirectoryButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t\t        persistenceFields);\n\n\t\t\t\t\t\t// Change directory\n\t\t\t\t\t\tHTMLNode directoryCellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode directoryFormNode = ctx.addFormChild(directoryCellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\t\tcreateChangeDirButton(directoryFormNode, currentFile.getName(),\n\t\t\t\t\t\t\t        currentFile.getAbsolutePath(), persistenceFields);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t}\n\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t} else {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t//Select file\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\tcreateSelectFileButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t        persistenceFields);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfileRow.addChild(\"td\", currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\", attemptedPath));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tlistingDiv.addChild(\"#\", l10n(\"dirCannotBeRead\", \"path\", attemptedPath));\n\t\t\tHTMLNode ulNode = listingDiv.addChild(\"ul\");\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathExist\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathIsDir\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathReadable\"));\n\t\t}\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t}","commit_id":"e40aef553213c1a0c264d3351086ca90ef2faa93","url":"https://github.com/freenet/fred"},{"original_method":"protected void createSelectFileButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectFile, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", \"filename\", absolutePath});\n\t\tnode.addChild(persistence);\n\t}","id":11684,"modified_method":"protected void createSelectFileButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectFile, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", filenameField(), absolutePath});\n\t\tnode.addChild(persistence);\n\t}","commit_id":"e40aef553213c1a0c264d3351086ca90ef2faa93","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * @param uri is unused,\n\t * @param request contains parameters.\n\t * @param ctx allows page rendering and permissions checks.\n\t * @exception ToadletContextClosedException Access is denied: uploading might be disabled overall.\n\t *                                                            The user might be denied access to this directory,\n\t *                                                            which could be their home directory.\n\t * @exception IOException Something file-related went wrong.\n\t * @see <a href=\"freenet/clients/http/Toadlet#findSupportedMethods()\">findSupportedMethods<\/a>\n\t * @see \"java.net.URI\"\n\t * @see \"<a href=\"freenet/clients/http/ToadletContext.html\">ToadletContext<\/a>\n\t */\n\tpublic void handleMethodGET (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException {\n\t\trenderPage(persistenceFields(readGET(request)), request.getParam(\"path\"), ctx);\n\t}","id":11685,"modified_method":"/**\n\t * @param uri is unused,\n\t * @param request contains parameters.\n\t * @param ctx allows page rendering and permissions checks.\n\t * @exception ToadletContextClosedException Access is denied: uploading might be disabled overall.\n\t *                                                            The user might be denied access to this directory,\n\t *                                                            which could be their home directory.\n\t * @exception IOException Something file-related went wrong.\n\t * @see <a href=\"freenet/clients/http/Toadlet#findSupportedMethods()\">findSupportedMethods<\/a>\n\t * @see \"java.net.URI\"\n\t * @see \"<a href=\"freenet/clients/http/ToadletContext.html\">ToadletContext<\/a>\n\t */\n\tpublic void handleMethodGET (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException, RedirectException {\n\t\trenderPage(persistenceFields(readGET(request)), request.getParam(\"path\"), ctx, selectedValue(request));\n\t}","commit_id":"e40aef553213c1a0c264d3351086ca90ef2faa93","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"submit\", selectDir,\n\t\t                NodeL10n.getBase().getString(\"ConfigToadlet.selectDirectory\")});\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"hidden\", \"filename\", path});\n\t\tformNode.addChild(persist);\n\t}","id":11686,"modified_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"submit\", selectDir,\n\t\t                NodeL10n.getBase().getString(\"ConfigToadlet.selectDirectory\")});\n\t\tformNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, \n\t\t        new String[] { \"hidden\", filenameField(), path});\n\t\tformNode.addChild(persist);\n\t}","commit_id":"8a6f5cc1616ffc47560736bd8a4b2bc1b34a2491","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"submit\", selectDir,\n\t\t\t\tNodeL10n.getBase().getString(\"QueueToadlet.download\")});\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"hidden\", \"path\", path});\n\t\tformNode.addChild(persist);\n\t}","id":11687,"modified_method":"@Override\n\tprotected void createSelectDirectoryButton (HTMLNode formNode, String path, HTMLNode persist) {\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"submit\", selectDir,\n\t\t\t\tNodeL10n.getBase().getString(\"QueueToadlet.download\")});\n\t\tformNode.addChild(\"input\",\n\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\tnew String[] { \"hidden\", filenameField(), path});\n\t\tformNode.addChild(persist);\n\t}","commit_id":"8a6f5cc1616ffc47560736bd8a4b2bc1b34a2491","url":"https://github.com/freenet/fred"},{"original_method":"protected void createSelectFileButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectFile, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", \"filename\", absolutePath});\n\t\tnode.addChild(persistence);\n\t}","id":11688,"modified_method":"protected void createSelectFileButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectFile, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", filenameField(), absolutePath});\n\t\tnode.addChild(persistence);\n\t}","commit_id":"8a6f5cc1616ffc47560736bd8a4b2bc1b34a2491","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * @param uri is unused,\n\t * @param request contains parameters.\n\t * @param ctx allows page rendering and permissions checks.\n\t * @exception ToadletContextClosedException Access is denied: uploading might be disabled overall.\n\t *                                                            The user might be denied access to this directory,\n\t *                                                            which could be their home directory.\n\t * @exception IOException Something file-related went wrong.\n\t * @see <a href=\"freenet/clients/http/Toadlet#findSupportedMethods()\">findSupportedMethods<\/a>\n\t * @see \"java.net.URI\"\n\t * @see \"<a href=\"freenet/clients/http/ToadletContext.html\">ToadletContext<\/a>\n\t */\n\tpublic void handleMethodGET (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException {\n\t\trenderPage(persistenceFields(readGET(request)), request.getParam(\"path\"), ctx);\n\t}","id":11689,"modified_method":"/**\n\t * @param uri is unused,\n\t * @param request contains parameters.\n\t * @param ctx allows page rendering and permissions checks.\n\t * @exception ToadletContextClosedException Access is denied: uploading might be disabled overall.\n\t *                                                            The user might be denied access to this directory,\n\t *                                                            which could be their home directory.\n\t * @exception IOException Something file-related went wrong.\n\t * @see <a href=\"freenet/clients/http/Toadlet#findSupportedMethods()\">findSupportedMethods<\/a>\n\t * @see \"java.net.URI\"\n\t * @see \"<a href=\"freenet/clients/http/ToadletContext.html\">ToadletContext<\/a>\n\t */\n\tpublic void handleMethodGET (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException, RedirectException {\n\t\trenderPage(persistenceFields(readGET(request)), request.getParam(\"path\"), ctx, selectedValue(request));\n\t}","commit_id":"8a6f5cc1616ffc47560736bd8a4b2bc1b34a2491","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodPOST (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException {\n\t\trenderPage(persistenceFields(readPOST(request)), request.getPartAsStringFailsafe(\"path\", 4096), ctx);\n\t}","id":11690,"modified_method":"public void handleMethodPOST (URI uri, HTTPRequest request, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException, RedirectException {\n\t\trenderPage(persistenceFields(readPOST(request)), request.getPartAsStringFailsafe(\"path\", maxPOSTSize),\n\t\t           ctx, selectedValue(request));\n\t}","commit_id":"8a6f5cc1616ffc47560736bd8a4b2bc1b34a2491","url":"https://github.com/freenet/fred"},{"original_method":"private void renderPage (Hashtable<String, String> fieldPairs, String path, final ToadletContext ctx)\n\t        throws ToadletContextClosedException, IOException {\n\t\tHTMLNode persistenceFields = renderPersistenceFields(fieldPairs);\n\n\t\tif (path.length() == 0) {\n\t\t\t//Path not specified, fall back to default.\n\t\t\tpath = startingDir();\n\t\t}\n\n\t\tFile currentPath = new File(path).getCanonicalFile();\n\t\t//For use in error messages.\n\t\tString attemptedPath = currentPath == null ? \"null\" : currentPath.getAbsolutePath();\n\n\t\tPageMaker pageMaker = ctx.getPageMaker();\n\n\t\tif (currentPath != null && !allowedDir(currentPath)) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageMaker.getInfobox(\"infobox-error\",  \"Forbidden\", page.content, \"access-denied\", true).\n\t\t\t        addChild(\"#\", l10n(\"dirAccessDenied\"));\n\n\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTMLNode pageNode;\n\n\t\tif (currentPath != null && currentPath.exists() && currentPath.isDirectory() && currentPath.canRead()) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tFile[] files = currentPath.listFiles();\n\t\t\t\n\t\t\tif (files == null) {\n\t\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(files, new Comparator<File>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(File firstFile, File secondFile) {\n\t\t\t\t\t/* Put directories above files, sorting each alphabetically and\n\t\t\t\t\t * case-insensitively.\n\t\t\t\t\t */\n\t\t\t\t\tif (firstFile.isDirectory() && !secondFile.isDirectory()) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!firstFile.isDirectory() && secondFile.isDirectory()) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn firstFile.getName().compareToIgnoreCase(secondFile.getName());\n\t\t\t\t}\n\t\t\t});\n\t\t\tHTMLNode listingTable = listingDiv.addChild(\"table\");\n\t\t\tHTMLNode headerRow = listingTable.addChild(\"tr\");\n\t\t\theaderRow.addChild(\"th\");\n\t\t\theaderRow.addChild(\"th\", l10n(\"fileHeader\"));\n\t\t\theaderRow.addChild(\"th\", l10n(\"sizeHeader\"));\n\t\t\t/* add filesystem roots (fsck windows) */\n\t\t\tfor (File currentRoot : File.listRoots()) {\n\t\t\t\tif (allowedDir(currentRoot)) {\n\t\t\t\tHTMLNode rootRow = listingTable.addChild(\"tr\");\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkCellNode = rootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkFormNode = ctx.addFormChild(rootLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(rootLinkFormNode, currentRoot.getCanonicalPath(),\n\t\t\t\t\t        currentRoot.getAbsolutePath(), persistenceFields);\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* add back link */\n\t\t\tif (currentPath.getParent() != null) {\n\t\t\t\tif (allowedDir(currentPath.getParentFile())) {\n\t\t\t\tHTMLNode backlinkRow = listingTable.addChild(\"tr\");\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkCellNode = backlinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkFormNode = ctx.addFormChild(backLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(backLinkFormNode, \"..\", currentPath.getParent(), persistenceFields);\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (File currentFile : files) {\n\t\t\t\tHTMLNode fileRow = listingTable.addChild(\"tr\");\n\t\t\t\tif (currentFile.isDirectory()) {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t// Select directory\n\t\t\t\t\t\tif (allowedDir(currentFile)) {\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, postTo(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\n\t\t\t\t\t\t\tcreateSelectDirectoryButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t\t        persistenceFields);\n\n\t\t\t\t\t\t// Change directory\n\t\t\t\t\t\tHTMLNode directoryCellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode directoryFormNode = ctx.addFormChild(directoryCellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\t\tcreateChangeDirButton(directoryFormNode, currentFile.getName(),\n\t\t\t\t\t\t\t        currentFile.getAbsolutePath(), persistenceFields);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t}\n\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t} else {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t//Select file\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, postTo(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\tcreateSelectFileButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t        persistenceFields);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfileRow.addChild(\"td\", currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\", attemptedPath));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tlistingDiv.addChild(\"#\", l10n(\"dirCannotBeRead\", \"path\", attemptedPath));\n\t\t\tHTMLNode ulNode = listingDiv.addChild(\"ul\");\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathExist\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathIsDir\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathReadable\"));\n\t\t}\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t}","id":11691,"modified_method":"/**\n\t * Presents a file selection screen, or a something has been selected notes its directory and redirects to the\n\t * POST target.\n\t * @param fieldPairs fields which are to be persisted between views\n\t * @param path current path to display\n\t * @param ctx context used for rendering\n\t * @param filename a filename if a file or directory is selected, NULL if not.\n\t * @throws ToadletContextClosedException\n\t * @throws IOException\n\t * @throws RedirectException\n\t */\n\tprivate void renderPage (Hashtable<String, String> fieldPairs, String path, final ToadletContext ctx, String filename)\n\t        throws ToadletContextClosedException, IOException, RedirectException {\n\t\tHTMLNode persistenceFields = renderPersistenceFields(fieldPairs);\n\n\t\tif (filename != null) {\n\t\t\tFile file = new File(filename);\n\t\t\tif (file.isDirectory()) lastSuccessful = file.getAbsoluteFile();\n\t\t\telse lastSuccessful = file.getParentFile().getAbsoluteFile();\n\n\t\t\ttry {\n\t\t\t\tSystem.out.println(postTo());\n\t\t\t\tthrow new RedirectException(postTo());\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tsendErrorPage(ctx, 500, NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\"),\n\t\t\t\t              e.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tif (path.length() == 0) {\n\t\t\tif (lastSuccessful != null && lastSuccessful.isDirectory() && allowedDir(lastSuccessful)) {\n\t\t\t\tpath = lastSuccessful.getAbsolutePath();\n\t\t\t} else {\n\t\t\t\tpath = startingDir();\n\t\t\t}\n\t\t}\n\n\t\tFile currentPath = new File(path).getCanonicalFile();\n\t\t//For use in error messages.\n\t\tString attemptedPath = currentPath == null ? \"null\" : currentPath.getAbsolutePath();\n\n\t\tPageMaker pageMaker = ctx.getPageMaker();\n\n\t\tif (currentPath != null && !allowedDir(currentPath)) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageMaker.getInfobox(\"infobox-error\",  \"Forbidden\", page.content, \"access-denied\", true).\n\t\t\t        addChild(\"#\", l10n(\"dirAccessDenied\"));\n\n\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTMLNode pageNode;\n\n\t\tif (currentPath != null && currentPath.exists() && currentPath.isDirectory() && currentPath.canRead()) {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\",\n\t\t\t        currentPath.getAbsolutePath()));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tFile[] files = currentPath.listFiles();\n\t\t\t\n\t\t\tif (files == null) {\n\t\t\t\tsendErrorPage(ctx, 403, \"Forbidden\", l10n(\"dirAccessDenied\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(files, new Comparator<File>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(File firstFile, File secondFile) {\n\t\t\t\t\t/* Put directories above files, sorting each alphabetically and\n\t\t\t\t\t * case-insensitively.\n\t\t\t\t\t */\n\t\t\t\t\tif (firstFile.isDirectory() && !secondFile.isDirectory()) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!firstFile.isDirectory() && secondFile.isDirectory()) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn firstFile.getName().compareToIgnoreCase(secondFile.getName());\n\t\t\t\t}\n\t\t\t});\n\t\t\tHTMLNode listingTable = listingDiv.addChild(\"table\");\n\t\t\tHTMLNode headerRow = listingTable.addChild(\"tr\");\n\t\t\theaderRow.addChild(\"th\");\n\t\t\theaderRow.addChild(\"th\", l10n(\"fileHeader\"));\n\t\t\theaderRow.addChild(\"th\", l10n(\"sizeHeader\"));\n\t\t\t/* add filesystem roots (fsck windows) */\n\t\t\tfor (File currentRoot : File.listRoots()) {\n\t\t\t\tif (allowedDir(currentRoot)) {\n\t\t\t\tHTMLNode rootRow = listingTable.addChild(\"tr\");\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkCellNode = rootRow.addChild(\"td\");\n\t\t\t\tHTMLNode rootLinkFormNode = ctx.addFormChild(rootLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(rootLinkFormNode, currentRoot.getCanonicalPath(),\n\t\t\t\t\t        currentRoot.getAbsolutePath(), persistenceFields);\n\t\t\t\trootRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* add back link */\n\t\t\tif (currentPath.getParent() != null) {\n\t\t\t\tif (allowedDir(currentPath.getParentFile())) {\n\t\t\t\tHTMLNode backlinkRow = listingTable.addChild(\"tr\");\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkCellNode = backlinkRow.addChild(\"td\");\n\t\t\t\tHTMLNode backLinkFormNode = ctx.addFormChild(backLinkCellNode, path(),\n\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\tcreateChangeDirButton(backLinkFormNode, \"..\", currentPath.getParent(), persistenceFields);\n\t\t\t\tbacklinkRow.addChild(\"td\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (File currentFile : files) {\n\t\t\t\tHTMLNode fileRow = listingTable.addChild(\"tr\");\n\t\t\t\tif (currentFile.isDirectory()) {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t// Select directory\n\t\t\t\t\t\tif (allowedDir(currentFile)) {\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\n\t\t\t\t\t\t\tcreateSelectDirectoryButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t\t        persistenceFields);\n\n\t\t\t\t\t\t// Change directory\n\t\t\t\t\t\tHTMLNode directoryCellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode directoryFormNode = ctx.addFormChild(directoryCellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\t\tcreateChangeDirButton(directoryFormNode, currentFile.getName(),\n\t\t\t\t\t\t\t        currentFile.getAbsolutePath(), persistenceFields);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t}\n\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t} else {\n\t\t\t\t\tif (currentFile.canRead()) {\n\t\t\t\t\t\t//Select file\n\t\t\t\t\t\tHTMLNode cellNode = fileRow.addChild(\"td\");\n\t\t\t\t\t\tHTMLNode formNode = ctx.addFormChild(cellNode, path(),\n\t\t\t\t\t\t        \"insertLocalFileForm\");\n\t\t\t\t\t\tcreateSelectFileButton(formNode, currentFile.getAbsolutePath(),\n\t\t\t\t\t\t        persistenceFields);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfileRow.addChild(\"td\", currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileRow.addChild(\"td\");\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"unreadable-file\",\n\t\t\t\t\t\t        currentFile.getName());\n\t\t\t\t\t\tfileRow.addChild(\"td\", \"class\", \"right-align\",\n\t\t\t\t\t\t        String.valueOf(currentFile.length()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tPageNode page = pageMaker.getPageNode(l10n(\"listingTitle\", \"path\", attemptedPath), ctx);\n\t\t\tpageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tif (ctx.isAllowedFullAccess()) contentNode.addChild(core.alerts.createSummary());\n\t\t\t\n\t\t\tHTMLNode infoboxDiv = contentNode.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tinfoboxDiv.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"listing\", \"path\", attemptedPath));\n\t\t\tHTMLNode listingDiv = infoboxDiv.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tlistingDiv.addChild(\"#\", l10n(\"dirCannotBeRead\", \"path\", attemptedPath));\n\t\t\tHTMLNode ulNode = listingDiv.addChild(\"ul\");\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathExist\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathIsDir\"));\n\t\t\tulNode.addChild(\"li\", l10n(\"checkPathReadable\"));\n\t\t}\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t}","commit_id":"8a6f5cc1616ffc47560736bd8a4b2bc1b34a2491","url":"https://github.com/freenet/fred"},{"original_method":"protected void createSelectDirectoryButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectDir, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", \"filename\", absolutePath});\n\t\tnode.addChild(persistence);\n\t}","id":11692,"modified_method":"protected void createSelectDirectoryButton (HTMLNode node, String absolutePath, HTMLNode persistence) {\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"submit\", selectDir, l10n(\"insert\")});\n\t\tnode.addChild(\"input\",\n\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t        new String[]{\"hidden\", filenameField(), absolutePath});\n\t\tnode.addChild(persistence);\n\t}","commit_id":"8a6f5cc1616ffc47560736bd8a4b2bc1b34a2491","url":"https://github.com/freenet/fred"},{"original_method":"@Transactional\n    public void doUpdate(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            OnmsNode node = m_nodeDao.get(nodeId);\n            \n            // if the node exists and has different label then first delete old data\n            RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();            \n            RancidNodeAuthentication rAuth = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getAuth();\n            if (!rNode.getDeviceName().equals(node.getLabel())) {\n                RWSClientApi.deleteRWSRancidNode(m_cp, rNode);\n                RWSClientApi.deleteRWSAuthNode(m_cp, rAuth);\n            }\n\n            \n            rNode = getSuitableRancidNode(node);\n            RWSClientApi.createOrUpdateRWSRancidNode(m_cp, rNode);\n            \n            rAuth = getSuitableRancidNodeAuthentication(node);\n            RWSClientApi.createOrUpdateRWSAuthNode(m_cp, getSuitableRancidNodeAuthentication(node));\n            \n            m_onmsNodeRancidNodeMap.replace(node.getId(), new RancidNodeContainer(rNode, rAuth));\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","id":11693,"modified_method":"@Transactional\n    public void doUpdate(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            OnmsNode node = m_nodeDao.get(nodeId);\n            Assert.notNull(node, \"Rancid Provisioning Adapter update Node method failed to return node for given nodeId:\"+nodeId);\n            \n            // if the node exists and has different label then first delete old data\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n            RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();            \n            RancidNodeAuthentication rAuth = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getAuth();\n                if (!rNode.getDeviceName().equals(node.getLabel())) {\n                    RWSClientApi.deleteRWSRancidNode(m_cp, rNode);\n                    RWSClientApi.deleteRWSAuthNode(m_cp, rAuth);\n                }\n            }\n            \n            RancidNode rNode = getSuitableRancidNode(node);\n            RWSClientApi.createOrUpdateRWSRancidNode(m_cp, rNode);\n            \n            RancidNodeAuthentication rAuth = getSuitableRancidNodeAuthentication(node);\n            RWSClientApi.createOrUpdateRWSAuthNode(m_cp, getSuitableRancidNodeAuthentication(node));\n            \n            m_onmsNodeRancidNodeMap.replace(node.getId(), new RancidNodeContainer(rNode, rAuth));\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","commit_id":"3174b33e91aaefa56f72a8eef33a43db2aaac240","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Transactional\n    public void doUpdate(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            OnmsNode node = m_nodeDao.get(nodeId);\n            \n            // if the node exists and has different label then first delete old data\n            RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();            \n            RancidNodeAuthentication rAuth = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getAuth();\n            if (!rNode.getDeviceName().equals(node.getLabel())) {\n                RWSClientApi.deleteRWSRancidNode(m_cp, rNode);\n                RWSClientApi.deleteRWSAuthNode(m_cp, rAuth);\n            }\n\n            \n            rNode = getSuitableRancidNode(node);\n            RWSClientApi.createOrUpdateRWSRancidNode(m_cp, rNode);\n            \n            rAuth = getSuitableRancidNodeAuthentication(node);\n            RWSClientApi.createOrUpdateRWSAuthNode(m_cp, getSuitableRancidNodeAuthentication(node));\n            \n            m_onmsNodeRancidNodeMap.replace(node.getId(), new RancidNodeContainer(rNode, rAuth));\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","id":11694,"modified_method":"@Transactional\n    public void doUpdate(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            OnmsNode node = m_nodeDao.get(nodeId);\n            Assert.notNull(node, \"Rancid Provisioning Adapter update Node method failed to return node for given nodeId:\"+nodeId);\n            \n            // if the node exists and has different label then first delete old data\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n            RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();            \n            RancidNodeAuthentication rAuth = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getAuth();\n                if (!rNode.getDeviceName().equals(node.getLabel())) {\n                    RWSClientApi.deleteRWSRancidNode(m_cp, rNode);\n                    RWSClientApi.deleteRWSAuthNode(m_cp, rAuth);\n                }\n            }\n            \n            RancidNode rNode = getSuitableRancidNode(node);\n            RWSClientApi.createOrUpdateRWSRancidNode(m_cp, rNode);\n            \n            RancidNodeAuthentication rAuth = getSuitableRancidNodeAuthentication(node);\n            RWSClientApi.createOrUpdateRWSAuthNode(m_cp, getSuitableRancidNodeAuthentication(node));\n            \n            m_onmsNodeRancidNodeMap.replace(node.getId(), new RancidNodeContainer(rNode, rAuth));\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","commit_id":"281e2580dedc8548556479b916eb452c62538d36","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Transactional\n    public void doUpdate(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            OnmsNode node = m_nodeDao.get(nodeId);\n            \n            // if the node exists and has different label then first delete old data\n            RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();            \n            RancidNodeAuthentication rAuth = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getAuth();\n            if (!rNode.getDeviceName().equals(node.getLabel())) {\n                RWSClientApi.deleteRWSRancidNode(m_cp, rNode);\n                RWSClientApi.deleteRWSAuthNode(m_cp, rAuth);\n            }\n\n            \n            rNode = getSuitableRancidNode(node);\n            RWSClientApi.createOrUpdateRWSRancidNode(m_cp, rNode);\n            \n            rAuth = getSuitableRancidNodeAuthentication(node);\n            RWSClientApi.createOrUpdateRWSAuthNode(m_cp, getSuitableRancidNodeAuthentication(node));\n            \n            m_onmsNodeRancidNodeMap.replace(node.getId(), new RancidNodeContainer(rNode, rAuth));\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","id":11695,"modified_method":"@Transactional\n    public void doUpdate(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            OnmsNode node = m_nodeDao.get(nodeId);\n            Assert.notNull(node, \"Rancid Provisioning Adapter update Node method failed to return node for given nodeId:\"+nodeId);\n            \n            // if the node exists and has different label then first delete old data\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n            RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();            \n            RancidNodeAuthentication rAuth = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getAuth();\n                if (!rNode.getDeviceName().equals(node.getLabel())) {\n                    RWSClientApi.deleteRWSRancidNode(m_cp, rNode);\n                    RWSClientApi.deleteRWSAuthNode(m_cp, rAuth);\n                }\n            }\n            \n            RancidNode rNode = getSuitableRancidNode(node);\n            RWSClientApi.createOrUpdateRWSRancidNode(m_cp, rNode);\n            \n            RancidNodeAuthentication rAuth = getSuitableRancidNodeAuthentication(node);\n            RWSClientApi.createOrUpdateRWSAuthNode(m_cp, getSuitableRancidNodeAuthentication(node));\n            \n            m_onmsNodeRancidNodeMap.replace(node.getId(), new RancidNodeContainer(rNode, rAuth));\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","commit_id":"88e8e2391757b2469c492cc883c6277befe4979d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Nonnull\n    @Override\n    public PermissionProvider getPermissionProvider(@Nonnull final Root root,\n                                                    @Nonnull final String workspaceName,\n                                                    @Nonnull final Set<Principal> principals) {\n        List<AuthorizationConfiguration> configurations = getConfigurations();\n        switch (configurations.size()) {\n            case 0: throw new IllegalStateException();\n            case 1: return configurations.get(0).getPermissionProvider(root, workspaceName, principals);\n            default:\n                List<AggregatedPermissionProvider> aggrPermissionProviders = Lists.newArrayListWithCapacity(configurations.size());\n                for (AuthorizationConfiguration conf : configurations) {\n                    PermissionProvider pProvider = conf.getPermissionProvider(root, workspaceName, principals);\n                    if (pProvider instanceof AggregatedPermissionProvider) {\n                        aggrPermissionProviders.add((AggregatedPermissionProvider) pProvider);\n                    }\n                }\n                if (aggrPermissionProviders.size() == 1) {\n                    return aggrPermissionProviders.get(0);\n                } else {\n                    return new CompositePermissionProvider(root, aggrPermissionProviders);\n                }\n        }\n    }","id":11696,"modified_method":"@Nonnull\n    @Override\n    public PermissionProvider getPermissionProvider(@Nonnull final Root root,\n                                                    @Nonnull final String workspaceName,\n                                                    @Nonnull final Set<Principal> principals) {\n        List<AuthorizationConfiguration> configurations = getConfigurations();\n        switch (configurations.size()) {\n            case 0: throw new IllegalStateException();\n            case 1: return configurations.get(0).getPermissionProvider(root, workspaceName, principals);\n            default:\n                List<AggregatedPermissionProvider> aggrPermissionProviders = Lists.newArrayListWithCapacity(configurations.size());\n                for (AuthorizationConfiguration conf : configurations) {\n                    PermissionProvider pProvider = conf.getPermissionProvider(root, workspaceName, principals);\n                    if (pProvider instanceof AggregatedPermissionProvider) {\n                        aggrPermissionProviders.add((AggregatedPermissionProvider) pProvider);\n                    }\n                }\n                PermissionProvider pp;\n                switch (aggrPermissionProviders.size()) {\n                    case 0 :\n                        pp = EmptyPermissionProvider.getInstance();\n                        break;\n                    case 1 :\n                        pp = aggrPermissionProviders.get(0);\n                        break;\n                    default :\n                        pp = new CompositePermissionProvider(root, aggrPermissionProviders);\n                }\n                return pp;\n        }\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean canRead(@Nonnull PropertyState property) {\n            Iterator<Map.Entry<AggregatedPermissionProvider, TreePermission>> it = map.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry<AggregatedPermissionProvider, TreePermission> entry = it.next();\n                TreePermission tp = entry.getValue();\n                if (entry.getKey().handles(tp, Permissions.READ_PROPERTY)) {\n                    boolean isGranted = entry.getValue().canRead(property);\n                    if (!it.hasNext() || !isGranted) {\n                        return isGranted;\n                    }\n                }\n            }\n            return false;\n        }","id":11697,"modified_method":"@Override\n        public boolean canRead(@Nonnull PropertyState property) {\n            boolean canReadProperty = false;\n            for (Map.Entry<AggregatedPermissionProvider, TreePermission> entry : map.entrySet()) {\n                TreePermission tp = entry.getValue();\n                if (entry.getKey().handles(tp, Permissions.READ_PROPERTY)) {\n                    canReadProperty = entry.getValue().canRead(property);\n                    if (!canReadProperty) {\n                        return false;\n                    }\n                }\n            }\n            return canReadProperty;\n        }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isGranted(@Nonnull final String oakPath, @Nonnull String jcrActions) {\n        final String[] actions = Text.explode(jcrActions, ',', false);\n        switch (actions.length) {\n            case 0: return true;\n            case 1:\n                Iterable<AggregatedPermissionProvider> providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n                    @Override\n                    public boolean apply(@Nullable AggregatedPermissionProvider pp) {\n                        return pp != null && pp.handles(oakPath, actions[0]);\n                    }\n                });\n                return grantsAction(oakPath, actions[0], providers);\n            default:\n                for (final String action : actions) {\n                    providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n                        @Override\n                        public boolean apply(@Nullable AggregatedPermissionProvider pp) {\n                            return pp != null && pp.handles(oakPath, action);\n                        }\n                    });\n                    if (!grantsAction(oakPath, action, providers)) {\n                        return false;\n                    }\n                }\n                return true;\n        }\n    }","id":11698,"modified_method":"@Override\n    public boolean isGranted(@Nonnull String oakPath, @Nonnull String jcrActions) {\n        final String[] actions = Text.explode(jcrActions, ',', false);\n        switch (actions.length) {\n            case 0: return true;\n            case 1:\n                return grantsAction(oakPath, actions[0], filter(oakPath, actions[0]));\n            default:\n                for (final String action : actions) {\n                    if (!grantsAction(oakPath, action, filter(oakPath, action))) {\n                        return false;\n                    }\n                }\n                return true;\n        }\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean isGranted(long repositoryPermissions) {\n            Iterable<AggregatedPermissionProvider> providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n                @Override\n                public boolean apply(@Nullable AggregatedPermissionProvider provider) {\n                    return provider != null && provider.handlesRepositoryPermissions();\n                }\n            });\n            if (Permissions.isAggregate(repositoryPermissions)) {\n                for (long permission : Permissions.aggregates(repositoryPermissions)) {\n                    if (!grantsRepoPermission(permission, providers)) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return grantsRepoPermission(repositoryPermissions, providers);\n            }\n        }","id":11699,"modified_method":"@Override\n        public boolean isGranted(long repositoryPermissions) {\n            if (Permissions.isAggregate(repositoryPermissions)) {\n                for (long permission : Permissions.aggregates(repositoryPermissions)) {\n                    if (!grantsRepoPermission(permission, filter(null))) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return grantsRepoPermission(repositoryPermissions, filter(null));\n            }\n        }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void refresh() {\n        immutableRoot = RootFactory.createReadOnlyRoot(root);\n        pbp = new PrivilegeBitsProvider(immutableRoot);\n\n        for (PermissionProvider pp : pps) {\n            pp.refresh();\n        }\n    }","id":11700,"modified_method":"@Override\n    public void refresh() {\n        immutableRoot = RootFactory.createReadOnlyRoot(root);\n        privilegeBitsProvider = new PrivilegeBitsProvider(immutableRoot);\n\n        for (PermissionProvider pp : pps) {\n            pp.refresh();\n        }\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"CompositePermissionProvider(@Nonnull Root root, @Nonnull List<AggregatedPermissionProvider> pps) {\n        this.root = root;\n        this.pps = pps;\n\n        repositoryPermission = new CompositeRepositoryPermission();\n        immutableRoot = RootFactory.createReadOnlyRoot(root);\n        pbp = new PrivilegeBitsProvider(immutableRoot);\n    }","id":11701,"modified_method":"CompositePermissionProvider(@Nonnull Root root, @Nonnull List<AggregatedPermissionProvider> pps) {\n        this.root = root;\n        this.pps = pps;\n\n        repositoryPermission = new CompositeRepositoryPermission();\n        immutableRoot = RootFactory.createReadOnlyRoot(root);\n        privilegeBitsProvider = new PrivilegeBitsProvider(immutableRoot);\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean grantsPermission(long permission, @Nullable PropertyState property) {\n            Iterator<Map.Entry<AggregatedPermissionProvider, TreePermission>> it = map.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry<AggregatedPermissionProvider, TreePermission> entry = it.next();\n                if (entry.getKey().handles(this, permission)) {\n                    TreePermission tp = entry.getValue();\n                    boolean isGranted = (property == null) ? tp.isGranted(permission) : tp.isGranted(permission, property);\n                    if (!it.hasNext() || !isGranted) {\n                        return isGranted;\n                    }\n                }\n            }\n            return false;\n        }","id":11702,"modified_method":"private boolean grantsPermission(long permission, @Nullable PropertyState property) {\n            boolean isGranted = false;\n            for (Map.Entry<AggregatedPermissionProvider, TreePermission> entry : map.entrySet()) {\n                if (entry.getKey().handles(this, permission)) {\n                    TreePermission tp = entry.getValue();\n                    isGranted = (property == null) ? tp.isGranted(permission) : tp.isGranted(permission, property);\n                    if (!isGranted) {\n                        return false;\n                    }\n                }\n            }\n            return isGranted;\n        }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static boolean grantsAction(@Nonnull final String oakPath,\n                                        @Nonnull final String action,\n                                        @Nonnull Iterable<AggregatedPermissionProvider> providers) {\n        Iterator<AggregatedPermissionProvider> it = providers.iterator();\n        while (it.hasNext()) {\n            AggregatedPermissionProvider pp = it.next();\n            boolean isGranted = pp.isGranted(oakPath, action);\n            if (!it.hasNext() || !isGranted) {\n                return isGranted;\n            }\n        }\n        return false;\n    }","id":11703,"modified_method":"private static boolean grantsAction(@Nonnull final String oakPath,\n                                        @Nonnull final String action,\n                                        @Nonnull Iterable<AggregatedPermissionProvider> providers) {\n        Iterator<AggregatedPermissionProvider> it = providers.iterator();\n        boolean isGranted = false;\n        while (it.hasNext()) {\n            AggregatedPermissionProvider pp = it.next();\n            isGranted = pp.isGranted(oakPath, action);\n            if (!isGranted) {\n                return false;\n            }\n        }\n        return isGranted;\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean canRead() {\n            if (canRead == null) {\n                canRead = false;\n                Iterator<Map.Entry<AggregatedPermissionProvider, TreePermission>> it = map.entrySet().iterator();\n                while (it.hasNext()) {\n                    Map.Entry<AggregatedPermissionProvider, TreePermission> entry = it.next();\n                    TreePermission tp = entry.getValue();\n                    if (entry.getKey().handles(tp, Permissions.READ_NODE)) {\n                        boolean isGranted = entry.getValue().canRead();\n                        if (!it.hasNext() || !isGranted) {\n                            this.canRead = isGranted;\n                            break;\n                        }\n                    }\n                }\n            }\n            return canRead;\n        }","id":11704,"modified_method":"@Override\n        public boolean canRead() {\n            if (canRead == null) {\n                canRead = false;\n                for (Map.Entry<AggregatedPermissionProvider, TreePermission> entry : map.entrySet()) {\n                    TreePermission tp = entry.getValue();\n                    if (entry.getKey().handles(tp, Permissions.READ_NODE)) {\n                        canRead = entry.getValue().canRead();\n                        if (!canRead) {\n                            break;\n                        }\n                    }\n                }\n            }\n            return canRead;\n        }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static boolean grantsPermission(@Nonnull final Tree parent,\n                                            @Nullable PropertyState property,\n                                            final long permission,\n                                            @Nonnull Iterable<AggregatedPermissionProvider> providers) {\n        Iterator<AggregatedPermissionProvider> it = providers.iterator();\n        while (it.hasNext()) {\n            AggregatedPermissionProvider pp = it.next();\n            boolean isGranted = pp.isGranted(parent, property, permission);\n            if (!it.hasNext() || !isGranted) {\n                return isGranted;\n            }\n        }\n        return false;\n    }","id":11705,"modified_method":"private static boolean grantsPermission(@Nonnull final Tree parent,\n                                            @Nullable PropertyState property,\n                                            final long permission,\n                                            @Nonnull Iterable<AggregatedPermissionProvider> providers) {\n        Iterator<AggregatedPermissionProvider> it = providers.iterator();\n        boolean isGranted = false;\n        while (it.hasNext()) {\n            AggregatedPermissionProvider pp = it.next();\n            isGranted = pp.isGranted(parent, property, permission);\n            if (!isGranted) {\n                break;\n            }\n        }\n        return isGranted;\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static boolean grantsRepoPermission(long permission, @Nonnull Iterable<AggregatedPermissionProvider> providers) {\n        Iterator<AggregatedPermissionProvider> it = providers.iterator();\n        while (it.hasNext()) {\n            AggregatedPermissionProvider pp = it.next();\n            boolean isGranted = pp.getRepositoryPermission().isGranted(permission);\n            if (!it.hasNext() || !isGranted) {\n                return isGranted;\n            }\n\n        }\n        return false;\n    }","id":11706,"modified_method":"private static boolean grantsRepoPermission(long permission, @Nonnull Iterable<AggregatedPermissionProvider> providers) {\n        Iterator<AggregatedPermissionProvider> it = providers.iterator();\n        boolean isGranted = false;\n        while (it.hasNext()) {\n            AggregatedPermissionProvider pp = it.next();\n            isGranted = pp.getRepositoryPermission().isGranted(permission);\n            if (!isGranted) {\n                return false;\n            }\n\n        }\n        return isGranted;\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean hasPrivileges(@Nullable final Tree tree, @Nonnull String... privilegeNames) {\n        for (final String privName : pbp.getAggregatedPrivilegeNames(privilegeNames)) {\n            Iterable<AggregatedPermissionProvider> providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n                @Override\n                public boolean apply(@Nullable AggregatedPermissionProvider pp) {\n                    return pp != null && ((tree == null) ? pp.handlesRepositoryPermissions() : pp.handles(tree, pbp.getBits(privName)));\n                }\n            });\n            for (AggregatedPermissionProvider pp : providers) {\n                if (!pp.hasPrivileges(tree, privName)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }","id":11707,"modified_method":"@Override\n    public boolean hasPrivileges(@Nullable final Tree tree, @Nonnull String... privilegeNames) {\n        for (final String privName : privilegeBitsProvider.getAggregatedPrivilegeNames(privilegeNames)) {\n            Iterable<AggregatedPermissionProvider> providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n                @Override\n                public boolean apply(AggregatedPermissionProvider pp) {\n                    // the permissionprovider is never null\n                    return (tree == null) ? pp.handlesRepositoryPermissions() : pp.handles(tree, privilegeBitsProvider.getBits(privName));\n                }\n            });\n            for (AggregatedPermissionProvider pp : providers) {\n                if (!pp.hasPrivileges(tree, privName)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public Set<String> getPrivileges(@Nullable final Tree tree) {\n        PrivilegeBits result = null;\n        Iterable<AggregatedPermissionProvider> providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n            @Override\n            public boolean apply(@Nullable AggregatedPermissionProvider pp) {\n                return pp != null && ((tree != null) || pp.handlesRepositoryPermissions());\n            }\n        });\n        for (AggregatedPermissionProvider pp : providers) {\n            PrivilegeBits privs = pbp.getBits(pp.getPrivileges(tree));\n            if (result == null) {\n                result = PrivilegeBits.getInstance();\n                result.add(privs);\n            } else {\n                // FIXME: only retain privs that are handled by prev. pp (and thus are denied)\n                result.retain(privs);\n            }\n        }\n        return pbp.getPrivilegeNames(result);\n    }","id":11708,"modified_method":"@Nonnull\n    @Override\n    public Set<String> getPrivileges(@Nullable final Tree tree) {\n        PrivilegeBits result = null;\n        for (AggregatedPermissionProvider pp : filter(tree)) {\n            PrivilegeBits privs = privilegeBitsProvider.getBits(pp.getPrivileges(tree));\n            if (result == null) {\n                result = PrivilegeBits.getInstance();\n                result.add(privs);\n            } else {\n                // FIXME: only retain privs that are handled by prev. pp (and thus are denied)\n                result.retain(privs);\n            }\n        }\n        return privilegeBitsProvider.getPrivilegeNames(result);\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isGranted(@Nonnull final Tree parent, @Nullable PropertyState property, final long permissions) {\n        if (Permissions.isAggregate(permissions)) {\n            for (final long permission : Permissions.aggregates(permissions)) {\n                Iterable<AggregatedPermissionProvider> providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n                    @Override\n                    public boolean apply(@Nullable AggregatedPermissionProvider pp) {\n                        return pp != null && pp.handles(parent, permission);\n                    }\n                });\n                if (!grantsPermission(parent, property, permission, providers)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            Iterable<AggregatedPermissionProvider> providers = Iterables.filter(pps, new Predicate<AggregatedPermissionProvider>() {\n                @Override\n                public boolean apply(@Nullable AggregatedPermissionProvider pp) {\n                    return pp != null && pp.handles(parent, permissions);\n                }\n            });\n            return grantsPermission(parent, property, permissions, providers);\n        }\n    }","id":11709,"modified_method":"@Override\n    public boolean isGranted(@Nonnull Tree parent, @Nullable PropertyState property, long permissions) {\n        if (Permissions.isAggregate(permissions)) {\n            for (final long permission : Permissions.aggregates(permissions)) {\n                if (!grantsPermission(parent, property, permission, filter(parent, permission))) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return grantsPermission(parent, property, permissions, filter(parent, permissions));\n        }\n    }","commit_id":"51a6e8adcf6ecfe17fd943e098ef4ee316ed38f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public boolean endProcessing(String status)\n\t\tthrows KettleException\n\t{\n\t\tif (preview) return true;\n\t\t\n\t\tResult result = getResult();\n\n\t\tlogDate     = new Date();\n\t\t\n\t\t// Change the logging back to stream...\n\t\tString log_string = null;\n\t\tif (transMeta.isLogfieldUsed())\n\t\t{\n\t\t\tlog_string = log.getString();\n\t\t\tlog_string+=Const.CR+Messages.getString(\"Trans.Log.Status.End\"); //$NON-NLS-1$\n\t\t\tlog.setString(\"\"); //$NON-NLS-1$\n\t\t\tlog.endStringCapture();\n\t\t}\n\t\t\n\t\tDatabaseMeta logcon = transMeta.getLogConnection();\n\t\tif (logcon!=null)\n\t\t{\n\t\t\tDatabase ldb = new Database(logcon);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tldb.connect();\n\t\t\t\t\n\t\t\t\tldb.writeLogRecord(transMeta.getLogTable(), transMeta.isBatchIdUsed(), transMeta.getBatchId(), false, transMeta.getName(), status, \n\t\t\t\t\tresult.getNrLinesRead(), \n\t\t\t\t\tresult.getNrLinesWritten(),\n\t\t\t\t\tresult.getNrLinesUpdated(),\n\t\t\t\t\tresult.getNrLinesInput()+result.getNrFilesRetrieved(),\n\t\t\t\t\tresult.getNrLinesOutput(),\n\t\t\t\t\tresult.getNrErrors(), \n\t\t\t\t    startDate, endDate, logDate, depDate,currentDate,\n\t\t\t\t\tlog_string\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleException(Messages.getString(\"Trans.Exception.ErrorWritingLogRecordToTable2\")+transMeta.getLogTable()+\"]\", e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tldb.disconnect();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":11710,"modified_method":"public boolean endProcessing(String status)\n\t\tthrows KettleException\n\t{\n\t\tif (preview) return true;\n\t\t\n\t\tResult result = getResult();\n\n\t\tlogDate     = new Date();\n\t\t\n\t\t// Change the logging back to stream...\n\t\tString log_string = null;\n\t\tif (transMeta.isLogfieldUsed())\n\t\t{\n\t\t\tlog_string = log.getString();\n\t\t\tlog_string+=Const.CR+Messages.getString(\"Trans.Log.Status.End\"); //$NON-NLS-1$\n\t\t\tlog.setString(\"\"); //$NON-NLS-1$\n\t\t\tlog.endStringCapture();\n\t\t}\n\t\t\n\t\tDatabaseMeta logcon = transMeta.getLogConnection();\n\t\tif (logcon!=null)\n\t\t{\n\t\t\tDatabase ldb = new Database(logcon);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tldb.connect();\n\t\t\t\t\n\t\t\t\tldb.writeLogRecord(transMeta.getLogTable(), transMeta.isBatchIdUsed(), transMeta.getBatchId(), false, transMeta.getName(), status, \n\t\t\t\t\tresult.getNrLinesRead(), \n\t\t\t\t\tresult.getNrLinesWritten(),\n\t\t\t\t\tresult.getNrLinesUpdated(),\n\t\t\t\t\tresult.getNrLinesInput()+result.getNrFilesRetrieved(),\n\t\t\t\t\tresult.getNrLinesOutput(),\n\t\t\t\t\tresult.getNrErrors(), \n\t\t\t\t    startDate, endDate, logDate, depDate,currentDate,\n\t\t\t\t\tlog_string\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleException(Messages.getString(\"Trans.Exception.ErrorWritingLogRecordToTable\")+transMeta.getLogTable()+\"]\", e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tldb.disconnect();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"dafcbd24ab463fb5d98150f6175cb884ed6cb47d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void printStats(int seconds)\n\t{\n\t\tint i;\n\t\tBaseStep thr;\n\t\tlong proc;\n\t\t\n\t\tlog.logBasic(toString(), \" \"); //$NON-NLS-1$\n\t\tif (steps==null) return;\n\t\t\n\t\tfor (i=0;i<steps.size();i++)\n\t\t{\n\t\t\tStepMetaDataCombi sid = (StepMetaDataCombi)steps.get(i);\n\t\t\tthr=(BaseStep)sid.step;\n\t\t\tproc=thr.getProcessed();\n\t\t\tif (seconds!=0)\n\t\t\t{\n\t\t\t\tif (thr.getErrors()==0)\n\t\t\t\t{\n\t\t\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ProcessSuccessfullyInfo\")+thr.getStepname()+\"'.\"+thr.getCopy()+\" ended successfully, processed \"+proc+\" lines. (\"+(proc/seconds)+\" lines/s)\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.ProcessErrorInfo\")+thr.getStepname()+\"'.\"+thr.getCopy()+\" ended with \"+thr.getErrors()+\" errors after \"+proc+\" lines. (\"+(proc/seconds)+\" lines/s)\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (thr.getErrors()==0)\n\t\t\t\t{\n\t\t\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ProcessSuccessfullyInfo2\")+thr.getStepname()+\"'.\"+thr.getCopy()+\" ended successfully, processed \"+proc+\" lines in \"+seconds+\" seconds.\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.ProcessErrorInfo\")+thr.getStepname()+\"'.\"+thr.getCopy()+\" ended with \"+thr.getErrors()+\" errors after processing \"+proc+\" lines in \"+seconds+\" seconds.\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","id":11711,"modified_method":"public void printStats(int seconds)\n\t{\n\t\tint i;\n\t\tBaseStep thr;\n\t\tlong proc;\n\t\t\n\t\tlog.logBasic(toString(), \" \"); //$NON-NLS-1$\n\t\tif (steps==null) return;\n\t\t\n\t\tfor (i=0;i<steps.size();i++)\n\t\t{\n\t\t\tStepMetaDataCombi sid = (StepMetaDataCombi)steps.get(i);\n\t\t\tthr=(BaseStep)sid.step;\n\t\t\tproc=thr.getProcessed();\n\t\t\tif (seconds!=0)\n\t\t\t{\n\t\t\t\tif (thr.getErrors()==0)\n\t\t\t\t{\n\t\t\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ProcessSuccessfullyInfo\",thr.getStepname(),\"'.\"+thr.getCopy(),String.valueOf(proc),String.valueOf((proc/seconds)))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.ProcessErrorInfo\",thr.getStepname(),\"'.\"+thr.getCopy(),String.valueOf(thr.getErrors()),String.valueOf(proc),String.valueOf(proc/seconds))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (thr.getErrors()==0)\n\t\t\t\t{\n\t\t\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.ProcessSuccessfullyInfo\",thr.getStepname(),\"'.\"+thr.getCopy(),String.valueOf(proc),String.valueOf((proc/seconds)))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"Trans.Log.ProcessErrorInfo2\",thr.getStepname(),\"'.\"+thr.getCopy(),String.valueOf(thr.getErrors()),String.valueOf(proc),String.valueOf(seconds))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"dafcbd24ab463fb5d98150f6175cb884ed6cb47d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void beginProcessing()\n\t\tthrows KettleTransException\n\t{\n\t\ttry\n\t\t{\n\t\t\t// if (preview) return true;\n\t\t\n\t\t\tcurrentDate = new Date();\n\t\t\tlogDate     = new Date();\n\t\t\tstartDate   = Const.MIN_DATE;\n\t\t\tendDate     = currentDate;\n\t\t\tSimpleDateFormat df = new SimpleDateFormat(REPLAY_DATE_FORMAT);\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.TransformationCanBeReplayed\") + df.format(currentDate)); //$NON-NLS-1$\n            \n            Database ldb = null;\n            try\n            {\n\t\t\t\tDatabaseMeta logcon = transMeta.getLogConnection();\n    \t\t\tif (logcon!=null)\n    \t\t\t{\n    \t\t\t    ldb = new Database(logcon);\n\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.OpeningLogConnection\")+transMeta.getLogConnection()+\"]\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tldb.connect();\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// Get the date range from the logging table: from the last end_date to now. (currentDate)\n\t\t\t\t\t//\n\t\t\t\t\tRow lastr = ldb.getLastLogDate(transMeta.getLogTable(), transMeta.getName(), false, Messages.getString(\"Trans.Row.Status.End\")); //$NON-NLS-1$\n\t\t\t\t\tif (lastr!=null && lastr.size()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tValue last = lastr.getValue(0); // #0: last enddate\n\t\t\t\t\t\tif (last!=null && !last.isNull())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstartDate = last.getDate();\n\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.StartDateFound\")+startDate); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// \n\t\t\t\t\t// OK, we have a date-range.\n\t\t\t\t\t// However, perhaps we need to look at a table before we make a final judment?\n\t\t\t\t\t//\n\t\t\t\t\tif (transMeta.getMaxDateConnection()!=null && \n\t\t\t\t\t\ttransMeta.getMaxDateTable()!=null && transMeta.getMaxDateTable().length()>0 &&\n\t\t\t\t\t\ttransMeta.getMaxDateField()!=null && transMeta.getMaxDateField().length()>0\n\t\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.LookingForMaxdateConnection\")+transMeta.getMaxDateConnection()+\"]\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\tDatabaseMeta maxcon = transMeta.getMaxDateConnection();\n\t\t\t\t\t\tif (maxcon!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDatabase maxdb = new Database(maxcon);\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.OpeningMaximumDateConnection\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t\tmaxdb.connect();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Determine the endDate by looking at a field in a table...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tString sql = \"SELECT MAX(\"+transMeta.getMaxDateField()+\") FROM \"+transMeta.getMaxDateTable(); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\tRow r1 = maxdb.getOneRow(sql);\n\t\t\t\t\t\t\t\tif (r1!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OK, we have a value, what's the offset?\n\t\t\t\t\t\t\t\t\tValue maxvalue = r1.getValue(0);\n\t\t\t\t\t\t\t\t\tif (maxvalue!=null && !maxvalue.isNull() && maxvalue.getDate()!=null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.LastDateFoundOnTheMaxdateConnection\")+r1); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\tendDate.setTime( (long)( maxvalue.getDate().getTime() + ( transMeta.getMaxDateOffset()*1000 ) ));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.NoLastDateFoundOnTheMaxdateConnection\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch(KettleException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Log.ErrorConnectingToDatabase\")+transMeta.getMaxDateConnection()+\"]\", e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxdb.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.MaximumDateConnectionCouldNotBeFound\")+transMeta.getMaxDateConnection()+\"] couldn't be found!\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t// Determine the last date of all dependend tables...\n\t\t\t\t\t// Get the maximum in depdate...\n\t\t\t\t\tif (transMeta.nrDependencies()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.CheckingForMaxDependencyDate\")); //$NON-NLS-1$\n\t\t\t\t\t\t// \n\t\t\t\t\t\t// Maybe one of the tables where this transformation is dependend on has changed?\n\t\t\t\t\t\t// If so we need to change the start-date!\n\t\t\t\t\t\t//\n\t\t\t\t\t\tdepDate = Const.MIN_DATE;\n\t\t\t\t\t\tDate maxdepdate = Const.MIN_DATE;\n\t\t\t\t\t\tif (lastr!=null && lastr.size()>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tValue dep = lastr.getValue(1); // #1: last depdate\n\t\t\t\t\t\t\tif (dep!=null && !dep.isNull()) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxdepdate = dep.getDate();\n\t\t\t\t\t\t\t\tdepDate    = dep.getDate();\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor (int i=0;i<transMeta.nrDependencies();i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTransDependency td = transMeta.getDependency(i);\n\t\t\t\t\t\t\tDatabaseMeta depcon = td.getDatabase();\n\t\t\t\t\t\t\tif (depcon!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDatabase depdb = new Database(depcon);\n\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdepdb.connect();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tString sql = \"SELECT MAX(\"+td.getFieldname()+\") FROM \"+td.getTablename(); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tRow r1 = depdb.getOneRow(sql);\n\t\t\t\t\t\t\t\t\tif (r1!=null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// OK, we have a row, get the result!\n\t\t\t\t\t\t\t\t\t\tValue maxvalue = r1.getValue(0);\n\t\t\t\t\t\t\t\t\t\tif (maxvalue!=null && !maxvalue.isNull() && maxvalue.getDate()!=null)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.FoundDateFromTable\")+td.getTablename()+\".\"+td.getFieldname()+\" = \"+maxvalue.toString()); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t\t\t\t\t\t\t\t\tif ( maxvalue.getDate().getTime() > maxdepdate.getTime())\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tmaxdepdate=maxvalue.getDate();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.UnableToGetDependencyInfoFromDB\")+td.getDatabase().getName()+\".\"+td.getTablename()+\".\"+td.getFieldname()+\"]\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.UnableToGetDependencyInfoFromDB2\")+td.getDatabase().getName()+\".\"+td.getTablename()+\".\"+td.getFieldname()+\"]\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(KettleException e)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.ErrorInDatabase\")+td.getDatabase()+\"]\", e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfinally\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdepdb.disconnect();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.ConnectionCouldNotBeFound\")+td.getDatabase()+\"] couldn't be found!\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.Maxdepdate\")+(new Value(\"maxdepdate\", maxdepdate)).toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// OK, so we now have the maximum depdate;\n\t\t\t\t\t\t// If it is larger, it means we have to read everything back in again.\n\t\t\t\t\t\t// Maybe something has changed that we need!\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif (maxdepdate.getTime() > depDate.getTime())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdepDate = maxdepdate;\n\t\t\t\t\t\t\tstartDate = Const.MIN_DATE;\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdepDate = currentDate;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// See if we have to add a batch id...\n\t\t\t\t\tValue id_batch = new Value(\"ID_BATCH\", (long)1); //$NON-NLS-1$\n\t\t\t\t\tif (transMeta.isBatchIdUsed())\n\t\t\t\t\t{\n\t\t\t\t\t\tldb.getNextValue(transMeta.getCounters(), transMeta.getLogTable(), id_batch);\n\t\t\t\t\t\ttransMeta.setBatchId( id_batch.getInteger() );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n                // OK, now we have a date-range.  See if we need to set a maximum!\n                if (transMeta.getMaxDateDifference()>0.0 && // Do we have a difference specified? \n                    startDate.getTime() > Const.MIN_DATE.getTime() // Is the startdate > Minimum?\n                    )\n                {\n                    // See if the end-date is larger then Start_date + DIFF?\n                    Date maxdesired = new Date( startDate.getTime()+((long)transMeta.getMaxDateDifference()*1000) );\n                    \n                    // If this is the case: lower the end-date. Pick up the next 'region' next time around.\n                    // We do this to limit the workload in a single update session (e.g. for large fact tables)\n                    // \n                    if ( endDate.compareTo( maxdesired )>0) endDate = maxdesired;\n                }\n\n                if (logcon!=null && transMeta.getLogTable()!=null && transMeta.getName()!=null)\n                {\n                    ldb.writeLogRecord(transMeta.getLogTable(), \n                               transMeta.isBatchIdUsed(), \n                               transMeta.getBatchId(), \n                               false, \n                               transMeta.getName(), \n                               Messages.getString(\"Trans.Dialog.Description.Start\"),  //$NON-NLS-1$\n                               0L, 0L, 0L, 0L, 0L, 0L, \n                               startDate, endDate, logDate, depDate,currentDate,\n                               null\n                             );\n                }\n                \n            }\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.ErrorWritingLogRecordToTable\")+transMeta.getLogTable()+\"]\", e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (ldb!=null) ldb.disconnect();\n\t\t\t}\n            \n\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.UnableToBeginProcessingTransformation\"), e); //$NON-NLS-1$\n\t\t}\n\t}","id":11712,"modified_method":"public void beginProcessing()\n\t\tthrows KettleTransException\n\t{\n\t\ttry\n\t\t{\n\t\t\t// if (preview) return true;\n\t\t\n\t\t\tcurrentDate = new Date();\n\t\t\tlogDate     = new Date();\n\t\t\tstartDate   = Const.MIN_DATE;\n\t\t\tendDate     = currentDate;\n\t\t\tSimpleDateFormat df = new SimpleDateFormat(REPLAY_DATE_FORMAT);\n\t\t\tlog.logBasic(toString(), Messages.getString(\"Trans.Log.TransformationCanBeReplayed\") + df.format(currentDate)); //$NON-NLS-1$\n            \n            Database ldb = null;\n            try\n            {\n\t\t\t\tDatabaseMeta logcon = transMeta.getLogConnection();\n    \t\t\tif (logcon!=null)\n    \t\t\t{\n    \t\t\t    ldb = new Database(logcon);\n\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.OpeningLogConnection\",\"\"+transMeta.getLogConnection())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tldb.connect();\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// Get the date range from the logging table: from the last end_date to now. (currentDate)\n\t\t\t\t\t//\n\t\t\t\t\tRow lastr = ldb.getLastLogDate(transMeta.getLogTable(), transMeta.getName(), false, Messages.getString(\"Trans.Row.Status.End\")); //$NON-NLS-1$\n\t\t\t\t\tif (lastr!=null && lastr.size()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tValue last = lastr.getValue(0); // #0: last enddate\n\t\t\t\t\t\tif (last!=null && !last.isNull())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstartDate = last.getDate();\n\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.StartDateFound\")+startDate); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// \n\t\t\t\t\t// OK, we have a date-range.\n\t\t\t\t\t// However, perhaps we need to look at a table before we make a final judment?\n\t\t\t\t\t//\n\t\t\t\t\tif (transMeta.getMaxDateConnection()!=null && \n\t\t\t\t\t\ttransMeta.getMaxDateTable()!=null && transMeta.getMaxDateTable().length()>0 &&\n\t\t\t\t\t\ttransMeta.getMaxDateField()!=null && transMeta.getMaxDateField().length()>0\n\t\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.LookingForMaxdateConnection\",\"\"+transMeta.getMaxDateConnection())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\tDatabaseMeta maxcon = transMeta.getMaxDateConnection();\n\t\t\t\t\t\tif (maxcon!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDatabase maxdb = new Database(maxcon);\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.OpeningMaximumDateConnection\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t\tmaxdb.connect();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Determine the endDate by looking at a field in a table...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tString sql = \"SELECT MAX(\"+transMeta.getMaxDateField()+\") FROM \"+transMeta.getMaxDateTable(); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\tRow r1 = maxdb.getOneRow(sql);\n\t\t\t\t\t\t\t\tif (r1!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OK, we have a value, what's the offset?\n\t\t\t\t\t\t\t\t\tValue maxvalue = r1.getValue(0);\n\t\t\t\t\t\t\t\t\tif (maxvalue!=null && !maxvalue.isNull() && maxvalue.getDate()!=null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.LastDateFoundOnTheMaxdateConnection\")+r1); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\tendDate.setTime( (long)( maxvalue.getDate().getTime() + ( transMeta.getMaxDateOffset()*1000 ) ));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t    log.logDetailed(toString(), Messages.getString(\"Trans.Log.NoLastDateFoundOnTheMaxdateConnection\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch(KettleException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.ErrorConnectingToDatabase\",\"\"+transMeta.getMaxDateConnection()), e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxdb.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.MaximumDateConnectionCouldNotBeFound\",\"\"+transMeta.getMaxDateConnection())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t// Determine the last date of all dependend tables...\n\t\t\t\t\t// Get the maximum in depdate...\n\t\t\t\t\tif (transMeta.nrDependencies()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.CheckingForMaxDependencyDate\")); //$NON-NLS-1$\n\t\t\t\t\t\t// \n\t\t\t\t\t\t// Maybe one of the tables where this transformation is dependend on has changed?\n\t\t\t\t\t\t// If so we need to change the start-date!\n\t\t\t\t\t\t//\n\t\t\t\t\t\tdepDate = Const.MIN_DATE;\n\t\t\t\t\t\tDate maxdepdate = Const.MIN_DATE;\n\t\t\t\t\t\tif (lastr!=null && lastr.size()>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tValue dep = lastr.getValue(1); // #1: last depdate\n\t\t\t\t\t\t\tif (dep!=null && !dep.isNull()) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxdepdate = dep.getDate();\n\t\t\t\t\t\t\t\tdepDate    = dep.getDate();\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor (int i=0;i<transMeta.nrDependencies();i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTransDependency td = transMeta.getDependency(i);\n\t\t\t\t\t\t\tDatabaseMeta depcon = td.getDatabase();\n\t\t\t\t\t\t\tif (depcon!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDatabase depdb = new Database(depcon);\n\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdepdb.connect();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tString sql = \"SELECT MAX(\"+td.getFieldname()+\") FROM \"+td.getTablename(); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tRow r1 = depdb.getOneRow(sql);\n\t\t\t\t\t\t\t\t\tif (r1!=null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// OK, we have a row, get the result!\n\t\t\t\t\t\t\t\t\t\tValue maxvalue = r1.getValue(0);\n\t\t\t\t\t\t\t\t\t\tif (maxvalue!=null && !maxvalue.isNull() && maxvalue.getDate()!=null)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.FoundDateFromTable\")+td.getTablename()+\".\"+td.getFieldname()+\" = \"+maxvalue.toString()); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t\t\t\t\t\t\t\t\tif ( maxvalue.getDate().getTime() > maxdepdate.getTime())\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tmaxdepdate=maxvalue.getDate();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.UnableToGetDependencyInfoFromDB\",td.getDatabase().getName()+\".\",td.getTablename()+\".\",td.getFieldname())); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.UnableToGetDependencyInfoFromDB\",td.getDatabase().getName()+\".\",td.getTablename()+\".\",td.getFieldname())); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(KettleException e)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.ErrorInDatabase\",\"\"+td.getDatabase()), e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfinally\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdepdb.disconnect();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.ConnectionCouldNotBeFound\",\"\"+td.getDatabase())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"Trans.Log.Maxdepdate\")+(new Value(\"maxdepdate\", maxdepdate)).toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// OK, so we now have the maximum depdate;\n\t\t\t\t\t\t// If it is larger, it means we have to read everything back in again.\n\t\t\t\t\t\t// Maybe something has changed that we need!\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif (maxdepdate.getTime() > depDate.getTime())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdepDate = maxdepdate;\n\t\t\t\t\t\t\tstartDate = Const.MIN_DATE;\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdepDate = currentDate;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// See if we have to add a batch id...\n\t\t\t\t\tValue id_batch = new Value(\"ID_BATCH\", (long)1); //$NON-NLS-1$\n\t\t\t\t\tif (transMeta.isBatchIdUsed())\n\t\t\t\t\t{\n\t\t\t\t\t\tldb.getNextValue(transMeta.getCounters(), transMeta.getLogTable(), id_batch);\n\t\t\t\t\t\ttransMeta.setBatchId( id_batch.getInteger() );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n                // OK, now we have a date-range.  See if we need to set a maximum!\n                if (transMeta.getMaxDateDifference()>0.0 && // Do we have a difference specified? \n                    startDate.getTime() > Const.MIN_DATE.getTime() // Is the startdate > Minimum?\n                    )\n                {\n                    // See if the end-date is larger then Start_date + DIFF?\n                    Date maxdesired = new Date( startDate.getTime()+((long)transMeta.getMaxDateDifference()*1000) );\n                    \n                    // If this is the case: lower the end-date. Pick up the next 'region' next time around.\n                    // We do this to limit the workload in a single update session (e.g. for large fact tables)\n                    // \n                    if ( endDate.compareTo( maxdesired )>0) endDate = maxdesired;\n                }\n\n                if (logcon!=null && transMeta.getLogTable()!=null && transMeta.getName()!=null)\n                {\n                    ldb.writeLogRecord(transMeta.getLogTable(), \n                               transMeta.isBatchIdUsed(), \n                               transMeta.getBatchId(), \n                               false, \n                               transMeta.getName(), \n                               Messages.getString(\"Trans.Dialog.Description.Start\"),  //$NON-NLS-1$\n                               0L, 0L, 0L, 0L, 0L, 0L, \n                               startDate, endDate, logDate, depDate,currentDate,\n                               null\n                             );\n                }\n                \n            }\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.ErrorWritingLogRecordToTable\",transMeta.getLogTable()), e); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (ldb!=null) ldb.disconnect();\n\t\t\t}\n            \n\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tthrow new KettleTransException(Messages.getString(\"Trans.Exception.UnableToBeginProcessingTransformation\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"dafcbd24ab463fb5d98150f6175cb884ed6cb47d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * @param inTx\n     * @throws Exception If failed.\n     */\n    private void checkTtl(boolean inTx) throws Exception {\n        int ttl = 1000;\n\n        final ExpiryPolicy expiry = new TouchedExpiryPolicy(new Duration(MILLISECONDS, ttl));\n\n        final IgniteCache<Integer, Integer> c = grid(0).jcache(null);\n\n        final Integer key = primaryKeys(jcache(0), 1, 0).get(0);\n\n        c.put(key, 1);\n\n        GridCacheEntryEx entry = ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n        assert entry != null;\n\n        assertEquals(0, entry.ttl());\n        assertEquals(0, entry.expireTime());\n\n        long startTime = System.currentTimeMillis();\n\n        if (inTx) {\n            // Rollback transaction for the first time.\n            IgniteTx tx = grid(0).transactions().txStart();\n\n            try {\n                grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 1);\n            }\n            finally {\n                tx.rollback();\n            }\n\n            entry = ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n            assertEquals(0, entry.ttl());\n            assertEquals(0, entry.expireTime());\n        }\n\n        // Now commit transaction and check that ttl and expire time have been saved.\n        IgniteTx tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 1);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        long[] expireTimes = new long[gridCount()];\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                GridCacheEntryEx<Object, Object> curEntry =\n                    ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n\n                assert curEntry.expireTime() > startTime;\n\n                expireTimes[i] = curEntry.expireTime();\n            }\n        }\n\n        // One more update from the same cache entry to ensure that expire time is shifted forward.\n        U.sleep(100);\n\n        tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 2);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                GridCacheEntryEx<Object, Object> curEntry =\n                    ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n\n                assert curEntry.expireTime() > startTime;\n\n                expireTimes[i] = curEntry.expireTime();\n            }\n        }\n\n        // And one more direct update to ensure that expire time is shifted forward.\n        U.sleep(100);\n\n        tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 3);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                GridCacheEntryEx<Object, Object> curEntry =\n                    ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n\n                assert curEntry.expireTime() > startTime;\n\n                expireTimes[i] = curEntry.expireTime();\n            }\n        }\n\n        // And one more update to ensure that ttl is not changed and expire time is not shifted forward.\n        U.sleep(100);\n\n        log.info(\"Put 4\");\n\n        tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            c.put(key, 4);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        log.info(\"Put 4 done\");\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                GridCacheEntryEx<Object, Object> curEntry =\n                    ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n                assertEquals(expireTimes[i], curEntry.expireTime());\n            }\n        }\n\n        // Avoid reloading from store.\n        map.remove(key);\n\n        assertTrue(GridTestUtils.waitForCondition(new GridAbsPredicateX() {\n            @SuppressWarnings(\"unchecked\")\n            @Override public boolean applyx() throws IgniteCheckedException {\n                try {\n                    if (c.get(key) != null)\n                        return false;\n\n                    // Get \"cache\" field from GridCacheProxyImpl.\n                    GridCacheAdapter c0 = cacheFromCtx(c);\n\n                    if (!c0.context().deferredDelete()) {\n                        GridCacheEntryEx e0 = c0.peekEx(key);\n\n                        return e0 == null || (e0.rawGet() == null && e0.valueBytes() == null);\n                    }\n                    else\n                        return true;\n                }\n                catch (GridCacheEntryRemovedException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }, Math.min(ttl * 10, getTestTimeout())));\n\n        // Ensure that old TTL and expire time are not longer \"visible\".\n        entry = ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n        assertEquals(0, entry.ttl());\n        assertEquals(0, entry.expireTime());\n    }","id":11713,"modified_method":"/**\n     * @param inTx {@code true} for tx.\n     * @throws Exception If failed.\n     */\n    private void checkTtl(boolean inTx) throws Exception {\n        int ttl = 1000;\n\n        final ExpiryPolicy expiry = new TouchedExpiryPolicy(new Duration(MILLISECONDS, ttl));\n\n        final IgniteCache<Integer, Integer> c = grid(0).jcache(null);\n\n        final Integer key = primaryKeys(jcache(0), 1, 0).get(0);\n\n        c.put(key, 1);\n\n        GridCacheAdapter<Object, Object> c0 = ((IgniteKernal)grid(0)).internalCache();\n\n        if (c0.isNear())\n            c0 = c0.context().near().dht();\n\n        GridCacheEntryEx entry = c0.entryEx(key);\n\n        assert entry != null;\n\n        assertEquals(0, entry.ttl());\n        assertEquals(0, entry.expireTime());\n\n        long startTime = System.currentTimeMillis();\n\n        if (inTx) {\n            // Rollback transaction for the first time.\n            IgniteTx tx = grid(0).transactions().txStart();\n\n            try {\n                grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 1);\n            }\n            finally {\n                tx.rollback();\n            }\n\n            entry = ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n            assertEquals(0, entry.ttl());\n            assertEquals(0, entry.expireTime());\n        }\n\n        // Now commit transaction and check that ttl and expire time have been saved.\n        IgniteTx tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 1);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        long[] expireTimes = new long[gridCount()];\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                c0 = ((IgniteKernal)grid(i)).internalCache();\n\n                if (c0.isNear())\n                    c0 = c0.context().near().dht();\n\n                GridCacheEntryEx<Object, Object> curEntry = c0.peekEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n\n                assert curEntry.expireTime() > startTime;\n\n                expireTimes[i] = curEntry.expireTime();\n            }\n        }\n\n        // One more update from the same cache entry to ensure that expire time is shifted forward.\n        U.sleep(100);\n\n        tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 2);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                c0 = ((IgniteKernal)grid(i)).internalCache();\n\n                if (c0.isNear())\n                    c0 = c0.context().near().dht();\n\n                GridCacheEntryEx<Object, Object> curEntry = c0.peekEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n\n                assert curEntry.expireTime() > startTime;\n\n                expireTimes[i] = curEntry.expireTime();\n            }\n        }\n\n        // And one more direct update to ensure that expire time is shifted forward.\n        U.sleep(100);\n\n        tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            grid(0).jcache(null).withExpiryPolicy(expiry).put(key, 3);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                c0 = ((IgniteKernal)grid(i)).internalCache();\n\n                if (c0.isNear())\n                    c0 = c0.context().near().dht();\n\n                GridCacheEntryEx<Object, Object> curEntry = c0.peekEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n\n                assert curEntry.expireTime() > startTime;\n\n                expireTimes[i] = curEntry.expireTime();\n            }\n        }\n\n        // And one more update to ensure that ttl is not changed and expire time is not shifted forward.\n        U.sleep(100);\n\n        log.info(\"Put 4\");\n\n        tx = inTx ? grid(0).transactions().txStart() : null;\n\n        try {\n            c.put(key, 4);\n        }\n        finally {\n            if (tx != null)\n                tx.commit();\n        }\n\n        log.info(\"Put 4 done\");\n\n        for (int i = 0; i < gridCount(); i++) {\n            if (grid(i).affinity(null).isPrimaryOrBackup(grid(i).localNode(), key)) {\n                c0 = ((IgniteKernal)grid(i)).internalCache();\n\n                if (c0.isNear())\n                    c0 = c0.context().near().dht();\n\n                GridCacheEntryEx<Object, Object> curEntry = c0.peekEx(key);\n\n                assertEquals(ttl, curEntry.ttl());\n                assertEquals(expireTimes[i], curEntry.expireTime());\n            }\n        }\n\n        // Avoid reloading from store.\n        map.remove(key);\n\n        assertTrue(GridTestUtils.waitForCondition(new GridAbsPredicateX() {\n            @SuppressWarnings(\"unchecked\")\n            @Override public boolean applyx() throws IgniteCheckedException {\n                try {\n                    if (c.get(key) != null)\n                        return false;\n\n                    // Get \"cache\" field from GridCacheProxyImpl.\n                    GridCacheAdapter c0 = cacheFromCtx(c);\n\n                    if (!c0.context().deferredDelete()) {\n                        GridCacheEntryEx e0 = c0.peekEx(key);\n\n                        return e0 == null || (e0.rawGet() == null && e0.valueBytes() == null);\n                    }\n                    else\n                        return true;\n                }\n                catch (GridCacheEntryRemovedException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }, Math.min(ttl * 10, getTestTimeout())));\n\n        // Ensure that old TTL and expire time are not longer \"visible\".\n        entry = ((IgniteKernal)grid(0)).internalCache().entryEx(key);\n\n        assertEquals(0, entry.ttl());\n        assertEquals(0, entry.expireTime());\n    }","commit_id":"c443245b12e7e4272ab006c51851396374877ff8","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Get data block for specified file ID and block index.\n     *\n     * @param fileInfo File info.\n     * @param path Path reading from.\n     * @param blockIdx Block index.\n     * @param secReader Optional secondary file system reader.\n     * @return Requested data block or {@code null} if nothing found.\n     * @throws IgniteCheckedException If failed.\n     */\n    @Nullable public IgniteInternalFuture<byte[]> dataBlock(final GridGgfsFileInfo fileInfo, final IgniteFsPath path,\n        final long blockIdx, @Nullable final IgniteFsReader secReader)\n        throws IgniteCheckedException {\n        //assert validTxState(any); // Allow this method call for any transaction state.\n\n        assert fileInfo != null;\n        assert blockIdx >= 0;\n\n        // Schedule block request BEFORE prefetch requests.\n        final GridGgfsBlockKey key = blockKey(blockIdx, fileInfo);\n\n//        TODO ignite-96\n//        if (log.isDebugEnabled()) {\n//            Entry<GridGgfsBlockKey, byte[]> entry = dataCachePrj.entry(key);\n//\n//            assert entry != null;\n//\n//            if (!entry.primary() && !entry.backup())\n//                log.debug(\"Reading non-local data block [path=\" + path + \", fileInfo=\" + fileInfo +\n//                    \", blockIdx=\" + blockIdx + ']');\n//        }\n\n        IgniteInternalFuture<byte[]> fut = dataCachePrj.getAsync(key);\n\n        if (secReader != null) {\n            fut = fut.chain(new CX1<IgniteInternalFuture<byte[]>, byte[]>() {\n                @Override public byte[] applyx(IgniteInternalFuture<byte[]> fut) throws IgniteCheckedException {\n                    byte[] res = fut.get();\n\n                    if (res == null) {\n                        GridFutureAdapter<byte[]> rmtReadFut = new GridFutureAdapter<>(ggfsCtx.kernalContext());\n\n                        IgniteInternalFuture<byte[]> oldRmtReadFut = rmtReadFuts.putIfAbsent(key, rmtReadFut);\n\n                        if (oldRmtReadFut == null) {\n                            try {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"Reading non-local data block in the secondary file system [path=\" +\n                                        path + \", fileInfo=\" + fileInfo + \", blockIdx=\" + blockIdx + ']');\n\n                                int blockSize = fileInfo.blockSize();\n\n                                long pos = blockIdx * blockSize; // Calculate position for Hadoop\n\n                                res = new byte[blockSize];\n\n                                int read = 0;\n\n                                synchronized (secReader) {\n                                    try {\n                                        // Delegate to the secondary file system.\n                                        while (read < blockSize) {\n                                            int r = secReader.read(pos + read, res, read, blockSize - read);\n\n                                            if (r < 0)\n                                                break;\n\n                                            read += r;\n                                        }\n                                    }\n                                    catch (IOException e) {\n                                        throw new IgniteCheckedException(\"Failed to read data due to secondary file system \" +\n                                            \"exception: \" + e.getMessage(), e);\n                                    }\n                                }\n\n                                // If we did not read full block at the end of the file - trim it.\n                                if (read != blockSize)\n                                    res = Arrays.copyOf(res, read);\n\n                                rmtReadFut.onDone(res);\n\n                                putSafe(key, res);\n\n                                metrics.addReadBlocks(1, 1);\n                            }\n                            catch (IgniteCheckedException e) {\n                                rmtReadFut.onDone(e);\n\n                                throw e;\n                            }\n                            finally {\n                                boolean rmv = rmtReadFuts.remove(key, rmtReadFut);\n\n                                assert rmv;\n                            }\n                        }\n                        else {\n                            // Wait for existing future to finish and get it's result.\n                            res = oldRmtReadFut.get();\n\n                            metrics.addReadBlocks(1, 0);\n                        }\n                    }\n                    else\n                        metrics.addReadBlocks(1, 0);\n\n                    return res;\n                }\n            });\n        }\n        else\n            metrics.addReadBlocks(1, 0);\n\n        return fut;\n    }","id":11714,"modified_method":"/**\n     * Get data block for specified file ID and block index.\n     *\n     * @param fileInfo File info.\n     * @param path Path reading from.\n     * @param blockIdx Block index.\n     * @param secReader Optional secondary file system reader.\n     * @return Requested data block or {@code null} if nothing found.\n     * @throws IgniteCheckedException If failed.\n     */\n    @Nullable public IgniteInternalFuture<byte[]> dataBlock(final GridGgfsFileInfo fileInfo, final IgniteFsPath path,\n        final long blockIdx, @Nullable final IgniteFsReader secReader)\n        throws IgniteCheckedException {\n        //assert validTxState(any); // Allow this method call for any transaction state.\n\n        assert fileInfo != null;\n        assert blockIdx >= 0;\n\n        // Schedule block request BEFORE prefetch requests.\n        final GridGgfsBlockKey key = blockKey(blockIdx, fileInfo);\n\n        if (log.isDebugEnabled() &&\n            dataCache.affinity().isPrimaryOrBackup(ggfsCtx.kernalContext().discovery().localNode(), key)) {\n            log.debug(\"Reading non-local data block [path=\" + path + \", fileInfo=\" + fileInfo +\n                \", blockIdx=\" + blockIdx + ']');\n        }\n\n        IgniteInternalFuture<byte[]> fut = dataCachePrj.getAsync(key);\n\n        if (secReader != null) {\n            fut = fut.chain(new CX1<IgniteInternalFuture<byte[]>, byte[]>() {\n                @Override public byte[] applyx(IgniteInternalFuture<byte[]> fut) throws IgniteCheckedException {\n                    byte[] res = fut.get();\n\n                    if (res == null) {\n                        GridFutureAdapter<byte[]> rmtReadFut = new GridFutureAdapter<>(ggfsCtx.kernalContext());\n\n                        IgniteInternalFuture<byte[]> oldRmtReadFut = rmtReadFuts.putIfAbsent(key, rmtReadFut);\n\n                        if (oldRmtReadFut == null) {\n                            try {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"Reading non-local data block in the secondary file system [path=\" +\n                                        path + \", fileInfo=\" + fileInfo + \", blockIdx=\" + blockIdx + ']');\n\n                                int blockSize = fileInfo.blockSize();\n\n                                long pos = blockIdx * blockSize; // Calculate position for Hadoop\n\n                                res = new byte[blockSize];\n\n                                int read = 0;\n\n                                synchronized (secReader) {\n                                    try {\n                                        // Delegate to the secondary file system.\n                                        while (read < blockSize) {\n                                            int r = secReader.read(pos + read, res, read, blockSize - read);\n\n                                            if (r < 0)\n                                                break;\n\n                                            read += r;\n                                        }\n                                    }\n                                    catch (IOException e) {\n                                        throw new IgniteCheckedException(\"Failed to read data due to secondary file system \" +\n                                            \"exception: \" + e.getMessage(), e);\n                                    }\n                                }\n\n                                // If we did not read full block at the end of the file - trim it.\n                                if (read != blockSize)\n                                    res = Arrays.copyOf(res, read);\n\n                                rmtReadFut.onDone(res);\n\n                                putSafe(key, res);\n\n                                metrics.addReadBlocks(1, 1);\n                            }\n                            catch (IgniteCheckedException e) {\n                                rmtReadFut.onDone(e);\n\n                                throw e;\n                            }\n                            finally {\n                                boolean rmv = rmtReadFuts.remove(key, rmtReadFut);\n\n                                assert rmv;\n                            }\n                        }\n                        else {\n                            // Wait for existing future to finish and get it's result.\n                            res = oldRmtReadFut.get();\n\n                            metrics.addReadBlocks(1, 0);\n                        }\n                    }\n                    else\n                        metrics.addReadBlocks(1, 0);\n\n                    return res;\n                }\n            });\n        }\n        else\n            metrics.addReadBlocks(1, 0);\n\n        return fut;\n    }","commit_id":"c443245b12e7e4272ab006c51851396374877ff8","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Encrypt the SHA-256 Hash of the payload, the 4 byte length, and the payload,\n     * with random padding up to the paddedSize, rounded up to the next multiple of 16.\n     *\n     * @param paddedSize minimum size of the output\n     * @param iv IV for CBC, must be 16 bytes\n     * @return null on error\n     * @deprecated unused\n     */\n    public byte[] safeEncrypt(byte payload[], SessionKey sessionKey, byte iv[], int paddedSize) {\n        if ((iv == null) || (payload == null) || (sessionKey == null) || (iv.length != 16)) return null;\n\n        int size = Hash.HASH_LENGTH \n                 + 4 // sizeof(payload)\n                 + payload.length;\n        int padding = ElGamalAESEngine.getPaddingSize(size, paddedSize);\n        \n        byte data[] = new byte[size + padding];\n        Hash h = _context.sha().calculateHash(iv);\n        \n        int cur = 0;\n        System.arraycopy(h.getData(), 0, data, cur, Hash.HASH_LENGTH);\n        cur += Hash.HASH_LENGTH;\n        \n        DataHelper.toLong(data, cur, 4, payload.length);\n        cur += 4;\n        System.arraycopy(payload, 0, data, cur, payload.length);\n        cur += payload.length;\n        byte paddingData[] = ElGamalAESEngine.getPadding(_context, size, paddedSize);\n        System.arraycopy(paddingData, 0, data, cur, paddingData.length);\n        \n        encrypt(data, 0, data, 0, sessionKey, iv, data.length);\n        return data;\n    }","id":11715,"modified_method":"/**\n     * Encrypt the SHA-256 Hash of the IV, the 4 byte length, and the payload,\n     * with random padding up to the paddedSize, rounded up to the next multiple of 16.\n     *\n     * @param paddedSize minimum size of the output\n     * @param iv IV for CBC, must be 16 bytes\n     * @return null on error\n     * @deprecated unused\n     */\n    public byte[] safeEncrypt(byte payload[], SessionKey sessionKey, byte iv[], int paddedSize) {\n        if ((iv == null) || (payload == null) || (sessionKey == null) || (iv.length != 16)) return null;\n\n        int size = Hash.HASH_LENGTH \n                 + 4 // sizeof(payload)\n                 + payload.length;\n        int padding = ElGamalAESEngine.getPaddingSize(size, paddedSize);\n        \n        byte data[] = new byte[size + padding];\n        _context.sha().calculateHash(iv, 0, 16, data, 0);\n        int cur = Hash.HASH_LENGTH;\n        \n        DataHelper.toLong(data, cur, 4, payload.length);\n        cur += 4;\n        System.arraycopy(payload, 0, data, cur, payload.length);\n        cur += payload.length;\n        byte paddingData[] = ElGamalAESEngine.getPadding(_context, size, paddedSize);\n        System.arraycopy(paddingData, 0, data, cur, paddingData.length);\n        \n        encrypt(data, 0, data, 0, sessionKey, iv, data.length);\n        return data;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * See safeEncrypt() for description.\n     * WARNING - no check for maximum length here, OOM DOS possible, fix it if you're going to use this.\n     *\n     * @param iv IV for CBC, must be 16 bytes\n     * @return null on error\n     * @deprecated unused\n     */\n    public byte[] safeDecrypt(byte payload[], SessionKey sessionKey, byte iv[]) {\n        if ((iv == null) || (payload == null) || (sessionKey == null) || (iv.length != 16)) return null;\n\n        byte decr[] = new byte[payload.length];\n        decrypt(payload, 0, decr, 0, sessionKey, iv, payload.length);\n        if (decr == null) {\n            _log.error(\"Error decrypting the data - payload \" + payload.length + \" decrypted to null\");\n            return null;\n        }\n\n        int cur = 0;\n        byte h[] = _context.sha().calculateHash(iv).getData();\n        for (int i = 0; i < Hash.HASH_LENGTH; i++) {\n            if (decr[i] != h[i]) {\n                _log.error(\"Hash does not match [key=\" + sessionKey + \" / iv =\" + DataHelper.toString(iv, iv.length)\n                           + \"]\", new Exception(\"Hash error\"));\n                return null;\n            }\n        }\n        cur += Hash.HASH_LENGTH;\n        \n        long len = DataHelper.fromLong(decr, cur, 4);\n        cur += 4;\n        \n        if (cur + len > decr.length) {\n            _log.error(\"Not enough to read\");\n            return null;\n        }\n        \n        byte data[] = new byte[(int)len];\n        System.arraycopy(decr, cur, data, 0, (int)len);\n        return data;\n    }","id":11716,"modified_method":"/**\n     * See safeEncrypt() for description.\n     * WARNING - no check for maximum length here, OOM DOS possible, fix it if you're going to use this.\n     *\n     * @param iv IV for CBC, must be 16 bytes\n     * @return null on error\n     * @deprecated unused\n     */\n    public byte[] safeDecrypt(byte payload[], SessionKey sessionKey, byte iv[]) {\n        if ((iv == null) || (payload == null) || (sessionKey == null) || (iv.length != 16)) return null;\n\n        byte decr[] = new byte[payload.length];\n        decrypt(payload, 0, decr, 0, sessionKey, iv, payload.length);\n        if (decr == null) {\n            _log.error(\"Error decrypting the data - payload \" + payload.length + \" decrypted to null\");\n            return null;\n        }\n\n        byte h[] = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n        _context.sha().calculateHash(iv, 0, 16, h, 0);\n        boolean eq = DataHelper.eq(decr, 0, h, 0, Hash.HASH_LENGTH);\n        SimpleByteCache.release(h);\n        if (!eq) {\n                _log.error(\"Hash does not match [key=\" + sessionKey + \" / iv =\" + DataHelper.toString(iv, iv.length)\n                           + \"]\", new Exception(\"Hash error\"));\n                return null;\n        }\n        int cur = Hash.HASH_LENGTH;\n        \n        long len = DataHelper.fromLong(decr, cur, 4);\n        cur += 4;\n        \n        if (cur + len > decr.length) {\n            _log.error(\"Not enough to read\");\n            return null;\n        }\n        \n        byte data[] = new byte[(int)len];\n        System.arraycopy(decr, cur, data, 0, (int)len);\n        return data;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * scenario 2: \n     * The data begins with 32 byte session tag, which also serves as the preIV.\n     * Then decrypt with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV:\n     * <pre>\n     *  - 2 byte integer specifying the # of session tags\n     *  - that many 32 byte session tags\n     *  - 4 byte integer specifying data.length\n     *  - SHA256 of data\n     *  - 1 byte flag that, if == 1, is followed by a new SessionKey\n     *  - data\n     *  - random bytes, padding the total size to greater than paddedSize with a mod 16 = 0\n     * <\/pre>\n     *\n     * If anything doesn't match up in decryption, it falls back to decryptNewSession\n     *\n     * @param foundTags set which is filled with any sessionTags found during decryption\n     * @param foundKey  out parameter. Data must be unset when called; may be filled with a new sessionKey found during decryption\n     * @param usedKey out parameter. Data must be unset when called; usedKey.setData() will be called by this method on success.\n     *\n     * @return decrypted data or null on failure\n     *\n     */\n    private byte[] decryptExistingSession(byte data[], SessionKey key, PrivateKey targetPrivateKey, Set foundTags,\n                                         SessionKey usedKey, SessionKey foundKey) throws DataFormatException {\n        byte preIV[] = new byte[32];\n        System.arraycopy(data, 0, preIV, 0, preIV.length);\n        Hash ivHash = _context.sha().calculateHash(preIV);\n        byte iv[] = new byte[16];\n        System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n\n        //_log.debug(\"Pre IV for decryptExistingSession: \" + DataHelper.toString(preIV, 32));\n        //_log.debug(\"SessionKey for decryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n        byte decrypted[] = decryptAESBlock(data, 32, data.length-32, key, iv, preIV, foundTags, foundKey);\n        if (decrypted == null) {\n            // it begins with a valid session tag, but thats just a coincidence.\n            //if (_log.shouldLog(Log.DEBUG))\n            //    _log.debug(\"Decrypt with a non session tag, but tags read: \" + foundTags.size());\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Decrypting looks negative... existing key fails with existing tag, lets try as a new one\");\n            byte rv[] = decryptNewSession(data, targetPrivateKey, foundTags, usedKey, foundKey);\n            if (_log.shouldLog(Log.WARN)) {\n                if (rv == null)\n                    _log.warn(\"Decrypting failed with a known existing tag as either an existing message or a new session\");\n                else\n                    _log.warn(\"Decrypting suceeded as a new session, even though it used an existing tag!\");\n            }\n            return rv;\n        }\n        // existing session decrypted successfully!\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Decrypt with an EXISTING session tag successfull, # tags read: \" + foundTags.size(),\n        //               new Exception(\"Decrypted by\"));\n        usedKey.setData(key.getData());\n        return decrypted;\n    }","id":11717,"modified_method":"/**\n     * scenario 2: \n     * The data begins with 32 byte session tag, which also serves as the preIV.\n     * Then decrypt with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV:\n     * <pre>\n     *  - 2 byte integer specifying the # of session tags\n     *  - that many 32 byte session tags\n     *  - 4 byte integer specifying data.length\n     *  - SHA256 of data\n     *  - 1 byte flag that, if == 1, is followed by a new SessionKey\n     *  - data\n     *  - random bytes, padding the total size to greater than paddedSize with a mod 16 = 0\n     * <\/pre>\n     *\n     * If anything doesn't match up in decryption, it falls back to decryptNewSession\n     *\n     * @param foundTags set which is filled with any sessionTags found during decryption\n     * @param foundKey  out parameter. Data must be unset when called; may be filled with a new sessionKey found during decryption\n     * @param usedKey out parameter. Data must be unset when called; usedKey.setData() will be called by this method on success.\n     *\n     * @return decrypted data or null on failure\n     *\n     */\n    private byte[] decryptExistingSession(byte data[], SessionKey key, PrivateKey targetPrivateKey, Set foundTags,\n                                         SessionKey usedKey, SessionKey foundKey) throws DataFormatException {\n        byte preIV[] = SimpleByteCache.acquire(32);\n        System.arraycopy(data, 0, preIV, 0, 32);\n        // use alternate calculateHash() method to avoid object churn and caching\n        //Hash ivHash = _context.sha().calculateHash(preIV);\n        //byte iv[] = new byte[16];\n        //System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n        byte[] iv = halfHash(preIV);\n        SimpleByteCache.release(preIV);\n\n        //_log.debug(\"Pre IV for decryptExistingSession: \" + DataHelper.toString(preIV, 32));\n        //_log.debug(\"SessionKey for decryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n        byte decrypted[] = decryptAESBlock(data, 32, data.length-32, key, iv, preIV, foundTags, foundKey);\n        SimpleByteCache.release(iv);\n        if (decrypted == null) {\n            // it begins with a valid session tag, but thats just a coincidence.\n            //if (_log.shouldLog(Log.DEBUG))\n            //    _log.debug(\"Decrypt with a non session tag, but tags read: \" + foundTags.size());\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Decrypting looks negative... existing key fails with existing tag, lets try as a new one\");\n            byte rv[] = decryptNewSession(data, targetPrivateKey, foundTags, usedKey, foundKey);\n            if (_log.shouldLog(Log.WARN)) {\n                if (rv == null)\n                    _log.warn(\"Decrypting failed with a known existing tag as either an existing message or a new session\");\n                else\n                    _log.warn(\"Decrypting suceeded as a new session, even though it used an existing tag!\");\n            }\n            return rv;\n        }\n        // existing session decrypted successfully!\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Decrypt with an EXISTING session tag successfull, # tags read: \" + foundTags.size(),\n        //               new Exception(\"Decrypted by\"));\n        usedKey.setData(key.getData());\n        return decrypted;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * scenario 1: \n     * Begin with 222 bytes, ElG encrypted, containing:\n     * <pre>\n     *  - 32 byte SessionKey\n     *  - 32 byte pre-IV for the AES\n     *  - 158 bytes of random padding\n     * <\/pre>\n     * After encryption, the ElG section is 514 bytes long.\n     * Then encrypt with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV, using\n     * the decryptAESBlock method & structure.\n     *\n     * @param foundTags set which is filled with any sessionTags found during decryption\n     * @param foundKey  out parameter. Data must be unset when called; may be filled with a new sessionKey found during decryption\n     * @param usedKey out parameter. Data must be unset when called; usedKey.setData() will be called by this method on success.\n     *\n     * @return null if decryption fails\n     */\n    private byte[] decryptNewSession(byte data[], PrivateKey targetPrivateKey, Set foundTags, SessionKey usedKey,\n                                    SessionKey foundKey) throws DataFormatException {\n        if (data == null) {\n            //if (_log.shouldLog(Log.WARN)) _log.warn(\"Data is null, unable to decrypt new session\");\n            return null;\n        } else if (data.length < 514) {\n            //if (_log.shouldLog(Log.WARN)) _log.warn(\"Data length is too small (\" + data.length + \")\");\n            return null;\n        }\n        byte elgEncr[] = new byte[514];\n        if (data.length > 514) {\n            System.arraycopy(data, 0, elgEncr, 0, 514);\n        } else {\n            System.arraycopy(data, 0, elgEncr, 514 - data.length, data.length);\n        }\n        byte elgDecr[] = _context.elGamalEngine().decrypt(elgEncr, targetPrivateKey);\n        if (elgDecr == null) {\n            //if (_log.shouldLog(Log.WARN))\n             //   _log.warn(\"decrypt returned null\", new Exception(\"decrypt failed\"));\n            return null;\n        }\n\n        byte preIV[] = null;\n        \n        int offset = 0;\n        byte key[] = new byte[SessionKey.KEYSIZE_BYTES];\n        System.arraycopy(elgDecr, offset, key, 0, SessionKey.KEYSIZE_BYTES);\n        offset += SessionKey.KEYSIZE_BYTES;\n        usedKey.setData(key);\n        preIV = new byte[32];\n        System.arraycopy(elgDecr, offset, preIV, 0, 32);\n        offset += 32;\n\n        //_log.debug(\"Pre IV for decryptNewSession: \" + DataHelper.toString(preIV, 32));\n        //_log.debug(\"SessionKey for decryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n        Hash ivHash = _context.sha().calculateHash(preIV);\n        byte iv[] = new byte[16];\n        System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n\n        // feed the extra bytes into the PRNG\n        _context.random().harvester().feedEntropy(\"ElG/AES\", elgDecr, offset, elgDecr.length - offset); \n\n        byte aesDecr[] = decryptAESBlock(data, 514, data.length-514, usedKey, iv, null, foundTags, foundKey);\n\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Decrypt with a NEW session successfull: # tags read = \" + foundTags.size(),\n        //               new Exception(\"Decrypted by\"));\n        return aesDecr;\n    }","id":11718,"modified_method":"/**\n     * scenario 1: \n     * Begin with 222 bytes, ElG encrypted, containing:\n     * <pre>\n     *  - 32 byte SessionKey\n     *  - 32 byte pre-IV for the AES\n     *  - 158 bytes of random padding\n     * <\/pre>\n     * After encryption, the ElG section is 514 bytes long.\n     * Then encrypt with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV, using\n     * the decryptAESBlock method & structure.\n     *\n     * @param foundTags set which is filled with any sessionTags found during decryption\n     * @param foundKey  out parameter. Data must be unset when called; may be filled with a new sessionKey found during decryption\n     * @param usedKey out parameter. Data must be unset when called; usedKey.setData() will be called by this method on success.\n     *\n     * @return null if decryption fails\n     */\n    private byte[] decryptNewSession(byte data[], PrivateKey targetPrivateKey, Set foundTags, SessionKey usedKey,\n                                    SessionKey foundKey) throws DataFormatException {\n        if (data == null) {\n            //if (_log.shouldLog(Log.WARN)) _log.warn(\"Data is null, unable to decrypt new session\");\n            return null;\n        } else if (data.length < 514) {\n            //if (_log.shouldLog(Log.WARN)) _log.warn(\"Data length is too small (\" + data.length + \")\");\n            return null;\n        }\n        byte elgEncr[] = new byte[514];\n        if (data.length > 514) {\n            System.arraycopy(data, 0, elgEncr, 0, 514);\n        } else {\n            System.arraycopy(data, 0, elgEncr, 514 - data.length, data.length);\n        }\n        byte elgDecr[] = _context.elGamalEngine().decrypt(elgEncr, targetPrivateKey);\n        if (elgDecr == null) {\n            //if (_log.shouldLog(Log.WARN))\n             //   _log.warn(\"decrypt returned null\", new Exception(\"decrypt failed\"));\n            return null;\n        }\n\n        int offset = 0;\n        byte key[] = new byte[SessionKey.KEYSIZE_BYTES];\n        System.arraycopy(elgDecr, offset, key, 0, SessionKey.KEYSIZE_BYTES);\n        offset += SessionKey.KEYSIZE_BYTES;\n        usedKey.setData(key);\n        byte[] preIV = SimpleByteCache.acquire(32);\n        System.arraycopy(elgDecr, offset, preIV, 0, 32);\n        offset += 32;\n\n        //_log.debug(\"Pre IV for decryptNewSession: \" + DataHelper.toString(preIV, 32));\n        //_log.debug(\"SessionKey for decryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n\n        // use alternate calculateHash() method to avoid object churn and caching\n        //Hash ivHash = _context.sha().calculateHash(preIV);\n        //byte iv[] = new byte[16];\n        //System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n        byte[] iv = halfHash(preIV);\n        SimpleByteCache.release(preIV);\n\n        // feed the extra bytes into the PRNG\n        _context.random().harvester().feedEntropy(\"ElG/AES\", elgDecr, offset, elgDecr.length - offset); \n\n        byte aesDecr[] = decryptAESBlock(data, 514, data.length-514, usedKey, iv, null, foundTags, foundKey);\n        SimpleByteCache.release(iv);\n\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Decrypt with a NEW session successfull: # tags read = \" + foundTags.size(),\n        //               new Exception(\"Decrypted by\"));\n        return aesDecr;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Decrypt the message using the given private key\n     * and using tags from the specified key manager.\n     * This works according to the\n     * ElGamal+AES algorithm in the data structure spec.\n     *\n     * @return decrypted data or null on failure\n     */\n    public byte[] decrypt(byte data[], PrivateKey targetPrivateKey, SessionKeyManager keyManager) throws DataFormatException {\n        if (data == null) {\n            if (_log.shouldLog(Log.ERROR)) _log.error(\"Null data being decrypted?\");\n            return null;\n        } else if (data.length < MIN_ENCRYPTED_SIZE) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Data is less than the minimum size (\" + data.length + \" < \" + MIN_ENCRYPTED_SIZE + \")\");\n            return null;\n        }\n\n        byte tag[] = new byte[32];\n        System.arraycopy(data, 0, tag, 0, tag.length);\n        SessionTag st = new SessionTag(tag);\n        SessionKey key = keyManager.consumeTag(st);\n        SessionKey foundKey = new SessionKey();\n        SessionKey usedKey = new SessionKey();\n        Set foundTags = new HashSet();\n        byte decrypted[] = null;\n        boolean wasExisting = false;\n        if (key != null) {\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Key is known for tag \" + st);\n            long id = _context.random().nextLong();\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(id + \": Decrypting existing session encrypted with tag: \" + st.toString() + \": key: \" + key.toBase64() + \": \" + data.length + \" bytes: \" + Base64.encode(data, 0, 64));\n            \n            decrypted = decryptExistingSession(data, key, targetPrivateKey, foundTags, usedKey, foundKey);\n            if (decrypted != null) {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptExistingSession\");\n                if ( (!foundTags.isEmpty()) && (_log.shouldLog(Log.DEBUG)) )\n                    _log.debug(id + \": ElG/AES decrypt success with \" + st + \": found tags: \" + foundTags);\n                wasExisting = true;\n            } else {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptFailed\");\n                if (_log.shouldLog(Log.WARN)) {\n                    _log.warn(id + \": ElG decrypt fail: known tag [\" + st + \"], failed decrypt\");\n                }\n            }\n        } else {\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Key is NOT known for tag \" + st);\n            decrypted = decryptNewSession(data, targetPrivateKey, foundTags, usedKey, foundKey);\n            if (decrypted != null) {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptNewSession\");\n                if ( (!foundTags.isEmpty()) && (_log.shouldLog(Log.DEBUG)) )\n                    _log.debug(\"ElG decrypt success: found tags: \" + foundTags);\n            } else {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptFailed\");\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"ElG decrypt fail: unknown tag: \" + st);\n            }\n        }\n\n        if ((key == null) && (decrypted == null)) {\n            //_log.debug(\"Unable to decrypt the data starting with tag [\" + st + \"] - did the tag expire recently?\", new Exception(\"Decrypt failure\"));\n        }\n\n        if (!foundTags.isEmpty()) {\n            if (foundKey.getData() != null) {\n                if (_log.shouldLog(Log.DEBUG)) \n                    _log.debug(\"Found key: \" + foundKey.toBase64() + \" tags: \" + foundTags + \" wasExisting? \" + wasExisting);\n                keyManager.tagsReceived(foundKey, foundTags);\n            } else if (usedKey.getData() != null) {\n                if (_log.shouldLog(Log.DEBUG)) \n                    _log.debug(\"Used key: \" + usedKey.toBase64() + \" tags: \" + foundTags + \" wasExisting? \" + wasExisting);\n                keyManager.tagsReceived(usedKey, foundTags);\n            }\n        }\n        return decrypted;\n    }","id":11719,"modified_method":"/**\n     * Decrypt the message using the given private key\n     * and using tags from the specified key manager.\n     * This works according to the\n     * ElGamal+AES algorithm in the data structure spec.\n     *\n     * @return decrypted data or null on failure\n     */\n    public byte[] decrypt(byte data[], PrivateKey targetPrivateKey, SessionKeyManager keyManager) throws DataFormatException {\n        if (data == null) {\n            if (_log.shouldLog(Log.ERROR)) _log.error(\"Null data being decrypted?\");\n            return null;\n        } else if (data.length < MIN_ENCRYPTED_SIZE) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Data is less than the minimum size (\" + data.length + \" < \" + MIN_ENCRYPTED_SIZE + \")\");\n            return null;\n        }\n\n        byte tag[] = new byte[32];\n        System.arraycopy(data, 0, tag, 0, 32);\n        SessionTag st = new SessionTag(tag);\n        SessionKey key = keyManager.consumeTag(st);\n        SessionKey foundKey = new SessionKey();\n        SessionKey usedKey = new SessionKey();\n        Set foundTags = new HashSet();\n        byte decrypted[] = null;\n        boolean wasExisting = false;\n        if (key != null) {\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Key is known for tag \" + st);\n            long id = _context.random().nextLong();\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(id + \": Decrypting existing session encrypted with tag: \" + st.toString() + \": key: \" + key.toBase64() + \": \" + data.length + \" bytes: \" + Base64.encode(data, 0, 64));\n            \n            decrypted = decryptExistingSession(data, key, targetPrivateKey, foundTags, usedKey, foundKey);\n            if (decrypted != null) {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptExistingSession\");\n                if ( (!foundTags.isEmpty()) && (_log.shouldLog(Log.DEBUG)) )\n                    _log.debug(id + \": ElG/AES decrypt success with \" + st + \": found tags: \" + foundTags);\n                wasExisting = true;\n            } else {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptFailed\");\n                if (_log.shouldLog(Log.WARN)) {\n                    _log.warn(id + \": ElG decrypt fail: known tag [\" + st + \"], failed decrypt\");\n                }\n            }\n        } else {\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Key is NOT known for tag \" + st);\n            decrypted = decryptNewSession(data, targetPrivateKey, foundTags, usedKey, foundKey);\n            if (decrypted != null) {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptNewSession\");\n                if ( (!foundTags.isEmpty()) && (_log.shouldLog(Log.DEBUG)) )\n                    _log.debug(\"ElG decrypt success: found tags: \" + foundTags);\n            } else {\n                _context.statManager().updateFrequency(\"crypto.elGamalAES.decryptFailed\");\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"ElG decrypt fail: unknown tag: \" + st);\n            }\n        }\n\n        if ((key == null) && (decrypted == null)) {\n            //_log.debug(\"Unable to decrypt the data starting with tag [\" + st + \"] - did the tag expire recently?\", new Exception(\"Decrypt failure\"));\n        }\n\n        if (!foundTags.isEmpty()) {\n            if (foundKey.getData() != null) {\n                if (_log.shouldLog(Log.DEBUG)) \n                    _log.debug(\"Found key: \" + foundKey.toBase64() + \" tags: \" + foundTags + \" wasExisting? \" + wasExisting);\n                keyManager.tagsReceived(foundKey, foundTags);\n            } else if (usedKey.getData() != null) {\n                if (_log.shouldLog(Log.DEBUG)) \n                    _log.debug(\"Used key: \" + usedKey.toBase64() + \" tags: \" + foundTags + \" wasExisting? \" + wasExisting);\n                keyManager.tagsReceived(usedKey, foundTags);\n            }\n        }\n        return decrypted;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * scenario 2: \n     * Begin with 32 byte session tag, which also serves as the preIV.\n     * Then encrypt with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV:\n     * <pre>\n     *  - 2 byte integer specifying the # of session tags\n     *  - that many 32 byte session tags\n     *  - 4 byte integer specifying data.length\n     *  - SHA256 of data\n     *  - 1 byte flag that, if == 1, is followed by a new SessionKey\n     *  - data\n     *  - random bytes, padding the total size to greater than paddedSize with a mod 16 = 0\n     * <\/pre>\n     *\n     */\n    private byte[] encryptExistingSession(byte data[], PublicKey target, SessionKey key, Set tagsForDelivery,\n                                         SessionTag currentTag, SessionKey newKey, long paddedSize) {\n        //_log.debug(\"Encrypting to an EXISTING session\");\n        byte rawTag[] = currentTag.getData();\n\n        //_log.debug(\"Pre IV for encryptExistingSession (aka tag): \" + currentTag.toString());\n        //_log.debug(\"SessionKey for encryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n        Hash ivHash = _context.sha().calculateHash(rawTag);\n        byte iv[] = new byte[16];\n        System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n        \n        byte aesEncr[] = encryptAESBlock(data, key, iv, tagsForDelivery, newKey, paddedSize, SessionTag.BYTE_LENGTH);\n        // that prepended SessionTag.BYTE_LENGTH bytes at the beginning of the buffer\n        System.arraycopy(rawTag, 0, aesEncr, 0, rawTag.length);\n        return aesEncr;\n    }","id":11720,"modified_method":"/**\n     * scenario 2: \n     * Begin with 32 byte session tag, which also serves as the preIV.\n     * Then encrypt with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV:\n     * <pre>\n     *  - 2 byte integer specifying the # of session tags\n     *  - that many 32 byte session tags\n     *  - 4 byte integer specifying data.length\n     *  - SHA256 of data\n     *  - 1 byte flag that, if == 1, is followed by a new SessionKey\n     *  - data\n     *  - random bytes, padding the total size to greater than paddedSize with a mod 16 = 0\n     * <\/pre>\n     *\n     */\n    private byte[] encryptExistingSession(byte data[], PublicKey target, SessionKey key, Set tagsForDelivery,\n                                         SessionTag currentTag, SessionKey newKey, long paddedSize) {\n        //_log.debug(\"Encrypting to an EXISTING session\");\n        byte rawTag[] = currentTag.getData();\n\n        //_log.debug(\"Pre IV for encryptExistingSession (aka tag): \" + currentTag.toString());\n        //_log.debug(\"SessionKey for encryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n        // use alternate calculateHash() method to avoid object churn and caching\n        //Hash ivHash = _context.sha().calculateHash(rawTag);\n        //byte iv[] = new byte[16];\n        //System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n        byte[] iv = halfHash(rawTag);\n        \n        byte aesEncr[] = encryptAESBlock(data, key, iv, tagsForDelivery, newKey, paddedSize, SessionTag.BYTE_LENGTH);\n        SimpleByteCache.release(iv);\n        // that prepended SessionTag.BYTE_LENGTH bytes at the beginning of the buffer\n        System.arraycopy(rawTag, 0, aesEncr, 0, rawTag.length);\n        return aesEncr;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"byte[] decryptAESBlock(byte encrypted[], int offset, int encryptedLen, SessionKey key, byte iv[], \n                           byte sentTag[], Set foundTags, SessionKey foundKey) throws DataFormatException {\n        //_log.debug(\"iv for decryption: \" + DataHelper.toString(iv, 16));\t\n        //_log.debug(\"decrypting AES block.  encr.length = \" + (encrypted == null? -1 : encrypted.length) + \" sentTag: \" + DataHelper.toString(sentTag, 32));\n        byte decrypted[] = new byte[encryptedLen];\n        _context.aes().decrypt(encrypted, offset, decrypted, 0, key, iv, encryptedLen);\n        //Hash h = _context.sha().calculateHash(decrypted);\n        //_log.debug(\"Hash of entire aes block after decryption: \\n\" + DataHelper.toString(h.getData(), 32));\n        try {\n            SessionKey newKey = null;\n            Hash readHash = null;\n            List tags = null;\n\n            //ByteArrayInputStream bais = new ByteArrayInputStream(decrypted);\n            int cur = 0;\n            long numTags = DataHelper.fromLong(decrypted, cur, 2);\n            if ((numTags < 0) || (numTags > 200)) throw new Exception(\"Invalid number of session tags\");\n            if (numTags > 0) tags = new ArrayList((int)numTags);\n            cur += 2;\n            //_log.debug(\"# tags: \" + numTags);\n            if (numTags * SessionTag.BYTE_LENGTH > decrypted.length - 2) {\n                throw new Exception(\"# tags: \" + numTags + \" is too many for \" + (decrypted.length - 2));\n            }\n            for (int i = 0; i < numTags; i++) {\n                byte tag[] = new byte[SessionTag.BYTE_LENGTH];\n                System.arraycopy(decrypted, cur, tag, 0, SessionTag.BYTE_LENGTH); \n                cur += SessionTag.BYTE_LENGTH;\n                tags.add(new SessionTag(tag));\n            }\n            long len = DataHelper.fromLong(decrypted, cur, 4);\n            cur += 4;\n            //_log.debug(\"len: \" + len);\n            if ((len < 0) || (len > decrypted.length - cur - Hash.HASH_LENGTH - 1)) \n                throw new Exception(\"Invalid size of payload (\" + len + \", remaining \" + (decrypted.length-cur) +\")\");\n            //byte hashval[] = new byte[Hash.HASH_LENGTH];\n            //System.arraycopy(decrypted, cur, hashval, 0, Hash.HASH_LENGTH);\n            //readHash = new Hash();\n            //readHash.setData(hashval);\n            readHash = Hash.create(decrypted, cur);\n            cur += Hash.HASH_LENGTH;\n            byte flag = decrypted[cur++];\n            if (flag == 0x01) {\n                byte rekeyVal[] = new byte[SessionKey.KEYSIZE_BYTES];\n                System.arraycopy(decrypted, cur, rekeyVal, 0, SessionKey.KEYSIZE_BYTES);\n                cur += SessionKey.KEYSIZE_BYTES;\n                newKey = new SessionKey();\n                newKey.setData(rekeyVal);\n            }\n            byte unencrData[] = new byte[(int) len];\n            System.arraycopy(decrypted, cur, unencrData, 0, (int)len);\n            cur += len;\n            Hash calcHash = _context.sha().calculateHash(unencrData);\n            boolean eq = calcHash.equals(readHash);\n            \n            if (eq) {\n                // everything matches.  w00t.\n                if (tags != null)\n                    foundTags.addAll(tags);\n                if (newKey != null) foundKey.setData(newKey.getData());\n                return unencrData;\n            }\n\n            throw new Exception(\"Hash does not match\");\n        } catch (Exception e) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"Unable to decrypt AES block\", e);\n            return null;\n        }\n    }","id":11721,"modified_method":"byte[] decryptAESBlock(byte encrypted[], int offset, int encryptedLen, SessionKey key, byte iv[], \n                           byte sentTag[], Set foundTags, SessionKey foundKey) throws DataFormatException {\n        //_log.debug(\"iv for decryption: \" + DataHelper.toString(iv, 16));\t\n        //_log.debug(\"decrypting AES block.  encr.length = \" + (encrypted == null? -1 : encrypted.length) + \" sentTag: \" + DataHelper.toString(sentTag, 32));\n        byte decrypted[] = new byte[encryptedLen];\n        _context.aes().decrypt(encrypted, offset, decrypted, 0, key, iv, encryptedLen);\n        //Hash h = _context.sha().calculateHash(decrypted);\n        //_log.debug(\"Hash of entire aes block after decryption: \\n\" + DataHelper.toString(h.getData(), 32));\n        try {\n            SessionKey newKey = null;\n            Hash readHash = null;\n            List tags = null;\n\n            //ByteArrayInputStream bais = new ByteArrayInputStream(decrypted);\n            int cur = 0;\n            long numTags = DataHelper.fromLong(decrypted, cur, 2);\n            if ((numTags < 0) || (numTags > 200)) throw new Exception(\"Invalid number of session tags\");\n            if (numTags > 0) tags = new ArrayList((int)numTags);\n            cur += 2;\n            //_log.debug(\"# tags: \" + numTags);\n            if (numTags * SessionTag.BYTE_LENGTH > decrypted.length - 2) {\n                throw new Exception(\"# tags: \" + numTags + \" is too many for \" + (decrypted.length - 2));\n            }\n            for (int i = 0; i < numTags; i++) {\n                byte tag[] = new byte[SessionTag.BYTE_LENGTH];\n                System.arraycopy(decrypted, cur, tag, 0, SessionTag.BYTE_LENGTH); \n                cur += SessionTag.BYTE_LENGTH;\n                tags.add(new SessionTag(tag));\n            }\n            long len = DataHelper.fromLong(decrypted, cur, 4);\n            cur += 4;\n            //_log.debug(\"len: \" + len);\n            if ((len < 0) || (len > decrypted.length - cur - Hash.HASH_LENGTH - 1)) \n                throw new Exception(\"Invalid size of payload (\" + len + \", remaining \" + (decrypted.length-cur) +\")\");\n            //byte hashval[] = new byte[Hash.HASH_LENGTH];\n            //System.arraycopy(decrypted, cur, hashval, 0, Hash.HASH_LENGTH);\n            //readHash = new Hash();\n            //readHash.setData(hashval);\n            //readHash = Hash.create(decrypted, cur);\n            int hashIndex = cur;\n            cur += Hash.HASH_LENGTH;\n            byte flag = decrypted[cur++];\n            if (flag == 0x01) {\n                byte rekeyVal[] = new byte[SessionKey.KEYSIZE_BYTES];\n                System.arraycopy(decrypted, cur, rekeyVal, 0, SessionKey.KEYSIZE_BYTES);\n                cur += SessionKey.KEYSIZE_BYTES;\n                newKey = new SessionKey();\n                newKey.setData(rekeyVal);\n            }\n            byte unencrData[] = new byte[(int) len];\n            System.arraycopy(decrypted, cur, unencrData, 0, (int)len);\n            cur += (int) len;\n            // use alternate calculateHash() method to avoid object churn and caching\n            //Hash calcHash = _context.sha().calculateHash(unencrData);\n            //boolean eq = calcHash.equals(readHash);\n            byte[] calcHash = SimpleByteCache.acquire(32);\n            _context.sha().calculateHash(unencrData, 0, (int) len, calcHash, 0);\n            boolean eq = DataHelper.eq(decrypted, hashIndex, calcHash, 0, 32);\n            SimpleByteCache.release(calcHash);\n            \n            if (eq) {\n                // everything matches.  w00t.\n                if (tags != null)\n                    foundTags.addAll(tags);\n                if (newKey != null) foundKey.setData(newKey.getData());\n                return unencrData;\n            }\n\n            throw new Exception(\"Hash does not match\");\n        } catch (Exception e) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"Unable to decrypt AES block\", e);\n            return null;\n        }\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * scenario 1: \n     * Begin with 222 bytes, ElG encrypted, containing:\n     * <pre>\n     *  - 32 byte SessionKey\n     *  - 32 byte pre-IV for the AES\n     *  - 158 bytes of random padding\n     * <\/pre>\n     * After encryption, the ElG section is 514 bytes long.\n     * Then encrypt the following with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV:\n     * <pre>\n     *  - 2 byte integer specifying the # of session tags\n     *  - that many 32 byte session tags\n     *  - 4 byte integer specifying data.length\n     *  - SHA256 of data\n     *  - 1 byte flag that, if == 1, is followed by a new SessionKey\n     *  - data\n     *  - random bytes, padding the total size to greater than paddedSize with a mod 16 = 0\n     * <\/pre>\n     *\n     */\n    private byte[] encryptNewSession(byte data[], PublicKey target, SessionKey key, Set tagsForDelivery,\n                                    SessionKey newKey, long paddedSize) {\n        //_log.debug(\"Encrypting to a NEW session\");\n        byte elgSrcData[] = new byte[SessionKey.KEYSIZE_BYTES+32+158];\n        System.arraycopy(key.getData(), 0, elgSrcData, 0, SessionKey.KEYSIZE_BYTES);\n        byte preIV[] = new byte[32];\n        _context.random().nextBytes(preIV);\n        System.arraycopy(preIV, 0, elgSrcData, SessionKey.KEYSIZE_BYTES, 32);\n        byte rnd[] = new byte[158];\n        _context.random().nextBytes(rnd);\n        System.arraycopy(rnd, 0, elgSrcData, SessionKey.KEYSIZE_BYTES+32, 158);\n\n        //_log.debug(\"Pre IV for encryptNewSession: \" + DataHelper.toString(preIV, 32));\n        //_log.debug(\"SessionKey for encryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n        long before = _context.clock().now();\n        byte elgEncr[] = _context.elGamalEngine().encrypt(elgSrcData, target);\n        if (_log.shouldLog(Log.INFO)) {\n            long after = _context.clock().now();\n            _log.info(\"elgEngine.encrypt of the session key took \" + (after - before) + \"ms\");\n        }\n        if (elgEncr.length < 514) {\n            // ??? ElGamalEngine.encrypt() always returns 514 bytes\n            byte elg[] = new byte[514];\n            int diff = elg.length - elgEncr.length;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Difference in size: \" + diff);\n            System.arraycopy(elgEncr, 0, elg, diff, elgEncr.length);\n            elgEncr = elg;\n        }\n        //_log.debug(\"ElGamal encrypted length: \" + elgEncr.length + \" elGamal source length: \" + elgSrc.toByteArray().length);\n        \n        // should we also feed the encrypted elG block into the harvester?\n\n        Hash ivHash = _context.sha().calculateHash(preIV);\n        byte iv[] = new byte[16];\n        System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n        byte aesEncr[] = encryptAESBlock(data, key, iv, tagsForDelivery, newKey, paddedSize);\n        //_log.debug(\"AES encrypted length: \" + aesEncr.length);\n\n        byte rv[] = new byte[elgEncr.length + aesEncr.length];\n        System.arraycopy(elgEncr, 0, rv, 0, elgEncr.length);\n        System.arraycopy(aesEncr, 0, rv, elgEncr.length, aesEncr.length);\n        //_log.debug(\"Return length: \" + rv.length);\n        //long finish = _context.clock().now();\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"after the elgEngine.encrypt took a total of \" + (finish - after) + \"ms\");\n        return rv;\n    }","id":11722,"modified_method":"/**\n     * scenario 1: \n     * Begin with 222 bytes, ElG encrypted, containing:\n     * <pre>\n     *  - 32 byte SessionKey\n     *  - 32 byte pre-IV for the AES\n     *  - 158 bytes of random padding\n     * <\/pre>\n     * After encryption, the ElG section is 514 bytes long.\n     * Then encrypt the following with AES using that session key and the first 16 bytes of the SHA256 of the pre-IV:\n     * <pre>\n     *  - 2 byte integer specifying the # of session tags\n     *  - that many 32 byte session tags\n     *  - 4 byte integer specifying data.length\n     *  - SHA256 of data\n     *  - 1 byte flag that, if == 1, is followed by a new SessionKey\n     *  - data\n     *  - random bytes, padding the total size to greater than paddedSize with a mod 16 = 0\n     * <\/pre>\n     *\n     */\n    private byte[] encryptNewSession(byte data[], PublicKey target, SessionKey key, Set tagsForDelivery,\n                                    SessionKey newKey, long paddedSize) {\n        //_log.debug(\"Encrypting to a NEW session\");\n        byte elgSrcData[] = new byte[SessionKey.KEYSIZE_BYTES+32+158];\n        System.arraycopy(key.getData(), 0, elgSrcData, 0, SessionKey.KEYSIZE_BYTES);\n        byte preIV[] = SimpleByteCache.acquire(32);\n        _context.random().nextBytes(preIV);\n        System.arraycopy(preIV, 0, elgSrcData, SessionKey.KEYSIZE_BYTES, 32);\n        byte rnd[] = new byte[158];\n        _context.random().nextBytes(rnd);\n        System.arraycopy(rnd, 0, elgSrcData, SessionKey.KEYSIZE_BYTES+32, 158);\n\n        //_log.debug(\"Pre IV for encryptNewSession: \" + DataHelper.toString(preIV, 32));\n        //_log.debug(\"SessionKey for encryptNewSession: \" + DataHelper.toString(key.getData(), 32));\n        long before = _context.clock().now();\n        byte elgEncr[] = _context.elGamalEngine().encrypt(elgSrcData, target);\n        if (_log.shouldLog(Log.INFO)) {\n            long after = _context.clock().now();\n            _log.info(\"elgEngine.encrypt of the session key took \" + (after - before) + \"ms\");\n        }\n        if (elgEncr.length < 514) {\n            // ??? ElGamalEngine.encrypt() always returns 514 bytes\n            byte elg[] = new byte[514];\n            int diff = elg.length - elgEncr.length;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"Difference in size: \" + diff);\n            System.arraycopy(elgEncr, 0, elg, diff, elgEncr.length);\n            elgEncr = elg;\n        }\n        //_log.debug(\"ElGamal encrypted length: \" + elgEncr.length + \" elGamal source length: \" + elgSrc.toByteArray().length);\n        \n        // should we also feed the encrypted elG block into the harvester?\n\n        // use alternate calculateHash() method to avoid object churn and caching\n        //Hash ivHash = _context.sha().calculateHash(preIV);\n        //byte iv[] = new byte[16];\n        //System.arraycopy(ivHash.getData(), 0, iv, 0, 16);\n        byte[] iv = halfHash(preIV);\n        SimpleByteCache.release(preIV);\n\n        byte aesEncr[] = encryptAESBlock(data, key, iv, tagsForDelivery, newKey, paddedSize);\n        SimpleByteCache.release(iv);\n        //_log.debug(\"AES encrypted length: \" + aesEncr.length);\n\n        byte rv[] = new byte[elgEncr.length + aesEncr.length];\n        System.arraycopy(elgEncr, 0, rv, 0, elgEncr.length);\n        System.arraycopy(aesEncr, 0, rv, elgEncr.length, aesEncr.length);\n        //_log.debug(\"Return length: \" + rv.length);\n        //long finish = _context.clock().now();\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"after the elgEngine.encrypt took a total of \" + (finish - after) + \"ms\");\n        return rv;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private final byte[] encryptAESBlock(byte data[], SessionKey key, byte[] iv, Set tagsForDelivery, SessionKey newKey,\n                                        long paddedSize, int prefixBytes) {\n        //_log.debug(\"iv for encryption: \" + DataHelper.toString(iv, 16));\n        //_log.debug(\"Encrypting AES\");\n        if (tagsForDelivery == null) tagsForDelivery = Collections.EMPTY_SET;\n        int size = 2 // sizeof(tags)\n                 + tagsForDelivery.size()\n                 + SessionTag.BYTE_LENGTH*tagsForDelivery.size()\n                 + 4 // payload length\n                 + Hash.HASH_LENGTH\n                 + (newKey == null ? 1 : 1 + SessionKey.KEYSIZE_BYTES)\n                 + data.length;\n        int totalSize = size + getPaddingSize(size, paddedSize);\n\n        byte aesData[] = new byte[totalSize + prefixBytes];\n\n        int cur = prefixBytes;\n        DataHelper.toLong(aesData, cur, 2, tagsForDelivery.size());\n        cur += 2;\n        for (Iterator iter = tagsForDelivery.iterator(); iter.hasNext();) {\n            SessionTag tag = (SessionTag) iter.next();\n            System.arraycopy(tag.getData(), 0, aesData, cur, SessionTag.BYTE_LENGTH);\n            cur += SessionTag.BYTE_LENGTH;\n        }\n        //_log.debug(\"# tags created, registered, and written: \" + tagsForDelivery.size());\n        DataHelper.toLong(aesData, cur, 4, data.length);\n        cur += 4;\n        //_log.debug(\"data length: \" + data.length);\n        Hash hash = _context.sha().calculateHash(data);\n        System.arraycopy(hash.getData(), 0, aesData, cur, Hash.HASH_LENGTH);\n        cur += Hash.HASH_LENGTH;\n        \n        //_log.debug(\"hash of data: \" + DataHelper.toString(hash.getData(), 32));\n        if (newKey == null) {\n            aesData[cur++] = 0x00; // don't rekey\n            //_log.debug(\"flag written\");\n        } else {\n            aesData[cur++] = 0x01; // rekey\n            System.arraycopy(newKey.getData(), 0, aesData, cur, SessionKey.KEYSIZE_BYTES);\n            cur += SessionKey.KEYSIZE_BYTES;\n        }\n        System.arraycopy(data, 0, aesData, cur, data.length);\n        cur += data.length;\n\n        //_log.debug(\"raw data written: \" + len);\n        byte padding[] = getPadding(_context, size, paddedSize);\n        //_log.debug(\"padding length: \" + padding.length);\n        System.arraycopy(padding, 0, aesData, cur, padding.length);\n        cur += padding.length;\n\n        //Hash h = _context.sha().calculateHash(data);\n        //_log.debug(\"Hash of entire aes block before encryption: (len=\" + data.length + \")\\n\" + DataHelper.toString(h.getData(), 32));\n        _context.aes().encrypt(aesData, prefixBytes, aesData, prefixBytes, key, iv, aesData.length - prefixBytes);\n        //_log.debug(\"Encrypted length: \" + aesEncr.length);\n        //return aesEncr;\n        return aesData;\n    }","id":11723,"modified_method":"private final byte[] encryptAESBlock(byte data[], SessionKey key, byte[] iv, Set tagsForDelivery, SessionKey newKey,\n                                        long paddedSize, int prefixBytes) {\n        //_log.debug(\"iv for encryption: \" + DataHelper.toString(iv, 16));\n        //_log.debug(\"Encrypting AES\");\n        if (tagsForDelivery == null) tagsForDelivery = Collections.EMPTY_SET;\n        int size = 2 // sizeof(tags)\n                 + tagsForDelivery.size()\n                 + SessionTag.BYTE_LENGTH*tagsForDelivery.size()\n                 + 4 // payload length\n                 + Hash.HASH_LENGTH\n                 + (newKey == null ? 1 : 1 + SessionKey.KEYSIZE_BYTES)\n                 + data.length;\n        int totalSize = size + getPaddingSize(size, paddedSize);\n\n        byte aesData[] = new byte[totalSize + prefixBytes];\n\n        int cur = prefixBytes;\n        DataHelper.toLong(aesData, cur, 2, tagsForDelivery.size());\n        cur += 2;\n        for (Iterator iter = tagsForDelivery.iterator(); iter.hasNext();) {\n            SessionTag tag = (SessionTag) iter.next();\n            System.arraycopy(tag.getData(), 0, aesData, cur, SessionTag.BYTE_LENGTH);\n            cur += SessionTag.BYTE_LENGTH;\n        }\n        //_log.debug(\"# tags created, registered, and written: \" + tagsForDelivery.size());\n        DataHelper.toLong(aesData, cur, 4, data.length);\n        cur += 4;\n        //_log.debug(\"data length: \" + data.length);\n        // use alternate calculateHash() method to avoid object churn and caching\n        //Hash hash = _context.sha().calculateHash(data);\n        //System.arraycopy(hash.getData(), 0, aesData, cur, Hash.HASH_LENGTH);\n        _context.sha().calculateHash(data, 0, data.length, aesData, cur);\n        cur += Hash.HASH_LENGTH;\n        \n        //_log.debug(\"hash of data: \" + DataHelper.toString(hash.getData(), 32));\n        if (newKey == null) {\n            aesData[cur++] = 0x00; // don't rekey\n            //_log.debug(\"flag written\");\n        } else {\n            aesData[cur++] = 0x01; // rekey\n            System.arraycopy(newKey.getData(), 0, aesData, cur, SessionKey.KEYSIZE_BYTES);\n            cur += SessionKey.KEYSIZE_BYTES;\n        }\n        System.arraycopy(data, 0, aesData, cur, data.length);\n        cur += data.length;\n\n        //_log.debug(\"raw data written: \" + len);\n        byte padding[] = getPadding(_context, size, paddedSize);\n        //_log.debug(\"padding length: \" + padding.length);\n        System.arraycopy(padding, 0, aesData, cur, padding.length);\n        cur += padding.length;\n\n        //Hash h = _context.sha().calculateHash(data);\n        //_log.debug(\"Hash of entire aes block before encryption: (len=\" + data.length + \")\\n\" + DataHelper.toString(h.getData(), 32));\n        _context.aes().encrypt(aesData, prefixBytes, aesData, prefixBytes, key, iv, aesData.length - prefixBytes);\n        //_log.debug(\"Encrypted length: \" + aesEncr.length);\n        //return aesEncr;\n        return aesData;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** Decrypt the data\n     * @param encrypted encrypted data, must be exactly 514 bytes\n     *         Contains the two-part encrypted data starting at bytes 0 and 257.\n     *         If the encrypted parts are smaller than 257 bytes, they must be\n     *         padded with leading zeros.\n     * @param privateKey private key to decrypt with\n     * @return unencrypted data or null on failure\n     */\n    public byte[] decrypt(byte encrypted[], PrivateKey privateKey) {\n        // actually it must be exactly 514 bytes or the arraycopy below will AIOOBE\n        if ((encrypted == null) || (encrypted.length > 514))\n            throw new IllegalArgumentException(\"Data to decrypt must be <= 514 bytes at the moment\");\n        long start = _context.clock().now();\n\n        byte[] ybytes = new byte[257];\n        byte[] dbytes = new byte[257];\n        System.arraycopy(encrypted, 0, ybytes, 0, 257);\n        System.arraycopy(encrypted, 257, dbytes, 0, 257);\n        BigInteger y = new NativeBigInteger(1, ybytes);\n        BigInteger d = new NativeBigInteger(1, dbytes);\n        BigInteger a = new NativeBigInteger(1, privateKey.getData());\n        BigInteger y1p = CryptoConstants.elgp.subtract(BigInteger.ONE).subtract(a);\n        BigInteger ya = y.modPow(y1p, CryptoConstants.elgp);\n        BigInteger m = ya.multiply(d);\n        m = m.mod(CryptoConstants.elgp);\n        byte val[] = m.toByteArray();\n        int i = 0;\n        for (i = 0; i < val.length; i++)\n            if (val[i] != (byte) 0x00) break;\n\n        int payloadLen = val.length - i - 1 - Hash.HASH_LENGTH;\n        if (payloadLen < 0) {\n            if (_log.shouldLog(Log.ERROR)) \n                _log.error(\"Decrypted data is too small (\" + (val.length - i)+ \")\");\n            return null;\n        }\n\n        //ByteArrayInputStream bais = new ByteArrayInputStream(val, i, val.length - i);\n        //byte hashData[] = new byte[Hash.HASH_LENGTH];\n        //System.arraycopy(val, i + 1, hashData, 0, Hash.HASH_LENGTH);\n        //Hash hash = new Hash(hashData);\n        Hash hash = Hash.create(val, i + 1);\n        byte rv[] = new byte[payloadLen];\n        System.arraycopy(val, i + 1 + Hash.HASH_LENGTH, rv, 0, rv.length);\n\n        Hash calcHash = _context.sha().calculateHash(rv);\n        boolean ok = calcHash.equals(hash);\n        \n        long end = _context.clock().now();\n\n        long diff = end - start;\n        if (diff > 1000) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Took too long to decrypt and verify ElGamal block (\" + diff + \"ms)\");\n        }\n\n        _context.statManager().addRateData(\"crypto.elGamal.decrypt\", diff, diff);\n\n        if (ok) {\n            //_log.debug(\"Hash matches: \" + DataHelper.toString(hash.getData(), hash.getData().length));\n            return rv;\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Doesn't match hash [sent hash=\" + hash + \"]\\ndata = \"\n                       + Base64.encode(rv), new Exception(\"Doesn't match\"));\n        return null;\n    }","id":11724,"modified_method":"/** Decrypt the data\n     * @param encrypted encrypted data, must be exactly 514 bytes\n     *         Contains the two-part encrypted data starting at bytes 0 and 257.\n     *         If the encrypted parts are smaller than 257 bytes, they must be\n     *         padded with leading zeros.\n     * @param privateKey private key to decrypt with\n     * @return unencrypted data or null on failure\n     */\n    public byte[] decrypt(byte encrypted[], PrivateKey privateKey) {\n        // actually it must be exactly 514 bytes or the arraycopy below will AIOOBE\n        if ((encrypted == null) || (encrypted.length > 514))\n            throw new IllegalArgumentException(\"Data to decrypt must be <= 514 bytes at the moment\");\n        long start = _context.clock().now();\n\n        byte[] ybytes = new byte[257];\n        byte[] dbytes = new byte[257];\n        System.arraycopy(encrypted, 0, ybytes, 0, 257);\n        System.arraycopy(encrypted, 257, dbytes, 0, 257);\n        BigInteger y = new NativeBigInteger(1, ybytes);\n        BigInteger d = new NativeBigInteger(1, dbytes);\n        BigInteger a = new NativeBigInteger(1, privateKey.getData());\n        BigInteger y1p = CryptoConstants.elgp.subtract(BigInteger.ONE).subtract(a);\n        BigInteger ya = y.modPow(y1p, CryptoConstants.elgp);\n        BigInteger m = ya.multiply(d);\n        m = m.mod(CryptoConstants.elgp);\n        byte val[] = m.toByteArray();\n        int i = 0;\n        for (i = 0; i < val.length; i++)\n            if (val[i] != (byte) 0x00) break;\n\n        int payloadLen = val.length - i - 1 - Hash.HASH_LENGTH;\n        if (payloadLen < 0) {\n            if (_log.shouldLog(Log.ERROR)) \n                _log.error(\"Decrypted data is too small (\" + (val.length - i)+ \")\");\n            return null;\n        }\n\n        //ByteArrayInputStream bais = new ByteArrayInputStream(val, i, val.length - i);\n        //byte hashData[] = new byte[Hash.HASH_LENGTH];\n        //System.arraycopy(val, i + 1, hashData, 0, Hash.HASH_LENGTH);\n        //Hash hash = new Hash(hashData);\n        //Hash hash = Hash.create(val, i + 1);\n        byte rv[] = new byte[payloadLen];\n        System.arraycopy(val, i + 1 + Hash.HASH_LENGTH, rv, 0, rv.length);\n\n        byte[] calcHash = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n        _context.sha().calculateHash(rv, 0, payloadLen, calcHash, 0);\n        boolean ok = DataHelper.eq(calcHash, 0, val, i + 1, Hash.HASH_LENGTH);\n        SimpleByteCache.release(calcHash);\n        \n        long end = _context.clock().now();\n\n        long diff = end - start;\n        if (diff > 1000) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Took too long to decrypt and verify ElGamal block (\" + diff + \"ms)\");\n        }\n\n        _context.statManager().addRateData(\"crypto.elGamal.decrypt\", diff, diff);\n\n        if (ok) {\n            //_log.debug(\"Hash matches: \" + DataHelper.toString(hash.getData(), hash.getData().length));\n            return rv;\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Doesn't match hash data = \"\n                       + Base64.encode(rv), new Exception(\"Doesn't match\"));\n        return null;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** encrypt the data to the public key\n     * @return encrypted data, will be exactly 514 bytes long\n     *         Contains the two-part encrypted data starting at bytes 0 and 257.\n     *         If the encrypted parts are smaller than 257 bytes, they will be\n     *         padded with leading zeros.\n     *         The parts appear to always be 256 bytes or less, in other words,\n     *         bytes 0 and 257 are always zero.\n     * @param publicKey public key encrypt to\n     * @param data data to encrypt, must be 222 bytes or less\n     *         As the encrypted data may contain a substantial number of zeros if the\n     *         cleartext is smaller than 222 bytes, it is recommended that the caller pad\n     *         the cleartext to 222 bytes with random data.\n     */\n    public byte[] encrypt(byte data[], PublicKey publicKey) {\n        if ((data == null) || (data.length >= 223))\n            throw new IllegalArgumentException(\"Data to encrypt must be < 223 bytes at the moment\");\n        if (publicKey == null) throw new IllegalArgumentException(\"Null public key specified\");\n\n        long start = _context.clock().now();\n\n        byte d2[] = new byte[1+Hash.HASH_LENGTH+data.length];\n        // FIXME this isn't a random nonzero byte!\n        d2[0] = (byte)0xFF;\n        Hash hash = _context.sha().calculateHash(data);\n        System.arraycopy(hash.getData(), 0, d2, 1, Hash.HASH_LENGTH);\n        System.arraycopy(data, 0, d2, 1+Hash.HASH_LENGTH, data.length);\n        \n        //long t0 = _context.clock().now();\n        BigInteger m = new NativeBigInteger(1, d2);\n        //long t1 = _context.clock().now();\n        if (m.compareTo(CryptoConstants.elgp) >= 0)\n            throw new IllegalArgumentException(\"ARGH.  Data cannot be larger than the ElGamal prime.  FIXME\");\n        //long t2 = _context.clock().now();\n        BigInteger aalpha = new NativeBigInteger(1, publicKey.getData());\n        //long t3 = _context.clock().now();\n        BigInteger yk[] = getNextYK();\n        BigInteger k = yk[1];\n        BigInteger y = yk[0];\n\n        //long t7 = _context.clock().now();\n        BigInteger d = aalpha.modPow(k, CryptoConstants.elgp);\n        //long t8 = _context.clock().now();\n        d = d.multiply(m);\n        //long t9 = _context.clock().now();\n        d = d.mod(CryptoConstants.elgp);\n        //long t10 = _context.clock().now();\n\n        byte[] ybytes = y.toByteArray();\n        byte[] dbytes = d.toByteArray();\n        byte[] out = new byte[514];\n        System.arraycopy(ybytes, 0, out, (ybytes.length < 257 ? 257 - ybytes.length : 0),\n                         (ybytes.length > 257 ? 257 : ybytes.length));\n        System.arraycopy(dbytes, 0, out, (dbytes.length < 257 ? 514 - dbytes.length : 257),\n                         (dbytes.length > 257 ? 257 : dbytes.length));\n        /*\n        StringBuilder buf = new StringBuilder(1024);\n        buf.append(\"Timing\\n\");\n        buf.append(\"0-1: \").append(t1 - t0).append('\\n');\n        buf.append(\"1-2: \").append(t2 - t1).append('\\n');\n        buf.append(\"2-3: \").append(t3 - t2).append('\\n');\n        //buf.append(\"3-4: \").append(t4-t3).append('\\n');\n        //buf.append(\"4-5: \").append(t5-t4).append('\\n');\n        //buf.append(\"5-6: \").append(t6-t5).append('\\n');\n        //buf.append(\"6-7: \").append(t7-t6).append('\\n');\n        buf.append(\"7-8: \").append(t8 - t7).append('\\n');\n        buf.append(\"8-9: \").append(t9 - t8).append('\\n');\n        buf.append(\"9-10: \").append(t10 - t9).append('\\n');\n        //_log.debug(buf.toString());\n         */\n        long end = _context.clock().now();\n\n        long diff = end - start;\n        if (diff > 1000) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"Took too long to encrypt ElGamal block (\" + diff + \"ms)\");\n        }\n\n        _context.statManager().addRateData(\"crypto.elGamal.encrypt\", diff, diff);\n        return out;\n    }","id":11725,"modified_method":"/** encrypt the data to the public key\n     * @return encrypted data, will be exactly 514 bytes long\n     *         Contains the two-part encrypted data starting at bytes 0 and 257.\n     *         If the encrypted parts are smaller than 257 bytes, they will be\n     *         padded with leading zeros.\n     *         The parts appear to always be 256 bytes or less, in other words,\n     *         bytes 0 and 257 are always zero.\n     * @param publicKey public key encrypt to\n     * @param data data to encrypt, must be 222 bytes or less\n     *         As the encrypted data may contain a substantial number of zeros if the\n     *         cleartext is smaller than 222 bytes, it is recommended that the caller pad\n     *         the cleartext to 222 bytes with random data.\n     */\n    public byte[] encrypt(byte data[], PublicKey publicKey) {\n        if ((data == null) || (data.length >= 223))\n            throw new IllegalArgumentException(\"Data to encrypt must be < 223 bytes at the moment\");\n        if (publicKey == null) throw new IllegalArgumentException(\"Null public key specified\");\n\n        long start = _context.clock().now();\n\n        byte d2[] = new byte[1+Hash.HASH_LENGTH+data.length];\n        // FIXME this isn't a random nonzero byte!\n        d2[0] = (byte)0xFF;\n        _context.sha().calculateHash(data, 0, data.length, d2, 1);\n        System.arraycopy(data, 0, d2, 1+Hash.HASH_LENGTH, data.length);\n        \n        //long t0 = _context.clock().now();\n        BigInteger m = new NativeBigInteger(1, d2);\n        //long t1 = _context.clock().now();\n        if (m.compareTo(CryptoConstants.elgp) >= 0)\n            throw new IllegalArgumentException(\"ARGH.  Data cannot be larger than the ElGamal prime.  FIXME\");\n        //long t2 = _context.clock().now();\n        BigInteger aalpha = new NativeBigInteger(1, publicKey.getData());\n        //long t3 = _context.clock().now();\n        BigInteger yk[] = getNextYK();\n        BigInteger k = yk[1];\n        BigInteger y = yk[0];\n\n        //long t7 = _context.clock().now();\n        BigInteger d = aalpha.modPow(k, CryptoConstants.elgp);\n        //long t8 = _context.clock().now();\n        d = d.multiply(m);\n        //long t9 = _context.clock().now();\n        d = d.mod(CryptoConstants.elgp);\n        //long t10 = _context.clock().now();\n\n        byte[] ybytes = y.toByteArray();\n        byte[] dbytes = d.toByteArray();\n        byte[] out = new byte[514];\n        System.arraycopy(ybytes, 0, out, (ybytes.length < 257 ? 257 - ybytes.length : 0),\n                         (ybytes.length > 257 ? 257 : ybytes.length));\n        System.arraycopy(dbytes, 0, out, (dbytes.length < 257 ? 514 - dbytes.length : 257),\n                         (dbytes.length > 257 ? 257 : dbytes.length));\n        /*\n        StringBuilder buf = new StringBuilder(1024);\n        buf.append(\"Timing\\n\");\n        buf.append(\"0-1: \").append(t1 - t0).append('\\n');\n        buf.append(\"1-2: \").append(t2 - t1).append('\\n');\n        buf.append(\"2-3: \").append(t3 - t2).append('\\n');\n        //buf.append(\"3-4: \").append(t4-t3).append('\\n');\n        //buf.append(\"4-5: \").append(t5-t4).append('\\n');\n        //buf.append(\"5-6: \").append(t6-t5).append('\\n');\n        //buf.append(\"6-7: \").append(t7-t6).append('\\n');\n        buf.append(\"7-8: \").append(t8 - t7).append('\\n');\n        buf.append(\"8-9: \").append(t9 - t8).append('\\n');\n        buf.append(\"9-10: \").append(t10 - t9).append('\\n');\n        //_log.debug(buf.toString());\n         */\n        long end = _context.clock().now();\n\n        long diff = end - start;\n        if (diff > 1000) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"Took too long to encrypt ElGamal block (\" + diff + \"ms)\");\n        }\n\n        _context.statManager().addRateData(\"crypto.elGamal.encrypt\", diff, diff);\n        return out;\n    }","commit_id":"3d5beece876c6210bb21bc56728681dcc1b7653e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  We are Alice, so receive these bytes as part of an outbound connection.\n     *  This method receives messages 2 and 4, and sends message 3.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveOutbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"Receive outbound \" + src + \" received=\" + _received);\n\n        // recv Y+E(H(X+Y)+tsB, sk, Y[239:255])\n        while (_received < _Y.length && src.hasRemaining()) {\n            byte c = src.get();\n            _Y[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            if (_received >= _Y.length) {\n                try {\n                    _dh.setPeerPublicValue(_Y);\n                    _dh.getSessionKey(); // force the calc\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n                    _e_hXY_tsB = new byte[Hash.HASH_LENGTH+4+12];\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1, 0);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n        }\n        if (_e_hXY_tsB == null) return; // !src.hasRemaining\n\n        while (_received < _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            int i = _received-_Y.length;\n            _received++;\n            byte c = src.get();\n            _e_hXY_tsB[i] = c;\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix() + \"recv _e_hXY_tsB \" + (int)c + \" received=\" + _received);\n            if (i+1 >= _e_hXY_tsB.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix() + \"received _e_hXY_tsB fully\");\n                byte hXY_tsB[] = new byte[_e_hXY_tsB.length];\n                _context.aes().decrypt(_e_hXY_tsB, 0, hXY_tsB, 0, _dh.getSessionKey(), _Y, _Y.length-16, _e_hXY_tsB.length);\n                byte XY[] = new byte[_X.length + _Y.length];\n                System.arraycopy(_X, 0, XY, 0, _X.length);\n                System.arraycopy(_Y, 0, XY, _X.length, _Y.length);\n                Hash h = _context.sha().calculateHash(XY);\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix() + \"h(XY)=\" + h.toBase64());\n                if (!DataHelper.eq(h.getData(), 0, hXY_tsB, 0, Hash.HASH_LENGTH)) {\n                    _context.statManager().addRateData(\"ntcp.invalidHXY\", 1, 0);\n                    fail(\"Invalid H(X+Y) - mitm attack attempted?\");\n                    return;\n                }\n                _tsB = DataHelper.fromLong(hXY_tsB, Hash.HASH_LENGTH, 4); // their (Bob's) timestamp in seconds\n                _tsA = (_context.clock().now() + 500) / 1000; // our (Alice's) timestamp in seconds\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"h(X+Y) is correct, tsA-tsB=\" + (_tsA-_tsB));\n\n                // the skew is not authenticated yet, but it is certainly fatal to\n                // the establishment, so fail hard if appropriate\n                long diff = 1000*Math.abs(_tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    _context.clock().setOffset(1000 * (_tsB - _tsA), true);\n                    _tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidOutboundSkew\", diff, 0);\n                    _transport.markReachable(_con.getRemotePeer().calculateHash(), false);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       _con.getRemotePeer().calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(_tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                // now prepare and send our response\n                // send E(#+Alice.identity+tsA+padding+S(X+Y+Bob.identHash+tsA+tsB), sk, hX_xor_Bob.identHash[16:31])\n                int sigSize = _X.length+_Y.length+Hash.HASH_LENGTH+4+4;//+12;\n                byte preSign[] = new byte[sigSize];\n                System.arraycopy(_X, 0, preSign, 0, _X.length);\n                System.arraycopy(_Y, 0, preSign, _X.length, _Y.length);\n                System.arraycopy(_con.getRemotePeer().calculateHash().getData(), 0, preSign, _X.length+_Y.length, Hash.HASH_LENGTH);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH, 4, _tsA);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4, 4, _tsB);\n                // hXY_tsB has 12 bytes of padding (size=48, tsB=4 + hXY=32)\n                //System.arraycopy(hXY_tsB, hXY_tsB.length-12, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, 12);\n                //byte sigPad[] = new byte[padSig];\n                //_context.random().nextBytes(sigPad);\n                //System.arraycopy(sigPad, 0, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, padSig);\n                Signature sig = _context.dsa().sign(preSign, _context.keyManager().getSigningPrivateKey());\n\n                //if (_log.shouldLog(Log.DEBUG)) {\n                //    _log.debug(prefix()+\"signing \" + Base64.encode(preSign));\n                //}\n\n                byte ident[] = _context.router().getRouterInfo().getIdentity().toByteArray();\n                int min = 2+ident.length+4+Signature.SIGNATURE_BYTES;\n                int rem = min % 16;\n                int padding = 0;\n                if (rem > 0)\n                    padding = 16 - rem;\n                byte preEncrypt[] = new byte[min+padding];\n                DataHelper.toLong(preEncrypt, 0, 2, ident.length);\n                System.arraycopy(ident, 0, preEncrypt, 2, ident.length);\n                DataHelper.toLong(preEncrypt, 2+ident.length, 4, _tsA);\n                if (padding > 0)\n                    _context.random().nextBytes(preEncrypt, 2 + ident.length + 4, padding);\n                System.arraycopy(sig.getData(), 0, preEncrypt, 2+ident.length+4+padding, Signature.SIGNATURE_BYTES);\n\n                _prevEncrypted = new byte[preEncrypt.length];\n                _context.aes().encrypt(preEncrypt, 0, _prevEncrypted, 0, _dh.getSessionKey(), _hX_xor_bobIdentHash, _hX_xor_bobIdentHash.length-16, preEncrypt.length);\n\n                if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix() + \"unencrypted response to Bob: \" + Base64.encode(preEncrypt));\n                    //_log.debug(prefix() + \"encrypted response to Bob: \" + Base64.encode(_prevEncrypted));\n                }\n                // send 'er off (when the bw limiter says, etc)\n                _transport.getPumper().wantsWrite(_con, _prevEncrypted);\n            }\n        }\n        if (_received >= _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            // we are receiving their confirmation\n\n            // recv E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev)\n            int off = 0;\n            if (_e_bobSig == null) {\n                _e_bobSig = new byte[48];\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"receiving E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" + src.hasRemaining() + \")\");\n            } else {\n                off = _received - _Y.length - _e_hXY_tsB.length;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"continuing to receive E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" + src.hasRemaining() + \" off=\" + off + \" recv=\" + _received + \")\");\n            }\n            while (src.hasRemaining() && off < _e_bobSig.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"recv bobSig received=\" + _received);\n                _e_bobSig[off++] = src.get();\n                _received++;\n\n                if (off >= _e_bobSig.length) {\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix() + \"received E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev): \" + Base64.encode(_e_bobSig));\n                    byte bobSig[] = new byte[_e_bobSig.length];\n                    _context.aes().decrypt(_e_bobSig, 0, bobSig, 0, _dh.getSessionKey(), _e_hXY_tsB, _e_hXY_tsB.length-16, _e_bobSig.length);\n                    // ignore the padding\n                    byte bobSigData[] = new byte[Signature.SIGNATURE_BYTES];\n                    System.arraycopy(bobSig, 0, bobSigData, 0, Signature.SIGNATURE_BYTES);\n                    Signature sig = new Signature(bobSigData);\n\n                    byte toVerify[] = new byte[_X.length+_Y.length+Hash.HASH_LENGTH+4+4];\n                    int voff = 0;\n                    System.arraycopy(_X, 0, toVerify, voff, _X.length); voff += _X.length;\n                    System.arraycopy(_Y, 0, toVerify, voff, _Y.length); voff += _Y.length;\n                    System.arraycopy(_context.routerHash().getData(), 0, toVerify, voff, Hash.HASH_LENGTH); voff += Hash.HASH_LENGTH;\n                    DataHelper.toLong(toVerify, voff, 4, _tsA); voff += 4;\n                    DataHelper.toLong(toVerify, voff, 4, _tsB); voff += 4;\n\n                    _verified = _context.dsa().verifySignature(sig, toVerify, _con.getRemotePeer().getSigningPublicKey());\n                    if (!_verified) {\n                        _context.statManager().addRateData(\"ntcp.invalidSignature\", 1, 0);\n                        fail(\"Signature was invalid - attempt to spoof \" + _con.getRemotePeer().calculateHash().toBase64() + \"?\");\n                    } else {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix() + \"signature verified from Bob.  done!\");\n                        prepareExtra(src);\n                        byte nextWriteIV[] = new byte[16];\n                        System.arraycopy(_prevEncrypted, _prevEncrypted.length-16, nextWriteIV, 0, 16);\n                        byte nextReadIV[] = new byte[16];\n                        System.arraycopy(_e_bobSig, _e_bobSig.length-16, nextReadIV, 0, nextReadIV.length);\n                        _con.finishOutboundEstablishment(_dh.getSessionKey(), (_tsA-_tsB), nextWriteIV, nextReadIV); // skew in seconds\n                        // if socket gets closed this will be null - prevent NPE\n                        InetAddress ia = _con.getChannel().socket().getInetAddress();\n                        if (ia != null)\n                            _transport.setIP(_con.getRemotePeer().calculateHash(), ia.getAddress());\n                    }\n                    return;\n                }\n            }\n        }\n    }","id":11726,"modified_method":"/**\n     *  We are Alice, so receive these bytes as part of an outbound connection.\n     *  This method receives messages 2 and 4, and sends message 3.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveOutbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"Receive outbound \" + src + \" received=\" + _received);\n\n        // recv Y+E(H(X+Y)+tsB, sk, Y[239:255])\n        while (_received < _Y.length && src.hasRemaining()) {\n            byte c = src.get();\n            _Y[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            if (_received >= _Y.length) {\n                try {\n                    _dh.setPeerPublicValue(_Y);\n                    _dh.getSessionKey(); // force the calc\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n                    _e_hXY_tsB = new byte[Hash.HASH_LENGTH+4+12];\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n        }\n        if (_e_hXY_tsB == null) return; // !src.hasRemaining\n\n        while (_received < _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            int i = _received-_Y.length;\n            _received++;\n            byte c = src.get();\n            _e_hXY_tsB[i] = c;\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix() + \"recv _e_hXY_tsB \" + (int)c + \" received=\" + _received);\n            if (i+1 >= _e_hXY_tsB.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix() + \"received _e_hXY_tsB fully\");\n                byte hXY_tsB[] = new byte[_e_hXY_tsB.length];\n                _context.aes().decrypt(_e_hXY_tsB, 0, hXY_tsB, 0, _dh.getSessionKey(), _Y, _Y.length-16, _e_hXY_tsB.length);\n                byte XY[] = new byte[_X.length + _Y.length];\n                System.arraycopy(_X, 0, XY, 0, _X.length);\n                System.arraycopy(_Y, 0, XY, _X.length, _Y.length);\n                byte[] h = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                _context.sha().calculateHash(XY, 0, XY.length, h, 0);\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(prefix() + \"h(XY)=\" + h.toBase64());\n                if (!DataHelper.eq(h, 0, hXY_tsB, 0, Hash.HASH_LENGTH)) {\n                    SimpleByteCache.release(h);\n                    _context.statManager().addRateData(\"ntcp.invalidHXY\", 1);\n                    fail(\"Invalid H(X+Y) - mitm attack attempted?\");\n                    return;\n                }\n                SimpleByteCache.release(h);\n                _tsB = DataHelper.fromLong(hXY_tsB, Hash.HASH_LENGTH, 4); // their (Bob's) timestamp in seconds\n                _tsA = (_context.clock().now() + 500) / 1000; // our (Alice's) timestamp in seconds\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"h(X+Y) is correct, tsA-tsB=\" + (_tsA-_tsB));\n\n                // the skew is not authenticated yet, but it is certainly fatal to\n                // the establishment, so fail hard if appropriate\n                long diff = 1000*Math.abs(_tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    _context.clock().setOffset(1000 * (_tsB - _tsA), true);\n                    _tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidOutboundSkew\", diff);\n                    _transport.markReachable(_con.getRemotePeer().calculateHash(), false);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       _con.getRemotePeer().calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(_tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                // now prepare and send our response\n                // send E(#+Alice.identity+tsA+padding+S(X+Y+Bob.identHash+tsA+tsB), sk, hX_xor_Bob.identHash[16:31])\n                int sigSize = _X.length+_Y.length+Hash.HASH_LENGTH+4+4;//+12;\n                byte preSign[] = new byte[sigSize];\n                System.arraycopy(_X, 0, preSign, 0, _X.length);\n                System.arraycopy(_Y, 0, preSign, _X.length, _Y.length);\n                System.arraycopy(_con.getRemotePeer().calculateHash().getData(), 0, preSign, _X.length+_Y.length, Hash.HASH_LENGTH);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH, 4, _tsA);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4, 4, _tsB);\n                // hXY_tsB has 12 bytes of padding (size=48, tsB=4 + hXY=32)\n                //System.arraycopy(hXY_tsB, hXY_tsB.length-12, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, 12);\n                //byte sigPad[] = new byte[padSig];\n                //_context.random().nextBytes(sigPad);\n                //System.arraycopy(sigPad, 0, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, padSig);\n                Signature sig = _context.dsa().sign(preSign, _context.keyManager().getSigningPrivateKey());\n\n                //if (_log.shouldLog(Log.DEBUG)) {\n                //    _log.debug(prefix()+\"signing \" + Base64.encode(preSign));\n                //}\n\n                byte ident[] = _context.router().getRouterInfo().getIdentity().toByteArray();\n                int min = 2+ident.length+4+Signature.SIGNATURE_BYTES;\n                int rem = min % 16;\n                int padding = 0;\n                if (rem > 0)\n                    padding = 16 - rem;\n                byte preEncrypt[] = new byte[min+padding];\n                DataHelper.toLong(preEncrypt, 0, 2, ident.length);\n                System.arraycopy(ident, 0, preEncrypt, 2, ident.length);\n                DataHelper.toLong(preEncrypt, 2+ident.length, 4, _tsA);\n                if (padding > 0)\n                    _context.random().nextBytes(preEncrypt, 2 + ident.length + 4, padding);\n                System.arraycopy(sig.getData(), 0, preEncrypt, 2+ident.length+4+padding, Signature.SIGNATURE_BYTES);\n\n                _prevEncrypted = new byte[preEncrypt.length];\n                _context.aes().encrypt(preEncrypt, 0, _prevEncrypted, 0, _dh.getSessionKey(), _hX_xor_bobIdentHash, _hX_xor_bobIdentHash.length-16, preEncrypt.length);\n\n                //if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix() + \"unencrypted response to Bob: \" + Base64.encode(preEncrypt));\n                    //_log.debug(prefix() + \"encrypted response to Bob: \" + Base64.encode(_prevEncrypted));\n                //}\n                // send 'er off (when the bw limiter says, etc)\n                _transport.getPumper().wantsWrite(_con, _prevEncrypted);\n            }\n        }\n        if (_received >= _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            // we are receiving their confirmation\n\n            // recv E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev)\n            int off = 0;\n            if (_e_bobSig == null) {\n                _e_bobSig = new byte[48];\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"receiving E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" + src.hasRemaining() + \")\");\n            } else {\n                off = _received - _Y.length - _e_hXY_tsB.length;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"continuing to receive E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" + src.hasRemaining() + \" off=\" + off + \" recv=\" + _received + \")\");\n            }\n            while (src.hasRemaining() && off < _e_bobSig.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"recv bobSig received=\" + _received);\n                _e_bobSig[off++] = src.get();\n                _received++;\n\n                if (off >= _e_bobSig.length) {\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix() + \"received E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev): \" + Base64.encode(_e_bobSig));\n                    byte bobSig[] = new byte[_e_bobSig.length];\n                    _context.aes().decrypt(_e_bobSig, 0, bobSig, 0, _dh.getSessionKey(), _e_hXY_tsB, _e_hXY_tsB.length-16, _e_bobSig.length);\n                    // ignore the padding\n                    byte bobSigData[] = new byte[Signature.SIGNATURE_BYTES];\n                    System.arraycopy(bobSig, 0, bobSigData, 0, Signature.SIGNATURE_BYTES);\n                    Signature sig = new Signature(bobSigData);\n\n                    byte toVerify[] = new byte[_X.length+_Y.length+Hash.HASH_LENGTH+4+4];\n                    int voff = 0;\n                    System.arraycopy(_X, 0, toVerify, voff, _X.length); voff += _X.length;\n                    System.arraycopy(_Y, 0, toVerify, voff, _Y.length); voff += _Y.length;\n                    System.arraycopy(_context.routerHash().getData(), 0, toVerify, voff, Hash.HASH_LENGTH); voff += Hash.HASH_LENGTH;\n                    DataHelper.toLong(toVerify, voff, 4, _tsA); voff += 4;\n                    DataHelper.toLong(toVerify, voff, 4, _tsB); voff += 4;\n\n                    _verified = _context.dsa().verifySignature(sig, toVerify, _con.getRemotePeer().getSigningPublicKey());\n                    if (!_verified) {\n                        _context.statManager().addRateData(\"ntcp.invalidSignature\", 1);\n                        fail(\"Signature was invalid - attempt to spoof \" + _con.getRemotePeer().calculateHash().toBase64() + \"?\");\n                    } else {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix() + \"signature verified from Bob.  done!\");\n                        prepareExtra(src);\n                        byte nextWriteIV[] = new byte[16];\n                        System.arraycopy(_prevEncrypted, _prevEncrypted.length-16, nextWriteIV, 0, 16);\n                        byte nextReadIV[] = new byte[16];\n                        System.arraycopy(_e_bobSig, _e_bobSig.length-16, nextReadIV, 0, nextReadIV.length);\n                        _con.finishOutboundEstablishment(_dh.getSessionKey(), (_tsA-_tsB), nextWriteIV, nextReadIV); // skew in seconds\n                        // if socket gets closed this will be null - prevent NPE\n                        InetAddress ia = _con.getChannel().socket().getInetAddress();\n                        if (ia != null)\n                            _transport.setIP(_con.getRemotePeer().calculateHash(), ia.getAddress());\n                    }\n                    return;\n                }\n            }\n        }\n    }","commit_id":"9d7a9c98952b101366219bd4761686e32c949463","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  we are Bob, so receive these bytes as part of an inbound connection\n     *  This method receives messages 1 and 3, and sends messages 2 and 4.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveInbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(prefix()+\"Receiving inbound: prev received=\" + _received + \" src.remaining=\" + src.remaining());\n        while (_received < _X.length && src.hasRemaining()) {\n            byte c = src.get();\n            _X[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            if (_received >= _X.length) {\n                if (isCheckInfo(_context, _context.routerHash(), _X)) {\n                    _context.statManager().addRateData(\"ntcp.inboundCheckConnection\", 1, 0);\n                    fail(\"Incoming connection was a check connection\");\n                    return;\n                }\n            }\n        }\n        while (_received < _X.length + _hX_xor_bobIdentHash.length && src.hasRemaining()) {\n            int i = _received-_X.length;\n            _received++;\n            byte c = src.get();\n            _hX_xor_bobIdentHash[i] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv bih\" + (int)c + \" received=\" + _received);\n        }\n\n        if (_received >= _X.length + _hX_xor_bobIdentHash.length) {\n            if (_dh.getSessionKey() == null) {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"Enough data for a DH received\");\n\n                // first verify that Alice knows who she is trying to talk with and that the X\n                // isn't corrupt\n                Hash hX = _context.sha().calculateHash(_X);\n                byte realXor[] = DataHelper.xor(hX.getData(), _context.routerHash().getData());\n                if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix()+\"_X = \" + Base64.encode(_X));\n                    _log.debug(prefix()+\"hx = \" + Base64.encode(hX.getData()));\n                    _log.debug(prefix()+\"bih=\" + Base64.encode(_context.routerHash().getData()));\n                    _log.debug(prefix()+\"xor=\" + Base64.encode(realXor));\n                }\n                if (!DataHelper.eq(realXor, _hX_xor_bobIdentHash)) {\n                    _context.statManager().addRateData(\"ntcp.invalidHXxorBIH\", 1, 0);\n                    fail(\"Invalid hX_xor\");\n                    return;\n                }\n                try {\n                    // ok, they're actually trying to talk to us, and we got their (unauthenticated) X\n                    _dh.setPeerPublicValue(_X);\n                    _dh.getSessionKey(); // force the calc\n                    System.arraycopy(realXor, 16, _prevEncrypted, 0, _prevEncrypted.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n\n                    // now prepare our response: Y+E(H(X+Y)+tsB+padding, sk, Y[239:255])\n                    _Y = _dh.getMyPublicValueBytes();\n                    byte xy[] = new byte[_X.length+_Y.length];\n                    System.arraycopy(_X, 0, xy, 0, _X.length);\n                    System.arraycopy(_Y, 0, xy, _X.length, _Y.length);\n                    Hash hxy = _context.sha().calculateHash(xy);\n                    _tsB = (_context.clock().now() + 500) / 1000l; // our (Bob's) timestamp in seconds\n                    byte toEncrypt[] = new byte[hxy.getData().length + (4 + 12)];\n                    System.arraycopy(hxy.getData(), 0, toEncrypt, 0, hxy.getData().length);\n                    byte tsB[] = DataHelper.toLong(4, _tsB);\n                    System.arraycopy(tsB, 0, toEncrypt, hxy.getData().length, tsB.length);\n                    //DataHelper.toLong(toEncrypt, hxy.getData().length, 4, _tsB);\n                    _context.random().nextBytes(toEncrypt, hxy.getData().length + 4, 12);\n                    if (_log.shouldLog(Log.DEBUG)) {\n                        //_log.debug(prefix()+\"Y=\"+Base64.encode(_Y));\n                        //_log.debug(prefix()+\"x+y=\"+Base64.encode(xy));\n                        _log.debug(prefix()+\"h(x+y)=\"+Base64.encode(hxy.getData()));\n                        _log.debug(prefix()+\"tsb=\"+Base64.encode(tsB));\n                        _log.debug(prefix()+\"unencrypted H(X+Y)+tsB+padding: \" + Base64.encode(toEncrypt));\n                        _log.debug(prefix()+\"encryption iv= \" + Base64.encode(_Y, _Y.length-16, 16));\n                        _log.debug(prefix()+\"encryption key= \" + _dh.getSessionKey().toBase64());\n                    }\n                    _e_hXY_tsB = new byte[toEncrypt.length];\n                    _context.aes().encrypt(toEncrypt, 0, _e_hXY_tsB, 0, _dh.getSessionKey(), _Y, _Y.length-16, toEncrypt.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"encrypted H(X+Y)+tsB+padding: \" + Base64.encode(_e_hXY_tsB));\n                    byte write[] = new byte[_Y.length + _e_hXY_tsB.length];\n                    System.arraycopy(_Y, 0, write, 0, _Y.length);\n                    System.arraycopy(_e_hXY_tsB, 0, write, _Y.length, _e_hXY_tsB.length);\n\n                    // ok, now that is prepared, we want to actually send it, so make sure we are up for writing\n                    _transport.getPumper().wantsWrite(_con, write);\n                    if (!src.hasRemaining()) return;\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1, 0);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n\n            // ok, we are onto the encrypted area\n            while (src.hasRemaining() && !_corrupt) {\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(prefix()+\"Encrypted bytes available (\" + src.hasRemaining() + \")\");\n                while (_curEncryptedOffset < _curEncrypted.length && src.hasRemaining()) {\n                    _curEncrypted[_curEncryptedOffset++] = src.get();\n                    _received++;\n                }\n                if (_curEncryptedOffset >= _curEncrypted.length) {\n                    _context.aes().decrypt(_curEncrypted, 0, _curDecrypted, 0, _dh.getSessionKey(), _prevEncrypted, 0, _curEncrypted.length);\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix()+\"full block read and decrypted: \" + Base64.encode(_curDecrypted));\n\n                    byte swap[] = new byte[16];\n                    _prevEncrypted = _curEncrypted;\n                    _curEncrypted = swap;\n                    _curEncryptedOffset = 0;\n\n                    if (_aliceIdentSize <= 0) { // we are on the first decrypted block\n                        _aliceIdentSize = (int)DataHelper.fromLong(_curDecrypted, 0, 2);\n                        _sz_aliceIdent_tsA_padding_aliceSigSize = 2 + _aliceIdentSize + 4 + Signature.SIGNATURE_BYTES;\n                        int rem = (_sz_aliceIdent_tsA_padding_aliceSigSize % 16);\n                        int padding = 0;\n                        if (rem > 0)\n                            padding = 16-rem;\n                        _sz_aliceIdent_tsA_padding_aliceSigSize += padding;\n                        try {\n                            _sz_aliceIdent_tsA_padding_aliceSig.write(_curDecrypted);\n                        } catch (IOException ioe) {\n                            if (_log.shouldLog(Log.ERROR)) _log.error(prefix()+\"Error writing to the baos?\", ioe);\n                        }\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix()+\"alice ident size decrypted as \" + _aliceIdentSize + \", making the padding at \" + padding + \" and total size at \" + _sz_aliceIdent_tsA_padding_aliceSigSize);\n                    } else {\n                        // subsequent block...\n                        try {\n                            _sz_aliceIdent_tsA_padding_aliceSig.write(_curDecrypted);\n                        } catch (IOException ioe) {\n                            if (_log.shouldLog(Log.ERROR)) _log.error(prefix()+\"Error writing to the baos?\", ioe);\n                        }\n                        //if (_log.shouldLog(Log.DEBUG))\n                        //    _log.debug(prefix()+\"subsequent block decrypted (\" + _sz_aliceIdent_tsA_padding_aliceSig.size() + \")\");\n\n                        if (_sz_aliceIdent_tsA_padding_aliceSig.size() >= _sz_aliceIdent_tsA_padding_aliceSigSize) {\n                            verifyInbound();\n                            if (!_corrupt && _verified && src.hasRemaining())\n                                prepareExtra(src);\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(prefix()+\"verifying size (sz=\" + _sz_aliceIdent_tsA_padding_aliceSig.size()\n                                           + \" expected=\" + _sz_aliceIdent_tsA_padding_aliceSigSize\n                                           + \" corrupt=\" + _corrupt\n                                           + \" verified=\" + _verified + \" extra=\" + (_extra != null ? _extra.length : 0) + \")\");\n                            return;\n                        }\n                    }\n                } else {\n                    // no more bytes available in the buffer, and only a partial\n                    // block was read, so we can't decrypt it.\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"end of available data with only a partial block read (\" + _curEncryptedOffset + \", \" + _received + \")\");\n                }\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix()+\"done with the data, not yet complete or corrupt\");\n        }\n    }","id":11727,"modified_method":"/**\n     *  we are Bob, so receive these bytes as part of an inbound connection\n     *  This method receives messages 1 and 3, and sends messages 2 and 4.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveInbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(prefix()+\"Receiving inbound: prev received=\" + _received + \" src.remaining=\" + src.remaining());\n        while (_received < _X.length && src.hasRemaining()) {\n            byte c = src.get();\n            _X[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            //if (_received >= _X.length) {\n            //    if (isCheckInfo(_context, _context.routerHash(), _X)) {\n            //        _context.statManager().addRateData(\"ntcp.inboundCheckConnection\", 1);\n            //        fail(\"Incoming connection was a check connection\");\n            //        return;\n            //    }\n            //}\n        }\n        while (_received < _X.length + _hX_xor_bobIdentHash.length && src.hasRemaining()) {\n            int i = _received-_X.length;\n            _received++;\n            byte c = src.get();\n            _hX_xor_bobIdentHash[i] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv bih\" + (int)c + \" received=\" + _received);\n        }\n\n        if (_received >= _X.length + _hX_xor_bobIdentHash.length) {\n            if (_dh.getSessionKey() == null) {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"Enough data for a DH received\");\n\n                // first verify that Alice knows who she is trying to talk with and that the X\n                // isn't corrupt\n                byte[] realXor = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                _context.sha().calculateHash(_X, 0, _X.length, realXor, 0);\n                xor32(_context.routerHash().getData(), realXor);\n                //if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix()+\"_X = \" + Base64.encode(_X));\n                //    _log.debug(prefix()+\"hx = \" + Base64.encode(hX.getData()));\n                //    _log.debug(prefix()+\"bih=\" + Base64.encode(_context.routerHash().getData()));\n                //    _log.debug(prefix()+\"xor=\" + Base64.encode(realXor));\n                //}\n                if (!DataHelper.eq(realXor, _hX_xor_bobIdentHash)) {\n                    SimpleByteCache.release(realXor);\n                    _context.statManager().addRateData(\"ntcp.invalidHXxorBIH\", 1);\n                    fail(\"Invalid hX_xor\");\n                    return;\n                }\n                SimpleByteCache.release(realXor);\n                if (!_transport.isHXHIValid(_hX_xor_bobIdentHash)) {\n                    // blocklist source? but spoofed IPs could DoS us\n                    _context.statManager().addRateData(\"ntcp.replayHXxorBIH\", 1);\n                    fail(\"Replay hX_xor\");\n                    return;\n                }\n\n                try {\n                    // ok, they're actually trying to talk to us, and we got their (unauthenticated) X\n                    _dh.setPeerPublicValue(_X);\n                    _dh.getSessionKey(); // force the calc\n                    System.arraycopy(realXor, 16, _prevEncrypted, 0, _prevEncrypted.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n\n                    // now prepare our response: Y+E(H(X+Y)+tsB+padding, sk, Y[239:255])\n                    _Y = _dh.getMyPublicValueBytes();\n                    byte xy[] = new byte[_X.length+_Y.length];\n                    System.arraycopy(_X, 0, xy, 0, _X.length);\n                    System.arraycopy(_Y, 0, xy, _X.length, _Y.length);\n                    byte[] hxy = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                    _context.sha().calculateHash(xy, 0, xy.length, hxy, 0);\n                    _tsB = (_context.clock().now() + 500) / 1000l; // our (Bob's) timestamp in seconds\n                    byte toEncrypt[] = new byte[hxy.length + (4 + 12)];  // 48\n                    System.arraycopy(hxy, 0, toEncrypt, 0, hxy.length);\n                    byte tsB[] = DataHelper.toLong(4, _tsB);\n                    System.arraycopy(tsB, 0, toEncrypt, hxy.length, tsB.length);\n                    //DataHelper.toLong(toEncrypt, hxy.getData().length, 4, _tsB);\n                    _context.random().nextBytes(toEncrypt, hxy.length + 4, 12);\n                    if (_log.shouldLog(Log.DEBUG)) {\n                        //_log.debug(prefix()+\"Y=\"+Base64.encode(_Y));\n                        //_log.debug(prefix()+\"x+y=\"+Base64.encode(xy));\n                        _log.debug(prefix()+\"h(x+y)=\"+Base64.encode(hxy));\n                        _log.debug(prefix()+\"tsb=\"+Base64.encode(tsB));\n                        _log.debug(prefix()+\"unencrypted H(X+Y)+tsB+padding: \" + Base64.encode(toEncrypt));\n                        _log.debug(prefix()+\"encryption iv= \" + Base64.encode(_Y, _Y.length-16, 16));\n                        _log.debug(prefix()+\"encryption key= \" + _dh.getSessionKey().toBase64());\n                    }\n                    SimpleByteCache.release(hxy);\n                    _e_hXY_tsB = new byte[toEncrypt.length];\n                    _context.aes().encrypt(toEncrypt, 0, _e_hXY_tsB, 0, _dh.getSessionKey(), _Y, _Y.length-16, toEncrypt.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"encrypted H(X+Y)+tsB+padding: \" + Base64.encode(_e_hXY_tsB));\n                    byte write[] = new byte[_Y.length + _e_hXY_tsB.length];\n                    System.arraycopy(_Y, 0, write, 0, _Y.length);\n                    System.arraycopy(_e_hXY_tsB, 0, write, _Y.length, _e_hXY_tsB.length);\n\n                    // ok, now that is prepared, we want to actually send it, so make sure we are up for writing\n                    _transport.getPumper().wantsWrite(_con, write);\n                    if (!src.hasRemaining()) return;\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n\n            // ok, we are onto the encrypted area\n            while (src.hasRemaining() && !_corrupt) {\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(prefix()+\"Encrypted bytes available (\" + src.hasRemaining() + \")\");\n                while (_curEncryptedOffset < _curEncrypted.length && src.hasRemaining()) {\n                    _curEncrypted[_curEncryptedOffset++] = src.get();\n                    _received++;\n                }\n                if (_curEncryptedOffset >= _curEncrypted.length) {\n                    _context.aes().decrypt(_curEncrypted, 0, _curDecrypted, 0, _dh.getSessionKey(), _prevEncrypted, 0, _curEncrypted.length);\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix()+\"full block read and decrypted: \" + Base64.encode(_curDecrypted));\n\n                    byte swap[] = new byte[16];\n                    _prevEncrypted = _curEncrypted;\n                    _curEncrypted = swap;\n                    _curEncryptedOffset = 0;\n\n                    if (_aliceIdentSize <= 0) { // we are on the first decrypted block\n                        _aliceIdentSize = (int)DataHelper.fromLong(_curDecrypted, 0, 2);\n                        _sz_aliceIdent_tsA_padding_aliceSigSize = 2 + _aliceIdentSize + 4 + Signature.SIGNATURE_BYTES;\n                        int rem = (_sz_aliceIdent_tsA_padding_aliceSigSize % 16);\n                        int padding = 0;\n                        if (rem > 0)\n                            padding = 16-rem;\n                        _sz_aliceIdent_tsA_padding_aliceSigSize += padding;\n                        try {\n                            _sz_aliceIdent_tsA_padding_aliceSig.write(_curDecrypted);\n                        } catch (IOException ioe) {\n                            if (_log.shouldLog(Log.ERROR)) _log.error(prefix()+\"Error writing to the baos?\", ioe);\n                        }\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix()+\"alice ident size decrypted as \" + _aliceIdentSize + \", making the padding at \" + padding + \" and total size at \" + _sz_aliceIdent_tsA_padding_aliceSigSize);\n                    } else {\n                        // subsequent block...\n                        try {\n                            _sz_aliceIdent_tsA_padding_aliceSig.write(_curDecrypted);\n                        } catch (IOException ioe) {\n                            if (_log.shouldLog(Log.ERROR)) _log.error(prefix()+\"Error writing to the baos?\", ioe);\n                        }\n                        //if (_log.shouldLog(Log.DEBUG))\n                        //    _log.debug(prefix()+\"subsequent block decrypted (\" + _sz_aliceIdent_tsA_padding_aliceSig.size() + \")\");\n\n                        if (_sz_aliceIdent_tsA_padding_aliceSig.size() >= _sz_aliceIdent_tsA_padding_aliceSigSize) {\n                            verifyInbound();\n                            if (!_corrupt && _verified && src.hasRemaining())\n                                prepareExtra(src);\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(prefix()+\"verifying size (sz=\" + _sz_aliceIdent_tsA_padding_aliceSig.size()\n                                           + \" expected=\" + _sz_aliceIdent_tsA_padding_aliceSigSize\n                                           + \" corrupt=\" + _corrupt\n                                           + \" verified=\" + _verified + \" extra=\" + (_extra != null ? _extra.length : 0) + \")\");\n                            return;\n                        }\n                    }\n                } else {\n                    // no more bytes available in the buffer, and only a partial\n                    // block was read, so we can't decrypt it.\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"end of available data with only a partial block read (\" + _curEncryptedOffset + \", \" + _received + \")\");\n                }\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix()+\"done with the data, not yet complete or corrupt\");\n        }\n    }","commit_id":"9d7a9c98952b101366219bd4761686e32c949463","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * We are Bob. Verify message #3 from Alice, then send message #4 to Alice.\n     *\n     * Make sure the signatures are correct, and if they are, update the\n     * NIOConnection with the session key / peer ident / clock skew / iv.\n     * The NIOConnection itself is responsible for registering with the\n     * transport\n     */\n    private void verifyInbound() {\n        if (_corrupt) return;\n        byte b[] = _sz_aliceIdent_tsA_padding_aliceSig.toByteArray();\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(prefix()+\"decrypted sz(etc) data: \" + Base64.encode(b));\n\n        try {\n            RouterIdentity alice = new RouterIdentity();\n            int sz = (int)DataHelper.fromLong(b, 0, 2); // TO-DO: Hey zzz... Throws an NPE for me... see below, for my \"quick fix\", need to find out the real reason\n            if ( (sz <= 0) || (sz > b.length-2-4-Signature.SIGNATURE_BYTES) ) {\n                _context.statManager().addRateData(\"ntcp.invalidInboundSize\", sz, 0);\n                fail(\"size is invalid\", new Exception(\"size is \" + sz));\n                return;\n            }\n            byte aliceData[] = new byte[sz];\n            System.arraycopy(b, 2, aliceData, 0, sz);\n            alice.fromByteArray(aliceData);\n            long tsA = DataHelper.fromLong(b, 2+sz, 4);\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream(768);\n            baos.write(_X);\n            baos.write(_Y);\n            baos.write(_context.routerHash().getData());\n            baos.write(DataHelper.toLong(4, tsA));\n            baos.write(DataHelper.toLong(4, _tsB));\n            //baos.write(b, 2+sz+4, b.length-2-sz-4-Signature.SIGNATURE_BYTES);\n\n            byte toVerify[] = baos.toByteArray();\n            if (_log.shouldLog(Log.DEBUG)) {\n                _log.debug(prefix()+\"checking \" + Base64.encode(toVerify, 0, 16));\n                //_log.debug(prefix()+\"check pad \" + Base64.encode(b, 2+sz+4, 12));\n            }\n\n            byte s[] = new byte[Signature.SIGNATURE_BYTES];\n            System.arraycopy(b, b.length-s.length, s, 0, s.length);\n            Signature sig = new Signature(s);\n            _verified = _context.dsa().verifySignature(sig, toVerify, alice.getSigningPublicKey());\n            if (_verified) {\n\t\t\t\t// get inet-addr\n\t\t\t\tInetAddress addr = this._con.getChannel().socket().getInetAddress();\n                byte[] ip = (addr == null) ? null : addr.getAddress();\n                if (_context.banlist().isBanlistedForever(alice.calculateHash())) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Dropping inbound connection from permanently banlisted peer: \" + alice.calculateHash().toBase64());\n                    // So next time we will not accept the con from this IP,\n                    // rather than doing the whole handshake\n\t\t\t\t\tif(ip != null)\n\t\t\t\t\t\t_context.blocklist().add(ip);\n                    fail(\"Peer is banlisted forever: \" + alice.calculateHash().toBase64());\n                    return;\n                }\n\t\t\t\tif(ip != null)\n\t\t\t\t\t_transport.setIP(alice.calculateHash(), ip);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"verification successful for \" + _con);\n\n                long diff = 1000*Math.abs(tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    // This isn't very likely, outbound will do it first\n                    _context.clock().setOffset(1000 * (_tsB - tsA), true);\n                    tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidInboundSkew\", diff, 0);\n                    _transport.markReachable(alice.calculateHash(), true);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       alice.calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                sendInboundConfirm(alice, tsA);\n                _con.setRemotePeer(alice);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"e_bobSig is \" + _e_bobSig.length + \" bytes long\");\n                byte iv[] = new byte[16];\n                System.arraycopy(_e_bobSig, _e_bobSig.length-16, iv, 0, 16);\n                _con.finishInboundEstablishment(_dh.getSessionKey(), (tsA-_tsB), iv, _prevEncrypted); // skew in seconds\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(prefix()+\"Verified remote peer as \" + alice.calculateHash().toBase64());\n            } else {\n                _context.statManager().addRateData(\"ntcp.invalidInboundSignature\", 1, 0);\n                fail(\"Peer verification failed - spoof of \" + alice.calculateHash().toBase64() + \"?\");\n            }\n        } catch (IOException ioe) {\n            _context.statManager().addRateData(\"ntcp.invalidInboundIOE\", 1, 0);\n            fail(\"Error verifying peer\", ioe);\n        } catch (DataFormatException dfe) {\n            _context.statManager().addRateData(\"ntcp.invalidInboundDFE\", 1, 0);\n            fail(\"Error verifying peer\", dfe);\n        } catch(NullPointerException npe) {\n            fail(\"Error verifying peer\", npe); // TO-DO: zzz This is that quick-fix. -- Sponge\n        }\n    }","id":11728,"modified_method":"/**\n     * We are Bob. Verify message #3 from Alice, then send message #4 to Alice.\n     *\n     * Make sure the signatures are correct, and if they are, update the\n     * NIOConnection with the session key / peer ident / clock skew / iv.\n     * The NIOConnection itself is responsible for registering with the\n     * transport\n     */\n    private void verifyInbound() {\n        if (_corrupt) return;\n        byte b[] = _sz_aliceIdent_tsA_padding_aliceSig.toByteArray();\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(prefix()+\"decrypted sz(etc) data: \" + Base64.encode(b));\n\n        try {\n            RouterIdentity alice = new RouterIdentity();\n            int sz = (int)DataHelper.fromLong(b, 0, 2); // TO-DO: Hey zzz... Throws an NPE for me... see below, for my \"quick fix\", need to find out the real reason\n            if ( (sz <= 0) || (sz > b.length-2-4-Signature.SIGNATURE_BYTES) ) {\n                _context.statManager().addRateData(\"ntcp.invalidInboundSize\", sz);\n                fail(\"size is invalid\", new Exception(\"size is \" + sz));\n                return;\n            }\n            byte aliceData[] = new byte[sz];\n            System.arraycopy(b, 2, aliceData, 0, sz);\n            alice.fromByteArray(aliceData);\n            long tsA = DataHelper.fromLong(b, 2+sz, 4);\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream(768);\n            baos.write(_X);\n            baos.write(_Y);\n            baos.write(_context.routerHash().getData());\n            baos.write(DataHelper.toLong(4, tsA));\n            baos.write(DataHelper.toLong(4, _tsB));\n            //baos.write(b, 2+sz+4, b.length-2-sz-4-Signature.SIGNATURE_BYTES);\n\n            byte toVerify[] = baos.toByteArray();\n            if (_log.shouldLog(Log.DEBUG)) {\n                _log.debug(prefix()+\"checking \" + Base64.encode(toVerify, 0, 16));\n                //_log.debug(prefix()+\"check pad \" + Base64.encode(b, 2+sz+4, 12));\n            }\n\n            byte s[] = new byte[Signature.SIGNATURE_BYTES];\n            System.arraycopy(b, b.length-s.length, s, 0, s.length);\n            Signature sig = new Signature(s);\n            _verified = _context.dsa().verifySignature(sig, toVerify, alice.getSigningPublicKey());\n            if (_verified) {\n                // get inet-addr\n                InetAddress addr = this._con.getChannel().socket().getInetAddress();\n                byte[] ip = (addr == null) ? null : addr.getAddress();\n                if (_context.banlist().isBanlistedForever(alice.calculateHash())) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Dropping inbound connection from permanently banlisted peer: \" + alice.calculateHash().toBase64());\n                    // So next time we will not accept the con from this IP,\n                    // rather than doing the whole handshake\n                    if(ip != null)\n                       _context.blocklist().add(ip);\n                    fail(\"Peer is banlisted forever: \" + alice.calculateHash().toBase64());\n                    return;\n                }\n                if(ip != null)\n                   _transport.setIP(alice.calculateHash(), ip);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"verification successful for \" + _con);\n\n                long diff = 1000*Math.abs(tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    // This isn't very likely, outbound will do it first\n                    _context.clock().setOffset(1000 * (_tsB - tsA), true);\n                    tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidInboundSkew\", diff);\n                    _transport.markReachable(alice.calculateHash(), true);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       alice.calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                sendInboundConfirm(alice, tsA);\n                _con.setRemotePeer(alice);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"e_bobSig is \" + _e_bobSig.length + \" bytes long\");\n                byte iv[] = new byte[16];\n                System.arraycopy(_e_bobSig, _e_bobSig.length-16, iv, 0, 16);\n                _con.finishInboundEstablishment(_dh.getSessionKey(), (tsA-_tsB), iv, _prevEncrypted); // skew in seconds\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(prefix()+\"Verified remote peer as \" + alice.calculateHash().toBase64());\n            } else {\n                _context.statManager().addRateData(\"ntcp.invalidInboundSignature\", 1);\n                fail(\"Peer verification failed - spoof of \" + alice.calculateHash().toBase64() + \"?\");\n            }\n        } catch (IOException ioe) {\n            _context.statManager().addRateData(\"ntcp.invalidInboundIOE\", 1);\n            fail(\"Error verifying peer\", ioe);\n        } catch (DataFormatException dfe) {\n            _context.statManager().addRateData(\"ntcp.invalidInboundDFE\", 1);\n            fail(\"Error verifying peer\", dfe);\n        } catch(NullPointerException npe) {\n            fail(\"Error verifying peer\", npe); // TO-DO: zzz This is that quick-fix. -- Sponge\n        }\n    }","commit_id":"9d7a9c98952b101366219bd4761686e32c949463","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public EstablishState(RouterContext ctx, NTCPTransport transport, NTCPConnection con) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(getClass());\n        _transport = transport;\n        _con = con;\n        _dh = _transport.getDHBuilder();\n        _hX_xor_bobIdentHash = new byte[Hash.HASH_LENGTH];\n        if (_con.isInbound()) {\n            _X = new byte[256];\n            _sz_aliceIdent_tsA_padding_aliceSig = new ByteArrayOutputStream(512);\n        } else {\n            _X = _dh.getMyPublicValueBytes();\n            _Y = new byte[256];\n            byte hx[] = ctx.sha().calculateHash(_X).getData();\n            DataHelper.xor(hx, 0, con.getRemotePeer().calculateHash().getData(), 0, _hX_xor_bobIdentHash, 0, hx.length);\n        }\n\n        _prevEncrypted = new byte[16];\n        _curEncrypted = new byte[16];\n        _curDecrypted = new byte[16];\n    }","id":11729,"modified_method":"public EstablishState(RouterContext ctx, NTCPTransport transport, NTCPConnection con) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(getClass());\n        _transport = transport;\n        _con = con;\n        _dh = _transport.getDHBuilder();\n        _hX_xor_bobIdentHash = new byte[Hash.HASH_LENGTH];\n        if (_con.isInbound()) {\n            _X = new byte[256];\n            _sz_aliceIdent_tsA_padding_aliceSig = new ByteArrayOutputStream(512);\n        } else {\n            _X = _dh.getMyPublicValueBytes();\n            _Y = new byte[256];\n            ctx.sha().calculateHash(_X, 0, _X.length, _hX_xor_bobIdentHash, 0);\n            xor32(con.getRemotePeer().calculateHash().getData(), _hX_xor_bobIdentHash);\n        }\n\n        _prevEncrypted = new byte[16];\n        _curEncrypted = new byte[16];\n        _curDecrypted = new byte[16];\n    }","commit_id":"9d7a9c98952b101366219bd4761686e32c949463","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public NTCPTransport(RouterContext ctx, DHSessionKeyBuilder.Factory dh) {\n        super(ctx);\n        _dhFactory = dh;\n        _log = ctx.logManager().getLog(getClass());\n\n        _context.statManager().createRateStat(\"ntcp.sendTime\", \"Total message lifetime when sent completely\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendQueueSize\", \"How many messages were ahead of the current one on the connection's queue when it was first added\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveTime\", \"How long it takes to receive an inbound message\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveSize\", \"How large the received message was\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendBacklogTime\", \"How long the head of the send queue has been waiting when we fail to add a new one to the queue (period is the number of messages queued)\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeWrites\", \"How many times do we need to proactively add in an extra nio write to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeCloses\", \"How many times do we need to proactively close an idle connection to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeInvalid\", \"How many times do we close a connection to a peer to work around a JVM bug?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.accept\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptBanlistedPeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptUnreachablePeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.closeOnBacklog\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedIOE\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.connectFailedInvalidPort\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.bidRejectedLocalAddress\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.bidRejectedNoNTCPAddress\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeout\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeoutIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedUnresolved\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.connectImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectSuccessful\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptDecryptedI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIME\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptMetaCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptTooLargeI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.dontSendOnBacklog\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundCheckConnection\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablished\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablishedDuplicate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.infoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.floodInfoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidDH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXY\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXxorBIH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundDFE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSignature\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSize\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidSignature\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.liveReadBufs\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.multipleCloseOnRemove\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundEstablishFailed\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundFailedIOEImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidOutboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.noBidTooLargeI2NP\", \"send size\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.queuedRecv\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.read\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.readEOF\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.readError\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveCorruptEstablishment\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveMeta\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.registerConnect\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledReadComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledWriteComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.wantsQueuedWrite\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.write\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.writeError\", \"\", \"ntcp\", RATES);\n        _endpoints = new HashSet<InetSocketAddress>(4);\n        _establishing = new ConcurrentHashSet<NTCPConnection>(16);\n        _conLock = new Object();\n        _conByIdent = new ConcurrentHashMap<Hash, NTCPConnection>(64);\n\n        _finisher = new NTCPSendFinisher(ctx, this);\n\n        _pumper = new EventPumper(ctx, this);\n        _reader = new Reader(ctx);\n        _writer = new net.i2p.router.transport.ntcp.Writer(ctx);\n\n        _fastBid = new SharedBid(25); // best\n        _slowBid = new SharedBid(70); // better than ssu unestablished, but not better than ssu established\n        _slowCostBid = new SharedBid(85);\n        _nearCapacityBid = new SharedBid(90); // not better than ssu - save our conns for inbound\n        _nearCapacityCostBid = new SharedBid(105);\n        _transientFail = new SharedBid(TransportBid.TRANSIENT_FAIL);\n    }","id":11730,"modified_method":"public NTCPTransport(RouterContext ctx, DHSessionKeyBuilder.Factory dh) {\n        super(ctx);\n        _dhFactory = dh;\n        _log = ctx.logManager().getLog(getClass());\n\n        _context.statManager().createRateStat(\"ntcp.sendTime\", \"Total message lifetime when sent completely\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendQueueSize\", \"How many messages were ahead of the current one on the connection's queue when it was first added\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveTime\", \"How long it takes to receive an inbound message\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveSize\", \"How large the received message was\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendBacklogTime\", \"How long the head of the send queue has been waiting when we fail to add a new one to the queue (period is the number of messages queued)\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeWrites\", \"How many times do we need to proactively add in an extra nio write to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeCloses\", \"How many times do we need to proactively close an idle connection to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeInvalid\", \"How many times do we close a connection to a peer to work around a JVM bug?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.accept\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptBanlistedPeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptUnreachablePeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.closeOnBacklog\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedIOE\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.connectFailedInvalidPort\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.bidRejectedLocalAddress\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.bidRejectedNoNTCPAddress\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeout\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeoutIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedUnresolved\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.connectImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectSuccessful\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptDecryptedI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIME\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptMetaCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptTooLargeI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.dontSendOnBacklog\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.inboundCheckConnection\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablished\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablishedDuplicate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.infoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.floodInfoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidDH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXY\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXxorBIH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundDFE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSignature\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSize\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidSignature\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.liveReadBufs\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.multipleCloseOnRemove\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundEstablishFailed\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundFailedIOEImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidOutboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.noBidTooLargeI2NP\", \"send size\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.queuedRecv\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.read\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.readEOF\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.readError\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveCorruptEstablishment\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveMeta\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.registerConnect\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.replayHXxorBIH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledReadComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledWriteComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.wantsQueuedWrite\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.write\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.writeError\", \"\", \"ntcp\", RATES);\n        _endpoints = new HashSet<InetSocketAddress>(4);\n        _establishing = new ConcurrentHashSet<NTCPConnection>(16);\n        _conLock = new Object();\n        _conByIdent = new ConcurrentHashMap<Hash, NTCPConnection>(64);\n        _replayFilter = new DecayingHashSet(ctx, 10*60*1000, 32, \"NTCP-Hx^HI\");\n\n        _finisher = new NTCPSendFinisher(ctx, this);\n\n        _pumper = new EventPumper(ctx, this);\n        _reader = new Reader(ctx);\n        _writer = new net.i2p.router.transport.ntcp.Writer(ctx);\n\n        _fastBid = new SharedBid(25); // best\n        _slowBid = new SharedBid(70); // better than ssu unestablished, but not better than ssu established\n        _slowCostBid = new SharedBid(85);\n        _nearCapacityBid = new SharedBid(90); // not better than ssu - save our conns for inbound\n        _nearCapacityCostBid = new SharedBid(105);\n        _transientFail = new SharedBid(TransportBid.TRANSIENT_FAIL);\n    }","commit_id":"9d7a9c98952b101366219bd4761686e32c949463","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n    \t\n    \tString state=\"\";\n    \t\n    \t// id for group\n    \tString groupId = null;\n    \t// title for group\n    \tString groupTitle = null;\n    \t// description for group\n    \tString groupDescription = null;\n    \t// member list for group\n    \tCollection<Member> groupMembers = new Vector<Member>();\n    \t\n    \tUIForm groupForm = UIForm.make(arg0, \"groups-form\");\n\n    \t String id = ((GroupEditViewParameters) arg1).id;\n    \t if (id != null)\n    \t {\n    \t\t try\n    \t\t {\n    \t\t\t Group g = siteService.findGroup(id);\n    \t\t\t groupId = g.getId();\n    \t\t\t groupTitle = g.getTitle();\n    \t\t\t groupDescription = g.getDescription();\n    \t\t\t groupMembers = g.getMembers();\n    \t\t }\n    \t\t catch (Exception e)\n    \t\t {\n    \t\t\t M_log.debug(this + \"fillComponents: cannot get group id=\" + id);\n    \t\t }\n    \t }\n    \t else\n    \t {\n    \t\t handler.resetParams();\n    \t }\n    \t \n\n         UIOutput.make(groupForm, \"prompt\", messageLocator.getMessage(\"group.newgroup\"));\n         UIOutput.make(groupForm, \"instructions\", messageLocator.getMessage(\"editgroup.instruction\"));\n         \n         UIOutput.make(groupForm, \"group_title_label\", messageLocator.getMessage(\"group.title\"));\n         UIInput titleTextIn = UIInput.make(groupForm, \"group_title\", \"#{SiteManageGroupHandler.title}\",groupTitle);\n\t\t \n\t\t\n\t\t UIMessage groupDescrLabel = UIMessage.make(arg0, \"group_description_label\", \"group.description\"); \n\t\t UIInput groupDescr = UIInput.make(groupForm, \"group_description:\", \"#{SiteManageGroupHandler.description}\", groupDescription); \n\t\t richTextEvolver.evolveTextInput(groupDescr);\n\t\t UILabelTargetDecorator.targetLabel(groupDescrLabel, groupDescr);\n\t\t \n\t\t UIOutput.make(groupForm, \"membership_label\", messageLocator.getMessage(\"editgroup.membership\"));\n\t\t UIOutput.make(groupForm, \"membership_site_label\", messageLocator.getMessage(\"editgroup.generallist\"));\n\t\t UIOutput.make(groupForm, \"membership_group_label\", messageLocator.getMessage(\"editgroup.grouplist\"));\n\t\t \n\t\t // for the site members list\n\t\t Collection siteMembers= handler.getSiteParticipant();\n\t\t String[] siteMemberLabels = new String[siteMembers.size()];\n\t\t String[] siteMemberValues = new String[siteMembers.size()];\n\t\t UISelect siteMember = UISelect.makeMultiple(groupForm,\"siteMembers\",siteMemberValues,siteMemberLabels,\"#{SiteManageGroupHandler.selectedSiteMembers}\", new String[] {});\n\t\t \n\t\t int i =0;\n\t\t Iterator<Participant> sIterator = new SortedIterator(siteMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; sIterator.hasNext();i++){\n\t        \tParticipant p = (Participant) sIterator.next();\n\t\t\t\tsiteMemberLabels[i] = p.getName();\n\t\t\t\tsiteMemberValues[i] = p.getUniqname();\n\t        }\n\t     \n\t     // for the group members list\n\t\t String[] groupMemberLabels = new String[groupMembers.size()];\n\t\t String[] groupMemberValues = new String[groupMembers.size()];\n\t\t UISelect groupMember = UISelect.make(groupForm,\"groupMembers\",groupMemberValues,groupMemberLabels,null);\n\t\t i =0;\n\t\t Iterator<Member> gIterator = new SortedIterator(groupMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; gIterator.hasNext();i++){\n\t        \tMember p = (Member) gIterator.next();\n\t        \tString userId = p.getUserId();\n\t        \ttry\n\t        \t{\n\t        \t\tUser u = userDirectoryService.getUser(userId);\n\t        \t\tgroupMemberLabels[i] = u.getSortName();\n\t        \t}\n\t        \tcatch (Exception e)\n\t        \t{\n\t        \t\tM_log.warn(this + \":fillComponents: cannot find user \" + userId);\n\t        \t}\n\t\t\t\tgroupMemberValues[i] = userId;\n\t        }\n\t        \n    \t UICommand.make(groupForm, \"save\", id != null?messageLocator.getMessage(\"editgroup.update\"):messageLocator.getMessage(\"editgroup.new\"), \"#{SiteManageGroupHandler.processAddGroup}\");\n\n         UICommand.make(groupForm, \"cancel\", messageLocator.getMessage(\"editgroup.cancel\"), \"#{SiteManageGroupHandler.processBack}\");\n         \n         UIInput.make(groupForm, \"newRight\", \"#{SiteManageGroupHandler.memberList}\", state);\n         \n         // hidden field for group id\n         UIInput.make(groupForm, \"groupId\", \"#{SiteManageGroupHandler.id}\", groupId);\n         \n         //process any messages\n         if (tml.size() > 0) {\n \t\t\tfor (i = 0; i < tml.size(); i ++ ) {\n \t\t\t\tUIBranchContainer errorRow = UIBranchContainer.make(arg0,\"error-row:\", new Integer(i).toString());\n \t\t\t\tif (tml.messageAt(i).args != null ) {\t    \t\t\n \t\t\t\t\tUIMessage.make(errorRow,\"error\",tml.messageAt(i).acquireMessageCode(),(String[])tml.messageAt(i).args[0]);\n \t\t\t\t} else {\n \t\t    \t\t\tUIMessage.make(errorRow,\"error\",tml.messageAt(i).acquireMessageCode());\n \t\t\t\t}\n \t\t    \t\t\n \t\t\t}\n         }\n         \n         frameAdjustingProducer.fillComponents(arg0, \"resize\", \"resetFrame\");\n    }","id":11731,"modified_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n    \t\n    \tString state=\"\";\n    \t\n    \t// id for group\n    \tString groupId = null;\n    \t// title for group\n    \tString groupTitle = null;\n    \t// description for group\n    \tString groupDescription = null;\n    \t// member list for group\n    \tCollection<Member> groupMembers = new Vector<Member>();\n    \t\n    \tUIForm groupForm = UIForm.make(arg0, \"groups-form\");\n\n    \t String id = ((GroupEditViewParameters) arg1).id;\n    \t if (id != null)\n    \t {\n    \t\t try\n    \t\t {\n    \t\t\t Group g = siteService.findGroup(id);\n    \t\t\t groupId = g.getId();\n    \t\t\t groupTitle = g.getTitle();\n    \t\t\t groupDescription = g.getDescription();\n    \t\t\t groupMembers = g.getMembers();\n    \t\t }\n    \t\t catch (Exception e)\n    \t\t {\n    \t\t\t M_log.debug(this + \"fillComponents: cannot get group id=\" + id);\n    \t\t }\n    \t }\n    \t else\n    \t {\n    \t\t handler.resetParams();\n    \t }\n    \t \n\n         UIOutput.make(groupForm, \"prompt\", messageLocator.getMessage(\"group.newgroup\"));\n         UIOutput.make(groupForm, \"instructions\", messageLocator.getMessage(\"editgroup.instruction\"));\n         \n         UIOutput.make(groupForm, \"group_title_label\", messageLocator.getMessage(\"group.title\"));\n         UIInput titleTextIn = UIInput.make(groupForm, \"group_title\", \"#{SiteManageGroupHandler.title}\",groupTitle);\n\t\t \n\t\t\n\t\t UIMessage groupDescrLabel = UIMessage.make(arg0, \"group_description_label\", \"group.description\"); \n\t\t UIInput groupDescr = UIInput.make(groupForm, \"group_description:\", \"#{SiteManageGroupHandler.description}\", groupDescription); \n\t\t richTextEvolver.evolveTextInput(groupDescr);\n\t\t UILabelTargetDecorator.targetLabel(groupDescrLabel, groupDescr);\n\t\t \n\t\t UIOutput.make(groupForm, \"membership_label\", messageLocator.getMessage(\"editgroup.membership\"));\n\t\t UIOutput.make(groupForm, \"membership_site_label\", messageLocator.getMessage(\"editgroup.generallist\"));\n\t\t UIOutput.make(groupForm, \"membership_group_label\", messageLocator.getMessage(\"editgroup.grouplist\"));\n\t\t \n\t\t // for the site members list\n\t\t Collection siteMembers= handler.getSiteParticipant();\n\t\t String[] siteMemberLabels = new String[siteMembers.size()];\n\t\t String[] siteMemberValues = new String[siteMembers.size()];\n\t\t UISelect siteMember = UISelect.makeMultiple(groupForm,\"siteMembers\",siteMemberValues,siteMemberLabels,\"#{SiteManageGroupHandler.selectedSiteMembers}\", new String[] {});\n\t\t \n\t\t int i =0;\n\t\t Iterator<Participant> sIterator = new SortedIterator(siteMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; sIterator.hasNext();i++){\n\t        \tParticipant p = (Participant) sIterator.next();\n\t\t\t\tsiteMemberLabels[i] = p.getName();\n\t\t\t\tsiteMemberValues[i] = p.getUniqname();\n\t        }\n\t     \n\t     // for the group members list\n\t\t String[] groupMemberLabels = new String[groupMembers.size()];\n\t\t String[] groupMemberValues = new String[groupMembers.size()];\n\t\t UISelect groupMember = UISelect.make(groupForm,\"groupMembers\",groupMemberValues,groupMemberLabels,null);\n\t\t i =0;\n\t\t Iterator<Member> gIterator = new SortedIterator(groupMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; gIterator.hasNext();i++){\n\t        \tMember p = (Member) gIterator.next();\n\t        \tString userId = p.getUserId();\n\t        \ttry\n\t        \t{\n\t        \t\tUser u = userDirectoryService.getUser(userId);\n\t        \t\tgroupMemberLabels[i] = u.getSortName();\n\t        \t}\n\t        \tcatch (Exception e)\n\t        \t{\n\t        \t\tM_log.warn(this + \":fillComponents: cannot find user \" + userId);\n\t        \t}\n\t\t\t\tgroupMemberValues[i] = userId;\n\t        }\n\t        \n    \t UICommand.make(groupForm, \"save\", id != null?messageLocator.getMessage(\"editgroup.update\"):messageLocator.getMessage(\"editgroup.new\"), \"#{SiteManageGroupHandler.processAddGroup}\");\n\n         UICommand.make(groupForm, \"cancel\", messageLocator.getMessage(\"editgroup.cancel\"), \"#{SiteManageGroupHandler.processBack}\");\n         \n         UIInput.make(groupForm, \"newRight\", \"#{SiteManageGroupHandler.memberList}\", state);\n         \n         // hidden field for group id\n         UIInput.make(groupForm, \"groupId\", \"#{SiteManageGroupHandler.id}\", groupId);\n         \n         //process any messages\n         if (tml.size() > 0) {\n \t\t\tfor (i = 0; i < tml.size(); i ++ ) {\n \t\t\t\tUIBranchContainer errorRow = UIBranchContainer.make(arg0,\"error-row:\", new Integer(i).toString());\n \t\t\t\tTargettedMessage msg = tml.messageAt(i);\n\t\t    \tif (msg.args != null ) \n\t\t    \t{\n\t\t    \t\tUIMessage.make(errorRow,\"error\", msg.acquireMessageCode(), (Object[]) msg.args);\n\t\t    \t} \n\t\t    \telse \n\t\t    \t{\n\t\t    \t\tUIMessage.make(errorRow,\"error\", msg.acquireMessageCode());\n\t\t    \t}\t\n \t\t\t}\n         }\n         \n         frameAdjustingProducer.fillComponents(arg0, \"resize\", \"resetFrame\");\n    }","commit_id":"d448490a4938032bb230bc9f48e03c80cfacefd0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Adds a new group to the current site\n     * @param toolId\n     * @param title\n     * @return the newly added Group\n     */\n    public String processAddGroup () {\n\n        Group group = null;\n        \n        id = StringUtil.trimToNull(id);\n        \n    \tString siteReference = siteService.siteReference(site.getId());\n    \t\n    \tif (title == null || title.length() == 0)\n    \t{\n    \t\tM_log.debug(this + \".processAddGroup: no title specified\");\n    \t\tmessages.addMessage(new TargettedMessage(\"editgroup.titlemissing\",\"no text\"));\n    \t\treturn null;\n    \t}\n    \telse if (id == null)\n    \t{\n    \t\tCollection siteGroups = site.getGroups();\n    \t\tif (siteGroups != null && siteGroups.size() > 0)\n    \t\t{\n\t    \t\t// when adding a group, check whether the group title has\n\t\t\t\t// been used already\n\t\t\t\tboolean titleExist = false;\n\t\t\t\tfor (Iterator iGroups = siteGroups.iterator(); !titleExist\n\t\t\t\t\t\t&& iGroups.hasNext();) {\n\t\t\t\t\tGroup iGroup = (Group) iGroups.next();\n\t\t\t\t\tif (title.equals(iGroup.getTitle())) {\n\t\t\t\t\t\t// found same title\n\t\t\t\t\t\ttitleExist = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (titleExist) {\n\t\t\t\t\tmessages.addMessage(new TargettedMessage(\"group.title.same\",\"group with same existing title\"));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n    \t\t}\n    \t}\n\n\t\tif (id != null)\n\t\t{\n\t\t\t// editing existing group\n\t\t\tgroup = site.getGroup(id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// adding a new group\n\t        group= site.addGroup();\n\t        group.getProperties().addProperty(SiteConstants.GROUP_PROP_WSETUP_CREATED, Boolean.TRUE.toString());\n\t\t}\n\t\t\n\t\tif (group != null)\n\t\t{\n\t\t\tgroup.setTitle(title);\n            group.setDescription(description);   \n            \n            boolean found = false;\n            // remove those no longer included in the group\n\t\t\tSet members = group.getMembers();\n\t\t\tString[] membersSelected = memberList.split(\",\");\n\t\t\tfor (Iterator iMembers = members.iterator(); iMembers\n\t\t\t\t\t.hasNext();) {\n\t\t\t\tfound = false;\n\t\t\t\tString mId = ((Member) iMembers.next()).getUserId();\n\t\t\t\tfor (int i = 0; !found && i < membersSelected.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (mId.equals(membersSelected[i])) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tgroup.removeMember(mId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add those seleted members\n\t\t\tfor (int i = 0; i < membersSelected.length; i++) {\n\t\t\t\tString memberId = membersSelected[i];\n\t\t\t\tif (group.getUserRole(memberId) == null) {\n\t\t\t\t\tRole r = site.getUserRole(memberId);\n\t\t\t\t\tMember m = site.getMember(memberId);\n\t\t\t\t\t// for every member added through the \"Manage\n\t\t\t\t\t// Groups\" interface, he should be defined as\n\t\t\t\t\t// non-provided\n\t\t\t\t\tgroup.addMember(memberId, r != null ? r.getId()\n\t\t\t\t\t\t\t: \"\", m != null ? m.isActive() : true,\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t}\n\t            \n    \t\t// save the changes\n    \t\ttry\n    \t\t{\n    \t\t\tsiteService.save(site);\n    \t\t\t// reset the form params\n    \t\t\tresetParams();\n\t        } \n\t        catch (IdUnusedException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        } \n\t        catch (PermissionException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        }\n    \t}\n        \n        return \"success\";\n    }","id":11732,"modified_method":"/**\n     * Adds a new group to the current site\n     * @param toolId\n     * @param title\n     * @return the newly added Group\n     */\n    public String processAddGroup () {\n\n        Group group = null;\n        \n        id = StringUtil.trimToNull(id);\n        \n    \tString siteReference = siteService.siteReference(site.getId());\n    \t\n    \tif (title == null || title.length() == 0)\n    \t{\n    \t\tM_log.debug(this + \".processAddGroup: no title specified\");\n    \t\tmessages.addMessage(new TargettedMessage(\"editgroup.titlemissing\",new Object[] {}, TargettedMessage.SEVERITY_ERROR));\n    \t\treturn null;\n    \t}\n    \telse if (title.length() > SiteConstants.SITE_GROUP_TITLE_LIMIT)\n    \t{\n    \t\tmessages.addMessage(new TargettedMessage(\"site_group_title_length_limit\",new Object[] { \"99\" }, TargettedMessage.SEVERITY_ERROR));\n    \t\treturn null;\n    \t}\n    \telse if (id == null)\n    \t{\n    \t\tCollection siteGroups = site.getGroups();\n    \t\tif (siteGroups != null && siteGroups.size() > 0)\n    \t\t{\n\t    \t\t// when adding a group, check whether the group title has\n\t\t\t\t// been used already\n\t\t\t\tboolean titleExist = false;\n\t\t\t\tfor (Iterator iGroups = siteGroups.iterator(); !titleExist\n\t\t\t\t\t\t&& iGroups.hasNext();) {\n\t\t\t\t\tGroup iGroup = (Group) iGroups.next();\n\t\t\t\t\tif (title.equals(iGroup.getTitle())) {\n\t\t\t\t\t\t// found same title\n\t\t\t\t\t\ttitleExist = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (titleExist) {\n\t\t\t\t\tmessages.addMessage(new TargettedMessage(\"group.title.same\",\"group with same existing title\"));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n    \t\t}\n    \t}\n\n\t\tif (id != null)\n\t\t{\n\t\t\t// editing existing group\n\t\t\tgroup = site.getGroup(id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// adding a new group\n\t        group= site.addGroup();\n\t        group.getProperties().addProperty(SiteConstants.GROUP_PROP_WSETUP_CREATED, Boolean.TRUE.toString());\n\t\t}\n\t\t\n\t\tif (group != null)\n\t\t{\n\t\t\tgroup.setTitle(title);\n            group.setDescription(description);   \n            \n            boolean found = false;\n            // remove those no longer included in the group\n\t\t\tSet members = group.getMembers();\n\t\t\tString[] membersSelected = memberList.split(\",\");\n\t\t\tfor (Iterator iMembers = members.iterator(); iMembers\n\t\t\t\t\t.hasNext();) {\n\t\t\t\tfound = false;\n\t\t\t\tString mId = ((Member) iMembers.next()).getUserId();\n\t\t\t\tfor (int i = 0; !found && i < membersSelected.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (mId.equals(membersSelected[i])) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tgroup.removeMember(mId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add those seleted members\n\t\t\tfor (int i = 0; i < membersSelected.length; i++) {\n\t\t\t\tString memberId = membersSelected[i];\n\t\t\t\tif (group.getUserRole(memberId) == null) {\n\t\t\t\t\tRole r = site.getUserRole(memberId);\n\t\t\t\t\tMember m = site.getMember(memberId);\n\t\t\t\t\t// for every member added through the \"Manage\n\t\t\t\t\t// Groups\" interface, he should be defined as\n\t\t\t\t\t// non-provided\n\t\t\t\t\tgroup.addMember(memberId, r != null ? r.getId()\n\t\t\t\t\t\t\t: \"\", m != null ? m.isActive() : true,\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t}\n\t            \n    \t\t// save the changes\n    \t\ttry\n    \t\t{\n    \t\t\tsiteService.save(site);\n    \t\t\t// reset the form params\n    \t\t\tresetParams();\n\t        } \n\t        catch (IdUnusedException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        } \n\t        catch (PermissionException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        }\n    \t}\n        \n        return \"success\";\n    }","commit_id":"d448490a4938032bb230bc9f48e03c80cfacefd0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n    \t\n    \tString state=\"\";\n    \t\n    \t// group\n    \tGroup g = null;\n    \t// id for group\n    \tString groupId = null;\n    \t// title for group\n    \tString groupTitle = null;\n    \t// description for group\n    \tString groupDescription = null;\n    \t// member list for group\n    \tCollection<Member> groupMembers = new Vector<Member>();\n    \t// group provider id\n    \tString groupProviderId = null;\n    \t// group role provider id\n    \tString groupRoleProviderId = null;\n    \t\n    \tUIForm groupForm = UIForm.make(arg0, \"groups-form\");\n\n    \t String id = ((GroupEditViewParameters) arg1).id;\n    \t if (id != null)\n    \t {\n    \t\t try\n    \t\t {\n    \t\t\t g = siteService.findGroup(id);\n    \t\t\t groupId = g.getId();\n    \t\t\t groupTitle = g.getTitle();\n    \t\t\t groupDescription = g.getDescription();\n    \t\t\t groupMembers = g.getMembers();\n    \t\t\t groupProviderId = g.getProviderGroupId();\n    \t\t\t groupRoleProviderId = g.getProperties().getProperty(SiteConstants.GROUP_PROP_ROLE_PROVIDERID);\n    \t\t }\n    \t\t catch (Exception e)\n    \t\t {\n    \t\t\t M_log.debug(this + \"fillComponents: cannot get group id=\" + id);\n    \t\t }\n    \t }\n    \t else\n    \t {\n    \t\t handler.resetParams();\n    \t }\n    \t \n\n         UIOutput.make(groupForm, \"prompt\", messageLocator.getMessage(\"group.newgroup\"));\n         UIOutput.make(groupForm, \"instructions\", messageLocator.getMessage(\"editgroup.instruction\"));\n         \n         UIOutput.make(groupForm, \"group_title_label\", messageLocator.getMessage(\"group.title\"));\n         UIInput titleTextIn = UIInput.make(groupForm, \"group_title\", \"#{SiteManageGroupSectionRoleHandler.title}\",groupTitle);\n\t\t \n\t\t\n\t\t UIMessage groupDescrLabel = UIMessage.make(arg0, \"group_description_label\", \"group.description\"); \n\t\t UIInput groupDescr = UIInput.make(groupForm, \"group_description:\", \"#{SiteManageGroupSectionRoleHandler.description}\", groupDescription); \n\t\t richTextEvolver.evolveTextInput(groupDescr);\n\t\t UILabelTargetDecorator.targetLabel(groupDescrLabel, groupDescr);\n\t\t \n\t\t UIOutput.make(groupForm, \"membership_label\", messageLocator.getMessage(\"editgroup.membership\"));\n\t\t UIOutput.make(groupForm, \"membership_site_label\", messageLocator.getMessage(\"editgroup.generallist\"));\n\t\t UIOutput.make(groupForm, \"membership_group_label\", messageLocator.getMessage(\"editgroup.grouplist\"));\n\t\t \n\t\t /********************** for the site members list **************************/\n\t\t List<String> siteRosters= handler.getSiteRosters(g);\n\t\t List<Role> siteRoles= handler.getSiteRoles(g);\n\t\t List<Participant> siteMembers= handler.getSiteParticipant(g);\n\t\t int totalListSize = siteRosters.size() + siteRoles.size() + siteMembers.size();\n\t\t String[] siteMemberLabels = new String[totalListSize];\n\t\t String[] siteMemberValues = new String[totalListSize];\n\t\t UISelect siteMember = UISelect.makeMultiple(groupForm,\"siteMembers\",siteMemberValues,siteMemberLabels,\"#{SiteManageGroupSectionRoleHandler.selectedSiteMembers}\", new String[] {});\n\t\t \n\t\t int i =0;\n\t\t // add site roster\n\t\t for (String roster:siteRosters)\n\t\t {\n\t\t\t // not include in the group yet\n\t\t\t if (groupProviderId == null || !groupProviderId.contains(roster))\n\t\t\t {\n\t\t\t\t siteMemberLabels[i] = SECTION_PREFIX + roster;\n\t\t\t\t siteMemberValues[i] = roster;\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add site role\n\t\t for (Role role:siteRoles)\n\t\t {\n\t\t\t // not include in the group yet\n\t\t\t if (groupRoleProviderId == null || !groupRoleProviderId.contains(role.getId()))\n\t\t\t {\n\t\t\t\t siteMemberLabels[i] = ROLE_PREFIX + role.getId();\n\t\t\t\t siteMemberValues[i] = role.getId();\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add site members to the list\n\t\t Iterator<Participant> sIterator = new SortedIterator(siteMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; sIterator.hasNext();i++){\n\t        \tParticipant p = (Participant) sIterator.next();\n\t        \t// not in the group yet\n\t        \tif (g == null || g.getMember(p.getUniqname()) == null)\n\t        \t{\n\t\t\t\t\tsiteMemberLabels[i] = p.getName();\n\t\t\t\t\tsiteMemberValues[i] = p.getUniqname();\n\t        \t}\n\t        }\n\t     \n\t     \n\t     /********************** for the group members list **************************/\n\t     // rosters\n\t     List<String> groupRosters = handler.getGroupRosters(g);\n\t     if (groupRosters != null)\n\t     {\n\t    \t totalListSize = groupRosters.size();\n\t     }\n\t     // roles\n\t     List<String> groupProviderRoles = handler.getGroupProviderRoles(g);\n\t     if (groupProviderRoles != null)\n\t     {\n\t    \t totalListSize += groupProviderRoles.size();\n\t     }\n\t     // group members\n\t     List<Member> groupMembersCopy = new Vector<Member>();\n\t     groupMembersCopy.addAll(groupMembers);\n\t     for (Iterator<Member> gItr=groupMembersCopy.iterator(); gItr.hasNext();i++){\n        \tMember p = (Member) gItr.next();\n        \t\n        \t// exclude those user with provided roles and rosters\n        \tString userId = p.getUserId();\n        \ttry{\n        \t\t// get user\n        \t\tUser u = userDirectoryService.getUser(userId);\n        \t\tif (handler.isUserFromProvider(u.getEid(), userId, g, groupRosters, groupProviderRoles))\n\t        \t{\n\t        \t\tgroupMembers.remove(p);\n\t        \t}\n        \t}\n        \tcatch (Exception e)\n        \t{\n        \t\tM_log.warn(this + \"fillInComponent: cannot find user with id \" + userId);\n        \t}\n\t     }\n\t     if (groupMembers != null)\n\t     {\n\t    \t totalListSize +=groupMembers.size();\n\t     }\n\t     \n\t\t String[] groupMemberLabels = new String[totalListSize];\n\t\t String[] groupMemberValues = new String[totalListSize];\n\t\t UISelect groupMember = UISelect.make(groupForm,\"groupMembers\",groupMemberValues,groupMemberLabels,null);\n\t\t i =0;\n\t\t // add the rosters first\n\t\t if (groupRosters != null)\n\t\t {\n\t\t\t for (String groupRoster:groupRosters)\n\t\t\t {\n\t\t\t\t groupMemberLabels[i] = SECTION_PREFIX + groupRoster;\n\t\t\t\t groupMemberValues[i] = groupRoster;\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add the roles next\n\t\t if (groupProviderRoles != null)\n\t\t {\n\t\t\t for (String groupProviderRole:groupProviderRoles)\n\t\t\t {\n\t\t\t\t groupMemberLabels[i] = ROLE_PREFIX + groupProviderRole;\n\t\t\t\t groupMemberValues[i] = groupProviderRole;\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add the members last\n\t\t Iterator<Member> gIterator = new SortedIterator(groupMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; gIterator.hasNext();i++){\n        \tMember p = (Member) gIterator.next();\n        \tString userId = p.getUserId();\n        \ttry\n        \t{\n        \t\tUser u = userDirectoryService.getUser(userId);\n        \t\tgroupMemberLabels[i] = u.getSortName();\n        \t}\n        \tcatch (Exception e)\n        \t{\n        \t\tM_log.warn(this + \":fillComponents: cannot find user \" + userId);\n        \t}\n\t\t\tgroupMemberValues[i] = userId;\n\t\t}\n\t        \n    \t UICommand.make(groupForm, \"save\", id != null?messageLocator.getMessage(\"editgroup.update\"):messageLocator.getMessage(\"editgroup.new\"), \"#{SiteManageGroupSectionRoleHandler.processAddGroup}\");\n\n         UICommand.make(groupForm, \"cancel\", messageLocator.getMessage(\"editgroup.cancel\"), \"#{SiteManageGroupSectionRoleHandler.processBack}\");\n         \n         UIInput.make(groupForm, \"newRight\", \"#{SiteManageGroupSectionRoleHandler.memberList}\", state);\n         \n         // hidden field for group id\n         UIInput.make(groupForm, \"groupId\", \"#{SiteManageGroupSectionRoleHandler.id}\", groupId);\n         \n         //process any messages\n         if (tml.size() > 0) {\n \t\t\tfor (i = 0; i < tml.size(); i ++ ) {\n \t\t\t\tUIBranchContainer errorRow = UIBranchContainer.make(arg0,\"error-row:\", new Integer(i).toString());\n \t\t\t\tif (tml.messageAt(i).args != null ) {\t    \t\t\n \t\t\t\t\tUIMessage.make(errorRow,\"error\",tml.messageAt(i).acquireMessageCode(),(String[])tml.messageAt(i).args[0]);\n \t\t\t\t} else {\n \t\t    \t\t\tUIMessage.make(errorRow,\"error\",tml.messageAt(i).acquireMessageCode());\n \t\t\t\t}\n \t\t    \t\t\n \t\t\t}\n         }\n         \n         frameAdjustingProducer.fillComponents(arg0, \"resize\", \"resetFrame\");\n    }","id":11733,"modified_method":"public void fillComponents(UIContainer arg0, ViewParameters arg1, ComponentChecker arg2) {\n    \t\n    \tString state=\"\";\n    \t\n    \t// group\n    \tGroup g = null;\n    \t// id for group\n    \tString groupId = null;\n    \t// title for group\n    \tString groupTitle = null;\n    \t// description for group\n    \tString groupDescription = null;\n    \t// member list for group\n    \tCollection<Member> groupMembers = new Vector<Member>();\n    \t// group provider id\n    \tString groupProviderId = null;\n    \t// group role provider id\n    \tString groupRoleProviderId = null;\n    \t\n    \tUIForm groupForm = UIForm.make(arg0, \"groups-form\");\n\n    \t String id = ((GroupEditViewParameters) arg1).id;\n    \t if (id != null)\n    \t {\n    \t\t try\n    \t\t {\n    \t\t\t g = siteService.findGroup(id);\n    \t\t\t groupId = g.getId();\n    \t\t\t groupTitle = g.getTitle();\n    \t\t\t groupDescription = g.getDescription();\n    \t\t\t groupMembers = g.getMembers();\n    \t\t\t groupProviderId = g.getProviderGroupId();\n    \t\t\t groupRoleProviderId = g.getProperties().getProperty(SiteConstants.GROUP_PROP_ROLE_PROVIDERID);\n    \t\t }\n    \t\t catch (Exception e)\n    \t\t {\n    \t\t\t M_log.debug(this + \"fillComponents: cannot get group id=\" + id);\n    \t\t }\n    \t }\n    \t else\n    \t {\n    \t\t handler.resetParams();\n    \t }\n    \t \n\n         UIOutput.make(groupForm, \"prompt\", messageLocator.getMessage(\"group.newgroup\"));\n         UIOutput.make(groupForm, \"instructions\", messageLocator.getMessage(\"editgroup.instruction\"));\n         \n         UIOutput.make(groupForm, \"group_title_label\", messageLocator.getMessage(\"group.title\"));\n         UIInput titleTextIn = UIInput.make(groupForm, \"group_title\", \"#{SiteManageGroupSectionRoleHandler.title}\",groupTitle);\n\t\t \n\t\t\n\t\t UIMessage groupDescrLabel = UIMessage.make(arg0, \"group_description_label\", \"group.description\"); \n\t\t UIInput groupDescr = UIInput.make(groupForm, \"group_description:\", \"#{SiteManageGroupSectionRoleHandler.description}\", groupDescription); \n\t\t richTextEvolver.evolveTextInput(groupDescr);\n\t\t UILabelTargetDecorator.targetLabel(groupDescrLabel, groupDescr);\n\t\t \n\t\t UIOutput.make(groupForm, \"membership_label\", messageLocator.getMessage(\"editgroup.membership\"));\n\t\t UIOutput.make(groupForm, \"membership_site_label\", messageLocator.getMessage(\"editgroup.generallist\"));\n\t\t UIOutput.make(groupForm, \"membership_group_label\", messageLocator.getMessage(\"editgroup.grouplist\"));\n\t\t \n\t\t /********************** for the site members list **************************/\n\t\t List<String> siteRosters= handler.getSiteRosters(g);\n\t\t List<Role> siteRoles= handler.getSiteRoles(g);\n\t\t List<Participant> siteMembers= handler.getSiteParticipant(g);\n\t\t int totalListSize = siteRosters.size() + siteRoles.size() + siteMembers.size();\n\t\t String[] siteMemberLabels = new String[totalListSize];\n\t\t String[] siteMemberValues = new String[totalListSize];\n\t\t UISelect siteMember = UISelect.makeMultiple(groupForm,\"siteMembers\",siteMemberValues,siteMemberLabels,\"#{SiteManageGroupSectionRoleHandler.selectedSiteMembers}\", new String[] {});\n\t\t \n\t\t int i =0;\n\t\t // add site roster\n\t\t for (String roster:siteRosters)\n\t\t {\n\t\t\t // not include in the group yet\n\t\t\t if (groupProviderId == null || !groupProviderId.contains(roster))\n\t\t\t {\n\t\t\t\t siteMemberLabels[i] = SECTION_PREFIX + roster;\n\t\t\t\t siteMemberValues[i] = roster;\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add site role\n\t\t for (Role role:siteRoles)\n\t\t {\n\t\t\t // not include in the group yet\n\t\t\t if (groupRoleProviderId == null || !groupRoleProviderId.contains(role.getId()))\n\t\t\t {\n\t\t\t\t siteMemberLabels[i] = ROLE_PREFIX + role.getId();\n\t\t\t\t siteMemberValues[i] = role.getId();\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add site members to the list\n\t\t Iterator<Participant> sIterator = new SortedIterator(siteMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; sIterator.hasNext();i++){\n\t        \tParticipant p = (Participant) sIterator.next();\n\t        \t// not in the group yet\n\t        \tif (g == null || g.getMember(p.getUniqname()) == null)\n\t        \t{\n\t\t\t\t\tsiteMemberLabels[i] = p.getName();\n\t\t\t\t\tsiteMemberValues[i] = p.getUniqname();\n\t        \t}\n\t        }\n\t     \n\t     \n\t     /********************** for the group members list **************************/\n\t     // rosters\n\t     List<String> groupRosters = handler.getGroupRosters(g);\n\t     if (groupRosters != null)\n\t     {\n\t    \t totalListSize = groupRosters.size();\n\t     }\n\t     // roles\n\t     List<String> groupProviderRoles = handler.getGroupProviderRoles(g);\n\t     if (groupProviderRoles != null)\n\t     {\n\t    \t totalListSize += groupProviderRoles.size();\n\t     }\n\t     // group members\n\t     List<Member> groupMembersCopy = new Vector<Member>();\n\t     groupMembersCopy.addAll(groupMembers);\n\t     for (Iterator<Member> gItr=groupMembersCopy.iterator(); gItr.hasNext();i++){\n        \tMember p = (Member) gItr.next();\n        \t\n        \t// exclude those user with provided roles and rosters\n        \tString userId = p.getUserId();\n        \ttry{\n        \t\t// get user\n        \t\tUser u = userDirectoryService.getUser(userId);\n        \t\tif (handler.isUserFromProvider(u.getEid(), userId, g, groupRosters, groupProviderRoles))\n\t        \t{\n\t        \t\tgroupMembers.remove(p);\n\t        \t}\n        \t}\n        \tcatch (Exception e)\n        \t{\n        \t\tM_log.warn(this + \"fillInComponent: cannot find user with id \" + userId);\n        \t}\n\t     }\n\t     if (groupMembers != null)\n\t     {\n\t    \t totalListSize +=groupMembers.size();\n\t     }\n\t     \n\t\t String[] groupMemberLabels = new String[totalListSize];\n\t\t String[] groupMemberValues = new String[totalListSize];\n\t\t UISelect groupMember = UISelect.make(groupForm,\"groupMembers\",groupMemberValues,groupMemberLabels,null);\n\t\t i =0;\n\t\t // add the rosters first\n\t\t if (groupRosters != null)\n\t\t {\n\t\t\t for (String groupRoster:groupRosters)\n\t\t\t {\n\t\t\t\t groupMemberLabels[i] = SECTION_PREFIX + groupRoster;\n\t\t\t\t groupMemberValues[i] = groupRoster;\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add the roles next\n\t\t if (groupProviderRoles != null)\n\t\t {\n\t\t\t for (String groupProviderRole:groupProviderRoles)\n\t\t\t {\n\t\t\t\t groupMemberLabels[i] = ROLE_PREFIX + groupProviderRole;\n\t\t\t\t groupMemberValues[i] = groupProviderRole;\n\t\t\t\t i++;\n\t\t\t }\n\t\t }\n\t\t // add the members last\n\t\t Iterator<Member> gIterator = new SortedIterator(groupMembers.iterator(), new SiteComparator(SiteConstants.SORTED_BY_PARTICIPANT_NAME, Boolean.TRUE.toString()));\n\t     for (; gIterator.hasNext();i++){\n        \tMember p = (Member) gIterator.next();\n        \tString userId = p.getUserId();\n        \ttry\n        \t{\n        \t\tUser u = userDirectoryService.getUser(userId);\n        \t\tgroupMemberLabels[i] = u.getSortName();\n        \t}\n        \tcatch (Exception e)\n        \t{\n        \t\tM_log.warn(this + \":fillComponents: cannot find user \" + userId);\n        \t}\n\t\t\tgroupMemberValues[i] = userId;\n\t\t}\n\t        \n    \t UICommand.make(groupForm, \"save\", id != null?messageLocator.getMessage(\"editgroup.update\"):messageLocator.getMessage(\"editgroup.new\"), \"#{SiteManageGroupSectionRoleHandler.processAddGroup}\");\n\n         UICommand.make(groupForm, \"cancel\", messageLocator.getMessage(\"editgroup.cancel\"), \"#{SiteManageGroupSectionRoleHandler.processBack}\");\n         \n         UIInput.make(groupForm, \"newRight\", \"#{SiteManageGroupSectionRoleHandler.memberList}\", state);\n         \n         // hidden field for group id\n         UIInput.make(groupForm, \"groupId\", \"#{SiteManageGroupSectionRoleHandler.id}\", groupId);\n         \n         //process any messages\n         if (tml.size() > 0) {\n \t\t\tfor (i = 0; i < tml.size(); i ++ ) {\n \t\t\t\tUIBranchContainer errorRow = UIBranchContainer.make(arg0,\"error-row:\", new Integer(i).toString());\n \t\t\t\tTargettedMessage msg = tml.messageAt(i);\n\t\t    \tif (msg.args != null ) \n\t\t    \t{\n\t\t    \t\tUIMessage.make(errorRow,\"error\", msg.acquireMessageCode(), (Object[]) msg.args);\n\t\t    \t} \n\t\t    \telse \n\t\t    \t{\n\t\t    \t\tUIMessage.make(errorRow,\"error\", msg.acquireMessageCode());\n\t\t    \t}\t\n \t\t\t}\n         }\n         \n         frameAdjustingProducer.fillComponents(arg0, \"resize\", \"resetFrame\");\n    }","commit_id":"d69b5a6c8d118308b16e6309c53acce08c0cf83b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Adds a new group to the current site\n     * @param toolId\n     * @param title\n     * @return the newly added Group\n     */\n    public String processAddGroup () {\n\n        Group group = null;\n        \n        id = StringUtil.trimToNull(id);\n        \n    \tString siteReference = siteService.siteReference(site.getId());\n    \t\n    \tif (title == null || title.length() == 0)\n    \t{\n    \t\tM_log.debug(this + \".processAddGroup: no title specified\");\n    \t\tmessages.addMessage(new TargettedMessage(\"editgroup.titlemissing\",\"no text\"));\n    \t\treturn null;\n    \t}\n    \telse if (id == null)\n    \t{\n    \t\tCollection siteGroups = site.getGroups();\n    \t\tif (siteGroups != null && siteGroups.size() > 0)\n    \t\t{\n\t    \t\t// when adding a group, check whether the group title has\n\t\t\t\t// been used already\n\t\t\t\tboolean titleExist = false;\n\t\t\t\tfor (Iterator iGroups = siteGroups.iterator(); !titleExist\n\t\t\t\t\t\t&& iGroups.hasNext();) {\n\t\t\t\t\tGroup iGroup = (Group) iGroups.next();\n\t\t\t\t\tif (title.equals(iGroup.getTitle())) {\n\t\t\t\t\t\t// found same title\n\t\t\t\t\t\ttitleExist = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (titleExist) {\n\t\t\t\t\tmessages.addMessage(new TargettedMessage(\"group.title.same\",\"group with same existing title\"));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n    \t\t}\n    \t}\n\n\t\tif (id != null)\n\t\t{\n\t\t\t// editing existing group\n\t\t\tgroup = site.getGroup(id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// adding a new group\n\t        group= site.addGroup();\n\t        group.getProperties().addProperty(SiteConstants.GROUP_PROP_WSETUP_CREATED, Boolean.TRUE.toString());\n\t\t}\n\t\t\n\t\tif (group != null)\n\t\t{\n\t\t\tgroup.setTitle(title);\n            group.setDescription(description);   \n            \n            boolean found = false;\n            // remove those no longer included in the group\n\t\t\tSet members = group.getMembers();\n\t\t\tString[] membersSelected = memberList.split(\",\");\n\t\t\tfor (Iterator iMembers = members.iterator(); iMembers\n\t\t\t\t\t.hasNext();) {\n\t\t\t\tfound = false;\n\t\t\t\tString mId = ((Member) iMembers.next()).getUserId();\n\t\t\t\tfor (int i = 0; !found && i < membersSelected.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (mId.equals(membersSelected[i])) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tgroup.removeMember(mId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add those seleted members\n\t\t\tList<String> siteRosters = getSiteRosters(null);\n\t\t\tList<String> siteRoles = getSiteRoleIds();\n\t\t\tList<String> selectedRosters = new Vector<String>();\n\t\t\tList<String> selectedRoles = new Vector<String>();\n\t\t\tfor (int i = 0; i < membersSelected.length; i++) {\n\t\t\t\tString memberId = membersSelected[i];\n\t\t\t\t\n\t\t\t\tif (siteRosters.contains(memberId))\n\t\t\t\t{\n\t\t\t\t\t// this is a roster\n\t\t\t\t\tselectedRosters.add(memberId);\n\t\t\t\t}\n\t\t\t\telse if (siteRoles.contains(memberId))\n\t\t\t\t{\n\t\t\t\t\t// this is a role\n\t\t\t\t\tSet roleUsers = site.getUsersHasRole(memberId);\n    \t\t\t\tfor (Iterator iRoleUsers = roleUsers.iterator(); iRoleUsers.hasNext();)\n    \t\t\t\t{\n    \t\t\t\t\tString roleUserId = (String) iRoleUsers.next();\n        \t\t\t\tMember member = site.getMember(roleUserId);\n    \t\t\t\t\tgroup.addMember(roleUserId, memberId, member.isActive(), false);\n    \t\t\t\t}\n    \t\t\t\tselectedRoles.add(memberId);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// normal user id\n\t\t\t\t\tif (group.getUserRole(memberId) == null) {\n\t\t\t\t\t\tRole r = site.getUserRole(memberId);\n\t\t\t\t\t\tMember m = site.getMember(memberId);\n\t\t\t\t\t\t// for every member added through the \"Manage\n\t\t\t\t\t\t// Groups\" interface, he should be defined as\n\t\t\t\t\t\t// non-provided\n\t\t\t\t\t\tgroup.addMember(memberId, r != null ? r.getId()\n\t\t\t\t\t\t\t\t: \"\", m != null ? m.isActive() : true,\n\t\t\t\t\t\t\t\tfalse);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!selectedRosters.isEmpty())\n\t\t\t{\n\t\t\t\t// set provider id\n\t\t\t\tgroup.setProviderGroupId(getProviderString(selectedRosters));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// clear the provider id\n\t\t\t\tgroup.setProviderGroupId(null);\n\t\t\t}\n\t\t\tif (!selectedRoles.isEmpty())\n\t\t\t{\n\t\t\t\t// pack the role provider id and add to property\n    \t\t\tgroup.getProperties().addProperty(SiteConstants.GROUP_PROP_ROLE_PROVIDERID, getProviderString(selectedRoles));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// clear the role provider id\n\t\t\t\tgroup.getProperties().removeProperty(SiteConstants.GROUP_PROP_ROLE_PROVIDERID);\n\t\t\t}\n\t            \n    \t\t// save the changes\n    \t\ttry\n    \t\t{\n    \t\t\tsiteService.save(site);\n    \t\t\t// reset the form params\n    \t\t\tresetParams();\n\t        } \n\t        catch (IdUnusedException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        } \n\t        catch (PermissionException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        }\n    \t}\n        \n        return \"success\";\n    }","id":11734,"modified_method":"/**\n     * Adds a new group to the current site\n     * @param toolId\n     * @param title\n     * @return the newly added Group\n     */\n    public String processAddGroup () {\n\n        Group group = null;\n        \n        id = StringUtil.trimToNull(id);\n        \n    \tString siteReference = siteService.siteReference(site.getId());\n    \t\n    \tif (title == null || title.length() == 0)\n    \t{\n    \t\tM_log.debug(this + \".processAddGroup: no title specified\");\n    \t\tmessages.addMessage(new TargettedMessage(\"editgroup.titlemissing\",new Object[] { }, TargettedMessage.SEVERITY_ERROR));\n    \t\treturn null;\n    \t}\n    \telse if (title.length() > SiteConstants.SITE_GROUP_TITLE_LIMIT)\n    \t{\n    \t\tmessages.addMessage(new TargettedMessage(\"site_group_title_length_limit\",new Object[] { String.valueOf(SiteConstants.SITE_GROUP_TITLE_LIMIT) }, TargettedMessage.SEVERITY_ERROR));\n    \t\treturn null;\n    \t}\n    \telse if (id == null)\n    \t{\n    \t\tCollection siteGroups = site.getGroups();\n    \t\tif (siteGroups != null && siteGroups.size() > 0)\n    \t\t{\n\t    \t\t// when adding a group, check whether the group title has\n\t\t\t\t// been used already\n\t\t\t\tboolean titleExist = false;\n\t\t\t\tfor (Iterator iGroups = siteGroups.iterator(); !titleExist\n\t\t\t\t\t\t&& iGroups.hasNext();) {\n\t\t\t\t\tGroup iGroup = (Group) iGroups.next();\n\t\t\t\t\tif (title.equals(iGroup.getTitle())) {\n\t\t\t\t\t\t// found same title\n\t\t\t\t\t\ttitleExist = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (titleExist) {\n\t\t\t\t\tmessages.addMessage(new TargettedMessage(\"group.title.same\",\"group with same existing title\"));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n    \t\t}\n    \t}\n\n\t\tif (id != null)\n\t\t{\n\t\t\t// editing existing group\n\t\t\tgroup = site.getGroup(id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// adding a new group\n\t        group= site.addGroup();\n\t        group.getProperties().addProperty(SiteConstants.GROUP_PROP_WSETUP_CREATED, Boolean.TRUE.toString());\n\t\t}\n\t\t\n\t\tif (group != null)\n\t\t{\n\t\t\tgroup.setTitle(title);\n            group.setDescription(description);   \n            \n            boolean found = false;\n            // remove those no longer included in the group\n\t\t\tSet members = group.getMembers();\n\t\t\tString[] membersSelected = memberList.split(\",\");\n\t\t\tfor (Iterator iMembers = members.iterator(); iMembers\n\t\t\t\t\t.hasNext();) {\n\t\t\t\tfound = false;\n\t\t\t\tString mId = ((Member) iMembers.next()).getUserId();\n\t\t\t\tfor (int i = 0; !found && i < membersSelected.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (mId.equals(membersSelected[i])) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tgroup.removeMember(mId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add those seleted members\n\t\t\tList<String> siteRosters = getSiteRosters(null);\n\t\t\tList<String> siteRoles = getSiteRoleIds();\n\t\t\tList<String> selectedRosters = new Vector<String>();\n\t\t\tList<String> selectedRoles = new Vector<String>();\n\t\t\tfor (int i = 0; i < membersSelected.length; i++) {\n\t\t\t\tString memberId = membersSelected[i];\n\t\t\t\t\n\t\t\t\tif (siteRosters.contains(memberId))\n\t\t\t\t{\n\t\t\t\t\t// this is a roster\n\t\t\t\t\tselectedRosters.add(memberId);\n\t\t\t\t}\n\t\t\t\telse if (siteRoles.contains(memberId))\n\t\t\t\t{\n\t\t\t\t\t// this is a role\n\t\t\t\t\tSet roleUsers = site.getUsersHasRole(memberId);\n    \t\t\t\tfor (Iterator iRoleUsers = roleUsers.iterator(); iRoleUsers.hasNext();)\n    \t\t\t\t{\n    \t\t\t\t\tString roleUserId = (String) iRoleUsers.next();\n        \t\t\t\tMember member = site.getMember(roleUserId);\n    \t\t\t\t\tgroup.addMember(roleUserId, memberId, member.isActive(), false);\n    \t\t\t\t}\n    \t\t\t\tselectedRoles.add(memberId);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// normal user id\n\t\t\t\t\tif (group.getUserRole(memberId) == null) {\n\t\t\t\t\t\tRole r = site.getUserRole(memberId);\n\t\t\t\t\t\tMember m = site.getMember(memberId);\n\t\t\t\t\t\t// for every member added through the \"Manage\n\t\t\t\t\t\t// Groups\" interface, he should be defined as\n\t\t\t\t\t\t// non-provided\n\t\t\t\t\t\tgroup.addMember(memberId, r != null ? r.getId()\n\t\t\t\t\t\t\t\t: \"\", m != null ? m.isActive() : true,\n\t\t\t\t\t\t\t\tfalse);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!selectedRosters.isEmpty())\n\t\t\t{\n\t\t\t\t// set provider id\n\t\t\t\tgroup.setProviderGroupId(getProviderString(selectedRosters));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// clear the provider id\n\t\t\t\tgroup.setProviderGroupId(null);\n\t\t\t}\n\t\t\tif (!selectedRoles.isEmpty())\n\t\t\t{\n\t\t\t\t// pack the role provider id and add to property\n    \t\t\tgroup.getProperties().addProperty(SiteConstants.GROUP_PROP_ROLE_PROVIDERID, getProviderString(selectedRoles));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// clear the role provider id\n\t\t\t\tgroup.getProperties().removeProperty(SiteConstants.GROUP_PROP_ROLE_PROVIDERID);\n\t\t\t}\n\t            \n    \t\t// save the changes\n    \t\ttry\n    \t\t{\n    \t\t\tsiteService.save(site);\n    \t\t\t// reset the form params\n    \t\t\tresetParams();\n\t        } \n\t        catch (IdUnusedException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        } \n\t        catch (PermissionException e) {\n\t        \tM_log.warn(this + \".processAddGroup: cannot find site \" + site.getId(), e);\n\t            return null;\n\t        }\n    \t}\n        \n        return \"success\";\n    }","commit_id":"d69b5a6c8d118308b16e6309c53acce08c0cf83b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void fillComponents(UIContainer tofill, ViewParameters viewParms,\n\t\t\tComponentChecker comp) {\n\t\t// TODO Auto-generated method stub\n\n\t\t\n\t\tif (tml!=null) {\n\t\t\tif (tml.size() > 0) {\n\n\t\t    \tfor (int i = 0; i < tml.size(); i ++ ) {\n\t\t    \t\tUIBranchContainer errorRow = UIBranchContainer.make(tofill,\"error-row:\");\n\t\t    \t\tif (tml.messageAt(i).args != null ) {\t    \t\t\n\t\t    \t\t\tUIVerbatim.make(errorRow, \"error\", messageLocator.getMessage(tml.messageAt(i).acquireMessageCode(), (String[])tml.messageAt(i).args[0]));\n\t\t    \t\t} else {\n\t\t    \t\t\tUIVerbatim.make(errorRow, \"error\", messageLocator.getMessage(tml.messageAt(i).acquireMessageCode()));\n\t\t    \t\t}\n\t\t    \t\t\n\t\t    \t}\n\t\t    }\n\t\t}\n\t\t// Get the instructions from the tool placement.\n\t\tPlacement placement = toolManager.getCurrentPlacement();\n\t\tif (placement != null) {\n\t\t\tString instuctions = placement.getConfig().getProperty(\"instructions\");\n\t\t\tif (instuctions != null && instuctions.length() > 0) {\n\t\t\t\tUIVerbatim.make(tofill, \"instructions\", instuctions);\n\t\t\t}\n\t\t} else {\n\t\t\tString[] args = new String[1];\n\t\t\targs[0]=serverConfigurationService.getString(\"ui.service\", \"Sakai Based Service\");\n\t\t\tUIVerbatim.make(tofill,\"main\",messageLocator.getMessage(\"mainText\", args));\n\t\t}\n\t\tUIForm form = UIForm.make(tofill,\"form\");\n\t\tboolean skipExpirationTime=true;\n\t\tString expirationTime=serverConfigurationService.getString(\"accountValidator.maxPasswordResetMinutes\");\n\t\tif (expirationTime != null && !\"\".equals(expirationTime))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint totalMinutes=Integer.parseInt(expirationTime);\n\n\t\t\t\tskipExpirationTime=false;\n\t\t\t\tUIOutput.make( form, \"output\", messageLocator.getMessage(\"explanation\", new Object[]{getFormattedMinutes(totalMinutes)} ));\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe)\n\t\t\t{\n\n\t\t\t}\n\t\t}\n\t\tif (skipExpirationTime)\n\t\t{\n\t\t\tUIOutput.make(form, \"output\", \"\");\n\t\t}\n\t\tUIInput.make(form,\"input\",\"#{userBean.email}\");\n\n\t\tboolean validatingAccounts = serverConfigurationService.getBoolean( \"siteManage.validateNewUsers\", false );\n\t\tif ( validatingAccounts )\n\t\t{\n\t\t\tUICommand.make( form, \"submit\", UIMessage.make( \"postForm2\" ), \"#{formHandler.processAction}\" );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUICommand.make( form, \"submit\", UIMessage.make( \"postForm\" ), \"#{formHandler.processAction}\" );\n\t\t}\n\t}","id":11735,"modified_method":"public void fillComponents(UIContainer tofill, ViewParameters viewParms,\n\t\t\tComponentChecker comp) {\n\t\t// TODO Auto-generated method stub\n\n\t\tPlacement placement = toolManager.getCurrentPlacement();\n\t\t\n\t\tif (tml!=null) {\n\t\t\tif (tml.size() > 0) {\n\n\t\t    \tfor (int i = 0; i < tml.size(); i ++ ) {\n\t\t    \t\tUIBranchContainer errorRow = UIBranchContainer.make(tofill,\"error-row:\");\n\t\t    \t\tTargettedMessage tmessage = tml.messageAt(i);\n\t\t    \t\tString messageKey = tmessage.acquireMessageCode();\n\t\t    \t\tif (messageKey.startsWith(TOOL_CONFIG_PREFIX)) {\n\t\t    \t\t\t// The messageKey begins with toolconfig_, so grab it from tool properties\n\t\t    \t\t\tString toolConfigKey = messageKey.substring(TOOL_CONFIG_PREFIX.length());\n\t\t    \t\t\tString message = placement.getConfig().getProperty(toolConfigKey);\n\t\t    \t\t\tUIVerbatim.make(errorRow, \"error\", message);\n\t\t    \t\t}\n\t\t    \t\telse if (tmessage.args != null ) {\t    \t\t\n\t\t    \t\t\tUIVerbatim.make(errorRow, \"error\", messageLocator.getMessage(messageKey, (String[])tmessage.args));\n\t\t    \t\t} else {\n\t\t    \t\t\tUIVerbatim.make(errorRow, \"error\", messageLocator.getMessage(messageKey));\n\t\t    \t\t}\n\t\t    \t\t\n\t\t    \t}\n\t\t    }\n\t\t}\n\t\t// Get the instructions from the tool placement.\n\t\tif (placement != null) {\n\t\t\tString instuctions = placement.getConfig().getProperty(\"instructions\");\n\t\t\tif (instuctions != null && instuctions.length() > 0) {\n\t\t\t\tUIVerbatim.make(tofill, \"instructions\", instuctions);\n\t\t\t}\n\t\t} else {\n\t\t\tString[] args = new String[1];\n\t\t\targs[0]=serverConfigurationService.getString(\"ui.service\", \"Sakai Based Service\");\n\t\t\tUIVerbatim.make(tofill,\"main\",messageLocator.getMessage(\"mainText\", args));\n\t\t}\n\t\tUIForm form = UIForm.make(tofill,\"form\");\n\t\tboolean skipExpirationTime=true;\n\t\tString expirationTime=serverConfigurationService.getString(\"accountValidator.maxPasswordResetMinutes\");\n\t\tif (expirationTime != null && !\"\".equals(expirationTime))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint totalMinutes=Integer.parseInt(expirationTime);\n\n\t\t\t\tskipExpirationTime=false;\n\t\t\t\tUIOutput.make( form, \"output\", messageLocator.getMessage(\"explanation\", new Object[]{getFormattedMinutes(totalMinutes)} ));\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe)\n\t\t\t{\n\n\t\t\t}\n\t\t}\n\t\tif (skipExpirationTime)\n\t\t{\n\t\t\tUIOutput.make(form, \"output\", \"\");\n\t\t}\n\t\tUIInput.make(form,\"input\",\"#{userBean.email}\");\n\n\t\tboolean validatingAccounts = serverConfigurationService.getBoolean( \"siteManage.validateNewUsers\", false );\n\t\tif ( validatingAccounts )\n\t\t{\n\t\t\tUICommand.make( form, \"submit\", UIMessage.make( \"postForm2\" ), \"#{formHandler.processAction}\" );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUICommand.make( form, \"submit\", UIMessage.make( \"postForm\" ), \"#{formHandler.processAction}\" );\n\t\t}\n\t}","commit_id":"3a7e07b12af8ae85eebf914901e1d4f7c6afc405","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void validate(Object obj, Errors errors) {\n\t\tRetUser retUser = (RetUser)obj;\n\t\tm_log.debug(\"validating user \" + retUser.getEmail());\n\n\t\tif (retUser.getEmail() == null || \"\".equals(retUser.getEmail()))\n\t\t{\n\t\t\tm_log.debug(\"no email provided\");\n\t\t\terrors.reject(\"noemailprovided\", \"no email provided\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tCollection<User> c = this.userDirectoryService.findUsersByEmail(retUser.getEmail().trim());\n\t\tif (c.size()>1) {\n\t\t\tm_log.debug(\"more than one email!\");\n\t\t\terrors.reject(\"morethanone\",\"more than one email\");\n\t\t\treturn;\n\t\t} else if (c.size()==0) {\n\t\t\tm_log.debug(\"no such email\");\n\t\t\terrors.reject(\"nosuchuser\",\"no such user\");\n\t\t\treturn;\n\t\t}\n\t\tIterator<User> i = c.iterator();\n\t\tUser user = (User)i.next();\n\t\tm_log.debug(\"got user \" + user.getId() + \" of type \" + user.getType());\n\t\tif (securityService.isSuperUser(user.getId())) {\n\t\t\tm_log.warn(\"tryng to change superuser password\");\n\t\t\terrors.reject(\"wrongtype\",\"wrong type\");\n\t\t\treturn;\n\t\t}\n\t\tboolean allroles = serverConfigurationService.getBoolean(\"resetPass.resetAllRoles\",false);\n\t\tif (!allroles){\n\t\t\t// SAK-24379 - deprecate the resetRoles property\n\t\t\tString[] roles = serverConfigurationService.getStrings(\"accountValidator.accountTypes.accept\");\n\t\t\tString[] rolesOld = serverConfigurationService.getStrings(\"resetRoles\");\n\t\t\tif (rolesOld != null)\n\t\t\t{\n\t\t\t\tm_log.warn(\"Found the resetRoles property; it is deprecated in favour of accountValidator.accountTypes.accept\");\n\t\t\t\tif (roles == null)\n\t\t\t\t{\n\t\t\t\t\troles = rolesOld;\n\t\t\t\t}\n\t\t\t}\n\t\t    if (roles == null ){\n\t\t        roles = new String[]{\"guest\"};\n\t\t    }\n\t\t    List<String> rolesL = Arrays.asList(roles);\n\t\t    if (!rolesL.contains(user.getType())) {\n\t\t        m_log.warn(\"this is a type don't change\");\n\t\t        errors.reject(\"wrongtype\",\"wrong type\");\n\t\t        return;\n\t\t    }\n\t\t}\n\t\tretUser.setUser(user);\n\t}","id":11736,"modified_method":"public void validate(Object obj, Errors errors) {\n\t\tRetUser retUser = (RetUser)obj;\n\t\tm_log.debug(\"validating user \" + retUser.getEmail());\n\n\t\tif (retUser.getEmail() == null || \"\".equals(retUser.getEmail()))\n\t\t{\n\t\t\tm_log.debug(\"no email provided\");\n\t\t\terrors.reject(\"noemailprovided\", \"no email provided\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tCollection<User> c = this.userDirectoryService.findUsersByEmail(retUser.getEmail().trim());\n\t\tif (c.size()>1) {\n\t\t\tm_log.debug(\"more than one email!\");\n\t\t\terrors.reject(\"morethanone\",\"more than one email\");\n\t\t\treturn;\n\t\t} else if (c.size()==0) {\n\t\t\tm_log.debug(\"no such email\");\n\t\t\terrors.reject(\"nosuchuser\",\"no such user\");\n\t\t\treturn;\n\t\t}\n\t\tIterator<User> i = c.iterator();\n\t\tUser user = (User)i.next();\n\t\tm_log.debug(\"got user \" + user.getId() + \" of type \" + user.getType());\n\t\tif (securityService.isSuperUser(user.getId())) {\n\t\t\tm_log.warn(\"tryng to change superuser password\");\n\t\t\trejectWrongType(errors);\n\t\t\treturn;\n\t\t}\n\t\tboolean allroles = serverConfigurationService.getBoolean(\"resetPass.resetAllRoles\",false);\n\t\tif (!allroles){\n\t\t\t// SAK-24379 - deprecate the resetRoles property\n\t\t\tString[] roles = serverConfigurationService.getStrings(\"accountValidator.accountTypes.accept\");\n\t\t\tString[] rolesOld = serverConfigurationService.getStrings(\"resetRoles\");\n\t\t\tif (rolesOld != null)\n\t\t\t{\n\t\t\t\tm_log.warn(\"Found the resetRoles property; it is deprecated in favour of accountValidator.accountTypes.accept\");\n\t\t\t\tif (roles == null)\n\t\t\t\t{\n\t\t\t\t\troles = rolesOld;\n\t\t\t\t}\n\t\t\t}\n\t\t    if (roles == null ){\n\t\t        roles = new String[]{\"guest\"};\n\t\t    }\n\t\t    List<String> rolesL = Arrays.asList(roles);\n\t\t    if (!rolesL.contains(user.getType())) {\n\t\t        m_log.warn(\"this is a type don't change\");\n\t\t        rejectWrongType(errors);\n\t\t        return;\n\t\t    }\n\t\t}\n\t\tretUser.setUser(user);\n\t}","commit_id":"3a7e07b12af8ae85eebf914901e1d4f7c6afc405","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static List<String> getSchedules(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.workflowSchedules(request, responder, appId, wflowId);\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                               (responder.getResponseContent())), Charsets.UTF_8));\n    List<String> schedules = GSON.fromJson(jsonReader,\n                                             new TypeToken<List<String>>() { }.getType());\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    return schedules;\n  }","id":11737,"modified_method":"public static List<String> getSchedules(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.workflowSchedules(request, responder, appId, wflowId);\n\n    List<String> schedules = responder.decodeResponseContent(new TypeToken<List<String>>() { });\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    return schedules;\n  }","commit_id":"f31766d3c90de0b68f59518ae5225fc296d7d861","url":"https://github.com/caskdata/cdap"},{"original_method":"public static List<RunRecord> getHistory(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/history\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.runnableHistory(request, responder, appId, \"workflows\", wflowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                               (responder.getResponseContent())), Charsets.UTF_8));\n    List<Map<String, String>> runList = GSON.fromJson(jsonReader,\n                                         new TypeToken<List<Map<String, String>>>() { }.getType());\n\n    List<RunRecord> runRecords = Lists.newArrayList();\n    for (Map<String, String> run : runList) {\n      runRecords.add(new RunRecord(run.get(\"runid\"), Long.parseLong(run.get(\"start\")),\n                                       Long.parseLong(run.get(\"end\")), run.get(\"status\")));\n    }\n    return runRecords;\n  }","id":11738,"modified_method":"public static List<RunRecord> getHistory(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/history\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.runnableHistory(request, responder, appId, \"workflows\", wflowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n\n    List<Map<String, String>> runList = responder.decodeResponseContent(new TypeToken<List<Map<String, String>>>() { });\n    List<RunRecord> runRecords = Lists.newArrayList();\n    for (Map<String, String> run : runList) {\n      runRecords.add(new RunRecord(run.get(\"runid\"), Long.parseLong(run.get(\"start\")),\n                                       Long.parseLong(run.get(\"end\")), run.get(\"status\")));\n    }\n    return runRecords;\n  }","commit_id":"f31766d3c90de0b68f59518ae5225fc296d7d861","url":"https://github.com/caskdata/cdap"},{"original_method":"public static String scheduleStatus(AppFabricHttpHandler httpHandler, String appId, String wflowId,\n                             String schedId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules/%s/status\", appId, wflowId, schedId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.getScheuleState(request, responder, appId, wflowId, schedId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                               (responder.getResponseContent())), Charsets.UTF_8));\n    Map<String, String> json = GSON.fromJson(jsonReader,\n                                             new TypeToken<Map<String, String>>() { }.getType());\n    return json.get(\"status\");\n  }","id":11739,"modified_method":"public static String scheduleStatus(AppFabricHttpHandler httpHandler, String appId, String wflowId,\n                             String schedId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules/%s/status\", appId, wflowId, schedId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.getScheuleState(request, responder, appId, wflowId, schedId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    Map<String, String> json = responder.decodeResponseContent(new TypeToken<Map<String, String>>() { });\n    return json.get(\"status\");\n  }","commit_id":"f31766d3c90de0b68f59518ae5225fc296d7d861","url":"https://github.com/caskdata/cdap"},{"original_method":"public static String getStatus(AppFabricHttpHandler httpHandler, String appId, String flowId,\n                                 String type) {\n\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/%s/%s/status\", appId, type, flowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri);\n    httpHandler.getStatus(request, responder, appId, type, flowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \"get status\" + \" \" + type + \"failed\");\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                          (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                          (responder.getResponseContent())), Charsets.UTF_8));\n    Map<String, String> json = GSON.fromJson(jsonReader,\n                                             new TypeToken<Map<String, String>>() { }.getType());\n    return json.get(\"status\");\n  }","id":11740,"modified_method":"public static String getStatus(AppFabricHttpHandler httpHandler, String appId, String flowId,\n                                 String type) {\n\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/%s/%s/status\", appId, type, flowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri);\n    httpHandler.getStatus(request, responder, appId, type, flowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \"get status\" + \" \" + type + \"failed\");\n    Map<String, String> json = responder.decodeResponseContent(new TypeToken<Map<String, String>>() { });\n    return json.get(\"status\");\n  }","commit_id":"f31766d3c90de0b68f59518ae5225fc296d7d861","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendContent(HttpResponseStatus status,\n                          ChannelBuffer content, String contentType, Multimap<String, String> headers) {\n    if (content != null) {\n      this.content = content.array();\n    }\n    this.status = status;\n  }","id":11741,"modified_method":"@Override\n  public void sendContent(HttpResponseStatus status,\n                          ChannelBuffer content, String contentType, Multimap<String, String> headers) {\n    if (content != null) {\n      this.content = content;\n    }\n    this.status = status;\n  }","commit_id":"f31766d3c90de0b68f59518ae5225fc296d7d861","url":"https://github.com/caskdata/cdap"},{"original_method":"@Nonnull\n    public ReplicationQueue getQueue(@Nonnull String agentName, @Nonnull String queueName)\n            throws ReplicationQueueException {\n        String key = agentName + queueName;\n\n        ReplicationQueue queue = queueMap.get(key);\n        if (queue == null) {\n            log.info(\"creating a queue with key {}\", key);\n            queue = getOrCreateQueue(agentName, queueName);\n            queueMap.put(key, queue);\n            log.info(\"queue created {}\", queue);\n        }\n        return queue;\n    }","id":11742,"modified_method":"@Nonnull\n    public ReplicationQueue getQueue(@Nonnull String agentName, @Nonnull String queueName)\n            throws ReplicationQueueException {\n        String key = agentName + queueName;\n\n        ReplicationQueue queue = queueMap.get(key);\n        if (queue == null) {\n            log.info(\"creating a queue with key {}\", key);\n            queue = getInternalQueue(agentName, queueName);\n            queueMap.put(key, queue);\n            log.info(\"queue created {}\", queue);\n        }\n        return queue;\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"protected abstract ReplicationQueue getOrCreateQueue(String agentName, String queueName) throws ReplicationQueueException;","id":11743,"modified_method":"protected abstract ReplicationQueue getInternalQueue(String agentName, String queueName) throws ReplicationQueueException;","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Nonnull\n    public ReplicationQueueItemState add(@Nonnull String agentName, @Nonnull ReplicationQueueItem item,\n                                         @Nonnull ReplicationQueueProvider queueProvider)\n            throws ReplicationQueueException {\n        try {\n            log.debug(\"using error aware queue distribution\");\n            ReplicationQueueItemState state = new ReplicationQueueItemState();\n            ReplicationQueue queue = queueProvider.getDefaultQueue(agentName);\n            log.debug(\"obtained queue {}\", queue);\n            if (queue.add(item)) {\n                log.info(\"replication status: {}\", state);\n                state = queue.getStatus(item);\n            } else {\n                log.error(\"could not add the item to the queue {}\", queue);\n                state.setItemState(ItemState.ERROR);\n                state.setSuccessful(false);\n            }\n            return state;\n        } finally {\n            checkAndRemoveStuckItems(agentName, queueProvider);\n        }\n    }","id":11744,"modified_method":"public boolean add(String agentName, ReplicationPackage replicationPackage,\n                         ReplicationQueueProvider queueProvider) throws ReplicationQueueException {\n        boolean added;\n        ReplicationQueueItem queueItem = getItem(replicationPackage);\n        ReplicationQueue queue = queueProvider.getDefaultQueue(agentName);\n        added = queue.add(queueItem);\n        checkAndRemoveStuckItems(agentName, queueProvider);\n        return added;\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"private void checkAndRemoveStuckItems(String agent,\n                                          ReplicationQueueProvider queueProvider) throws ReplicationQueueException {\n        ReplicationQueue defaultQueue = queueProvider.getDefaultQueue(agent);\n        // get first item in the queue with its status\n        ReplicationQueueItem firstItem = defaultQueue.getHead();\n        if (firstItem != null) {\n            ReplicationQueueItemState status = defaultQueue.getStatus(firstItem);\n            // if item is still in the queue after a max no. of attempts, move it to the error queue\n            int attempts = status.getAttempts();\n            Calendar entered = status.getEntered();\n            log.info(\"item {} entered {} was attempted {} times\", new Object[]{firstItem, entered, attempts});\n            if (attempts > attemptsThreshold || (entered != null && Calendar.getInstance().getTimeInMillis() - entered.getTimeInMillis() > timeThreshold)) {\n                if (ERROR.equals(stuckQueueHandling)) {\n                    log.warn(\"item {} moved to the error queue\", firstItem);\n\n                    ReplicationQueue errorQueue = queueProvider.getQueue(agent, \"-error\");\n                    if (!errorQueue.add(firstItem)) {\n                        log.error(\"failed to move item {} the queue {}\", firstItem, errorQueue);\n                        throw new ReplicationQueueException(\"could not move an item to the error queue\");\n                    }\n                }\n                log.warn(\"item {} dropped from the default queue\", firstItem);\n                defaultQueue.remove(firstItem.getId());\n            }\n        }\n    }","id":11745,"modified_method":"private void checkAndRemoveStuckItems(String agent,\n                                          ReplicationQueueProvider queueProvider) throws ReplicationQueueException {\n        ReplicationQueue defaultQueue = queueProvider.getDefaultQueue(agent);\n        // get first item in the queue with its status\n        ReplicationQueueItem firstItem = defaultQueue.getHead();\n        if (firstItem != null) {\n            ReplicationQueueItemState status = defaultQueue.getStatus(firstItem);\n            // if item is still in the queue after a max no. of attempts, move it to the error queue\n            int attempts = status.getAttempts();\n            Calendar entered = status.getEntered();\n            log.info(\"item {} entered {} was attempted {} times\", new Object[]{firstItem, entered, attempts});\n            if (attempts > attemptsThreshold || (entered != null && Calendar.getInstance().getTimeInMillis() - entered.getTimeInMillis() > timeThreshold)) {\n                if (ERROR.equals(stuckQueueHandling)) {\n                    log.warn(\"item {} moved to the error queue\", firstItem);\n\n                    ReplicationQueue errorQueue = queueProvider.getQueue(agent, ERROR_QUEUE_NAME);\n                    if (!errorQueue.add(firstItem)) {\n                        log.error(\"failed to move item {} the queue {}\", firstItem, errorQueue);\n                        throw new ReplicationQueueException(\"could not move an item to the error queue\");\n                    }\n                }\n                log.warn(\"item {} dropped from the default queue\", firstItem);\n                defaultQueue.remove(firstItem.getId());\n            }\n        }\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n    }","id":11746,"modified_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNull(returnedState);\n    }","id":11747,"modified_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n        boolean returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithMultipleFailingItemsDeliveryAndDropFromQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"attempts.threshold\")).thenReturn(new String[]{\"1\"});\n        when(properties.get(\"stuck.handling\")).thenReturn(new String[]{\"DROP\"});\n        when(context.getProperties()).thenReturn(properties);\n        errorAwareDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        when(queue.getHead()).thenReturn(replicationPackage);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(state.getAttempts()).thenReturn(2);\n        when(queue.getStatus(any(ReplicationQueueItem.class))).thenReturn(state);\n        ReplicationQueueItemState returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertFalse(returnedState.isSuccessful());\n    }","id":11748,"modified_method":"@Test\n    public void testPackageAdditionWithMultipleFailingItemsDeliveryAndDropFromQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"attempts.threshold\")).thenReturn(new String[]{\"1\"});\n        when(properties.get(\"stuck.handling\")).thenReturn(new String[]{\"DROP\"});\n        when(context.getProperties()).thenReturn(properties);\n        errorAwareDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n        when(queue.getHead()).thenReturn(mock(ReplicationQueueItem.class));\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(state.getAttempts()).thenReturn(2);\n        when(queue.getStatus(any(ReplicationQueueItem.class))).thenReturn(state);\n        boolean returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithFailingItemDelivery() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertFalse(returnedState.isSuccessful());\n    }","id":11749,"modified_method":"@Test\n    public void testPackageAdditionWithFailingItemDelivery() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        ReplicationQueueItem queueItem = mock(ReplicationQueueItem.class);\n\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(queueItem)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(queue.getStatus(queueItem)).thenReturn(state);\n        boolean returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertFalse(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDelivery() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(true);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertTrue(returnedState.isSuccessful());\n    }","id":11750,"modified_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDelivery() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithMultipleFailingItemsDeliveryAndErrorQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"attempts.threshold\")).thenReturn(new String[]{\"1\"});\n        when(properties.get(\"stuck.handling\")).thenReturn(new String[]{\"ERROR\"});\n        when(context.getProperties()).thenReturn(properties);\n        errorAwareDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        when(queue.getHead()).thenReturn(replicationPackage);\n        ReplicationQueue errorQueue = mock(ReplicationQueue.class);\n        when(errorQueue.add(replicationPackage)).thenReturn(true);\n        when(queueProvider.getQueue(\"agentName\", \"-error\")).thenReturn(errorQueue);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(state.getAttempts()).thenReturn(2);\n        when(queue.getStatus(any(ReplicationQueueItem.class))).thenReturn(state);\n        ReplicationQueueItemState returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertFalse(returnedState.isSuccessful());\n    }","id":11751,"modified_method":"@Test\n    public void testPackageAdditionWithMultipleFailingItemsDeliveryAndErrorQueue() throws Exception {\n        ErrorAwareQueueDistributionStrategy errorAwareDistributionStrategy = new ErrorAwareQueueDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"attempts.threshold\")).thenReturn(new String[]{\"1\"});\n        when(properties.get(\"stuck.handling\")).thenReturn(new String[]{\"ERROR\"});\n        when(context.getProperties()).thenReturn(properties);\n        errorAwareDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        ReplicationQueueItem queueItem = mock(ReplicationQueueItem.class);\n\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(queueItem)).thenReturn(true);\n        when(queue.getHead()).thenReturn(queueItem);\n        ReplicationQueue errorQueue = mock(ReplicationQueue.class);\n        when(errorQueue.add(queueItem)).thenReturn(true);\n        when(queueProvider.getQueue(\"agentName\", ErrorAwareQueueDistributionStrategy.ERROR_QUEUE_NAME)).thenReturn(errorQueue);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(state.getAttempts()).thenReturn(2);\n        when(queue.getStatus(any(ReplicationQueueItem.class))).thenReturn(state);\n        boolean returnedState = errorAwareDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertFalse(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"public void enableQueueProcessing(@Nonnull String agentName, @Nonnull ReplicationQueueProcessor queueProcessor) {\n        // eventually register job consumer for sling job handling based queues\n        Dictionary<String, Object> jobProps = new Hashtable<String, Object>();\n        String topic = JobHandlingReplicationQueue.REPLICATION_QUEUE_TOPIC + '/' + agentName;\n        String childTopic = topic + \"/*\";\n        jobProps.put(JobConsumer.PROPERTY_TOPICS, new String[]{topic, childTopic});\n        synchronized (jobs) {\n            log.info(\"registering job consumer for agent {}\", agentName);\n            ServiceRegistration jobReg = context.registerService(JobConsumer.class.getName(),\n                    new ReplicationAgentJobConsumer(queueProcessor), jobProps);\n            if (jobReg != null) {\n                jobs.put(agentName, jobReg);\n            }\n            log.info(\"job consumer for agent {} registered\", agentName);\n        }\n    }","id":11752,"modified_method":"public void enableQueueProcessing(@Nonnull String agentName, @Nonnull ReplicationQueueProcessor queueProcessor) {\n        // eventually register job consumer for sling job handling based queues\n        Dictionary<String, Object> jobProps = new Hashtable<String, Object>();\n        String topic = JobHandlingReplicationQueue.REPLICATION_QUEUE_TOPIC + '/' + agentName;\n        String childTopic = topic + \"/*\";\n        jobProps.put(JobConsumer.PROPERTY_TOPICS, new String[]{topic, childTopic});\n        synchronized (jobConsumers) {\n            log.info(\"registering job consumer for agent {}\", agentName);\n            ServiceRegistration jobReg = context.registerService(JobConsumer.class.getName(),\n                    new ReplicationAgentJobConsumer(queueProcessor), jobProps);\n            if (jobReg != null) {\n                jobConsumers.put(agentName, jobReg);\n            }\n            log.info(\"job consumer for agent {} registered\", agentName);\n        }\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"public void disableQueueProcessing(@Nonnull String agentName) {\n        synchronized (jobs) {\n            log.info(\"unregistering job consumer for agent {}\", agentName);\n            ServiceRegistration jobReg = jobs.remove(agentName);\n            if (jobReg != null) {\n                jobReg.unregister();\n                log.info(\"job consumer for agent {} unregistered\", agentName);\n            }\n        }\n    }","id":11753,"modified_method":"public void disableQueueProcessing(@Nonnull String agentName) {\n        synchronized (jobConsumers) {\n            log.info(\"unregistering job consumer for agent {}\", agentName);\n            ServiceRegistration jobReg = jobConsumers.remove(agentName);\n            if (jobReg != null) {\n                jobReg.unregister();\n                log.info(\"job consumer for agent {} unregistered\", agentName);\n            }\n        }\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Deactivate\n    private void deactivate() {\n        for (ServiceRegistration jobReg : jobs.values()) {\n            jobReg.unregister();\n        }\n        this.context = null;\n    }","id":11754,"modified_method":"@Deactivate\n    private void deactivate() {\n        for (ServiceRegistration jobReg : jobConsumers.values()) {\n            jobReg.unregister();\n        }\n        this.context = null;\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"protected JobHandlingReplicationQueueProvider(JobManager jobManager, ConfigurationAdmin configAdmin, BundleContext context) {\n        this.jobManager = jobManager;\n        this.configAdmin = configAdmin;\n        this.context = context;\n    }","id":11755,"modified_method":"protected JobHandlingReplicationQueueProvider(JobManager jobManager, BundleContext context) {\n        this.jobManager = jobManager;\n        this.context = context;\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected ReplicationQueue getOrCreateQueue(String agentName, String queueName)\n            throws ReplicationQueueException {\n        try {\n            String name = agentName;\n            if (queueName.length() > 0) {\n                name += \"/\" + queueName;\n            }\n            String topic = JobHandlingReplicationQueue.REPLICATION_QUEUE_TOPIC + '/' + name;\n            if (jobManager.getQueue(name) == null) {\n                Configuration config = configAdmin.createFactoryConfiguration(\n                        QueueConfiguration.class.getName(), null);\n                Dictionary<String, Object> props = new Hashtable<String, Object>();\n                props.put(ConfigurationConstants.PROP_NAME, name);\n                props.put(ConfigurationConstants.PROP_TYPE, QueueConfiguration.Type.ORDERED.name());\n                props.put(ConfigurationConstants.PROP_TOPICS, new String[]{topic});\n                props.put(ConfigurationConstants.PROP_RETRIES, -1);\n                props.put(ConfigurationConstants.PROP_RETRY_DELAY, 2000L);\n                props.put(ConfigurationConstants.PROP_KEEP_JOBS, true);\n                props.put(ConfigurationConstants.PROP_PRIORITY, \"MAX\");\n                config.update(props);\n            }\n            return new JobHandlingReplicationQueue(name, topic, jobManager);\n        } catch (IOException e) {\n            throw new ReplicationQueueException(\"could not create a queue\", e);\n        }\n    }","id":11756,"modified_method":"@Override\n    protected ReplicationQueue getInternalQueue(String agentName, String queueName)\n            throws ReplicationQueueException {\n        String name = agentName;\n        if (queueName.length() > 0) {\n            name += \"/\" + queueName;\n        }\n        String topic = JobHandlingReplicationQueue.REPLICATION_QUEUE_TOPIC + '/' + name;\n        return new JobHandlingReplicationQueue(name, topic, jobManager);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testEnableQueueProcessing() throws Exception {\n        JobManager jobManager = mock(JobManager.class);\n        ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class);\n        Configuration config = mock(Configuration.class);\n        when(configAdmin.createFactoryConfiguration(QueueConfiguration.class.getName(), null)).thenReturn(config);\n        BundleContext context = mock(BundleContext.class);\n        JobHandlingReplicationQueueProvider jobHandlingReplicationQueueProvider = new JobHandlingReplicationQueueProvider(\n                jobManager, configAdmin, context);\n        String agentName = \"dummy-agent\";\n        ReplicationQueueProcessor queueProcessor = mock(ReplicationQueueProcessor.class);\n        jobHandlingReplicationQueueProvider.enableQueueProcessing(agentName, queueProcessor);\n    }","id":11757,"modified_method":"@Test\n    public void testEnableQueueProcessing() throws Exception {\n        JobManager jobManager = mock(JobManager.class);\n        ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class);\n        Configuration config = mock(Configuration.class);\n        when(configAdmin.createFactoryConfiguration(QueueConfiguration.class.getName(), null)).thenReturn(config);\n        BundleContext context = mock(BundleContext.class);\n        JobHandlingReplicationQueueProvider jobHandlingReplicationQueueProvider = new JobHandlingReplicationQueueProvider(\n                jobManager, context);\n        String agentName = \"dummy-agent\";\n        ReplicationQueueProcessor queueProcessor = mock(ReplicationQueueProcessor.class);\n        jobHandlingReplicationQueueProvider.enableQueueProcessing(agentName, queueProcessor);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testDisableQueueProcessing() throws Exception {\n        JobManager jobManager = mock(JobManager.class);\n        ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class);\n        Configuration config = mock(Configuration.class);\n        when(configAdmin.createFactoryConfiguration(QueueConfiguration.class.getName(), null)).thenReturn(config);\n        BundleContext context = mock(BundleContext.class);\n        JobHandlingReplicationQueueProvider jobHandlingReplicationQueueProvider = new JobHandlingReplicationQueueProvider(\n                jobManager, configAdmin, context);\n        String agentName = \"dummy-agent\";\n        jobHandlingReplicationQueueProvider.disableQueueProcessing(agentName);\n    }","id":11758,"modified_method":"@Test\n    public void testDisableQueueProcessing() throws Exception {\n        JobManager jobManager = mock(JobManager.class);\n        ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class);\n        Configuration config = mock(Configuration.class);\n        when(configAdmin.createFactoryConfiguration(QueueConfiguration.class.getName(), null)).thenReturn(config);\n        BundleContext context = mock(BundleContext.class);\n        JobHandlingReplicationQueueProvider jobHandlingReplicationQueueProvider = new JobHandlingReplicationQueueProvider(\n                jobManager,  context);\n        String agentName = \"dummy-agent\";\n        jobHandlingReplicationQueueProvider.disableQueueProcessing(agentName);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testGetOrCreateNamedQueue() throws Exception {\n        JobManager jobManager = mock(JobManager.class);\n        ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class);\n        Configuration config = mock(Configuration.class);\n        when(configAdmin.createFactoryConfiguration(QueueConfiguration.class.getName(), null)).thenReturn(config);\n        BundleContext context = mock(BundleContext.class);\n        JobHandlingReplicationQueueProvider jobHandlingReplicationQueueProvider = new JobHandlingReplicationQueueProvider(\n                jobManager, configAdmin, context);\n        ReplicationQueue queue = jobHandlingReplicationQueueProvider.getOrCreateQueue(\"dummy-agent\", \"default\");\n        assertNotNull(queue);\n    }","id":11759,"modified_method":"@Test\n    public void testGetOrCreateNamedQueue() throws Exception {\n        JobManager jobManager = mock(JobManager.class);\n\n        BundleContext context = mock(BundleContext.class);\n        JobHandlingReplicationQueueProvider jobHandlingReplicationQueueProvider = new JobHandlingReplicationQueueProvider(\n                jobManager, context);\n        ReplicationQueue queue = jobHandlingReplicationQueueProvider.getInternalQueue(\"dummy-agent\", \"default\");\n        assertNotNull(queue);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Nonnull\n    public ReplicationQueueItemState add(@Nonnull String agentName, @Nonnull ReplicationQueueItem item,\n                                         @Nonnull ReplicationQueueProvider queueProvider)\n            throws ReplicationQueueException {\n        log.debug(\"using path priority based queue distribution\");\n        ReplicationQueueItemState state = new ReplicationQueueItemState();\n\n        ReplicationQueue queue = getQueue(agentName, item, queueProvider);\n        log.debug(\"obtained queue {}\", queue);\n\n        if (queue != null) {\n            if (queue.add(item)) {\n                log.info(\"replication status: {}\", state);\n                state = queue.getStatus(item);\n            } else {\n                log.error(\"could not add the item to the queue {}\", queue);\n                state.setItemState(ItemState.ERROR);\n                state.setSuccessful(false);\n            }\n            return state;\n        } else {\n            throw new ReplicationQueueException(\"could not get a queue for agent \" + agentName);\n        }\n\n    }","id":11760,"modified_method":"public boolean add(String agentName, ReplicationPackage replicationPackage,\n                         ReplicationQueueProvider queueProvider) throws ReplicationQueueException {\n\n        ReplicationQueueItem queueItem = getItem(replicationPackage);\n        ReplicationQueue queue = getQueue(agentName, queueItem, queueProvider);\n        if (queue != null) {\n            return queue.add(queueItem);\n        } else {\n            throw new ReplicationQueueException(\"could not get a queue for agent \" + agentName);\n        }\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithFailingItemDelivery() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertFalse(returnedState.isSuccessful());\n    }","id":11761,"modified_method":"@Test\n    public void testPackageAdditionWithFailingItemDelivery() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDelivery() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(true);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertTrue(returnedState.isSuccessful());\n    }","id":11762,"modified_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDelivery() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueue() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n    }","id":11763,"modified_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueue() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithFailingItemDeliveryOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/content/sample2\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getQueue(\"agentName\", \"/content\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertFalse(returnedState.isSuccessful());\n    }","id":11764,"modified_method":"@Test\n    public void testPackageAdditionWithFailingItemDeliveryOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/content/sample2\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n\n        when(queueProvider.getQueue(\"agentName\", \"/content\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueueOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/apps\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getQueue(\"agentName\", \"/apps\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n    }","id":11765,"modified_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueueOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/apps\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n\n        when(queueProvider.getQueue(\"agentName\", \"/apps\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDeliveryOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/content/sample1\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getQueue(\"agentName\", \"/content\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(true);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertTrue(returnedState.isSuccessful());\n    }","id":11766,"modified_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDeliveryOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/content/sample1\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getQueue(\"agentName\", \"/content\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueueOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/apps/some/stuff\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getQueue(\"agentName\", \"/apps\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNull(returnedState);\n    }","id":11767,"modified_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueueOnPriorityPath() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/apps/some/stuff\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n\n        when(queueProvider.getQueue(\"agentName\", \"/apps\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueue() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNull(returnedState);\n    }","id":11768,"modified_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueue() throws Exception {\n        PriorityPathDistributionStrategy priorityPathDistributionStrategy = new PriorityPathDistributionStrategy();\n        ComponentContext context = mock(ComponentContext.class);\n        Dictionary properties = mock(Dictionary.class);\n        when(properties.get(\"priority.paths\")).thenReturn(new String[]{\"/content\", \"/apps\"});\n        when(context.getProperties()).thenReturn(properties);\n        priorityPathDistributionStrategy.activate(context);\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/etc\"});\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n        boolean returnedState = priorityPathDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void doPost(SlingHttpServletRequest request, SlingHttpServletResponse response)\n            throws ServletException, IOException {\n\n        response.setContentType(\"application/json\");\n\n        ReplicationRequest replicationRequest = RequestUtils.fromServletRequest(request);\n\n        ReplicationAgent agent = request.getResource().adaptTo(ReplicationAgent.class);\n\n        ResourceResolver resourceResolver = request.getResourceResolver();\n\n        if (agent != null) {\n            try {\n                ReplicationResponse replicationResponse = agent.execute(resourceResolver, replicationRequest);\n                if (replicationResponse.isSuccessful()) {\n                    response.setStatus(200);\n                } else if (ItemState.QUEUED.toString().equals(replicationResponse.getStatus())\n                        || ItemState.ACTIVE.toString().equals(\n                        replicationResponse.getStatus())) {\n                    response.setStatus(202);\n                } else if (ItemState.DROPPED.toString().equals(\n                        replicationResponse.getStatus())) {\n                    response.setStatus(404);\n                } else {\n                    response.setStatus(400);\n                }\n                response.getWriter().append(replicationResponse.toString());\n            } catch (ReplicationAgentException e) {\n                response.setStatus(503);\n                response.getWriter().append(\"{\\\"error\\\" : \\\"\").append(e.toString()).append(\"\\\"}\");\n            }\n        } else {\n            response.setStatus(404);\n            response.getWriter().append(\"{\\\"error\\\" : \\\"agent \").append(request.getServletPath())\n                    .append(\" not found\\\"}\");\n        }\n    }","id":11769,"modified_method":"@Override\n    protected void doPost(SlingHttpServletRequest request, SlingHttpServletResponse response)\n            throws ServletException, IOException {\n\n        response.setContentType(\"application/json\");\n\n        ReplicationRequest replicationRequest = RequestUtils.fromServletRequest(request);\n\n        ReplicationAgent agent = request.getResource().adaptTo(ReplicationAgent.class);\n\n        ResourceResolver resourceResolver = request.getResourceResolver();\n\n        if (agent != null) {\n            try {\n                ReplicationResponse replicationResponse = agent.execute(resourceResolver, replicationRequest);\n                if (replicationResponse.isSuccessful()) {\n                    if (ItemState.SUCCEEDED.toString().equals(replicationResponse.getStatus())) {\n                        response.setStatus(200);\n                    }\n                    if (ItemState.QUEUED.toString().equals(replicationResponse.getStatus())\n                            || ItemState.ACTIVE.toString().equals(\n                            replicationResponse.getStatus())) {\n                        response.setStatus(202);\n                    }\n\n                }\n                else {\n                    if (ItemState.DROPPED.toString().equals(replicationResponse.getStatus())) {\n                        response.setStatus(404);\n                    } else {\n                        response.setStatus(400);\n                    }\n                }\n\n                response.getWriter().append(replicationResponse.toString());\n            } catch (ReplicationAgentException e) {\n                response.setStatus(503);\n                response.getWriter().append(\"{\\\"error\\\" : \\\"\").append(e.toString()).append(\"\\\"}\");\n            }\n        } else {\n            response.setStatus(404);\n            response.getWriter().append(\"{\\\"error\\\" : \\\"agent \").append(request.getServletPath())\n                    .append(\" not found\\\"}\");\n        }\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"private String generatePathFromId(ResourceResolver resourceResolver, ReplicationPackage replicationPackage) throws PersistenceException {\n        String name = PACKAGE_NAME_PREFIX + \"_\" + System.currentTimeMillis() + \"_\" +  UUID.randomUUID();\n        String packagePath = sharedPackagesRoot + name;\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(PN_ORIGINAL_ID, replicationPackage.getId());\n        properties.put(PN_ORIGINAL_ACTION, replicationPackage.getAction());\n        properties.put(PN_ORIGINAL_PATHS, replicationPackage.getPaths());\n\n        Resource resource = ResourceUtil.getOrCreateResource(resourceResolver, packagePath, \"sling:Folder\", \"nt:unstructured\", false);\n        ModifiableValueMap valueMap = resource.adaptTo(ModifiableValueMap.class);\n        valueMap.putAll(properties);\n\n        resourceResolver.commit();\n        return packagePath;\n\n    }","id":11770,"modified_method":"private String generatePathFromId(ResourceResolver resourceResolver, ReplicationPackage replicationPackage) throws PersistenceException {\n        String name = PACKAGE_NAME_PREFIX + \"_\" + System.currentTimeMillis() + \"_\" +  UUID.randomUUID();\n        String packagePath = sharedPackagesRoot + name;\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(PN_ORIGINAL_ID, replicationPackage.getId());\n        properties.put(PN_ORIGINAL_ACTION, replicationPackage.getAction());\n        properties.put(PN_ORIGINAL_PATHS, replicationPackage.getPaths());\n\n        Resource resource = ResourceUtil.getOrCreateResource(resourceResolver, packagePath, \"nt:unstructured\", \"sling:Folder\", false);\n        ModifiableValueMap valueMap = resource.adaptTo(ModifiableValueMap.class);\n        valueMap.putAll(properties);\n\n        resourceResolver.commit();\n        return packagePath;\n\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"private ReplicationResponse schedule(ReplicationPackage replicationPackage) {\n        ReplicationResponse replicationResponse;\n        log.info(\"scheduling replication of package {}\", replicationPackage);\n\n        ReplicationQueueItem replicationQueueItem = new ReplicationQueueItem(replicationPackage.getId(),\n                replicationPackage.getPaths(),\n                replicationPackage.getAction(),\n                replicationPackage.getType(),\n                replicationPackage.getInfo());\n\n        // dispatch the replication package to the queue distribution handler\n        try {\n            ReplicationQueueItemState state = queueDistributionStrategy.add(name, replicationQueueItem,\n                    queueProvider);\n\n            Dictionary<Object, Object> properties = new Properties();\n            properties.put(\"replication.package.paths\", replicationQueueItem.getPaths());\n            properties.put(\"replication.agent.name\", name);\n            replicationEventFactory.generateEvent(ReplicationEventType.PACKAGE_QUEUED, properties);\n\n            replicationResponse = new ReplicationResponse(state.getItemState().toString(), state.isSuccessful());\n        } catch (Exception e) {\n            log.error(\"an error happened during queue processing\", e);\n            replicationResponse = new ReplicationResponse(e.toString(), false);\n        }\n\n        return replicationResponse;\n    }","id":11771,"modified_method":"private ReplicationResponse schedule(ReplicationPackage replicationPackage) {\n        ReplicationResponse replicationResponse;\n        log.info(\"scheduling replication of package {}\", replicationPackage);\n\n\n\n        // dispatch the replication package to the queue distribution handler\n        try {\n            boolean success = queueDistributionStrategy.add(name, replicationPackage, queueProvider);\n\n            Dictionary<Object, Object> properties = new Properties();\n            properties.put(\"replication.package.paths\", replicationPackage.getPaths());\n            properties.put(\"replication.agent.name\", name);\n            replicationEventFactory.generateEvent(ReplicationEventType.PACKAGE_QUEUED, properties);\n\n            replicationResponse = new ReplicationResponse(success? ReplicationQueueItemState.ItemState.QUEUED.toString() :\n                    ReplicationQueueItemState.ItemState.ERROR.toString(), success);\n        } catch (Exception e) {\n            log.error(\"an error happened during queue processing\", e);\n            replicationResponse = new ReplicationResponse(e.toString(), false);\n        }\n\n        return replicationResponse;\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testReplicationWithWorkingDistributionStrategy() throws Exception {\n        String name = \"sample-agent\";\n        ReplicationPackageImporter packageImporter = mock(ReplicationPackageImporter.class);\n        ReplicationPackageExporter packageExporter = mock(ReplicationPackageExporter.class);\n        ReplicationRequestAuthorizationStrategy packageExporterStrategy = mock(ReplicationRequestAuthorizationStrategy.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueueDistributionStrategy distributionHandler = mock(ReplicationQueueDistributionStrategy.class);\n        ReplicationEventFactory replicationEventFactory = mock(ReplicationEventFactory.class);\n        ResourceResolverFactory resolverFactory = mock(ResourceResolverFactory.class);\n        SimpleReplicationAgent agent = new SimpleReplicationAgent(name,\n                false, \"subServiceName\", packageImporter,\n                packageExporter, packageExporterStrategy,\n                queueProvider,\n                distributionHandler, replicationEventFactory, resolverFactory, null);\n        ReplicationRequest request = new ReplicationRequest(System.nanoTime(),\n                ReplicationActionType.ADD, \"/\");\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ResourceResolver resourceResolver = mock(ResourceResolver.class);\n\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/\"});\n        ReplicationQueueItemState state = new ReplicationQueueItemState();\n        state.setItemState(ReplicationQueueItemState.ItemState.SUCCEEDED);\n        when(distributionHandler.add(any(String.class), any(ReplicationQueueItem.class), eq(queueProvider))).thenReturn(state);\n        when(packageExporter.exportPackages(any(ResourceResolver.class), any(ReplicationRequest.class)))\n                .thenReturn(Arrays.asList(replicationPackage));\n        when(queueProvider.getDefaultQueue(name)).thenReturn(\n                new SimpleReplicationQueue(name, \"name\"));\n        ReplicationResponse response = agent.execute(resourceResolver, request);\n        assertNotNull(response);\n        assertEquals(\"SUCCEEDED\", response.getStatus());\n    }","id":11772,"modified_method":"@Test\n    public void testReplicationWithWorkingDistributionStrategy() throws Exception {\n        String name = \"sample-agent\";\n        ReplicationPackageImporter packageImporter = mock(ReplicationPackageImporter.class);\n        ReplicationPackageExporter packageExporter = mock(ReplicationPackageExporter.class);\n        ReplicationRequestAuthorizationStrategy packageExporterStrategy = mock(ReplicationRequestAuthorizationStrategy.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueueDistributionStrategy distributionHandler = mock(ReplicationQueueDistributionStrategy.class);\n        ReplicationEventFactory replicationEventFactory = mock(ReplicationEventFactory.class);\n        ResourceResolverFactory resolverFactory = mock(ResourceResolverFactory.class);\n        SimpleReplicationAgent agent = new SimpleReplicationAgent(name,\n                false, \"subServiceName\", packageImporter,\n                packageExporter, packageExporterStrategy,\n                queueProvider,\n                distributionHandler, replicationEventFactory, resolverFactory, null);\n        ReplicationRequest request = new ReplicationRequest(System.nanoTime(),\n                ReplicationActionType.ADD, \"/\");\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ResourceResolver resourceResolver = mock(ResourceResolver.class);\n\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/\"});\n        when(distributionHandler.add(any(String.class), any(ReplicationPackage.class), eq(queueProvider))).thenReturn(true);\n        when(packageExporter.exportPackages(any(ResourceResolver.class), any(ReplicationRequest.class)))\n                .thenReturn(Arrays.asList(replicationPackage));\n        when(queueProvider.getDefaultQueue(name)).thenReturn(\n                new SimpleReplicationQueue(name, \"name\"));\n        ReplicationResponse response = agent.execute(resourceResolver, request);\n        assertNotNull(response);\n        assertEquals(\"QUEUED\", response.getStatus());\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testReplicationWithFailingDistributionStrategy() throws Exception {\n        String name = \"sample-agent\";\n        ReplicationPackageImporter packageImporter = mock(ReplicationPackageImporter.class);\n        ReplicationPackageExporter packageExporter = mock(ReplicationPackageExporter.class);\n        ReplicationRequestAuthorizationStrategy packageExporterStrategy = mock(ReplicationRequestAuthorizationStrategy.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueueDistributionStrategy distributionHandler = mock(ReplicationQueueDistributionStrategy.class);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.getItemState()).thenReturn(ReplicationQueueItemState.ItemState.ERROR);\n        when(distributionHandler.add(any(String.class), any(ReplicationQueueItem.class), any(ReplicationQueueProvider.class))).thenReturn(state);\n        ReplicationEventFactory replicationEventFactory = mock(ReplicationEventFactory.class);\n        ResourceResolverFactory resolverFactory = mock(ResourceResolverFactory.class);\n\n        SimpleReplicationAgent agent = new SimpleReplicationAgent(name,\n                false, \"serviceName\", packageImporter,\n                packageExporter, packageExporterStrategy,\n                queueProvider, distributionHandler,\n                replicationEventFactory, resolverFactory,  null);\n        ReplicationRequest request = new ReplicationRequest(System.nanoTime(),\n                ReplicationActionType.ADD, \"/\");\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ResourceResolver resourceResolver = mock(ResourceResolver.class);\n\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/\"});\n        when(packageExporter.exportPackages(any(ResourceResolver.class), any(ReplicationRequest.class)))\n                .thenReturn(Arrays.asList(replicationPackage));\n        when(queueProvider.getDefaultQueue(name)).thenReturn(\n                new SimpleReplicationQueue(name, \"name\"));\n        ReplicationResponse response = agent.execute(resourceResolver, request);\n        assertNotNull(response);\n        assertEquals(\"ERROR\", response.getStatus());\n    }","id":11773,"modified_method":"@Test\n    public void testReplicationWithFailingDistributionStrategy() throws Exception {\n        String name = \"sample-agent\";\n        ReplicationPackageImporter packageImporter = mock(ReplicationPackageImporter.class);\n        ReplicationPackageExporter packageExporter = mock(ReplicationPackageExporter.class);\n        ReplicationRequestAuthorizationStrategy packageExporterStrategy = mock(ReplicationRequestAuthorizationStrategy.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueueDistributionStrategy distributionHandler = mock(ReplicationQueueDistributionStrategy.class);\n        when(distributionHandler.add(any(String.class), any(ReplicationPackage.class), any(ReplicationQueueProvider.class))).thenReturn(false);\n        ReplicationEventFactory replicationEventFactory = mock(ReplicationEventFactory.class);\n        ResourceResolverFactory resolverFactory = mock(ResourceResolverFactory.class);\n\n        SimpleReplicationAgent agent = new SimpleReplicationAgent(name,\n                false, \"serviceName\", packageImporter,\n                packageExporter, packageExporterStrategy,\n                queueProvider, distributionHandler,\n                replicationEventFactory, resolverFactory,  null);\n        ReplicationRequest request = new ReplicationRequest(System.nanoTime(),\n                ReplicationActionType.ADD, \"/\");\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ResourceResolver resourceResolver = mock(ResourceResolver.class);\n\n        when(replicationPackage.getPaths()).thenReturn(new String[]{\"/\"});\n        when(packageExporter.exportPackages(any(ResourceResolver.class), any(ReplicationRequest.class)))\n                .thenReturn(Arrays.asList(replicationPackage));\n        when(queueProvider.getDefaultQueue(name)).thenReturn(\n                new SimpleReplicationQueue(name, \"name\"));\n        ReplicationResponse response = agent.execute(resourceResolver, request);\n        assertNotNull(response);\n        assertEquals(\"ERROR\", response.getStatus());\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"protected ReplicationQueue getOrCreateQueue(String agentName, String selector)\n            throws ReplicationQueueException {\n        return new SimpleReplicationQueue(agentName, selector);\n    }","id":11774,"modified_method":"protected ReplicationQueue getInternalQueue(String agentName, String selector)\n            throws ReplicationQueueException {\n        return new SimpleReplicationQueue(agentName, selector);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testGetOrCreateQueue() throws Exception {\n        SimpleReplicationQueueProvider simpleReplicationQueueProvider = new SimpleReplicationQueueProvider();\n        ReplicationQueue queue = simpleReplicationQueueProvider.getOrCreateQueue(\"dummy-agent\", \"default\");\n        assertNotNull(queue);\n    }","id":11775,"modified_method":"@Test\n    public void testGetOrCreateQueue() throws Exception {\n        SimpleReplicationQueueProvider simpleReplicationQueueProvider = new SimpleReplicationQueueProvider();\n        ReplicationQueue queue = simpleReplicationQueueProvider.getInternalQueue(\"dummy-agent\", \"default\");\n        assertNotNull(queue);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Nonnull\n    public ReplicationQueueItemState add(@Nonnull String agentName, @Nonnull ReplicationQueueItem item,\n                                         @Nonnull ReplicationQueueProvider queueProvider)\n            throws ReplicationQueueException {\n        log.debug(\"using single queue distribution\");\n\n        ReplicationQueueItemState state = new ReplicationQueueItemState();\n        ReplicationQueue queue = queueProvider.getDefaultQueue(agentName);\n        log.debug(\"obtained queue {}\", queue);\n\n        if (queue.add(item)) {\n            state = queue.getStatus(item);\n            log.info(\"replication status: {}\", state);\n        } else {\n            log.error(\"could not add the item to the queue {}\", queue);\n            state.setItemState(ItemState.ERROR);\n            state.setSuccessful(false);\n        }\n        return state;\n\n    }","id":11776,"modified_method":"public boolean add(String agentName, ReplicationPackage replicationPackage,\n                         ReplicationQueueProvider queueProvider) throws ReplicationQueueException {\n        ReplicationQueueItem queueItem = getItem(replicationPackage);\n        ReplicationQueue queue = queueProvider.getDefaultQueue(agentName);\n        return queue.add(queueItem);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueue() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNull(returnedState);\n    }","id":11777,"modified_method":"@Test\n    public void testPackageAdditionWithNullItemStateFromTheQueue() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n        boolean returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDelivery() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(true);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertTrue(returnedState.isSuccessful());\n    }","id":11778,"modified_method":"@Test\n    public void testPackageAdditionWithSucceedingItemDelivery() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueue() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n    }","id":11779,"modified_method":"@Test\n    public void testPackageAdditionWithNotNullItemStateFromTheQueue() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(any(ReplicationQueueItem.class))).thenReturn(true);\n\n        boolean returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertTrue(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testPackageAdditionWithFailingItemDelivery() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationQueueItem replicationPackage = mock(ReplicationQueueItem.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(replicationPackage)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(queue.getStatus(replicationPackage)).thenReturn(state);\n        ReplicationQueueItemState returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertNotNull(returnedState);\n        assertFalse(returnedState.isSuccessful());\n    }","id":11780,"modified_method":"@Test\n    public void testPackageAdditionWithFailingItemDelivery() throws Exception {\n        SingleQueueDistributionStrategy singleQueueDistributionStrategy = new SingleQueueDistributionStrategy();\n        ReplicationPackage replicationPackage = mock(ReplicationPackage.class);\n        ReplicationQueueProvider queueProvider = mock(ReplicationQueueProvider.class);\n        ReplicationQueue queue = mock(ReplicationQueue.class);\n        ReplicationQueueItem queueItem = mock(ReplicationQueueItem.class);\n        when(queueProvider.getDefaultQueue(\"agentName\")).thenReturn(queue);\n        when(queue.add(queueItem)).thenReturn(true);\n        ReplicationQueueItemState state = mock(ReplicationQueueItemState.class);\n        when(state.isSuccessful()).thenReturn(false);\n        when(queue.getStatus(queueItem)).thenReturn(state);\n        boolean returnedState = singleQueueDistributionStrategy.add(\"agentName\", replicationPackage, queueProvider);\n        assertFalse(returnedState);\n    }","commit_id":"a1ccce3b5c703e9084b4961a96bb639d05895fda","url":"https://github.com/apache/sling"},{"original_method":"/** Setup renderer hints for the MXBean attributes. */\n    @SuppressWarnings(\"rawtypes\")\n    public static void init() {\n        if (initialized.get()) return;\n        synchronized (initialized) {\n            if (initialized.get()) return;\n\n            RendererHints.register(UsesJavaMXBeans.USED_HEAP_MEMORY, new RendererHints.DisplayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.INIT_HEAP_MEMORY, new RendererHints.DisplayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.MAX_HEAP_MEMORY, new RendererHints.DisplayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.COMMITTED_HEAP_MEMORY, new RendererHints.DisplayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.NON_HEAP_MEMORY_USAGE, new RendererHints.DisplayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.TOTAL_PHYSICAL_MEMORY_SIZE, new RendererHints.DisplayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.FREE_PHYSICAL_MEMORY_SIZE, new RendererHints.DisplayValue(ByteSizeStrings.metric()));\n\n            RendererHints.register(UsesJavaMXBeans.START_TIME, new RendererHints.DisplayValue(Time.toDateString()));\n            RendererHints.register(UsesJavaMXBeans.UP_TIME, new RendererHints.DisplayValue(Duration.millisToStringRounded()));\n            RendererHints.register(UsesJavaMXBeans.PROCESS_CPU_TIME, new RendererHints.DisplayValue(Duration.millisToStringRounded()));\n            RendererHints.register(UsesJavaMXBeans.PROCESS_CPU_TIME_FRACTION_LAST, new RendererHints.DisplayValue(Duration.millisToStringRounded()));\n            RendererHints.register(UsesJavaMXBeans.PROCESS_CPU_TIME_FRACTION_IN_WINDOW, new RendererHints.DisplayValue(Duration.millisToStringRounded()));\n\n            initialized.set(true);\n        }\n    }","id":11781,"modified_method":"/** Setup renderer hints for the MXBean attributes. */\n    @SuppressWarnings(\"rawtypes\")\n    public static void init() {\n        if (initialized.get()) return;\n        synchronized (initialized) {\n            if (initialized.get()) return;\n\n            RendererHints.register(UsesJavaMXBeans.USED_HEAP_MEMORY, RendererHints.displayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.INIT_HEAP_MEMORY, RendererHints.displayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.MAX_HEAP_MEMORY, RendererHints.displayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.COMMITTED_HEAP_MEMORY, RendererHints.displayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.NON_HEAP_MEMORY_USAGE, RendererHints.displayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.TOTAL_PHYSICAL_MEMORY_SIZE, RendererHints.displayValue(ByteSizeStrings.metric()));\n            RendererHints.register(UsesJavaMXBeans.FREE_PHYSICAL_MEMORY_SIZE, RendererHints.displayValue(ByteSizeStrings.metric()));\n\n            RendererHints.register(UsesJavaMXBeans.START_TIME, RendererHints.displayValue(Time.toDateString()));\n            RendererHints.register(UsesJavaMXBeans.UP_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));\n            RendererHints.register(UsesJavaMXBeans.PROCESS_CPU_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));\n            RendererHints.register(UsesJavaMXBeans.PROCESS_CPU_TIME_FRACTION_LAST, RendererHints.displayValue(Duration.millisToStringRounded()));\n            RendererHints.register(UsesJavaMXBeans.PROCESS_CPU_TIME_FRACTION_IN_WINDOW, RendererHints.displayValue(Duration.millisToStringRounded()));\n\n            initialized.set(true);\n        }\n    }","commit_id":"180b94c5ba1fe96cd80b84659e61516c13ce7980","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public String getDisplayValue(Object v) {\n            if (transform != null) {\n                v = transform.apply(v);\n            }\n            if (v != null) {\n                return v.toString();\n            }\n            return null;\n        }","id":11782,"modified_method":"public String getDisplayValue(Object v) {\n            String dv = transform.apply(v);\n            return Strings.nullToEmpty(dv);\n        }","commit_id":"180b94c5ba1fe96cd80b84659e61516c13ce7980","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public DisplayValue(Function transform) {\n            this.transform = transform;\n        }","id":11783,"modified_method":"public DisplayValue(Function<?, String> transform) {\n            this.transform = (Function<Object, String>) Preconditions.checkNotNull(transform, \"transform\");\n        }","commit_id":"180b94c5ba1fe96cd80b84659e61516c13ce7980","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public String getDisplayValue(Entity e, AttributeSensor s) {\n            return getDisplayValue(e.getAttribute(s));\n        }","id":11784,"modified_method":"public String getDisplayValue(Entity e, AttributeSensor<?> s) {\n            return getDisplayValue(e.getAttribute(s));\n        }","commit_id":"180b94c5ba1fe96cd80b84659e61516c13ce7980","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void checkResourceDir(File directory, SnmpThresholdNetworkInterface snmpIface, Date date, Events events) throws IllegalArgumentException {\n        // TODO: do more specific and thorough assertions on arguments\n\n        // Sanity Check\n        if (directory == null || snmpIface.getNodeId() == null || snmpIface.getInetAddress() == null || date == null || events == null) {\n            throw new IllegalArgumentException(\"Null parameters not permitted.\");\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: threshold checking generic resource dir: \" + directory.getAbsolutePath());\n        }\n        \n        String resourceType = directory.getName();\n        \n        if (!directory.exists()) {\n        \tlog().debug(\"Aborting check because this node does not support Resource Type \" + resourceType);\n        \treturn;\n        }\n\n        SnmpThresholdConfiguration config = snmpIface.getThresholdConfiguration(); \n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: group=\"  + config.getGroupName() + \", resourceType=\" + resourceType);\n        }\n        \n        ThresholdResourceType thresholdResourceType = config.getGenericResourceTypeMap().get(resourceType);\n        if (thresholdResourceType == null) {\n            log().info(\"No generic resources for group \" + config.getGroupName());\n            return;\n        }\n        Map<String, ThresholdEntity> thresholdMap = thresholdResourceType.getThresholdMap();\n        \n        File[] files = directory.listFiles();\n        for (File file : files) {\n            String resource = file.getName();\n            for(String threshKey  :thresholdMap.keySet()) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"checkResourceDir: resource=\" + resource);\n                }\n                processThresholdForResource(file, snmpIface, date, events, thresholdMap.get(threshKey), resource);\n            }\n        }\n    }","id":11785,"modified_method":"protected void checkResourceDir(File directory, SnmpThresholdNetworkInterface snmpIface, Date date, Events events) throws IllegalArgumentException {\n        // TODO: do more specific and thorough assertions on arguments\n\n        // Sanity Check\n        if (directory == null || snmpIface.getNodeId() == null || snmpIface.getInetAddress() == null || date == null || events == null) {\n            throw new IllegalArgumentException(\"Null parameters not permitted.\");\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: threshold checking generic resource dir: \" + directory.getAbsolutePath());\n        }\n        \n        String resourceType = directory.getName();\n        \n        if (!directory.exists()) {\n        \tlog().debug(\"Aborting check because this node does not support Resource Type \" + resourceType);\n        \treturn;\n        }\n\n        SnmpThresholdConfiguration config = snmpIface.getThresholdConfiguration(); \n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: group=\"  + config.getGroupName() + \", resourceType=\" + resourceType);\n        }\n        \n        ThresholdResourceType thresholdResourceType = config.getGenericResourceTypeMap().get(resourceType);\n        if (thresholdResourceType == null) {\n            log().info(\"No generic resources for group \" + config.getGroupName());\n            return;\n        }\n        Map<String, ThresholdEntity> thresholdMap = thresholdResourceType.getThresholdMap();\n        \n        File[] files = directory.listFiles();\n        for (File file : files) {\n            String resource = file.getName();\n            for(String threshKey  :thresholdMap.keySet()) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"checkResourceDir: resource=\" + resource);\n                }\n                String dsLabelValue = getDataSourceLabel(file, snmpIface, thresholdMap.get(threshKey));\n                processThresholdForResource(file, snmpIface, date, events, thresholdMap.get(threshKey), dsLabelValue);\n            }\n        }\n    }","commit_id":"8b4b3137b7cfcfa1ccc5fd4bc9b8d2459cff35a2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGenericResourceTypes() throws Exception {\n        System.err.println(\"--------------------------------------------------------\");\n        // Set storeByGroup, because JRBs will be created with this feature\n        System.setProperty(\"org.opennms.rrd.storeByGroup\", \"true\");\n\n        // Get ThresholdGroup and validate data\n        ThresholdGroup group = m_thresholdsDao.get(\"generic-snmp\");\n        assertEquals(1, group.getGenericResourceTypeMap().size());\n        assertEquals(2, group.getGenericResourceTypeMap().get(\"frCircuitIfIndex\").getThresholdMap().size());\n\n        // Common Variables\n        File path = m_fileAnticipator.getTempDir();\n        File nodeDir = m_fileAnticipator.tempDir(path, \"1\");\n        File rtDir = m_fileAnticipator.tempDir(nodeDir, \"frCircuitIfIndex\");\n        Properties strings = new Properties();\n        long start = System.currentTimeMillis();\n        List<String> sources = new ArrayList<String>();\n        sources.add(\"frSentFrames\");\n        sources.add(\"frSentOctets\");\n        sources.add(\"frReceivedFrames\");\n        sources.add(\"frReceivedOctets\");\n\n        // Create JRB File for Resource 1\n        File r1Dir = m_fileAnticipator.tempDir(rtDir, \"Se0.100\");\n        File rrd1 = m_fileAnticipator.tempFile(r1Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r1Dir, sources, \"rfc1315-frame-relay\");\n                \n        // Creating strings.properties for Resource 1\n        strings.setProperty(\"frDlci\", \"100\");\n        strings.setProperty(\"frIntf\", \"0\");\n        File sFile1 = m_fileAnticipator.tempFile(r1Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile1), null);\n        \n        // Creating JRB content for Resource 1\n        List<String> data1 = new ArrayList<String>();\n        data1.add(\"100:200:300:350\"); // TRIGGERED:TRIGGERED:NONE:NONE\n        createAndUpdateRrd(rrd1, start, sources, data1);\n                \n        // Create Temporal Files for Resource 2\n        File r2Dir = m_fileAnticipator.tempDir(rtDir, \"Se1.200\");\n        File rrd2 = m_fileAnticipator.tempFile(r2Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r2Dir, sources, \"rfc1315-frame-relay\");\n\n        // Creating strings.properties for Resource 2\n        strings.setProperty(\"frDlci\", \"200\");\n        strings.setProperty(\"frIntf\", \"1\");\n        File sFile2 = m_fileAnticipator.tempFile(r2Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile2), null);\n        \n        // Creating JRB content for Resource 2        \n        List<String> data2 = new ArrayList<String>();\n        data2.add(\"50:150:400:300\"); // RE_ARMED:NO_CHANGE:NONE:NONE\n        createAndUpdateRrd(rrd2, start, sources, data2);\n\n        // Run Thresholds Check and Validate. It must generate 3 events\n        m_thresholdInterface.getThresholdConfiguration().setThresholdGroup(group);\n        Events events = new Events();\n        m_snmpThresholder.checkResourceDir(rtDir, m_thresholdInterface, new Date(start), events);\n        //assertEquals(3, events.getEventCount()); // with no Filters. See test-thresholds.xml\n        assertEquals(2, events.getEventCount()); // with Filters Enabled. See test-thresholds.xml\n    }","id":11786,"modified_method":"public void testGenericResourceTypes() throws Exception {\n        System.err.println(\"--------------------------------------------------------\");\n        // Set storeByGroup, because JRBs will be created with this feature\n        System.setProperty(\"org.opennms.rrd.storeByGroup\", \"true\");\n\n        // Get ThresholdGroup and validate data\n        ThresholdGroup group = m_thresholdsDao.get(\"generic-snmp\");\n        assertEquals(1, group.getGenericResourceTypeMap().size());\n        assertEquals(2, group.getGenericResourceTypeMap().get(\"frCircuitIfIndex\").getThresholdMap().size());\n\n        // Common Variables\n        File path = m_fileAnticipator.getTempDir();\n        File nodeDir = m_fileAnticipator.tempDir(path, \"1\");\n        File rtDir = m_fileAnticipator.tempDir(nodeDir, \"frCircuitIfIndex\");\n        Properties strings = new Properties();\n        long start = System.currentTimeMillis();\n        List<String> sources = new ArrayList<String>();\n        sources.add(\"frSentFrames\");\n        sources.add(\"frSentOctets\");\n        sources.add(\"frReceivedFrames\");\n        sources.add(\"frReceivedOctets\");\n\n        // Create JRB File for Resource 1\n        File r1Dir = m_fileAnticipator.tempDir(rtDir, \"Se0.100\");\n        File rrd1 = m_fileAnticipator.tempFile(r1Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r1Dir, sources, \"rfc1315-frame-relay\");\n                \n        // Creating strings.properties for Resource 1\n        strings.setProperty(\"frName\", \"caracas\");\n        strings.setProperty(\"frDlci\", \"100\");\n        strings.setProperty(\"frIntf\", \"0\");\n        File sFile1 = m_fileAnticipator.tempFile(r1Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile1), null);\n        \n        // Creating JRB content for Resource 1\n        List<String> data1 = new ArrayList<String>();\n        data1.add(\"100:200:300:350\"); // TRIGGERED:TRIGGERED:NONE:NONE\n        createAndUpdateRrd(rrd1, start, sources, data1);\n                \n        // Create Temporal Files for Resource 2\n        File r2Dir = m_fileAnticipator.tempDir(rtDir, \"Se1.200\");\n        File rrd2 = m_fileAnticipator.tempFile(r2Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r2Dir, sources, \"rfc1315-frame-relay\");\n\n        // Creating strings.properties for Resource 2\n        strings.setProperty(\"frDlci\", \"200\");\n        strings.setProperty(\"frIntf\", \"1\");\n        File sFile2 = m_fileAnticipator.tempFile(r2Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile2), null);\n        \n        // Creating JRB content for Resource 2        \n        List<String> data2 = new ArrayList<String>();\n        data2.add(\"50:150:400:300\"); // RE_ARMED:NO_CHANGE:NONE:NONE\n        createAndUpdateRrd(rrd2, start, sources, data2);\n\n        // Run Thresholds Check and Validate. It must generate 3 events\n        m_thresholdInterface.getThresholdConfiguration().setThresholdGroup(group);\n        Events events = new Events();\n        m_snmpThresholder.checkResourceDir(rtDir, m_thresholdInterface, new Date(start), events);\n        //assertEquals(3, events.getEventCount()); // with no Filters. See test-thresholds.xml\n        assertEquals(2, events.getEventCount()); // with Filters Enabled. See test-thresholds.xml\n        // Validating ds-value for bug 2129\n        for (Event e : events.getEvent()) {\n        \tassertEquals(\"label\", e.getParms().getParm(5).getParmName());\n        \tassertEquals(\"caracas\", e.getParms().getParm(5).getValue().getContent());\n        }\n    }","commit_id":"8b4b3137b7cfcfa1ccc5fd4bc9b8d2459cff35a2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void checkResourceDir(File directory, SnmpThresholdNetworkInterface snmpIface, Date date, Events events) throws IllegalArgumentException {\n        // TODO: do more specific and thorough assertions on arguments\n\n        // Sanity Check\n        if (directory == null || snmpIface.getNodeId() == null || snmpIface.getInetAddress() == null || date == null || events == null) {\n            throw new IllegalArgumentException(\"Null parameters not permitted.\");\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: threshold checking generic resource dir: \" + directory.getAbsolutePath());\n        }\n        \n        String resourceType = directory.getName();\n        \n        if (!directory.exists()) {\n        \tlog().debug(\"Aborting check because this node does not support Resource Type \" + resourceType);\n        \treturn;\n        }\n\n        SnmpThresholdConfiguration config = snmpIface.getThresholdConfiguration(); \n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: group=\"  + config.getGroupName() + \", resourceType=\" + resourceType);\n        }\n        \n        ThresholdResourceType thresholdResourceType = config.getGenericResourceTypeMap().get(resourceType);\n        if (thresholdResourceType == null) {\n            log().info(\"No generic resources for group \" + config.getGroupName());\n            return;\n        }\n        Map<String, ThresholdEntity> thresholdMap = thresholdResourceType.getThresholdMap();\n        \n        File[] files = directory.listFiles();\n        for (File file : files) {\n            String resource = file.getName();\n            for(String threshKey  :thresholdMap.keySet()) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"checkResourceDir: resource=\" + resource);\n                }\n                processThresholdForResource(file, snmpIface, date, events, thresholdMap.get(threshKey), resource);\n            }\n        }\n    }","id":11787,"modified_method":"protected void checkResourceDir(File directory, SnmpThresholdNetworkInterface snmpIface, Date date, Events events) throws IllegalArgumentException {\n        // TODO: do more specific and thorough assertions on arguments\n\n        // Sanity Check\n        if (directory == null || snmpIface.getNodeId() == null || snmpIface.getInetAddress() == null || date == null || events == null) {\n            throw new IllegalArgumentException(\"Null parameters not permitted.\");\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: threshold checking generic resource dir: \" + directory.getAbsolutePath());\n        }\n        \n        String resourceType = directory.getName();\n        \n        if (!directory.exists()) {\n        \tlog().debug(\"Aborting check because this node does not support Resource Type \" + resourceType);\n        \treturn;\n        }\n\n        SnmpThresholdConfiguration config = snmpIface.getThresholdConfiguration(); \n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: group=\"  + config.getGroupName() + \", resourceType=\" + resourceType);\n        }\n        \n        ThresholdResourceType thresholdResourceType = config.getGenericResourceTypeMap().get(resourceType);\n        if (thresholdResourceType == null) {\n            log().info(\"No generic resources for group \" + config.getGroupName());\n            return;\n        }\n        Map<String, ThresholdEntity> thresholdMap = thresholdResourceType.getThresholdMap();\n        \n        File[] files = directory.listFiles();\n        for (File file : files) {\n            String resource = file.getName();\n            for(String threshKey  :thresholdMap.keySet()) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"checkResourceDir: resource=\" + resource);\n                }\n                String dsLabelValue = getDataSourceLabel(file, snmpIface, thresholdMap.get(threshKey));\n                processThresholdForResource(file, snmpIface, date, events, thresholdMap.get(threshKey), dsLabelValue);\n            }\n        }\n    }","commit_id":"ef43a7fd23e1457d99489c6e6d962d21f919470e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGenericResourceTypes() throws Exception {\n        System.err.println(\"--------------------------------------------------------\");\n        // Set storeByGroup, because JRBs will be created with this feature\n        System.setProperty(\"org.opennms.rrd.storeByGroup\", \"true\");\n\n        // Get ThresholdGroup and validate data\n        ThresholdGroup group = m_thresholdsDao.get(\"generic-snmp\");\n        assertEquals(1, group.getGenericResourceTypeMap().size());\n        assertEquals(2, group.getGenericResourceTypeMap().get(\"frCircuitIfIndex\").getThresholdMap().size());\n\n        // Common Variables\n        File path = m_fileAnticipator.getTempDir();\n        File nodeDir = m_fileAnticipator.tempDir(path, \"1\");\n        File rtDir = m_fileAnticipator.tempDir(nodeDir, \"frCircuitIfIndex\");\n        Properties strings = new Properties();\n        long start = System.currentTimeMillis();\n        List<String> sources = new ArrayList<String>();\n        sources.add(\"frSentFrames\");\n        sources.add(\"frSentOctets\");\n        sources.add(\"frReceivedFrames\");\n        sources.add(\"frReceivedOctets\");\n\n        // Create JRB File for Resource 1\n        File r1Dir = m_fileAnticipator.tempDir(rtDir, \"Se0.100\");\n        File rrd1 = m_fileAnticipator.tempFile(r1Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r1Dir, sources, \"rfc1315-frame-relay\");\n                \n        // Creating strings.properties for Resource 1\n        strings.setProperty(\"frDlci\", \"100\");\n        strings.setProperty(\"frIntf\", \"0\");\n        File sFile1 = m_fileAnticipator.tempFile(r1Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile1), null);\n        \n        // Creating JRB content for Resource 1\n        List<String> data1 = new ArrayList<String>();\n        data1.add(\"100:200:300:350\"); // TRIGGERED:TRIGGERED:NONE:NONE\n        createAndUpdateRrd(rrd1, start, sources, data1);\n                \n        // Create Temporal Files for Resource 2\n        File r2Dir = m_fileAnticipator.tempDir(rtDir, \"Se1.200\");\n        File rrd2 = m_fileAnticipator.tempFile(r2Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r2Dir, sources, \"rfc1315-frame-relay\");\n\n        // Creating strings.properties for Resource 2\n        strings.setProperty(\"frDlci\", \"200\");\n        strings.setProperty(\"frIntf\", \"1\");\n        File sFile2 = m_fileAnticipator.tempFile(r2Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile2), null);\n        \n        // Creating JRB content for Resource 2        \n        List<String> data2 = new ArrayList<String>();\n        data2.add(\"50:150:400:300\"); // RE_ARMED:NO_CHANGE:NONE:NONE\n        createAndUpdateRrd(rrd2, start, sources, data2);\n\n        // Run Thresholds Check and Validate. It must generate 3 events\n        m_thresholdInterface.getThresholdConfiguration().setThresholdGroup(group);\n        Events events = new Events();\n        m_snmpThresholder.checkResourceDir(rtDir, m_thresholdInterface, new Date(start), events);\n        //assertEquals(3, events.getEventCount()); // with no Filters. See test-thresholds.xml\n        assertEquals(2, events.getEventCount()); // with Filters Enabled. See test-thresholds.xml\n    }","id":11788,"modified_method":"public void testGenericResourceTypes() throws Exception {\n        System.err.println(\"--------------------------------------------------------\");\n        // Set storeByGroup, because JRBs will be created with this feature\n        System.setProperty(\"org.opennms.rrd.storeByGroup\", \"true\");\n\n        // Get ThresholdGroup and validate data\n        ThresholdGroup group = m_thresholdsDao.get(\"generic-snmp\");\n        assertEquals(1, group.getGenericResourceTypeMap().size());\n        assertEquals(2, group.getGenericResourceTypeMap().get(\"frCircuitIfIndex\").getThresholdMap().size());\n\n        // Common Variables\n        File path = m_fileAnticipator.getTempDir();\n        File nodeDir = m_fileAnticipator.tempDir(path, \"1\");\n        File rtDir = m_fileAnticipator.tempDir(nodeDir, \"frCircuitIfIndex\");\n        Properties strings = new Properties();\n        long start = System.currentTimeMillis();\n        List<String> sources = new ArrayList<String>();\n        sources.add(\"frSentFrames\");\n        sources.add(\"frSentOctets\");\n        sources.add(\"frReceivedFrames\");\n        sources.add(\"frReceivedOctets\");\n\n        // Create JRB File for Resource 1\n        File r1Dir = m_fileAnticipator.tempDir(rtDir, \"Se0.100\");\n        File rrd1 = m_fileAnticipator.tempFile(r1Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r1Dir, sources, \"rfc1315-frame-relay\");\n                \n        // Creating strings.properties for Resource 1\n        strings.setProperty(\"frName\", \"caracas\");\n        strings.setProperty(\"frDlci\", \"100\");\n        strings.setProperty(\"frIntf\", \"0\");\n        File sFile1 = m_fileAnticipator.tempFile(r1Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile1), null);\n        \n        // Creating JRB content for Resource 1\n        List<String> data1 = new ArrayList<String>();\n        data1.add(\"100:200:300:350\"); // TRIGGERED:TRIGGERED:NONE:NONE\n        createAndUpdateRrd(rrd1, start, sources, data1);\n                \n        // Create Temporal Files for Resource 2\n        File r2Dir = m_fileAnticipator.tempDir(rtDir, \"Se1.200\");\n        File rrd2 = m_fileAnticipator.tempFile(r2Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r2Dir, sources, \"rfc1315-frame-relay\");\n\n        // Creating strings.properties for Resource 2\n        strings.setProperty(\"frDlci\", \"200\");\n        strings.setProperty(\"frIntf\", \"1\");\n        File sFile2 = m_fileAnticipator.tempFile(r2Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile2), null);\n        \n        // Creating JRB content for Resource 2        \n        List<String> data2 = new ArrayList<String>();\n        data2.add(\"50:150:400:300\"); // RE_ARMED:NO_CHANGE:NONE:NONE\n        createAndUpdateRrd(rrd2, start, sources, data2);\n\n        // Run Thresholds Check and Validate. It must generate 3 events\n        m_thresholdInterface.getThresholdConfiguration().setThresholdGroup(group);\n        Events events = new Events();\n        m_snmpThresholder.checkResourceDir(rtDir, m_thresholdInterface, new Date(start), events);\n        //assertEquals(3, events.getEventCount()); // with no Filters. See test-thresholds.xml\n        assertEquals(2, events.getEventCount()); // with Filters Enabled. See test-thresholds.xml\n        // Validating ds-value for bug 2129\n        for (Event e : events.getEvent()) {\n        \tassertEquals(\"label\", e.getParms().getParm(5).getParmName());\n        \tassertEquals(\"caracas\", e.getParms().getParm(5).getValue().getContent());\n        }\n    }","commit_id":"ef43a7fd23e1457d99489c6e6d962d21f919470e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void checkResourceDir(File directory, SnmpThresholdNetworkInterface snmpIface, Date date, Events events) throws IllegalArgumentException {\n        // TODO: do more specific and thorough assertions on arguments\n\n        // Sanity Check\n        if (directory == null || snmpIface.getNodeId() == null || snmpIface.getInetAddress() == null || date == null || events == null) {\n            throw new IllegalArgumentException(\"Null parameters not permitted.\");\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: threshold checking generic resource dir: \" + directory.getAbsolutePath());\n        }\n        \n        String resourceType = directory.getName();\n        \n        if (!directory.exists()) {\n        \tlog().debug(\"Aborting check because this node does not support Resource Type \" + resourceType);\n        \treturn;\n        }\n\n        SnmpThresholdConfiguration config = snmpIface.getThresholdConfiguration(); \n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: group=\"  + config.getGroupName() + \", resourceType=\" + resourceType);\n        }\n        \n        ThresholdResourceType thresholdResourceType = config.getGenericResourceTypeMap().get(resourceType);\n        if (thresholdResourceType == null) {\n            log().info(\"No generic resources for group \" + config.getGroupName());\n            return;\n        }\n        Map<String, ThresholdEntity> thresholdMap = thresholdResourceType.getThresholdMap();\n        \n        File[] files = directory.listFiles();\n        for (File file : files) {\n            String resource = file.getName();\n            for(String threshKey  :thresholdMap.keySet()) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"checkResourceDir: resource=\" + resource);\n                }\n                processThresholdForResource(file, snmpIface, date, events, thresholdMap.get(threshKey), resource);\n            }\n        }\n    }","id":11789,"modified_method":"protected void checkResourceDir(File directory, SnmpThresholdNetworkInterface snmpIface, Date date, Events events) throws IllegalArgumentException {\n        // TODO: do more specific and thorough assertions on arguments\n\n        // Sanity Check\n        if (directory == null || snmpIface.getNodeId() == null || snmpIface.getInetAddress() == null || date == null || events == null) {\n            throw new IllegalArgumentException(\"Null parameters not permitted.\");\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: threshold checking generic resource dir: \" + directory.getAbsolutePath());\n        }\n        \n        String resourceType = directory.getName();\n        \n        if (!directory.exists()) {\n        \tlog().debug(\"Aborting check because this node does not support Resource Type \" + resourceType);\n        \treturn;\n        }\n\n        SnmpThresholdConfiguration config = snmpIface.getThresholdConfiguration(); \n        if (log().isDebugEnabled()) {\n            log().debug(\"checkResourceDir: group=\"  + config.getGroupName() + \", resourceType=\" + resourceType);\n        }\n        \n        ThresholdResourceType thresholdResourceType = config.getGenericResourceTypeMap().get(resourceType);\n        if (thresholdResourceType == null) {\n            log().info(\"No generic resources for group \" + config.getGroupName());\n            return;\n        }\n        Map<String, ThresholdEntity> thresholdMap = thresholdResourceType.getThresholdMap();\n        \n        File[] files = directory.listFiles();\n        for (File file : files) {\n            String resource = file.getName();\n            for(String threshKey  :thresholdMap.keySet()) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"checkResourceDir: resource=\" + resource);\n                }\n                String dsLabelValue = getDataSourceLabel(file, snmpIface, thresholdMap.get(threshKey));\n                processThresholdForResource(file, snmpIface, date, events, thresholdMap.get(threshKey), dsLabelValue);\n            }\n        }\n    }","commit_id":"0d138be3c0d50be36aeb28206401290fe269433a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGenericResourceTypes() throws Exception {\n        System.err.println(\"--------------------------------------------------------\");\n        // Set storeByGroup, because JRBs will be created with this feature\n        System.setProperty(\"org.opennms.rrd.storeByGroup\", \"true\");\n\n        // Get ThresholdGroup and validate data\n        ThresholdGroup group = m_thresholdsDao.get(\"generic-snmp\");\n        assertEquals(1, group.getGenericResourceTypeMap().size());\n        assertEquals(2, group.getGenericResourceTypeMap().get(\"frCircuitIfIndex\").getThresholdMap().size());\n\n        // Common Variables\n        File path = m_fileAnticipator.getTempDir();\n        File nodeDir = m_fileAnticipator.tempDir(path, \"1\");\n        File rtDir = m_fileAnticipator.tempDir(nodeDir, \"frCircuitIfIndex\");\n        Properties strings = new Properties();\n        long start = System.currentTimeMillis();\n        List<String> sources = new ArrayList<String>();\n        sources.add(\"frSentFrames\");\n        sources.add(\"frSentOctets\");\n        sources.add(\"frReceivedFrames\");\n        sources.add(\"frReceivedOctets\");\n\n        // Create JRB File for Resource 1\n        File r1Dir = m_fileAnticipator.tempDir(rtDir, \"Se0.100\");\n        File rrd1 = m_fileAnticipator.tempFile(r1Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r1Dir, sources, \"rfc1315-frame-relay\");\n                \n        // Creating strings.properties for Resource 1\n        strings.setProperty(\"frDlci\", \"100\");\n        strings.setProperty(\"frIntf\", \"0\");\n        File sFile1 = m_fileAnticipator.tempFile(r1Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile1), null);\n        \n        // Creating JRB content for Resource 1\n        List<String> data1 = new ArrayList<String>();\n        data1.add(\"100:200:300:350\"); // TRIGGERED:TRIGGERED:NONE:NONE\n        createAndUpdateRrd(rrd1, start, sources, data1);\n                \n        // Create Temporal Files for Resource 2\n        File r2Dir = m_fileAnticipator.tempDir(rtDir, \"Se1.200\");\n        File rrd2 = m_fileAnticipator.tempFile(r2Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r2Dir, sources, \"rfc1315-frame-relay\");\n\n        // Creating strings.properties for Resource 2\n        strings.setProperty(\"frDlci\", \"200\");\n        strings.setProperty(\"frIntf\", \"1\");\n        File sFile2 = m_fileAnticipator.tempFile(r2Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile2), null);\n        \n        // Creating JRB content for Resource 2        \n        List<String> data2 = new ArrayList<String>();\n        data2.add(\"50:150:400:300\"); // RE_ARMED:NO_CHANGE:NONE:NONE\n        createAndUpdateRrd(rrd2, start, sources, data2);\n\n        // Run Thresholds Check and Validate. It must generate 3 events\n        m_thresholdInterface.getThresholdConfiguration().setThresholdGroup(group);\n        Events events = new Events();\n        m_snmpThresholder.checkResourceDir(rtDir, m_thresholdInterface, new Date(start), events);\n        //assertEquals(3, events.getEventCount()); // with no Filters. See test-thresholds.xml\n        assertEquals(2, events.getEventCount()); // with Filters Enabled. See test-thresholds.xml\n    }","id":11790,"modified_method":"public void testGenericResourceTypes() throws Exception {\n        System.err.println(\"--------------------------------------------------------\");\n        // Set storeByGroup, because JRBs will be created with this feature\n        System.setProperty(\"org.opennms.rrd.storeByGroup\", \"true\");\n\n        // Get ThresholdGroup and validate data\n        ThresholdGroup group = m_thresholdsDao.get(\"generic-snmp\");\n        assertEquals(1, group.getGenericResourceTypeMap().size());\n        assertEquals(2, group.getGenericResourceTypeMap().get(\"frCircuitIfIndex\").getThresholdMap().size());\n\n        // Common Variables\n        File path = m_fileAnticipator.getTempDir();\n        File nodeDir = m_fileAnticipator.tempDir(path, \"1\");\n        File rtDir = m_fileAnticipator.tempDir(nodeDir, \"frCircuitIfIndex\");\n        Properties strings = new Properties();\n        long start = System.currentTimeMillis();\n        List<String> sources = new ArrayList<String>();\n        sources.add(\"frSentFrames\");\n        sources.add(\"frSentOctets\");\n        sources.add(\"frReceivedFrames\");\n        sources.add(\"frReceivedOctets\");\n\n        // Create JRB File for Resource 1\n        File r1Dir = m_fileAnticipator.tempDir(rtDir, \"Se0.100\");\n        File rrd1 = m_fileAnticipator.tempFile(r1Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r1Dir, sources, \"rfc1315-frame-relay\");\n                \n        // Creating strings.properties for Resource 1\n        strings.setProperty(\"frName\", \"caracas\");\n        strings.setProperty(\"frDlci\", \"100\");\n        strings.setProperty(\"frIntf\", \"0\");\n        File sFile1 = m_fileAnticipator.tempFile(r1Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile1), null);\n        \n        // Creating JRB content for Resource 1\n        List<String> data1 = new ArrayList<String>();\n        data1.add(\"100:200:300:350\"); // TRIGGERED:TRIGGERED:NONE:NONE\n        createAndUpdateRrd(rrd1, start, sources, data1);\n                \n        // Create Temporal Files for Resource 2\n        File r2Dir = m_fileAnticipator.tempDir(rtDir, \"Se1.200\");\n        File rrd2 = m_fileAnticipator.tempFile(r2Dir, \"rfc1315-frame-relay.jrb\");\n        createDsProperties(r2Dir, sources, \"rfc1315-frame-relay\");\n\n        // Creating strings.properties for Resource 2\n        strings.setProperty(\"frDlci\", \"200\");\n        strings.setProperty(\"frIntf\", \"1\");\n        File sFile2 = m_fileAnticipator.tempFile(r2Dir, \"strings.properties\");\n        strings.store(new FileOutputStream(sFile2), null);\n        \n        // Creating JRB content for Resource 2        \n        List<String> data2 = new ArrayList<String>();\n        data2.add(\"50:150:400:300\"); // RE_ARMED:NO_CHANGE:NONE:NONE\n        createAndUpdateRrd(rrd2, start, sources, data2);\n\n        // Run Thresholds Check and Validate. It must generate 3 events\n        m_thresholdInterface.getThresholdConfiguration().setThresholdGroup(group);\n        Events events = new Events();\n        m_snmpThresholder.checkResourceDir(rtDir, m_thresholdInterface, new Date(start), events);\n        //assertEquals(3, events.getEventCount()); // with no Filters. See test-thresholds.xml\n        assertEquals(2, events.getEventCount()); // with Filters Enabled. See test-thresholds.xml\n        // Validating ds-value for bug 2129\n        for (Event e : events.getEvent()) {\n        \tassertEquals(\"label\", e.getParms().getParm(5).getParmName());\n        \tassertEquals(\"caracas\", e.getParms().getParm(5).getValue().getContent());\n        }\n    }","commit_id":"0d138be3c0d50be36aeb28206401290fe269433a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public void visitPyConditionalExpression(PyConditionalExpression node) {   //PY-4293\n    super.visitPyConditionalExpression(node);\n    if (myVersionsToProcess.contains(LanguageLevel.PYTHON24)) {\n      registerProblem(node, \"Python version 2.4 doesn't support this syntax.\");\n    }\n  }","id":11791,"modified_method":"@Override\n  public void visitPyConditionalExpression(PyConditionalExpression node) {   //PY-4293\n    super.visitPyConditionalExpression(node);\n\n    registerFirst(node,\n                  \"Python version 2.4 doesn't support this syntax.\",\n                  myVersionsToProcess,\n                  LanguageLevel.PYTHON24::equals);\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyFromImportStatement(PyFromImportStatement node) {\n    super.visitPyFromImportStatement(node);\n    PyReferenceExpression importSource  = node.getImportSource();\n    if (importSource != null) {\n      if (myVersionsToProcess.contains(LanguageLevel.PYTHON24)) {      //PY-2793\n        PsiElement prev = importSource.getPrevSibling();\n        if (prev != null && prev.getNode().getElementType() == PyTokenTypes.DOT)\n          registerProblem(node, \"Python version 2.4 doesn't support this syntax.\");\n      }\n    }\n    else {\n      if (myVersionsToProcess.contains(LanguageLevel.PYTHON24))\n        registerProblem(node, \"Python version 2.4 doesn't support this syntax.\");\n    }\n  }","id":11792,"modified_method":"@Override\n  public void visitPyFromImportStatement(PyFromImportStatement node) {\n    super.visitPyFromImportStatement(node);\n\n    final PyReferenceExpression importSource  = node.getImportSource();\n    if (importSource != null) {\n      final PsiElement prev = importSource.getPrevSibling();\n      if (prev != null && prev.getNode().getElementType() == PyTokenTypes.DOT) { // PY-2793\n        registerFirst(node, \"Python version 2.4 doesn't support this syntax.\", myVersionsToProcess, LanguageLevel.PYTHON24::equals);\n      }\n    }\n    else {\n      registerFirst(node, \"Python version 2.4 doesn't support this syntax.\", myVersionsToProcess, LanguageLevel.PYTHON24::equals);\n    }\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyStarExpression(PyStarExpression node) {\n    super.visitPyStarExpression(node);\n\n    if (node.isAssignmentTarget()) {\n      for (LanguageLevel level : myVersionsToProcess) {\n        if (level.isOlderThan(LanguageLevel.PYTHON30)) {\n          registerProblem(node, \"Python versions < 3.0 do not support starred expressions as assignment targets\");\n          break;\n        }\n      }\n    }\n\n    if (node.isUnpacking()) {\n      for (LanguageLevel level : myVersionsToProcess) {\n        if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n          registerProblem(node, \"Python versions < 3.5 do not support starred expressions in tuples, lists, and sets\");\n          break;\n        }\n      }\n    }\n  }","id":11793,"modified_method":"@Override\n  public void visitPyStarExpression(PyStarExpression node) {\n    super.visitPyStarExpression(node);\n\n    if (node.isAssignmentTarget()) {\n      registerFirst(node,\n                    \"Python versions < 3.0 do not support starred expressions as assignment targets\",\n                    myVersionsToProcess,\n                    level -> level.isOlderThan(LanguageLevel.PYTHON30));\n    }\n\n    if (node.isUnpacking()) {\n      registerFirst(node,\n                    \"Python versions < 3.5 do not support starred expressions in tuples, lists, and sets\",\n                    myVersionsToProcess,\n                    level -> level.isOlderThan(LanguageLevel.PYTHON35));\n    }\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyDoubleStarExpression(PyDoubleStarExpression node) {\n    super.visitPyDoubleStarExpression(node);\n\n    for (LanguageLevel level : myVersionsToProcess) {\n      if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n        registerProblem(node, \"Python versions < 3.5 do not support starred expressions in dicts\");\n        break;\n      }\n    }\n  }","id":11794,"modified_method":"@Override\n  public void visitPyDoubleStarExpression(PyDoubleStarExpression node) {\n    super.visitPyDoubleStarExpression(node);\n\n    registerFirst(node,\n                  \"Python versions < 3.5 do not support starred expressions in dicts\",\n                  myVersionsToProcess,\n                  level -> level.isOlderThan(LanguageLevel.PYTHON35));\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyTryExceptStatement(PyTryExceptStatement node) { // PY-2795\n    super.visitPyTryExceptStatement(node);\n    if (myVersionsToProcess.contains(LanguageLevel.PYTHON24)) {\n      PyExceptPart[] excepts =  node.getExceptParts();\n      PyFinallyPart finallyPart = node.getFinallyPart();\n      if (excepts.length != 0 && finallyPart != null)\n        registerProblem(node, \"Python version 2.4 doesn't support this syntax. You could use a finally block to ensure \" +\n                                                \"that code is always executed, or one or more except blocks to catch specific exceptions.\");\n    }\n  }","id":11795,"modified_method":"@Override\n  public void visitPyTryExceptStatement(PyTryExceptStatement node) { // PY-2795\n    super.visitPyTryExceptStatement(node);\n\n    final PyExceptPart[] excepts = node.getExceptParts();\n    final PyFinallyPart finallyPart = node.getFinallyPart();\n    if (excepts.length != 0 && finallyPart != null) {\n      registerFirst(node,\n                    \"Python version 2.4 doesn't support this syntax. You could use a finally block to ensure \" +\n                    \"that code is always executed, or one or more except blocks to catch specific exceptions.\",\n                    myVersionsToProcess,\n                    LanguageLevel.PYTHON24::equals);\n    }\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyYieldExpression(PyYieldExpression node) {\n    super.visitPyYieldExpression(node);\n    if (!node.isDelegating()) {\n      return;\n    }\n    for (LanguageLevel level : myVersionsToProcess) {\n      if (level.isOlderThan(LanguageLevel.PYTHON33)) {\n        registerProblem(node, \"Python versions < 3.3 do not support this syntax. Delegating to a subgenerator is available since \" +\n                              \"Python 3.3; use explicit iteration over subgenerator instead.\");\n        break;\n      }\n    }\n  }","id":11796,"modified_method":"@Override\n  public void visitPyYieldExpression(PyYieldExpression node) {\n    super.visitPyYieldExpression(node);\n\n    if (!node.isDelegating()) {\n      return;\n    }\n\n    registerFirst(node,\n                  \"Python versions < 3.3 do not support this syntax. Delegating to a subgenerator is available since \" +\n                  \"Python 3.3; use explicit iteration over subgenerator instead.\",\n                  myVersionsToProcess,\n                  level -> level.isOlderThan(LanguageLevel.PYTHON33));\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyClass(PyClass node) {    //PY-2719\n    super.visitPyClass(node);\n    if (myVersionsToProcess.contains(LanguageLevel.PYTHON24)) {\n      PyArgumentList list = node.getSuperClassExpressionList();\n      if (list != null && list.getArguments().length == 0)\n        registerProblem(list, \"Python version 2.4 does not support this syntax.\");\n    }\n  }","id":11797,"modified_method":"@Override\n  public void visitPyClass(PyClass node) {    // PY-2719\n    super.visitPyClass(node);\n\n    final PyArgumentList list = node.getSuperClassExpressionList();\n    if (list != null && list.getArguments().length == 0) {\n      registerFirst(list, \"Python version 2.4 does not support this syntax.\", myVersionsToProcess, LanguageLevel.PYTHON24::equals);\n    }\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyPrefixExpression(PyPrefixExpression node) {\n    super.visitPyPrefixExpression(node);\n    if (node.getOperator() == PyTokenTypes.AWAIT_KEYWORD) {\n      for (LanguageLevel level : myVersionsToProcess) {\n        if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n          registerProblem(node, \"Python versions < 3.5 do not support this syntax\");\n          break;\n        }\n      }\n    }\n  }","id":11798,"modified_method":"@Override\n  public void visitPyPrefixExpression(PyPrefixExpression node) {\n    super.visitPyPrefixExpression(node);\n\n    if (node.getOperator() == PyTokenTypes.AWAIT_KEYWORD) {\n      registerFirst(node,\n                    \"Python versions < 3.5 do not support this syntax\",\n                    myVersionsToProcess,\n                    level -> level.isOlderThan(LanguageLevel.PYTHON35));\n    }\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkMatrixMultiplicationOperator(PsiElement node) {\n    boolean problem = false;\n    for (LanguageLevel level : myVersionsToProcess) {\n      if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n        problem = true;\n        break;\n      }\n    }\n    if (problem) {\n      registerProblem(node, \"Python versions < 3.5 do not support matrix multiplication operators\");\n    }\n  }","id":11799,"modified_method":"private void checkMatrixMultiplicationOperator(PsiElement node) {\n    registerFirst(node,\n                  \"Python versions < 3.5 do not support matrix multiplication operators\",\n                  myVersionsToProcess,\n                  level -> level.isOlderThan(LanguageLevel.PYTHON35));\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void highlightIncorrectArguments(@NotNull PyCallExpression callExpression) {\n    final Set<String> keywordArgumentNames = new HashSet<>();\n    boolean seenKeywordArgument = false;\n    boolean seenKeywordContainer = false;\n    boolean seenPositionalContainer = false;\n    for (PyExpression argument : callExpression.getArguments()) {\n      if (argument instanceof PyKeywordArgument) {\n        seenKeywordArgument = true;\n        final String keyword = ((PyKeywordArgument)argument).getKeyword();\n        boolean reported = false;\n        if (keywordArgumentNames.contains(keyword)) {\n          registerProblem(argument, \"Keyword argument repeated\", new PyRemoveArgumentQuickFix());\n          reported = true;\n        }\n        if (seenPositionalContainer && !reported) {\n          for (LanguageLevel level : myVersionsToProcess) {\n            if (level.isOlderThan(LanguageLevel.PYTHON26)) {\n              registerProblem(argument, \"Python versions < 2.6 do not allow keyword arguments after *expression\",\n                              new PyRemoveArgumentQuickFix());\n              reported = true;\n              break;\n            }\n          }\n        }\n        if (seenKeywordContainer && !reported) {\n          for (LanguageLevel level : myVersionsToProcess) {\n            if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n              registerProblem(argument, \"Python versions < 3.5 do not allow keyword arguments after **expression\",\n                              new PyRemoveArgumentQuickFix());\n              break;\n            }\n          }\n        }\n        keywordArgumentNames.add(keyword);\n      }\n      else if (argument instanceof PyStarArgument) {\n        final PyStarArgument starArgument = (PyStarArgument)argument;\n        if (starArgument.isKeyword()) {\n          if (seenKeywordContainer) {\n            for (LanguageLevel level : myVersionsToProcess) {\n              if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n                registerProblem(argument, \"Python versions < 3.5 do not allow duplicate **expressions\", new PyRemoveArgumentQuickFix());\n                break;\n              }\n            }\n          }\n          seenKeywordContainer = true;\n        }\n        else {\n          if (seenPositionalContainer) {\n            for (LanguageLevel level : myVersionsToProcess) {\n              if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n                registerProblem(argument, \"Python versions < 3.5 do not allow duplicate *expressions\", new PyRemoveArgumentQuickFix());\n                break;\n              }\n            }\n          }\n          seenPositionalContainer = true;\n        }\n      }\n      else {\n        if (seenKeywordArgument) {\n          registerProblem(argument, \"Positional argument after keyword argument\", new PyRemoveArgumentQuickFix());\n        }\n        else if (seenPositionalContainer) {\n          for (LanguageLevel level : myVersionsToProcess) {\n            if (level.isOlderThan(LanguageLevel.PYTHON35)) {\n              registerProblem(argument, \"Python versions < 3.5 do not allow positional arguments after *expression\",\n                              new PyRemoveArgumentQuickFix());\n              break;\n            }\n          }\n        }\n        else if (seenKeywordContainer) {\n          registerProblem(argument, \"Positional argument after **expression\", new PyRemoveArgumentQuickFix());\n        }\n      }\n    }\n  }","id":11800,"modified_method":"private void highlightIncorrectArguments(@NotNull PyCallExpression callExpression) {\n    final Set<String> keywordArgumentNames = new HashSet<>();\n\n    boolean seenKeywordArgument = false;\n    boolean seenKeywordContainer = false;\n    boolean seenPositionalContainer = false;\n\n    for (PyExpression argument : callExpression.getArguments()) {\n      if (argument instanceof PyKeywordArgument) {\n        final String keyword = ((PyKeywordArgument)argument).getKeyword();\n\n        if (keywordArgumentNames.contains(keyword)) {\n          registerProblem(argument, \"Keyword argument repeated\", new PyRemoveArgumentQuickFix());\n        }\n        else if (seenPositionalContainer) {\n          registerFirst(argument,\n                        \"Python versions < 2.6 do not allow keyword arguments after *expression\",\n                        new PyRemoveArgumentQuickFix(),\n                        myVersionsToProcess,\n                        level -> level.isOlderThan(LanguageLevel.PYTHON26));\n        }\n        else if (seenKeywordContainer) {\n          registerFirst(argument,\n                        \"Python versions < 3.5 do not allow keyword arguments after **expression\",\n                        new PyRemoveArgumentQuickFix(),\n                        myVersionsToProcess,\n                        level -> level.isOlderThan(LanguageLevel.PYTHON35));\n        }\n\n        seenKeywordArgument = true;\n        keywordArgumentNames.add(keyword);\n      }\n      else if (argument instanceof PyStarArgument) {\n        final PyStarArgument starArgument = (PyStarArgument)argument;\n        if (starArgument.isKeyword()) {\n          if (seenKeywordContainer) {\n            registerFirst(argument,\n                          \"Python versions < 3.5 do not allow duplicate **expressions\",\n                          new PyRemoveArgumentQuickFix(),\n                          myVersionsToProcess,\n                          level -> level.isOlderThan(LanguageLevel.PYTHON35));\n          }\n          seenKeywordContainer = true;\n        }\n        else {\n          if (seenPositionalContainer) {\n            registerFirst(argument,\n                          \"Python versions < 3.5 do not allow duplicate *expressions\",\n                          new PyRemoveArgumentQuickFix(),\n                          myVersionsToProcess,\n                          level -> level.isOlderThan(LanguageLevel.PYTHON35));\n          }\n          seenPositionalContainer = true;\n        }\n      }\n      else {\n        if (seenKeywordArgument) {\n          registerProblem(argument, \"Positional argument after keyword argument\", new PyRemoveArgumentQuickFix());\n        }\n        else if (seenPositionalContainer) {\n          registerFirst(argument,\n                        \"Python versions < 3.5 do not allow positional arguments after *expression\",\n                        new PyRemoveArgumentQuickFix(),\n                        myVersionsToProcess,\n                        level -> level.isOlderThan(LanguageLevel.PYTHON35));\n        }\n        else if (seenKeywordContainer) {\n          registerProblem(argument, \"Positional argument after **expression\", new PyRemoveArgumentQuickFix());\n        }\n      }\n    }\n  }","commit_id":"5009a2b4570474f4588026bc406651b1ba5711be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String[] tokenize(String line, String delimiters, boolean processQuotes) {\n        return StringUtils.tokenizeWithQuotingAndEscapes(line, delimiters, processQuotes);\n    }","id":11801,"modified_method":"private String[] tokenize(String line, String delimiters, boolean processQuotes) {\n        String passthroughTokens = \"lcrjgsJ\"; /* see org.jrobin.graph.RrdGraphConstants.MARKERS */\n        return StringUtils.tokenizeWithQuotingAndEscapes(line, delimiters, processQuotes, passthroughTokens);\n    }","commit_id":"13f8dd159978ee7946f594b4fecb6df84e139081","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected RrdGraphDef createGraphDef(File workDir, String[] commandArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+height);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = tokenize(definition, \":\", true);\n                String[] ds = tokenize(def[0], \"=\", true);\n                File dsFile = new File(workDir, ds[1]);\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n            \n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                graphDef.area(color[0], getColorOrInvisible(color, 1), (area.length > 1 ? area[1] : \"\"));\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n            \n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","id":11802,"modified_method":"protected RrdGraphDef createGraphDef(File workDir, String[] commandArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+height);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = tokenize(definition, \":\", true);\n                String[] ds = tokenize(def[0], \"=\", true);\n                File dsFile = new File(workDir, ds[1]);\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n            \n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                if (area.length > 1) {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1), area[1]);\n                } else {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1));\n                }\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n            \n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","commit_id":"13f8dd159978ee7946f594b4fecb6df84e139081","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected RrdGraphDef createGraphDef(File workDir, String[] commandArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+height);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = tokenize(definition, \":\", true);\n                String[] ds = tokenize(def[0], \"=\", true);\n                File dsFile = new File(workDir, ds[1]);\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n            \n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                graphDef.area(color[0], getColorOrInvisible(color, 1), (area.length > 1 ? area[1] : \"\"));\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n            \n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","id":11803,"modified_method":"protected RrdGraphDef createGraphDef(File workDir, String[] commandArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+height);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = tokenize(definition, \":\", true);\n                String[] ds = tokenize(def[0], \"=\", true);\n                File dsFile = new File(workDir, ds[1]);\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n            \n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                if (area.length > 1) {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1), area[1]);\n                } else {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1));\n                }\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n            \n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","commit_id":"e12d06bdeec58f01443e1f518db96124ee28f14a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String[] tokenize(String line, String delimiters, boolean processQuotes) {\n        return StringUtils.tokenizeWithQuotingAndEscapes(line, delimiters, processQuotes);\n    }","id":11804,"modified_method":"private String[] tokenize(String line, String delimiters, boolean processQuotes) {\n        String passthroughTokens = \"lcrjgsJ\"; /* see org.jrobin.graph.RrdGraphConstants.MARKERS */\n        return StringUtils.tokenizeWithQuotingAndEscapes(line, delimiters, processQuotes, passthroughTokens);\n    }","commit_id":"e12d06bdeec58f01443e1f518db96124ee28f14a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String[] tokenize(String line, String delimiters, boolean processQuotes) {\n        return StringUtils.tokenizeWithQuotingAndEscapes(line, delimiters, processQuotes);\n    }","id":11805,"modified_method":"private String[] tokenize(String line, String delimiters, boolean processQuotes) {\n        String passthroughTokens = \"lcrjgsJ\"; /* see org.jrobin.graph.RrdGraphConstants.MARKERS */\n        return StringUtils.tokenizeWithQuotingAndEscapes(line, delimiters, processQuotes, passthroughTokens);\n    }","commit_id":"5d24dee9eb4e9e35e9c151edb387736e11bc19f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected RrdGraphDef createGraphDef(File workDir, String[] commandArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+height);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = tokenize(definition, \":\", true);\n                String[] ds = tokenize(def[0], \"=\", true);\n                File dsFile = new File(workDir, ds[1]);\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n            \n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                graphDef.area(color[0], getColorOrInvisible(color, 1), (area.length > 1 ? area[1] : \"\"));\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n            \n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","id":11806,"modified_method":"protected RrdGraphDef createGraphDef(File workDir, String[] commandArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+height);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = tokenize(definition, \":\", true);\n                String[] ds = tokenize(def[0], \"=\", true);\n                File dsFile = new File(workDir, ds[1]);\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n            \n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                if (area.length > 1) {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1), area[1]);\n                } else {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1));\n                }\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n            \n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","commit_id":"5d24dee9eb4e9e35e9c151edb387736e11bc19f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static AttributesTransformer getInstance() {\n\t\tif (_attributesTransformer == null) {\n\t\t\t_attributesTransformer = (AttributesTransformer)InstancePool.get(\n\t\t\t\tPropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t}\n\n\t\treturn _attributesTransformer;\n\t}","id":11807,"modified_method":"public static AttributesTransformer getInstance() {\n\t\tif (_attributesTransformer == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_attributesTransformer =\n\t\t\t\t\t(AttributesTransformer)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.LDAP_ATTRS_TRANSFORMER_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _attributesTransformer.getClass().getName());\n\t\t}\n\n\t\treturn _attributesTransformer;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setInstance(\n\t\tAttributesTransformer attributesTransformer) {\n\n\t\t_attributesTransformer = attributesTransformer;\n\t}","id":11808,"modified_method":"public static void setInstance(\n\t\tAttributesTransformer attributesTransformer) {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Set \" + attributesTransformer.getClass().getName());\n\t\t}\n\n\t\t_attributesTransformer = attributesTransformer;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.IMAGE_HOOK_IMPL);\n\t\t\t}\n\n\t\t\t_hook = (Hook)InstancePool.get(PropsValues.IMAGE_HOOK_IMPL);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","id":11809,"modified_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.IMAGE_HOOK_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_hook = (Hook)classLoader.loadClass(\n\t\t\t\t\tPropsValues.IMAGE_HOOK_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.DL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\t_hook = (Hook)InstancePool.get(PropsValues.DL_HOOK_IMPL);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","id":11810,"modified_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.DL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_hook = (Hook)classLoader.loadClass(\n\t\t\t\t\tPropsValues.DL_HOOK_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\t_hook = (Hook)InstancePool.get(PropsValues.MAIL_HOOK_IMPL);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","id":11811,"modified_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_hook = (Hook)classLoader.loadClass(\n\t\t\t\t\tPropsValues.MAIL_HOOK_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static JournalCreationStrategy getInstance() {\n\t\treturn (JournalCreationStrategy)InstancePool.get(\n\t\t\tPropsValues.JOURNAL_LAR_CREATION_STRATEGY);\n\t}","id":11812,"modified_method":"public static JournalCreationStrategy getInstance() {\n\t\tif (_journalCreationStrategy == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.JOURNAL_LAR_CREATION_STRATEGY);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_journalCreationStrategy =\n\t\t\t\t\t(JournalCreationStrategy)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.JOURNAL_LAR_CREATION_STRATEGY).\n\t\t\t\t\t\t\tnewInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + _journalCreationStrategy.getClass().getName());\n\t\t}\n\n\t\treturn _journalCreationStrategy;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static LayoutClone getInstance() {\n\t\tif (_layoutClone == null) {\n\t\t\tif (Validator.isNotNull(PropsValues.LAYOUT_CLONE_IMPL)) {\n\t\t\t\t_layoutClone = (LayoutClone)InstancePool.get(\n\t\t\t\t\tPropsValues.LAYOUT_CLONE_IMPL);\n\t\t\t}\n\t\t}\n\n\t\treturn _layoutClone;\n\t}","id":11813,"modified_method":"public static LayoutClone getInstance() {\n\t\tif (_layoutClone == null) {\n\t\t\tif (Validator.isNotNull(PropsValues.LAYOUT_CLONE_IMPL)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.LAYOUT_CLONE_IMPL);\n\t\t\t\t}\n\n\t\t\t\tClassLoader classLoader =\n\t\t\t\t\tPortalClassLoaderUtil.getClassLoader();\n\n\t\t\t\ttry {\n\t\t\t\t\t_layoutClone = (LayoutClone)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.LAYOUT_CLONE_IMPL).newInstance();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Return \" + _layoutClone.getClass().getName());\n\t\t\t}\n\t\t}\n\n\t\treturn _layoutClone;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static PermissionsListFilter getInstance() {\n\t\tif (_permissionsListFilter == null) {\n\t\t\t_permissionsListFilter = (PermissionsListFilter)InstancePool.get(\n\t\t\t\tPropsUtil.get(PropsKeys.PERMISSIONS_LIST_FILTER));\n\t\t}\n\n\t\treturn _permissionsListFilter;\n\t}","id":11814,"modified_method":"public static PermissionsListFilter getInstance() {\n\t\tif (_permissionsListFilter == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.PERMISSIONS_LIST_FILTER);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_permissionsListFilter =\n\t\t\t\t\t(PermissionsListFilter)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.PERMISSIONS_LIST_FILTER).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _permissionsListFilter.getClass().getName());\n\t\t}\n\n\t\treturn _permissionsListFilter;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ScreenNameGenerator getInstance() {\n\t\tif (_screenNameGenerator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\n\t\t\t_screenNameGenerator = (ScreenNameGenerator)InstancePool.get(\n\t\t\t\tPropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _screenNameGenerator.getClass().getName());\n\t\t}\n\n\t\treturn _screenNameGenerator;\n\t}","id":11815,"modified_method":"public static ScreenNameGenerator getInstance() {\n\t\tif (_screenNameGenerator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_screenNameGenerator =\n\t\t\t\t\t(ScreenNameGenerator)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.USERS_SCREEN_NAME_GENERATOR).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _screenNameGenerator.getClass().getName());\n\t\t}\n\n\t\treturn _screenNameGenerator;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ScreenNameValidator getInstance() {\n\t\tif (_screenNameValidator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\n\t\t\t_screenNameValidator = (ScreenNameValidator)InstancePool.get(\n\t\t\t\tPropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _screenNameValidator.getClass().getName());\n\t\t}\n\n\t\treturn _screenNameValidator;\n\t}","id":11816,"modified_method":"public static ScreenNameValidator getInstance() {\n\t\tif (_screenNameValidator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader = PortalClassLoaderUtil.getClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_screenNameValidator =\n\t\t\t\t\t(ScreenNameValidator)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.USERS_SCREEN_NAME_VALIDATOR).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _screenNameValidator.getClass().getName());\n\t\t}\n\n\t\treturn _screenNameValidator;\n\t}","commit_id":"5ed9b3e1f655120f39e2d075fd5a280117535ab9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * The JS client calls this to grab the latest data in one call. Connections, latest messages, online users\n     * and present users (in a site) are all returned in one lump of JSON. If the online parameter is supplied and\n     * true, a heartbeat is stamped for the sender as well.\n     */\n\t@EntityCustomAction(action = \"latestData\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleLatestData(EntityReference ref, Map<String,Object> params) {\n\t\t\n\t\tlogger.debug(\"handleLatestData\");\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t\t//return new HashMap<String,Object>(0);\n\t\t}\n\t\t\n\t\tString online = (String) params.get(\"online\");\n\t\tString videoAgent = (String) params.get(\"videoAgent\");\n\n\t\tString siteId = (String) params.get(\"siteId\");\n\t\tif (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" +  siteId);\n        }\n\t\t\n\t\tif (logger.isDebugEnabled()) logger.debug(\"online: \" + online);\n\t\t\n\t\tif (online != null && \"true\".equals(online)) {\n\t\t\t\n\t\t\tif (logger.isDebugEnabled()) logger.debug(currentUser.getEid() + \" is online. Stamping their heartbeat ...\");\n\t\t\t\n\t\t\tUserMessage userMessage = new UserMessage(currentUser.getId(), videoAgent);\n\t\t\theartbeatMap.put(currentUser.getId(), userMessage);\n\n            if (clustered) {\n            \t\n            \tlogger.debug(\"We are clustered. Propagating heartbeat ...\");\n            \t\n                Message msg = new Message(null, null, userMessage);\n                try {\n                    clusterChannel.send(msg);\n                    logger.debug(\"Heartbeat message sent.\");\n                } catch (Exception e) {\n                    logger.error(\"Error sending JGroups heartbeat message\", e);\n                }\n            }\n        } else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Removing them from the message map ...\");\n            }\n\n            synchronized (messageMap) {\n                messageMap.remove(currentUser.getId());\n            }\n\n\t        sendClearMessage(currentUser.getId());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Returning an empty data map ...\");\n            }\n\t\t\t\n            return new HashMap<String,Object>(0);\n        }\n\n        List<PortalChatUser> presentUsers = new ArrayList<PortalChatUser>();\n\t\t\n        if (siteId != null && siteId.length() > 0 && showSiteUsers) {\n\t\t\t// A site id has been specified, so we refresh our presence at the \n\t\t\t// location and retrieve the present users\n\t\t\tString location = siteId + \"-presence\";\n\t\t\tpresenceService.setPresence(location);\n\t\t\tList<User> presentSakaiUsers = presenceService.getPresentUsers(siteId + \"-presence\");\n\t\t\tpresentSakaiUsers.remove(currentUser);\n\t\t\tfor (User user : presentSakaiUsers) {\n\t\t\t\tUserMessage heartbeat = heartbeatMap.get(user.getId());\n\t\t\t\t// Flag this user as offline if they can't access portal chat\n\t\t\t\tboolean offline = !portalChatPermittedHelper.checkChatPermitted(user.getId());\n\t\t\t\tpresentUsers.add(new PortalChatUser(user.getId(), user.getDisplayName(), offline, heartbeatMap.get(user.getId()).content));\n\t\t\t}\n        }\n\t\t\n\t\tList<Person> connections = getConnectionsForUser(currentUser.getId());\n\t\t\n\t\tList<PortalChatUser> onlineConnections = new ArrayList<PortalChatUser>(connections.size());\n\t\t\n\t\tDate now = new Date();\n\t\t\n\t\tfor (Person person : connections) {\n\n            String uuid = person.getUuid();\n\t\t\t\n\t\t\tUserMessage lastHeartbeat = heartbeatMap.get(uuid);\n\t\t\t\n\t\t\tif (lastHeartbeat == null) continue;\n\t\t\t\n\t\t\tif ((now.getTime() - lastHeartbeat.timestamp) < pollInterval) {\n\t\t\t\tonlineConnections.add(new PortalChatUser(uuid, uuid, false, lastHeartbeat.content));\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<UserMessage> messages = new ArrayList<UserMessage>();\n\t\tList<UserMessage> videoMessages = new ArrayList<UserMessage>();\n\n\t\tString currentUserId = currentUser.getId();\n\t\t\n\t\tsynchronized (messageMap) {\n\t\t\tif (messageMap.containsKey(currentUserId)) {\n\t\t\t\t// Grab the type map for this user\n                Map<String, Map<String, List<UserMessage>>> typeMap = messageMap.get(currentUserId);\n\n\t\t\t\t// Now pull the plain and video messages for this site\n                messages = typeMap.get(PLAIN).get(siteId);\n                videoMessages = typeMap.get(VIDEO).get(siteId);\n\n\t\t\t\t// Now we can remove the messages for this site\n\t\t\t\ttypeMap.get(PLAIN).remove(siteId);\n\t\t\t\ttypeMap.get(VIDEO).remove(siteId);\n\t\t\t}\n\n            sendClearMessage(currentUserId);\n\t\t}\n\n\t\tMap<String,Object> data = new HashMap<String,Object>(4);\n\t\t\n\t\tdata.put(\"connections\", connections);\n\t\tdata.put(\"messages\", messages);\n\t\tdata.put(\"videoMessages\", videoMessages);\n\t\tdata.put(\"online\", onlineConnections);\n\t\tdata.put(\"showSiteUsers\", showSiteUsers);\n\t\tdata.put(\"presentUsers\", presentUsers);\n\t\tdata.put(\"connectionsAvailable\", true);\n\t\t\n\t\treturn data;\n\t}","id":11817,"modified_method":"/**\n     * The JS client calls this to grab the latest data in one call. Connections, latest messages, online users\n     * and present users (in a site) are all returned in one lump of JSON. If the online parameter is supplied and\n     * true, a heartbeat is stamped for the sender as well.\n     */\n\t@EntityCustomAction(action = \"latestData\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleLatestData(EntityReference ref, Map<String,Object> params) {\n\t\t\n\t\tlogger.debug(\"handleLatestData\");\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tString online = (String) params.get(\"online\");\n\t\tString videoAgent = (String) params.get(\"videoAgent\");\n\n\t\tString siteId = (String) params.get(\"siteId\");\n\t\tif (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" +  siteId);\n        }\n\t\t\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"online: \" + online);\n        }\n\t\t\n\t\tif (online != null && \"true\".equals(online)) {\n\t\t\t\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is online. Stamping their heartbeat ...\");\n            }\n\t\t\t\n\t\t\tUserMessage userMessage = new UserMessage(currentUser.getId(), videoAgent);\n\t\t\theartbeatMap.put(currentUser.getId(), userMessage);\n\n            if (clustered) {\n            \t\n            \tlogger.debug(\"We are clustered. Propagating heartbeat ...\");\n            \t\n                Message msg = new Message(null, null, userMessage);\n                try {\n                    clusterChannel.send(msg);\n                    logger.debug(\"Heartbeat message sent.\");\n                } catch (Exception e) {\n                    logger.error(\"Error sending JGroups heartbeat message\", e);\n                }\n            }\n        } else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Removing them from the message map ...\");\n            }\n\n            synchronized (messageMap) {\n                messageMap.remove(currentUser.getId());\n            }\n\n\t        sendClearMessage(currentUser.getId());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Returning an empty data map ...\");\n            }\n\t\t\t\n            return new HashMap<String,Object>(0);\n        }\n\n        List<PortalChatUser> presentUsers = new ArrayList<PortalChatUser>();\n\t\t\n        if (siteId != null && siteId.length() > 0 && showSiteUsers) {\n\t\t\t// A site id has been specified, so we refresh our presence at the \n\t\t\t// location and retrieve the present users\n\t\t\tString location = siteId + \"-presence\";\n\t\t\tpresenceService.setPresence(location);\n\t\t\tList<User> presentSakaiUsers = presenceService.getPresentUsers(siteId + \"-presence\");\n\t\t\tpresentSakaiUsers.remove(currentUser);\n\t\t\tfor (User user : presentSakaiUsers) {\n\t\t\t\tUserMessage heartbeat = heartbeatMap.get(user.getId());\n\t\t\t\t// Flag this user as offline if they can't access portal chat\n\t\t\t\tboolean offline = !portalChatPermittedHelper.checkChatPermitted(user.getId());\n\t\t\t\tpresentUsers.add(new PortalChatUser(user.getId(), user.getDisplayName(), offline, heartbeatMap.get(user.getId()).content));\n\t\t\t}\n        }\n\t\t\n\t\tList<Person> connections = getConnectionsForUser(currentUser.getId());\n\t\t\n\t\tList<PortalChatUser> onlineConnections = new ArrayList<PortalChatUser>(connections.size());\n\t\t\n\t\tDate now = new Date();\n\t\t\n\t\tfor (Person person : connections) {\n\n            String uuid = person.getUuid();\n\t\t\t\n\t\t\tUserMessage lastHeartbeat = heartbeatMap.get(uuid);\n\t\t\t\n\t\t\tif (lastHeartbeat == null) continue;\n\t\t\t\n\t\t\tif ((now.getTime() - lastHeartbeat.timestamp) < pollInterval) {\n\t\t\t\tonlineConnections.add(new PortalChatUser(uuid, uuid, false, lastHeartbeat.content));\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<UserMessage> messages = new ArrayList<UserMessage>();\n\t\tList<UserMessage> videoMessages = new ArrayList<UserMessage>();\n\n\t\tString currentUserId = currentUser.getId();\n\t\t\n\t\tsynchronized (messageMap) {\n\t\t\tif (messageMap.containsKey(currentUserId)) {\n\t\t\t\t// Grab the type map for this user\n                Map<String, Map<String, List<UserMessage>>> typeMap = messageMap.get(currentUserId);\n\n                // Now pull the plain, video and connection messages for this site\n                messages = typeMap.get(PLAIN).get(siteId);\n                if (messages != null) {\n                    messages.addAll(typeMap.get(PLAIN).get(CONNECTION));\n                } else {\n                    messages = typeMap.get(PLAIN).get(CONNECTION);\n                }\n\n                videoMessages = typeMap.get(VIDEO).get(siteId);\n                if (videoMessages != null) {\n                    videoMessages.addAll(typeMap.get(VIDEO).get(CONNECTION));\n                } else {\n                    videoMessages = typeMap.get(VIDEO).get(CONNECTION);\n                }\n\n                messageMap.remove(currentUserId);\n\t\t\t}\n\n            sendClearMessage(currentUserId);\n\t\t}\n\n\t\tMap<String,Object> data = new HashMap<String,Object>(4);\n\t\t\n\t\tdata.put(\"connections\", connections);\n\t\tdata.put(\"messages\", messages);\n\t\tdata.put(\"videoMessages\", videoMessages);\n\t\tdata.put(\"online\", onlineConnections);\n\t\tdata.put(\"showSiteUsers\", showSiteUsers);\n\t\tdata.put(\"presentUsers\", presentUsers);\n\t\tdata.put(\"connectionsAvailable\", true);\n\t\t\n\t\treturn data;\n\t}","commit_id":"6e81cad4cd2aa711c3f8acb353f10c2435a69e73","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@EntityCustomAction(action = \"servers\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleServers(EntityReference ref) {\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\n\t\tfinal Map<String,Object> data = new HashMap<String,Object>();\n\t\tdata.put(\"iceServers\", iceServers);\n\t\treturn data;\n\t}","id":11818,"modified_method":"@EntityCustomAction(action = \"servers\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleServers(EntityReference ref) {\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\n\t\tfinal Map<String,Object> data = new HashMap<String,Object>();\n\t\tdata.put(\"iceServers\", iceServers);\n\t\treturn data;\n\t}","commit_id":"6e81cad4cd2aa711c3f8acb353f10c2435a69e73","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Implements a threadsafe addition to the message map\n     */\n    private void addMessageToMap(UserMessage m) {\n\n        synchronized (messageMap) {\n\n            if (!messageMap.containsKey(m.to)) {\n                Map<String, Map<String, List<UserMessage>>> typeMap = new HashMap<String, Map<String, List<UserMessage>>>();\n                typeMap.put(PLAIN, new HashMap<String, List<UserMessage>>());\n                typeMap.get(PLAIN).put(m.siteId, new ArrayList<UserMessage>());\n                typeMap.put(VIDEO, new HashMap<String, List<UserMessage>>());\n                typeMap.get(VIDEO).put(m.siteId, new ArrayList<UserMessage>());\n                messageMap.put(m.to, typeMap);\n            }\n\n            if (m.video) {\n                Map<String, List<UserMessage>> siteMap = messageMap.get(m.to).get(VIDEO);\n\n                if (siteMap.containsKey(m.siteId)) {\n                    siteMap.get(m.siteId).add(m);\n                } else {\n                    siteMap.put(m.siteId, Arrays.asList(m));\n                }\n            } else {\n                Map<String, List<UserMessage>> siteMap = messageMap.get(m.to).get(PLAIN);\n\n                if (siteMap.containsKey(m.siteId)) {\n                    siteMap.get(m.siteId).add(m);\n                } else {\n                    siteMap.put(m.siteId, Arrays.asList(m));\n                }\n            }\n\n        }\n    }","id":11819,"modified_method":"/**\n     * Implements a threadsafe addition to the message map\n     */\n    private void addMessageToMap(UserMessage m) {\n\n        synchronized (messageMap) {\n\n            if (!messageMap.containsKey(m.to)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"No message map entry for '\" + m.to + \"'. Creating new entries ...\");\n                }\n                Map<String, Map<String, List<UserMessage>>> typeMap = new HashMap<String, Map<String, List<UserMessage>>>();\n                typeMap.put(PLAIN, new HashMap<String, List<UserMessage>>());\n                typeMap.get(PLAIN).put(m.siteId, new ArrayList<UserMessage>());\n                typeMap.get(PLAIN).put(CONNECTION, new ArrayList<UserMessage>());\n                typeMap.put(VIDEO, new HashMap<String, List<UserMessage>>());\n                typeMap.get(VIDEO).put(m.siteId, new ArrayList<UserMessage>());\n                typeMap.get(VIDEO).put(CONNECTION, new ArrayList<UserMessage>());\n                messageMap.put(m.to, typeMap);\n            }\n\n            if (m.video) {\n                logger.debug(\"Message is a video message\");\n                Map<String, List<UserMessage>> videoMap = messageMap.get(m.to).get(VIDEO);\n\n                if (m.fromConnection) {\n                    videoMap.get(CONNECTION).add(m);\n                } else if (videoMap.containsKey(m.siteId)) {\n                    videoMap.get(m.siteId).add(m);\n                } else {\n                    videoMap.put(m.siteId, Arrays.asList(m));\n                }\n            } else {\n                logger.debug(\"Message is a plain message\");\n                Map<String, List<UserMessage>> plainMap = messageMap.get(m.to).get(PLAIN);\n\n                if (m.fromConnection) {\n                    plainMap.get(CONNECTION).add(m);\n                } else if (plainMap.containsKey(m.siteId)) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"plainMap already contains '\" + m.siteId + \"'\");\n                    }\n                    plainMap.get(m.siteId).add(m);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"plainMap does not contain '\" + m.siteId + \"'. A new list will be mapped\");\n                    }\n                    plainMap.put(m.siteId, Arrays.asList(m));\n                }\n            }\n        }\n    }","commit_id":"6e81cad4cd2aa711c3f8acb353f10c2435a69e73","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * New messages come in here. The recipient is indicated by the parameter 'to'.\n     */\n\tpublic String createEntity(EntityReference ref, Object entity, Map<String, Object> params) {\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tfinal String to = (String) params.get(\"to\");\n\t\tif (to == null) throw new IllegalArgumentException(\"You must supply a recipient\");\n\t\t\n\t\tif (to.equals(currentUser.getId())) {\n\t\t\tthrow new IllegalArgumentException(\"You can't chat with yourself\");\n\t\t}\n\t\t\n\t\tString message = (String) params.get(\"message\");\n\n\t\tif (message == null) {\n            throw new IllegalArgumentException(\"You must supply a message\");\n        }\n\n\t\tString siteId = (String) params.get(\"siteId\");\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" + siteId);\n        }\n\n\t\tboolean isMessageToConnection = \"true\".equals(params.get(\"isMessageToConnection\"));\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"isMessageToConnection: \" + isMessageToConnection);\n        }\n\n        // Sakai plays the role of signalling server in the WebRTC architecture.\n\t\tboolean isVideoSignal = \"true\".equals(params.get(\"video\"));\n\n\t\tfinal UserMessage lastHeartbeat = heartbeatMap.get(to);\n\t\t\n\t\tif (lastHeartbeat == null || ((new Date()).getTime() - lastHeartbeat.timestamp) >= pollInterval) {\n            // If this is not a video signal, send a message via the profile's\n            // messaging function\n            if (!isVideoSignal) {\n                profileMessagingLogic.sendNewMessage(to,currentUser.getId(), UUID.randomUUID().toString(), rb.getString(\"profile_message_subject\"), message);\n            }\n\t\t\treturn \"OFFLINE\";\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"message: \" + message);\n            logger.debug(\"isVideoSignal: \" + isVideoSignal);\n        }\n\t\t\n\t\t// Sanitise the message. XSS attacks. Unescape single quotes. They are valid.\n\t\tif (!isVideoSignal) { \n\t\t\tmessage = StringEscapeUtils.escapeHtml4(\n\t\t\t\t\t\tStringEscapeUtils.escapeEcmaScript(message)).replaceAll(\"\\\\\\\\'\", \"'\");\n\t\t}\n\n\t\tfinal UserMessage userMessage = new UserMessage(currentUser.getId(), to, siteId, message, isVideoSignal, false, isMessageToConnection);\n\n\t\taddMessageToMap(userMessage);\n\t\t\n        if (clustered) {\n            try {\n            \tif (logger.isDebugEnabled()) {\n                    logger.debug(\"Sending \" + (isVideoSignal ? \"video signal \" : \"\") + \"message to cluster ...\");\n                }\n                Message msg = new Message(null, null, userMessage);\n            \tclusterChannel.send(msg);\n            } catch (Exception e) {\n                logger.error(\"Error sending JGroups message\", e);\n            }\n        }\n\t\t\n\t\treturn \"success\";\n\t}","id":11820,"modified_method":"/**\n     * New messages come in here. The recipient is indicated by the parameter 'to'.\n     */\n\tpublic String createEntity(EntityReference ref, Object entity, Map<String, Object> params) {\n\n        logger.debug(\"createEntity\");\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tfinal String to = (String) params.get(\"to\");\n        if (to == null) {\n            logger.debug(\"No recipient\");\n            throw new IllegalArgumentException(\"You must supply a recipient\");\n        }\n\t\t\n\t\tif (to.equals(currentUser.getId())) {\n            logger.debug(\"recipient is sender\");\n\t\t\tthrow new IllegalArgumentException(\"You can't chat with yourself\");\n\t\t}\n\t\t\n\t\tString message = (String) params.get(\"message\");\n\n\t\tif (message == null) {\n            logger.debug(\"no message supplied\");\n            throw new IllegalArgumentException(\"You must supply a message\");\n        }\n\n\t\tString siteId = (String) params.get(\"siteId\");\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" + siteId);\n        }\n\n\t\tboolean isMessageToConnection = \"true\".equals(params.get(\"isMessageToConnection\"));\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"isMessageToConnection: \" + isMessageToConnection);\n        }\n\n        // Sakai plays the role of signalling server in the WebRTC architecture.\n\t\tboolean isVideoSignal = \"true\".equals(params.get(\"video\"));\n\n\t\tfinal UserMessage lastHeartbeat = heartbeatMap.get(to);\n\t\t\n\t\tif (lastHeartbeat == null || ((new Date()).getTime() - lastHeartbeat.timestamp) >= pollInterval) {\n            // If this is not a video signal, send a message via the profile's\n            // messaging function\n            if (!isVideoSignal) {\n                profileMessagingLogic.sendNewMessage(to,currentUser.getId(), UUID.randomUUID().toString(), rb.getString(\"profile_message_subject\"), message);\n            }\n            logger.debug(\"returning OFFLINE ...\");\n\t\t\treturn \"OFFLINE\";\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"message: \" + message);\n            logger.debug(\"isVideoSignal: \" + isVideoSignal);\n        }\n\t\t\n\t\t// Sanitise the message. XSS attacks. Unescape single quotes. They are valid.\n\t\tif (!isVideoSignal) { \n\t\t\tmessage = StringEscapeUtils.escapeHtml4(\n\t\t\t\t\t\tStringEscapeUtils.escapeEcmaScript(message)).replaceAll(\"\\\\\\\\'\", \"'\");\n\t\t}\n\n\t\tfinal UserMessage userMessage = new UserMessage(currentUser.getId(), to, siteId, message, isVideoSignal, false, isMessageToConnection);\n\n\t\taddMessageToMap(userMessage);\n\t\t\n        if (clustered) {\n            try {\n            \tif (logger.isDebugEnabled()) {\n                    logger.debug(\"Sending \" + (isVideoSignal ? \"video signal \" : \"\") + \"message to cluster ...\");\n                }\n                Message msg = new Message(null, null, userMessage);\n            \tclusterChannel.send(msg);\n            } catch (Exception e) {\n                logger.error(\"Error sending JGroups message\", e);\n            }\n        }\n\t\t\n\t\treturn \"success\";\n\t}","commit_id":"6e81cad4cd2aa711c3f8acb353f10c2435a69e73","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@EntityCustomAction(action = \"ping\", viewKey = EntityView.VIEW_SHOW)\n\tpublic String handlePing(EntityReference ref) {\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tString userId = ref.getId();\n\t\t\n\t\ttry {\n\t\t\tString email = userDirectoryService.getUser(userId).getEmail();\n            new EmailSender(email, rb.getFormattedMessage(\"email.subject\", new String[]{service}), rb.getFormattedMessage(\"email.body\", new String[]{currentUser.getDisplayName(), service, portalUrl}));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EntityException(\"Failed to send email\",userId);\n\t\t}\n\t\t\n\t\treturn \"success\";\n\t}","id":11821,"modified_method":"@EntityCustomAction(action = \"ping\", viewKey = EntityView.VIEW_SHOW)\n\tpublic String handlePing(EntityReference ref) {\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tString userId = ref.getId();\n\t\t\n\t\ttry {\n\t\t\tString email = userDirectoryService.getUser(userId).getEmail();\n            new EmailSender(email, rb.getFormattedMessage(\"email.subject\", new String[]{service}), rb.getFormattedMessage(\"email.body\", new String[]{currentUser.getDisplayName(), service, portalUrl}));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EntityException(\"Failed to send email\",userId);\n\t\t}\n\t\t\n\t\treturn \"success\";\n\t}","commit_id":"6e81cad4cd2aa711c3f8acb353f10c2435a69e73","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * The JS client calls this to grab the latest data in one call. Connections, latest messages, online users\n     * and present users (in a site) are all returned in one lump of JSON. If the online parameter is supplied and\n     * true, a heartbeat is stamped for the sender as well.\n     */\n\t@EntityCustomAction(action = \"latestData\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleLatestData(EntityReference ref, Map<String,Object> params) {\n\t\t\n\t\tlogger.debug(\"handleLatestData\");\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t\t//return new HashMap<String,Object>(0);\n\t\t}\n\t\t\n\t\tString online = (String) params.get(\"online\");\n\t\tString videoAgent = (String) params.get(\"videoAgent\");\n\n\t\tString siteId = (String) params.get(\"siteId\");\n\t\tif (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" +  siteId);\n        }\n\t\t\n\t\tif (logger.isDebugEnabled()) logger.debug(\"online: \" + online);\n\t\t\n\t\tif (online != null && \"true\".equals(online)) {\n\t\t\t\n\t\t\tif (logger.isDebugEnabled()) logger.debug(currentUser.getEid() + \" is online. Stamping their heartbeat ...\");\n\t\t\t\n\t\t\tUserMessage userMessage = new UserMessage(currentUser.getId(), videoAgent);\n\t\t\theartbeatMap.put(currentUser.getId(), userMessage);\n\n            if (clustered) {\n            \t\n            \tlogger.debug(\"We are clustered. Propagating heartbeat ...\");\n            \t\n                Message msg = new Message(null, null, userMessage);\n                try {\n                    clusterChannel.send(msg);\n                    logger.debug(\"Heartbeat message sent.\");\n                } catch (Exception e) {\n                    logger.error(\"Error sending JGroups heartbeat message\", e);\n                }\n            }\n        } else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Removing them from the message map ...\");\n            }\n\n            synchronized (messageMap) {\n                messageMap.remove(currentUser.getId());\n            }\n\n\t        sendClearMessage(currentUser.getId());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Returning an empty data map ...\");\n            }\n\t\t\t\n            return new HashMap<String,Object>(0);\n        }\n\n        List<PortalChatUser> presentUsers = new ArrayList<PortalChatUser>();\n\t\t\n        if (siteId != null && siteId.length() > 0 && showSiteUsers) {\n\t\t\t// A site id has been specified, so we refresh our presence at the \n\t\t\t// location and retrieve the present users\n\t\t\tString location = siteId + \"-presence\";\n\t\t\tpresenceService.setPresence(location);\n\t\t\tList<User> presentSakaiUsers = presenceService.getPresentUsers(siteId + \"-presence\");\n\t\t\tpresentSakaiUsers.remove(currentUser);\n\t\t\tfor (User user : presentSakaiUsers) {\n\t\t\t\tUserMessage heartbeat = heartbeatMap.get(user.getId());\n\t\t\t\t// Flag this user as offline if they can't access portal chat\n\t\t\t\tboolean offline = !portalChatPermittedHelper.checkChatPermitted(user.getId());\n\t\t\t\tpresentUsers.add(new PortalChatUser(user.getId(), user.getDisplayName(), offline, heartbeatMap.get(user.getId()).content));\n\t\t\t}\n        }\n\t\t\n\t\tList<Person> connections = getConnectionsForUser(currentUser.getId());\n\t\t\n\t\tList<PortalChatUser> onlineConnections = new ArrayList<PortalChatUser>(connections.size());\n\t\t\n\t\tDate now = new Date();\n\t\t\n\t\tfor (Person person : connections) {\n\n            String uuid = person.getUuid();\n\t\t\t\n\t\t\tUserMessage lastHeartbeat = heartbeatMap.get(uuid);\n\t\t\t\n\t\t\tif (lastHeartbeat == null) continue;\n\t\t\t\n\t\t\tif ((now.getTime() - lastHeartbeat.timestamp) < pollInterval) {\n\t\t\t\tonlineConnections.add(new PortalChatUser(uuid, uuid, false, lastHeartbeat.content));\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<UserMessage> messages = new ArrayList<UserMessage>();\n\t\tList<UserMessage> videoMessages = new ArrayList<UserMessage>();\n\n\t\tString currentUserId = currentUser.getId();\n\t\t\n\t\tsynchronized (messageMap) {\n\t\t\tif (messageMap.containsKey(currentUserId)) {\n\t\t\t\t// Grab the type map for this user\n                Map<String, Map<String, List<UserMessage>>> typeMap = messageMap.get(currentUserId);\n\n\t\t\t\t// Now pull the plain and video messages for this site\n                messages = typeMap.get(PLAIN).get(siteId);\n                videoMessages = typeMap.get(VIDEO).get(siteId);\n\n\t\t\t\t// Now we can remove the messages for this site\n\t\t\t\ttypeMap.get(PLAIN).remove(siteId);\n\t\t\t\ttypeMap.get(VIDEO).remove(siteId);\n\t\t\t}\n\n            sendClearMessage(currentUserId);\n\t\t}\n\n\t\tMap<String,Object> data = new HashMap<String,Object>(4);\n\t\t\n\t\tdata.put(\"connections\", connections);\n\t\tdata.put(\"messages\", messages);\n\t\tdata.put(\"videoMessages\", videoMessages);\n\t\tdata.put(\"online\", onlineConnections);\n\t\tdata.put(\"showSiteUsers\", showSiteUsers);\n\t\tdata.put(\"presentUsers\", presentUsers);\n\t\tdata.put(\"connectionsAvailable\", true);\n\t\t\n\t\treturn data;\n\t}","id":11822,"modified_method":"/**\n     * The JS client calls this to grab the latest data in one call. Connections, latest messages, online users\n     * and present users (in a site) are all returned in one lump of JSON. If the online parameter is supplied and\n     * true, a heartbeat is stamped for the sender as well.\n     */\n\t@EntityCustomAction(action = \"latestData\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleLatestData(EntityReference ref, Map<String,Object> params) {\n\t\t\n\t\tlogger.debug(\"handleLatestData\");\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tString online = (String) params.get(\"online\");\n\t\tString videoAgent = (String) params.get(\"videoAgent\");\n\n\t\tString siteId = (String) params.get(\"siteId\");\n\t\tif (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" +  siteId);\n        }\n\t\t\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"online: \" + online);\n        }\n\t\t\n\t\tif (online != null && \"true\".equals(online)) {\n\t\t\t\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is online. Stamping their heartbeat ...\");\n            }\n\t\t\t\n\t\t\tUserMessage userMessage = new UserMessage(currentUser.getId(), videoAgent);\n\t\t\theartbeatMap.put(currentUser.getId(), userMessage);\n\n            if (clustered) {\n            \t\n            \tlogger.debug(\"We are clustered. Propagating heartbeat ...\");\n            \t\n                Message msg = new Message(null, null, userMessage);\n                try {\n                    clusterChannel.send(msg);\n                    logger.debug(\"Heartbeat message sent.\");\n                } catch (Exception e) {\n                    logger.error(\"Error sending JGroups heartbeat message\", e);\n                }\n            }\n        } else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Removing them from the message map ...\");\n            }\n\n            synchronized (messageMap) {\n                messageMap.remove(currentUser.getId());\n            }\n\n\t        sendClearMessage(currentUser.getId());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(currentUser.getEid() + \" is offline. Returning an empty data map ...\");\n            }\n\t\t\t\n            return new HashMap<String,Object>(0);\n        }\n\n        List<PortalChatUser> presentUsers = new ArrayList<PortalChatUser>();\n\t\t\n        if (siteId != null && siteId.length() > 0 && showSiteUsers) {\n\t\t\t// A site id has been specified, so we refresh our presence at the \n\t\t\t// location and retrieve the present users\n\t\t\tString location = siteId + \"-presence\";\n\t\t\tpresenceService.setPresence(location);\n\t\t\tList<User> presentSakaiUsers = presenceService.getPresentUsers(siteId + \"-presence\");\n\t\t\tpresentSakaiUsers.remove(currentUser);\n\t\t\tfor (User user : presentSakaiUsers) {\n\t\t\t\tUserMessage heartbeat = heartbeatMap.get(user.getId());\n\t\t\t\t// Flag this user as offline if they can't access portal chat\n\t\t\t\tboolean offline = !portalChatPermittedHelper.checkChatPermitted(user.getId());\n\t\t\t\tpresentUsers.add(new PortalChatUser(user.getId(), user.getDisplayName(), offline, heartbeatMap.get(user.getId()).content));\n\t\t\t}\n        }\n\t\t\n\t\tList<Person> connections = getConnectionsForUser(currentUser.getId());\n\t\t\n\t\tList<PortalChatUser> onlineConnections = new ArrayList<PortalChatUser>(connections.size());\n\t\t\n\t\tDate now = new Date();\n\t\t\n\t\tfor (Person person : connections) {\n\n            String uuid = person.getUuid();\n\t\t\t\n\t\t\tUserMessage lastHeartbeat = heartbeatMap.get(uuid);\n\t\t\t\n\t\t\tif (lastHeartbeat == null) continue;\n\t\t\t\n\t\t\tif ((now.getTime() - lastHeartbeat.timestamp) < pollInterval) {\n\t\t\t\tonlineConnections.add(new PortalChatUser(uuid, uuid, false, lastHeartbeat.content));\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<UserMessage> messages = new ArrayList<UserMessage>();\n\t\tList<UserMessage> videoMessages = new ArrayList<UserMessage>();\n\n\t\tString currentUserId = currentUser.getId();\n\t\t\n\t\tsynchronized (messageMap) {\n\t\t\tif (messageMap.containsKey(currentUserId)) {\n\t\t\t\t// Grab the type map for this user\n                Map<String, Map<String, List<UserMessage>>> typeMap = messageMap.get(currentUserId);\n\n                // Now pull the plain, video and connection messages for this site\n                messages = typeMap.get(PLAIN).get(siteId);\n                if (messages != null) {\n                    messages.addAll(typeMap.get(PLAIN).get(CONNECTION));\n                } else {\n                    messages = typeMap.get(PLAIN).get(CONNECTION);\n                }\n\n                videoMessages = typeMap.get(VIDEO).get(siteId);\n                if (videoMessages != null) {\n                    videoMessages.addAll(typeMap.get(VIDEO).get(CONNECTION));\n                } else {\n                    videoMessages = typeMap.get(VIDEO).get(CONNECTION);\n                }\n\n                messageMap.remove(currentUserId);\n\t\t\t}\n\n            sendClearMessage(currentUserId);\n\t\t}\n\n\t\tMap<String,Object> data = new HashMap<String,Object>(4);\n\t\t\n\t\tdata.put(\"connections\", connections);\n\t\tdata.put(\"messages\", messages);\n\t\tdata.put(\"videoMessages\", videoMessages);\n\t\tdata.put(\"online\", onlineConnections);\n\t\tdata.put(\"showSiteUsers\", showSiteUsers);\n\t\tdata.put(\"presentUsers\", presentUsers);\n\t\tdata.put(\"connectionsAvailable\", true);\n\t\t\n\t\treturn data;\n\t}","commit_id":"40d8e0394191e80d93255bc6cced2d9e8bee549d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@EntityCustomAction(action = \"servers\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleServers(EntityReference ref) {\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\n\t\tfinal Map<String,Object> data = new HashMap<String,Object>();\n\t\tdata.put(\"iceServers\", iceServers);\n\t\treturn data;\n\t}","id":11823,"modified_method":"@EntityCustomAction(action = \"servers\", viewKey = EntityView.VIEW_SHOW)\n\tpublic Map<String,Object> handleServers(EntityReference ref) {\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\n\t\tfinal Map<String,Object> data = new HashMap<String,Object>();\n\t\tdata.put(\"iceServers\", iceServers);\n\t\treturn data;\n\t}","commit_id":"40d8e0394191e80d93255bc6cced2d9e8bee549d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@EntityCustomAction(action = \"ping\", viewKey = EntityView.VIEW_SHOW)\n\tpublic String handlePing(EntityReference ref) {\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tString userId = ref.getId();\n\t\t\n\t\ttry {\n\t\t\tString email = userDirectoryService.getUser(userId).getEmail();\n            new EmailSender(email, rb.getFormattedMessage(\"email.subject\", new String[]{service}), rb.getFormattedMessage(\"email.body\", new String[]{currentUser.getDisplayName(), service, portalUrl}));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EntityException(\"Failed to send email\",userId);\n\t\t}\n\t\t\n\t\treturn \"success\";\n\t}","id":11824,"modified_method":"@EntityCustomAction(action = \"ping\", viewKey = EntityView.VIEW_SHOW)\n\tpublic String handlePing(EntityReference ref) {\n\n\t\tUser currentUser = userDirectoryService.getCurrentUser();\n\t\tUser anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tString userId = ref.getId();\n\t\t\n\t\ttry {\n\t\t\tString email = userDirectoryService.getUser(userId).getEmail();\n            new EmailSender(email, rb.getFormattedMessage(\"email.subject\", new String[]{service}), rb.getFormattedMessage(\"email.body\", new String[]{currentUser.getDisplayName(), service, portalUrl}));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EntityException(\"Failed to send email\",userId);\n\t\t}\n\t\t\n\t\treturn \"success\";\n\t}","commit_id":"40d8e0394191e80d93255bc6cced2d9e8bee549d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Implements a threadsafe addition to the message map\n     */\n    private void addMessageToMap(UserMessage m) {\n\n        synchronized (messageMap) {\n\n            if (!messageMap.containsKey(m.to)) {\n                Map<String, Map<String, List<UserMessage>>> typeMap = new HashMap<String, Map<String, List<UserMessage>>>();\n                typeMap.put(PLAIN, new HashMap<String, List<UserMessage>>());\n                typeMap.get(PLAIN).put(m.siteId, new ArrayList<UserMessage>());\n                typeMap.put(VIDEO, new HashMap<String, List<UserMessage>>());\n                typeMap.get(VIDEO).put(m.siteId, new ArrayList<UserMessage>());\n                messageMap.put(m.to, typeMap);\n            }\n\n            if (m.video) {\n                Map<String, List<UserMessage>> siteMap = messageMap.get(m.to).get(VIDEO);\n\n                if (siteMap.containsKey(m.siteId)) {\n                    siteMap.get(m.siteId).add(m);\n                } else {\n                    siteMap.put(m.siteId, Arrays.asList(m));\n                }\n            } else {\n                Map<String, List<UserMessage>> siteMap = messageMap.get(m.to).get(PLAIN);\n\n                if (siteMap.containsKey(m.siteId)) {\n                    siteMap.get(m.siteId).add(m);\n                } else {\n                    siteMap.put(m.siteId, Arrays.asList(m));\n                }\n            }\n\n        }\n    }","id":11825,"modified_method":"/**\n     * Implements a threadsafe addition to the message map\n     */\n    private void addMessageToMap(UserMessage m) {\n\n        synchronized (messageMap) {\n\n            if (!messageMap.containsKey(m.to)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"No message map entry for '\" + m.to + \"'. Creating new entries ...\");\n                }\n                Map<String, Map<String, List<UserMessage>>> typeMap = new HashMap<String, Map<String, List<UserMessage>>>();\n                typeMap.put(PLAIN, new HashMap<String, List<UserMessage>>());\n                typeMap.get(PLAIN).put(m.siteId, new ArrayList<UserMessage>());\n                typeMap.get(PLAIN).put(CONNECTION, new ArrayList<UserMessage>());\n                typeMap.put(VIDEO, new HashMap<String, List<UserMessage>>());\n                typeMap.get(VIDEO).put(m.siteId, new ArrayList<UserMessage>());\n                typeMap.get(VIDEO).put(CONNECTION, new ArrayList<UserMessage>());\n                messageMap.put(m.to, typeMap);\n            }\n\n            if (m.video) {\n                logger.debug(\"Message is a video message\");\n                Map<String, List<UserMessage>> videoMap = messageMap.get(m.to).get(VIDEO);\n\n                if (m.fromConnection) {\n                    videoMap.get(CONNECTION).add(m);\n                } else if (videoMap.containsKey(m.siteId)) {\n                    videoMap.get(m.siteId).add(m);\n                } else {\n                    videoMap.put(m.siteId, Arrays.asList(m));\n                }\n            } else {\n                logger.debug(\"Message is a plain message\");\n                Map<String, List<UserMessage>> plainMap = messageMap.get(m.to).get(PLAIN);\n\n                if (m.fromConnection) {\n                    plainMap.get(CONNECTION).add(m);\n                } else if (plainMap.containsKey(m.siteId)) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"plainMap already contains '\" + m.siteId + \"'\");\n                    }\n                    plainMap.get(m.siteId).add(m);\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"plainMap does not contain '\" + m.siteId + \"'. A new list will be mapped\");\n                    }\n                    plainMap.put(m.siteId, Arrays.asList(m));\n                }\n            }\n        }\n    }","commit_id":"40d8e0394191e80d93255bc6cced2d9e8bee549d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * New messages come in here. The recipient is indicated by the parameter 'to'.\n     */\n\tpublic String createEntity(EntityReference ref, Object entity, Map<String, Object> params) {\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tfinal String to = (String) params.get(\"to\");\n\t\tif (to == null) throw new IllegalArgumentException(\"You must supply a recipient\");\n\t\t\n\t\tif (to.equals(currentUser.getId())) {\n\t\t\tthrow new IllegalArgumentException(\"You can't chat with yourself\");\n\t\t}\n\t\t\n\t\tString message = (String) params.get(\"message\");\n\n\t\tif (message == null) {\n            throw new IllegalArgumentException(\"You must supply a message\");\n        }\n\n\t\tString siteId = (String) params.get(\"siteId\");\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" + siteId);\n        }\n\n\t\tboolean isMessageToConnection = \"true\".equals(params.get(\"isMessageToConnection\"));\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"isMessageToConnection: \" + isMessageToConnection);\n        }\n\n        // Sakai plays the role of signalling server in the WebRTC architecture.\n\t\tboolean isVideoSignal = \"true\".equals(params.get(\"video\"));\n\n\t\tfinal UserMessage lastHeartbeat = heartbeatMap.get(to);\n\t\t\n\t\tif (lastHeartbeat == null || ((new Date()).getTime() - lastHeartbeat.timestamp) >= pollInterval) {\n            // If this is not a video signal, send a message via the profile's\n            // messaging function\n            if (!isVideoSignal) {\n                profileMessagingLogic.sendNewMessage(to,currentUser.getId(), UUID.randomUUID().toString(), rb.getString(\"profile_message_subject\"), message);\n            }\n\t\t\treturn \"OFFLINE\";\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"message: \" + message);\n            logger.debug(\"isVideoSignal: \" + isVideoSignal);\n        }\n\t\t\n\t\t// Sanitise the message. XSS attacks. Unescape single quotes. They are valid.\n\t\tif (!isVideoSignal) { \n\t\t\tmessage = StringEscapeUtils.escapeHtml4(\n\t\t\t\t\t\tStringEscapeUtils.escapeEcmaScript(message)).replaceAll(\"\\\\\\\\'\", \"'\");\n\t\t}\n\n\t\tfinal UserMessage userMessage = new UserMessage(currentUser.getId(), to, siteId, message, isVideoSignal, false, isMessageToConnection);\n\n\t\taddMessageToMap(userMessage);\n\t\t\n        if (clustered) {\n            try {\n            \tif (logger.isDebugEnabled()) {\n                    logger.debug(\"Sending \" + (isVideoSignal ? \"video signal \" : \"\") + \"message to cluster ...\");\n                }\n                Message msg = new Message(null, null, userMessage);\n            \tclusterChannel.send(msg);\n            } catch (Exception e) {\n                logger.error(\"Error sending JGroups message\", e);\n            }\n        }\n\t\t\n\t\treturn \"success\";\n\t}","id":11826,"modified_method":"/**\n     * New messages come in here. The recipient is indicated by the parameter 'to'.\n     */\n\tpublic String createEntity(EntityReference ref, Object entity, Map<String, Object> params) {\n\n        logger.debug(\"createEntity\");\n\n\t\tfinal User currentUser = userDirectoryService.getCurrentUser();\n\t\tfinal User anon = userDirectoryService.getAnonymousUser();\n\t\t\n\t\tif (anon.equals(currentUser)) {\n            logger.debug(\"No current user\");\n\t\t\tthrow new SecurityException(\"You must be logged in to use this service\");\n\t\t}\n\t\t\n\t\tfinal String to = (String) params.get(\"to\");\n        if (to == null) {\n            logger.debug(\"No recipient\");\n            throw new IllegalArgumentException(\"You must supply a recipient\");\n        }\n\t\t\n\t\tif (to.equals(currentUser.getId())) {\n            logger.debug(\"recipient is sender\");\n\t\t\tthrow new IllegalArgumentException(\"You can't chat with yourself\");\n\t\t}\n\t\t\n\t\tString message = (String) params.get(\"message\");\n\n\t\tif (message == null) {\n            logger.debug(\"no message supplied\");\n            throw new IllegalArgumentException(\"You must supply a message\");\n        }\n\n\t\tString siteId = (String) params.get(\"siteId\");\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"siteId: \" + siteId);\n        }\n\n\t\tboolean isMessageToConnection = \"true\".equals(params.get(\"isMessageToConnection\"));\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"isMessageToConnection: \" + isMessageToConnection);\n        }\n\n        // Sakai plays the role of signalling server in the WebRTC architecture.\n\t\tboolean isVideoSignal = \"true\".equals(params.get(\"video\"));\n\n\t\tfinal UserMessage lastHeartbeat = heartbeatMap.get(to);\n\t\t\n\t\tif (lastHeartbeat == null || ((new Date()).getTime() - lastHeartbeat.timestamp) >= pollInterval) {\n            // If this is not a video signal, send a message via the profile's\n            // messaging function\n            if (!isVideoSignal) {\n                profileMessagingLogic.sendNewMessage(to,currentUser.getId(), UUID.randomUUID().toString(), rb.getString(\"profile_message_subject\"), message);\n            }\n            logger.debug(\"returning OFFLINE ...\");\n\t\t\treturn \"OFFLINE\";\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"message: \" + message);\n            logger.debug(\"isVideoSignal: \" + isVideoSignal);\n        }\n\t\t\n\t\t// Sanitise the message. XSS attacks. Unescape single quotes. They are valid.\n\t\tif (!isVideoSignal) { \n\t\t\tmessage = StringEscapeUtils.escapeHtml4(\n\t\t\t\t\t\tStringEscapeUtils.escapeEcmaScript(message)).replaceAll(\"\\\\\\\\'\", \"'\");\n\t\t}\n\n\t\tfinal UserMessage userMessage = new UserMessage(currentUser.getId(), to, siteId, message, isVideoSignal, false, isMessageToConnection);\n\n\t\taddMessageToMap(userMessage);\n\t\t\n        if (clustered) {\n            try {\n            \tif (logger.isDebugEnabled()) {\n                    logger.debug(\"Sending \" + (isVideoSignal ? \"video signal \" : \"\") + \"message to cluster ...\");\n                }\n                Message msg = new Message(null, null, userMessage);\n            \tclusterChannel.send(msg);\n            } catch (Exception e) {\n                logger.error(\"Error sending JGroups message\", e);\n            }\n        }\n\t\t\n\t\treturn \"success\";\n\t}","commit_id":"40d8e0394191e80d93255bc6cced2d9e8bee549d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List<SNode> getNodes(SNode node) {\n    return ListSequence.fromListAndArray(new ArrayList<SNode>(), getNode(node));\n  }","id":11827,"modified_method":"public List<SNode> getNodes(SNode node) {\n    List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());\n    SNode n = getNode(node);\n    if (n == null) {\n      return list;\n    }\n    ListSequence.fromList(list).addElement(n);\n    return list;\n  }","commit_id":"4e7703763486527e131a459b134130cb2fe587d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getNodes(SNode node) {\n    return ListSequence.fromListAndArray(new ArrayList<SNode>(), getNode(node));\n  }","id":11828,"modified_method":"public List<SNode> getNodes(SNode node) {\n    List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());\n    SNode n = getNode(node);\n    if (n == null) {\n      return list;\n    }\n    ListSequence.fromList(list).addElement(n);\n    return list;\n  }","commit_id":"4e7703763486527e131a459b134130cb2fe587d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getNodes(SNode node) {\n    return ListSequence.fromListAndArray(new ArrayList<SNode>(), getNode(node));\n  }","id":11829,"modified_method":"public List<SNode> getNodes(SNode node) {\n    List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());\n    SNode n = getNode(node);\n    if (n == null) {\n      return list;\n    }\n    ListSequence.fromList(list).addElement(n);\n    return list;\n  }","commit_id":"4e7703763486527e131a459b134130cb2fe587d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getNodes(SNode node) {\n    return ListSequence.fromListAndArray(new ArrayList<SNode>(), getNode(node));\n  }","id":11830,"modified_method":"public List<SNode> getNodes(SNode node) {\n    List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());\n    SNode n = getNode(node);\n    if (n == null) {\n      return list;\n    }\n    ListSequence.fromList(list).addElement(n);\n    return list;\n  }","commit_id":"4e7703763486527e131a459b134130cb2fe587d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getNodes(SNode node) {\n    return ListSequence.fromListAndArray(new ArrayList<SNode>(), getNode(node));\n  }","id":11831,"modified_method":"public List<SNode> getNodes(SNode node) {\n    List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());\n    SNode n = getNode(node);\n    if (n == null) {\n      return list;\n    }\n    ListSequence.fromList(list).addElement(n);\n    return list;\n  }","commit_id":"4e7703763486527e131a459b134130cb2fe587d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getNodes(SNode node) {\n    return ListSequence.fromListAndArray(new ArrayList<SNode>(), getNode(node));\n  }","id":11832,"modified_method":"public List<SNode> getNodes(SNode node) {\n    List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());\n    SNode n = getNode(node);\n    if (n == null) {\n      return list;\n    }\n    ListSequence.fromList(list).addElement(n);\n    return list;\n  }","commit_id":"4e7703763486527e131a459b134130cb2fe587d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getNodes(SNode node) {\n    return ListSequence.fromListAndArray(new ArrayList<SNode>(), getNode(node));\n  }","id":11833,"modified_method":"public List<SNode> getNodes(SNode node) {\n    List<SNode> list = ListSequence.fromList(new ArrayList<SNode>());\n    SNode n = getNode(node);\n    if (n == null) {\n      return list;\n    }\n    ListSequence.fromList(list).addElement(n);\n    return list;\n  }","commit_id":"4e7703763486527e131a459b134130cb2fe587d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void paintComponent(Graphics g) {\n    if (myPaintingBgNow) return;\n\n    if ((myAnimator.isRunning() || myPaintPassive || (myLastPaintWasRunning && !myAnimator.isRunning()))) {\n      Rectangle b = getBounds();\n\n      if (!isOpaque()) {\n        try {\n          myPaintingBgNow = true;\n          Container p = getParent();\n          if (p instanceof JComponent) {\n            JComponent parentComponent = (JComponent)p;\n            RepaintManager.currentManager(p).addDirtyRegion(parentComponent, b.x, b.y, b.width, b.height);\n          }\n        }\n        finally {\n          myPaintingBgNow = false;\n        }\n      } else {\n        Container parent = getParent();\n        if (parent instanceof JComponent) {\n          final Component opaque = UIUtil.findNearestOpaque((JComponent)parent);\n          if (opaque != null) {\n            g.setColor(opaque.getBackground());\n            g.fillRect(b.x, b.y, b.width, b.height);\n          }\n        }\n      }\n\n    }\n\n    Icon icon;\n\n    if (myAnimator.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = getPassiveIcon();\n    }\n\n    final Dimension size = getSize();\n    int x = (size.width - icon.getIconWidth()) / 2;\n    int y = (size.height - icon.getIconHeight()) / 2;\n\n    paintIcon(g, icon, x, y);\n\n    myLastPaintWasRunning = myAnimator.isRunning();\n  }","id":11834,"modified_method":"protected void paintComponent(Graphics g) {\n    if (myPaintingBgNow) return;\n\n    if (isOpaque()) {\n      final Container parent = getParent();\n      JComponent opaque = null;\n      if (parent instanceof JComponent) {\n        opaque = (JComponent)UIUtil.findNearestOpaque((JComponent)parent);\n      }\n      Color bg = opaque != null ? opaque.getBackground() : UIManager.getColor(\"Panel.background\");\n      g.setColor(bg);\n      g.fillRect(0, 0, getWidth(), getHeight());\n    } \n\n    Icon icon;\n\n    if (myAnimator.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = getPassiveIcon();\n    }\n\n    final Dimension size = getSize();\n    int x = (size.width - icon.getIconWidth()) / 2;\n    int y = (size.height - icon.getIconHeight()) / 2;\n\n    paintIcon(g, icon, x, y);\n\n    myLastPaintWasRunning = myAnimator.isRunning();\n  }","commit_id":"f21f8713c0a20c7255f7712828bf31b2f48495e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void paintComponent(Graphics g) {\n    if (myPaintingBgNow) return;\n\n    if (isOpaque()) {\n      final Container parent = getParent();\n      JComponent opaque = null;\n      if (parent instanceof JComponent) {\n        opaque = (JComponent)UIUtil.findNearestOpaque((JComponent)parent);\n      }\n      Color bg = opaque != null ? opaque.getBackground() : UIManager.getColor(\"Panel.background\");\n      g.setColor(bg);\n      g.fillRect(0, 0, getWidth(), getHeight());\n    } \n\n    Icon icon;\n\n    if (myAnimator.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = getPassiveIcon();\n    }\n\n    final Dimension size = getSize();\n    int x = (size.width - icon.getIconWidth()) / 2;\n    int y = (size.height - icon.getIconHeight()) / 2;\n\n    paintIcon(g, icon, x, y);\n\n    myLastPaintWasRunning = myAnimator.isRunning();\n  }","id":11835,"modified_method":"protected void paintComponent(Graphics g) {\n    if (myPaintingBgNow) return;\n\n    if ((myAnimator.isRunning() || myPaintPassive || (myLastPaintWasRunning && !myAnimator.isRunning()))) {\n      Rectangle b = getBounds();\n\n      if (!isOpaque()) {\n        try {\n          myPaintingBgNow = true;\n          Container p = getParent();\n          if (p instanceof JComponent) {\n            JComponent parentComponent = (JComponent)p;\n            RepaintManager.currentManager(p).addDirtyRegion(parentComponent, b.x, b.y, b.width, b.height);\n          }\n        }\n        finally {\n          myPaintingBgNow = false;\n        }\n      } else {\n        Container parent = getParent();\n        if (parent instanceof JComponent) {\n          final Component opaque = UIUtil.findNearestOpaque((JComponent)parent);\n          if (opaque != null) {\n            g.setColor(opaque.getBackground());\n            g.fillRect(b.x, b.y, b.width, b.height);\n          }\n        }\n      }\n\n    }\n\n    Icon icon;\n\n    if (myAnimator.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = getPassiveIcon();\n    }\n\n    final Dimension size = getSize();\n    int x = (size.width - icon.getIconWidth()) / 2;\n    int y = (size.height - icon.getIconHeight()) / 2;\n\n    paintIcon(g, icon, x, y);\n\n    myLastPaintWasRunning = myAnimator.isRunning();\n  }","commit_id":"5a8cf4a5c40ab15c49958f6e52ae3152897e4e2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void paintComponent(Graphics g) {\n    if (myPaintingBgNow) return;\n\n    if ((myAnimator.isRunning() || myPaintPassive || (myLastPaintWasRunning && !myAnimator.isRunning()))) {\n      Rectangle b = getBounds();\n\n      if (!isOpaque()) {\n        try {\n          myPaintingBgNow = true;\n          Container p = getParent();\n          if (p instanceof JComponent) {\n            JComponent parentComponent = (JComponent)p;\n            RepaintManager.currentManager(p).addDirtyRegion(parentComponent, b.x, b.y, b.width, b.height);\n          }\n        }\n        finally {\n          myPaintingBgNow = false;\n        }\n      } else {\n        Container parent = getParent();\n        if (parent instanceof JComponent) {\n          final Component opaque = UIUtil.findNearestOpaque((JComponent)parent);\n          if (opaque != null) {\n            g.setColor(opaque.getBackground());\n            g.fillRect(b.x, b.y, b.width, b.height);\n          }\n        }\n      }\n\n    }\n\n    Icon icon;\n\n    if (myAnimator.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = getPassiveIcon();\n    }\n\n    final Dimension size = getSize();\n    int x = (size.width - icon.getIconWidth()) / 2;\n    int y = (size.height - icon.getIconHeight()) / 2;\n\n    paintIcon(g, icon, x, y);\n\n    myLastPaintWasRunning = myAnimator.isRunning();\n  }","id":11836,"modified_method":"protected void paintComponent(Graphics g) {\n    if (myPaintingBgNow) return;\n\n    if (isOpaque()) {\n      final Container parent = getParent();\n      JComponent opaque = null;\n      if (parent instanceof JComponent) {\n        opaque = (JComponent)UIUtil.findNearestOpaque((JComponent)parent);\n      }\n      Color bg = opaque != null ? opaque.getBackground() : UIManager.getColor(\"Panel.background\");\n      g.setColor(bg);\n      g.fillRect(0, 0, getWidth(), getHeight());\n    } \n\n    Icon icon;\n\n    if (myAnimator.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = getPassiveIcon();\n    }\n\n    final Dimension size = getSize();\n    int x = (size.width - icon.getIconWidth()) / 2;\n    int y = (size.height - icon.getIconHeight()) / 2;\n\n    paintIcon(g, icon, x, y);\n\n    myLastPaintWasRunning = myAnimator.isRunning();\n  }","commit_id":"bd36aa4f8d205b772a67963cf1d419355ebd4f86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean match(NodePath other) {\n        if (isQNameIndex)\n            return other.getLastComponent().equalsSimple(path.getLastComponent());\n        return path.match(other);\n    }","id":11837,"modified_method":"@Override\n    public boolean match(NodePath other) {\n        if (isQNameIndex) {\n            final QName qn1 = path.getLastComponent();\n            final QName qn2 = other.getLastComponent();\n            return qn1.getNameType() == qn2.getNameType() && qn2.equalsSimple(qn1);\n        }\n        return path.match(other);\n    }","commit_id":"d1337e97dcf1fb0a39726a49f3ce7b09a8446a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean match(NodePath other) {\n    \tif (isQNameIndex)\n    \t\treturn other.getLastComponent().equalsSimple(path.getLastComponent());\n        return path.match(other);\n    }","id":11838,"modified_method":"public boolean match(NodePath other) {\n        if (isQNameIndex) {\n            final QName qn1 = path.getLastComponent();\n            final QName qn2 = other.getLastComponent();\n            return qn1.getNameType() == qn2.getNameType() && qn2.equalsSimple(qn1);\n        }\n        return path.match(other);\n    }","commit_id":"d1337e97dcf1fb0a39726a49f3ce7b09a8446a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean match(NodePath other) {\n        if (isQNameIndex)\n            return other.getLastComponent().equalsSimple(path.getLastComponent());\n        return other.match(path);\n    }","id":11839,"modified_method":"public boolean match(NodePath other) {\n        if (isQNameIndex) {\n            final QName qn1 = path.getLastComponent();\n            final QName qn2 = other.getLastComponent();\n            return qn1.getNameType() == qn2.getNameType() && qn2.equalsSimple(qn1);\n        }\n        return other.match(path);\n    }","commit_id":"d1337e97dcf1fb0a39726a49f3ce7b09a8446a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    if (getAnswerPlaceholder(e) == null) {\n      e.getPresentation().setEnabledAndVisible(false);\n    }\n  }","id":11840,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    Presentation presentation = e.getPresentation();\n    presentation.setEnabledAndVisible(false);\n    Project project = e.getProject();\n    if (project == null) {\n      return;\n    }\n    Course course = StudyTaskManager.getInstance(project).getCourse();\n    if (course == null) {\n      return;\n    }\n\n    if (!EduNames.STUDY.equals(course.getCourseMode())) {\n      presentation.setVisible(true);\n      return;\n    }\n\n    if (getAnswerPlaceholder(e) == null) {\n      presentation.setEnabledAndVisible(false);\n    }\n  }","commit_id":"073bc1508598350798def8f80a52333dc0af5d30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent event) {\n    StudyUtils.updateAction(event);\n    final Project project = event.getProject();\n    if (project != null) {\n      StudyEditor studyEditor = StudyUtils.getSelectedStudyEditor(project);\n      StudyState studyState = new StudyState(studyEditor);\n      if (!studyState.isValid()) {\n        event.getPresentation().setEnabled(false);\n      }\n    }\n  }","id":11841,"modified_method":"@Override\n  public void update(AnActionEvent event) {\n    StudyUtils.updateAction(event);\n    final Project project = event.getProject();\n    if (project != null) {\n      StudyEditor studyEditor = StudyUtils.getSelectedStudyEditor(project);\n      StudyState studyState = new StudyState(studyEditor);\n      Presentation presentation = event.getPresentation();\n      if (!studyState.isValid()) {\n        presentation.setEnabled(false);\n        return;\n      }\n\n      Course course = StudyTaskManager.getInstance(project).getCourse();\n      if (course == null) {\n        return;\n      }\n      if (!EduNames.STUDY.equals(course.getCourseMode())) {\n        presentation.setVisible(true);\n        presentation.setEnabled(false);\n      }\n    }\n  }","commit_id":"073bc1508598350798def8f80a52333dc0af5d30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    e.getPresentation().setEnabled(project != null);\n  }","id":11842,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    final Presentation p = e.getPresentation();\n    if (project == null) {\n      p.setVisible(false);\n      p.setEnabled(false);\n      return;\n    }\n\n    if (ApplicationManagerEx.getApplicationEx().isInternal()) {\n      p.setVisible(true);\n      p.setEnabled(true);\n      return;\n    }\n\n    final Module[] modules = ModuleManager.getInstance(project).getModules();\n    for (Module module : modules) {\n      if (\"PLUGIN_MODULE\".equals(ModuleType.get(module).getId())) {\n        p.setVisible(true);\n        p.setEnabled(true);\n        return;\n      }\n    }\n    \n    p.setVisible(false);\n    p.setEnabled(false);\n  }","commit_id":"16cade3831576ae41e57a90ca760c83d40c82193","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    e.getPresentation().setEnabled(project != null);\n  }","id":11843,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    final Presentation p = e.getPresentation();\n    if (project == null) {\n      p.setVisible(false);\n      p.setEnabled(false);\n      return;\n    }\n\n    if (ApplicationManagerEx.getApplicationEx().isInternal()) {\n      p.setVisible(true);\n      p.setEnabled(true);\n      return;\n    }\n\n    final Module[] modules = ModuleManager.getInstance(project).getModules();\n    for (Module module : modules) {\n      if (\"PLUGIN_MODULE\".equals(ModuleType.get(module).getId())) {\n        p.setVisible(true);\n        p.setEnabled(true);\n        return;\n      }\n    }\n    \n    p.setVisible(false);\n    p.setEnabled(false);\n  }","commit_id":"82e02f7e0c8b27bd8944c05ffe06f7cb1cbb1541","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11844,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11845,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                doubles[i++] = values[loc];\n            }\n        }\n        return doubles;\n    }","id":11846,"modified_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        for (int i = 0; i < length; i++) {\n            doubles[i] = values[ordinals[i][docId]];\n        }\n        return doubles;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, Byte.toString(values[loc]));\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11847,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, Byte.toString(values[loc]));\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public byte[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        byte[] bytes;\n        if (length < VALUE_CACHE_SIZE) {\n            bytes = valuesCache.get().get()[length];\n        } else {\n            bytes = new byte[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                bytes[i++] = values[loc];\n            }\n        }\n        return bytes;\n    }","id":11848,"modified_method":"@Override\n    public byte[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        byte[] bytes;\n        if (length < VALUE_CACHE_SIZE) {\n            bytes = valuesCache.get().get()[length];\n        } else {\n            bytes = new byte[length];\n        }\n        for (int i = 0; i < length; i++) {\n            bytes[i] = values[ordinals[i][docId]];\n        }\n        return bytes;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onOrdinal(docId, loc);\n            }\n        }\n        if (!found) {\n            proc.onOrdinal(docId, 0);\n        }\n    }","id":11849,"modified_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onOrdinal(docId, 0);\n                }\n                break;\n            }\n            proc.onOrdinal(docId, loc);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11850,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11851,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11852,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, Double.toString(values[loc]));\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11853,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, Double.toString(values[loc]));\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11854,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11855,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, (long) values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11856,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, (long) values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public double[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = valuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                doubles[i++] = values[loc];\n            }\n        }\n        return doubles;\n    }","id":11857,"modified_method":"@Override\n    public double[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = valuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        for (int i = 0; i < length; i++) {\n            doubles[i] = values[ordinals[i][docId]];\n        }\n        return doubles;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, (long) values[loc]);\n            }\n        }\n    }","id":11858,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, (long) values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11859,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onOrdinal(docId, loc);\n            }\n        }\n        if (!found) {\n            proc.onOrdinal(docId, 0);\n        }\n    }","id":11860,"modified_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onOrdinal(docId, 0);\n                }\n                break;\n            }\n            proc.onOrdinal(docId, loc);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public float[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        float[] floats;\n        if (length < VALUE_CACHE_SIZE) {\n            floats = valuesCache.get().get()[length];\n        } else {\n            floats = new float[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                floats[i++] = values[loc];\n            }\n        }\n        return floats;\n    }","id":11861,"modified_method":"@Override\n    public float[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        float[] floats;\n        if (length < VALUE_CACHE_SIZE) {\n            floats = valuesCache.get().get()[length];\n        } else {\n            floats = new float[length];\n        }\n        for (int i = 0; i < length; i++) {\n            floats[i] = values[ordinals[i][docId]];\n        }\n        return floats;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, (long) values[loc]);\n            }\n        }\n    }","id":11862,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, (long) values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, Float.toString(values[loc]));\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11863,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, Double.toString(values[loc]));\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11864,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onOrdinal(docId, loc);\n            }\n        }\n        if (!found) {\n            proc.onOrdinal(docId, 0);\n        }\n    }","id":11865,"modified_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onOrdinal(docId, 0);\n                }\n                break;\n            }\n            proc.onOrdinal(docId, loc);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, (long) values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11866,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, (long) values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                doubles[i++] = values[loc];\n            }\n        }\n        return doubles;\n    }","id":11867,"modified_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        for (int i = 0; i < length; i++) {\n            doubles[i] = values[ordinals[i][docId]];\n        }\n        return doubles;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11868,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11869,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public double[] lonValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = valuesLonCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                doubles[i++] = lon[loc];\n            }\n        }\n        return doubles;\n    }","id":11870,"modified_method":"@Override\n    public double[] lonValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = valuesLonCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        for (int i = 0; i < length; i++) {\n            doubles[i] = lon[ordinals[i][docId]];\n        }\n        return doubles;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public double[] latValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = valuesLatCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                doubles[i++] = lat[loc];\n            }\n        }\n        return doubles;\n    }","id":11871,"modified_method":"@Override\n    public double[] latValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = valuesLatCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        for (int i = 0; i < length; i++) {\n            doubles[i] = lat[ordinals[i][docId]];\n        }\n        return doubles;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, lat[loc], lon[loc]);\n            }\n        }\n    }","id":11872,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, lat[loc], lon[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onOrdinal(docId, loc);\n            }\n        }\n        if (!found) {\n            proc.onOrdinal(docId, 0);\n        }\n    }","id":11873,"modified_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onOrdinal(docId, 0);\n                }\n                break;\n            }\n            proc.onOrdinal(docId, loc);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public GeoPoint[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        GeoPoint[] points;\n        if (length < VALUE_CACHE_SIZE) {\n            points = valuesArrayCache.get().get()[length];\n            int i = 0;\n            for (int[] ordinal : ordinals) {\n                int loc = ordinal[docId];\n                if (loc != 0) {\n                    points[i++].latlon(lat[loc], lon[loc]);\n                }\n            }\n        } else {\n            points = new GeoPoint[length];\n            int i = 0;\n            for (int[] ordinal : ordinals) {\n                int loc = ordinal[docId];\n                if (loc != 0) {\n                    points[i++] = new GeoPoint(lat[loc], lon[loc]);\n                }\n            }\n        }\n        return points;\n    }","id":11874,"modified_method":"@Override\n    public GeoPoint[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        GeoPoint[] points;\n        if (length < VALUE_CACHE_SIZE) {\n            points = valuesArrayCache.get().get()[length];\n            for (int i = 0; i < length; i++) {\n                int loc = ordinals[i][docId];\n                points[i].latlon(lat[loc], lon[loc]);\n            }\n        } else {\n            points = new GeoPoint[length];\n            for (int i = 0; i < length; i++) {\n                int loc = ordinals[i][docId];\n                points[i] = new GeoPoint(lat[loc], lon[loc]);\n            }\n        }\n        return points;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, GeoHashUtils.encode(lat[loc], lon[loc]));\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11875,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, GeoHashUtils.encode(lat[loc], lon[loc]));\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                doubles[i++] = values[loc];\n            }\n        }\n        return doubles;\n    }","id":11876,"modified_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        for (int i = 0; i < length; i++) {\n            doubles[i] = values[ordinals[i][docId]];\n        }\n        return doubles;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11877,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11878,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11879,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public int[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        int[] ints;\n        if (length < VALUE_CACHE_SIZE) {\n            ints = valuesCache.get().get()[length];\n        } else {\n            ints = new int[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                ints[i++] = values[loc];\n            }\n        }\n        return ints;\n    }","id":11880,"modified_method":"@Override\n    public int[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        int[] ints;\n        if (length < VALUE_CACHE_SIZE) {\n            ints = valuesCache.get().get()[length];\n        } else {\n            ints = new int[length];\n        }\n        for (int i = 0; i < length; i++) {\n            ints[i] = values[ordinals[i][docId]];\n        }\n        return ints;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, Integer.toString(values[loc]));\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11881,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, Integer.toString(values[loc]));\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11882,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11883,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onOrdinal(docId, loc);\n            }\n        }\n        if (!found) {\n            proc.onOrdinal(docId, 0);\n        }\n    }","id":11884,"modified_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onOrdinal(docId, 0);\n                }\n                break;\n            }\n            proc.onOrdinal(docId, loc);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11885,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingDoubleValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                doubles[i++] = values[loc];\n            }\n        }\n        return doubles;\n    }","id":11886,"modified_method":"@Override\n    public double[] doubleValues(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return DoubleFieldData.EMPTY_DOUBLE_ARRAY;\n        }\n        double[] doubles;\n        if (length < VALUE_CACHE_SIZE) {\n            doubles = doublesValuesCache.get().get()[length];\n        } else {\n            doubles = new double[length];\n        }\n        for (int i = 0; i < length; i++) {\n            doubles[i] = values[ordinals[i][docId]];\n        }\n        return doubles;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MutableDateTime dateTime, DateValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                dateTime.setMillis(values[loc]);\n                proc.onValue(docId, dateTime);\n            }\n        }\n    }","id":11887,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MutableDateTime dateTime, DateValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            dateTime.setMillis(values[loc]);\n            proc.onValue(docId, dateTime);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, DateValueInDocProc proc) {\n        MutableDateTime dateTime = dateTimeCache.get().get();\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                dateTime.setMillis(values[loc]);\n                proc.onValue(docId, dateTime);\n            }\n        }\n    }","id":11888,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, DateValueInDocProc proc) {\n        MutableDateTime dateTime = dateTimeCache.get().get();\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            dateTime.setMillis(values[loc]);\n            proc.onValue(docId, dateTime);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onOrdinal(docId, loc);\n            }\n        }\n        if (!found) {\n            proc.onOrdinal(docId, 0);\n        }\n    }","id":11889,"modified_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onOrdinal(docId, 0);\n                }\n                break;\n            }\n            proc.onOrdinal(docId, loc);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11890,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, MissingLongValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public long[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        long[] longs;\n        if (length < VALUE_CACHE_SIZE) {\n            longs = valuesCache.get().get()[length];\n        } else {\n            longs = new long[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                longs[i++] = values[loc];\n            }\n        }\n        return longs;\n    }","id":11891,"modified_method":"@Override\n    public long[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        long[] longs;\n        if (length < VALUE_CACHE_SIZE) {\n            longs = valuesCache.get().get()[length];\n        } else {\n            longs = new long[length];\n        }\n        for (int i = 0; i < length; i++) {\n            longs[i] = values[ordinals[i][docId]];\n        }\n        return longs;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11892,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, LongValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                proc.onValue(docId, values[loc]);\n            }\n        }\n    }","id":11893,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, DoubleValueInDocProc proc) {\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc == 0) {\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, Long.toString(values[loc]));\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11894,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, Long.toString(values[loc]));\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11895,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, ValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public String[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] != 0) {\n                length++;\n            }\n        }\n        if (length == 0) {\n            return Strings.EMPTY_ARRAY;\n        }\n        String[] strings;\n        if (length < VALUE_CACHE_SIZE) {\n            strings = valuesCache.get().get()[length];\n        } else {\n            strings = new String[length];\n        }\n        int i = 0;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                strings[i++] = values[loc];\n            }\n        }\n        return strings;\n    }","id":11896,"modified_method":"@Override\n    public String[] values(int docId) {\n        int length = 0;\n        for (int[] ordinal : ordinals) {\n            if (ordinal[docId] == 0) {\n                break;\n            }\n            length++;\n        }\n        if (length == 0) {\n            return Strings.EMPTY_ARRAY;\n        }\n        String[] strings;\n        if (length < VALUE_CACHE_SIZE) {\n            strings = valuesCache.get().get()[length];\n        } else {\n            strings = new String[length];\n        }\n        for (int i = 0; i < length; i++) {\n            strings[i] = values[ordinals[i][docId]];\n        }\n        return strings;\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onValue(docId, values[loc]);\n            }\n        }\n        if (!found) {\n            proc.onMissing(docId);\n        }\n    }","id":11897,"modified_method":"@Override\n    public void forEachValueInDoc(int docId, StringValueInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onMissing(docId);\n                }\n                break;\n            }\n            proc.onValue(docId, values[loc]);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        boolean found = false;\n        for (int[] ordinal : ordinals) {\n            int loc = ordinal[docId];\n            if (loc != 0) {\n                found = true;\n                proc.onOrdinal(docId, loc);\n            }\n        }\n        if (!found) {\n            proc.onOrdinal(docId, 0);\n        }\n    }","id":11898,"modified_method":"@Override\n    public void forEachOrdinalInDoc(int docId, OrdinalInDocProc proc) {\n        for (int i = 0; i < ordinals.length; i++) {\n            int loc = ordinals[i][docId];\n            if (loc == 0) {\n                if (i == 0) {\n                    proc.onOrdinal(docId, 0);\n                }\n                break;\n            }\n            proc.onOrdinal(docId, loc);\n        }\n    }","commit_id":"2d46b4102142c70c6f083da0221429a6221b537e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void insertHelperUtilities(\n\t\tVelocityContext vc, String[] restrictedVariables) {\n\n\t\t// Array util\n\n\t\tvc.put(\"arrayUtil\", ArrayUtil_IW.getInstance());\n\n\t\t// Browser sniffer\n\n\t\tvc.put(\"browserSniffer\", BrowserSniffer_IW.getInstance());\n\n\t\t// Date formats\n\n\t\tvc.put(\"dateFormats\", DateFormats_IW.getInstance());\n\n\t\t// Date tool\n\n\t\tvc.put(\"dateTool\", new DateTool());\n\n\t\t// Date util\n\n\t\tvc.put(\"dateUtil\", DateUtil_IW.getInstance());\n\n\t\t// Escape tool\n\n\t\tvc.put(\"escapeTool\", new EscapeTool());\n\n\t\t// Expando column service\n\n\t\tServiceLocator serviceLocator = ServiceLocator.getInstance();\n\n\t\tvc.put(\"expandoColumnService\",\n\t\t\t(ExpandoColumnService)Proxy.newProxyInstance(\n\t\t\t\tExpandoColumnService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoColumnService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoColumnService.class.getName()))));\n\n\t\t// Expando row service\n\n\t\tvc.put(\"expandoRowService\",\n\t\t\t(ExpandoRowService)Proxy.newProxyInstance(\n\t\t\t\tExpandoRowService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoRowService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoRowService.class.getName()))));\n\n\t\t// Expando table service\n\n\t\tvc.put(\"expandoTableService\",\n\t\t\t(ExpandoTableService)Proxy.newProxyInstance(\n\t\t\t\tExpandoTableService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoTableService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoTableService.class.getName()))));\n\n\t\t// Expando value service\n\n\t\tvc.put(\"expandoValueService\",\n\t\t\t(ExpandoValueService)Proxy.newProxyInstance(\n\t\t\t\tExpandoValueService.class.getClassLoader(),\n\t\t\t\tnew Class[] { ExpandoValueService.class },\n\t\t\t\tnew ExceptionSafeServiceHandler(serviceLocator.findService(\n\t\t\t\t\tExpandoValueService.class.getName()))));\n\n\t\t// Getter util\n\n\t\tvc.put(\"getterUtil\", GetterUtil_IW.getInstance());\n\n\t\t// Html util\n\n\t\tvc.put(\"htmlUtil\", HtmlUtil.getHtml());\n\n\t\t// Http util\n\n\t\tvc.put(\"httpUtil\", HttpUtil.getHttp());\n\n\t\t// ImageServletToken\n\n\t\tvc.put(\"imageToken\", ImageServletTokenUtil.getImageServletToken());\n\n\t\t// Iterator tool\n\n\t\tvc.put(\"iteratorTool\", new IteratorTool());\n\n\t\t// Language util\n\n\t\tvc.put(\"languageUtil\", LanguageUtil.getLanguage());\n\t\tvc.put(\"unicodeLanguageUtil\", UnicodeLanguageUtil.getUnicodeLanguage());\n\n\t\t// List tool\n\n\t\tvc.put(\"listTool\", new ListTool());\n\n\t\t// Locale util\n\n\t\tvc.put(\"localeUtil\", LocaleUtil.getInstance());\n\n\t\t// Math tool\n\n\t\tvc.put(\"mathTool\", new MathTool());\n\n\t\t// Number tool\n\n\t\tvc.put(\"numberTool\", new NumberTool());\n\n\t\t// Param util\n\n\t\tvc.put(\"paramUtil\", ParamUtil_IW.getInstance());\n\n\t\t// Portal util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portalUtil\", PortalUtil.getPortal());\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portal\", PortalUtil.getPortal());\n\n\t\t// Prefs props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"prefsPropsUtil\",\n\t\t\tPrefsPropsUtil_IW.getInstance());\n\n\t\t// Props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"propsUtil\", PropsUtil_IW.getInstance());\n\n\t\t// Portlet URL factory\n\n\t\tvc.put(\"portletURLFactory\", PortletURLFactory.getInstance());\n\n\t\t// Portlet preferences\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"velocityPortletPreferences\",\n\t\t\tnew VelocityPortletPreferences());\n\n\t\t// Randomizer\n\n\t\tvc.put(\"randomizer\", Randomizer_IW.getInstance().getWrappedInstance());\n\n\t\t// Service locator\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"serviceLocator\", serviceLocator);\n\n\t\t// Session clicks\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"sessionClicks\",\n\t\t\tSessionClicks_IW.getInstance());\n\n\t\t// Sort tool\n\n\t\tvc.put(\"sortTool\", new SortTool());\n\n\t\t// Static field getter\n\n\t\tvc.put(\"staticFieldGetter\", StaticFieldGetter.getInstance());\n\n\t\t// String util\n\n\t\tvc.put(\"stringUtil\", StringUtil_IW.getInstance());\n\n\t\t// Unicode formatter\n\n\t\tvc.put(\"unicodeFormatter\", UnicodeFormatter_IW.getInstance());\n\n\t\t// Validator\n\n\t\tvc.put(\"validator\", Validator_IW.getInstance());\n\n\t\t// Permissions\n\n\t\tvc.put(\n\t\t\t\"accountPermission\", AccountPermissionUtil.getAccountPermission());\n\t\tvc.put(\"commonPermission\", CommonPermissionUtil.getCommonPermission());\n\t\tvc.put(\"groupPermission\", GroupPermissionUtil.getGroupPermission());\n\t\tvc.put(\"layoutPermission\", LayoutPermissionUtil.getLayoutPermission());\n\t\tvc.put(\n\t\t\t\"organizationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t\tvc.put(\n\t\t\t\"passwordPolicyPermission\",\n\t\t\tPasswordPolicyPermissionUtil.getPasswordPolicyPermission());\n\t\tvc.put(\"portalPermission\", PortalPermissionUtil.getPortalPermission());\n\t\tvc.put(\n\t\t\t\"portletPermission\", PortletPermissionUtil.getPortletPermission());\n\t\tvc.put(\"rolePermission\", RolePermissionUtil.getRolePermission());\n\t\tvc.put(\n\t\t\t\"userGroupPermission\",\n\t\t\tUserGroupPermissionUtil.getUserGroupPermission());\n\t\tvc.put(\"userPermission\", UserPermissionUtil.getUserPermission());\n\n\t\t// Deprecated permissions\n\n\t\tvc.put(\n\t\t\t\"locationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t}","id":11899,"modified_method":"public static void insertHelperUtilities(\n\t\tVelocityContext vc, String[] restrictedVariables) {\n\n\t\t// Array util\n\n\t\tvc.put(\"arrayUtil\", ArrayUtil_IW.getInstance());\n\n\t\t// Browser sniffer\n\n\t\tvc.put(\"browserSniffer\", BrowserSniffer_IW.getInstance());\n\n\t\t// Date formats\n\n\t\tvc.put(\"dateFormats\", DateFormats_IW.getInstance());\n\n\t\t// Date tool\n\n\t\tvc.put(\"dateTool\", new DateTool());\n\n\t\t// Date util\n\n\t\tvc.put(\"dateUtil\", DateUtil_IW.getInstance());\n\n\t\t// Escape tool\n\n\t\tvc.put(\"escapeTool\", new EscapeTool());\n\n\t\t// Expando column service\n\n\t\tServiceLocator serviceLocator = ServiceLocator.getInstance();\n\n\t\tvc.put(\n\t\t\t\"expandoColumnService\",\n\t\t\tserviceLocator.findExceptionSafeService(\n\t\t\t\tExpandoColumnService.class));\n\n\t\t// Expando row service\n\n\t\tvc.put(\n\t\t\t\"expandoRowService\",\n\t\t\tserviceLocator.findExceptionSafeService(ExpandoRowService.class));\n\n\t\t// Expando table service\n\n\t\tvc.put(\n\t\t\t\"expandoTableService\",\n\t\t\tserviceLocator.findExceptionSafeService(ExpandoTableService.class));\n\n\t\t// Expando value service\n\n\t\tvc.put(\n\t\t\t\"expandoValueService\",\n\t\t\tserviceLocator.findExceptionSafeService(ExpandoValueService.class));\n\n\t\t// Getter util\n\n\t\tvc.put(\"getterUtil\", GetterUtil_IW.getInstance());\n\n\t\t// Html util\n\n\t\tvc.put(\"htmlUtil\", HtmlUtil.getHtml());\n\n\t\t// Http util\n\n\t\tvc.put(\"httpUtil\", HttpUtil.getHttp());\n\n\t\t// ImageServletToken\n\n\t\tvc.put(\"imageToken\", ImageServletTokenUtil.getImageServletToken());\n\n\t\t// Iterator tool\n\n\t\tvc.put(\"iteratorTool\", new IteratorTool());\n\n\t\t// Language util\n\n\t\tvc.put(\"languageUtil\", LanguageUtil.getLanguage());\n\t\tvc.put(\"unicodeLanguageUtil\", UnicodeLanguageUtil.getUnicodeLanguage());\n\n\t\t// List tool\n\n\t\tvc.put(\"listTool\", new ListTool());\n\n\t\t// Locale util\n\n\t\tvc.put(\"localeUtil\", LocaleUtil.getInstance());\n\n\t\t// Math tool\n\n\t\tvc.put(\"mathTool\", new MathTool());\n\n\t\t// Number tool\n\n\t\tvc.put(\"numberTool\", new NumberTool());\n\n\t\t// Param util\n\n\t\tvc.put(\"paramUtil\", ParamUtil_IW.getInstance());\n\n\t\t// Portal util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portalUtil\", PortalUtil.getPortal());\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"portal\", PortalUtil.getPortal());\n\n\t\t// Prefs props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"prefsPropsUtil\",\n\t\t\tPrefsPropsUtil_IW.getInstance());\n\n\t\t// Props util\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"propsUtil\", PropsUtil_IW.getInstance());\n\n\t\t// Portlet URL factory\n\n\t\tvc.put(\"portletURLFactory\", PortletURLFactory.getInstance());\n\n\t\t// Portlet preferences\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"velocityPortletPreferences\",\n\t\t\tnew VelocityPortletPreferences());\n\n\t\t// Randomizer\n\n\t\tvc.put(\"randomizer\", Randomizer_IW.getInstance().getWrappedInstance());\n\n\t\t// Service locator\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"serviceLocator\", serviceLocator);\n\n\t\t// Session clicks\n\n\t\t_insertHelperUtility(\n\t\t\tvc, restrictedVariables, \"sessionClicks\",\n\t\t\tSessionClicks_IW.getInstance());\n\n\t\t// Sort tool\n\n\t\tvc.put(\"sortTool\", new SortTool());\n\n\t\t// Static field getter\n\n\t\tvc.put(\"staticFieldGetter\", StaticFieldGetter.getInstance());\n\n\t\t// String util\n\n\t\tvc.put(\"stringUtil\", StringUtil_IW.getInstance());\n\n\t\t// Unicode formatter\n\n\t\tvc.put(\"unicodeFormatter\", UnicodeFormatter_IW.getInstance());\n\n\t\t// Validator\n\n\t\tvc.put(\"validator\", Validator_IW.getInstance());\n\n\t\t// Permissions\n\n\t\tvc.put(\n\t\t\t\"accountPermission\", AccountPermissionUtil.getAccountPermission());\n\t\tvc.put(\"commonPermission\", CommonPermissionUtil.getCommonPermission());\n\t\tvc.put(\"groupPermission\", GroupPermissionUtil.getGroupPermission());\n\t\tvc.put(\"layoutPermission\", LayoutPermissionUtil.getLayoutPermission());\n\t\tvc.put(\n\t\t\t\"organizationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t\tvc.put(\n\t\t\t\"passwordPolicyPermission\",\n\t\t\tPasswordPolicyPermissionUtil.getPasswordPolicyPermission());\n\t\tvc.put(\"portalPermission\", PortalPermissionUtil.getPortalPermission());\n\t\tvc.put(\n\t\t\t\"portletPermission\", PortletPermissionUtil.getPortletPermission());\n\t\tvc.put(\"rolePermission\", RolePermissionUtil.getRolePermission());\n\t\tvc.put(\n\t\t\t\"userGroupPermission\",\n\t\t\tUserGroupPermissionUtil.getUserGroupPermission());\n\t\tvc.put(\"userPermission\", UserPermissionUtil.getUserPermission());\n\n\t\t// Deprecated permissions\n\n\t\tvc.put(\n\t\t\t\"locationPermission\",\n\t\t\tOrganizationPermissionUtil.getOrganizationPermission());\n\t}","commit_id":"d26a6df8749ada09d49ab504fbaa5fd5edd435a1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Overriden to contruct a valid SQL92 JOIN clause as opposed to\n     * the Oracle-like SQL the superclass produces.\n     *\n     * @param leftName  the table name on the left side of the clause\n     * @param rightName the table name on the right side of the clause\n     * @param semantic  the join semantic\n     * @return  the join clause\n     */\n    public String assembleJoinClause(String leftName,\n                                     String rightName,\n                                     int semantic) {\n        if (!useAliases()) {\n            return super.assembleJoinClause(leftName, rightName, semantic);\n        }\n        \n        String leftAlias = leftName.substring(0, leftName.indexOf(\".\"));\n        String rightAlias = rightName.substring(0, rightName.indexOf(\".\"));\n        \n        NSArray k;\n        EOEntity rightEntity;\n        EOEntity leftEntity;\n        String relationshipKey = null;\n        EORelationship r;\n        \n        \n        if (leftAlias.equals(\"t0\")) {\n            leftEntity = entity();\n        } else {\n            k = aliasesByRelationshipPath().allKeysForObject(leftAlias);\n            relationshipKey = k.count()>0? (String)k.lastObject() : \"\";\n            leftEntity = entityForKeyPath(relationshipKey);\n        }\n        \n        if (rightAlias.equals(\"t0\")) {\n            rightEntity = entity();\n        } else {\n            k = aliasesByRelationshipPath().allKeysForObject(rightAlias);\n            relationshipKey = k.count()>0? (String)k.lastObject() : \"\";\n            rightEntity = entityForKeyPath(relationshipKey);\n        }\n        int dotIndex = relationshipKey.indexOf( \".\" );\n        relationshipKey = dotIndex == -1\n            ? relationshipKey\n            : relationshipKey.substring( relationshipKey.lastIndexOf( \".\" ) + 1 );\n        r = rightEntity.anyRelationshipNamed( relationshipKey );\n        // fix from Michael M�ller for the case Foo.fooBars.bar has a Bar.foo relationship (instead of Bar.foos)\n        if( r == null || r.destinationEntity() != leftEntity ) {\n            r = leftEntity.anyRelationshipNamed( relationshipKey );\n        }\n        //timc 2006-02-26 IMPORTANT or quotes are ignored and mixed case field names won't work\n        String rightTable;\n        String leftTable; \n        if(enableIdentifierQuoting()) {\n            rightTable = rightEntity.valueForSQLExpression(this);\n            leftTable = leftEntity.valueForSQLExpression(this);\n        } else {\n            rightTable = rightEntity.externalName(); \n            leftTable = leftEntity.externalName(); \n        }\n        JoinClause jc = new JoinClause();\n        \n        jc.table1 = leftTable + \" \" + leftAlias;\n        \n        switch (semantic) {\n            case EORelationship.LeftOuterJoin:\n                jc.op = \" LEFT OUTER JOIN \";\n                break;\n            case EORelationship.RightOuterJoin:\n                jc.op = \" RIGHT OUTER JOIN \";\n                break;\n            case EORelationship.FullOuterJoin:\n                jc.op = \" FULL OUTER JOIN \";\n                break;\n            case EORelationship.InnerJoin:\n                jc.op = \" INNER JOIN \";\n                break;\n        }\n        \n        jc.table2 = rightTable + \" \" + rightAlias;\n        NSArray joins = r.joins();\n        int joinsCount = joins.count();\n        NSMutableArray joinStrings = new NSMutableArray( joinsCount );\n        for( int i = 0; i < joinsCount; i++ ) {\n            EOJoin currentJoin = (EOJoin)joins.objectAtIndex(i);\n            String left;\n            String right;\n            if(enableIdentifierQuoting()) {\n                left = leftAlias +\".\"+ sqlStringForSchemaObjectName(currentJoin.sourceAttribute().columnName());\n                right =  rightAlias +\".\"+ sqlStringForSchemaObjectName(currentJoin.destinationAttribute().columnName());\n            } else {\n                left = leftAlias +\".\"+currentJoin.sourceAttribute().columnName();\n                right = rightAlias +\".\"+currentJoin.destinationAttribute().columnName();\n            }\n            joinStrings.addObject( left + \" = \" + right);\n        }\n        jc.joinCondition = \" ON \" + joinStrings.componentsJoinedByString( \" AND \" );\n        if( !_alreadyJoined.containsObject( jc ) ) {\n            _alreadyJoined.insertObjectAtIndex(jc, 0);\n            return jc.toString();\n        }\n        return null;\n    }","id":11900,"modified_method":"/**\n   * Overriden to contruct a valid SQL92 JOIN clause as opposed to\n   * the Oracle-like SQL the superclass produces.\n   *\n   * @param leftName  the table name on the left side of the clause\n   * @param rightName the table name on the right side of the clause\n   * @param semantic  the join semantic\n   * @return  the join clause\n   */\n  @Override\n  public String assembleJoinClause(String leftName,\n      String rightName,\n      int semantic) {\n    if (!useAliases()) {\n      return super.assembleJoinClause(leftName, rightName, semantic);\n    }\n\n    String leftAlias = leftName.substring(0, leftName.indexOf(\".\"));\n    String rightAlias = rightName.substring(0, rightName.indexOf(\".\"));\n\n    NSArray<String> keys;\n    EOEntity rightEntity;\n    EOEntity leftEntity;\n    String relationshipKey = null;\n    EORelationship rel;\n\n\n    if (leftAlias.equals(\"t0\")) {\n      leftEntity = entity();\n    } else {\n      keys = aliasesByRelationshipPath().allKeysForObject(leftAlias);\n      relationshipKey = keys.count() > 0 ? keys.lastObject() : \"\";\n      leftEntity = entityForKeyPath(relationshipKey);\n    }\n\n    if (rightAlias.equals(\"t0\")) {\n      rightEntity = entity();\n    } else {\n      keys = aliasesByRelationshipPath().allKeysForObject(rightAlias);\n      relationshipKey = keys.count() > 0? keys.lastObject() : \"\";\n      rightEntity = entityForKeyPath(relationshipKey);\n    }\n    int dotIndex = relationshipKey.indexOf(\".\");\n    relationshipKey = dotIndex == -1\n    ? relationshipKey\n        : relationshipKey.substring(relationshipKey.lastIndexOf(\".\") + 1);\n    rel = rightEntity.anyRelationshipNamed( relationshipKey );\n    // fix from Michael M�ller for the case Foo.fooBars.bar has a Bar.foo relationship (instead of Bar.foos)\n    if (rel == null || rel.destinationEntity() != leftEntity) {\n      rel = leftEntity.anyRelationshipNamed(relationshipKey);\n    }\n    //timc 2006-02-26 IMPORTANT or quotes are ignored and mixed case field names won't work\n    String rightTable;\n    String leftTable; \n    if (enableIdentifierQuoting()) {\n      rightTable = rightEntity.valueForSQLExpression(this);\n      leftTable = leftEntity.valueForSQLExpression(this);\n    } else {\n      rightTable = rightEntity.externalName(); \n      leftTable = leftEntity.externalName(); \n    }\n    JoinClause jc = new JoinClause();\n\n    jc.table1 = leftTable + \" \" + leftAlias;\n\n    switch (semantic) {\n    case EORelationship.LeftOuterJoin:\n      jc.op = \" LEFT OUTER JOIN \";\n      break;\n    case EORelationship.RightOuterJoin:\n      jc.op = \" RIGHT OUTER JOIN \";\n      break;\n    case EORelationship.FullOuterJoin:\n      jc.op = \" FULL OUTER JOIN \";\n      break;\n    case EORelationship.InnerJoin:\n      jc.op = \" INNER JOIN \";\n      break;\n    }\n\n    jc.table2 = rightTable + \" \" + rightAlias;\n    NSArray<EOJoin> joins = rel.joins();\n    NSMutableArray<String> joinStrings = new NSMutableArray<String>(joins.count());\n    for (EOJoin currentJoin : joins) {\n      String left;\n      String right;\n      if(enableIdentifierQuoting()) {\n        left = leftAlias + \".\" + sqlStringForSchemaObjectName(currentJoin.sourceAttribute().columnName());\n        right = rightAlias + \".\" + sqlStringForSchemaObjectName(currentJoin.destinationAttribute().columnName());\n      } else {\n        left = leftAlias + \".\" + currentJoin.sourceAttribute().columnName();\n        right = rightAlias + \".\" + currentJoin.destinationAttribute().columnName();\n      }\n      joinStrings.addObject(left + \" = \" + right);\n    }\n    jc.joinCondition = \" ON \" + joinStrings.componentsJoinedByString(\" AND \");\n    if (!_alreadyJoined.containsObject(jc)) {\n      _alreadyJoined.insertObjectAtIndex(jc, 0);\n      return jc.toString();\n    }\n    return null;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Overrides the parent implementation to:\n     * <ul>\n     * <li>add typecasts after the value, i.e. '2'::char,\n     * which is required with certain PostgreSQL versions (<=7.4.x) for the correct query processing, \n     * particularly with index usage. \n     * <li>quotes values if bind variables are disabled on this attribute. \n     * <\/ul>\n     * NULL values are excluded from casting. <br/>\n     * You can set the System default <code>com.webobjects.jdbcadaptor.PostgresqlExpression.disableTypeCasting<\/code>\n     * to true to disable both fixes (the former you might want to disable when PG says it can't cast a certain value and\n     * the second when you have values with a greater resolution already in the DB).\n     * @param v the value\n     * @param kp    the keypath associated with the value\n     */\n    public String sqlStringForValue(Object v, String kp) {\n        if(disableTypeCasting()) {\n            return super.sqlStringForValue(v,kp);\n        }\n        EOAttribute attribute;\n        int lastDotIdx = kp.lastIndexOf(\".\");\n        if (lastDotIdx == -1) {\n        \tattribute = entity().attributeNamed(kp);\n        } else {\n        \tEOEntity kpEntity = entityForKeyPath(kp);\n        \tattribute = kpEntity.attributeNamed(kp.substring(lastDotIdx+1));\n        }\n        if(attribute != null && v != null && v != NSKeyValueCoding.NullValue) {\n        \tString s = columnTypeStringForAttribute(attribute);\n        \treturn super.sqlStringForValue(v, kp) + \"::\" + s;\n        } \n        \n        return super.sqlStringForValue(v,kp);\n    }","id":11901,"modified_method":"/**\n   * Overrides the parent implementation to:\n   * <ul>\n   * <li>add typecasts after the value, i.e. '2'::char,\n   * which is required with certain PostgreSQL versions (<=7.4.x) for the correct query processing, \n   * particularly with index usage. \n   * <li>quotes values if bind variables are disabled on this attribute. \n   * <\/ul>\n   * NULL values are excluded from casting. <br/>\n   * You can set the System default <code>com.webobjects.jdbcadaptor.PostgresqlExpression.disableTypeCasting<\/code>\n   * to true to disable both fixes (the former you might want to disable when PG says it can't cast a certain value and\n   * the second when you have values with a greater resolution already in the DB).\n   * @param value the value\n   * @param keyPath the keypath associated with the value\n   */\n  @Override\n  public String sqlStringForValue(Object value, String keyPath) {\n    if (disableTypeCasting()) {\n      return super.sqlStringForValue(value,keyPath);\n    }\n    EOAttribute attribute;\n    int lastDotIdx = keyPath.lastIndexOf(\".\");\n    if (lastDotIdx == -1) {\n      attribute = entity().attributeNamed(keyPath);\n    } else {\n      EOEntity kpEntity = entityForKeyPath(keyPath);\n      attribute = kpEntity.attributeNamed(keyPath.substring(lastDotIdx+1));\n    }\n    if (attribute != null && value != null && value != NSKeyValueCoding.NullValue) {\n      String columnType = columnTypeStringForAttribute(attribute);\n      return super.sqlStringForValue(value, keyPath) + \"::\" + columnType;\n    } \n\n    return super.sqlStringForValue(value, keyPath);\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Replaces a given string by another string in a string.\n     * @param old string to be replaced\n     * @param newString to be inserted\n     * @param buffer string to have the replacement done on it\n     * @return string after having all of the replacement done.\n     */\n    public static String replaceStringByStringInString(String old, String newString, String buffer) {\n        int begin, end;\n        int oldLength = old.length();\n        int length = buffer.length();\n        StringBuffer convertedString = new StringBuffer(length + 100);\n\n        begin = 0;\n        while(begin < length)\n        {\n            end = buffer.indexOf(old, begin);\n            if(end == -1)\n            {\n                convertedString.append(buffer.substring(begin));\n                break;\n            }\n            if(end == 0)\n                convertedString.append(newString);\n            else {\n                convertedString.append(buffer.substring(begin, end));\n                convertedString.append(newString);\n            }\n            begin = end+oldLength;\n        }\n        return convertedString.toString();\n    }","id":11902,"modified_method":"/**\n   * Replaces a given string by another string in a string.\n   * @param old string to be replaced\n   * @param newString to be inserted\n   * @param buffer string to have the replacement done on it\n   * @return string after having all of the replacement done.\n   */\n  public static String replaceStringByStringInString(String old, String newString, String buffer) {\n    int begin, end;\n    int oldLength = old.length();\n    int length = buffer.length();\n    StringBuilder convertedString = new StringBuilder(length + 100);\n\n    begin = 0;\n    while (begin < length) {\n      end = buffer.indexOf(old, begin);\n      if (end == -1) {\n        convertedString.append(buffer.substring(begin));\n        break;\n      }\n      if (end == 0) {\n        convertedString.append(newString);\n      } else {\n        convertedString.append(buffer.substring(begin, end));\n        convertedString.append(newString);\n      }\n      begin = end + oldLength;\n    }\n    return convertedString.toString();\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Overrides the parent implementation to add an <code>INITIALLY DEFERRED<\/code> to the generated statement.\n     * Useful you want to generate the schema-building SQL from a pure java environment.\n     * \n     * cug: Also handles identifier quoting now\n     * \n     * @param relationship  the relationship\n     * @param sourceColumns the source columns for the constraints\n     * @param destinationColumns    the destination columns for the constraints\n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic void prepareConstraintStatementForRelationship(EORelationship relationship, NSArray sourceColumns, NSArray destinationColumns) {\n\t\t\n    \tEOEntity entity = relationship.entity();\n\t\tString tableName = entity.externalName();\n\t\t\n\t\tint lastDot = tableName.lastIndexOf('.');\n\t\t\n\t\tif (lastDot >= 0) {\n\t\t\ttableName = tableName.substring(lastDot + 1);\n\t\t}\n\t\t\n\t\tString constraintName = _NSStringUtilities.concat(tableName, \"_\", relationship.name(), \"_fk\");\n\t\t\n\t\t// quotes the identifier in the array\n\t\t\n\t\tString sourceKeyList = this.quoteArrayContents(sourceColumns).componentsJoinedByString(\", \");\n\t\tString destinationKeyList = this.quoteArrayContents(destinationColumns).componentsJoinedByString(\", \");\n\t\t\n\t\tEOModel sourceModel = entity.model();\n\t\tEOModel destModel = relationship.destinationEntity().model();\n\t\tif (sourceModel != destModel && !sourceModel.connectionDictionary().equals(destModel.connectionDictionary())) {\n\t\t\tthrow new IllegalArgumentException((new StringBuilder()).append(\"prepareConstraintStatementForRelationship unable to create a constraint for \").append(relationship.name()).append(\" because the source and destination entities reside in different databases\").toString());\n\t\t} \n\t\telse {\n\t\t\tsetStatement((new StringBuilder())\n\t\t\t\t\t.append(\"ALTER TABLE \")\n\t\t\t\t\t.append(sqlStringForSchemaObjectName(entity.externalName()))\n\t\t\t\t\t.append(\" ADD CONSTRAINT \")\n\t\t\t\t\t.append(quoteIdentifier(constraintName))\n\t\t\t\t\t.append(\" FOREIGN KEY (\")\n\t\t\t\t\t.append(sourceKeyList)\n\t\t\t\t\t.append(\") REFERENCES \")\n\t\t\t\t\t.append(sqlStringForSchemaObjectName(relationship.destinationEntity().externalName()))\n\t\t\t\t\t.append(\" (\")\n\t\t\t\t\t.append(destinationKeyList)\n\t\t\t\t\t.append(\") INITIALLY DEFERRED\")\n\t\t\t\t\t.toString());\n\t\t}\n\t}","id":11903,"modified_method":"/**\n   * Overrides the parent implementation to add an <code>INITIALLY DEFERRED<\/code> to the generated statement.\n   * Useful you want to generate the schema-building SQL from a pure java environment.\n   * \n   * cug: Also handles identifier quoting now\n   * \n   * @param relationship  the relationship\n   * @param sourceColumns the source columns for the constraints\n   * @param destinationColumns    the destination columns for the constraints\n   */\n  @Override\n  public void prepareConstraintStatementForRelationship(EORelationship relationship, NSArray sourceColumns, NSArray destinationColumns) {\n\n    EOEntity entity = relationship.entity();\n    String tableName = entity.externalName();\n\n    int lastDot = tableName.lastIndexOf('.');\n\n    if (lastDot >= 0) {\n      tableName = tableName.substring(lastDot + 1);\n    }\n\n    String constraintName = _NSStringUtilities.concat(tableName, \"_\", relationship.name(), \"_fk\");\n\n    // quotes the identifier in the array\n\n    String sourceKeyList = this.quoteArrayContents(sourceColumns).componentsJoinedByString(\", \");\n    String destinationKeyList = this.quoteArrayContents(destinationColumns).componentsJoinedByString(\", \");\n\n    EOModel sourceModel = entity.model();\n    EOModel destModel = relationship.destinationEntity().model();\n    if (sourceModel != destModel && !sourceModel.connectionDictionary().equals(destModel.connectionDictionary())) {\n      throw new IllegalArgumentException((new StringBuilder()).append(\"prepareConstraintStatementForRelationship unable to create a constraint for \").append(relationship.name()).append(\" because the source and destination entities reside in different databases\").toString());\n    }\n    setStatement((new StringBuilder())\n        .append(\"ALTER TABLE \")\n        .append(sqlStringForSchemaObjectName(entity.externalName()))\n        .append(\" ADD CONSTRAINT \")\n        .append(quoteIdentifier(constraintName))\n        .append(\" FOREIGN KEY (\")\n        .append(sourceKeyList)\n        .append(\") REFERENCES \")\n        .append(sqlStringForSchemaObjectName(relationship.destinationEntity().externalName()))\n        .append(\" (\")\n        .append(destinationKeyList)\n        .append(\") INITIALLY DEFERRED\")\n        .toString());\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Takes an array of strings and quotes every single string, if set to do so\n     * \n     * @param a - array of strings\n     * \n     * @return array of quoted or unquoted strings, depends on enableIdentifierQuoting\n     */\n    @SuppressWarnings(\"unchecked\")\n\tprivate NSArray quoteArrayContents (NSArray a) {\n    \tEnumeration enumeration = a.objectEnumerator();\n    \tNSMutableArray result = new NSMutableArray();\n    \twhile (enumeration.hasMoreElements()) {\n    \t\tString identifier = (String) enumeration.nextElement();\n    \t\tString quotedString = this.quoteIdentifier(identifier);\n    \t\tresult.addObject(quotedString);\n    \t}\n    \treturn result;\n    }","id":11904,"modified_method":"/**\n   * Takes an array of strings and quotes every single string, if set to do so\n   * \n   * @param a - array of strings\n   * \n   * @return array of quoted or unquoted strings, depends on enableIdentifierQuoting\n   */\n  private NSArray quoteArrayContents (NSArray<String> array) {\n    NSMutableArray<String> result = new NSMutableArray<String>(array.count());\n    for (String identifier : array) {\n      String quotedString = this.quoteIdentifier(identifier);\n      result.add(quotedString);\n    }\n    return result;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Utility that traverses a key path to find the last destination entity\n     *\n     * @param keyPath   the key path\n     * @return  the entity at the end of the keypath\n     */\n    private EOEntity entityForKeyPath(String keyPath) {\n        NSArray keys = NSArray.componentsSeparatedByString(keyPath, \".\");\n        EOEntity ent = entity();\n        \n        for (int i = 0; i < keys.count(); i++) {\n            String k = (String)keys.objectAtIndex(i);\n            EORelationship rel = ent.anyRelationshipNamed(k);\n            if (rel == null) {\n                // it may be an attribute \n                if (ent.anyAttributeNamed(k) != null) {\n                    break;\n                }\n                throw new IllegalArgumentException(\"relationship \" + keyPath + \" generated null\");\n            }\n            ent = rel.destinationEntity();\n        }\n        return ent;\n    }","id":11905,"modified_method":"/**\n   * Utility that traverses a key path to find the last destination entity\n   *\n   * @param keyPath the key path\n   * @return the entity at the end of the keypath\n   */\n  private EOEntity entityForKeyPath(String keyPath) {\n    NSArray<String> keys = NSArray.componentsSeparatedByString(keyPath, \".\");\n    EOEntity entity = entity();\n\n    for (String key : keys) {\n      EORelationship rel = entity.anyRelationshipNamed(key);\n      if (rel == null) {\n        // it may be an attribute \n        if (entity.anyAttributeNamed(key) != null) {\n          break;\n        }\n        throw new IllegalArgumentException(\"relationship \" + keyPath + \" generated null\");\n      }\n      entity = rel.destinationEntity();\n    }\n    return entity;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Overriddden to return the negated value of {@link #disableBindVariables()}.\n     */\n    public boolean useBindVariables() {\n        return !disableBindVariables();\n    }","id":11906,"modified_method":"/**\n   * Overridden to return the negated value of {@link #disableBindVariables()}.\n   */\n  @Override\n  public boolean useBindVariables() {\n    return !disableBindVariables();\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * cug: Quick hack for bug in WebObjects 5.4 where the \"not null\" statement is added without a space, \n     * and \"addCreateClauseForAttribute\" is not called anymore. Will probably change.\n     */\n    public String allowsNullClauseForConstraint(boolean allowsNull)\n    {\n        if(allowsNull)\n            return \"\";\n        Object value = jdbcInfo().objectForKey(\"NON_NULLABLE_COLUMNS\");\n        if(value != null && value.equals(\"T\"))\n            return \" NOT NULL\";\n        else\n            return \"\";\n    }","id":11907,"modified_method":"/**\n   * cug: Quick hack for bug in WebObjects 5.4 where the \"not null\" statement is added without a space, \n   * and \"addCreateClauseForAttribute\" is not called anymore. Will probably change.\n   */\n  @Override\n  public String allowsNullClauseForConstraint(boolean allowsNull) {\n    if (allowsNull) {\n      return \"\";\n    }\n    Object value = jdbcInfo().objectForKey(\"NON_NULLABLE_COLUMNS\");\n    if (value != null && value.equals(\"T\")) {\n      return \" NOT NULL\";\n    }\n    return \"\";\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void addCreateClauseForAttribute(EOAttribute attribute) {\n      NSDictionary userInfo = attribute.userInfo();\n      Object defaultValue = null;\n      if (userInfo != null) {\n        defaultValue = userInfo.valueForKey(\"er.extensions.eoattribute.default\");\n      }\n      String allowsNullClauseForConstraint = allowsNullClauseForConstraint(shouldAllowNull(attribute));\n      String sql;\n      if (defaultValue == null) {\n          sql = _NSStringUtilities.concat(this.quoteIdentifier(attribute.columnName()), \" \", columnTypeStringForAttribute(attribute), \" \", allowsNullClauseForConstraint);\n      }\n      else {\n          sql = _NSStringUtilities.concat(this.quoteIdentifier(attribute.columnName()), \" \", columnTypeStringForAttribute(attribute), \" DEFAULT \", formatValueForAttribute(defaultValue, attribute), \" \", allowsNullClauseForConstraint);\n      }\n      appendItemToListString(sql, _listString());\n    }","id":11908,"modified_method":"@Override\n  public void addCreateClauseForAttribute(EOAttribute attribute) {\n    NSDictionary<String, Object> userInfo = attribute.userInfo();\n    Object defaultValue = null;\n    if (userInfo != null) {\n      defaultValue = userInfo.valueForKey(\"er.extensions.eoattribute.default\");\n    }\n    String allowsNullClauseForConstraint = allowsNullClauseForConstraint(shouldAllowNull(attribute));\n    String sql;\n    if (defaultValue == null) {\n      sql = _NSStringUtilities.concat(this.quoteIdentifier(attribute.columnName()), \" \",\n          columnTypeStringForAttribute(attribute), \" \", allowsNullClauseForConstraint);\n    } else {\n      sql = _NSStringUtilities.concat(this.quoteIdentifier(attribute.columnName()), \" \",\n          columnTypeStringForAttribute(attribute), \" DEFAULT \", formatValueForAttribute(defaultValue, attribute), \" \", allowsNullClauseForConstraint);\n    }\n    appendItemToListString(sql, _listString());\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Overridden to fix an issue with NStimestamp classes and \"T\" value-typed attributes. \n     */\n    public NSMutableDictionary bindVariableDictionaryForAttribute(EOAttribute eoattribute, Object obj) {\n        NSMutableDictionary result =  super.bindVariableDictionaryForAttribute(eoattribute, obj);\n        if((obj instanceof NSTimestamp) && (isTimestampAttribute(eoattribute))) {\n            NSTimestamp nstimestamp = (NSTimestamp)obj;\n            long millis = nstimestamp.getTime();\n            // AK: since NSTimestamp places fractional millis in the getTime,\n            // the driver is getting very confused and refuses to update the columns as \n            // they get translated to 0 as the fractional values.\n            Timestamp timestamp = new Timestamp(millis);\n            timestamp.setNanos(timestamp.getNanos()+nstimestamp.getNanos());\n            result.setObjectForKey(timestamp, \"BindVariableValue\");\n         }\n        return result;\n    }","id":11909,"modified_method":"/**\n   * Overridden to fix an issue with NStimestamp classes and \"T\" value-typed attributes. \n   */\n  @Override\n  public NSMutableDictionary bindVariableDictionaryForAttribute(EOAttribute eoattribute, Object obj) {\n    NSMutableDictionary<String, Object> result =  super.bindVariableDictionaryForAttribute(eoattribute, obj);\n    if ((obj instanceof NSTimestamp) && (isTimestampAttribute(eoattribute))) {\n      NSTimestamp nstimestamp = (NSTimestamp)obj;\n      long millis = nstimestamp.getTime();\n      // AK: since NSTimestamp places fractional millis in the getTime,\n      // the driver is getting very confused and refuses to update the columns as \n      // they get translated to 0 as the fractional values.\n      Timestamp timestamp = new Timestamp(millis);\n      timestamp.setNanos(timestamp.getNanos() + nstimestamp.getNanos());\n      result.setObjectForKey(timestamp, \"BindVariableValue\");\n    }\n    return result;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Overrides the parent implementation to compose the final string\n     * expression for the join clauses.\n     */\n    public String joinClauseString() {\n        NSMutableDictionary seenIt = new NSMutableDictionary();\n        StringBuffer sb = new StringBuffer();\n        JoinClause jc;\n        EOSortOrdering.sortArrayUsingKeyOrderArray\n            ( _alreadyJoined, new NSArray( EOSortOrdering.sortOrderingWithKey( \"sortKey\", EOSortOrdering.CompareCaseInsensitiveAscending ) ) );\n        if (_alreadyJoined.count() > 0) {\n            jc = (JoinClause)_alreadyJoined.objectAtIndex(0);\n            \n            sb.append(jc);\n            seenIt.setObjectForKey(Boolean.TRUE, jc.table1);\n            seenIt.setObjectForKey(Boolean.TRUE, jc.table2);\n        }\n        \n        for (int i = 1; i < _alreadyJoined.count(); i++) {\n            jc = (JoinClause)_alreadyJoined.objectAtIndex(i);\n            \n            sb.append(jc.op);\n            if (seenIt.objectForKey(jc.table1) == null) {\n                sb.append(jc.table1);\n                seenIt.setObjectForKey(Boolean.TRUE, jc.table1);\n            }\n            else if (seenIt.objectForKey(jc.table2) == null) {\n                sb.append(jc.table2);\n                seenIt.setObjectForKey(Boolean.TRUE, jc.table2);\n            }\n            sb.append(jc.joinCondition);\n        }\n        return sb.toString();\n    }","id":11910,"modified_method":"/**\n   * Overrides the parent implementation to compose the final string\n   * expression for the join clauses.\n   */\n  @Override\n  public String joinClauseString() {\n    NSMutableSet<String> seenIt = new NSMutableSet<String>();\n    StringBuilder sb = new StringBuilder();\n    JoinClause jc;\n    EOSortOrdering.sortArrayUsingKeyOrderArray(_alreadyJoined,\n        new NSArray<EOSortOrdering>(EOSortOrdering.sortOrderingWithKey(\"sortKey\", EOSortOrdering.CompareCaseInsensitiveAscending)));\n    if (_alreadyJoined.count() > 0) {\n      jc = _alreadyJoined.objectAtIndex(0);\n\n      sb.append(jc);\n      seenIt.add(jc.table1);\n      seenIt.add(jc.table2);\n    }\n\n    for (int i = 1; i < _alreadyJoined.count(); i++) {\n      jc = _alreadyJoined.objectAtIndex(i);\n\n      sb.append(jc.op);\n      if (!seenIt.contains(jc.table1)) {\n        sb.append(jc.table1);\n        seenIt.add(jc.table1);\n      } else if (!seenIt.contains(jc.table2)) {\n        sb.append(jc.table2);\n        seenIt.add(jc.table2);\n      }\n      sb.append(jc.joinCondition);\n    }\n    return sb.toString();\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Overridden so we can get the fetch limit from the fetchSpec.\n     *\n     * @param nsarray   the array of attributes\n     * @param flag  locking flag\n     * @param eofetchspecification  the fetch specification\n     */\n    public void prepareSelectExpressionWithAttributes(NSArray nsarray, boolean flag, EOFetchSpecification eofetchspecification) {\n        if(!eofetchspecification.promptsAfterFetchLimit()) {\n            _fetchLimit = eofetchspecification.fetchLimit();\n        }\n        super.prepareSelectExpressionWithAttributes(nsarray, flag, eofetchspecification);\n    }","id":11911,"modified_method":"/**\n   * Overridden so we can get the fetch limit from the fetchSpec.\n   *\n   * @param nsarray   the array of attributes\n   * @param flag  locking flag\n   * @param eofetchspecification  the fetch specification\n   */\n  @Override\n  public void prepareSelectExpressionWithAttributes(NSArray<EOAttribute> attributes, boolean lock, EOFetchSpecification fetchSpec) {\n    if (!fetchSpec.promptsAfterFetchLimit()) {\n      _fetchLimit = fetchSpec.fetchLimit();\n    }\n    super.prepareSelectExpressionWithAttributes(attributes, lock, fetchSpec);\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Overriden to handle correct placements of join conditions and \n     * to handle DISTINCT fetches with compareCaseInsensitiveA(De)scending sort orders.\n     *\n     * @param attributes    the attributes to select\n     * @param lock  flag for locking rows in the database\n     * @param qualifier the qualifier to restrict the selection\n     * @param fetchOrder    specifies the fetch order\n     * @param columnList    the SQL columns to be fetched\n     * @param tableList the the SQL tables to be fetched\n     * @param whereClause   the SQL where clause\n     * @param joinClause    the SQL join clause\n     * @param orderByClause the SQL sort order clause\n     * @param lockClause    the SQL lock clause\n     * @return  the select statement\n     */\n    public String assembleSelectStatementWithAttributes(NSArray attributes,\n                                                        boolean lock,\n                                                        EOQualifier qualifier,\n                                                        NSArray fetchOrder,\n                                                        String selectString,\n                                                        String columnList,\n                                                        String tableList,\n                                                        String whereClause,\n                                                        String joinClause,\n                                                        String orderByClause,\n                                                        String lockClause) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(selectString);\n        sb.append(columnList);\n        // AK: using DISTINCT with ORDER BY UPPER(foo) is an error if it is not also present in the columns list...\n        // This implementation sucks, but should be good enough for the normal case\n        if(selectString.indexOf(\" DISTINCT\") != -1) {\n            String [] columns = orderByClause.split(\",\");\n            for(int i = 0; i < columns.length; i++) {\n                String column = columns[i].replaceFirst(\"\\\\s+(ASC|DESC)\\\\s*\", \"\");\n                if(columnList.indexOf(column) == -1) {\n                    sb.append(\", \");\n                    sb.append(column);\n                }\n            }\n        }\n        sb.append(\" FROM \");\n        String fieldString;\n        if (_alreadyJoined.count() > 0) {\n            fieldString = joinClauseString();\n        } else {\n            fieldString = tableList;\n        }\n        sb.append(fieldString);\n        if ((whereClause != null && whereClause.length() > 0) ||\n            (joinClause != null && joinClause.length() > 0)) {\n            sb.append(\" WHERE \");\n            if (joinClause != null && joinClause.length() > 0) {\n                sb.append(joinClause);\n                if (whereClause != null && whereClause.length() > 0)\n                    sb.append(\" AND \");\n            }\n            \n            if (whereClause != null && whereClause.length() > 0) {\n                sb.append(whereClause);\n            }\n        }\n        if (orderByClause != null && orderByClause.length() > 0) {\n            sb.append(\" ORDER BY \");\n            sb.append(orderByClause);\n        }\n        if (lockClause != null && lockClause.length() > 0) {\n            sb.append(\" \");\n            sb.append(lockClause);\n        }\n        if (_fetchLimit != 0) {\n            sb.append(\" LIMIT \");\n            sb.append(_fetchLimit);\n        }        \n        return sb.toString();\n    }","id":11912,"modified_method":"/**\n   * Overriden to handle correct placements of join conditions and \n   * to handle DISTINCT fetches with compareCaseInsensitiveA(De)scending sort orders.\n   *\n   * @param attributes    the attributes to select\n   * @param lock  flag for locking rows in the database\n   * @param qualifier the qualifier to restrict the selection\n   * @param fetchOrder    specifies the fetch order\n   * @param columnList    the SQL columns to be fetched\n   * @param tableList the the SQL tables to be fetched\n   * @param whereClause   the SQL where clause\n   * @param joinClause    the SQL join clause\n   * @param orderByClause the SQL sort order clause\n   * @param lockClause    the SQL lock clause\n   * @return  the select statement\n   */\n  @Override\n  public String assembleSelectStatementWithAttributes(NSArray attributes,\n      boolean lock,\n      EOQualifier qualifier,\n      NSArray fetchOrder,\n      String selectString,\n      String columnList,\n      String tableList,\n      String whereClause,\n      String joinClause,\n      String orderByClause,\n      String lockClause) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(selectString);\n    sb.append(columnList);\n    // AK: using DISTINCT with ORDER BY UPPER(foo) is an error if it is not also present in the columns list...\n    // This implementation sucks, but should be good enough for the normal case\n    if (selectString.indexOf(\" DISTINCT\") != -1) {\n      String[] columns = orderByClause.split(\",\");\n      for (int i = 0; i < columns.length; i++) {\n        String column = columns[i].replaceFirst(\"\\\\s+(ASC|DESC)\\\\s*\", \"\");\n        if (columnList.indexOf(column) == -1) {\n          sb.append(\", \");\n          sb.append(column);\n        }\n      }\n    }\n    sb.append(\" FROM \");\n    String fieldString;\n    if (_alreadyJoined.count() > 0) {\n      fieldString = joinClauseString();\n    } else {\n      fieldString = tableList;\n    }\n    sb.append(fieldString);\n    if ((whereClause != null && whereClause.length() > 0) ||\n        (joinClause != null && joinClause.length() > 0)) {\n      sb.append(\" WHERE \");\n      if (joinClause != null && joinClause.length() > 0) {\n        sb.append(joinClause);\n        if (whereClause != null && whereClause.length() > 0)\n          sb.append(\" AND \");\n      }\n\n      if (whereClause != null && whereClause.length() > 0) {\n        sb.append(whereClause);\n      }\n    }\n    if (orderByClause != null && orderByClause.length() > 0) {\n      sb.append(\" ORDER BY \");\n      sb.append(orderByClause);\n    }\n    if (lockClause != null && lockClause.length() > 0) {\n      sb.append(\" \");\n      sb.append(lockClause);\n    }\n    if (_fetchLimit != 0) {\n      sb.append(\" LIMIT \");\n      sb.append(_fetchLimit);\n    }        \n    return sb.toString();\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique  primary key value\n   */\n  public NSArray newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n    \n    EOAttribute attribute = (EOAttribute) entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray results = new NSMutableArray(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n    \n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuffer sql = new StringBuffer();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary row;\n            while ((row = channel.fetchRow()) != null) {\n              Enumeration pksEnum = row.allValues().objectEnumerator();\n              while (pksEnum.hasMoreElements()) {\n                Number pkObj = (Number)pksEnum.nextElement();\n                Number pk;\n                if (isIntType) {\n                  pk = new Integer(pkObj.intValue());\n                }\n                else {\n                  pk = new Long(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray(entity));\n            int stmCount = statements.count();\n            for (int i = 0; i < stmCount; i++) {\n              channel.evaluateExpression((EOSQLExpression) statements.objectAtIndex(i));\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n    \n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n    \n    return results;\n  }","id":11913,"modified_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique  primary key value\n   */\n  @Override\n  public NSArray newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n\n    EOAttribute attribute = entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray<NSDictionary<String, Number>> results = new NSMutableArray<NSDictionary<String, Number>>(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n\n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuilder sql = new StringBuilder();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary<String, Object> row;\n            while ((row = channel.fetchRow()) != null) {\n              for (Object obj : row.allValues()) {\n                Number pkObj = (Number)obj;\n                Number pk;\n                if (isIntType) {\n                  pk = Integer.valueOf(pkObj.intValue());\n                }\n                else {\n                  pk = Long.valueOf(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary<String, Number>(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary<String, Object> row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray<EOSQLExpression> statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray<EOEntity>(entity));\n            for (EOSQLExpression statement : statements) {\n              channel.evaluateExpression(statement);\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n\n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n\n    return results;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <P>This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * <\/P> \n   */\n  public NSDictionary jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n//    try {\n//      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n//      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n//      fos.write(jdbcInfoS.getBytes());\n//      fos.close();\n//    }\n//    catch(Exception e) {\n//      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n//    }\n\n    NSDictionary jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if(shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n      \n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      }\n    }\n    else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","id":11914,"modified_method":"/**\n   * <P>This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * <\/P> \n   */\n  @Override\n  public NSDictionary jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n    //    try {\n    //      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n    //      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n    //      fos.write(jdbcInfoS.getBytes());\n    //      fos.close();\n    //    }\n    //    catch(Exception e) {\n    //      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n    //    }\n\n    NSDictionary jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if (shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n\n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      } finally {\n        try {\n          jdbcInfoStream.close();\n        } catch (IOException e) {\n          throw new RuntimeException(\"Failed to close input stream for 'JDBCInfo.plist'.\", e);\n        }\n      }\n    }\n    else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Checks whether primary key generation can be supported for <code>entity<\/code>\n   *\n   * @param entity    the entity to be checked\n   * @return  yes/no\n   */\n  private boolean isPrimaryKeyGenerationNotSupported(EOEntity entity) {\n    return entity.primaryKeyAttributes().count() > 1 || ((EOAttribute) entity.primaryKeyAttributes().lastObject()).adaptorValueType() != EOAttribute.AdaptorNumberType;\n  }","id":11915,"modified_method":"/**\n   * Checks whether primary key generation can be supported for <code>entity<\/code>\n   *\n   * @param entity    the entity to be checked\n   * @return  yes/no\n   */\n  private boolean isPrimaryKeyGenerationNotSupported(EOEntity entity) {\n    return entity.primaryKeyAttributes().count() > 1 || (entity.primaryKeyAttributes().lastObject()).adaptorValueType() != EOAttribute.AdaptorNumberType;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToInsertColumnForAttribute(EOAttribute attribute, NSDictionary options) {\n      String clause = _columnCreationClauseForAttribute(attribute);\n      return new NSArray(_expressionForString(\"alter table \" + formatTableName(attribute.entity().externalName()) + \" add \" + clause));\n    }","id":11916,"modified_method":"@Override\n  public NSArray statementsToInsertColumnForAttribute(EOAttribute attribute, NSDictionary options) {\n    String clause = _columnCreationClauseForAttribute(attribute);\n    return new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(attribute.entity().externalName())\n        + \" add \" + clause));\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected String formatTableName(String name) {\n        if (!enableIdentifierQuoting()) {\n            return name;\n        }\n    \t//Needs to replicate functionality of EOSQLExpression.sqlStringForSchemaObjectName(String name).  For example MySchema.MyTable needs to be quoted \"MySchema\".\"MyTable\"\n        NSArray components = NSArray.componentsSeparatedByString(name, \".\");\n        return \"\\\"\" + components.componentsJoinedByString(\"\\\".\\\"\") + \"\\\"\";\n    }","id":11917,"modified_method":"@Override\n  protected String formatTableName(String name) {\n    if (!enableIdentifierQuoting()) {\n      return name;\n    }\n    //Needs to replicate functionality of EOSQLExpression.sqlStringForSchemaObjectName(String name).  For example MySchema.MyTable needs to be quoted \"MySchema\".\"MyTable\"\n    NSArray<String> components = NSArray.componentsSeparatedByString(name, \".\");\n    return \"\\\"\" + components.componentsJoinedByString(\"\\\".\\\"\") + \"\\\"\";\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to create the primary\n     * key support.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray primaryKeySupportStatementsForEntityGroup(NSArray entityGroup) {\n        EOEntity entity;\n        int count;\n        int i;\n        NSMutableArray results;\n        NSArray priKeyAttributes;\n        EOAttribute priKeyAttribute;\n        String sequenceName;\n\n        NSMutableSet sequenceNames = new NSMutableSet();\n        results = new NSMutableArray();\n        count = entityGroup.count();\n        for (i = 0; i < count; i++) {\n            entity = (EOEntity) entityGroup.objectAtIndex(i);\n            priKeyAttributes = entity.primaryKeyAttributes();\n            if (priKeyAttributes.count() == 1) {\n                priKeyAttribute = (EOAttribute) priKeyAttributes.objectAtIndex(0);\n                \n                // Q: Don't create a sequence for non number primary keys\n                if (priKeyAttribute.adaptorValueType() != EOAttribute.AdaptorNumberType) {\n                \tcontinue;\n                }\n                String sql;\n\n                sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n                if (!sequenceNames.containsObject(sequenceName)) {\n                    sequenceNames.addObject(sequenceName);\n                    // timc 2006-11-06 create result here so we can check for\n                    // enableIdentifierQuoting while building the statement\n                    PostgresqlExpression result = new PostgresqlExpression(entity);\n                    String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n                    String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n                    sql = \"CREATE SEQUENCE \" + sequenceName;\n                    results.addObject(createExpression(entity, sql));\n\n                    sql = \"CREATE TEMP TABLE EOF_TMP_TABLE AS SELECT SETVAL('\" + sequenceName + \"', (SELECT MAX(\" + attributeName + \") FROM \" + tableName + \"))\";\n                    results.addObject(createExpression(entity, sql));\n                    \n                    // In Entity Modeler, we want to skip over the drop statement\n                    if (!isInEntityModeler(entity.model())) {\n                      sql = \"DROP TABLE EOF_TMP_TABLE\";\n                      results.addObject(createExpression(entity, sql));\n                    }\n\n                    sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + attributeName + \" SET DEFAULT nextval( '\" + sequenceName + \"' )\";\n                    results.addObject(createExpression(entity, sql));\n                }\n            }\n        }\n        return results;\n    }","id":11918,"modified_method":"/**\n   * Generates the PostgreSQL-specific SQL statements to create the primary\n   * key support.\n   * \n   * @param entityGroup\n   *            an array of <code>EOEntity<\/code> objects\n   * @return the array of SQL statements\n   */\n  @Override\n  public NSArray primaryKeySupportStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n    NSMutableArray<PostgresqlExpression> results = new NSMutableArray<PostgresqlExpression>();\n    NSArray<EOAttribute> priKeyAttributes;\n    EOAttribute priKeyAttribute;\n    String sequenceName;\n\n    NSMutableSet<String> sequenceNames = new NSMutableSet<String>();\n    for (EOEntity entity : entityGroup) {\n      priKeyAttributes = entity.primaryKeyAttributes();\n      if (priKeyAttributes.count() == 1) {\n        priKeyAttribute = priKeyAttributes.objectAtIndex(0);\n\n        // Q: Don't create a sequence for non number primary keys\n        if (priKeyAttribute.adaptorValueType() != EOAttribute.AdaptorNumberType) {\n          continue;\n        }\n        String sql;\n\n        sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n        if (!sequenceNames.containsObject(sequenceName)) {\n          sequenceNames.addObject(sequenceName);\n          // timc 2006-11-06 create result here so we can check for\n          // enableIdentifierQuoting while building the statement\n          PostgresqlExpression result = new PostgresqlExpression(entity);\n          String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n          String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n          sql = \"CREATE SEQUENCE \" + sequenceName;\n          results.addObject(createExpression(entity, sql));\n\n          sql = \"CREATE TEMP TABLE EOF_TMP_TABLE AS SELECT SETVAL('\" + sequenceName + \"', (SELECT MAX(\" + attributeName + \") FROM \" + tableName + \"))\";\n          results.addObject(createExpression(entity, sql));\n\n          // In Entity Modeler, we want to skip over the drop statement\n          if (!isInEntityModeler(entity.model())) {\n            sql = \"DROP TABLE EOF_TMP_TABLE\";\n            results.addObject(createExpression(entity, sql));\n          }\n\n          sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + attributeName + \" SET DEFAULT nextval( '\" + sequenceName + \"' )\";\n          results.addObject(createExpression(entity, sql));\n        }\n      }\n    }\n    return results;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray _foreignKeyConstraintStatementsForEntityGroup(NSArray group) {\n        if (group == null)\n            return NSArray.EmptyArray;\n        NSMutableArray result = new NSMutableArray();\n        NSMutableSet generatedStatements = new NSMutableSet();\n        int i = 0;\n        for (int groupCount = group.count(); i < groupCount; i++) {\n            EOEntity currentEntity = (EOEntity) group.objectAtIndex(i);\n            if (currentEntity.externalName() != null) {\n                NSArray relationships = currentEntity.relationships();\n                int relCount = relationships.count();\n                for (int j = 0; j < relCount; j++) {\n                    EORelationship currentRelationship = ((EORelationship) relationships.objectAtIndex(j));\n                    if (_shouldGenerateForeignKeyConstraints(currentRelationship)) {\n                        NSArray statements = foreignKeyConstraintStatementsForRelationship(currentRelationship);\n                        if (!generatedStatements.containsObject(statements.valueForKey(\"statement\"))) {\n                            result.addObjectsFromArray(statements);\n                            generatedStatements.addObject(statements.valueForKey(\"statement\"));\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","id":11919,"modified_method":"@Override\n  public NSArray _foreignKeyConstraintStatementsForEntityGroup(NSArray<EOEntity> group) {\n    if (group == null)\n      return NSArray.EmptyArray;\n    NSMutableArray<PostgresqlExpression> result = new NSMutableArray<PostgresqlExpression>();\n    NSMutableSet<NSArray<String>> generatedStatements = new NSMutableSet<NSArray<String>>();\n    for (EOEntity currentEntity : group) {\n      if (currentEntity.externalName() != null) {\n        NSArray<EORelationship> relationships = currentEntity.relationships();\n        for (EORelationship currentRelationship : relationships) {\n          if (_shouldGenerateForeignKeyConstraints(currentRelationship)) {\n            NSArray<PostgresqlExpression> statements = foreignKeyConstraintStatementsForRelationship(currentRelationship);\n            if (!generatedStatements.containsObject(statements.valueForKey(\"statement\"))) {\n              result.addObjectsFromArray(statements);\n              generatedStatements.addObject(statements.valueForKey(\"statement\"));\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToRenameTableNamed(String tableName, String newName, NSDictionary options) {\n    \treturn new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" rename to \" + formatTableName(newName)));\n    }","id":11920,"modified_method":"@Override\n  public NSArray statementsToRenameTableNamed(String tableName, String newName, NSDictionary options) {\n    return new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName)\n        + \" rename to \" + formatTableName(newName)));\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Replaces a given string by another string in a string.\n\t * \n\t * @param old\n\t *            string to be replaced\n\t * @param newString\n\t *            to be inserted\n\t * @param buffer\n\t *            string to have the replacement done on it\n\t * @return string after having all of the replacement done.\n\t */\n    public static String replaceStringByStringInString(String old, String newString, String buffer) {\n        int begin, end;\n        int oldLength = old.length();\n        int length = buffer.length();\n        StringBuffer convertedString = new StringBuffer(length + 100);\n\n        begin = 0;\n        while (begin < length) {\n            end = buffer.indexOf(old, begin);\n            if (end == -1) {\n                convertedString.append(buffer.substring(begin));\n                break;\n            }\n            if (end == 0)\n                convertedString.append(newString);\n            else {\n                convertedString.append(buffer.substring(begin, end));\n                convertedString.append(newString);\n            }\n            begin = end + oldLength;\n        }\n        return convertedString.toString();\n    }","id":11921,"modified_method":"/**\n   * Replaces a given string by another string in a string.\n   * \n   * @param old\n   *            string to be replaced\n   * @param newString\n   *            to be inserted\n   * @param buffer\n   *            string to have the replacement done on it\n   * @return string after having all of the replacement done.\n   */\n  public static String replaceStringByStringInString(String old, String newString, String buffer) {\n    int begin, end;\n    int oldLength = old.length();\n    int length = buffer.length();\n    StringBuilder convertedString = new StringBuilder(length + 100);\n\n    begin = 0;\n    while (begin < length) {\n      end = buffer.indexOf(old, begin);\n      if (end == -1) {\n        convertedString.append(buffer.substring(begin));\n        break;\n      }\n      if (end == 0) {\n        convertedString.append(newString);\n      } else {\n        convertedString.append(buffer.substring(begin, end));\n        convertedString.append(newString);\n      }\n      begin = end + oldLength;\n    }\n    return convertedString.toString();\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to enforce the foreign\n     * key constraints for <code>relationship<\/code>.\n     * \n     * @param relationship\n     *            the relationship, as represented by EOF\n     * @return the array of SQL statements\n     */\n    public NSArray foreignKeyConstraintStatementsForRelationship(EORelationship relationship) {\n        NSArray superResults;\n        NSMutableArray results;\n        int count;\n        int i;\n        EOSQLExpression expression;\n\n        results = new NSMutableArray();\n        superResults = super.foreignKeyConstraintStatementsForRelationship(relationship);\n\n        count = superResults.count();\n        for (i = 0; i < count; i++) {\n            expression = (EOSQLExpression) superResults.objectAtIndex(i);\n            String s = expression.statement();\n            s = replaceStringByStringInString(\") INITIALLY DEFERRED\", \") DEFERRABLE INITIALLY DEFERRED\", s);\n            expression.setStatement(s);\n            results.addObject(expression);\n            // timc 2006-11-06 check for enableIdentifierQuoting\n            String tableNameWithoutSchemaName = externalNameForEntityWithoutSchema(relationship.entity());\n            String tableName = expression.sqlStringForSchemaObjectName(expression.entity().externalName());\n            s = replaceStringByStringInString(\"ALTER TABLE \" + tableNameWithoutSchemaName, \"ALTER TABLE \" + tableName, s);\n            expression.setStatement(s);\n            NSArray columnNames = ((NSArray) relationship.sourceAttributes().valueForKey(\"columnName\"));\n            StringBuffer sbColumnNames = new StringBuffer();\n            for (int j = 0; j < columnNames.count(); j++) {\n                sbColumnNames.append((j == 0 ? \"\" : \", \") + expression.sqlStringForSchemaObjectName((String) columnNames.objectAtIndex(j)));\n            }\n            String indexName = externalNameForEntityWithoutSchema(relationship.entity()) + \"_\" + columnNames.componentsJoinedByString(\"_\") + \"_idx\";\n            results.addObject(createExpression(expression.entity(), \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"( \" + sbColumnNames.toString() + \" )\"));\n        }\n        return results;\n    }","id":11922,"modified_method":"/**\n   * Generates the PostgreSQL-specific SQL statements to enforce the foreign\n   * key constraints for <code>relationship<\/code>.\n   * \n   * @param relationship\n   *            the relationship, as represented by EOF\n   * @return the array of SQL statements\n   */\n  @Override\n  public NSArray foreignKeyConstraintStatementsForRelationship(EORelationship relationship) {\n    NSArray<EOSQLExpression> superResults = super.foreignKeyConstraintStatementsForRelationship(relationship);\n    NSMutableArray<PostgresqlExpression> results = new NSMutableArray<PostgresqlExpression>();\n\n    for (EOSQLExpression expression : superResults) {\n      String s = expression.statement();\n      s = replaceStringByStringInString(\") INITIALLY DEFERRED\", \") DEFERRABLE INITIALLY DEFERRED\", s);\n      expression.setStatement(s);\n      results.addObject(expression);\n      // timc 2006-11-06 check for enableIdentifierQuoting\n      String tableNameWithoutSchemaName = externalNameForEntityWithoutSchema(relationship.entity());\n      String tableName = expression.sqlStringForSchemaObjectName(expression.entity().externalName());\n      s = replaceStringByStringInString(\"ALTER TABLE \" + tableNameWithoutSchemaName, \"ALTER TABLE \" + tableName, s);\n      expression.setStatement(s);\n      NSArray<String> columnNames = ((NSArray<String>) relationship.sourceAttributes().valueForKey(\"columnName\"));\n      StringBuilder sbColumnNames = new StringBuilder();\n      for (int j = 0; j < columnNames.count(); j++) {\n        sbColumnNames.append((j == 0 ? \"\" : \", \") + expression.sqlStringForSchemaObjectName(columnNames.objectAtIndex(j)));\n      }\n      String indexName = externalNameForEntityWithoutSchema(relationship.entity()) + \"_\" + columnNames.componentsJoinedByString(\"_\") + \"_idx\";\n      results.addObject(createExpression(expression.entity(), \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"( \" + sbColumnNames.toString() + \" )\"));\n    }\n    return results;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String schemaCreationScriptForEntities(NSArray allEntities, NSDictionary options)\n    {\n/* 741*/        StringBuffer result = new StringBuffer();\n/* 744*/        if(options == null)\n/* 745*/            options = NSDictionary.EmptyDictionary;\n/* 747*/        NSArray statements = schemaCreationStatementsForEntities(allEntities, options);\n/* 748*/        int i = 0;\n/* 748*/        for(int count = statements.count(); i < count; i++)\n/* 749*/            appendExpressionToScript((EOSQLExpression)statements.objectAtIndex(i), result);\n\n/* 751*/        return new String(result);\n    }","id":11923,"modified_method":"@Override\n  public String schemaCreationScriptForEntities(NSArray<EOEntity> allEntities, NSDictionary<String, String> options) {\n    StringBuffer result = new StringBuffer();\n    if (options == null) {\n      options = NSDictionary.EmptyDictionary;\n    }\n    NSArray<EOSQLExpression> statements = schemaCreationStatementsForEntities(allEntities, options);\n    for (EOSQLExpression statement : statements) {\n      appendExpressionToScript(statement, result);\n    }\n\n    return result.toString();\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Quote table name if necessary\n     */\n    public NSArray createTableStatementsForEntityGroup(NSArray entityGroup) {\n\t\tNSMutableSet columnNames = new NSMutableSet();\n\t\tStringBuffer aStatement = new StringBuffer(128);\n\t\tif (entityGroup != null && entityGroup.count() > 0) {\n\t\t\tEOSQLExpression sqlExpr = _expressionForEntity((EOEntity) entityGroup.objectAtIndex(0));\n\t\t\tfor (Iterator entityIterator = entityGroup.iterator(); entityIterator.hasNext();) {\n\t\t\t\tEOEntity entity = (EOEntity) entityIterator.next();\n\t\t\t\tIterator attributeIterator = entity.attributes().iterator();\n\t\t\t\twhile (attributeIterator.hasNext()) {\n\t\t\t\t\tEOAttribute attribute = (EOAttribute) attributeIterator.next();\n\t\t\t\t\tString columnName = attribute.columnName();\n\t\t\t\t\tif (!attribute.isDerived() && !attribute.isFlattened() && columnName != null && columnName.length() > 0 && !columnNames.contains(columnName)) {\n\t\t\t\t\t\tsqlExpr.appendItemToListString(_columnCreationClauseForAttribute(attribute), aStatement);\n\t\t\t\t\t\tcolumnNames.addObject(columnName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new NSArray(_expressionForString((new StringBuilder()).append(\"CREATE TABLE \").append(this.formatTableName(((EOEntity) entityGroup.objectAtIndex(0)).externalName())).append(\" (\").append(aStatement.toString()).append(\")\").toString()));\n\t\t}\n\t\treturn new NSArray();\n\t}","id":11924,"modified_method":"/**\n   * Quote table name if necessary\n   */\n  @Override\n  public NSArray createTableStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n    NSMutableSet<String> columnNames = new NSMutableSet<String>();\n    StringBuffer aStatement = new StringBuffer(128);\n    if (entityGroup != null && entityGroup.count() > 0) {\n      EOSQLExpression sqlExpr = _expressionForEntity(entityGroup.objectAtIndex(0));\n      for (EOEntity entity : entityGroup) {\n        for (EOAttribute attribute : entity.attributes()) {\n          String columnName = attribute.columnName();\n          if (!attribute.isDerived() && !attribute.isFlattened() && columnName != null && columnName.length() > 0 && !columnNames.contains(columnName)) {\n            sqlExpr.appendItemToListString(_columnCreationClauseForAttribute(attribute), aStatement);\n            columnNames.addObject(columnName);\n          }\n        }\n      }\n      return new NSArray(_expressionForString((new StringBuilder()).append(\"CREATE TABLE \").append(this.formatTableName((entityGroup.objectAtIndex(0))\n          .externalName())).append(\" (\").append(aStatement.toString()).append(\")\").toString()));\n    }\n    return NSArray.EmptyArray;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray statementsToRenameColumnNamed(String columnName, String tableName, String newName, NSDictionary nsdictionary) {\n      return new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" rename column \" + formatColumnName(columnName) + \" to \" + formatColumnName(newName)));\n    }","id":11925,"modified_method":"@Override\n  public NSArray statementsToRenameColumnNamed(String columnName, String tableName, String newName, NSDictionary nsdictionary) {\n    return new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName)\n        + \" rename column \" + formatColumnName(columnName) + \" to \" + formatColumnName(newName)));\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToDeleteColumnNamed(String columnName, String tableName, NSDictionary options) {\n    \treturn new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" drop column \" + formatTableName(columnName) + \" cascade\"));\n    }","id":11926,"modified_method":"@Override\n  public NSArray statementsToDeleteColumnNamed(String columnName, String tableName, NSDictionary options) {\n    return new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName)\n        + \" drop column \" + formatTableName(columnName) + \" cascade\"));\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToConvertColumnType(String columnName, String tableName, ColumnTypes oldType, ColumnTypes newType, NSDictionary options) {\n      EOAttribute attr = new EOAttribute();\n      attr.setName(columnName);\n      attr.setColumnName(columnName);\n      attr.setExternalType(newType.name());\n      attr.setScale(newType.scale());\n      attr.setPrecision(newType.precision());\n      attr.setWidth(newType.width());\n\n      String usingClause = \"\";\n      String columnTypeString = columnTypeStringForAttribute(attr);\n      if (options != null) {\n        String usingExpression = (String) options.objectForKey(PostgresqlSynchronizationFactory.USING_KEY);\n        if (usingExpression != null) {\n          usingClause = \" USING \" + usingExpression;\n        }\n      }\n      NSArray statements = new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" type \" + columnTypeString + usingClause));\n      return statements;\n    }","id":11927,"modified_method":"@Override\n  public NSArray statementsToConvertColumnType(String columnName, String tableName, ColumnTypes oldType, ColumnTypes newType, NSDictionary options) {\n    EOAttribute attr = new EOAttribute();\n    attr.setName(columnName);\n    attr.setColumnName(columnName);\n    attr.setExternalType(newType.name());\n    attr.setScale(newType.scale());\n    attr.setPrecision(newType.precision());\n    attr.setWidth(newType.width());\n\n    String usingClause = \"\";\n    String columnTypeString = columnTypeStringForAttribute(attr);\n    if (options != null) {\n      String usingExpression = (String) options.objectForKey(PostgresqlSynchronizationFactory.USING_KEY);\n      if (usingExpression != null) {\n        usingClause = \" USING \" + usingExpression;\n      }\n    }\n    NSArray<EOSQLExpression> statements = new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName)\n        + \" alter column \" + formatColumnName(columnName) + \" type \" + columnTypeString + usingClause));\n    return statements;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to drop tables.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray dropTableStatementsForEntityGroup(NSArray entityGroup) {\n        NSMutableArray results = new NSMutableArray();\n        int count = entityGroup.count();\n        for (int i = 0; i < count; i++) {\n            EOEntity entity = (EOEntity) entityGroup.objectAtIndex(i);\n            // timc 2006-11-06 create result here so we can check for\n            // enableIdentifierQuoting while building the statement\n            PostgresqlExpression result = new PostgresqlExpression(entity);\n            String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n            if(entityUsesSeparateTable(entity)) {\n                result.setStatement(\"DROP TABLE \" + tableName + \" CASCADE\");\n                results.addObject(result);\n            }\n        }\n        return results;\n    }","id":11928,"modified_method":"/**\n   * Generates the PostgreSQL-specific SQL statements to drop tables.\n   * \n   * @param entityGroup\n   *            an array of <code>EOEntity<\/code> objects\n   * @return the array of SQL statements\n   */\n  @Override\n  public NSArray dropTableStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n    NSMutableArray<PostgresqlExpression> results = new NSMutableArray<PostgresqlExpression>();\n    for (EOEntity entity : entityGroup) {\n      // timc 2006-11-06 create result here so we can check for\n      // enableIdentifierQuoting while building the statement\n      PostgresqlExpression result = new PostgresqlExpression(entity);\n      String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n      if (entityUsesSeparateTable(entity)) {\n        result.setStatement(\"DROP TABLE \" + tableName + \" CASCADE\");\n        results.addObject(result);\n      }\n    }\n    return results;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to enforce primary key\n     * constraints.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray primaryKeyConstraintStatementsForEntityGroup(NSArray entityGroup) {\n        EOEntity entity;\n        int count;\n        int i;\n        NSMutableArray results;\n        NSArray priKeyAttributes;\n        EOAttribute priKeyAttribute;\n        int priKeyAttributeCount;\n        int j;\n\n        results = new NSMutableArray();\n        count = entityGroup.count();\n        for (i = 0; i < count; i++) {\n            entity = (EOEntity) entityGroup.objectAtIndex(i);\n            if (!entityUsesSeparateTable(entity))\n                continue;\n            // timc 2006-11-06 create result here so we can check for\n            // enableIdentifierQuoting while building the statement\n            PostgresqlExpression result = new PostgresqlExpression(entity);\n            String constraintName = result.sqlStringForSchemaObjectName(externalNameForEntityWithoutSchema(entity) + \"_pk\");\n            String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n            StringBuffer statement = new StringBuffer(\"ALTER TABLE \");\n            statement.append(tableName);\n            statement.append(\" ADD CONSTRAINT \");\n            statement.append(constraintName);\n            statement.append(\" PRIMARY KEY (\");\n            priKeyAttributes = entity.primaryKeyAttributes();\n            priKeyAttributeCount = priKeyAttributes.count();\n            for (j = 0; j < priKeyAttributeCount; j++) {\n                priKeyAttribute = (EOAttribute) priKeyAttributes.objectAtIndex(j);\n                String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n                statement.append(attributeName);\n                if (j < priKeyAttributeCount - 1) {\n                    statement.append(\", \");\n                } else {\n                    statement.append(\")\");\n                }\n            }\n            result.setStatement(statement.toString());\n            results.addObject(result);\n        }\n        return results;\n    }","id":11929,"modified_method":"/**\n   * Generates the PostgreSQL-specific SQL statements to enforce primary key\n   * constraints.\n   * \n   * @param entityGroup\n   *            an array of <code>EOEntity<\/code> objects\n   * @return the array of SQL statements\n   */\n  @Override\n  public NSArray primaryKeyConstraintStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n    NSMutableArray<PostgresqlExpression> results = new NSMutableArray<PostgresqlExpression>();\n    NSArray<EOAttribute> priKeyAttributes;\n    EOAttribute priKeyAttribute;\n\n    for (EOEntity entity : entityGroup) {\n      if (!entityUsesSeparateTable(entity)) {\n        continue;\n      }\n      // timc 2006-11-06 create result here so we can check for\n      // enableIdentifierQuoting while building the statement\n      PostgresqlExpression result = new PostgresqlExpression(entity);\n      String constraintName = result.sqlStringForSchemaObjectName(externalNameForEntityWithoutSchema(entity) + \"_pk\");\n      String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n      StringBuilder statement = new StringBuilder(\"ALTER TABLE \");\n      statement.append(tableName);\n      statement.append(\" ADD CONSTRAINT \");\n      statement.append(constraintName);\n      statement.append(\" PRIMARY KEY (\");\n      priKeyAttributes = entity.primaryKeyAttributes();\n      int priKeyAttributeCount = priKeyAttributes.count();\n      for (int j = 0; j < priKeyAttributeCount; j++) {\n        priKeyAttribute = priKeyAttributes.objectAtIndex(j);\n        String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n        statement.append(attributeName);\n        if (j < priKeyAttributeCount - 1) {\n          statement.append(\", \");\n        } else {\n          statement.append(\")\");\n        }\n      }\n      result.setStatement(statement.toString());\n      results.addObject(result);\n    }\n    return results;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray schemaCreationStatementsForEntities(NSArray allEntities, NSDictionary options)\n    {\n/* 879*/        NSMutableArray result = new NSMutableArray();\n/* 880*/        if(allEntities == null || allEntities.count() == 0)\n/* 881*/            return result;\n/* 883*/        if(options == null)\n/* 884*/            options = NSDictionary.EmptyDictionary;\n/* 889*/        NSDictionary connectionDictionary = ((EOEntity)allEntities.lastObject()).model().connectionDictionary();\n/* 892*/        boolean createDatabase = _NSDictionaryUtilities.boolValueForKeyDefault(options, \"createDatabase\", false);\n/* 893*/        boolean dropDatabase = _NSDictionaryUtilities.boolValueForKeyDefault(options, \"dropDatabase\", false);\n/* 895*/        if(createDatabase || dropDatabase)\n        {\n/* 896*/            boolean adminCommentsNeeded = false;\n/* 897*/            NSArray dropDatabaseStatements = null;\n/* 898*/            NSArray createDatabaseStatements = null;\n/* 900*/            if(dropDatabase)\n            {\n/* 901*/                dropDatabaseStatements = dropDatabaseStatementsForConnectionDictionary(connectionDictionary, null);\n/* 903*/                if(dropDatabaseStatements == null)\n/* 904*/                    dropDatabaseStatements = new NSArray(_expressionForString(\"/* The 'Drop Database' option is unavailable. */\"));\n/* 907*/                else\n/* 907*/                    adminCommentsNeeded = true;\n            }\n/* 911*/            if(createDatabase)\n            {\n/* 912*/                createDatabaseStatements = createDatabaseStatementsForConnectionDictionary(connectionDictionary, null);\n/* 914*/                if(createDatabaseStatements == null)\n/* 915*/                    createDatabaseStatements = new NSArray(_expressionForString(\"/* The 'Create Database' option is unavailable. */\"));\n/* 918*/                else\n/* 918*/                    adminCommentsNeeded = true;\n            }\n/* 922*/            if(adminCommentsNeeded)\n/* 923*/                result.addObject(_expressionForString(\"/* connect as an administrator */\"));\n/* 926*/            if(dropDatabaseStatements != null)\n/* 927*/                result.addObjectsFromArray(dropDatabaseStatements);\n/* 930*/            if(createDatabaseStatements != null)\n/* 931*/                result.addObjectsFromArray(createDatabaseStatements);\n/* 934*/            if(adminCommentsNeeded)\n/* 935*/                result.addObject(_expressionForString(\"/* connect as the user from the connection dictionary */\"));\n        }\n/* 939*/        if(_NSDictionaryUtilities.boolValueForKeyDefault(options, \"dropPrimaryKeySupport\", true))\n        {\n/* 940*/            NSArray entityGroups = primaryKeyEntityGroupsForEntities(allEntities);\n/* 941*/            result.addObjectsFromArray(dropPrimaryKeySupportStatementsForEntityGroups(entityGroups));\n        }\n/* 944*/        if(_NSDictionaryUtilities.boolValueForKeyDefault(options, \"dropTables\", true))\n        {\n/* 945*/            NSArray entityGroups = tableEntityGroupsForEntities(allEntities);\n/* 946*/            result.addObjectsFromArray(dropTableStatementsForEntityGroups(entityGroups));\n        }\n/* 949*/        if(_NSDictionaryUtilities.boolValueForKeyDefault(options, \"createTables\", true))\n        {\n/* 950*/            NSArray entityGroups = tableEntityGroupsForEntities(allEntities);\n/* 951*/            result.addObjectsFromArray(createTableStatementsForEntityGroups(entityGroups));\n        }\n/* 954*/        if(_NSDictionaryUtilities.boolValueForKeyDefault(options, \"createPrimaryKeySupport\", true))\n        {\n/* 955*/            NSArray entityGroups = primaryKeyEntityGroupsForEntities(allEntities);\n/* 956*/            result.addObjectsFromArray(primaryKeySupportStatementsForEntityGroups(entityGroups));\n                }\n/* 959*/        if(_NSDictionaryUtilities.boolValueForKeyDefault(options, \"primaryKeyConstraints\", true))\n                {\n/* 960*/            NSArray entityGroups = tableEntityGroupsForEntities(allEntities);\n/* 961*/            result.addObjectsFromArray(primaryKeyConstraintStatementsForEntityGroups(entityGroups));\n                }\n/* 964*/        if(_NSDictionaryUtilities.boolValueForKeyDefault(options, \"foreignKeyConstraints\", false))\n                {\n/* 965*/            NSArray entityGroups = tableEntityGroupsForEntities(allEntities);\n/* 966*/            int i = 0;\n/* 966*/            for(int iCount = entityGroups.count(); i < iCount; i++)\n/* 967*/                result.addObjectsFromArray(_foreignKeyConstraintStatementsForEntityGroup((NSArray)entityGroups.objectAtIndex(i)));\n\n                }\n/* 970*/        return result;\n            }","id":11930,"modified_method":"@Override\n  public NSArray<EOSQLExpression> schemaCreationStatementsForEntities(NSArray<EOEntity> allEntities, NSDictionary<String, String> options) {\n    NSMutableArray<EOSQLExpression> result = new NSMutableArray<EOSQLExpression>();\n    if (allEntities == null || allEntities.count() == 0) {\n      return result;\n    }\n    if (options == null) {\n      options = NSDictionary.EmptyDictionary;\n    }\n    NSDictionary connectionDictionary = allEntities.lastObject().model().connectionDictionary();\n    boolean createDatabase = _NSDictionaryUtilities.boolValueForKeyDefault(options, \"createDatabase\", false);\n    boolean dropDatabase = _NSDictionaryUtilities.boolValueForKeyDefault(options, \"dropDatabase\", false);\n    if (createDatabase || dropDatabase) {\n      boolean adminCommentsNeeded = false;\n      NSArray<EOSQLExpression> dropDatabaseStatements = null;\n      NSArray<EOSQLExpression> createDatabaseStatements = null;\n      if (dropDatabase) {\n        dropDatabaseStatements = dropDatabaseStatementsForConnectionDictionary(connectionDictionary, null);\n        if (dropDatabaseStatements == null) {\n          dropDatabaseStatements = new NSArray<EOSQLExpression>(_expressionForString(\"/* The 'Drop Database' option is unavailable. */\"));\n        } else {\n          adminCommentsNeeded = true;\n        }\n      }\n      if (createDatabase) {\n        createDatabaseStatements = createDatabaseStatementsForConnectionDictionary(connectionDictionary, null);\n        if (createDatabaseStatements == null) {\n          createDatabaseStatements = new NSArray<EOSQLExpression>(_expressionForString(\"/* The 'Create Database' option is unavailable. */\"));\n        } else {\n          adminCommentsNeeded = true;\n        }\n      }\n      if (adminCommentsNeeded) {\n        result.addObject(_expressionForString(\"/* connect as an administrator */\"));\n      }\n      if (dropDatabaseStatements != null) {\n        result.addObjectsFromArray(dropDatabaseStatements);\n      }\n      if (createDatabaseStatements != null) {\n        result.addObjectsFromArray(createDatabaseStatements);\n      }\n      if (adminCommentsNeeded) {\n        result.addObject(_expressionForString(\"/* connect as the user from the connection dictionary */\"));\n      }\n    }\n    if (_NSDictionaryUtilities.boolValueForKeyDefault(options, \"dropPrimaryKeySupport\", true)) {\n      NSArray<NSArray<EOEntity>> entityGroups = primaryKeyEntityGroupsForEntities(allEntities);\n      result.addObjectsFromArray(dropPrimaryKeySupportStatementsForEntityGroups(entityGroups));\n    }\n    if (_NSDictionaryUtilities.boolValueForKeyDefault(options, \"dropTables\", true)) {\n      NSArray<NSArray<EOEntity>> entityGroups = tableEntityGroupsForEntities(allEntities);\n      result.addObjectsFromArray(dropTableStatementsForEntityGroups(entityGroups));\n    }\n    if (_NSDictionaryUtilities.boolValueForKeyDefault(options, \"createTables\", true)) {\n      NSArray<NSArray<EOEntity>> entityGroups = tableEntityGroupsForEntities(allEntities);\n      result.addObjectsFromArray(createTableStatementsForEntityGroups(entityGroups));\n    }\n    if (_NSDictionaryUtilities.boolValueForKeyDefault(options, \"createPrimaryKeySupport\", true)) {\n      NSArray<NSArray<EOEntity>> entityGroups = primaryKeyEntityGroupsForEntities(allEntities);\n      result.addObjectsFromArray(primaryKeySupportStatementsForEntityGroups(entityGroups));\n    }\n    if (_NSDictionaryUtilities.boolValueForKeyDefault(options, \"primaryKeyConstraints\", true)) {\n      NSArray<NSArray<EOEntity>> entityGroups = tableEntityGroupsForEntities(allEntities);\n      result.addObjectsFromArray(primaryKeyConstraintStatementsForEntityGroups(entityGroups));\n    }\n    if (_NSDictionaryUtilities.boolValueForKeyDefault(options, \"foreignKeyConstraints\", false)) {\n      NSArray<NSArray<EOEntity>> entityGroups = tableEntityGroupsForEntities(allEntities);\n      for (NSArray<EOEntity> entityGroup : entityGroups) {\n        result.addObjectsFromArray(_foreignKeyConstraintStatementsForEntityGroup(entityGroup));\n      }\n    }\n    return result;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray statementsToModifyColumnNullRule(String columnName, String tableName, boolean allowsNull, NSDictionary nsdictionary) {\n      NSArray statements;\n      if (allowsNull) {\n        statements = new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" drop not null\"));\n      } else {\n        statements = new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" set not null\"));\n      }\n      return statements;\n    }","id":11931,"modified_method":"@Override\n  public NSArray statementsToModifyColumnNullRule(String columnName, String tableName, boolean allowsNull, NSDictionary nsdictionary) {\n    NSArray<EOSQLExpression> statements;\n    if (allowsNull) {\n      statements = new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName)\n          + \" alter column \" + formatColumnName(columnName) + \" drop not null\"));\n    } else {\n      statements = new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName)\n          + \" alter column \" + formatColumnName(columnName) + \" set not null\"));\n    }\n    return statements;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to drop the primary key\n     * support.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray dropPrimaryKeySupportStatementsForEntityGroup(NSArray entityGroup) {\n        NSMutableSet sequenceNames = new NSMutableSet();\n        NSMutableArray results = new NSMutableArray();\n        int count = entityGroup.count();\n        for (int i = 0; i < count; i++) {\n            EOEntity entity = (EOEntity) entityGroup.objectAtIndex(i);\n            String sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n            if (!sequenceNames.containsObject(sequenceName)) {\n                sequenceNames.addObject(sequenceName);\n                String sql = \"DROP SEQUENCE \" + sequenceName + \" CASCADE\";\n                results.addObject(createExpression(entity, sql));\n            }\n        }\n        return results;\n    }","id":11932,"modified_method":"/**\n   * Generates the PostgreSQL-specific SQL statements to drop the primary key\n   * support.\n   * \n   * @param entityGroup\n   *            an array of <code>EOEntity<\/code> objects\n   * @return the array of SQL statements\n   */\n  @Override\n  public NSArray dropPrimaryKeySupportStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n    NSMutableSet<String> sequenceNames = new NSMutableSet<String>();\n    NSMutableArray<PostgresqlExpression> results = new NSMutableArray<PostgresqlExpression>();\n    for (EOEntity entity : entityGroup) {\n      String sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n      if (!sequenceNames.containsObject(sequenceName)) {\n        sequenceNames.addObject(sequenceName);\n        String sql = \"DROP SEQUENCE \" + sequenceName + \" CASCADE\";\n        results.addObject(createExpression(entity, sql));\n      }\n    }\n    return results;\n  }","commit_id":"9ef24685a0baaf16743a0e3fa5a719f42780a4fe","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique primary key value\n   */\n  @Override\n  public NSArray<NSDictionary<String, Object>> newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n    \n    EOAttribute attribute = entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray<NSDictionary<String, Object>> results = new NSMutableArray<NSDictionary<String, Object>>(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n    \n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuilder sql = new StringBuilder();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary row;\n            while ((row = channel.fetchRow()) != null) {\n              Enumeration pksEnum = row.allValues().objectEnumerator();\n              while (pksEnum.hasMoreElements()) {\n                Number pkObj = (Number)pksEnum.nextElement();\n                Number pk;\n                if (isIntType) {\n                  pk = Integer.valueOf(pkObj.intValue());\n                }\n                else {\n                  pk = Long.valueOf(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary<String, Object>(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary<String, Object> row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray<EOSQLExpression> statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray<EOEntity>(entity));\n            int stmCount = statements.count();\n            for (int i = 0; i < stmCount; i++) {\n              channel.evaluateExpression(statements.objectAtIndex(i));\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n    \n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n    \n    return results;\n  }","id":11933,"modified_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique primary key value\n   */\n  @Override\n  public NSArray<NSDictionary<String, Object>> newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n    \n    EOAttribute attribute = entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray<NSDictionary<String, Object>> results = new NSMutableArray<NSDictionary<String, Object>>(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n    \n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuilder sql = new StringBuilder();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary<String, Object> row;\n            while ((row = channel.fetchRow()) != null) {\n              Enumeration pksEnum = row.allValues().objectEnumerator();\n              while (pksEnum.hasMoreElements()) {\n                Number pkObj = (Number)pksEnum.nextElement();\n                Number pk;\n                if (isIntType) {\n                  pk = Integer.valueOf(pkObj.intValue());\n                }\n                else {\n                  pk = Long.valueOf(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary<String, Object>(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary<String, Object> row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray<EOSQLExpression> statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray<EOEntity>(entity));\n            int stmCount = statements.count();\n            for (int i = 0; i < stmCount; i++) {\n              channel.evaluateExpression(statements.objectAtIndex(i));\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n    \n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n    \n    return results;\n  }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * \n   * @return jdbcInfo dictionary\n   */\n  @Override\n  public NSDictionary jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n//    try {\n//      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n//      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n//      fos.write(jdbcInfoS.getBytes());\n//      fos.close();\n//    }\n//    catch(Exception e) {\n//      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n//    }\n\n    NSDictionary jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if(shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n      \n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      }\n      finally {\n        try {\n          jdbcInfoStream.close();\n        }\n        catch (IOException e) {\n          // ignore\n        }\n      }\n    } else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","id":11934,"modified_method":"/**\n   * This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * \n   * @return jdbcInfo dictionary\n   */\n  @Override\n  public NSDictionary<String, Object> jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n//    try {\n//      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n//      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n//      fos.write(jdbcInfoS.getBytes());\n//      fos.close();\n//    }\n//    catch(Exception e) {\n//      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n//    }\n\n    NSDictionary<String, Object> jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if(shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n      \n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary<String, Object>) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      }\n      finally {\n        try {\n          jdbcInfoStream.close();\n        }\n        catch (IOException e) {\n          // ignore\n        }\n      }\n    } else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to drop the primary key\n     * support.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray dropPrimaryKeySupportStatementsForEntityGroup(NSArray entityGroup) {\n        if (entityGroup == null) {\n            return NSArray.EmptyArray;\n        }\n        NSMutableSet sequenceNames = new NSMutableSet();\n        NSMutableArray results = new NSMutableArray();\n        int count = entityGroup.count();\n        for (int i = 0; i < count; i++) {\n            EOEntity entity = (EOEntity) entityGroup.objectAtIndex(i);\n            String sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n            if (!sequenceNames.containsObject(sequenceName)) {\n                sequenceNames.addObject(sequenceName);\n                String sql = \"DROP SEQUENCE \" + sequenceName + \" CASCADE\";\n                results.addObject(createExpression(entity, sql));\n            }\n        }\n        return results;\n    }","id":11935,"modified_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to drop the primary key\n     * support.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    @Override\n    public NSArray<EOSQLExpression> dropPrimaryKeySupportStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n        if (entityGroup == null) {\n            return NSArray.EmptyArray;\n        }\n        NSMutableSet<String> sequenceNames = new NSMutableSet<String>();\n        NSMutableArray<EOSQLExpression> results = new NSMutableArray<EOSQLExpression>();\n        for (EOEntity entity : entityGroup) {\n            String sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n            if (!sequenceNames.containsObject(sequenceName)) {\n                sequenceNames.addObject(sequenceName);\n                String sql = \"DROP SEQUENCE \" + sequenceName + \" CASCADE\";\n                results.addObject(createExpression(entity, sql));\n            }\n        }\n        return results;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to enforce primary key\n     * constraints.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray primaryKeyConstraintStatementsForEntityGroup(NSArray entityGroup) {\n        EOEntity entity;\n        int count;\n        int i;\n        NSMutableArray results;\n        NSArray priKeyAttributes;\n        EOAttribute priKeyAttribute;\n        int priKeyAttributeCount;\n        int j;\n\n        results = new NSMutableArray();\n        count = entityGroup.count();\n        for (i = 0; i < count; i++) {\n            entity = (EOEntity) entityGroup.objectAtIndex(i);\n            if (!entityUsesSeparateTable(entity))\n                continue;\n            // timc 2006-11-06 create result here so we can check for\n            // enableIdentifierQuoting while building the statement\n            PostgresqlExpression result = new PostgresqlExpression(entity);\n            String constraintName = result.sqlStringForSchemaObjectName(externalNameForEntityWithoutSchema(entity) + \"_pk\");\n            String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n            StringBuilder statement = new StringBuilder(\"ALTER TABLE \");\n            statement.append(tableName);\n            statement.append(\" ADD CONSTRAINT \");\n            statement.append(constraintName);\n            statement.append(\" PRIMARY KEY (\");\n            priKeyAttributes = entity.primaryKeyAttributes();\n            priKeyAttributeCount = priKeyAttributes.count();\n            for (j = 0; j < priKeyAttributeCount; j++) {\n                priKeyAttribute = (EOAttribute) priKeyAttributes.objectAtIndex(j);\n                String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n                statement.append(attributeName);\n                if (j < priKeyAttributeCount - 1) {\n                    statement.append(\", \");\n                } else {\n                    statement.append(\")\");\n                }\n            }\n            result.setStatement(statement.toString());\n            results.addObject(result);\n        }\n        return results;\n    }","id":11936,"modified_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to enforce primary key\n     * constraints.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    @Override\n    public NSArray<EOSQLExpression> primaryKeyConstraintStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n        NSMutableArray<EOSQLExpression> results = new NSMutableArray<EOSQLExpression>();\n        for (EOEntity entity : entityGroup) {\n            if (!entityUsesSeparateTable(entity))\n                continue;\n            // timc 2006-11-06 create result here so we can check for\n            // enableIdentifierQuoting while building the statement\n            PostgresqlExpression result = new PostgresqlExpression(entity);\n            String constraintName = result.sqlStringForSchemaObjectName(externalNameForEntityWithoutSchema(entity) + \"_pk\");\n            String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n            StringBuilder statement = new StringBuilder(\"ALTER TABLE \");\n            statement.append(tableName);\n            statement.append(\" ADD CONSTRAINT \");\n            statement.append(constraintName);\n            statement.append(\" PRIMARY KEY (\");\n            NSArray<EOAttribute> priKeyAttributes = entity.primaryKeyAttributes();\n            int priKeyAttributeCount = priKeyAttributes.count();\n            for (int j = 0; j < priKeyAttributeCount; j++) {\n                EOAttribute priKeyAttribute = priKeyAttributes.objectAtIndex(j);\n                String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n                statement.append(attributeName);\n                if (j < priKeyAttributeCount - 1) {\n                    statement.append(\", \");\n                } else {\n                    statement.append(\")\");\n                }\n            }\n            result.setStatement(statement.toString());\n            results.addObject(result);\n        }\n        return results;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray statementsToModifyColumnNullRule(String columnName, String tableName, boolean allowsNull, NSDictionary nsdictionary) {\n      NSArray statements;\n      if (allowsNull) {\n        statements = new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" drop not null\"));\n      } else {\n        statements = new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" set not null\"));\n      }\n      return statements;\n    }","id":11937,"modified_method":"@Override\n    public NSArray<EOSQLExpression> statementsToModifyColumnNullRule(String columnName, String tableName, boolean allowsNull, NSDictionary nsdictionary) {\n      NSArray<EOSQLExpression> statements;\n      if (allowsNull) {\n        statements = new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" drop not null\"));\n      } else {\n        statements = new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" set not null\"));\n      }\n      return statements;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns true if Entity Modeler is running the operation on this model.\n     * \n     * @param model the model to check\n     * @return true if Entity Modeler is running\n     */\n    protected boolean isInEntityModeler(EOModel model) {\n      boolean inEntityModeler = false;\n      if (model != null) {\n        NSDictionary userInfo = model.userInfo();\n        NSDictionary entityModelerDict = (NSDictionary) userInfo.objectForKey(\"_EntityModeler\");\n        if (entityModelerDict != null) {\n          Boolean inEntityModelerBoolean = (Boolean)entityModelerDict.objectForKey(\"inEntityModeler\");\n          if (inEntityModelerBoolean != null && inEntityModelerBoolean.booleanValue()) {\n            inEntityModeler = inEntityModelerBoolean.booleanValue();\n          }\n        }\n      }\n      return inEntityModeler;\n    }","id":11938,"modified_method":"/**\n     * Returns true if Entity Modeler is running the operation on this model.\n     * \n     * @param model the model to check\n     * @return true if Entity Modeler is running\n     */\n    protected boolean isInEntityModeler(EOModel model) {\n      boolean inEntityModeler = false;\n      if (model != null) {\n        NSDictionary<String, Object> userInfo = model.userInfo();\n        NSDictionary entityModelerDict = (NSDictionary) userInfo.objectForKey(\"_EntityModeler\");\n        if (entityModelerDict != null) {\n          Boolean inEntityModelerBoolean = (Boolean)entityModelerDict.objectForKey(\"inEntityModeler\");\n          if (inEntityModelerBoolean != null && inEntityModelerBoolean.booleanValue()) {\n            inEntityModeler = inEntityModelerBoolean.booleanValue();\n          }\n        }\n      }\n      return inEntityModeler;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Quote table name if necessary\n     */\n    public NSArray createTableStatementsForEntityGroup(NSArray entityGroup) {\n\t\tNSMutableSet columnNames = new NSMutableSet();\n\t\tStringBuffer aStatement = new StringBuffer(128);\n\t\tif (entityGroup != null && entityGroup.count() > 0) {\n\t\t\tEOSQLExpression sqlExpr = _expressionForEntity((EOEntity) entityGroup.objectAtIndex(0));\n\t\t\tfor (Iterator entityIterator = entityGroup.iterator(); entityIterator.hasNext();) {\n\t\t\t\tEOEntity entity = (EOEntity) entityIterator.next();\n\t\t\t\tIterator attributeIterator = entity.attributes().iterator();\n\t\t\t\twhile (attributeIterator.hasNext()) {\n\t\t\t\t\tEOAttribute attribute = (EOAttribute) attributeIterator.next();\n\t\t\t\t\tString columnName = attribute.columnName();\n\t\t\t\t\tif (!attribute.isDerived() && !attribute.isFlattened() && columnName != null && columnName.length() > 0 && !columnNames.contains(columnName)) {\n\t\t\t\t\t\tsqlExpr.appendItemToListString(_columnCreationClauseForAttribute(attribute), aStatement);\n\t\t\t\t\t\tcolumnNames.addObject(columnName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new NSArray(_expressionForString((new StringBuilder()).append(\"CREATE TABLE \").append(this.formatTableName(((EOEntity) entityGroup.objectAtIndex(0)).externalName())).append(\" (\").append(aStatement.toString()).append(\")\").toString()));\n\t\t}\n\t\treturn NSArray.EmptyArray;\n\t}","id":11939,"modified_method":"/**\n     * Quote table name if necessary\n     */\n    @Override\n    public NSArray<EOSQLExpression> createTableStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n\t\tNSMutableSet<String> columnNames = new NSMutableSet<String>();\n\t\tStringBuffer aStatement = new StringBuffer(128);\n\t\tif (entityGroup != null && entityGroup.count() > 0) {\n\t\t\tEOSQLExpression sqlExpr = _expressionForEntity(entityGroup.objectAtIndex(0));\n\t\t\tfor (EOEntity entity : entityGroup) {\n\t\t\t\tfor (EOAttribute attribute : entity.attributes()) {\n\t\t\t\t\tString columnName = attribute.columnName();\n\t\t\t\t\tif (!attribute.isDerived() && !attribute.isFlattened() && columnName != null && columnName.length() > 0 && !columnNames.contains(columnName)) {\n\t\t\t\t\t\tsqlExpr.appendItemToListString(_columnCreationClauseForAttribute(attribute), aStatement);\n\t\t\t\t\t\tcolumnNames.addObject(columnName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new NSArray<EOSQLExpression>(_expressionForString(new StringBuilder().append(\"CREATE TABLE \").append(this.formatTableName(entityGroup.objectAtIndex(0).externalName())).append(\" (\").append(aStatement.toString()).append(\")\").toString()));\n\t\t}\n\t\treturn NSArray.EmptyArray;\n\t}","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToDeleteColumnNamed(String columnName, String tableName, NSDictionary options) {\n    \treturn new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" drop column \" + formatTableName(columnName) + \" cascade\"));\n    }","id":11940,"modified_method":"@Override\n    public NSArray<EOSQLExpression> statementsToDeleteColumnNamed(String columnName, String tableName, NSDictionary options) {\n    \treturn new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName) + \" drop column \" + formatTableName(columnName) + \" cascade\"));\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToRenameTableNamed(String tableName, String newName, NSDictionary options) {\n    \treturn new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" rename to \" + formatTableName(newName)));\n    }","id":11941,"modified_method":"@Override\n    public NSArray<EOSQLExpression> statementsToRenameTableNamed(String tableName, String newName, NSDictionary options) {\n    \treturn new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName) + \" rename to \" + formatTableName(newName)));\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray statementsToRenameColumnNamed(String columnName, String tableName, String newName, NSDictionary nsdictionary) {\n      return new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" rename column \" + formatColumnName(columnName) + \" to \" + formatColumnName(newName)));\n    }","id":11942,"modified_method":"@Override\n    public NSArray<EOSQLExpression> statementsToRenameColumnNamed(String columnName, String tableName, String newName, NSDictionary nsdictionary) {\n      return new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName) + \" rename column \" + formatColumnName(columnName) + \" to \" + formatColumnName(newName)));\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to create the primary\n     * key support.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray primaryKeySupportStatementsForEntityGroup(NSArray entityGroup) {\n        EOEntity entity;\n        int count;\n        int i;\n        NSMutableArray results;\n        NSArray priKeyAttributes;\n        EOAttribute priKeyAttribute;\n        String sequenceName;\n\n        NSMutableSet sequenceNames = new NSMutableSet();\n        results = new NSMutableArray();\n        count = entityGroup.count();\n        for (i = 0; i < count; i++) {\n            entity = (EOEntity) entityGroup.objectAtIndex(i);\n            priKeyAttributes = entity.primaryKeyAttributes();\n            if (priKeyAttributes.count() == 1) {\n                priKeyAttribute = (EOAttribute) priKeyAttributes.objectAtIndex(0);\n                \n                // Q: Don't create a sequence for non number primary keys\n                if (priKeyAttribute.adaptorValueType() != EOAttribute.AdaptorNumberType) {\n                \tcontinue;\n                }\n                String sql;\n\n                sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n                if (!sequenceNames.containsObject(sequenceName)) {\n                    sequenceNames.addObject(sequenceName);\n                    // timc 2006-11-06 create result here so we can check for\n                    // enableIdentifierQuoting while building the statement\n                    PostgresqlExpression result = new PostgresqlExpression(entity);\n                    String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n                    String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n                    sql = \"CREATE SEQUENCE \" + sequenceName;\n                    results.addObject(createExpression(entity, sql));\n\n                    sql = \"CREATE TEMP TABLE EOF_TMP_TABLE AS SELECT SETVAL('\" + sequenceName + \"', (SELECT MAX(\" + attributeName + \") FROM \" + tableName + \"))\";\n                    results.addObject(createExpression(entity, sql));\n                    \n                    // In Entity Modeler, we want to skip over the drop statement\n                    if (!isInEntityModeler(entity.model())) {\n                      sql = \"DROP TABLE EOF_TMP_TABLE\";\n                      results.addObject(createExpression(entity, sql));\n                    }\n\n                    sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + attributeName + \" SET DEFAULT nextval( '\" + sequenceName + \"' )\";\n                    results.addObject(createExpression(entity, sql));\n                }\n            }\n        }\n        return results;\n    }","id":11943,"modified_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to create the primary\n     * key support.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    @Override\n    public NSArray<EOSQLExpression> primaryKeySupportStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n        NSMutableSet<String> sequenceNames = new NSMutableSet<String>();\n        NSMutableArray<EOSQLExpression> results = new NSMutableArray<EOSQLExpression>();\n        for (EOEntity entity : entityGroup) {\n            NSArray<EOAttribute> priKeyAttributes = entity.primaryKeyAttributes();\n            if (priKeyAttributes.count() == 1) {\n                EOAttribute priKeyAttribute = priKeyAttributes.objectAtIndex(0);\n                \n                // Q: Don't create a sequence for non number primary keys\n                if (priKeyAttribute.adaptorValueType() != EOAttribute.AdaptorNumberType) {\n                \tcontinue;\n                }\n\n                String sequenceName = PostgresqlPlugIn._sequenceNameForEntity(entity);\n                if (!sequenceNames.containsObject(sequenceName)) {\n                    sequenceNames.addObject(sequenceName);\n                    // timc 2006-11-06 create result here so we can check for\n                    // enableIdentifierQuoting while building the statement\n                    PostgresqlExpression result = new PostgresqlExpression(entity);\n                    String attributeName = result.sqlStringForAttribute(priKeyAttribute);\n                    String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n\n                    String sql = \"CREATE SEQUENCE \" + sequenceName;\n                    results.addObject(createExpression(entity, sql));\n\n                    sql = \"CREATE TEMP TABLE EOF_TMP_TABLE AS SELECT SETVAL('\" + sequenceName + \"', (SELECT MAX(\" + attributeName + \") FROM \" + tableName + \"))\";\n                    results.addObject(createExpression(entity, sql));\n                    \n                    // In Entity Modeler, we want to skip over the drop statement\n                    if (!isInEntityModeler(entity.model())) {\n                      sql = \"DROP TABLE EOF_TMP_TABLE\";\n                      results.addObject(createExpression(entity, sql));\n                    }\n\n                    sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + attributeName + \" SET DEFAULT nextval( '\" + sequenceName + \"' )\";\n                    results.addObject(createExpression(entity, sql));\n                }\n            }\n        }\n        return results;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to enforce the foreign\n     * key constraints for <code>relationship<\/code>.\n     * \n     * @param relationship\n     *            the relationship, as represented by EOF\n     * @return the array of SQL statements\n     */\n    public NSArray foreignKeyConstraintStatementsForRelationship(EORelationship relationship) {\n        NSArray superResults;\n        NSMutableArray results;\n        int count;\n        int i;\n        EOSQLExpression expression;\n\n        results = new NSMutableArray();\n        superResults = super.foreignKeyConstraintStatementsForRelationship(relationship);\n\n        count = superResults.count();\n        for (i = 0; i < count; i++) {\n            expression = (EOSQLExpression) superResults.objectAtIndex(i);\n            String s = expression.statement();\n            s = replaceStringByStringInString(\") INITIALLY DEFERRED\", \") DEFERRABLE INITIALLY DEFERRED\", s);\n            expression.setStatement(s);\n            results.addObject(expression);\n            // timc 2006-11-06 check for enableIdentifierQuoting\n            String tableNameWithoutSchemaName = externalNameForEntityWithoutSchema(relationship.entity());\n            String tableName = expression.sqlStringForSchemaObjectName(expression.entity().externalName());\n            s = replaceStringByStringInString(\"ALTER TABLE \" + tableNameWithoutSchemaName, \"ALTER TABLE \" + tableName, s);\n            expression.setStatement(s);\n            NSArray columnNames = ((NSArray) relationship.sourceAttributes().valueForKey(\"columnName\"));\n            StringBuilder sbColumnNames = new StringBuilder();\n            for (int j = 0; j < columnNames.count(); j++) {\n                sbColumnNames.append((j == 0 ? \"\" : \", \") + expression.sqlStringForSchemaObjectName((String) columnNames.objectAtIndex(j)));\n            }\n            String indexName = externalNameForEntityWithoutSchema(relationship.entity()) + \"_\" + columnNames.componentsJoinedByString(\"_\") + \"_idx\";\n            results.addObject(createExpression(expression.entity(), \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"( \" + sbColumnNames.toString() + \" )\"));\n        }\n        return results;\n    }","id":11944,"modified_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to enforce the foreign\n     * key constraints for <code>relationship<\/code>.\n     * \n     * @param relationship\n     *            the relationship, as represented by EOF\n     * @return the array of SQL statements\n     */\n    @Override\n    public NSArray<EOSQLExpression> foreignKeyConstraintStatementsForRelationship(EORelationship relationship) {\n        NSMutableArray<EOSQLExpression> results = new NSMutableArray<EOSQLExpression>();\n        NSArray<EOSQLExpression> superResults = super.foreignKeyConstraintStatementsForRelationship(relationship);\n        for (EOSQLExpression expression : superResults) {\n            String s = expression.statement();\n            s = replaceStringByStringInString(\") INITIALLY DEFERRED\", \") DEFERRABLE INITIALLY DEFERRED\", s);\n            expression.setStatement(s);\n            results.addObject(expression);\n            // timc 2006-11-06 check for enableIdentifierQuoting\n            String tableNameWithoutSchemaName = externalNameForEntityWithoutSchema(relationship.entity());\n            String tableName = expression.sqlStringForSchemaObjectName(expression.entity().externalName());\n            s = replaceStringByStringInString(\"ALTER TABLE \" + tableNameWithoutSchemaName, \"ALTER TABLE \" + tableName, s);\n            expression.setStatement(s);\n            NSArray<String> columnNames = ((NSArray<String>) relationship.sourceAttributes().valueForKey(\"columnName\"));\n            StringBuilder sbColumnNames = new StringBuilder();\n            for (int j = 0; j < columnNames.count(); j++) {\n                sbColumnNames.append((j == 0 ? \"\" : \", \") + expression.sqlStringForSchemaObjectName(columnNames.objectAtIndex(j)));\n            }\n            String indexName = externalNameForEntityWithoutSchema(relationship.entity()) + \"_\" + columnNames.componentsJoinedByString(\"_\") + \"_idx\";\n            results.addObject(createExpression(expression.entity(), \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"( \" + sbColumnNames.toString() + \" )\"));\n        }\n        return results;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to drop tables.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    public NSArray dropTableStatementsForEntityGroup(NSArray entityGroup) {\n        if (entityGroup == null) {\n            return NSArray.EmptyArray;\n        }\n        NSMutableArray results = new NSMutableArray();\n        int count = entityGroup.count();\n        for (int i = 0; i < count; i++) {\n            EOEntity entity = (EOEntity) entityGroup.objectAtIndex(i);\n            // timc 2006-11-06 create result here so we can check for\n            // enableIdentifierQuoting while building the statement\n            PostgresqlExpression result = new PostgresqlExpression(entity);\n            String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n            if(entityUsesSeparateTable(entity)) {\n                result.setStatement(\"DROP TABLE \" + tableName + \" CASCADE\");\n                results.addObject(result);\n            }\n        }\n        return results;\n    }","id":11945,"modified_method":"/**\n     * Generates the PostgreSQL-specific SQL statements to drop tables.\n     * \n     * @param entityGroup\n     *            an array of <code>EOEntity<\/code> objects\n     * @return the array of SQL statements\n     */\n    @Override\n    public NSArray<EOSQLExpression> dropTableStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n        if (entityGroup == null) {\n            return NSArray.EmptyArray;\n        }\n        NSMutableArray<EOSQLExpression> results = new NSMutableArray<EOSQLExpression>();\n        for (EOEntity entity : entityGroup) {\n            // timc 2006-11-06 create result here so we can check for\n            // enableIdentifierQuoting while building the statement\n            PostgresqlExpression result = new PostgresqlExpression(entity);\n            String tableName = result.sqlStringForSchemaObjectName(entity.externalName());\n            if(entityUsesSeparateTable(entity)) {\n                result.setStatement(\"DROP TABLE \" + tableName + \" CASCADE\");\n                results.addObject(result);\n            }\n        }\n        return results;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToConvertColumnType(String columnName, String tableName, ColumnTypes oldType, ColumnTypes newType, NSDictionary options) {\n      EOAttribute attr = new EOAttribute();\n      attr.setName(columnName);\n      attr.setColumnName(columnName);\n      attr.setExternalType(newType.name());\n      attr.setScale(newType.scale());\n      attr.setPrecision(newType.precision());\n      attr.setWidth(newType.width());\n\n      String usingClause = \"\";\n      String columnTypeString = columnTypeStringForAttribute(attr);\n      if (options != null) {\n        String usingExpression = (String) options.objectForKey(PostgresqlSynchronizationFactory.USING_KEY);\n        if (usingExpression != null) {\n          usingClause = \" USING \" + usingExpression;\n        }\n      }\n      NSArray statements = new NSArray(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" type \" + columnTypeString + usingClause));\n      return statements;\n    }","id":11946,"modified_method":"@Override\n    public NSArray<EOSQLExpression> statementsToConvertColumnType(String columnName, String tableName, ColumnTypes oldType, ColumnTypes newType, NSDictionary options) {\n      EOAttribute attr = new EOAttribute();\n      attr.setName(columnName);\n      attr.setColumnName(columnName);\n      attr.setExternalType(newType.name());\n      attr.setScale(newType.scale());\n      attr.setPrecision(newType.precision());\n      attr.setWidth(newType.width());\n\n      String usingClause = \"\";\n      String columnTypeString = columnTypeStringForAttribute(attr);\n      if (options != null) {\n        String usingExpression = (String) options.objectForKey(PostgresqlSynchronizationFactory.USING_KEY);\n        if (usingExpression != null) {\n          usingClause = \" USING \" + usingExpression;\n        }\n      }\n      NSArray<EOSQLExpression> statements = new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(tableName) + \" alter column \" + formatColumnName(columnName) + \" type \" + columnTypeString + usingClause));\n      return statements;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray _foreignKeyConstraintStatementsForEntityGroup(NSArray group) {\n        if (group == null)\n            return NSArray.EmptyArray;\n        NSMutableArray result = new NSMutableArray();\n        NSMutableSet generatedStatements = new NSMutableSet();\n        int i = 0;\n        for (int groupCount = group.count(); i < groupCount; i++) {\n            EOEntity currentEntity = (EOEntity) group.objectAtIndex(i);\n            if (currentEntity.externalName() != null) {\n                NSArray relationships = currentEntity.relationships();\n                int relCount = relationships.count();\n                for (int j = 0; j < relCount; j++) {\n                    EORelationship currentRelationship = ((EORelationship) relationships.objectAtIndex(j));\n                    if (_shouldGenerateForeignKeyConstraints(currentRelationship)) {\n                        NSArray statements = foreignKeyConstraintStatementsForRelationship(currentRelationship);\n                        if (!generatedStatements.containsObject(statements.valueForKey(\"statement\"))) {\n                            result.addObjectsFromArray(statements);\n                            generatedStatements.addObject(statements.valueForKey(\"statement\"));\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","id":11947,"modified_method":"@Override\n    public NSArray<EOSQLExpression> _foreignKeyConstraintStatementsForEntityGroup(NSArray<EOEntity> entityGroup) {\n        if (entityGroup == null)\n            return NSArray.EmptyArray;\n        NSMutableArray<EOSQLExpression> result = new NSMutableArray<EOSQLExpression>();\n        NSMutableSet<String> generatedStatements = new NSMutableSet<String>();\n        for (EOEntity currentEntity : entityGroup) {\n            if (currentEntity.externalName() != null) {\n                NSArray<EORelationship> relationships = currentEntity.relationships();\n                for (EORelationship currentRelationship : relationships) {\n                    if (_shouldGenerateForeignKeyConstraints(currentRelationship)) {\n                        NSArray<EOSQLExpression> statements = foreignKeyConstraintStatementsForRelationship(currentRelationship);\n                        if (!generatedStatements.containsObject(statements.valueForKey(\"statement\"))) {\n                            result.addObjectsFromArray(statements);\n                            generatedStatements.addObject(statements.valueForKey(\"statement\"));\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public NSArray statementsToInsertColumnForAttribute(EOAttribute attribute, NSDictionary options) {\n      String clause = _columnCreationClauseForAttribute(attribute);\n      return new NSArray(_expressionForString(\"alter table \" + formatTableName(attribute.entity().externalName()) + \" add \" + clause));\n    }","id":11948,"modified_method":"@Override\n    public NSArray<EOSQLExpression> statementsToInsertColumnForAttribute(EOAttribute attribute, NSDictionary options) {\n      String clause = _columnCreationClauseForAttribute(attribute);\n      return new NSArray<EOSQLExpression>(_expressionForString(\"alter table \" + formatTableName(attribute.entity().externalName()) + \" add \" + clause));\n    }","commit_id":"76f4e7f96bdb10ad44edf3197700073fa28df9b1","url":"https://github.com/wocommunity/wonder"},{"original_method":"private static String loadText(VirtualFile file) {\n    if (file.getFileType().isBinary()) {\n      try {\n        return \"Binary file, base64 encoded: \" + Base64Converter.encode(file.contentsToByteArray());\n      }\n      catch (IOException e) {\n        return \"Cannot load binary file content\";\n      }\n    }\n    else {\n      return LoadTextUtil.loadText(file).toString();\n    }\n  }","id":11949,"modified_method":"private static byte[] getBytes(VirtualFile file) {\n    try {\n      return file.contentsToByteArray();\n    }\n    catch (IOException e) {\n      return getBytes(MessageFormat.format(ERROR_MESSAGE_PATTERN, e.getMessage()));\n    }\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Attachment(@NotNull VirtualFile file) {\n    this(file.getPresentableUrl(), loadText(file));\n  }","id":11950,"modified_method":"public Attachment(@NotNull VirtualFile file) {\n    myPath = file.getPresentableUrl();\n    myBytes = getBytes(file);\n    myDisplayText = file.getFileType().isBinary() ? \"File is binary\" : LoadTextUtil.loadText(file).toString();\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Attachment(String path, String content) {\n    myPath = path;\n    myContent = content;\n  }","id":11951,"modified_method":"public Attachment(String path, String content) {\n    myPath = path;\n    myDisplayText = content;\n    myBytes = getBytes(content);\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AttachmentsTabForm() {\n    myFileTextArea.getTextComponent().setEditable(false);\n    myFileTextArea.setTitle(DiagnosticBundle.message(\"error.dialog.filecontent.title\"));\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final Attachment selection = myTable.getSelectedObject();\n        if (selection != null) {\n          LabeledTextComponent.setText(myFileTextArea.getTextComponent(), selection.getContent(), true);\n        }\n        else {\n          LabeledTextComponent.setText(myFileTextArea.getTextComponent(), null, true);\n        }\n      }\n    });\n    myTable.registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final int[] selectedRows = myTable.getSelectedRows();\n        boolean aggregateValue = true;\n        for (final int selectedRow : selectedRows) {\n          if (selectedRow < 0 || !myTable.isCellEditable(selectedRow, 0)) {\n            return;\n          }\n          final Boolean value = (Boolean)myTable.getValueAt(selectedRow, 0);\n          aggregateValue &= value == null || value.booleanValue();\n        }\n        for (int selectedRow : selectedRows) {\n          myTable.setValueAt(aggregateValue ? Boolean.FALSE : Boolean.TRUE, selectedRow, 0);\n        }\n        myTable.repaint();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_FOCUSED);\n  }","id":11952,"modified_method":"public AttachmentsTabForm() {\n    myFileTextArea.getTextComponent().setEditable(false);\n    myFileTextArea.setTitle(DiagnosticBundle.message(\"error.dialog.filecontent.title\"));\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        if (e.getValueIsAdjusting()) {\n          return;\n        }\n        final Attachment selection = myTable.getSelectedObject();\n        if (selection != null) {\n          LabeledTextComponent.setText(myFileTextArea.getTextComponent(), selection.getDisplayText(), true);\n        }\n        else {\n          LabeledTextComponent.setText(myFileTextArea.getTextComponent(), null, true);\n        }\n      }\n    });\n    myTable.registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final int[] selectedRows = myTable.getSelectedRows();\n        boolean aggregateValue = true;\n        for (final int selectedRow : selectedRows) {\n          if (selectedRow < 0 || !myTable.isCellEditable(selectedRow, 0)) {\n            return;\n          }\n          final Boolean value = (Boolean)myTable.getValueAt(selectedRow, 0);\n          aggregateValue &= value == null || value.booleanValue();\n        }\n        for (int selectedRow : selectedRows) {\n          myTable.setValueAt(aggregateValue ? Boolean.FALSE : Boolean.TRUE, selectedRow, 0);\n        }\n        myTable.repaint();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_FOCUSED);\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static HttpURLConnection post (String url, Map<String,String> params) throws IOException, MalformedURLException {\n    HttpURLConnection connection = (HttpURLConnection) new URL (url).openConnection();\n    connection.setReadTimeout(10 * 1000);\n    connection.setConnectTimeout(10 * 1000);\n    connection.setRequestMethod(HTTP_POST);\n    connection.setDoInput(true);\n    connection.setDoOutput(true);\n    connection.setRequestProperty(HTTP_CONTENT_TYPE, HTTP_WWW_FORM);\n\n    StringBuffer buffer = new StringBuffer();\n    for (String name : params.keySet()) {\n      if (params.containsKey(name) && params.get(name) != null)\n        buffer.append(name + \"=\" + URLEncoder.encode(params.get(name), ENCODE) + POST_DELIMETER);\n      else\n        throw new IllegalArgumentException(name);\n    }\n    connection.setRequestProperty(HTTP_CONTENT_LENGTH, Integer.toString(buffer.length()));\n    connection.getOutputStream().write(buffer.toString().getBytes());\n    return connection;\n  }","id":11953,"modified_method":"private static HttpURLConnection post (String url, List<Pair<String,String>> params) throws IOException, MalformedURLException {\n    HttpURLConnection connection = (HttpURLConnection) new URL (url).openConnection();\n    connection.setReadTimeout(10 * 1000);\n    connection.setConnectTimeout(10 * 1000);\n    connection.setRequestMethod(HTTP_POST);\n    connection.setDoInput(true);\n    connection.setDoOutput(true);\n    connection.setRequestProperty(HTTP_CONTENT_TYPE, HTTP_WWW_FORM);\n\n    StringBuilder buffer = new StringBuilder();\n    for (Pair<String, String> param : params) {\n      if (StringUtil.isNotEmpty(param.first) && StringUtil.isNotEmpty(param.second))\n        buffer.append(param.first + \"=\" + URLEncoder.encode(param.second, ENCODE) + POST_DELIMETER);\n      else\n        throw new IllegalArgumentException(param.toString());\n    }\n    connection.setRequestProperty(HTTP_CONTENT_LENGTH, Integer.toString(buffer.length()));\n    connection.getOutputStream().write(buffer.toString().getBytes());\n    return connection;\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int postNewThread (String userName, String password, ErrorBean error,\n                                   String compilationTimestamp)\n          throws IOException, NoSuchEAPUserException, InternalEAPException {\n    @NonNls Map<String,String> params = new HashMap<String, String>();\n    params.put(\"username\", userName);\n    params.put(\"pwd\", password);\n    params.put(\"_title\", MessageFormat.format(THREAD_SUBJECT,\n                                              error.getLastAction() == null ? error.getExceptionClass() :\n                                              error.getLastAction() + \", \" + error.getExceptionClass()));\n    ApplicationInfoEx appInfo =\n      (ApplicationInfoEx) ApplicationManager.getApplication().getComponent(\n        ApplicationInfo.class);\n\n    params.put(\"_build\", appInfo.getBuild().asString());\n    params.put(\"_description\",\n               (compilationTimestamp != null ? (\"Build time: \" + compilationTimestamp + \"\\n\") : \"\") +\n               error.getDescription() + \"\\n\\n\" + error.getStackTrace());\n\n    String jdkVersion = SystemProperties.getJavaVersion();\n    String jdkVendor = SystemProperties.getJavaVmVendor();\n\n    if (jdkVendor.indexOf(SUN) != -1) {\n      if (jdkVersion.equals(JDK_1_4_2))\n        jdkVersion = \"10\";\n      else if (jdkVersion.equals(JDK_1_4_1))\n        jdkVersion = \"7\";\n      else if (jdkVersion.equals(JDK_1_4_0_02))\n        jdkVersion = \"9\";\n      else if (jdkVersion.equals(JDK_1_4_0_01))\n        jdkVersion = \"8\";\n      else if (jdkVersion.equals(JDK_1_4_0))\n        jdkVersion = \"6\";\n      else if (jdkVersion.equals(JDK_1_3_1_01))\n        jdkVersion = \"5\";\n      else if (jdkVersion.equals(JDK_1_3_1))\n        jdkVersion = \"4\";\n      else if (jdkVersion.equals(JDK_1_3_0))\n        jdkVersion = \"3\";\n      else if (jdkVersion.equals(JDK_1_2_2))\n        jdkVersion = \"2\";\n      else\n        jdkVersion = \"1\";\n    } else\n      jdkVersion = \"1\";\n\n    params.put(\"_jdk\", jdkVersion);\n\n    String os = error.getOs();\n    if (os == null)\n      os = \"\";\n\n    if (os.indexOf(WINDOWS_XP) != -1)\n      os = \"4\";\n    else if (os.indexOf(WINDOWS_2000) != -1 || os.indexOf(WINDOWS_NT) != -1)\n      os = \"3\";\n    else if (os.indexOf(WINDOWS_95) != -1 || os.indexOf(WINDOWS_98) != -1 || os.indexOf(WINDOWS_ME) != -1)\n      os = \"2\";\n    else if (os.indexOf(SOLARIS) != -1)\n      os = \"7\";\n    else if (os.indexOf(MAC_OS_X) != -1)\n      os = \"6\";\n    else if (os.indexOf(LINUX) != -1)\n      os = \"5\";\n    else\n      os = \"1\";\n    params.put(\"_os\", os);\n\n    params.put(\"_product\", ApplicationNamesInfo.getInstance().getProductName());\n\n    HttpURLConnection connection = post(NEW_THREAD_URL, params);\n    int responce = connection.getResponseCode();\n    switch (responce) {\n      case HttpURLConnection.HTTP_OK:\n        break;\n      case HttpURLConnection.HTTP_BAD_REQUEST:\n      case HttpURLConnection.HTTP_NOT_FOUND:\n        // user not found\n        throw new NoSuchEAPUserException(userName);\n      default:\n        // some problems\n        throw new InternalEAPException(DiagnosticBundle.message(\"error.http.result.code\", responce));\n    }\n\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    InputStream is = connection.getInputStream();\n\n    int c;\n    while ((c = is.read()) != -1) {\n      baos.write (c);\n    }\n    int threadId;\n\n    try {\n      threadId = Integer.valueOf(baos.toString().trim()).intValue();\n    } catch (NumberFormatException ex) {\n      // Tibor!!!! :-E\n      throw new InternalEAPException(DiagnosticBundle.message(\"error.itn.returns.wrong.data\"));\n    }\n\n    return threadId;\n  }","id":11954,"modified_method":"public static int postNewThread (String userName, String password, ErrorBean error,\n                                   String compilationTimestamp)\n          throws IOException, NoSuchEAPUserException, InternalEAPException {\n    @NonNls List<Pair<String,String>> params = new ArrayList<Pair<String, String>>();\n    params.add(Pair.create(\"username\", userName));\n    params.add(Pair.create(\"pwd\", password));\n    params.add(Pair.create(\"_title\", MessageFormat.format(THREAD_SUBJECT,\n                                              error.getLastAction() == null ? error.getExceptionClass() :\n                                              error.getLastAction() + \", \" + error.getExceptionClass())));\n    ApplicationInfoEx appInfo =\n      (ApplicationInfoEx) ApplicationManager.getApplication().getComponent(\n        ApplicationInfo.class);\n\n    params.add(Pair.create(\"_build\", appInfo.getBuild().asString()));\n    params.add(Pair.create(\"_description\",\n               (compilationTimestamp != null ? (\"Build time: \" + compilationTimestamp + \"\\n\") : \"\") +\n               error.getDescription() + \"\\n\\n\" + error.getStackTrace()));\n\n    String jdkVersion = SystemProperties.getJavaVersion();\n    String jdkVendor = SystemProperties.getJavaVmVendor();\n\n    if (jdkVendor.indexOf(SUN) != -1) {\n      if (jdkVersion.equals(JDK_1_4_2))\n        jdkVersion = \"10\";\n      else if (jdkVersion.equals(JDK_1_4_1))\n        jdkVersion = \"7\";\n      else if (jdkVersion.equals(JDK_1_4_0_02))\n        jdkVersion = \"9\";\n      else if (jdkVersion.equals(JDK_1_4_0_01))\n        jdkVersion = \"8\";\n      else if (jdkVersion.equals(JDK_1_4_0))\n        jdkVersion = \"6\";\n      else if (jdkVersion.equals(JDK_1_3_1_01))\n        jdkVersion = \"5\";\n      else if (jdkVersion.equals(JDK_1_3_1))\n        jdkVersion = \"4\";\n      else if (jdkVersion.equals(JDK_1_3_0))\n        jdkVersion = \"3\";\n      else if (jdkVersion.equals(JDK_1_2_2))\n        jdkVersion = \"2\";\n      else\n        jdkVersion = \"1\";\n    } else\n      jdkVersion = \"1\";\n\n    params.add(Pair.create(\"_jdk\", jdkVersion));\n\n    String os = error.getOs();\n    if (os == null)\n      os = \"\";\n\n    if (os.indexOf(WINDOWS_XP) != -1)\n      os = \"4\";\n    else if (os.indexOf(WINDOWS_2000) != -1 || os.indexOf(WINDOWS_NT) != -1)\n      os = \"3\";\n    else if (os.indexOf(WINDOWS_95) != -1 || os.indexOf(WINDOWS_98) != -1 || os.indexOf(WINDOWS_ME) != -1)\n      os = \"2\";\n    else if (os.indexOf(SOLARIS) != -1)\n      os = \"7\";\n    else if (os.indexOf(MAC_OS_X) != -1)\n      os = \"6\";\n    else if (os.indexOf(LINUX) != -1)\n      os = \"5\";\n    else\n      os = \"1\";\n    params.add(Pair.create(\"_os\", os));\n\n    params.add(Pair.create(\"_product\", ApplicationNamesInfo.getInstance().getProductName()));\n\n    for (Attachment attachment : error.getAttachments()) {\n      params.add(Pair.create(\"_attachment_name\", attachment.getName()));\n      params.add(Pair.create(\"_attachment_value\", attachment.getEncodedBytes()));\n    }\n    \n    HttpURLConnection connection = post(NEW_THREAD_URL, params);\n    int responce = connection.getResponseCode();\n    switch (responce) {\n      case HttpURLConnection.HTTP_OK:\n        break;\n      case HttpURLConnection.HTTP_BAD_REQUEST:\n      case HttpURLConnection.HTTP_NOT_FOUND:\n        // user not found\n        throw new NoSuchEAPUserException(userName);\n      default:\n        // some problems\n        throw new InternalEAPException(DiagnosticBundle.message(\"error.http.result.code\", responce));\n    }\n\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    InputStream is = connection.getInputStream();\n\n    int c;\n    while ((c = is.read()) != -1) {\n      baos.write (c);\n    }\n    int threadId;\n\n    try {\n      threadId = Integer.valueOf(baos.toString().trim()).intValue();\n    } catch (NumberFormatException ex) {\n      // Tibor!!!! :-E\n      throw new InternalEAPException(DiagnosticBundle.message(\"error.itn.returns.wrong.data\"));\n    }\n\n    return threadId;\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean doSubmit(final IdeaLoggingEvent event,\n                               final Component parentComponent,\n                               final Consumer<SubmittedReportInfo> callback,\n                               final ErrorBean errorBean,\n                               final String description) {\n    final DataContext dataContext = DataManager.getInstance().getDataContext(parentComponent);\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n\n    final ErrorReportConfigurable errorReportConfigurable = ErrorReportConfigurable.getInstance();\n    if (!errorReportConfigurable.KEEP_ITN_PASSWORD &&\n        !StringUtil.isEmpty(errorReportConfigurable.ITN_LOGIN) &&\n        StringUtil.isEmpty(errorReportConfigurable.getPlainItnPassword())) {\n      final JetBrainsAccountDialog dlg = new JetBrainsAccountDialog(parentComponent);\n      dlg.show();\n      if (!dlg.isOK()) {\n        return false;\n      }\n    }\n\n    @NonNls String login = errorReportConfigurable.ITN_LOGIN;\n    @NonNls String password = errorReportConfigurable.getPlainItnPassword();\n    if (login.trim().length() == 0 && password.trim().length() == 0) {\n      login = \"idea_anonymous\";\n      password = \"guest\";\n    }\n\n    errorBean.setDescription(buildDescription(event, description));\n\n    ErrorReportSender.sendError(project, login, password, errorBean, new Consumer<Integer>() {\n      @SuppressWarnings({\"AssignmentToStaticFieldFromInstanceMethod\"})\n      @Override\n      public void consume(Integer threadId) {\n        previousExceptionThreadId = threadId;\n        wasException = true;\n        final SubmittedReportInfo reportInfo = new SubmittedReportInfo(URL_HEADER + threadId, String.valueOf(threadId),\n                                                        SubmittedReportInfo.SubmissionStatus.NEW_ISSUE);\n        callback.consume(reportInfo);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            StringBuilder text = new StringBuilder(\"<html>\");\n            final String url = IdeErrorsDialog.getUrl(reportInfo, true);\n            IdeErrorsDialog.appendSubmissionInformation(reportInfo, text, url);\n            text.append(\".\");\n            if (reportInfo.getStatus() != SubmittedReportInfo.SubmissionStatus.FAILED) {\n              text.append(\"<br/>\").append(DiagnosticBundle.message(\"error.report.gratitude\"));\n            }\n            text.append(\"<\/html>\");\n            NotificationType type = reportInfo.getStatus() == SubmittedReportInfo.SubmissionStatus.FAILED\n                                    ? NotificationType.ERROR\n                                    : NotificationType.INFORMATION;\n            NotificationListener listener = url != null ? new NotificationListener() {\n              @Override\n              public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n                BrowserUtil.launchBrowser(url);\n                notification.expire();\n              }\n            } : null;\n            ReportMessages.GROUP.createNotification(ReportMessages.ERROR_REPORT,\n                                                    text.toString(),\n                                                    type, listener).notify(project);\n          }\n        });\n      }\n    }, new Consumer<Exception>() {\n      @Override\n      public void consume(final Exception e) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            String msg;\n            if (e instanceof NoSuchEAPUserException) {\n              msg = DiagnosticBundle.message(\"error.report.authentication.failed\");\n            }\n            else if (e instanceof InternalEAPException) {\n              msg = DiagnosticBundle.message(\"error.report.posting.failed\", e.getMessage());\n            }\n            else {\n              msg = DiagnosticBundle.message(\"error.report.sending.failure\");\n            }\n            if (Messages.showYesNoDialog(parentComponent, msg,\n                                         ReportMessages.ERROR_REPORT, Messages.getErrorIcon()) != 0) {\n              callback.consume(new SubmittedReportInfo(null, \"0\", SubmittedReportInfo.SubmissionStatus.FAILED));\n            }\n            else {\n              if (e instanceof NoSuchEAPUserException) {\n                final JetBrainsAccountDialog dialog;\n                if (parentComponent.isShowing()) {\n                  dialog = new JetBrainsAccountDialog(parentComponent);\n                }\n                else {\n                  dialog = new JetBrainsAccountDialog(project);\n                }\n                dialog.show();\n              }\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                  doSubmit(event, parentComponent, callback, errorBean, description);\n                }\n              });\n            }\n          }\n        });\n      }\n    });\n    return true;\n  }","id":11955,"modified_method":"private static boolean doSubmit(final IdeaLoggingEvent event,\n                               final Component parentComponent,\n                               final Consumer<SubmittedReportInfo> callback,\n                               final ErrorBean errorBean,\n                               final String description) {\n    final DataContext dataContext = DataManager.getInstance().getDataContext(parentComponent);\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n\n    final ErrorReportConfigurable errorReportConfigurable = ErrorReportConfigurable.getInstance();\n    if (!errorReportConfigurable.KEEP_ITN_PASSWORD &&\n        !StringUtil.isEmpty(errorReportConfigurable.ITN_LOGIN) &&\n        StringUtil.isEmpty(errorReportConfigurable.getPlainItnPassword())) {\n      final JetBrainsAccountDialog dlg = new JetBrainsAccountDialog(parentComponent);\n      dlg.show();\n      if (!dlg.isOK()) {\n        return false;\n      }\n    }\n\n    @NonNls String login = errorReportConfigurable.ITN_LOGIN;\n    @NonNls String password = errorReportConfigurable.getPlainItnPassword();\n    if (login.trim().length() == 0 && password.trim().length() == 0) {\n      login = \"idea_anonymous\";\n      password = \"guest\";\n    }\n\n    errorBean.setDescription(buildDescription(event, description));\n    if (event.getData() instanceof LogMessageEx) {\n      errorBean.setAttachments(((LogMessageEx)event.getData()).getAttachments());\n    }\n\n    ErrorReportSender.sendError(project, login, password, errorBean, new Consumer<Integer>() {\n      @SuppressWarnings({\"AssignmentToStaticFieldFromInstanceMethod\"})\n      @Override\n      public void consume(Integer threadId) {\n        previousExceptionThreadId = threadId;\n        wasException = true;\n        final SubmittedReportInfo reportInfo = new SubmittedReportInfo(URL_HEADER + threadId, String.valueOf(threadId),\n                                                        SubmittedReportInfo.SubmissionStatus.NEW_ISSUE);\n        callback.consume(reportInfo);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            StringBuilder text = new StringBuilder(\"<html>\");\n            final String url = IdeErrorsDialog.getUrl(reportInfo, true);\n            IdeErrorsDialog.appendSubmissionInformation(reportInfo, text, url);\n            text.append(\".\");\n            if (reportInfo.getStatus() != SubmittedReportInfo.SubmissionStatus.FAILED) {\n              text.append(\"<br/>\").append(DiagnosticBundle.message(\"error.report.gratitude\"));\n            }\n            text.append(\"<\/html>\");\n            NotificationType type = reportInfo.getStatus() == SubmittedReportInfo.SubmissionStatus.FAILED\n                                    ? NotificationType.ERROR\n                                    : NotificationType.INFORMATION;\n            NotificationListener listener = url != null ? new NotificationListener() {\n              @Override\n              public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n                BrowserUtil.launchBrowser(url);\n                notification.expire();\n              }\n            } : null;\n            ReportMessages.GROUP.createNotification(ReportMessages.ERROR_REPORT,\n                                                    text.toString(),\n                                                    type, listener).notify(project);\n          }\n        });\n      }\n    }, new Consumer<Exception>() {\n      @Override\n      public void consume(final Exception e) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            String msg;\n            if (e instanceof NoSuchEAPUserException) {\n              msg = DiagnosticBundle.message(\"error.report.authentication.failed\");\n            }\n            else if (e instanceof InternalEAPException) {\n              msg = DiagnosticBundle.message(\"error.report.posting.failed\", e.getMessage());\n            }\n            else {\n              msg = DiagnosticBundle.message(\"error.report.sending.failure\");\n            }\n            if (Messages.showYesNoDialog(parentComponent, msg,\n                                         ReportMessages.ERROR_REPORT, Messages.getErrorIcon()) != 0) {\n              callback.consume(new SubmittedReportInfo(null, \"0\", SubmittedReportInfo.SubmissionStatus.FAILED));\n            }\n            else {\n              if (e instanceof NoSuchEAPUserException) {\n                final JetBrainsAccountDialog dialog;\n                if (parentComponent.isShowing()) {\n                  dialog = new JetBrainsAccountDialog(parentComponent);\n                }\n                else {\n                  dialog = new JetBrainsAccountDialog(project);\n                }\n                dialog.show();\n              }\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                  doSubmit(event, parentComponent, callback, errorBean, description);\n                }\n              });\n            }\n          }\n        });\n      }\n    });\n    return true;\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private IdeaLoggingEvent getEvent(final AbstractMessage logMessage) {\n      StringBuilder msg = new StringBuilder(logMessage.getMessage());\n      if (logMessage instanceof LogMessageEx) {\n        final List<Attachment> attachments = ((LogMessageEx)logMessage).getAttachments();\n        for (Attachment attachment : attachments) {\n          if (attachment.isIncluded()) {\n            int i = attachment.getPath().lastIndexOf(File.separator);\n            String name = i >= 0 ? attachment.getPath().substring(i + 1) : attachment.getPath();\n            msg.append(\"\\n+++++++++++++++++++++++++++++ Attachment: \").append(name).append(\"\\n\").append(attachment.getContent());\n          }\n        }\n        if (!attachments.isEmpty()) {\n          msg.append(\"\\n-----------------------------\\n\");\n        }\n      }\n      return new IdeaLoggingEvent(msg.toString(), logMessage.getThrowable());\n    }","id":11956,"modified_method":"private IdeaLoggingEvent getEvent(final AbstractMessage logMessage) {\n      if (logMessage instanceof LogMessageEx) {\n        return ((LogMessageEx)logMessage).toEvent();\n      }\n      return new IdeaLoggingEvent(logMessage.getMessage(), logMessage.getThrowable());\n    }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param aEvent\n   * @param title            text to show in Event Log tool window entry (it comes before 'more')\n   * @param notificationText text to show in the error balloon that is popped up automatically\n   */\n  public LogMessageEx(IdeaLoggingEvent aEvent, String title, String notificationText) {\n    super(aEvent);\n    myTitle = title;\n    myNotificationText = notificationText;\n  }","id":11957,"modified_method":"/**\n   * @param aEvent\n   * @param title            text to show in Event Log tool window entry (it comes before 'more')\n   * @param notificationText text to show in the error balloon that is popped up automatically\n   */\n  public LogMessageEx(IdeaLoggingEvent aEvent, String title, String notificationText) {\n    super(aEvent);\n    myEvent = aEvent;\n    myTitle = title;\n    myNotificationText = notificationText;\n  }","commit_id":"e42025b73fbece1d3fc4990252a289674de05016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public SAbstractConcept getOwner() {\n    SConceptId id = getRoleId().getConceptId();\n    ConceptDescriptor concept = ConceptRegistry.getInstance().getConceptDescriptor(id);\n    String fqName = concept.getConceptFqName();\n    return concept.isInterfaceConcept() ?\n        MetaAdapterFactory.getInterfaceConcept(id, fqName) :\n        MetaAdapterFactory.getConcept(id, fqName);\n  }","id":11958,"modified_method":"@NotNull\n  @Override\n  public SAbstractConcept getOwner() {\n    return ConceptFeatureHelper.getOwner(getRoleId());\n  }","commit_id":"e16b5cf49c7dd8806b58d058b4f189d64f099e64","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public SAbstractConcept getOwner() {\n    SConceptId id = getId().getConceptId();\n    ConceptDescriptor concept = ConceptRegistry.getInstance().getConceptDescriptor(id);\n    return concept.isInterfaceConcept() ?\n        MetaAdapterFactory.getInterfaceConcept(id, concept.getConceptFqName()) :\n        MetaAdapterFactory.getConcept(id, concept.getConceptFqName());\n  }","id":11959,"modified_method":"@NotNull\n  @Override\n  public SAbstractConcept getOwner() {\n    return ConceptFeatureHelper.getOwner(getId());\n  }","commit_id":"e16b5cf49c7dd8806b58d058b4f189d64f099e64","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public SAbstractConcept getOwner() {\n    SConceptId id = getRoleId().getConceptId();\n    ConceptDescriptor concept = ConceptRegistry.getInstance().getConceptDescriptor(id);\n    return concept.isInterfaceConcept() ?\n        MetaAdapterFactory.getInterfaceConcept(id, concept.getConceptFqName()) :\n        MetaAdapterFactory.getConcept(id, concept.getConceptFqName());\n  }","id":11960,"modified_method":"@NotNull\n  @Override\n  public SAbstractConcept getOwner() {\n    return ConceptFeatureHelper.getOwner(getRoleId());\n  }","commit_id":"e16b5cf49c7dd8806b58d058b4f189d64f099e64","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_933643154465852759(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11961,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_933643154465852759(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2681305894288382558(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11962,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2681305894288382558(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_8371596541809088644(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11963,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_8371596541809088644(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_4146564171992608883(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11964,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_4146564171992608883(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2681305894288486365(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11965,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2681305894288486365(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2681305894288275225(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11966,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2681305894288275225(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2163819695913701566(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11967,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_2163819695913701566(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_5857536350883030949(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      environment.getTracer().pushRule(getRuleNode());\n      try {\n        return doApply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n      } finally {\n        environment.getTracer().closeRule(getRuleNode());\n      }\n    }","id":11968,"modified_method":"@Override\n    public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n      final GeneratedMatchingPattern pattern = QueriesGenerated.patternRule_Condition_5857536350883030949(new PatternRuleContext(context, getRuleNode(), environment.getGenerator()));\n      if (pattern == null) {\n        return null;\n      }\n\n      return super.tryToApply(environment, context.subContext(pattern));\n    }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    GeneratedMatchingPattern pattern = checkIfApplicable(environment, context);\n    if (pattern == null) {\n      return null;\n    }\n    environment.getTracer().pushRule(getRuleNode());\n    try {\n      // the order of subContext is important - first pattern, then mapping name: subContext(Pattern) drops mapping name\n      return apply(context.subContext(pattern), environment.getEnvironment(context.getInput(), this));\n    } finally {\n      environment.getTracer().closeRule(getRuleNode());\n    }\n\n  }","id":11969,"modified_method":"@Override\n  public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    GeneratedMatchingPattern pattern = checkIfApplicable(environment, context);\n    if (pattern == null) {\n      return null;\n    }\n    // the order of subContext is important - first pattern, then mapping name: subContext(Pattern) drops mapping name\n    return super.tryToApply(environment, context.subContext(pattern));\n  }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  private Collection<SNode> apply(TemplateContext templateContext, @NotNull TemplateExecutionEnvironment environment) throws GenerationException {\n    final SNode inputNode = templateContext.getInput();\n    if (myRuleConsequence == null) {\n      throw new TemplateProcessingFailureException(myRuleNode, \"no rule consequence\", GeneratorUtil.describe(inputNode, \"input\"));\n    }\n\n    RuleConsequenceProcessor rcp = new RuleConsequenceProcessor(environment);\n    templateContext = templateContext.subContext(myRuleMappingName);\n    rcp.prepare(myRuleConsequence, templateContext);\n    return rcp.processRuleConsequence();\n  }","id":11970,"modified_method":"@Override\n  @NotNull\n  protected Collection<SNode> doApply(@NotNull TemplateContext templateContext, @NotNull TemplateExecutionEnvironment environment) throws GenerationException {\n    if (myRuleConsequence == null) {\n      throw new TemplateProcessingFailureException(myRuleNode, \"no rule consequence\", GeneratorUtil.describeInput(templateContext));\n    }\n\n    RuleConsequenceProcessor rcp = new RuleConsequenceProcessor(environment);\n    templateContext = templateContext.subContext(myRuleMappingName);\n    rcp.prepare(myRuleConsequence, templateContext);\n    return rcp.processRuleConsequence();\n  }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateReductionPatternRuleInterpreted(SNode ruleNode) {\n    myRuleNode = ruleNode;\n    mySNodePointer = new SNodePointer(myRuleNode);\n    myRuleMappingName = RuleUtil.getPatternReductionRuleLabel(ruleNode);\n    myRuleConsequence = RuleUtil.getPatternReductionRuleConsequence(ruleNode);\n    SNode patternNode = RuleUtil.getPatternReductionRulePatternNode(ruleNode);\n    myApplicableConcept = patternNode.getConcept().getQualifiedName();\n  }","id":11971,"modified_method":"public TemplateReductionPatternRuleInterpreted(SNode ruleNode) {\n    super(new SNodePointer(ruleNode), RuleUtil.getPatternReductionRulePatternNode(ruleNode).getConcept().getQualifiedName(), false);\n    myRuleNode = ruleNode;\n    myRuleMappingName = RuleUtil.getPatternReductionRuleLabel(ruleNode);\n    myRuleConsequence = RuleUtil.getPatternReductionRuleConsequence(ruleNode);\n  }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateReductionRuleInterpreted(SNode ruleNode) {\n    myRuleNode = ruleNode;\n    myApplicableConcept = GeneratorUtil.getConceptQualifiedName(RuleUtil.getBaseRuleApplicableConcept(ruleNode));\n    myMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n    myRuleConsequence = RuleUtil.getReductionRuleConsequence(ruleNode);\n    myApplyToInheritors = RuleUtil.getBaseRuleApplyToConceptInheritors(ruleNode);\n    myNodePointer = new SNodePointer(ruleNode);\n  }","id":11972,"modified_method":"public TemplateReductionRuleInterpreted(SNode ruleNode) {\n    super(new SNodePointer(ruleNode), GeneratorUtil.getConceptQualifiedName(RuleUtil.getBaseRuleApplicableConcept(ruleNode)), RuleUtil.getBaseRuleApplyToConceptInheritors(ruleNode));\n    myRuleNode = ruleNode;\n    myMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n    myRuleConsequence = RuleUtil.getReductionRuleConsequence(ruleNode);\n  }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  private Collection<SNode> apply(TemplateContext context, @NotNull TemplateExecutionEnvironment environment) throws GenerationException {\n    if (myRuleConsequence == null) {\n      throw new TemplateProcessingFailureException(myRuleNode, \"no rule consequence\", GeneratorUtil.describe(context.getInput(), \"input\"));\n    }\n\n    RuleConsequenceProcessor rcp = new RuleConsequenceProcessor(environment);\n    context = context.subContext(myMappingName);\n    rcp.prepare(myRuleConsequence, context);\n    return rcp.processRuleConsequence();\n  }","id":11973,"modified_method":"@Override\n  @NotNull\n  protected Collection<SNode> doApply(@NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment env) throws GenerationException {\n    if (myRuleConsequence == null) {\n      throw new TemplateProcessingFailureException(myRuleNode, \"no rule consequence\", GeneratorUtil.describeInput(context));\n    }\n\n    RuleConsequenceProcessor rcp = new RuleConsequenceProcessor(env);\n    context = context.subContext(myMappingName);\n    rcp.prepare(myRuleConsequence, context);\n    return rcp.processRuleConsequence();\n  }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    environment.getTracer().pushRule(myNodePointer);\n    try {\n      if (environment.getGenerator().isIncremental()) {\n        // turn off tracing\n        NodeReadEventsCaster.setNodesReadListener(null);\n      }\n\n      return apply(context, environment.getEnvironment(context.getInput(), this));\n    } finally {\n      if (environment.getGenerator().isIncremental()) {\n        // restore tracing\n        NodeReadEventsCaster.removeNodesReadListener();\n      }\n      environment.getTracer().closeRule(myNodePointer);\n    }\n  }","id":11974,"modified_method":"@Override\n  public Collection<SNode> tryToApply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    try {\n      if (environment.getGenerator().isIncremental()) {\n        NodeReadEventsCaster.setNodesReadListener(null); // turn tracing off\n      }\n\n      return super.tryToApply(environment, context);\n    } finally {\n      if (environment.getGenerator().isIncremental()) {\n        NodeReadEventsCaster.removeNodesReadListener(); // restore tracing\n      }\n    }\n  }","commit_id":"ba8d6d9905d0bd2b5635362b8224aa04b92ce9e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * \n     * @param regFilePath Path to the output file produced by RegRipper.\n     * @param regFile File object for registry that we are parsing (to make blackboard artifacts with)\n     * @return \n     */\n    private boolean parseAutopsyPluginOutput(String regFilePath, AbstractFile regFile) {\n        FileInputStream fstream = null;\n        try {\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n     \n            // Read the file in and create a Document and elements\n            File regfile = new File(regFilePath);\n            fstream = new FileInputStream(regfile);\n            \n            String regString = new Scanner(fstream, \"UTF-8\").useDelimiter(\"\\\\Z\").next(); //NON-NLS\n            String startdoc = \"<?xml version=\\\"1.0\\\"?><document>\"; //NON-NLS\n            String result = regString.replaceAll(\"----------------------------------------\", \"\");\n            result = result.replaceAll(\"\\\\n\", \"\"); //NON-NLS\n            result = result.replaceAll(\"\\\\r\", \"\"); //NON-NLS\n            result = result.replaceAll(\"'\", \"&apos;\"); //NON-NLS\n            result = result.replaceAll(\"&\", \"&amp;\"); //NON-NLS\n            result = result.replace('\\0', ' '); // NON-NLS\n            String enddoc = \"<\/document>\"; //NON-NLS\n            String stringdoc = startdoc + result + enddoc;\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(stringdoc)));\n            \n            // cycle through the elements in the doc\n            Element oroot = doc.getDocumentElement();\n            NodeList children = oroot.getChildNodes();\n            int len = children.getLength();\n            for (int i = 0; i < len; i++) {\n                Element tempnode = (Element) children.item(i);\n                \n                String dataType = tempnode.getNodeName();\n\n                NodeList timenodes = tempnode.getElementsByTagName(\"mtime\"); //NON-NLS\n                Long mtime = null;\n                if (timenodes.getLength() > 0) {\n                    Element timenode = (Element) timenodes.item(0);\n                    String etime = timenode.getTextContent();\n                    try {\n                        Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(etime).getTime();\n                        mtime = epochtime;\n                        String Tempdate = mtime.toString();\n                        mtime = Long.valueOf(Tempdate) / 1000;\n                    } catch (ParseException ex) {\n                        logger.log(Level.WARNING, \"Failed to parse epoch time when parsing the registry.\"); //NON-NLS\n                    }\n                }\n\n                NodeList artroots = tempnode.getElementsByTagName(\"artifacts\"); //NON-NLS\n                if (artroots.getLength() == 0) {\n                    // If there isn't an artifact node, skip this entry\n                    continue;\n                }\n                \n                Element artroot = (Element) artroots.item(0);\n                NodeList myartlist = artroot.getChildNodes();\n                String parentModuleName = NbBundle.getMessage(this.getClass(), \"ExtractRegistry.parentModuleName.noSpace\");\n                String winver = \"\";\n                \n                // If all artifact nodes should really go under one Blackboard artifact, need to process it differently\n                if(dataType.equals(\"WinVersion\")){\n                    \n                    String version = \"\";\n                    String systemRoot = \"\";\n                    String productId = \"\";\n                    String regOwner = \"\";\n                    String regOrg = \"\";\n                    Long installtime = null;\n                    \n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            String name = artnode.getAttribute(\"name\");\n                            \n                            if(name.equals(\"ProductName\")){ // NON_NLS\n                                version = value;\n                            }\n                            else if(name.equals(\"CSDVersion\")){ // NON_NLS\n                                // This is dependant on the fact that ProductName shows up first in the module output\n                                version = version + \" \" + value;\n                            }\n                            else if(name.equals(\"SystemRoot\")){\n                                systemRoot = value;\n                            }\n                            else if(name.equals(\"ProductId\")){\n                                productId = value;\n                            }\n                            else if(name.equals(\"RegisteredOwner\")){\n                                regOwner = value;\n                            }\n                            else if(name.equals(\"RegisteredOrganization\")){\n                                regOrg = value;\n                            }\n                            else if(name.equals(\"InstallDate\")){\n                                try {\n                                    Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(value).getTime();\n                                    installtime = epochtime;\n                                    String Tempdate = installtime.toString();\n                                    installtime = Long.valueOf(Tempdate) / 1000;\n                                } catch (ParseException e) {\n                                    logger.log(Level.SEVERE, \"RegRipper::Conversion on DateTime -> \", e); //NON-NLS\n                                }\n                            }\n                        }\n                    }\n                    \n                    try {\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), parentModuleName, version));\n                        if(installtime != null){\n                            bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), parentModuleName, installtime));\n                        }\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), parentModuleName, systemRoot));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PRODUCT_ID.getTypeID(), parentModuleName, productId));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_OWNER.getTypeID(), parentModuleName, regOwner));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_ORGANIZATION.getTypeID(), parentModuleName, regOrg));\n                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                        bbart.addAttributes(bbattributes);\n                    } catch (TskCoreException ex) {\n                        logger.log(Level.SEVERE, \"Error adding installed program artifact to blackboard.\"); //NON-NLS                                    \n                    }\n                }\n                else if(dataType.equals(\"Profiler\")){ // NON-NLS\n                    \n                    String os = \"\";\n                    String procArch = \"\";\n                    String procId = \"\";\n                    String tempDir = \"\";\n                    \n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            String name = artnode.getAttribute(\"name\");\n                            \n                            if(name.equals(\"OS\")){ // NON-NLS\n                                os = value;\n                            }\n                            else if(name.equals(\"PROCESSOR_ARCHITECTURE\")){ // NON-NLS\n                                procArch = value;\n                            }\n                            else if(name.equals(\"PROCESSOR_IDENTIFIER\")){  //NON-NLS\n                                procId = value;\n                            }\n                            else if(name.equals(\"TEMP\")){\n                                tempDir = value;\n                            }\n                        }\n                    }\n                    \n                    try {\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VERSION.getTypeID(), parentModuleName, os));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROCESSOR_ARCHITECTURE.getTypeID(), parentModuleName, procArch));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROCESSOR_NAME.getTypeID(), parentModuleName, procId));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_TEMP_DIR.getTypeID(), parentModuleName, tempDir));\n                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                        bbart.addAttributes(bbattributes);\n                    } catch (TskCoreException ex) {  \n                        logger.log(Level.SEVERE, \"Error adding os info artifact to blackboard.\"); //NON-NLS\n                    }\n                }\n                else if(dataType.equals(\"CompName\")){ // NON-NLS\n                    \n                    String compName = \"\";\n                    String domain = \"\";\n                    \n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            String name = artnode.getAttribute(\"name\");\n                            \n                            if(name.equals(\"ComputerName\")){ // NON-NLS\n                                compName = value;\n                            }\n                            else if(name.equals(\"Domain\")){ // NON-NLS\n                                domain = value;\n                            }\n                        }\n                    }\n                    \n                    try {\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), parentModuleName, compName));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(), parentModuleName, domain));\n                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                        bbart.addAttributes(bbattributes);\n                    } catch (TskCoreException ex) {  \n                        logger.log(Level.SEVERE, \"Error adding os info artifact to blackboard.\"); //NON-NLS\n                    }\n                }\n                else{\n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n\n                            switch (dataType) {\n                                case \"recentdocs\": //NON-NLS                                \n                                    // BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                                    // bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", dataType, mtime));\n                                    // bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", dataType, mtimeItem));\n                                    // bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", dataType, value));\n                                    // bbart.addAttributes(bbattributes);\n                                    // @@@ BC: Why are we ignoring this...\n                                    break;\n                                case \"usb\": //NON-NLS\n                                    try {      \n                                        Long usbMtime = Long.parseLong(artnode.getAttribute(\"mtime\")); //NON-NLS\n                                        usbMtime = Long.valueOf(usbMtime.toString());\n\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), parentModuleName, usbMtime));\n                                        String dev = artnode.getAttribute(\"dev\"); //NON-NLS\n                                        String make = \"\";\n                                        String model = dev; \n                                        if (dev.toLowerCase().contains(\"vid\")) { //NON-NLS\n                                            USBInfo info = usbMapper.parseAndLookup(dev);\n                                            if (info.getVendor() != null) {\n                                                make = info.getVendor();\n                                            }\n                                            if (info.getProduct() != null) {\n                                                model = info.getProduct();\n                                            }\n                                        }\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE.getTypeID(), parentModuleName, make));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID(), parentModuleName, model));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID(), parentModuleName, value));\n                                        bbart.addAttributes(bbattributes);\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding device attached artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n                                case \"uninstall\": //NON-NLS\n                                    Long itemMtime = null;\n                                    try {\n                                        Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(artnode.getAttribute(\"mtime\")).getTime(); //NON-NLS\n                                        itemMtime = epochtime;\n                                        itemMtime = itemMtime / 1000;\n                                    } catch (ParseException e) {\n                                        logger.log(Level.WARNING, \"Failed to parse epoch time for installed program artifact.\"); //NON-NLS\n                                    }\n\n                                    try {\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), parentModuleName, value));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(),parentModuleName, itemMtime));\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_INSTALLED_PROG);\n                                        bbart.addAttributes(bbattributes);\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding installed program artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n                                case \"office\": //NON-NLS\n                                    String officeName = artnode.getAttribute(\"name\"); //NON-NLS\n\n                                    try {\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                                        // @@@ BC: Consider removing this after some more testing. It looks like an Mtime associated with the root key and not the individual item\n                                        if (mtime != null) {\n                                            bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), parentModuleName, mtime));\n                                        }\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), parentModuleName, officeName));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), parentModuleName, value));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), parentModuleName, artnode.getNodeName()));\n                                        bbart.addAttributes(bbattributes);\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding recent object artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n                                    \n                                case \"ProcessorArchitecture\": //NON-NLS\n                                    // Architecture is now included under Profiler\n                                    //try {\n                                    //    String processorArchitecture = value;\n                                    //    if (processorArchitecture.equals(\"AMD64\"))\n                                    //        processorArchitecture = \"x86-64\";\n\n                                    //    BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                                    //    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROCESSOR_ARCHITECTURE.getTypeID(), parentModuleName, processorArchitecture));\n                                    //    bbart.addAttributes(bbattributes);\n                                    //} catch (TskCoreException ex) {\n                                    //    logger.log(Level.SEVERE, \"Error adding os info artifact to blackboard.\"); //NON-NLS\n                                    //}\n                                    break;\n                                \n                                case \"ProfileList\": //NON-NLS\n                                    try {\n\n                                        String homeDir = value;\n                                        String sid = artnode.getAttribute(\"sid\"); //NON-NLS\n                                        String username = artnode.getAttribute(\"username\"); //NON-NLS\n\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_ACCOUNT);\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USER_NAME.getTypeID(),\n                                                             parentModuleName, username)); \n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USER_ID.getTypeID(),\n                                                             parentModuleName, sid));\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(),\n                                                             parentModuleName, homeDir));\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding account artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;    \n                                    \n                                case \"NtuserNetwork\": // NON-NLS\n                                    try{\n                                        String localPath = artnode.getAttribute(\"localPath\");\n                                        String remoteName = value;\n                                        \n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(),\n                                                             parentModuleName, localPath)); \n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\n                                                             parentModuleName, remoteName));\n                                        \n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding network artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;  \n\n                                default:\n                                    logger.log(Level.WARNING, \"Unrecognized node name: {0}\", dataType);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n            return true;\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Error finding the registry file.\"); //NON-NLS\n        } catch (SAXException ex) {\n            logger.log(Level.SEVERE, \"Error parsing the registry XML: {0}\", ex); //NON-NLS\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error building the document parser: {0}\", ex); //NON-NLS\n        } catch (ParserConfigurationException ex) {\n            logger.log(Level.SEVERE, \"Error configuring the registry parser: {0}\", ex); //NON-NLS\n        } finally {\n            try {\n                if (fstream != null) {\n                    fstream.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n        return false;\n    }","id":11975,"modified_method":"/**\n     *\n     * @param regFilePath Path to the output file produced by RegRipper.\n     * @param regFile File object for registry that we are parsing (to make\n     * blackboard artifacts with)\n     * @return\n     */\n    private boolean parseAutopsyPluginOutput(String regFilePath, AbstractFile regFile) {\n        FileInputStream fstream = null;\n        try {\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n\n            // Read the file in and create a Document and elements\n            File regfile = new File(regFilePath);\n            fstream = new FileInputStream(regfile);\n\n            String regString = new Scanner(fstream, \"UTF-8\").useDelimiter(\"\\\\Z\").next(); //NON-NLS\n            String startdoc = \"<?xml version=\\\"1.0\\\"?><document>\"; //NON-NLS\n            String result = regString.replaceAll(\"----------------------------------------\", \"\");\n            result = result.replaceAll(\"\\\\n\", \"\"); //NON-NLS\n            result = result.replaceAll(\"\\\\r\", \"\"); //NON-NLS\n            result = result.replaceAll(\"'\", \"&apos;\"); //NON-NLS\n            result = result.replaceAll(\"&\", \"&amp;\"); //NON-NLS\n            result = result.replace('\\0', ' '); // NON-NLS\n            String enddoc = \"<\/document>\"; //NON-NLS\n            String stringdoc = startdoc + result + enddoc;\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(stringdoc)));\n\n            // cycle through the elements in the doc\n            Element oroot = doc.getDocumentElement();\n            NodeList children = oroot.getChildNodes();\n            int len = children.getLength();\n            for (int i = 0; i < len; i++) {\n                Element tempnode = (Element) children.item(i);\n\n                String dataType = tempnode.getNodeName();\n\n                NodeList timenodes = tempnode.getElementsByTagName(\"mtime\"); //NON-NLS\n                Long mtime = null;\n                if (timenodes.getLength() > 0) {\n                    Element timenode = (Element) timenodes.item(0);\n                    String etime = timenode.getTextContent();\n                    try {\n                        Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(etime).getTime();\n                        mtime = epochtime;\n                        String Tempdate = mtime.toString();\n                        mtime = Long.valueOf(Tempdate) / 1000;\n                    } catch (ParseException ex) {\n                        logger.log(Level.WARNING, \"Failed to parse epoch time when parsing the registry.\"); //NON-NLS\n                    }\n                }\n\n                NodeList artroots = tempnode.getElementsByTagName(\"artifacts\"); //NON-NLS\n                if (artroots.getLength() == 0) {\n                    // If there isn't an artifact node, skip this entry\n                    continue;\n                }\n\n                Element artroot = (Element) artroots.item(0);\n                NodeList myartlist = artroot.getChildNodes();\n                String parentModuleName = NbBundle.getMessage(this.getClass(), \"ExtractRegistry.parentModuleName.noSpace\");\n                String winver = \"\";\n\n                // If all artifact nodes should really go under one Blackboard artifact, need to process it differently\n                if (dataType.equals(\"WinVersion\")) {\n\n                    String version = \"\";\n                    String systemRoot = \"\";\n                    String productId = \"\";\n                    String regOwner = \"\";\n                    String regOrg = \"\";\n                    Long installtime = null;\n\n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            String name = artnode.getAttribute(\"name\");\n\n                            if (name.equals(\"ProductName\")) { // NON_NLS\n                                version = value;\n                            } else if (name.equals(\"CSDVersion\")) { // NON_NLS\n                                // This is dependant on the fact that ProductName shows up first in the module output\n                                version = version + \" \" + value;\n                            } else if (name.equals(\"SystemRoot\")) {\n                                systemRoot = value;\n                            } else if (name.equals(\"ProductId\")) {\n                                productId = value;\n                            } else if (name.equals(\"RegisteredOwner\")) {\n                                regOwner = value;\n                            } else if (name.equals(\"RegisteredOrganization\")) {\n                                regOrg = value;\n                            } else if (name.equals(\"InstallDate\")) {\n                                try {\n                                    Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(value).getTime();\n                                    installtime = epochtime;\n                                    String Tempdate = installtime.toString();\n                                    installtime = Long.valueOf(Tempdate) / 1000;\n                                } catch (ParseException e) {\n                                    logger.log(Level.SEVERE, \"RegRipper::Conversion on DateTime -> \", e); //NON-NLS\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), parentModuleName, version));\n                        if (installtime != null) {\n                            bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), parentModuleName, installtime));\n                        }\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), parentModuleName, systemRoot));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PRODUCT_ID.getTypeID(), parentModuleName, productId));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_OWNER.getTypeID(), parentModuleName, regOwner));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_ORGANIZATION.getTypeID(), parentModuleName, regOrg));\n\n                        // Check if there is already an OS_INFO artifact for this file, and add to that if possible.\n                        ArrayList<BlackboardArtifact> results = tempDb.getBlackboardArtifacts(ARTIFACT_TYPE.TSK_OS_INFO, regFile.getId());\n                        if (results.isEmpty()) {\n                            BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                            bbart.addAttributes(bbattributes);\n                        } else {\n                            results.get(0).addAttributes(bbattributes);\n                        }\n\n                    } catch (TskCoreException ex) {\n                        logger.log(Level.SEVERE, \"Error adding installed program artifact to blackboard.\"); //NON-NLS                                    \n                    }\n                } else if (dataType.equals(\"Profiler\")) { // NON-NLS\n\n                    String os = \"\";\n                    String procArch = \"\";\n                    String procId = \"\";\n                    String tempDir = \"\";\n\n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            String name = artnode.getAttribute(\"name\");\n\n                            if (name.equals(\"OS\")) { // NON-NLS\n                                os = value;\n                            } else if (name.equals(\"PROCESSOR_ARCHITECTURE\")) { // NON-NLS\n                                procArch = value;\n                            } else if (name.equals(\"PROCESSOR_IDENTIFIER\")) {  //NON-NLS\n                                procId = value;\n                            } else if (name.equals(\"TEMP\")) {\n                                tempDir = value;\n                            }\n                        }\n                    }\n\n                    try {\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VERSION.getTypeID(), parentModuleName, os));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROCESSOR_ARCHITECTURE.getTypeID(), parentModuleName, procArch));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROCESSOR_NAME.getTypeID(), parentModuleName, procId));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_TEMP_DIR.getTypeID(), parentModuleName, tempDir));\n\n                        // Check if there is already an OS_INFO artifact for this file and add to that if possible\n                        ArrayList<BlackboardArtifact> results = tempDb.getBlackboardArtifacts(ARTIFACT_TYPE.TSK_OS_INFO, regFile.getId());\n                        if (results.isEmpty()) {\n                            BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                            bbart.addAttributes(bbattributes);\n                        } else {\n                            results.get(0).addAttributes(bbattributes);\n                        }\n                    } catch (TskCoreException ex) {\n                        logger.log(Level.SEVERE, \"Error adding os info artifact to blackboard.\"); //NON-NLS\n                    }\n                } else if (dataType.equals(\"CompName\")) { // NON-NLS\n\n                    String compName = \"\";\n                    String domain = \"\";\n\n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            String name = artnode.getAttribute(\"name\");\n\n                            if (name.equals(\"ComputerName\")) { // NON-NLS\n                                compName = value;\n                            } else if (name.equals(\"Domain\")) { // NON-NLS\n                                domain = value;\n                            }\n                        }\n                    }\n\n                    try {\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), parentModuleName, compName));\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(), parentModuleName, domain));\n\n                        // Check if there is already an OS_INFO artifact for this file and add to that if possible\n                        ArrayList<BlackboardArtifact> results = tempDb.getBlackboardArtifacts(ARTIFACT_TYPE.TSK_OS_INFO, regFile.getId());\n                        if (results.isEmpty()) {\n                            BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                            bbart.addAttributes(bbattributes);\n                        } else {\n                            results.get(0).addAttributes(bbattributes);\n                        }\n                    } catch (TskCoreException ex) {\n                        logger.log(Level.SEVERE, \"Error adding os info artifact to blackboard.\"); //NON-NLS\n                    }\n                } else {\n                    for (int j = 0; j < myartlist.getLength(); j++) {\n                        Node artchild = myartlist.item(j);\n                        // If it has attributes, then it is an Element (based off API)\n                        if (artchild.hasAttributes()) {\n                            Element artnode = (Element) artchild;\n\n                            String value = artnode.getTextContent().trim();\n                            Collection<BlackboardAttribute> bbattributes = new ArrayList<>();\n\n                            switch (dataType) {\n                                case \"recentdocs\": //NON-NLS                                \n                                    // BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                                    // bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", dataType, mtime));\n                                    // bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", dataType, mtimeItem));\n                                    // bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", dataType, value));\n                                    // bbart.addAttributes(bbattributes);\n                                    // @@@ BC: Why are we ignoring this...\n                                    break;\n                                case \"usb\": //NON-NLS\n                                    try {\n                                        Long usbMtime = Long.parseLong(artnode.getAttribute(\"mtime\")); //NON-NLS\n                                        usbMtime = Long.valueOf(usbMtime.toString());\n\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), parentModuleName, usbMtime));\n                                        String dev = artnode.getAttribute(\"dev\"); //NON-NLS\n                                        String make = \"\";\n                                        String model = dev;\n                                        if (dev.toLowerCase().contains(\"vid\")) { //NON-NLS\n                                            USBInfo info = usbMapper.parseAndLookup(dev);\n                                            if (info.getVendor() != null) {\n                                                make = info.getVendor();\n                                            }\n                                            if (info.getProduct() != null) {\n                                                model = info.getProduct();\n                                            }\n                                        }\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE.getTypeID(), parentModuleName, make));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID(), parentModuleName, model));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID(), parentModuleName, value));\n                                        bbart.addAttributes(bbattributes);\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding device attached artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n                                case \"uninstall\": //NON-NLS\n                                    Long itemMtime = null;\n                                    try {\n                                        Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(artnode.getAttribute(\"mtime\")).getTime(); //NON-NLS\n                                        itemMtime = epochtime;\n                                        itemMtime = itemMtime / 1000;\n                                    } catch (ParseException e) {\n                                        logger.log(Level.WARNING, \"Failed to parse epoch time for installed program artifact.\"); //NON-NLS\n                                    }\n\n                                    try {\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), parentModuleName, value));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), parentModuleName, itemMtime));\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_INSTALLED_PROG);\n                                        bbart.addAttributes(bbattributes);\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding installed program artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n                                case \"office\": //NON-NLS\n                                    String officeName = artnode.getAttribute(\"name\"); //NON-NLS\n\n                                    try {\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                                        // @@@ BC: Consider removing this after some more testing. It looks like an Mtime associated with the root key and not the individual item\n                                        if (mtime != null) {\n                                            bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), parentModuleName, mtime));\n                                        }\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), parentModuleName, officeName));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), parentModuleName, value));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), parentModuleName, artnode.getNodeName()));\n                                        bbart.addAttributes(bbattributes);\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding recent object artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n\n                                case \"ProcessorArchitecture\": //NON-NLS\n                                    // Architecture is now included under Profiler\n                                    //try {\n                                    //    String processorArchitecture = value;\n                                    //    if (processorArchitecture.equals(\"AMD64\"))\n                                    //        processorArchitecture = \"x86-64\";\n\n                                    //    BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_INFO);\n                                    //    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROCESSOR_ARCHITECTURE.getTypeID(), parentModuleName, processorArchitecture));\n                                    //    bbart.addAttributes(bbattributes);\n                                    //} catch (TskCoreException ex) {\n                                    //    logger.log(Level.SEVERE, \"Error adding os info artifact to blackboard.\"); //NON-NLS\n                                    //}\n                                    break;\n\n                                case \"ProfileList\": //NON-NLS\n                                    try {\n\n                                        String homeDir = value;\n                                        String sid = artnode.getAttribute(\"sid\"); //NON-NLS\n                                        String username = artnode.getAttribute(\"username\"); //NON-NLS\n\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_OS_ACCOUNT);\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USER_NAME.getTypeID(),\n                                                parentModuleName, username));\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USER_ID.getTypeID(),\n                                                parentModuleName, sid));\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(),\n                                                parentModuleName, homeDir));\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding account artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n\n                                case \"NtuserNetwork\": // NON-NLS\n                                    try {\n                                        String localPath = artnode.getAttribute(\"localPath\");\n                                        String remoteName = value;\n                                        BlackboardArtifact bbart = regFile.newArtifact(ARTIFACT_TYPE.TSK_REMOTE_DRIVE);\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LOCAL_PATH.getTypeID(),\n                                                parentModuleName, localPath));\n                                        bbart.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REMOTE_PATH.getTypeID(),\n                                                parentModuleName, remoteName));\n\n                                    } catch (TskCoreException ex) {\n                                        logger.log(Level.SEVERE, \"Error adding network artifact to blackboard.\"); //NON-NLS\n                                    }\n                                    break;\n\n                                default:\n                                    logger.log(Level.WARNING, \"Unrecognized node name: {0}\", dataType);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n            return true;\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Error finding the registry file.\"); //NON-NLS\n        } catch (SAXException ex) {\n            logger.log(Level.SEVERE, \"Error parsing the registry XML: {0}\", ex); //NON-NLS\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error building the document parser: {0}\", ex); //NON-NLS\n        } catch (ParserConfigurationException ex) {\n            logger.log(Level.SEVERE, \"Error configuring the registry parser: {0}\", ex); //NON-NLS\n        } finally {\n            try {\n                if (fstream != null) {\n                    fstream.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n        return false;\n    }","commit_id":"8ac91c2cb8085d5123b43d15c242fbf1f2728e9b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void disconnect(MuxChannel ch) {\n        Entry entry;\n        ch.setClosed(false);\n        ch.setConnected(false);\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    mux.disconnect(); // disconnects JChannel if all MuxChannels are in disconnected state\n                }\n            }\n        }\n    }","id":11976,"modified_method":"public void disconnect(MuxChannel ch) {\n        Entry entry;\n        ch.setClosed(false);\n        ch.setConnected(false);\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    Address addr=entry.channel.getLocalAddress();\n                    try {\n                        mux.sendServiceDownMessage(ch.getId(), addr);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed sending SERVICE_DOWN message\", e);\n                    }\n                    mux.disconnect(); // disconnects JChannel if all MuxChannels are in disconnected state\n                }\n            }\n        }\n    }","commit_id":"e349d68844ac460e1450364de549b8c0dab762c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void connect(MuxChannel ch) throws ChannelException {\n        Entry entry;\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                if(entry.channel == null)\n                    throw new ChannelException(\"channel has to be created before it can be connected\");\n                if(!entry.channel.isConnected())\n                    entry.channel.connect(ch.getStackName());\n            }\n        }\n        ch.setClosed(false);\n        ch.setConnected(true);\n    }","id":11977,"modified_method":"public void connect(MuxChannel ch) throws ChannelException {\n        Entry entry;\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                if(entry.channel == null)\n                    throw new ChannelException(\"channel has to be created before it can be connected\");\n                if(!entry.channel.isConnected()) {\n                    entry.channel.connect(ch.getStackName());\n                    if(entry.multiplexer != null) {\n                        try {\n                            entry.multiplexer.fetchServiceInformation();\n                        }\n                        catch(Exception e) {\n                            if(log.isErrorEnabled())\n                                log.error(\"failed fetching service state\", e);\n                        }\n                    }\n                }\n                if(entry.multiplexer != null) {\n                    try {\n                        Address addr=entry.channel.getLocalAddress();\n                        entry.multiplexer.sendServiceUpMessage(ch.getId(), addr);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed sending SERVICE_UP message\", e);\n                    }\n                }\n            }\n        }\n        ch.setClosed(false);\n        ch.setConnected(true);\n    }","commit_id":"e349d68844ac460e1450364de549b8c0dab762c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void shutdown(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n            if(entry != null) {\n                synchronized(entry) {\n                    Multiplexer mux=entry.multiplexer;\n                    if(mux != null) {\n                        all_closed=mux.shutdown(); // closes JChannel if all MuxChannels are in closed state\n                        mux.unregister(ch.getId());\n                    }\n                }\n                if(all_closed) {\n                    channels.remove(stack_name);\n                }\n                if(expose_channels && server != null) {\n                    try {\n                        unregister(domain + \":*,cluster=\" + stack_name);\n                    }\n                    catch(Exception e) {\n                        log.error(\"failed unregistering channel \" + stack_name, e);\n                    }\n                }\n            }\n        }\n    }","id":11978,"modified_method":"public void shutdown(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n            if(entry != null) {\n                synchronized(entry) {\n                    Multiplexer mux=entry.multiplexer;\n                    if(mux != null) {\n                        Address addr=entry.channel.getLocalAddress();\n                        try {\n                            mux.sendServiceDownMessage(ch.getId(), addr);\n                        }\n                        catch(Exception e) {\n                            if(log.isErrorEnabled())\n                                log.error(\"failed sending SERVICE_DOWN message\", e);\n                        }\n                        all_closed=mux.shutdown(); // closes JChannel if all MuxChannels are in closed state\n\n                        //mux.unregister(ch.getId());\n                    }\n                }\n                if(all_closed) {\n                    channels.remove(stack_name);\n                }\n                if(expose_channels && server != null) {\n                    try {\n                        unregister(domain + \":*,cluster=\" + stack_name);\n                    }\n                    catch(Exception e) {\n                        log.error(\"failed unregistering channel \" + stack_name, e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"e349d68844ac460e1450364de549b8c0dab762c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    all_closed=mux.close(); // closes JChannel if all MuxChannels are in closed state\n                    mux.unregister(ch.getId());\n                }\n            }\n            if(all_closed) {\n                channels.remove(stack_name);\n            }\n            if(expose_channels && server != null) {\n                try {\n                    unregister(domain + \":*,cluster=\" + stack_name);\n                }\n                catch(Exception e) {\n                    log.error(\"failed unregistering channel \" + stack_name, e);\n                }\n            }\n        }\n    }","id":11979,"modified_method":"public void close(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    Address addr=entry.channel.getLocalAddress();\n                    try {\n                        mux.sendServiceDownMessage(ch.getId(), addr);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed sending SERVICE_DOWN message\", e);\n                    }\n                    all_closed=mux.close(); // closes JChannel if all MuxChannels are in closed state\n                    //mux.unregister(ch.getId());\n                }\n            }\n            if(all_closed) {\n                channels.remove(stack_name);\n            }\n            if(expose_channels && server != null) {\n                try {\n                    unregister(domain + \":*,cluster=\" + stack_name);\n                }\n                catch(Exception e) {\n                    log.error(\"failed unregistering channel \" + stack_name, e);\n                }\n            }\n        }\n    }","commit_id":"e349d68844ac460e1450364de549b8c0dab762c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void up(Event evt) {\n        // remove header and dispatch to correct MuxChannel\n        MuxHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                hdr=(MuxHeader)msg.getHeader(\"MUX\");\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return;\n                }\n                MuxChannel mux_ch=(MuxChannel)services.get(hdr.id);\n                if(mux_ch == null) {\n                    log.error(\"didn't find a service for id=\" + hdr.id + \" discarding messgage \" + msg);\n                    return;\n                }\n                if(log.isTraceEnabled())\n                    log.trace(\"dispatching message to \" + hdr.id);\n                mux_ch.up(evt);\n                break;\n\n            case Event.VIEW_CHANGE:\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.SUSPECT:\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n                handleStateRequest(evt);\n                break;\n\n            case Event.GET_STATE_OK:\n                handleStateResponse(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n    }","id":11980,"modified_method":"public void up(Event evt) {\n        // remove header and dispatch to correct MuxChannel\n        MuxHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                hdr=(MuxHeader)msg.getHeader(NAME);\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return;\n                }\n\n                if(hdr.info != null) { // it is a service state request - not a default multiplex request\n                    try {\n                        handleServiceStateRequest(hdr.info, msg.getSrc());\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failure in handling service state request\", e);\n                    }\n                    break;\n                }\n\n                MuxChannel mux_ch=(MuxChannel)services.get(hdr.id);\n                if(mux_ch == null) {\n                    log.warn(\"service \" + hdr.id + \" not currently running, discarding messgage \" + msg);\n                    return;\n                }\n                if(log.isTraceEnabled())\n                    log.trace(\"dispatching message to \" + hdr.id);\n                mux_ch.up(evt);\n                break;\n\n            case Event.VIEW_CHANGE:\n                view=(View)evt.getArg();\n\n                if(view instanceof MergeView) {\n                    // handle merges here\n                }\n\n                // passToAllMuxChannels(evt);\n                break;\n\n            case Event.SUSPECT:\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n                handleStateRequest(evt);\n                break;\n\n            case Event.GET_STATE_OK:\n                handleStateResponse(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n    }","commit_id":"e349d68844ac460e1450364de549b8c0dab762c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createMuxChannel(JChannelFactory f, String id, String stack_name) throws Exception {\n        synchronized(services) {\n            if(services.containsKey(id))\n                throw new Exception(\"service ID \\\"\" + id + \"\\\" is already registered, cannot register duplicate ID\");\n            MuxChannel ch=new MuxChannel(f, channel, id, stack_name, this);\n            services.put(id, ch);\n            return ch;\n        }\n    }","id":11981,"modified_method":"public Channel createMuxChannel(JChannelFactory f, String id, String stack_name) throws Exception {\n        MuxChannel ch;\n        synchronized(services) {\n            if(services.containsKey(id))\n                throw new Exception(\"service ID \\\"\" + id + \"\\\" is already registered, cannot register duplicate ID\");\n            ch=new MuxChannel(f, channel, id, stack_name, this);\n            services.put(id, ch);\n        }\n        return ch;\n    }","commit_id":"e349d68844ac460e1450364de549b8c0dab762c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void shutdown(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n            if(entry != null) {\n                synchronized(entry) {\n                    Multiplexer mux=entry.multiplexer;\n                    if(mux != null) {\n                        all_closed=mux.shutdown(); // closes JChannel if all MuxChannels are in closed state\n                        mux.unregister(ch.getId());\n                    }\n                }\n                if(all_closed) {\n                    channels.remove(stack_name);\n                }\n                if(expose_channels && server != null) {\n                    try {\n                        unregister(domain + \":*,cluster=\" + stack_name);\n                    }\n                    catch(Exception e) {\n                        log.error(\"failed unregistering channel \" + stack_name, e);\n                    }\n                }\n            }\n        }\n    }","id":11982,"modified_method":"public void shutdown(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n            if(entry != null) {\n                synchronized(entry) {\n                    Multiplexer mux=entry.multiplexer;\n                    if(mux != null) {\n                        Address addr=entry.channel.getLocalAddress();\n                        try {\n                            mux.sendServiceDownMessage(ch.getId(), addr);\n                        }\n                        catch(Exception e) {\n                            if(log.isErrorEnabled())\n                                log.error(\"failed sending SERVICE_DOWN message\", e);\n                        }\n                        all_closed=mux.shutdown(); // closes JChannel if all MuxChannels are in closed state\n\n                        //mux.unregister(ch.getId());\n                    }\n                }\n                if(all_closed) {\n                    channels.remove(stack_name);\n                }\n                if(expose_channels && server != null) {\n                    try {\n                        unregister(domain + \":*,cluster=\" + stack_name);\n                    }\n                    catch(Exception e) {\n                        log.error(\"failed unregistering channel \" + stack_name, e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"e6da0cfff1e2f6822de31b81dba0c91163d52ad1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    all_closed=mux.close(); // closes JChannel if all MuxChannels are in closed state\n                    mux.unregister(ch.getId());\n                }\n            }\n            if(all_closed) {\n                channels.remove(stack_name);\n            }\n            if(expose_channels && server != null) {\n                try {\n                    unregister(domain + \":*,cluster=\" + stack_name);\n                }\n                catch(Exception e) {\n                    log.error(\"failed unregistering channel \" + stack_name, e);\n                }\n            }\n        }\n    }","id":11983,"modified_method":"public void close(MuxChannel ch) {\n        Entry entry;\n        String stack_name=ch.getStackName();\n        ch.setClosed(true);\n        ch.setConnected(false);\n        ch.closeMessageQueue(true);\n        boolean all_closed=false;\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(stack_name);\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    Address addr=entry.channel.getLocalAddress();\n                    try {\n                        mux.sendServiceDownMessage(ch.getId(), addr);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed sending SERVICE_DOWN message\", e);\n                    }\n                    all_closed=mux.close(); // closes JChannel if all MuxChannels are in closed state\n                    //mux.unregister(ch.getId());\n                }\n            }\n            if(all_closed) {\n                channels.remove(stack_name);\n            }\n            if(expose_channels && server != null) {\n                try {\n                    unregister(domain + \":*,cluster=\" + stack_name);\n                }\n                catch(Exception e) {\n                    log.error(\"failed unregistering channel \" + stack_name, e);\n                }\n            }\n        }\n    }","commit_id":"e6da0cfff1e2f6822de31b81dba0c91163d52ad1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void disconnect(MuxChannel ch) {\n        Entry entry;\n        ch.setClosed(false);\n        ch.setConnected(false);\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    mux.disconnect(); // disconnects JChannel if all MuxChannels are in disconnected state\n                }\n            }\n        }\n    }","id":11984,"modified_method":"public void disconnect(MuxChannel ch) {\n        Entry entry;\n        ch.setClosed(false);\n        ch.setConnected(false);\n\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                Multiplexer mux=entry.multiplexer;\n                if(mux != null) {\n                    Address addr=entry.channel.getLocalAddress();\n                    try {\n                        mux.sendServiceDownMessage(ch.getId(), addr);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed sending SERVICE_DOWN message\", e);\n                    }\n                    mux.disconnect(); // disconnects JChannel if all MuxChannels are in disconnected state\n                }\n            }\n        }\n    }","commit_id":"e6da0cfff1e2f6822de31b81dba0c91163d52ad1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void connect(MuxChannel ch) throws ChannelException {\n        Entry entry;\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                if(entry.channel == null)\n                    throw new ChannelException(\"channel has to be created before it can be connected\");\n                if(!entry.channel.isConnected())\n                    entry.channel.connect(ch.getStackName());\n            }\n        }\n        ch.setClosed(false);\n        ch.setConnected(true);\n    }","id":11985,"modified_method":"public void connect(MuxChannel ch) throws ChannelException {\n        Entry entry;\n        synchronized(channels) {\n            entry=(Entry)channels.get(ch.getStackName());\n        }\n        if(entry != null) {\n            synchronized(entry) {\n                if(entry.channel == null)\n                    throw new ChannelException(\"channel has to be created before it can be connected\");\n                if(!entry.channel.isConnected()) {\n                    entry.channel.connect(ch.getStackName());\n                    if(entry.multiplexer != null) {\n                        try {\n                            entry.multiplexer.fetchServiceInformation();\n                        }\n                        catch(Exception e) {\n                            if(log.isErrorEnabled())\n                                log.error(\"failed fetching service state\", e);\n                        }\n                    }\n                }\n                if(entry.multiplexer != null) {\n                    try {\n                        Address addr=entry.channel.getLocalAddress();\n                        entry.multiplexer.sendServiceUpMessage(ch.getId(), addr);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed sending SERVICE_UP message\", e);\n                    }\n                }\n            }\n        }\n        ch.setClosed(false);\n        ch.setConnected(true);\n    }","commit_id":"e6da0cfff1e2f6822de31b81dba0c91163d52ad1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void up(Event evt) {\n        // remove header and dispatch to correct MuxChannel\n        MuxHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                hdr=(MuxHeader)msg.getHeader(\"MUX\");\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return;\n                }\n                MuxChannel mux_ch=(MuxChannel)services.get(hdr.id);\n                if(mux_ch == null) {\n                    log.error(\"didn't find a service for id=\" + hdr.id + \" discarding messgage \" + msg);\n                    return;\n                }\n                if(log.isTraceEnabled())\n                    log.trace(\"dispatching message to \" + hdr.id);\n                mux_ch.up(evt);\n                break;\n\n            case Event.VIEW_CHANGE:\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.SUSPECT:\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n                handleStateRequest(evt);\n                break;\n\n            case Event.GET_STATE_OK:\n                handleStateResponse(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n    }","id":11986,"modified_method":"public void up(Event evt) {\n        // remove header and dispatch to correct MuxChannel\n        MuxHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                hdr=(MuxHeader)msg.getHeader(NAME);\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return;\n                }\n\n                if(hdr.info != null) { // it is a service state request - not a default multiplex request\n                    try {\n                        handleServiceStateRequest(hdr.info, msg.getSrc());\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failure in handling service state request\", e);\n                    }\n                    break;\n                }\n\n                MuxChannel mux_ch=(MuxChannel)services.get(hdr.id);\n                if(mux_ch == null) {\n                    log.warn(\"service \" + hdr.id + \" not currently running, discarding messgage \" + msg);\n                    return;\n                }\n                if(log.isTraceEnabled())\n                    log.trace(\"dispatching message to \" + hdr.id);\n                mux_ch.up(evt);\n                break;\n\n            case Event.VIEW_CHANGE:\n                view=(View)evt.getArg();\n\n                if(view instanceof MergeView) {\n                    // handle merges here\n                }\n\n                // passToAllMuxChannels(evt);\n                break;\n\n            case Event.SUSPECT:\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n                handleStateRequest(evt);\n                break;\n\n            case Event.GET_STATE_OK:\n                handleStateResponse(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n    }","commit_id":"e6da0cfff1e2f6822de31b81dba0c91163d52ad1","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createMuxChannel(JChannelFactory f, String id, String stack_name) throws Exception {\n        synchronized(services) {\n            if(services.containsKey(id))\n                throw new Exception(\"service ID \\\"\" + id + \"\\\" is already registered, cannot register duplicate ID\");\n            MuxChannel ch=new MuxChannel(f, channel, id, stack_name, this);\n            services.put(id, ch);\n            return ch;\n        }\n    }","id":11987,"modified_method":"public Channel createMuxChannel(JChannelFactory f, String id, String stack_name) throws Exception {\n        MuxChannel ch;\n        synchronized(services) {\n            if(services.containsKey(id))\n                throw new Exception(\"service ID \\\"\" + id + \"\\\" is already registered, cannot register duplicate ID\");\n            ch=new MuxChannel(f, channel, id, stack_name, this);\n            services.put(id, ch);\n        }\n        return ch;\n    }","commit_id":"e6da0cfff1e2f6822de31b81dba0c91163d52ad1","url":"https://github.com/belaban/JGroups"},{"original_method":"private EditorCell createProperty_okhcuc_a0a0(EditorContext editorContext, SNode node) {\n      CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n      provider.setRole(\"name\");\n      provider.setNoTargetText(\"<no name>\");\n      EditorCell editorCell;\n      editorCell = provider.createEditorCell(editorContext);\n      editorCell.setCellId(\"property_name\");\n      editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n      SNode attributeConcept = provider.getRoleAttribute();\n      Class attributeKind = provider.getRoleAttributeClass();\n      if (attributeConcept != null) {\n        IOperationContext opContext = editorContext.getOperationContext();\n        EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n        return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n      } else\n      return editorCell;\n    }","id":11988,"modified_method":"private EditorCell createProperty_okhcuc_a0a0(EditorContext editorContext, SNode node) {\n      CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n      provider.setRole(\"name\");\n      provider.setNoTargetText(\"<no name>\");\n      provider.setReadOnly(true);\n      EditorCell editorCell;\n      editorCell = provider.createEditorCell(editorContext);\n      editorCell.setCellId(\"property_name\");\n      editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n      SNode attributeConcept = provider.getRoleAttribute();\n      Class attributeKind = provider.getRoleAttributeClass();\n      if (attributeConcept != null) {\n        IOperationContext opContext = editorContext.getOperationContext();\n        EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n        return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n      } else\n      return editorCell;\n    }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_SProperty_7581772527307667439(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.structure.structure.SProperty\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        SNode wrappedConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.structure.structure.SDataType\");\n        IChildNodeSetter setter = new AbstractChildNodeSetter() {\n          public SNode wrapNode(SNode nodeToWrap, SModel model) {\n            SNode prop = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.core.structure.structure.SProperty\", null);\n            SLinkOperations.setTarget(prop, \"type\", nodeToWrap, true);\n            return prop;\n          }\n\n          public boolean returnSmallPart(SNode nodeToWrap) {\n            return false;\n          }\n\n          public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n            SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n            _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n            if (this.returnSmallPart(nc)) {\n              return nc;\n            } else {\n              return wrappedNode;\n            }\n          }\n        };\n        ListSequence.fromList(result).addSequence(ListSequence.fromList(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext)));\n      }\n    }\n    return result;\n  }","id":11989,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_SProperty_7581772527307667439(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.structure.structure.SProperty\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        SNode wrappedConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.core.structure.structure.SDataType\");\n        IChildNodeSetter setter = new AbstractChildNodeSetter() {\n          public SNode wrapNode(SNode nodeToWrap, SModel model) {\n            SNode prop = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.core.structure.structure.SProperty\", _context.getCurrentTargetNode());\n            SLinkOperations.setTarget(prop, \"type\", nodeToWrap, true);\n            return prop;\n          }\n\n          public boolean returnSmallPart(SNode nodeToWrap) {\n            return false;\n          }\n\n          public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n            SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n            _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n            if (this.returnSmallPart(nc)) {\n              return nc;\n            } else {\n              return wrappedNode;\n            }\n          }\n        };\n        ListSequence.fromList(result).addSequence(ListSequence.fromList(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext)));\n      }\n    }\n    return result;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefCell_lacg44_a0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new RefCellCellProvider(node, editorContext);\n    provider.setRole(\"target\");\n    provider.setNoTargetText(\"<no target>\");\n    EditorCell editorCell;\n    provider.setAuxiliaryCellProvider(new SChildLink_Editor._Inline_lacg44_a0a());\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":11990,"modified_method":"private EditorCell createRefCell_lacg44_a0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new RefCellCellProvider(node, editorContext);\n    provider.setRole(\"target\");\n    provider.setNoTargetText(\"<no target>\");\n    EditorCell editorCell;\n    provider.setAuxiliaryCellProvider(new SChildLink_Editor._Inline_lacg44_a0a());\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setSubstituteInfo(new CompositeSubstituteInfo(editorContext, provider.getCellContext(), new SubstituteInfoPart[]{new SChildLink_Editor.ReplaceWith_SProperty_cellMenu_a0a0(), new SChildLink_Editor.SChildLink_target_cellMenu_b0a0()}));\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_hi5u6k_c0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_hi5u6k_c0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.addEditorCell(this.createConstant_hi5u6k_a2a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_hi5u6k_b2a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_hi5u6k_c2a(editorContext, node));\n    return editorCell;\n  }","id":11991,"modified_method":"private EditorCell createCollection_hi5u6k_f0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_hi5u6k_f0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.addEditorCell(this.createConstant_hi5u6k_a5a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_hi5u6k_b5a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_hi5u6k_c5a(editorContext, node));\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNode_hi5u6k_e0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new RefNodeCellProvider(node, editorContext);\n    provider.setRole(\"body\");\n    provider.setNoTargetText(\"<no body>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":11992,"modified_method":"private EditorCell createRefNode_hi5u6k_h0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new RefNodeCellProvider(node, editorContext);\n    provider.setRole(\"body\");\n    provider.setNoTargetText(\"<no body>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    SConceptQuery_deleteEq.setCellActions(editorCell, node, editorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_hi5u6k_a2a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"(\");\n    editorCell.setCellId(\"Constant_hi5u6k_a2a\");\n    MqlSS_StyleSheet.getPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":11993,"modified_method":"private EditorCell createConstant_hi5u6k_a5a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"(\");\n    editorCell.setCellId(\"Constant_hi5u6k_a5a\");\n    MqlSS_StyleSheet.getPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_hi5u6k_d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"=\");\n    editorCell.setCellId(\"Constant_hi5u6k_d0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":11994,"modified_method":"private EditorCell createConstant_hi5u6k_i0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \";\");\n    editorCell.setCellId(\"Constant_hi5u6k_i0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_hi5u6k_f0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \";\");\n    editorCell.setCellId(\"Constant_hi5u6k_f0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":11995,"modified_method":"private EditorCell createConstant_hi5u6k_b0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"final\");\n    editorCell.setCellId(\"Constant_hi5u6k_b0\");\n    default_StyleSheet.getKeyword(editorCell).apply(editorCell);\n    SConceptQuery_deleteFinal.setCellActions(editorCell, node, editorContext);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_hi5u6k_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"query\");\n    editorCell.setCellId(\"Constant_hi5u6k_a0\");\n    MqlSS_StyleSheet.getKeyword(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.RT_ANCHOR_TAG, \"ext_2_RTransform\");\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":11996,"modified_method":"private EditorCell createConstant_hi5u6k_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"abstract\");\n    editorCell.setCellId(\"Constant_hi5u6k_a0\");\n    default_StyleSheet.getKeyword(editorCell).apply(editorCell);\n    SConceptQuery_deleteAbstract.setCellActions(editorCell, node, editorContext);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createProperty_hi5u6k_b0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"name\");\n    provider.setNoTargetText(\"<no name>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_name\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.RT_ANCHOR_TAG, \"ext_1_RTransform\");\n    }\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":11997,"modified_method":"private EditorCell createProperty_hi5u6k_e0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"name\");\n    provider.setNoTargetText(\"<no name>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_name\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.RT_ANCHOR_TAG, \"ext_1_RTransform\");\n    }\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_hi5u6k_b2a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new SConceptQuery_Editor.parametersListHandler_hi5u6k_b2a(node, \"parameters\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_parameters\");\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":11998,"modified_method":"private EditorCell createRefNodeList_hi5u6k_b5a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new SConceptQuery_Editor.parametersListHandler_hi5u6k_b5a(node, \"parameters\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_parameters\");\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_hi5u6k_c2a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \")\");\n    editorCell.setCellId(\"Constant_hi5u6k_c2a\");\n    MqlSS_StyleSheet.getPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":11999,"modified_method":"private EditorCell createConstant_hi5u6k_c5a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \")\");\n    editorCell.setCellId(\"Constant_hi5u6k_c5a\");\n    MqlSS_StyleSheet.getPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"d2621e88f0f0c432f560ad487b0afc6c906dff12","url":"https://github.com/JetBrains/MPS"}]