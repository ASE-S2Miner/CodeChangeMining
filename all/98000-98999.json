[{"original_method":"private static void startArgumentLiveTemplate(InsertionContext context, PsiMethod method) {\n    TemplateManager manager = TemplateManager.getInstance(method.getProject());\n    Template template = manager.createTemplate(\"\", \"\");\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    for (int i = 0; i < parameters.length; i++) {\n      if (i > 0) {\n        template.addTextSegment(\", \");\n      }\n      String name = StringUtil.notNullize(parameters[i].getName());\n      template.addVariable(name, new MacroCallNode(new CompleteMacro()), new ConstantNode(name), true);\n    }\n\n    manager.startTemplate(context.getEditor(), template);\n  }","id":98000,"modified_method":"private void startArgumentLiveTemplate(InsertionContext context, PsiMethod method) {\n    TemplateManager manager = TemplateManager.getInstance(method.getProject());\n    Template template = manager.createTemplate(\"\", \"\");\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    for (int i = 0; i < parameters.length; i++) {\n      if (i > 0) {\n        template.addTextSegment(\", \");\n      }\n      String name = StringUtil.notNullize(parameters[i].getName());\n      template.addVariable(name, new MacroCallNode(new CompleteMacro()), new ConstantNode(name), true);\n    }\n\n    Editor editor = context.getEditor();\n    manager.startTemplate(editor, template);\n\n    TemplateState templateState = TemplateManagerImpl.getTemplateState(editor);\n    if (templateState == null) return;\n\n    editor.putUserData(ARGUMENT_TEMPLATE_ACTIVE, this);\n    Disposer.register(templateState, () -> {\n      if (editor.getUserData(ARGUMENT_TEMPLATE_ACTIVE) == this) {\n        editor.putUserData(ARGUMENT_TEMPLATE_ACTIVE, null);\n      }\n    });\n  }","commit_id":"877358aea3bb24a8b7c862cf51555c31258ff16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean nextTabOnItemSelected(final ExpressionContext context, final LookupElement item) {\n    final List<? extends PsiElement> elements = JavaCompletionUtil.getAllPsiElements(item);\n    if (elements != null && elements.size() == 1 && elements.get(0) instanceof PsiPackage) {\n      return false;\n    }\n    return true;\n  }","id":98001,"modified_method":"@Override\n  public boolean nextTabOnItemSelected(final ExpressionContext context, final LookupElement item) {\n    final List<? extends PsiElement> elements = JavaCompletionUtil.getAllPsiElements(item);\n    if (elements != null && elements.size() == 1 && elements.get(0) instanceof PsiPackage) {\n      return false;\n    }\n\n    Editor editor = context.getEditor();\n    if (editor != null && editor.getUserData(JavaMethodCallElement.ARGUMENT_TEMPLATE_ACTIVE) != null) {\n      return item.as(ClassConditionKey.create(SmartCompletionDecorator.class)) != null;\n    }\n\n    return true;\n  }","commit_id":"877358aea3bb24a8b7c862cf51555c31258ff16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void eventDispatched(AWTEvent event) {\n    if (!isShown()) {\n      return;\n    }\n    MouseEvent mouseEvent = (MouseEvent)event;\n    if (mouseEvent.getClickCount() == 0) {\n      return;\n    }\n\n    final int id = mouseEvent.getID();\n    if ((id != MouseEvent.MOUSE_PRESSED && id != MouseEvent.MOUSE_RELEASED && id != MouseEvent.MOUSE_CLICKED)) {\n      return;\n    }\n    \n    final Component sourceComponent = mouseEvent.getComponent();\n    final Point originalPoint = mouseEvent.getPoint();\n\n    final Lookup activeLookup = LookupManager.getInstance(getEditor().getProject()).getActiveLookup();\n    if (activeLookup != null){\n      final JLayeredPane layeredPane = getTree().getRootPane().getLayeredPane();\n      final Point layeredPoint = SwingUtilities.convertPoint(sourceComponent, originalPoint, layeredPane);\n      if (activeLookup.getBounds().contains(layeredPoint)){\n        return; //mouse click inside lookup\n      } else {\n        ((LookupImpl)activeLookup).hide(); //hide popup on mouse position changed\n      }\n    }\n\n    final Point point = SwingUtilities.convertPoint(sourceComponent, originalPoint, myInplaceEditorComponent);\n    if (myInplaceEditorComponent.contains(point)) {\n      return;\n    }\n    final Component componentAtPoint = SwingUtilities.getDeepestComponentAt(sourceComponent, originalPoint.x, originalPoint.y);\n    for (Component comp = componentAtPoint; comp != null; comp = comp.getParent()) {\n      if (comp instanceof ComboPopup) {\n        return;\n      }\n    }\n    cancelEditing();\n  }","id":98002,"modified_method":"public void eventDispatched(AWTEvent event) {\n    if (!isShown()) {\n      return;\n    }\n    MouseEvent mouseEvent = (MouseEvent)event;\n    if (mouseEvent.getClickCount() == 0) {\n      return;\n    }\n\n    final int id = mouseEvent.getID();\n    if ((id != MouseEvent.MOUSE_PRESSED && id != MouseEvent.MOUSE_RELEASED && id != MouseEvent.MOUSE_CLICKED)) {\n      return;\n    }\n    \n    final Component sourceComponent = mouseEvent.getComponent();\n    final Point originalPoint = mouseEvent.getPoint();\n\n    final Editor editor = getEditor();\n    if (editor == null) return;\n    \n    final Lookup activeLookup = LookupManager.getInstance(editor.getProject()).getActiveLookup();\n    if (activeLookup != null){\n      final JLayeredPane layeredPane = getTree().getRootPane().getLayeredPane();\n      final Point layeredPoint = SwingUtilities.convertPoint(sourceComponent, originalPoint, layeredPane);\n      if (activeLookup.getBounds().contains(layeredPoint)){\n        return; //mouse click inside lookup\n      } else {\n        ((LookupImpl)activeLookup).hide(); //hide popup on mouse position changed\n      }\n    }\n\n    final Point point = SwingUtilities.convertPoint(sourceComponent, originalPoint, myInplaceEditorComponent);\n    if (myInplaceEditorComponent.contains(point)) {\n      return;\n    }\n    final Component componentAtPoint = SwingUtilities.getDeepestComponentAt(sourceComponent, originalPoint.x, originalPoint.y);\n    for (Component comp = componentAtPoint; comp != null; comp = comp.getParent()) {\n      if (comp instanceof ComboPopup) {\n        return;\n      }\n    }\n    cancelEditing();\n  }","commit_id":"8ae6eb1a9559ddeed043173e18b4a2f40c75ecb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addDocListener(Document document) {\n    final VirtualFile file = myDocumentManager.getFile(document);\n    if (file != null && file.isValid() && !myListenerMap.containsKey(file)) {\n      final MyDocumentChangeAdapter adapter = new MyDocumentChangeAdapter();\n      document.addDocumentListener(adapter);\n      myListenerMap.put(file, adapter);\n    }\n  }","id":98003,"modified_method":"public void addDocListener(VirtualFile file) {\n    if (file == null) return;\n    final Document document = myDocumentManager.getDocument(file);\n    if (file.isValid() && !myListenerMap.containsKey(file)) {\n      final MyDocumentChangeAdapter adapter = new MyDocumentChangeAdapter();\n      document.addDocumentListener(adapter);\n      myListenerMap.put(file, adapter);\n    }\n  }","commit_id":"4a608f52fe7982e3aca4c686f0e70bbb9d5de177","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeDocListener(Document document, VirtualFile file) {\n    final MyDocumentChangeAdapter adapter = myListenerMap.remove(file);\n    if (adapter != null) {\n      document.removeDocumentListener(adapter);\n    }\n  }","id":98004,"modified_method":"public void removeDocListener(Document document, VirtualFile file) {\n    final MyDocumentChangeAdapter adapter = myListenerMap.remove(file);\n    if (adapter != null) {\n      document.removeDocumentListener(adapter);\n    }\n  }","commit_id":"4a608f52fe7982e3aca4c686f0e70bbb9d5de177","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void editorCreated(EditorFactoryEvent event) {\n    final Editor editor = event.getEditor();\n    if (editor.getProject() != myProject) return;\n    addDocListener(editor.getDocument());\n  }","id":98005,"modified_method":"@Override\n  public void editorCreated(EditorFactoryEvent event) {\n    final Editor editor = event.getEditor();\n    if (editor.getProject() != myProject) return;\n    addDocListener(((EditorEx)editor).getVirtualFile());\n  }","commit_id":"4a608f52fe7982e3aca4c686f0e70bbb9d5de177","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void editorReleased(EditorFactoryEvent event) {\n    removeDocListener(event.getEditor().getDocument());\n  }","id":98006,"modified_method":"@Override\n  public void editorReleased(EditorFactoryEvent event) {\n    final EditorEx editor = (EditorEx)event.getEditor();\n    final VirtualFile file = editor.getVirtualFile();\n    if (file != null && file.isValid()) {\n      if (myFileEditorManager.isFileOpen(file)) {\n        return;\n      }\n    }\n    removeDocListener(editor.getDocument(), file);\n  }","commit_id":"4a608f52fe7982e3aca4c686f0e70bbb9d5de177","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest(final Runnable run, boolean shouldShow, final String hint) {\n    myFixture.configureByFile(\"/refactoring/changeSignatureGesture/\" + getTestName(false) + \".java\");\n    final ChangeSignatureGestureDetector detector = ChangeSignatureGestureDetector.getInstance(getProject());\n    final Document document = myFixture.getEditor().getDocument();\n    try {\n      PsiManager.getInstance(getProject()).addPsiTreeChangeListener(detector);\n      detector.addDocListener(document);\n      new WriteCommandAction.Simple(getProject()) {\n        @Override\n        protected void run() throws Throwable {\n          run.run();\n        }\n      }.execute().throwException();\n\n\n      myFixture.doHighlighting();\n      if (shouldShow) {\n        final IntentionAction intention = myFixture.findSingleIntention(hint);\n        myFixture.launchAction(intention);\n        myFixture.checkResultByFile(\"/refactoring/changeSignatureGesture/\" + getTestName(false) + \"_after.java\");\n      } else {\n        final List<IntentionAction> intentionActions = myFixture.filterAvailableIntentions(hint);\n        Assert.assertEquals(true, intentionActions.isEmpty());\n      }\n    }\n    finally {\n      detector.removeDocListener(document);\n      PsiManager.getInstance(getProject()).removePsiTreeChangeListener(detector);\n    }\n  }","id":98007,"modified_method":"private void doTest(final Runnable run, boolean shouldShow, final String hint) {\n    myFixture.configureByFile(\"/refactoring/changeSignatureGesture/\" + getTestName(false) + \".java\");\n    final ChangeSignatureGestureDetector detector = ChangeSignatureGestureDetector.getInstance(getProject());\n    final EditorEx editor = (EditorEx)myFixture.getEditor();\n    final Document document = editor.getDocument();\n    try {\n      PsiManager.getInstance(getProject()).addPsiTreeChangeListener(detector);\n      detector.addDocListener(editor.getVirtualFile());\n      new WriteCommandAction.Simple(getProject()) {\n        @Override\n        protected void run() throws Throwable {\n          run.run();\n        }\n      }.execute().throwException();\n\n\n      myFixture.doHighlighting();\n      if (shouldShow) {\n        final IntentionAction intention = myFixture.findSingleIntention(hint);\n        myFixture.launchAction(intention);\n        myFixture.checkResultByFile(\"/refactoring/changeSignatureGesture/\" + getTestName(false) + \"_after.java\");\n      } else {\n        final List<IntentionAction> intentionActions = myFixture.filterAvailableIntentions(hint);\n        Assert.assertEquals(true, intentionActions.isEmpty());\n      }\n    }\n    finally {\n      detector.removeDocListener(document, editor.getVirtualFile());\n      PsiManager.getInstance(getProject()).removePsiTreeChangeListener(detector);\n    }\n  }","commit_id":"4a608f52fe7982e3aca4c686f0e70bbb9d5de177","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Color getLineSeparatorColorForType(@Nullable TextAttributesKey type) {\n    LOG.assertTrue(type == DiffColors.DIFF_DELETED || type == DiffColors.DIFF_MODIFIED || type == null);\n    if (type == null || type == DiffColors.DIFF_MODIFIED) return Color.GRAY;\n    return TextDiffType.DELETED.getTextBackground(getEditor());\n  }","id":98008,"modified_method":"@Nullable\n  private Color getLineSeparatorColorForType(@NotNull TextDiffType type) {\n    EditorEx editor = getEditor();\n    if (editor == null) {\n      return null;\n    }\n    return type.getPolygonColor(editor);\n  }","commit_id":"2abdf4f0192b47d63b9efb7d051d49701089f560","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addBottomLine(final Fragment fragment, DiffMarkup appender, int endLine) {\n    if (endLine <= 0) return;\n    TextRange range = fragment.getRange(appender.getSide());\n    appender.addLineMarker(endLine - 1, getRangeType(fragment, range));\n  }","id":98009,"modified_method":"private static void addSeparatingLine(final Fragment fragment, DiffMarkup appender, int startLine, int endLine) {\n    if (endLine <= 0) return;\n    TextDiffTypeEnum type = fragment.getType();\n    appender.addLineMarker(endLine - 1, type == null ? null : TextDiffType.create(type), SeparatorPlacement.BOTTOM);\n    if (fragment.getRange(appender.getSide()).getLength() > 0) {\n      appender.addLineMarker(startLine, type == null ? null : TextDiffType.create(type), SeparatorPlacement.TOP);\n    }\n  }","commit_id":"2abdf4f0192b47d63b9efb7d051d49701089f560","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void highlightLine(final LineFragment fragment) {\n    highlightFragmentImpl(fragment);\n\n    addModifyActions(fragment, myAppender1, myAppender2);\n    final Iterator<Fragment> iterator = fragment.getChildrenIterator();\n    if (iterator == null) {\n      highlightFragmentImpl(fragment);\n    }\n    else {\n      for (; iterator.hasNext();) {\n        Fragment childFragment = iterator.next();\n        childFragment.highlight(this);\n      }\n    }\n    if (fragment.isEqual() && myIsLast) return;\n    addBottomLine(fragment, myAppender1, fragment.getEndLine1());\n    addBottomLine(fragment, myAppender2, fragment.getEndLine2());\n  }","id":98010,"modified_method":"public void highlightLine(final LineFragment fragment) {\n    highlightFragmentImpl(fragment);\n\n    addModifyActions(fragment, myAppender1, myAppender2);\n    final Iterator<Fragment> iterator = fragment.getChildrenIterator();\n    if (iterator == null) {\n      highlightFragmentImpl(fragment);\n    }\n    else {\n      while (iterator.hasNext()) {\n        Fragment childFragment = iterator.next();\n        childFragment.highlight(this);\n      }\n    }\n    if (fragment.isEqual() && myIsLast) return;\n    addSeparatingLine(fragment, myAppender1, fragment.getStartingLine1(), fragment.getEndLine1());\n    addSeparatingLine(fragment, myAppender2, fragment.getStartingLine2(), fragment.getEndLine2());\n  }","commit_id":"2abdf4f0192b47d63b9efb7d051d49701089f560","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    // 1. Show light bulb\n    myManager.showIntentionHint();\n\n    // 2. Commit possible non committed value and show popup\n    final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(myManager.getEditor().getProject());\n    final PropertyInspector propertyInspector = manager.getPropertyInspector();\n    if(propertyInspector != null && propertyInspector.isEditing()) {\n      propertyInspector.stopEditing();\n    }\n    myManager.showIntentionPopup();\n  }","id":98011,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n    final GuiEditor editor = myManager.getEditor();\n    if (editor == null) return;\n\n    // 1. Show light bulb\n    myManager.showIntentionHint();\n\n    // 2. Commit possible non committed value and show popup\n    final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(editor.getProject());\n    final PropertyInspector propertyInspector = manager.getPropertyInspector();\n    if(propertyInspector != null && propertyInspector.isEditing()) {\n      propertyInspector.stopEditing();\n    }\n    myManager.showIntentionPopup();\n  }","commit_id":"28468750761bc0c441ce4c13ed6e2a3ddb82f47b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlAttributeInsertHandler(@Nullable String namespaceToInsert, @Nullable String namespacePrefixToInsert) {\n    myNamespaceToInsert = namespaceToInsert;\n    myNamespacePrefixToInsert = namespacePrefixToInsert;\n  }","id":98012,"modified_method":"public XmlAttributeInsertHandler(@Nullable String namespaceToInsert) {\n    myNamespaceToInsert = namespaceToInsert;\n  }","commit_id":"ce19f3866183ff6a8dd4a4761895f0feae6ab6f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleInsert(InsertionContext context, LookupElement item) {\n    final Editor editor = context.getEditor();\n\n    final Document document = editor.getDocument();\n    final int caretOffset = editor.getCaretModel().getOffset();\n    PsiFile file = context.getFile();\n    if (file.getLanguage() == HTMLLanguage.INSTANCE &&\n        HtmlUtil.isSingleHtmlAttribute((String)item.getObject())) {\n      return;\n    }\n\n    final CharSequence chars = document.getCharsSequence();\n    if (!CharArrayUtil.regionMatches(chars, caretOffset, \"=\\\"\") && !CharArrayUtil.regionMatches(chars, caretOffset, \"='\")) {\n      PsiElement fileContext = file.getContext();\n      String toInsert= \"=\\\"\\\"\";\n\n      if(fileContext != null) {\n        if (fileContext.getText().startsWith(\"\\\"\")) toInsert = \"=''\";\n      }\n      \n      if (caretOffset >= document.getTextLength() || \"/> \\n\\t\\r\".indexOf(document.getCharsSequence().charAt(caretOffset)) < 0) {\n        document.insertString(caretOffset, toInsert + \" \");\n      }\n      else {\n        document.insertString(caretOffset, toInsert);\n      }\n\n      if ('=' == context.getCompletionChar()) {\n        context.setAddCompletionChar(false); // IDEA-19449\n      }\n    }\n\n    editor.getCaretModel().moveToOffset(caretOffset + 2);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    editor.getSelectionModel().removeSelection();\n    AutoPopupController.getInstance(editor.getProject()).scheduleAutoPopup(editor);\n\n    if (myNamespaceToInsert != null && file instanceof XmlFile) {\n      final XmlNamespaceHelper helper = XmlNamespaceHelper.getHelper(context.getFile());\n\n      if (helper != null) {\n        PsiDocumentManager.getInstance(context.getProject()).commitDocument(document);\n        helper.insertNamespaceDeclaration((XmlFile)file, editor, Collections.singleton(myNamespaceToInsert),\n                                          myNamespacePrefixToInsert, null);\n      }\n    }\n  }","id":98013,"modified_method":"public void handleInsert(final InsertionContext context, final LookupElement item) {\n    final Editor editor = context.getEditor();\n\n    final Document document = editor.getDocument();\n    final int caretOffset = editor.getCaretModel().getOffset();\n    final PsiFile file = context.getFile();\n    if (file.getLanguage() == HTMLLanguage.INSTANCE &&\n        HtmlUtil.isSingleHtmlAttribute((String)item.getObject())) {\n      return;\n    }\n\n    final CharSequence chars = document.getCharsSequence();\n    if (!CharArrayUtil.regionMatches(chars, caretOffset, \"=\\\"\") && !CharArrayUtil.regionMatches(chars, caretOffset, \"='\")) {\n      PsiElement fileContext = file.getContext();\n      String toInsert= \"=\\\"\\\"\";\n\n      if(fileContext != null) {\n        if (fileContext.getText().startsWith(\"\\\"\")) toInsert = \"=''\";\n      }\n      \n      if (caretOffset >= document.getTextLength() || \"/> \\n\\t\\r\".indexOf(document.getCharsSequence().charAt(caretOffset)) < 0) {\n        document.insertString(caretOffset, toInsert + \" \");\n      }\n      else {\n        document.insertString(caretOffset, toInsert);\n      }\n\n      if ('=' == context.getCompletionChar()) {\n        context.setAddCompletionChar(false); // IDEA-19449\n      }\n    }\n\n    editor.getCaretModel().moveToOffset(caretOffset + 2);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    editor.getSelectionModel().removeSelection();\n    AutoPopupController.getInstance(editor.getProject()).scheduleAutoPopup(editor);\n\n    if (myNamespaceToInsert != null && file instanceof XmlFile) {\n      final PsiElement element = file.findElementAt(context.getStartOffset());\n      final XmlTag tag = element != null ? PsiTreeUtil.getParentOfType(element, XmlTag.class) : null;\n\n      if (tag != null) {\n        String prefix = ExtendedTagInsertHandler.suggestPrefix((XmlFile)file, myNamespaceToInsert);\n\n        if (prefix != null) {\n          prefix = makePrefixUnique(prefix, tag);\n          final XmlNamespaceHelper helper = XmlNamespaceHelper.getHelper(context.getFile());\n\n          if (helper != null) {\n            final Project project = context.getProject();\n            PsiDocumentManager.getInstance(project).commitDocument(document);\n            qualifyWithPrefix(prefix, element);\n            helper.insertNamespaceDeclaration((XmlFile)file, editor, Collections.singleton(\n              myNamespaceToInsert), prefix, null);\n          }\n        }\n      }\n    }\n  }","commit_id":"ce19f3866183ff6a8dd4a4761895f0feae6ab6f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlAttributeInsertHandler() {\n    this(null, null);\n  }","id":98014,"modified_method":"public XmlAttributeInsertHandler() {\n    this(null);\n  }","commit_id":"ce19f3866183ff6a8dd4a4761895f0feae6ab6f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addVariants(final CompletionResultSet result,\n                                  final XmlAttribute[] attributes,\n                                  final XmlAttributeDescriptor[] descriptors,\n                                  XmlAttribute attribute,\n                                  @Nullable InsertHandler<LookupElement> replacementInsertHandler) {\n    final XmlTag tag = attribute.getParent();\n    final PsiFile file = tag.getContainingFile();\n    final XmlExtension extension = XmlExtension.getExtension(file);\n    final String prefix = attribute.getName().contains(\":\") && ((XmlAttributeImpl) attribute).getRealLocalName().length() > 0\n                          ? attribute.getNamespacePrefix() + \":\"\n                          : null;\n\n    CompletionData\n      completionData = CompletionUtil.getCompletionDataByElement(attribute, attribute.getContainingFile().getOriginalFile());\n    boolean caseSensitive = !(completionData instanceof HtmlCompletionData) || ((HtmlCompletionData)completionData).isCaseSensitive();\n\n    for (XmlAttributeDescriptor descriptor : descriptors) {\n      if (isValidVariant(attribute, descriptor, attributes, extension)) {\n        String name = descriptor.getName(tag);\n\n        InsertHandler<LookupElement> insertHandler = XmlAttributeInsertHandler.INSTANCE;\n\n        if (replacementInsertHandler != null) {\n          insertHandler = replacementInsertHandler;\n        }\n        else if (descriptor instanceof NamespaceAwareXmlAttributeDescriptor) {\n          final String namespace = ((NamespaceAwareXmlAttributeDescriptor)descriptor).getNamespace(tag);\n\n          if (file instanceof XmlFile &&\n              namespace != null &&\n              namespace.length() > 0 &&\n              !name.contains(\":\") &&\n              tag.getPrefixByNamespace(namespace) == null) {\n            String suggestedPrefix = ExtendedTagInsertHandler.suggestPrefix((XmlFile)file, namespace);\n\n            if (suggestedPrefix != null) {\n              suggestedPrefix = makePrefixUnique(suggestedPrefix, tag);\n              name = suggestedPrefix + \":\" + name;\n              insertHandler = new XmlAttributeInsertHandler(namespace, suggestedPrefix);\n            }\n          }\n        }\n        if (prefix == null || name.startsWith(prefix)) {\n          if (prefix != null && name.length() > prefix.length()) {\n            name = descriptor.getName(tag).substring(prefix.length());\n          }\n          LookupElementBuilder element = LookupElementBuilder.create(name);\n          if (descriptor instanceof PsiPresentableMetaData) {\n            element = element.withIcon(((PsiPresentableMetaData)descriptor).getIcon());\n          }\n          final int separator = name.indexOf(':');\n          if (separator > 0) {\n            element = element.withLookupString(name.substring(separator + 1));\n          }\n          element = element\n            .withCaseSensitivity(caseSensitive)\n            .withInsertHandler(insertHandler);\n          result.addElement(\n            descriptor.isRequired() ? PrioritizedLookupElement.withPriority(element.appendTailText(\"(required)\", true), 100) : element);\n        }\n      }\n    }\n  }","id":98015,"modified_method":"private static void addVariants(final CompletionResultSet result,\n                                  final XmlAttribute[] attributes,\n                                  final XmlAttributeDescriptor[] descriptors,\n                                  XmlAttribute attribute,\n                                  @Nullable InsertHandler<LookupElement> replacementInsertHandler) {\n    final XmlTag tag = attribute.getParent();\n    final PsiFile file = tag.getContainingFile();\n    final XmlExtension extension = XmlExtension.getExtension(file);\n    final String prefix = attribute.getName().contains(\":\") && ((XmlAttributeImpl) attribute).getRealLocalName().length() > 0\n                          ? attribute.getNamespacePrefix() + \":\"\n                          : null;\n\n    CompletionData\n      completionData = CompletionUtil.getCompletionDataByElement(attribute, attribute.getContainingFile().getOriginalFile());\n    boolean caseSensitive = !(completionData instanceof HtmlCompletionData) || ((HtmlCompletionData)completionData).isCaseSensitive();\n\n    for (XmlAttributeDescriptor descriptor : descriptors) {\n      if (isValidVariant(attribute, descriptor, attributes, extension)) {\n        String name = descriptor.getName(tag);\n\n        InsertHandler<LookupElement> insertHandler = XmlAttributeInsertHandler.INSTANCE;\n\n        if (replacementInsertHandler != null) {\n          insertHandler = replacementInsertHandler;\n        }\n        else if (descriptor instanceof NamespaceAwareXmlAttributeDescriptor) {\n          final String namespace = ((NamespaceAwareXmlAttributeDescriptor)descriptor).getNamespace(tag);\n\n          if (file instanceof XmlFile &&\n              namespace != null &&\n              namespace.length() > 0 &&\n              !name.contains(\":\") &&\n              tag.getPrefixByNamespace(namespace) == null) {\n            insertHandler = new XmlAttributeInsertHandler(namespace);\n          }\n        }\n        if (prefix == null || name.startsWith(prefix)) {\n          if (prefix != null && name.length() > prefix.length()) {\n            name = descriptor.getName(tag).substring(prefix.length());\n          }\n          LookupElementBuilder element = LookupElementBuilder.create(name);\n          if (descriptor instanceof PsiPresentableMetaData) {\n            element = element.withIcon(((PsiPresentableMetaData)descriptor).getIcon());\n          }\n          final int separator = name.indexOf(':');\n          if (separator > 0) {\n            element = element.withLookupString(name.substring(separator + 1));\n          }\n          element = element\n            .withCaseSensitivity(caseSensitive)\n            .withInsertHandler(insertHandler);\n          result.addElement(\n            descriptor.isRequired() ? PrioritizedLookupElement.withPriority(element.appendTailText(\"(required)\", true), 100) : element);\n        }\n      }\n    }\n  }","commit_id":"ce19f3866183ff6a8dd4a4761895f0feae6ab6f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void executeWriteActionInner(Editor editor, DataContext dataContext) {\n    Project project = DataKeys.PROJECT.getData(dataContext);\n    if (project != null) {\n      PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n    }\n\n    if (project == null || !handleEnter(editor, dataContext, project) &&\n        myOriginalHandler != null &&\n        myOriginalHandler.isEnabled(editor, dataContext)) {\n      Document document = editor.getDocument();\n      PsiDocumentManager.getInstance(project).commitDocument(document);\n      myOriginalHandler.execute(editor, dataContext);\n    }\n  }","id":98016,"modified_method":"private void executeWriteActionInner(Editor editor, DataContext dataContext) {\n    Project project = DataKeys.PROJECT.getData(dataContext);\n    if (project != null) {\n      PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n    }\n\n    if (project == null || !handleEnter(editor, dataContext, project) &&\n        myOriginalHandler != null &&\n        myOriginalHandler.isEnabled(editor, dataContext)) {\n      Document document = editor.getDocument();\n      if (project != null) {\n        PsiDocumentManager.getInstance(project).commitDocument(document);\n      }\n      myOriginalHandler.execute(editor, dataContext);\n    }\n  }","commit_id":"cce77059200995498572e5dbad85cf547daabf87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void testReplicaRelocationWhileIndexing(final int numberOfRelocations, final int numberOfWriters, final boolean batch) throws Exception {\n        logger.info(\"--> starting [node1] ...\");\n        startNode(\"node1\");\n\n        logger.info(\"--> creating test index ...\");\n        client(\"node1\").admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 1)\n                ).execute().actionGet();\n\n        logger.info(\"--> starting [node2] ...\");\n        startNode(\"node2\");\n\n        ClusterHealthResponse healthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForNodes(\"2\").setWaitForGreenStatus().execute().actionGet();\n        assertThat(healthResponse.timedOut(), equalTo(false));\n\n        logger.info(\"--> starting [node3] ...\");\n        startNode(\"node3\");\n\n        healthResponse = client(\"node3\").admin().cluster().prepareHealth().setWaitForNodes(\"3\").setWaitForGreenStatus().execute().actionGet();\n        assertThat(healthResponse.timedOut(), equalTo(false));\n\n        final AtomicLong idGenerator = new AtomicLong();\n        final AtomicLong indexCounter = new AtomicLong();\n        final AtomicBoolean stop = new AtomicBoolean(false);\n        Thread[] writers = new Thread[numberOfWriters];\n        final CountDownLatch stopLatch = new CountDownLatch(writers.length);\n\n        logger.info(\"--> starting {} indexing threads\", writers.length);\n        for (int i = 0; i < writers.length; i++) {\n            final int indexerId = i;\n            writers[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        logger.info(\"**** starting indexing thread {}\", indexerId);\n                        while (!stop.get()) {\n                            if (batch) {\n                                BulkRequestBuilder bulkRequest = client(\"node1\").prepareBulk();\n                                for (int i = 0; i < 100; i++) {\n                                    long id = idGenerator.incrementAndGet();\n                                    if (id % 1000 == 0) {\n                                        client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                    }\n                                    bulkRequest.add(client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                            .setSource(\"test\", \"value\" + id));\n                                }\n                                BulkResponse bulkResponse = bulkRequest.execute().actionGet();\n                                for (BulkItemResponse bulkItemResponse : bulkResponse) {\n                                    if (!bulkItemResponse.failed()) {\n                                        indexCounter.incrementAndGet();\n                                    } else {\n                                        logger.warn(\"**** failed bulk indexing thread {}, {}/{}\", indexerId, bulkItemResponse.failure().getId(), bulkItemResponse.failure().getMessage());\n                                    }\n                                }\n                            } else {\n                                long id = idGenerator.incrementAndGet();\n                                if (id % 1000 == 0) {\n                                    client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                }\n                                client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                        .setSource(\"test\", \"value\" + id).execute().actionGet();\n                                indexCounter.incrementAndGet();\n                            }\n                        }\n                        logger.info(\"**** done indexing thread {}\", indexerId);\n                    } catch (Exception e) {\n                        logger.warn(\"**** failed indexing thread {}\", e, indexerId);\n                    } finally {\n                        stopLatch.countDown();\n                    }\n                }\n            };\n            writers[i].start();\n        }\n\n        logger.info(\"--> waiting for 2000 docs to be indexed ...\");\n        while (client(\"node1\").prepareCount().setQuery(matchAllQuery()).execute().actionGet().count() < 2000) {\n            Thread.sleep(100);\n            client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        }\n        logger.info(\"--> 2000 docs indexed\");\n\n        logger.info(\"--> starting relocations...\");\n        for (int i = 0; i < numberOfRelocations; i++) {\n            String fromNode = \"node\" + (2 + (i % 2));\n            String toNode = \"node2\".equals(fromNode) ? \"node3\" : \"node2\";\n            logger.info(\"--> START relocate the shard from {} to {}\", fromNode, toNode);\n            client(\"node1\").admin().cluster().prepareReroute()\n                    .add(new MoveAllocationCommand(new ShardId(\"test\", 0), fromNode, toNode))\n                    .execute().actionGet();\n            ClusterHealthResponse clusterHealthResponse = client(\"node1\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            logger.info(\"--> DONE relocate the shard from {} to {}\", fromNode, toNode);\n        }\n        logger.info(\"--> done relocations\");\n\n        logger.info(\"--> marking and waiting for indexing threads to stop ...\");\n        stop.set(true);\n        stopLatch.await();\n        logger.info(\"--> indexing threads stopped\");\n\n        logger.info(\"--> refreshing the index\");\n        client(\"node1\").admin().indices().prepareRefresh(\"test\").execute().actionGet();\n        logger.info(\"--> searching the index\");\n        boolean ranOnce = false;\n        for (int i = 0; i < 10; i++) {\n            try {\n                logger.info(\"--> START search test round {}\", i + 1);\n                SearchHits hits = client(\"node1\").prepareSearch(\"test\").setQuery(matchAllQuery()).setSize((int) indexCounter.get()).setNoFields().execute().actionGet().hits();\n                ranOnce = true;\n                if (hits.totalHits() != indexCounter.get()) {\n                    int[] hitIds = new int[(int) indexCounter.get()];\n                    for (int hit = 0; hit < indexCounter.get(); hit++) {\n                        hitIds[hit] = hit + 1;\n                    }\n                    TIntSet set = new TIntHashSet(hitIds);\n                    for (SearchHit hit : hits.hits()) {\n                        int id = Integer.parseInt(hit.id());\n                        if (!set.remove(id)) {\n                            logger.error(\"Extra id [{}]\", id);\n                        }\n                    }\n                    set.forEach(new TIntProcedure() {\n                        @Override\n                        public boolean execute(int value) {\n                            logger.error(\"Missing id [{}]\", value);\n                            return true;\n                        }\n                    });\n                }\n                assertThat(hits.totalHits(), equalTo(indexCounter.get()));\n                logger.info(\"--> DONE search test round {}\", i + 1);\n            } catch (SearchPhaseExecutionException ex) {\n                // TODO: the first run fails with this failure, waiting for relocating nodes set to 0 is not enough?\n                logger.warn(\"Got exception while searching.\", ex);\n            }\n        }\n        if (!ranOnce) {\n            assert false;\n        }\n    }","id":98017,"modified_method":"private void testReplicaRelocationWhileIndexing(final int numberOfRelocations, final int numberOfWriters, final boolean batch) throws Exception {\n        logger.info(\"--> starting [node1] ...\");\n        startNode(\"node1\");\n\n        logger.info(\"--> creating test index ...\");\n        client(\"node1\").admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 1)\n                ).execute().actionGet();\n\n        logger.info(\"--> starting [node2] ...\");\n        startNode(\"node2\");\n\n        ClusterHealthResponse healthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForNodes(\"2\").setWaitForGreenStatus().execute().actionGet();\n        assertThat(healthResponse.timedOut(), equalTo(false));\n\n        logger.info(\"--> starting [node3] ...\");\n        startNode(\"node3\");\n\n        healthResponse = client(\"node3\").admin().cluster().prepareHealth().setWaitForNodes(\"3\").setWaitForGreenStatus().execute().actionGet();\n        assertThat(healthResponse.timedOut(), equalTo(false));\n\n        final AtomicLong idGenerator = new AtomicLong();\n        final AtomicLong indexCounter = new AtomicLong();\n        final AtomicBoolean stop = new AtomicBoolean(false);\n        Thread[] writers = new Thread[numberOfWriters];\n        final CountDownLatch stopLatch = new CountDownLatch(writers.length);\n\n        logger.info(\"--> starting {} indexing threads\", writers.length);\n        for (int i = 0; i < writers.length; i++) {\n            final int indexerId = i;\n            writers[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        logger.info(\"**** starting indexing thread {}\", indexerId);\n                        while (!stop.get()) {\n                            if (batch) {\n                                BulkRequestBuilder bulkRequest = client(\"node1\").prepareBulk();\n                                for (int i = 0; i < 100; i++) {\n                                    long id = idGenerator.incrementAndGet();\n                                    if (id % 1000 == 0) {\n                                        client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                    }\n                                    bulkRequest.add(client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                            .setSource(\"test\", \"value\" + id));\n                                }\n                                BulkResponse bulkResponse = bulkRequest.execute().actionGet();\n                                for (BulkItemResponse bulkItemResponse : bulkResponse) {\n                                    if (!bulkItemResponse.failed()) {\n                                        indexCounter.incrementAndGet();\n                                    } else {\n                                        logger.warn(\"**** failed bulk indexing thread {}, {}/{}\", indexerId, bulkItemResponse.failure().getId(), bulkItemResponse.failure().getMessage());\n                                    }\n                                }\n                            } else {\n                                long id = idGenerator.incrementAndGet();\n                                if (id % 1000 == 0) {\n                                    client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                }\n                                client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                        .setSource(\"test\", \"value\" + id).execute().actionGet();\n                                indexCounter.incrementAndGet();\n                            }\n                        }\n                        logger.info(\"**** done indexing thread {}\", indexerId);\n                    } catch (Exception e) {\n                        logger.warn(\"**** failed indexing thread {}\", e, indexerId);\n                    } finally {\n                        stopLatch.countDown();\n                    }\n                }\n            };\n            writers[i].start();\n        }\n\n        logger.info(\"--> waiting for 2000 docs to be indexed ...\");\n        while (client(\"node1\").prepareCount().setQuery(matchAllQuery()).execute().actionGet().count() < 2000) {\n            Thread.sleep(100);\n            client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        }\n        logger.info(\"--> 2000 docs indexed\");\n\n        logger.info(\"--> starting relocations...\");\n        for (int i = 0; i < numberOfRelocations; i++) {\n            String fromNode = \"node\" + (2 + (i % 2));\n            String toNode = \"node2\".equals(fromNode) ? \"node3\" : \"node2\";\n            logger.info(\"--> START relocate the shard from {} to {}\", fromNode, toNode);\n            client(\"node1\").admin().cluster().prepareReroute()\n                    .add(new MoveAllocationCommand(new ShardId(\"test\", 0), fromNode, toNode))\n                    .execute().actionGet();\n            ClusterHealthResponse clusterHealthResponse = client(\"node1\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).setTimeout(ACCEPTABLE_RELOCATION_TIME).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).setTimeout(ACCEPTABLE_RELOCATION_TIME).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            logger.info(\"--> DONE relocate the shard from {} to {}\", fromNode, toNode);\n        }\n        logger.info(\"--> done relocations\");\n\n        logger.info(\"--> marking and waiting for indexing threads to stop ...\");\n        stop.set(true);\n        stopLatch.await();\n        logger.info(\"--> indexing threads stopped\");\n\n        logger.info(\"--> refreshing the index\");\n        client(\"node1\").admin().indices().prepareRefresh(\"test\").execute().actionGet();\n        logger.info(\"--> searching the index\");\n        boolean ranOnce = false;\n        for (int i = 0; i < 10; i++) {\n            try {\n                logger.info(\"--> START search test round {}\", i + 1);\n                SearchHits hits = client(\"node1\").prepareSearch(\"test\").setQuery(matchAllQuery()).setSize((int) indexCounter.get()).setNoFields().execute().actionGet().hits();\n                ranOnce = true;\n                if (hits.totalHits() != indexCounter.get()) {\n                    int[] hitIds = new int[(int) indexCounter.get()];\n                    for (int hit = 0; hit < indexCounter.get(); hit++) {\n                        hitIds[hit] = hit + 1;\n                    }\n                    TIntSet set = new TIntHashSet(hitIds);\n                    for (SearchHit hit : hits.hits()) {\n                        int id = Integer.parseInt(hit.id());\n                        if (!set.remove(id)) {\n                            logger.error(\"Extra id [{}]\", id);\n                        }\n                    }\n                    set.forEach(new TIntProcedure() {\n                        @Override\n                        public boolean execute(int value) {\n                            logger.error(\"Missing id [{}]\", value);\n                            return true;\n                        }\n                    });\n                }\n                assertThat(hits.totalHits(), equalTo(indexCounter.get()));\n                logger.info(\"--> DONE search test round {}\", i + 1);\n            } catch (SearchPhaseExecutionException ex) {\n                // TODO: the first run fails with this failure, waiting for relocating nodes set to 0 is not enough?\n                logger.warn(\"Got exception while searching.\", ex);\n            }\n        }\n        if (!ranOnce) {\n            assert false;\n        }\n    }","commit_id":"5519f80abba5d42ae5a6d69b9659c596fd8717eb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void testPrimaryRelocationWhileIndexing(final int numberOfRelocations, final int numberOfWriters, final boolean batch) throws Exception {\n        logger.info(\"--> starting [node1] ...\");\n        startNode(\"node1\");\n\n        logger.info(\"--> creating test index ...\");\n        client(\"node1\").admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 0)\n                ).execute().actionGet();\n\n        logger.info(\"--> starting [node2] ...\");\n        startNode(\"node2\");\n\n        final AtomicLong idGenerator = new AtomicLong();\n        final AtomicLong indexCounter = new AtomicLong();\n        final AtomicBoolean stop = new AtomicBoolean(false);\n        Thread[] writers = new Thread[numberOfWriters];\n        final CountDownLatch stopLatch = new CountDownLatch(writers.length);\n\n        logger.info(\"--> starting {} indexing threads\", writers.length);\n        for (int i = 0; i < writers.length; i++) {\n            final int indexerId = i;\n            writers[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        logger.info(\"**** starting indexing thread {}\", indexerId);\n                        while (!stop.get()) {\n                            if (batch) {\n                                BulkRequestBuilder bulkRequest = client(\"node1\").prepareBulk();\n                                for (int i = 0; i < 100; i++) {\n                                    long id = idGenerator.incrementAndGet();\n                                    if (id % 1000 == 0) {\n                                        client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                    }\n                                    bulkRequest.add(client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                            .setSource(\"test\", \"value\" + id));\n                                }\n                                BulkResponse bulkResponse = bulkRequest.execute().actionGet();\n                                for (BulkItemResponse bulkItemResponse : bulkResponse) {\n                                    if (!bulkItemResponse.failed()) {\n                                        indexCounter.incrementAndGet();\n                                    } else {\n                                        logger.warn(\"**** failed bulk indexing thread {}, {}/{}\", indexerId, bulkItemResponse.failure().getId(), bulkItemResponse.failure().getMessage());\n                                    }\n                                }\n                            } else {\n                                long id = idGenerator.incrementAndGet();\n                                if (id % 1000 == 0) {\n                                    client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                }\n                                client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                        .setSource(\"test\", \"value\" + id).execute().actionGet();\n                                indexCounter.incrementAndGet();\n                            }\n                        }\n                        logger.info(\"**** done indexing thread {}\", indexerId);\n                    } catch (Exception e) {\n                        logger.warn(\"**** failed indexing thread {}\", e, indexerId);\n                    } finally {\n                        stopLatch.countDown();\n                    }\n                }\n            };\n            writers[i].start();\n        }\n\n        logger.info(\"--> waiting for 2000 docs to be indexed ...\");\n        while (client(\"node1\").prepareCount().setQuery(matchAllQuery()).execute().actionGet().count() < 2000) {\n            Thread.sleep(100);\n            client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        }\n        logger.info(\"--> 2000 docs indexed\");\n\n        logger.info(\"--> starting relocations...\");\n        for (int i = 0; i < numberOfRelocations; i++) {\n            String fromNode = \"node\" + (1 + (i % 2));\n            String toNode = \"node1\".equals(fromNode) ? \"node2\" : \"node1\";\n            logger.info(\"--> START relocate the shard from {} to {}\", fromNode, toNode);\n            client(\"node1\").admin().cluster().prepareReroute()\n                    .add(new MoveAllocationCommand(new ShardId(\"test\", 0), fromNode, toNode))\n                    .execute().actionGet();\n            ClusterHealthResponse clusterHealthResponse = client(\"node1\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            logger.info(\"--> DONE relocate the shard from {} to {}\", fromNode, toNode);\n        }\n        logger.info(\"--> done relocations\");\n\n        logger.info(\"--> marking and waiting for indexing threads to stop ...\");\n        stop.set(true);\n        stopLatch.await();\n        logger.info(\"--> indexing threads stopped\");\n\n        logger.info(\"--> refreshing the index\");\n        client(\"node1\").admin().indices().prepareRefresh(\"test\").execute().actionGet();\n        logger.info(\"--> searching the index\");\n        boolean ranOnce = false;\n        for (int i = 0; i < 10; i++) {\n            try {\n                logger.info(\"--> START search test round {}\", i + 1);\n                SearchHits hits = client(\"node1\").prepareSearch(\"test\").setQuery(matchAllQuery()).setSize((int) indexCounter.get()).setNoFields().execute().actionGet().hits();\n                ranOnce = true;\n                if (hits.totalHits() != indexCounter.get()) {\n                    int[] hitIds = new int[(int) indexCounter.get()];\n                    for (int hit = 0; hit < indexCounter.get(); hit++) {\n                        hitIds[hit] = hit + 1;\n                    }\n                    TIntSet set = new TIntHashSet(hitIds);\n                    for (SearchHit hit : hits.hits()) {\n                        int id = Integer.parseInt(hit.id());\n                        if (!set.remove(id)) {\n                            logger.error(\"Extra id [{}]\", id);\n                        }\n                    }\n                    set.forEach(new TIntProcedure() {\n                        @Override\n                        public boolean execute(int value) {\n                            logger.error(\"Missing id [{}]\", value);\n                            return true;\n                        }\n                    });\n                }\n                assertThat(hits.totalHits(), equalTo(indexCounter.get()));\n                logger.info(\"--> DONE search test round {}\", i + 1);\n            } catch (SearchPhaseExecutionException ex) {\n                // TODO: the first run fails with this failure, waiting for relocating nodes set to 0 is not enough?\n                logger.warn(\"Got exception while searching.\", ex);\n            }\n        }\n        if (!ranOnce) {\n            assert false;\n        }\n    }","id":98018,"modified_method":"private void testPrimaryRelocationWhileIndexing(final int numberOfRelocations, final int numberOfWriters, final boolean batch) throws Exception {\n        logger.info(\"--> starting [node1] ...\");\n        startNode(\"node1\");\n\n        logger.info(\"--> creating test index ...\");\n        client(\"node1\").admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 0)\n                ).execute().actionGet();\n\n        logger.info(\"--> starting [node2] ...\");\n        startNode(\"node2\");\n\n        final AtomicLong idGenerator = new AtomicLong();\n        final AtomicLong indexCounter = new AtomicLong();\n        final AtomicBoolean stop = new AtomicBoolean(false);\n        Thread[] writers = new Thread[numberOfWriters];\n        final CountDownLatch stopLatch = new CountDownLatch(writers.length);\n\n        logger.info(\"--> starting {} indexing threads\", writers.length);\n        for (int i = 0; i < writers.length; i++) {\n            final int indexerId = i;\n            writers[i] = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        logger.info(\"**** starting indexing thread {}\", indexerId);\n                        while (!stop.get()) {\n                            if (batch) {\n                                BulkRequestBuilder bulkRequest = client(\"node1\").prepareBulk();\n                                for (int i = 0; i < 100; i++) {\n                                    long id = idGenerator.incrementAndGet();\n                                    if (id % 1000 == 0) {\n                                        client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                    }\n                                    bulkRequest.add(client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                            .setSource(\"test\", \"value\" + id));\n                                }\n                                BulkResponse bulkResponse = bulkRequest.execute().actionGet();\n                                for (BulkItemResponse bulkItemResponse : bulkResponse) {\n                                    if (!bulkItemResponse.failed()) {\n                                        indexCounter.incrementAndGet();\n                                    } else {\n                                        logger.warn(\"**** failed bulk indexing thread {}, {}/{}\", indexerId, bulkItemResponse.failure().getId(), bulkItemResponse.failure().getMessage());\n                                    }\n                                }\n                            } else {\n                                long id = idGenerator.incrementAndGet();\n                                if (id % 1000 == 0) {\n                                    client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n                                }\n                                client(\"node1\").prepareIndex(\"test\", \"type1\", Long.toString(id))\n                                        .setSource(\"test\", \"value\" + id).execute().actionGet();\n                                indexCounter.incrementAndGet();\n                            }\n                        }\n                        logger.info(\"**** done indexing thread {}\", indexerId);\n                    } catch (Exception e) {\n                        logger.warn(\"**** failed indexing thread {}\", e, indexerId);\n                    } finally {\n                        stopLatch.countDown();\n                    }\n                }\n            };\n            writers[i].start();\n        }\n\n        logger.info(\"--> waiting for 2000 docs to be indexed ...\");\n        while (client(\"node1\").prepareCount().setQuery(matchAllQuery()).execute().actionGet().count() < 2000) {\n            Thread.sleep(100);\n            client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        }\n        logger.info(\"--> 2000 docs indexed\");\n\n        logger.info(\"--> starting relocations...\");\n        for (int i = 0; i < numberOfRelocations; i++) {\n            String fromNode = \"node\" + (1 + (i % 2));\n            String toNode = \"node1\".equals(fromNode) ? \"node2\" : \"node1\";\n            logger.info(\"--> START relocate the shard from {} to {}\", fromNode, toNode);\n            client(\"node1\").admin().cluster().prepareReroute()\n                    .add(new MoveAllocationCommand(new ShardId(\"test\", 0), fromNode, toNode))\n                    .execute().actionGet();\n            ClusterHealthResponse clusterHealthResponse = client(\"node1\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).setTimeout(ACCEPTABLE_RELOCATION_TIME).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).setTimeout(ACCEPTABLE_RELOCATION_TIME).execute().actionGet();\n            assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n            logger.info(\"--> DONE relocate the shard from {} to {}\", fromNode, toNode);\n        }\n        logger.info(\"--> done relocations\");\n\n        logger.info(\"--> marking and waiting for indexing threads to stop ...\");\n        stop.set(true);\n        stopLatch.await();\n        logger.info(\"--> indexing threads stopped\");\n\n        logger.info(\"--> refreshing the index\");\n        client(\"node1\").admin().indices().prepareRefresh(\"test\").execute().actionGet();\n        logger.info(\"--> searching the index\");\n        boolean ranOnce = false;\n        for (int i = 0; i < 10; i++) {\n            try {\n                logger.info(\"--> START search test round {}\", i + 1);\n                SearchHits hits = client(\"node1\").prepareSearch(\"test\").setQuery(matchAllQuery()).setSize((int) indexCounter.get()).setNoFields().execute().actionGet().hits();\n                ranOnce = true;\n                if (hits.totalHits() != indexCounter.get()) {\n                    int[] hitIds = new int[(int) indexCounter.get()];\n                    for (int hit = 0; hit < indexCounter.get(); hit++) {\n                        hitIds[hit] = hit + 1;\n                    }\n                    TIntSet set = new TIntHashSet(hitIds);\n                    for (SearchHit hit : hits.hits()) {\n                        int id = Integer.parseInt(hit.id());\n                        if (!set.remove(id)) {\n                            logger.error(\"Extra id [{}]\", id);\n                        }\n                    }\n                    set.forEach(new TIntProcedure() {\n                        @Override\n                        public boolean execute(int value) {\n                            logger.error(\"Missing id [{}]\", value);\n                            return true;\n                        }\n                    });\n                }\n                assertThat(hits.totalHits(), equalTo(indexCounter.get()));\n                logger.info(\"--> DONE search test round {}\", i + 1);\n            } catch (SearchPhaseExecutionException ex) {\n                // TODO: the first run fails with this failure, waiting for relocating nodes set to 0 is not enough?\n                logger.warn(\"Got exception while searching.\", ex);\n            }\n        }\n        if (!ranOnce) {\n            assert false;\n        }\n    }","commit_id":"5519f80abba5d42ae5a6d69b9659c596fd8717eb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleRelocationNoIndexing() {\n        logger.info(\"--> starting [node1] ...\");\n        startNode(\"node1\");\n\n        logger.info(\"--> creating test index ...\");\n        client(\"node1\").admin().indices().prepareCreate(\"test\")\n                .setSettings(ImmutableSettings.settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 0)\n                )\n                .execute().actionGet();\n\n        logger.info(\"--> index 10 docs\");\n        for (int i = 0; i < 10; i++) {\n            client(\"node1\").prepareIndex(\"test\", \"type\", Integer.toString(i)).setSource(\"field\", \"value\" + i).execute().actionGet();\n        }\n        logger.info(\"--> flush so we have an actual index\");\n        client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n        logger.info(\"--> index more docs so we have something in the translog\");\n        for (int i = 10; i < 20; i++) {\n            client(\"node1\").prepareIndex(\"test\", \"type\", Integer.toString(i)).setSource(\"field\", \"value\" + i).execute().actionGet();\n        }\n\n        logger.info(\"--> verifying count\");\n        client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        assertThat(client(\"node1\").prepareCount(\"test\").execute().actionGet().count(), equalTo(20l));\n\n        logger.info(\"--> start another node\");\n        startNode(\"node2\");\n        ClusterHealthResponse clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n\n        logger.info(\"--> relocate the shard from node1 to node2\");\n        client(\"node1\").admin().cluster().prepareReroute()\n                .add(new MoveAllocationCommand(new ShardId(\"test\", 0), \"node1\", \"node2\"))\n                .execute().actionGet();\n\n        clusterHealthResponse = client(\"node1\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).execute().actionGet();\n        assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n        clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).execute().actionGet();\n        assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n\n        logger.info(\"--> verifying count again...\");\n        client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        assertThat(client(\"node1\").prepareCount(\"test\").execute().actionGet().count(), equalTo(20l));\n    }","id":98019,"modified_method":"@Test\n    public void testSimpleRelocationNoIndexing() {\n        logger.info(\"--> starting [node1] ...\");\n        startNode(\"node1\");\n\n        logger.info(\"--> creating test index ...\");\n        client(\"node1\").admin().indices().prepareCreate(\"test\")\n                .setSettings(ImmutableSettings.settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 0)\n                )\n                .execute().actionGet();\n\n        logger.info(\"--> index 10 docs\");\n        for (int i = 0; i < 10; i++) {\n            client(\"node1\").prepareIndex(\"test\", \"type\", Integer.toString(i)).setSource(\"field\", \"value\" + i).execute().actionGet();\n        }\n        logger.info(\"--> flush so we have an actual index\");\n        client(\"node1\").admin().indices().prepareFlush().execute().actionGet();\n        logger.info(\"--> index more docs so we have something in the translog\");\n        for (int i = 10; i < 20; i++) {\n            client(\"node1\").prepareIndex(\"test\", \"type\", Integer.toString(i)).setSource(\"field\", \"value\" + i).execute().actionGet();\n        }\n\n        logger.info(\"--> verifying count\");\n        client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        assertThat(client(\"node1\").prepareCount(\"test\").execute().actionGet().count(), equalTo(20l));\n\n        logger.info(\"--> start another node\");\n        startNode(\"node2\");\n        ClusterHealthResponse clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForNodes(\"2\").execute().actionGet();\n        assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n\n        logger.info(\"--> relocate the shard from node1 to node2\");\n        client(\"node1\").admin().cluster().prepareReroute()\n                .add(new MoveAllocationCommand(new ShardId(\"test\", 0), \"node1\", \"node2\"))\n                .execute().actionGet();\n\n        clusterHealthResponse = client(\"node1\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).setTimeout(ACCEPTABLE_RELOCATION_TIME).execute().actionGet();\n        assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n        clusterHealthResponse = client(\"node2\").admin().cluster().prepareHealth().setWaitForRelocatingShards(0).setTimeout(ACCEPTABLE_RELOCATION_TIME).execute().actionGet();\n        assertThat(clusterHealthResponse.timedOut(), equalTo(false));\n\n        logger.info(\"--> verifying count again...\");\n        client(\"node1\").admin().indices().prepareRefresh().execute().actionGet();\n        assertThat(client(\"node1\").prepareCount(\"test\").execute().actionGet().count(), equalTo(20l));\n    }","commit_id":"5519f80abba5d42ae5a6d69b9659c596fd8717eb","url":"https://github.com/elastic/elasticsearch"},{"original_method":"void bat(String s) {\n    if (s == null) {\n      System.out.println();\n    }\n    if (s != null) {\n\n    } else {\n      \n    }\n  }","id":98020,"modified_method":"void bat(String s) {\n    if (s != null) {\n      System.out.println();\n    }\n    if (s == null) {\n\n    } else {\n      \n    }\n  }","commit_id":"201c7b55127cdf6069221eea938f2f2b3f8ba046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void money(String s) {\n    if ((s == null)) {\n      System.out.println();\n    }\n  }","id":98021,"modified_method":"void money(String s) {\n    if (((s) != (null))) {\n      System.out.println();\n    }\n  }","commit_id":"201c7b55127cdf6069221eea938f2f2b3f8ba046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkVariableUsage(PsiReferenceExpression referenceExpression, PsiElement thenContext, PsiElement elseContext) {\n      if (thenContext == null) {\n        return;\n      }\n      final PsiElement target = referenceExpression.resolve();\n      if (!(target instanceof PsiVariable)) {\n        return;\n      }\n      final PsiVariable variable = (PsiVariable)target;\n      if (contextExits(thenContext) || VariableAccessUtils.variableIsAssigned(variable, thenContext)) {\n        return;\n      }\n      if (elseContext != null && (contextExits(elseContext) || VariableAccessUtils.variableIsUsed(variable, elseContext))) {\n        return;\n      }\n      registerError(referenceExpression);\n    }","id":98022,"modified_method":"private boolean checkVariableUsage(PsiReferenceExpression referenceExpression, PsiElement thenContext, PsiElement elseContext) {\n      final PsiElement target = referenceExpression.resolve();\n      if (!(target instanceof PsiVariable)) {\n        return false;\n      }\n      final PsiVariable variable = (PsiVariable)target;\n      if (thenContext != null && (contextExits(thenContext) || VariableAccessUtils.variableIsAssigned(variable, thenContext))) {\n        return false;\n      }\n      if (elseContext == null || VariableAccessUtils.variableIsUsed(variable, elseContext)) {\n        return false;\n      }\n      return true;\n    }","commit_id":"201c7b55127cdf6069221eea938f2f2b3f8ba046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitIfStatement(PsiIfStatement statement) {\n      super.visitIfStatement(statement);\n      final PsiExpression condition = ParenthesesUtils.stripParentheses(statement.getCondition());\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression = (PsiBinaryExpression)condition;\n      final PsiReferenceExpression referenceExpression = extractVariableReference(binaryExpression);\n      if (referenceExpression == null) {\n        return;\n      }\n      final IElementType tokenType = binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        checkVariableUsage(referenceExpression, statement.getThenBranch(), statement.getElseBranch());\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        checkVariableUsage(referenceExpression, statement.getElseBranch(), statement.getThenBranch());\n      }\n    }","id":98023,"modified_method":"@Override\n    public void visitIfStatement(PsiIfStatement statement) {\n      super.visitIfStatement(statement);\n      final PsiExpression condition = ParenthesesUtils.stripParentheses(statement.getCondition());\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression = (PsiBinaryExpression)condition;\n      final PsiReferenceExpression referenceExpression = extractVariableReference(binaryExpression);\n      if (referenceExpression == null) {\n        return;\n      }\n      final IElementType tokenType = binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        if (checkVariableUsage(referenceExpression, statement.getThenBranch(), statement.getElseBranch())) {\n          registerError(referenceExpression, Boolean.TRUE);\n        }\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        if (checkVariableUsage(referenceExpression, statement.getElseBranch(), statement.getThenBranch())) {\n          registerError(referenceExpression, Boolean.TRUE);\n        }\n      }\n    }","commit_id":"201c7b55127cdf6069221eea938f2f2b3f8ba046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  protected String buildErrorString(Object... infos) {\n    return InspectionGadgetsBundle.message(\n      \"variable.not.used.inside.if.problem.descriptor\");\n  }","id":98024,"modified_method":"@Override\n  @NotNull\n  protected String buildErrorString(Object... infos) {\n    final boolean isIf = ((Boolean)infos[0]).booleanValue();\n    if (isIf) {\n      return InspectionGadgetsBundle.message(\"variable.not.used.inside.if.problem.descriptor\");\n    }\n    else {\n      return InspectionGadgetsBundle.message(\"variable.not.used.inside.conditional.problem.descriptor\");\n    }\n  }","commit_id":"201c7b55127cdf6069221eea938f2f2b3f8ba046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitConditionalExpression(PsiConditionalExpression expression) {\n      super.visitConditionalExpression(expression);\n      final PsiExpression condition = expression.getCondition();\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression = (PsiBinaryExpression)condition;\n      final PsiReferenceExpression referenceExpression = extractVariableReference(binaryExpression);\n      if (referenceExpression == null) {\n        return;\n      }\n      final IElementType tokenType = binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        checkVariableUsage(referenceExpression, expression.getThenExpression(), expression.getElseExpression());\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        checkVariableUsage(referenceExpression, expression.getElseExpression(), expression.getThenExpression());\n      }\n    }","id":98025,"modified_method":"@Override\n    public void visitConditionalExpression(PsiConditionalExpression expression) {\n      super.visitConditionalExpression(expression);\n      final PsiExpression condition = expression.getCondition();\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression = (PsiBinaryExpression)condition;\n      final PsiReferenceExpression referenceExpression = extractVariableReference(binaryExpression);\n      if (referenceExpression == null) {\n        return;\n      }\n      final IElementType tokenType = binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        if (checkVariableUsage(referenceExpression, expression.getThenExpression(), expression.getElseExpression())) {\n          registerError(referenceExpression, Boolean.FALSE);\n        }\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        if (checkVariableUsage(referenceExpression, expression.getElseExpression(), expression.getThenExpression())) {\n          registerError(referenceExpression, Boolean.FALSE);\n        }\n      }\n    }","commit_id":"201c7b55127cdf6069221eea938f2f2b3f8ba046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void traceOnException(TracedRouteNodes traced, Exchange exchange) throws Exception {\n        traced.addTraced(new DefaultRouteNode(traced.getLastNode().getProcessorDefinition(), traced.getLastNode().getProcessor()));\n        traced.addTraced(new OnExceptionRouteNode());\n        // log and trace so we have the from -> onException event as well\n        logExchange(exchange);\n        traceExchange(exchange);\n        traced.addTraced(new DefaultRouteNode(node, super.getProcessor()));\n    }","id":98026,"modified_method":"private void traceOnException(TracedRouteNodes traced, Exchange exchange) throws Exception {\n        if (traced.getLastNode() != null) {\n            traced.addTraced(new DefaultRouteNode(traced.getLastNode().getProcessorDefinition(), traced.getLastNode().getProcessor()));\n        }\n        traced.addTraced(new OnExceptionRouteNode());\n        // log and trace so we have the from -> onException event as well\n        logExchange(exchange);\n        traceExchange(exchange);\n        traced.addTraced(new DefaultRouteNode(node, super.getProcessor()));\n    }","commit_id":"db4fe9124d83dfa73ae20cdde8aa7c58ebcee7ea","url":"https://github.com/apache/camel"},{"original_method":"private void traceDoCatch(TracedRouteNodes traced, Exchange exchange) throws Exception {\n        traced.addTraced(new DefaultRouteNode(traced.getLastNode().getProcessorDefinition(), traced.getLastNode().getProcessor()));\n        traced.addTraced(new DoCatchRouteNode());\n        // log and trace so we have the from -> doCatch event as well\n        logExchange(exchange);\n        traceExchange(exchange);\n        traced.addTraced(new DefaultRouteNode(node, super.getProcessor()));\n    }","id":98027,"modified_method":"private void traceDoCatch(TracedRouteNodes traced, Exchange exchange) throws Exception {\n        if (traced.getLastNode() != null) {\n            traced.addTraced(new DefaultRouteNode(traced.getLastNode().getProcessorDefinition(), traced.getLastNode().getProcessor()));\n        }\n        traced.addTraced(new DoCatchRouteNode());\n        // log and trace so we have the from -> doCatch event as well\n        logExchange(exchange);\n        traceExchange(exchange);\n        traced.addTraced(new DefaultRouteNode(node, super.getProcessor()));\n    }","commit_id":"db4fe9124d83dfa73ae20cdde8aa7c58ebcee7ea","url":"https://github.com/apache/camel"},{"original_method":"private void traceDoFinally(TracedRouteNodes traced, Exchange exchange) throws Exception {\n        traced.addTraced(new DefaultRouteNode(traced.getLastNode().getProcessorDefinition(), traced.getLastNode().getProcessor()));\n        traced.addTraced(new DoFinallyRouteNode());\n        // log and trace so we have the from -> doFinally event as well\n        logExchange(exchange);\n        traceExchange(exchange);\n        traced.addTraced(new DefaultRouteNode(node, super.getProcessor()));\n    }","id":98028,"modified_method":"private void traceDoFinally(TracedRouteNodes traced, Exchange exchange) throws Exception {\n        if (traced.getLastNode() != null) {\n            traced.addTraced(new DefaultRouteNode(traced.getLastNode().getProcessorDefinition(), traced.getLastNode().getProcessor()));\n        }\n        traced.addTraced(new DoFinallyRouteNode());\n        // log and trace so we have the from -> doFinally event as well\n        logExchange(exchange);\n        traceExchange(exchange);\n        traced.addTraced(new DefaultRouteNode(node, super.getProcessor()));\n    }","commit_id":"db4fe9124d83dfa73ae20cdde8aa7c58ebcee7ea","url":"https://github.com/apache/camel"},{"original_method":"private MethodDocs getOperationDocInternal(OperationResourceInfo ori) throws Exception {\n        ClassDocs classDoc = getClassDocInternal(ori.getClassResourceInfo());\n        if (classDoc == null) {\n            return null;\n        }\n        String methodName = ori.getMethodToInvoke().getName();\n        MethodDocs mDocs = classDoc.getMethodDocs(methodName);\n        if (mDocs == null) {\n            String operLink = getOperLink();\n            String operMarker = operLink + methodName + \"(\";\n            int operMarkerIndex = classDoc.getClassDoc().indexOf(operMarker);\n            if (operMarkerIndex == -1) { \n                return null;\n            }\n            String operDoc = classDoc.getClassDoc().substring(operMarkerIndex + operMarker.length());\n            String operInfoTag = getOperInfoTag();\n            String operInfo = getJavaDocText(operDoc, operInfoTag, operLink, 0);\n            String responseInfo = null;\n            List<String> paramDocs = new LinkedList<String>();\n            if (!StringUtils.isEmpty(operInfo)) {\n                int returnsIndex = operDoc.indexOf(\"Returns:\", operLink.length());\n                int nextOpIndex = operDoc.indexOf(operLink);\n                if (returnsIndex != -1 && (nextOpIndex > returnsIndex || nextOpIndex == -1)) {\n                    responseInfo = getJavaDocText(operDoc, getResponseMarker(), operLink, returnsIndex + 8);\n                }\n            \n                int paramIndex = operDoc.indexOf(\"Parameters:\");\n                if (paramIndex != -1 && (nextOpIndex == -1 || paramIndex < nextOpIndex)) {\n                    String paramString = returnsIndex == -1 ? operDoc.substring(paramIndex)\n                        : operDoc.substring(paramIndex, returnsIndex); \n                    \n                    String codeTag = getCodeTag(); \n                    \n                    int codeIndex = paramString.indexOf(codeTag);\n                    while (codeIndex != -1) {\n                        int next = paramString.indexOf(\"<\", codeIndex + 7);\n                        if (next == -1) {\n                            next = paramString.length();\n                        }\n                        String param = paramString.substring(codeIndex + 7, next).trim();\n                        if (param.startsWith(\"-\")) {\n                            param = param.substring(1).trim();\n                        }\n                        paramDocs.add(param);\n                        if (next == paramString.length()) {\n                            break;\n                        } else {\n                            codeIndex = next + 1;    \n                        }\n                        codeIndex = paramString.indexOf(codeTag, codeIndex);\n                    }\n                    \n                }\n            }\n            mDocs = new MethodDocs(operInfo, paramDocs, responseInfo);\n            classDoc.addMethodDocs(methodName, mDocs);\n        }\n        \n        return mDocs;\n    }","id":98029,"modified_method":"private MethodDocs getOperationDocInternal(OperationResourceInfo ori) throws Exception {\n        ClassDocs classDoc = getClassDocInternal(ori.getClassResourceInfo());\n        if (classDoc == null) {\n            return null;\n        }\n        Method method = ori.getAnnotatedMethod() == null ? ori.getMethodToInvoke() \n            : ori.getAnnotatedMethod(); \n        String methodName = method.getName();\n        MethodDocs mDocs = classDoc.getMethodDocs(methodName);\n        if (mDocs == null) {\n            String operLink = getOperLink();\n            String operMarker = operLink + methodName + \"(\";\n            int operMarkerIndex = classDoc.getClassDoc().indexOf(operMarker);\n            if (operMarkerIndex == -1) { \n                return null;\n            }\n            String operDoc = classDoc.getClassDoc().substring(operMarkerIndex + operMarker.length());\n            String operInfoTag = getOperInfoTag();\n            String operInfo = getJavaDocText(operDoc, operInfoTag, operLink, 0);\n            String responseInfo = null;\n            List<String> paramDocs = new LinkedList<String>();\n            if (!StringUtils.isEmpty(operInfo)) {\n                int returnsIndex = operDoc.indexOf(\"Returns:\", operLink.length());\n                int nextOpIndex = operDoc.indexOf(operLink);\n                if (returnsIndex != -1 && (nextOpIndex > returnsIndex || nextOpIndex == -1)) {\n                    responseInfo = getJavaDocText(operDoc, getResponseMarker(), operLink, returnsIndex + 8);\n                }\n            \n                int paramIndex = operDoc.indexOf(\"Parameters:\");\n                if (paramIndex != -1 && (nextOpIndex == -1 || paramIndex < nextOpIndex)) {\n                    String paramString = returnsIndex == -1 ? operDoc.substring(paramIndex)\n                        : operDoc.substring(paramIndex, returnsIndex); \n                    \n                    String codeTag = getCodeTag(); \n                    \n                    int codeIndex = paramString.indexOf(codeTag);\n                    while (codeIndex != -1) {\n                        int next = paramString.indexOf(\"<\", codeIndex + 7);\n                        if (next == -1) {\n                            next = paramString.length();\n                        }\n                        String param = paramString.substring(codeIndex + 7, next).trim();\n                        if (param.startsWith(\"-\")) {\n                            param = param.substring(1).trim();\n                        }\n                        paramDocs.add(param);\n                        if (next == paramString.length()) {\n                            break;\n                        } else {\n                            codeIndex = next + 1;    \n                        }\n                        codeIndex = paramString.indexOf(codeTag, codeIndex);\n                    }\n                    \n                }\n            }\n            mDocs = new MethodDocs(operInfo, paramDocs, responseInfo);\n            classDoc.addMethodDocs(methodName, mDocs);\n        }\n        \n        return mDocs;\n    }","commit_id":"b54be09de3abb65bb0bf43dbe3ed8aa346a47251","url":"https://github.com/apache/cxf"},{"original_method":"private ClassDocs getClassDocInternal(ClassResourceInfo cri) throws Exception {\n        String resource = cri.getServiceClass().getName().replace(\".\", \"/\") + \".html\";\n        ClassDocs classDocs = docs.get(resource);\n        if (classDocs == null) {\n            InputStream resourceStream = javaDocLoader.getResourceAsStream(resource);\n            if (resourceStream != null) {\n                String doc = IOUtils.readStringFromStream(resourceStream);\n                \n                String classMarker = \"Class \" + cri.getServiceClass().getSimpleName();\n                int index = doc.indexOf(classMarker);\n                if (index != -1) {\n                    String classInfoTag = getClassInfoTag();\n                    String classInfo = getJavaDocText(doc, classInfoTag, \n                                                      \"Method Summary\", index + classMarker.length());\n                    classDocs = new ClassDocs(doc, classInfo);\n                    docs.putIfAbsent(resource, classDocs);\n                }\n            }\n        }\n        return classDocs;\n    }","id":98030,"modified_method":"private ClassDocs getClassDocInternal(ClassResourceInfo cri) throws Exception {\n        Class<?> annotatedClass = getPathAnnotatedClass(cri.getServiceClass());\n        String resource = annotatedClass.getName().replace(\".\", \"/\") + \".html\";\n        ClassDocs classDocs = docs.get(resource);\n        if (classDocs == null) {\n            InputStream resourceStream = javaDocLoader.getResourceAsStream(resource);\n            if (resourceStream != null) {\n                String doc = IOUtils.readStringFromStream(resourceStream);\n                \n                String classMarker = \"Class \" + annotatedClass.getSimpleName();\n                int index = doc.indexOf(classMarker);\n                if (index != -1) {\n                    String classInfoTag = getClassInfoTag();\n                    String classInfo = getJavaDocText(doc, classInfoTag, \n                                                      \"Method Summary\", index + classMarker.length());\n                    classDocs = new ClassDocs(doc, classInfo);\n                    docs.putIfAbsent(resource, classDocs);\n                }\n            }\n        }\n        return classDocs;\n    }","commit_id":"b54be09de3abb65bb0bf43dbe3ed8aa346a47251","url":"https://github.com/apache/cxf"},{"original_method":"private static void getAllTypesForResource(ClassResourceInfo resource, \n                                               ResourceTypes types,\n                                               boolean jaxbOnly,\n                                               MessageBodyWriter<?> jaxbWriter) {\n        for (OperationResourceInfo ori : resource.getMethodDispatcher().getOperationResourceInfos()) {\n            Method method = ori.getMethodToInvoke();\n            Class<?> realReturnType = method.getReturnType();\n            Class<?> cls = realReturnType;\n            if (cls == Response.class) {\n                cls = getActualJaxbType(cls, method, false);\n            }\n            Type type = method.getGenericReturnType();\n            if (jaxbOnly) {\n                checkJaxbType(resource.getServiceClass(), cls, realReturnType == Response.class ? cls : type, types, \n                    method.getAnnotations(), jaxbWriter);\n            } else {\n                types.getAllTypes().put(cls, type);\n            }\n            \n            for (Parameter pm : ori.getParameters()) {\n                if (pm.getType() == ParameterType.REQUEST_BODY) {\n                    Class<?> inType = method.getParameterTypes()[pm.getIndex()];\n                    Type paramType = method.getGenericParameterTypes()[pm.getIndex()];\n                    if (jaxbOnly) {\n                        checkJaxbType(resource.getServiceClass(), inType, paramType, types, \n                                      method.getParameterAnnotations()[pm.getIndex()], jaxbWriter);\n                    } else {\n                        types.getAllTypes().put(inType, paramType);\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        for (ClassResourceInfo sub : resource.getSubResources()) {\n            if (!isRecursiveSubResource(resource, sub)) {\n                getAllTypesForResource(sub, types, jaxbOnly, jaxbWriter);\n            }\n        }\n    }","id":98031,"modified_method":"private static void getAllTypesForResource(ClassResourceInfo resource, \n                                               ResourceTypes types,\n                                               boolean jaxbOnly,\n                                               MessageBodyWriter<?> jaxbWriter) {\n        for (OperationResourceInfo ori : resource.getMethodDispatcher().getOperationResourceInfos()) {\n            Method method = ori.getAnnotatedMethod() == null ? ori.getMethodToInvoke() : ori.getAnnotatedMethod();\n            Class<?> realReturnType = method.getReturnType();\n            Class<?> cls = realReturnType;\n            if (cls == Response.class) {\n                cls = getActualJaxbType(cls, method, false);\n            }\n            Type type = method.getGenericReturnType();\n            if (jaxbOnly) {\n                checkJaxbType(resource.getServiceClass(), cls, realReturnType == Response.class ? cls : type, types, \n                    method.getAnnotations(), jaxbWriter);\n            } else {\n                types.getAllTypes().put(cls, type);\n            }\n            \n            for (Parameter pm : ori.getParameters()) {\n                if (pm.getType() == ParameterType.REQUEST_BODY) {\n                    Class<?> inType = method.getParameterTypes()[pm.getIndex()];\n                    Type paramType = method.getGenericParameterTypes()[pm.getIndex()];\n                    if (jaxbOnly) {\n                        checkJaxbType(resource.getServiceClass(), inType, paramType, types, \n                                      method.getParameterAnnotations()[pm.getIndex()], jaxbWriter);\n                    } else {\n                        types.getAllTypes().put(inType, paramType);\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        for (ClassResourceInfo sub : resource.getSubResources()) {\n            if (!isRecursiveSubResource(resource, sub)) {\n                getAllTypesForResource(sub, types, jaxbOnly, jaxbWriter);\n            }\n        }\n    }","commit_id":"6e0c7ece8cce0835642599d05431240637e74e42","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public Set<Class<?>> getClasses() {\n        Set<Class<?>> classes = new HashSet<Class<?>>();\n        classes.add(org.apache.cxf.systest.jaxrs.BookStorePerRequest.class);\n        classes.add(org.apache.cxf.systest.jaxrs.BookStoreJaxrsJaxws.class);\n        return classes;\n    }","id":98032,"modified_method":"@Override\n    public Set<Class<?>> getClasses() {\n        Set<Class<?>> classes = new HashSet<Class<?>>();\n        classes.add(org.apache.cxf.systest.jaxrs.BookStorePerRequest.class);\n        classes.add(org.apache.cxf.systest.jaxrs.jaxws.BookStoreJaxrsJaxws.class);\n        return classes;\n    }","commit_id":"9a646a7fe066b2801fec3129651536abcff5b2cb","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private void serializeMessage(Message message, \n                                  Response response, \n                                  OperationResourceInfo ori,\n                                  boolean firstTry) {\n        int status = response.getStatus();\n        Object responseObj = response.getEntity();\n        if (status == 200 && !isResponseNull(responseObj) && firstTry \n            && ori != null && JAXRSUtils.headMethodPossible(ori.getHttpMethod(), \n                (String)message.getExchange().getInMessage().get(Message.HTTP_REQUEST_METHOD))) {\n            LOG.info(new org.apache.cxf.common.i18n.Message(\"HEAD_WITHOUT_ENTITY\", BUNDLE).toString());\n            responseObj = null;\n        }\n        if (status == -1) {\n            status = isResponseNull(responseObj) ? 204 : 200;\n        }\n        \n        message.put(Message.RESPONSE_CODE, status);\n        Map<String, List<String>> theHeaders = \n            (Map<String, List<String>>)message.get(Message.PROTOCOL_HEADERS);\n        if (firstTry && theHeaders != null) {\n            // some headers might've been setup by custom cxf interceptors\n            theHeaders.putAll((Map)response.getMetadata());\n        } else {\n            message.put(Message.PROTOCOL_HEADERS, response.getMetadata());\n        }\n        Map<String, List<Object>> rh = \n            (Map<String, List<Object>>)message.get(Message.PROTOCOL_HEADERS);\n        MultivaluedMap<String, Object> responseHeaders;\n        if (!(rh instanceof MultivaluedMap)) {\n            responseHeaders = new MetadataMap<String, Object>(rh);\n        } else {\n            responseHeaders = (MultivaluedMap)rh;\n        }\n        setResponseDate((MultivaluedMap)responseHeaders, firstTry);\n        if (isResponseNull(responseObj)) {\n            return;\n        }\n        \n        Object ignoreWritersProp = message.getExchange().get(JAXRSUtils.IGNORE_MESSAGE_WRITERS);\n        boolean ignoreWriters = \n            ignoreWritersProp == null ? false : Boolean.valueOf(ignoreWritersProp.toString());\n        if (ignoreWriters) {\n            writeResponseToStream(message.getContent(OutputStream.class), responseObj);\n            return;\n        }\n        \n        List<MediaType> availableContentTypes = computeAvailableContentTypes(message, response);  \n        \n        Method invoked = null;\n        if (firstTry) {\n            invoked = ori == null ? null : ori.getMethodToInvoke();\n        }\n        Class<?> targetType = getRawResponseClass(responseObj);\n        Type genericType = \n            getGenericResponseType(ori == null ? null : ori.getAnnotatedMethod(), responseObj);\n        if (genericType instanceof TypeVariable) {\n            genericType = InjectionUtils.getSuperType(ori.getClassResourceInfo().getServiceClass(), \n                                                       (TypeVariable)genericType);\n        }\n        \n        MessageBodyWriter writer = null;\n        MediaType responseType = null;\n        for (MediaType type : availableContentTypes) { \n            writer = ProviderFactory.getInstance(message)\n                .createMessageBodyWriter(targetType, genericType, \n                      invoked != null ? invoked.getAnnotations() : new Annotation[]{}, \n                      type,\n                      message);\n            \n            if (writer != null) {\n                responseType = type;\n                break;\n            }\n        }\n    \n        OutputStream outOriginal = message.getContent(OutputStream.class);\n        if (writer == null) {\n            message.put(Message.CONTENT_TYPE, \"text/plain\");\n            message.put(Message.RESPONSE_CODE, 500);\n            writeResponseErrorMessage(outOriginal, \"NO_MSG_WRITER\", targetType.getSimpleName());\n            return;\n        }\n        boolean enabled = checkBufferingMode(message, writer, firstTry);\n        Object entity = getEntity(responseObj);\n        try {\n            responseType = checkFinalContentType(responseType);\n            LOG.fine(\"Response content type is: \" + responseType.toString());\n            message.put(Message.CONTENT_TYPE, responseType.toString());\n            \n            Annotation[] annotations = invoked != null ? invoked.getAnnotations() : new Annotation[]{};\n            \n            long size = writer.getSize(entity, targetType, genericType, annotations, responseType);\n            if (size > 0) {\n                LOG.fine(\"Setting ContentLength to \" + size + \" as requested by \" \n                         + writer.getClass().getName());\n                responseHeaders.putSingle(HttpHeaders.CONTENT_LENGTH, Long.toString(size));\n            }\n            \n            LOG.fine(\"Response EntityProvider is: \" + writer.getClass().getName());\n            try {\n                writer.writeTo(entity, targetType, genericType, \n                               annotations, \n                               responseType, \n                               responseHeaders, \n                               message.getContent(OutputStream.class));\n                \n                if (isResponseRedirected(message)) {\n                    return;\n                }\n                \n                Object newContentType = responseHeaders.getFirst(HttpHeaders.CONTENT_TYPE);\n                if (newContentType != null) {\n                    message.put(Message.CONTENT_TYPE, newContentType.toString());\n                }\n                checkCachedStream(message, outOriginal, enabled);\n            } finally {\n                if (enabled) {\n                    message.setContent(OutputStream.class, outOriginal);\n                    message.put(XMLStreamWriter.class.getName(), null);\n                }\n            }\n            \n        } catch (IOException ex) {\n            handleWriteException(message, response, ori, ex, entity, firstTry);\n        } catch (Throwable ex) {\n            handleWriteException(message, response, ori, ex, entity, firstTry);\n        }\n    }","id":98033,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private void serializeMessage(Message message, \n                                  Response response, \n                                  OperationResourceInfo ori,\n                                  boolean firstTry) {\n        int status = response.getStatus();\n        Object responseObj = response.getEntity();\n        if (status == 200 && !isResponseNull(responseObj) && firstTry \n            && ori != null && JAXRSUtils.headMethodPossible(ori.getHttpMethod(), \n                (String)message.getExchange().getInMessage().get(Message.HTTP_REQUEST_METHOD))) {\n            LOG.info(new org.apache.cxf.common.i18n.Message(\"HEAD_WITHOUT_ENTITY\", BUNDLE).toString());\n            responseObj = null;\n        }\n        if (status == -1) {\n            status = isResponseNull(responseObj) ? 204 : 200;\n        }\n        \n        message.put(Message.RESPONSE_CODE, status);\n        Map<String, List<String>> theHeaders = \n            (Map<String, List<String>>)message.get(Message.PROTOCOL_HEADERS);\n        if (firstTry && theHeaders != null) {\n            // some headers might've been setup by custom cxf interceptors\n            theHeaders.putAll((Map)response.getMetadata());\n        } else {\n            message.put(Message.PROTOCOL_HEADERS, response.getMetadata());\n        }\n        Map<String, List<Object>> rh = \n            (Map<String, List<Object>>)message.get(Message.PROTOCOL_HEADERS);\n        MultivaluedMap<String, Object> responseHeaders;\n        if (!(rh instanceof MultivaluedMap)) {\n            responseHeaders = new MetadataMap<String, Object>(rh);\n        } else {\n            responseHeaders = (MultivaluedMap)rh;\n        }\n        setResponseDate((MultivaluedMap)responseHeaders, firstTry);\n        if (isResponseNull(responseObj)) {\n            return;\n        }\n        \n        Object ignoreWritersProp = message.getExchange().get(JAXRSUtils.IGNORE_MESSAGE_WRITERS);\n        boolean ignoreWriters = \n            ignoreWritersProp == null ? false : Boolean.valueOf(ignoreWritersProp.toString());\n        if (ignoreWriters) {\n            writeResponseToStream(message.getContent(OutputStream.class), responseObj);\n            return;\n        }\n        \n        List<MediaType> availableContentTypes = computeAvailableContentTypes(message, response);  \n        \n        Method invoked = null;\n        if (firstTry) {\n            invoked = ori == null ? null : ori.getAnnotatedMethod() == null\n                ? ori.getMethodToInvoke() : ori.getAnnotatedMethod();\n        }\n        Class<?> targetType = getRawResponseClass(responseObj);\n        Type genericType = \n            getGenericResponseType(ori == null ? null : ori.getAnnotatedMethod(), responseObj);\n        if (genericType instanceof TypeVariable) {\n            genericType = InjectionUtils.getSuperType(ori.getClassResourceInfo().getServiceClass(), \n                                                       (TypeVariable)genericType);\n        }\n        \n        MessageBodyWriter writer = null;\n        MediaType responseType = null;\n        for (MediaType type : availableContentTypes) { \n            writer = ProviderFactory.getInstance(message)\n                .createMessageBodyWriter(targetType, genericType, \n                      invoked != null ? invoked.getAnnotations() : new Annotation[]{}, \n                      type,\n                      message);\n            \n            if (writer != null) {\n                responseType = type;\n                break;\n            }\n        }\n    \n        OutputStream outOriginal = message.getContent(OutputStream.class);\n        if (writer == null) {\n            message.put(Message.CONTENT_TYPE, \"text/plain\");\n            message.put(Message.RESPONSE_CODE, 500);\n            writeResponseErrorMessage(outOriginal, \"NO_MSG_WRITER\", targetType.getSimpleName());\n            return;\n        }\n        boolean enabled = checkBufferingMode(message, writer, firstTry);\n        Object entity = getEntity(responseObj);\n        try {\n            responseType = checkFinalContentType(responseType);\n            LOG.fine(\"Response content type is: \" + responseType.toString());\n            message.put(Message.CONTENT_TYPE, responseType.toString());\n            \n            Annotation[] annotations = invoked != null ? invoked.getAnnotations() : new Annotation[]{};\n            \n            long size = writer.getSize(entity, targetType, genericType, annotations, responseType);\n            if (size > 0) {\n                LOG.fine(\"Setting ContentLength to \" + size + \" as requested by \" \n                         + writer.getClass().getName());\n                responseHeaders.putSingle(HttpHeaders.CONTENT_LENGTH, Long.toString(size));\n            }\n            \n            LOG.fine(\"Response EntityProvider is: \" + writer.getClass().getName());\n            try {\n                writer.writeTo(entity, targetType, genericType, \n                               annotations, \n                               responseType, \n                               responseHeaders, \n                               message.getContent(OutputStream.class));\n                \n                if (isResponseRedirected(message)) {\n                    return;\n                }\n                \n                Object newContentType = responseHeaders.getFirst(HttpHeaders.CONTENT_TYPE);\n                if (newContentType != null) {\n                    message.put(Message.CONTENT_TYPE, newContentType.toString());\n                }\n                checkCachedStream(message, outOriginal, enabled);\n            } finally {\n                if (enabled) {\n                    message.setContent(OutputStream.class, outOriginal);\n                    message.put(XMLStreamWriter.class.getName(), null);\n                }\n            }\n            \n        } catch (IOException ex) {\n            handleWriteException(message, response, ori, ex, entity, firstTry);\n        } catch (Throwable ex) {\n            handleWriteException(message, response, ori, ex, entity, firstTry);\n        }\n    }","commit_id":"9a646a7fe066b2801fec3129651536abcff5b2cb","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n        public void renderBody()\n        {\n            Scm scm = model.getScm();\n            if ( scm == null )\n            {\n                startSection( getTitle() );\n\n                paragraph( getI18nString( \"noscm\" ) );\n\n                endSection();\n\n                return;\n            }\n\n            if ( StringUtils.isEmpty( anonymousConnection ) && StringUtils.isEmpty( devConnection )\n                && StringUtils.isEmpty( scm.getUrl() ) )\n            {\n                startSection( getTitle() );\n\n                paragraph( getI18nString( \"noscm\" ) );\n\n                endSection();\n\n                return;\n            }\n\n            ScmRepository anonymousRepository = getScmRepository( anonymousConnection );\n            ScmRepository devRepository = getScmRepository( devConnection );\n\n            // Overview section\n            renderOverviewSection( anonymousRepository );\n\n            // Web access section\n            renderWebAccessSection( webAccessUrl );\n\n            // Anonymous access section if needed\n            renderAnonymousAccessSection( anonymousRepository );\n\n            // Developer access section\n            renderDeveloperAccessSection( devRepository );\n\n            // Access from behind a firewall section if needed\n            renderAccessBehindFirewallSection( devRepository );\n\n            // Access through a proxy section if needed\n            renderAccessThroughProxySection( anonymousRepository, devRepository );\n        }","id":98034,"modified_method":"@Override\n        public void renderBody()\n        {\n            Scm scm = model.getScm();\n            if ( scm == null )\n            {\n                startSection( getTitle() );\n\n                paragraph( getI18nString( \"noscm\" ) );\n\n                endSection();\n\n                return;\n            }\n\n            if ( StringUtils.isEmpty( anonymousConnection ) && StringUtils.isEmpty( devConnection )\n                && StringUtils.isEmpty( scm.getUrl() ) )\n            {\n                startSection( getTitle() );\n\n                paragraph( getI18nString( \"noscm\" ) );\n\n                endSection();\n\n                return;\n            }\n\n            ScmRepository anonymousRepository = getScmRepository( anonymousConnection );\n            ScmRepository devRepository = getScmRepository( devConnection );\n\n            // Overview section\n            renderOverviewSection( anonymousRepository, devRepository );\n\n            // Web access section\n            renderWebAccessSection( webAccessUrl );\n\n            // Anonymous access section if needed\n            renderAnonymousAccessSection( anonymousRepository );\n\n            // Developer access section\n            renderDeveloperAccessSection( devRepository );\n\n            // Access from behind a firewall section if needed\n            renderAccessBehindFirewallSection( devRepository );\n\n            // Access through a proxy section if needed\n            renderAccessThroughProxySection( anonymousRepository, devRepository );\n        }","commit_id":"faba0590031d3db7946b124e1d8534c750c70dce","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n         * Render the overview section\n         *\n         * @param anonymousRepository the anonymous repository\n         */\n        private void renderOverviewSection( ScmRepository anonymousRepository )\n        {\n            startSection( getI18nString( \"overview.title\" ) );\n\n            if ( isScmSystem( anonymousRepository, \"clearcase\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"clearcase.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"cvs\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"cvs.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"git\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"git.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"hg\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"hg.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"perforce\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"perforce.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"starteam\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"starteam.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"svn\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"svn.intro\" ) );\n                sink.paragraph_();\n            }\n            else\n            {\n                paragraph( getI18nString( \"general.intro\" ) );\n            }\n\n            endSection();\n        }","id":98035,"modified_method":"/**\n         * Render the overview section\n         *\n         * @param anonymousRepository the anonymous repository\n         * @param devRepository the developer repository\n         */\n        private void renderOverviewSection( ScmRepository anonymousRepository, ScmRepository devRepository )\n        {\n            startSection( getI18nString( \"overview.title\" ) );\n\n            if ( isScmSystem( anonymousRepository, \"clearcase\" ) || isScmSystem( devRepository, \"clearcase\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"clearcase.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"cvs\" ) || isScmSystem( devRepository, \"cvs\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"cvs.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"git\" ) || isScmSystem( devRepository, \"git\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"git.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"hg\" ) || isScmSystem( devRepository, \"hg\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"hg.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"perforce\" ) || isScmSystem( devRepository, \"perforce\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"perforce.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"starteam\" ) || isScmSystem( devRepository, \"starteam\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"starteam.intro\" ) );\n                sink.paragraph_();\n            }\n            else if ( isScmSystem( anonymousRepository, \"svn\" ) || isScmSystem( devRepository, \"svn\" ) )\n            {\n                sink.paragraph();\n                linkPatternedText( getI18nString( \"svn.intro\" ) );\n                sink.paragraph_();\n            }\n            else\n            {\n                paragraph( getI18nString( \"general.intro\" ) );\n            }\n\n            endSection();\n        }","commit_id":"faba0590031d3db7946b124e1d8534c750c70dce","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void sendDownstreamNewEvent( ChannelHandlerContext ctx, ChannelEvent e, BaseMessage reply ) {\n    MappingHttpRequest request = null;\n    Context reqCtx = null;\n    try {\n      if ( reply != null ) {\n        reqCtx = Contexts.lookup( reply.getCorrelationId( ) );\n        request = reqCtx.getHttpRequest( );\n      }\n    } catch ( NoSuchContextException e1 ) {\n      LOG.debug( e1, e1 );\n    }\n    if ( request != null ) {\n      if ( reply == null ) {\n        LOG.warn( \"Received a null response for request: \" + request.getMessageString( ) );\n        reply = new EucalyptusErrorMessageType( this.getClass( ).getSimpleName( ), ( BaseMessage ) request.getMessage( ), \"Received a NULL reply\" );\n      }\n      if( LogLevels.DEBUG ) {\n        Long currTime = System.currentTimeMillis( );\n        EventRecord.here( reply.getClass( ), EventClass.MESSAGE, EventType.MSG_SERVICED, \n                          \"rtt-ms\", Long.toString( currTime - this.openTime.get( ctx.getChannel( ) ) ),\n                          \"request-ms\", Long.toString( currTime - this.startTime.get( ctx.getChannel( ) ) ) ).debug( );\n      }\n      final MappingHttpResponse response = new MappingHttpResponse( request.getProtocolVersion( ) );\n      final DownstreamMessageEvent newEvent = new DownstreamMessageEvent( ctx.getChannel( ), e.getFuture( ), response, null );\n      response.setMessage( reply );\n      ctx.sendDownstream( newEvent );\n//      Contexts.clear( reqCtx );\n    }\n  }","id":98036,"modified_method":"private MessageEvent makeDownstreamNewEvent( ChannelHandlerContext ctx, ChannelEvent e, BaseMessage reply ) {\n    MappingHttpRequest request = null;\n    Context reqCtx = null;\n    try {\n      if ( reply != null ) {\n        reqCtx = Contexts.lookup( reply.getCorrelationId( ) );\n        request = reqCtx.getHttpRequest( );\n      }\n    } catch ( NoSuchContextException e1 ) {\n      LOG.debug( e1, e1 );\n    }\n    if ( request != null ) {\n      if ( reply == null ) {\n        LOG.warn( \"Received a null response for request: \" + request.getMessageString( ) );\n        reply = new EucalyptusErrorMessageType( this.getClass( ).getSimpleName( ), ( BaseMessage ) request.getMessage( ), \"Received a NULL reply\" );\n      }\n      if( LogLevels.DEBUG ) {\n        Long currTime = System.currentTimeMillis( );\n        EventRecord.here( reply.getClass( ), EventClass.MESSAGE, EventType.MSG_SERVICED, \n                          \"rtt-ms\", Long.toString( currTime - this.openTime.get( ctx.getChannel( ) ) ),\n                          \"request-ms\", Long.toString( currTime - this.startTime.get( ctx.getChannel( ) ) ) ).debug( );\n      }\n      final MappingHttpResponse response = new MappingHttpResponse( request.getProtocolVersion( ) );\n      final DownstreamMessageEvent newEvent = new DownstreamMessageEvent( ctx.getChannel( ), e.getFuture( ), response, null );\n      response.setMessage( reply );\n      return newEvent;\n//      Contexts.clear( reqCtx );\n    } else {\n      final MappingHttpResponse response = new MappingHttpResponse( HttpVersion.HTTP_1_1 ) {{\n        setMessage( new EucalyptusErrorMessageType( this.getClass( ).getSimpleName( ), \"Received a NULL reply\" ) );\n      }};\n      final DownstreamMessageEvent newEvent = new DownstreamMessageEvent( ctx.getChannel( ), e.getFuture( ), response, null );\n      return newEvent;\n    }\n  }","commit_id":"f48d676e47c019683a7b9ea65c454e1be5eecbd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void handleUpstream( final ChannelHandlerContext ctx, final ChannelEvent e ) throws Exception {\n    final MappingHttpMessage request = MappingHttpMessage.extractMessage( e );\n    final BaseMessage msg = BaseMessage.extractMessage( e );\n    if ( LogLevels.EXTREME ) LOG.trace( this.getClass( ).getSimpleName( ) + \"[incoming]:\" + (msg!=null?msg.getClass().getSimpleName( ):\"\")+ \" \"  + e );\n\n    if ( e instanceof ExceptionEvent ) {\n      this.exceptionCaught( ctx, ( ExceptionEvent ) e );\n    } else if ( e instanceof IdleStateEvent ) {\n      LOG.warn( \"Closing idle connection: \" + e );\n      e.getFuture( ).addListener( ChannelFutureListener.CLOSE );\n      ctx.sendUpstream( e );\n    } else if ( request != null && msg != null ) {      \n      this.startTime.set( ctx.getChannel( ), System.currentTimeMillis( ) );\n      EventRecord.here( ServiceContextHandler.class, EventType.MSG_RECEIVED, msg.getClass( ).getSimpleName( ) ).trace( );\n      ServiceContext.dispatch( RequestQueue.ENDPOINT, msg );\n    } else if( e instanceof ChannelStateEvent ) {\n      ChannelStateEvent evt = (ChannelStateEvent) e;\n      if (evt.getState().equals(ChannelState.CONNECTED) && Boolean.TRUE.equals(evt.getValue())) {\n        this.openTime.set( ctx.getChannel( ), System.currentTimeMillis( ) );\n      } else if (evt.getState().equals(ChannelState.CONNECTED) && Boolean.FALSE.equals(evt.getValue())) {\n        try {\n          Contexts.clear( Contexts.lookup( ctx.getChannel( ) ) );\n        } catch ( Throwable e1 ) {\n          LOG.warn( \"Failed to remove the channel context on connection close.\", e1 );\n        }\n      }\n      ctx.sendUpstream(e);\n    } else if (e instanceof ExceptionEvent) {\n      exceptionCaught(ctx, (ExceptionEvent) e);\n      ctx.sendUpstream( e );\n    } else {\n      ctx.sendUpstream( e );\n    }\n  }","id":98037,"modified_method":"@Override\n  public void handleUpstream( final ChannelHandlerContext ctx, final ChannelEvent e ) throws Exception {\n    final MappingHttpMessage request = MappingHttpMessage.extractMessage( e );\n    final BaseMessage msg = BaseMessage.extractMessage( e );\n    if ( LogLevels.EXTREME ) LOG.trace( this.getClass( ).getSimpleName( ) + \"[incoming]:\" + (msg!=null?msg.getClass().getSimpleName( ):\"\")+ \" \"  + e );\n\n    if( e instanceof ChannelStateEvent ) {\n      this.channelOpened( ctx, (ChannelStateEvent) e );\n      ctx.sendUpstream(e);\n    } else if ( e instanceof IdleStateEvent ) {\n      LOG.warn( \"Closing idle connection: \" + e );\n      e.getFuture( ).addListener( ChannelFutureListener.CLOSE );\n      ctx.sendUpstream( e );\n    } else if ( request != null && msg != null ) {      \n      this.messageReceived( ctx, msg );\n      ctx.sendUpstream( e );\n    } else if (e instanceof ExceptionEvent) {\n      this.exceptionCaught(ctx, (ExceptionEvent) e);\n      ctx.sendUpstream( e );\n    } else {\n      ctx.sendUpstream( e );\n    }\n  }","commit_id":"f48d676e47c019683a7b9ea65c454e1be5eecbd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n  @Override\n  public void handleDownstream( final ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n    if ( LogLevels.EXTREME ) LOG.trace( this.getClass( ).getSimpleName( ) + \"[outgoing]: \" + e.getClass( ) );\n    BaseMessage reply = BaseMessage.extractMessage( e );\n    if ( reply instanceof HasSideEffect && reply.get_return( ) ) {\n      ServiceContextManager.restart( );\n      this.sendDownstreamNewEvent( ctx, e, reply );\n    } else if( reply instanceof BaseMessage ) {\n      this.sendDownstreamNewEvent( ctx, e, reply );\n    } else if (e instanceof ExceptionEvent) {\n      exceptionCaught(ctx, (ExceptionEvent) e);\n      ctx.sendDownstream( e );\n    } else {\n      ctx.sendDownstream( e );\n    }\n  }","id":98038,"modified_method":"@SuppressWarnings( \"unchecked\" )\n  @Override\n  public void handleDownstream( final ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n    if ( LogLevels.EXTREME ) LOG.trace( this.getClass( ).getSimpleName( ) + \"[outgoing]: \" + e.getClass( ) );\n    BaseMessage reply = BaseMessage.extractMessage( e );\n    if ( reply instanceof HasSideEffect && reply.get_return( ) ) {\n      ServiceContextManager.restart( );\n      MessageEvent newEvent = makeDownstreamNewEvent( ctx, e, reply );\n      ctx.sendDownstream( newEvent );\n    } else if( reply instanceof BaseMessage ) {\n      MessageEvent newEvent = makeDownstreamNewEvent( ctx, e, reply );\n      ctx.sendDownstream( newEvent );\n    } else if (e instanceof ExceptionEvent) {\n      exceptionCaught(ctx, (ExceptionEvent) e);\n      ctx.sendDownstream( e );\n    } else {\n      ctx.sendDownstream( e );\n    }\n  }","commit_id":"f48d676e47c019683a7b9ea65c454e1be5eecbd4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public NioServer( int port ) {\n    super( );\n    this.port = port;\n    this.socketFactory = new NioServerSocketChannelFactory( Executors.newCachedThreadPool( ), Executors.newCachedThreadPool( ) );\n    this.bootstrap = new ServerBootstrap( this.socketFactory );\n    LOG.info( \"Server bootstrap options:\" );\n    this.bootstrap.setOption( \"child.tcpNoDelay\", true );\n    this.bootstrap.setOption( \"child.reuseAddress\", false );\n    this.bootstrap.setOption( \"child.keepAlive\", true );\n    for ( String key : this.bootstrap.getOptions( ).keySet( ) ) {\n      Object value = this.bootstrap.getOption( key );\n      LOG.info( String.format( \"== %20s %s\", key, value ) );\n    }\n    this.bootstrap.setPipelineFactory( new NioServerPipelineFactory( ) );\n    PipelineRegistry.getInstance( ).register( new EucalyptusSoapPipeline( ) );\n    PipelineRegistry.getInstance( ).register( new ElasticFoxPipeline( ) );\n    PipelineRegistry.getInstance( ).register( new EucalyptusQueryPipeline( ) );\n    PipelineRegistry.getInstance( ).register( new WalrusRESTPipeline( ) );\n  }","id":98039,"modified_method":"public NioServer( int port ) {\n    super( );\n    this.port = port;\n    this.socketFactory = new NioServerSocketChannelFactory( Executors.newCachedThreadPool( ), Executors.newCachedThreadPool( ) );\n    this.bootstrap = new ServerBootstrap( this.socketFactory );\n    this.bootstrap.setPipelineFactory( new NioServerPipelineFactory( ) );\n    PipelineRegistry.getInstance( ).register( new EucalyptusSoapPipeline( ) );\n    PipelineRegistry.getInstance( ).register( new ElasticFoxPipeline( ) );\n    PipelineRegistry.getInstance( ).register( new EucalyptusQueryPipeline( ) );\n    PipelineRegistry.getInstance( ).register( new WalrusRESTPipeline( ) );\n  }","commit_id":"1439eb5aaa79432a1a67e0950391ca235901f63e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void messageReceived( final ChannelHandlerContext ctx, final MessageEvent e ) throws Exception {\n    if ( this.first ) {\n      lookupPipeline( ctx, e );\n      ctx.sendUpstream( e );\n    } else {\n      LOG.warn( \"Hard close the socket on an attempt to do a second request. no u.\" );\n      ctx.getChannel( ).close( );\n    }\n  }","id":98040,"modified_method":"@Override\n  public void messageReceived( final ChannelHandlerContext ctx, final MessageEvent e ) throws Exception {\n    synchronized ( this ) {\n      if ( this.first ) {\n        try {\n          final HttpRequest request = ( HttpRequest ) e.getMessage( );\n          final ChannelPipeline pipeline = ctx.getPipeline( );\n          FilteredPipeline filteredPipeline = PipelineRegistry.getInstance( ).find( request );\n          filteredPipeline.unroll( pipeline );\n          this.first = false;\n        } catch ( DuplicatePipelineException e1 ) {\n          LOG.error( \"This is a BUG: \" + e1, e1 );\n          throw e1;\n        } catch ( NoAcceptingPipelineException e2 ) {\n          throw e2;\n        }\n      }\n    }\n    ctx.sendUpstream( e );\n  }","commit_id":"1439eb5aaa79432a1a67e0950391ca235901f63e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void handleUpstream( ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n\t\tLOG.debug( this.getClass( ).getSimpleName( ) + \"[incoming]: \" + e );\n\t\tif ( e instanceof MessageEvent ) {\n\t\t\tfinal MessageEvent event = ( MessageEvent ) e;\n\t\t\tif(event.getMessage() instanceof MappingHttpMessage) {\n\t\t\t\tMappingHttpMessage message = ( MappingHttpMessage ) event.getMessage( );\n\t\t\t\tEucalyptusMessage msg = (EucalyptusMessage) message.getMessage( );\n\t\t\t\tLOG.info( EventRecord.create( this.getClass().getSimpleName(), msg.getUserId(), msg.getCorrelationId(), EventType.MSG_RECEIVED, msg.getClass().getSimpleName() ) );\n\t\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\t\tif(msg instanceof PutObjectType) {\n\t\t\t\t\tDispatcher dispatch = new Dispatcher(ctx, msg, message, startTime);\n\t\t\t\t\tdispatch.start();\n\t\t\t\t} else {\n\t\t\t\t\tMessaging.dispatch( \"vm://RequestQueue\", msg );\n\t\t\t\t\tEucalyptusMessage reply = null;\n\n\t\t\t\t\treply = ReplyQueue.getReply( msg.getCorrelationId() );\n\t\t\t\t\tLOG.info( EventRecord.create( this.getClass().getSimpleName(), msg.getUserId(), msg.getCorrelationId(), EventType.MSG_SERVICED, ( System.currentTimeMillis() - startTime ) ) );\n\t\t\t\t\tif ( reply == null ) {\n\t\t\t\t\t\treply = new EucalyptusErrorMessageType( this.getClass().getSimpleName(), msg, \"Received a NULL reply\" );\n\t\t\t\t\t}\n\t\t\t\t\tMappingHttpResponse response = new MappingHttpResponse( message.getProtocolVersion( ) ); \n\t\t\t\t\tresponse.setMessage( reply );\n\t\t\t\t\tif(!(reply instanceof WalrusDataGetResponseType)) {\n\t\t\t\t\t\tChannelFuture writeFuture = Channels.write( ctx.getChannel( ), response );\t\t\t\t\t\t\n\t\t\t\t\t\twriteFuture.addListener( ChannelFutureListener.CLOSE );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":98041,"modified_method":"@Override\n\tpublic void handleUpstream( ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n\t\tLOG.debug( this.getClass( ).getSimpleName( ) + \"[incoming]: \" + e );\n\t\tif ( e instanceof MessageEvent ) {\n\t\t\tfinal MessageEvent event = ( MessageEvent ) e;\n\t\t\tif(event.getMessage() instanceof MappingHttpMessage) {\n\t\t\t\tMappingHttpMessage message = ( MappingHttpMessage ) event.getMessage( );\n\t\t\t\tEucalyptusMessage msg = (EucalyptusMessage) message.getMessage( );\n\t\t\t\tLOG.info( EventRecord.create( this.getClass().getSimpleName(), msg.getUserId(), msg.getCorrelationId(), EventType.MSG_RECEIVED, msg.getClass().getSimpleName() ) );\n\t\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\t\tif(msg instanceof PutObjectType) {\n\t\t\t\t\tDispatcher dispatch = new Dispatcher(ctx, msg, message, startTime);\n\t\t\t\t\tdispatch.start();\n\t\t\t\t} else {\n\t\t\t\t\tMessaging.dispatch( \"vm://RequestQueue\", msg );\n\t\t\t\t\tEucalyptusMessage reply = null;\n\n\t\t\t\t\treply = ReplyQueue.getReply( msg.getCorrelationId() );\n\t\t\t\t\tLOG.info( EventRecord.create( this.getClass().getSimpleName(), msg.getUserId(), msg.getCorrelationId(), EventType.MSG_SERVICED, ( System.currentTimeMillis() - startTime ) ) );\n\t\t\t\t\tif ( reply == null ) {\n\t\t\t\t\t\treply = new EucalyptusErrorMessageType( this.getClass().getSimpleName(), msg, \"Received a NULL reply\" );\n\t\t\t\t\t}\n\t\t\t\t\tMappingHttpResponse response = new MappingHttpResponse( message.getProtocolVersion( ) ); \n\t\t\t\t\tresponse.setMessage( reply );\n\t\t\t\t\tif(!(reply instanceof WalrusDataGetResponseType)) {\n\t\t\t\t\t\tChannels.write(ctx.getChannel(), response);\n\t\t\t\t\t\t//ChannelFuture writeFuture = Channels.write( ctx.getChannel( ), response );\t\t\t\t\t\t\n\t\t\t\t\t\t//writeFuture.addListener( ChannelFutureListener.CLOSE );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"1439eb5aaa79432a1a67e0950391ca235901f63e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListBucketResponseType listBucket(ListBucketType request) throws EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tString prefix = request.getPrefix();\n\t\tif(prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString marker = request.getMarker();\n\t\tif(marker == null)\n\t\t\tmarker = \"\";\n\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif(maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = new EntityWrapper<BucketInfo>();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif(bucket.canRead(userId)) {\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif(maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setMarker(marker);\n\t\t\t\tif(delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>();\n\t\t\t\t\tfor(ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tif(objectKey.compareTo(marker) < 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\t\tif(!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif(parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor(PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif(prefixEntry.getPrefix().equals(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(prefixString));\n\t\t\t\t\t\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tString displayName = objectInfo.getOwnerId();\n\n\t\t\t\t\t\tEntityWrapper<UserInfo> db2 = new EntityWrapper<UserInfo>();\n\t\t\t\t\t\tUserInfo userInfo = new UserInfo(displayName);\n\t\t\t\t\t\tList<UserInfo> ownerInfos = db2.query(userInfo);\n\t\t\t\t\t\tdb2.commit();\n\t\t\t\t\t\tif(ownerInfos.size() > 0) {\n\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(ownerInfos.get(0).getQueryId(), displayName));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>();\n\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t}\n\t\t\t\t\treply.setContents(contents);\n\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(bucketName);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":98042,"modified_method":"public ListBucketResponseType listBucket(ListBucketType request) throws EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tString prefix = request.getPrefix();\n\t\tif(prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString marker = request.getMarker();\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif(maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = new EntityWrapper<BucketInfo>();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif(bucket.canRead(userId)) {\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif(maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setMarker(marker);\n\t\t\t\tif(delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tif(marker != null || objectInfos.size() < maxKeys)\n\t\t\t\t\t\tCollections.sort(objectInfos);\n\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>();\n\t\t\t\t\tfor(ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tif(objectKey.compareTo(marker) <= 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\t\tif(!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif(parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor(PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif(prefixEntry.getPrefix().equals(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(prefixString));\n\t\t\t\t\t\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tString displayName = objectInfo.getOwnerId();\n\n\t\t\t\t\t\tEntityWrapper<UserInfo> db2 = new EntityWrapper<UserInfo>();\n\t\t\t\t\t\tUserInfo userInfo = new UserInfo(displayName);\n\t\t\t\t\t\tList<UserInfo> ownerInfos = db2.query(userInfo);\n\t\t\t\t\t\tdb2.commit();\n\t\t\t\t\t\tif(ownerInfos.size() > 0) {\n\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(ownerInfos.get(0).getQueryId(), displayName));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>();\n\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t}\n\t\t\t\t\treply.setContents(contents);\n\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(bucketName);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"1439eb5aaa79432a1a67e0950391ca235901f63e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(\"Starting to run...\");\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(\"Unexpected error in '\"+debug+\"' : \"+e.toString());\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","id":98043,"modified_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(Messages.getString(\"FieldSplitter.Log.StartingToRun\")); //$NON-NLS-1$\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"FieldSplitter.Log.UnexpectedError\")+debug+\"' : \"+e.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(FieldSplitterMeta)smi;\n\t\tdata=(FieldSplitterData)sdi;\n\n\t\tRow r=getRow();   // get row from rowset, wait for our turn, indicate busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean noerr = splitField(r);\n\t\tif (!noerr)\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\n\t\tputRow(r);\n\n\t\tif ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(\"linenr \"+linesRead);\n\t\t\t\n\t\treturn true;\n\t}","id":98044,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(FieldSplitterMeta)smi;\n\t\tdata=(FieldSplitterData)sdi;\n\n\t\tRow r=getRow();   // get row from rowset, wait for our turn, indicate busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean noerr = splitField(r);\n\t\tif (!noerr)\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\n\t\tputRow(r);\n\n\t\tif ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(Messages.getString(\"FieldSplitter.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean splitField(Row r)\n\t{\n\t\tif (first)\n\t\t{\n\t\t\tdata.fieldnr=r.searchValueIndex(meta.getSplitField());\n\t\t\tif (data.fieldnr<0)\n\t\t\t{\n\t\t\t\tlogError(\"Couldn't find field to split [\"+meta.getSplitField()+\"] in input stream!\");\n\t\t\t\tsetErrors(1);\n\t\t\t\tstopAll();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tValue v=r.getValue(data.fieldnr);\n\t\tr.removeValue(data.fieldnr); \n\t\tboolean insert = data.fieldnr<r.size();\n\t\t\n\t\tif (!v.isString())\n\t\t{\n\t\t\tlogError(\"Can only split string fields.  [\"+meta.getSplitField()+\"] is not a string!\");\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Named values info.id[0] not filled in!\n\t\tboolean use_ids = meta.getFieldID().length>0 && meta.getFieldID()[0]!=null && meta.getFieldID()[0].length()>0;\n\t\t\n\t\tValue value=null;\n\t\tif (use_ids)\n\t\t{\n\t\t\tif (log.isDebug()) logDebug(\"Using IDs!!\");\n\t\t\t// pol all split fields\n\t\t\t// Loop over the specified field list\n\t\t\t// If we spot the corresponding id[] entry in pol, add the value\n\t\t\t//\n\t\t\tString pol[] = new String[meta.getField().length];\n\t\t\tint prev=0;\n\t\t\tint i=0;\n\t\t\twhile(v.getString()!=null && prev<v.getString().length() && i<pol.length)\n\t\t\t{\n\t\t\t\tpol[i]=polNext(v.getString(), meta.getDelimiter(), prev);\n\t\t\t\tif (log.isDebug()) logDebug(\"pol=\"+pol[i]+\", prev=\"+prev);\n\t\t\t\tprev+=pol[i].length()+meta.getDelimiter().length();\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// We have to add info.field.length variables!\n\t\t\tfor (i=0;i<meta.getField().length;i++)\n\t\t\t{\n\t\t\t\t// We have a field, search the corresponding pol[] entry.\n\t\t\t\tString split=null;\n\n\t\t\t\tfor (int p=0; p<pol.length && split==null; p++) \n\t\t\t\t{\n\t\t\t\t\t// With which line does pol[p] correspond?\n\t\t\t\t\tif (pol[p]!=null && pol[p].indexOf(meta.getFieldID()[i])>=0) split=pol[p];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Optionally remove the indicator\t\t\t\t\n\t\t\t\tif (split!=null && meta.removeID()[i])\n\t\t\t\t{\n\t\t\t\t\tStringBuffer sb = new StringBuffer(split);\n\t\t\t\t\tint idx = sb.indexOf(meta.getFieldID()[i]);\n\t\t\t\t\tsb.delete(idx, idx+meta.getFieldID()[i].length());\n\t\t\t\t\tsplit=sb.toString();\n\t\t\t\t}\n\n\t\t\t\tif (split==null) split=\"\";\n\t\t\t\tif (log.isDebug()) logDebug(\"Split=\"+split);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvalue = TextFileInput.convertValue\n\t\t\t\t\t(\n\t\t\t\t\t\tsplit,\n\t\t\t\t\t\tmeta.getField()[i],\n\t\t\t\t\t\tmeta.getFieldType()[i],\n\t\t\t\t\t\tmeta.getFieldFormat()[i],\n\t\t\t\t\t\tmeta.getFieldLength()[i],\n\t\t\t\t\t\tmeta.getFieldPrecision()[i],\n\t\t\t\t\t\tmeta.getFieldGroup()[i],\n\t\t\t\t\t\tmeta.getFieldDecimal()[i],\n\t\t\t\t\t\tmeta.getFieldCurrency()[i],\n\t\t\t\t\t\tmeta.getFieldDefault()[i],\n\t\t\t\t\t\t\"\", // --> The default String value in case a field is empty.\n\t\t\t\t\t\tTextFileInputMeta.TYPE_TRIM_BOTH,\n\t\t\t\t\t\tdata.df, data.dfs,\n\t\t\t\t\t\tdata.daf, data.dafs\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\tlogError(\"Error converting value [\"+split+\"], when splitting field [\"+meta.getSplitField()+\"]!\");\n\t\t\t\t\tsetErrors(1);\n\t\t\t\t\tstopAll();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (insert) r.addValue(data.fieldnr+i, value); else r.addValue(value);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (log.isDebug()) logDebug(\"Using position of value!!\");\n\t\t\tint prev=0;\n\t\t\tfor (int i=0;i<meta.getField().length;i++)\n\t\t\t{\n\t\t\t\tString pol = polNext(v.getString(), meta.getDelimiter(), prev);\n\t\t\t\tif (log.isDebug()) logDebug(\"pol=\"+pol+\", prev=\"+prev);\n\t\t\t\tprev+=(pol==null?0:pol.length()) + meta.getDelimiter().length();\n\t\t\t\t\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvalue = TextFileInput.convertValue\n\t\t\t\t\t(\n\t\t\t\t\t\tpol,\n\t\t\t\t\t\tmeta.getField()[i],\n\t\t\t\t\t\tmeta.getFieldType()[i],\n\t\t\t\t\t\tmeta.getFieldFormat()[i],\n\t\t\t\t\t\tmeta.getFieldLength()[i],\n\t\t\t\t\t\tmeta.getFieldPrecision()[i],\n\t\t\t\t\t\tmeta.getFieldGroup()[i],\n\t\t\t\t\t\tmeta.getFieldDecimal()[i],\n\t\t\t\t\t\tmeta.getFieldCurrency()[i],\n\t\t\t\t\t\tmeta.getFieldDefault()[i],\n\t\t\t\t\t\t\"\", // --> The default String value in case a field is empty.\n\t\t\t\t\t\tTextFileInputMeta.TYPE_TRIM_BOTH,\n\t\t\t\t\t\tdata.df, data.dfs,\n\t\t\t\t\t\tdata.daf, data.dafs\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\tlogError(\"Error converting value [\"+pol+\"], when splitting field [\"+meta.getSplitField()+\"]!\");\n\t\t\t\t\tsetErrors(1);\n\t\t\t\t\tstopAll();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (insert) r.addValue(data.fieldnr+i, value); else r.addValue(value);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}","id":98045,"modified_method":"private boolean splitField(Row r)\n\t{\n\t\tif (first)\n\t\t{\n\t\t\tdata.fieldnr=r.searchValueIndex(meta.getSplitField());\n\t\t\tif (data.fieldnr<0)\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"FieldSplitter.Log.CouldNotFindFieldToSplit\",meta.getSplitField())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tsetErrors(1);\n\t\t\t\tstopAll();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tValue v=r.getValue(data.fieldnr);\n\t\tr.removeValue(data.fieldnr); \n\t\tboolean insert = data.fieldnr<r.size();\n\t\t\n\t\tif (!v.isString())\n\t\t{\n\t\t\tlogError(Messages.getString(\"FieldSplitter.Log.SplitFieldNotValid\",meta.getSplitField())); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Named values info.id[0] not filled in!\n\t\tboolean use_ids = meta.getFieldID().length>0 && meta.getFieldID()[0]!=null && meta.getFieldID()[0].length()>0;\n\t\t\n\t\tValue value=null;\n\t\tif (use_ids)\n\t\t{\n\t\t\tif (log.isDebug()) logDebug(Messages.getString(\"FieldSplitter.Log.UsingIds\")); //$NON-NLS-1$\n\t\t\t// pol all split fields\n\t\t\t// Loop over the specified field list\n\t\t\t// If we spot the corresponding id[] entry in pol, add the value\n\t\t\t//\n\t\t\tString pol[] = new String[meta.getField().length];\n\t\t\tint prev=0;\n\t\t\tint i=0;\n\t\t\twhile(v.getString()!=null && prev<v.getString().length() && i<pol.length)\n\t\t\t{\n\t\t\t\tpol[i]=polNext(v.getString(), meta.getDelimiter(), prev);\n\t\t\t\tif (log.isDebug()) logDebug(Messages.getString(\"FieldSplitter.Log.SplitFieldsInfo\",pol[i],String.valueOf(prev))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tprev+=pol[i].length()+meta.getDelimiter().length();\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// We have to add info.field.length variables!\n\t\t\tfor (i=0;i<meta.getField().length;i++)\n\t\t\t{\n\t\t\t\t// We have a field, search the corresponding pol[] entry.\n\t\t\t\tString split=null;\n\n\t\t\t\tfor (int p=0; p<pol.length && split==null; p++) \n\t\t\t\t{\n\t\t\t\t\t// With which line does pol[p] correspond?\n\t\t\t\t\tif (pol[p]!=null && pol[p].indexOf(meta.getFieldID()[i])>=0) split=pol[p];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Optionally remove the indicator\t\t\t\t\n\t\t\t\tif (split!=null && meta.removeID()[i])\n\t\t\t\t{\n\t\t\t\t\tStringBuffer sb = new StringBuffer(split);\n\t\t\t\t\tint idx = sb.indexOf(meta.getFieldID()[i]);\n\t\t\t\t\tsb.delete(idx, idx+meta.getFieldID()[i].length());\n\t\t\t\t\tsplit=sb.toString();\n\t\t\t\t}\n\n\t\t\t\tif (split==null) split=\"\"; //$NON-NLS-1$\n\t\t\t\tif (log.isDebug()) logDebug(Messages.getString(\"FieldSplitter.Log.SplitInfo\")+split); //$NON-NLS-1$\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvalue = TextFileInput.convertValue\n\t\t\t\t\t(\n\t\t\t\t\t\tsplit,\n\t\t\t\t\t\tmeta.getField()[i],\n\t\t\t\t\t\tmeta.getFieldType()[i],\n\t\t\t\t\t\tmeta.getFieldFormat()[i],\n\t\t\t\t\t\tmeta.getFieldLength()[i],\n\t\t\t\t\t\tmeta.getFieldPrecision()[i],\n\t\t\t\t\t\tmeta.getFieldGroup()[i],\n\t\t\t\t\t\tmeta.getFieldDecimal()[i],\n\t\t\t\t\t\tmeta.getFieldCurrency()[i],\n\t\t\t\t\t\tmeta.getFieldDefault()[i],\n\t\t\t\t\t\t\"\", // --> The default String value in case a field is empty. //$NON-NLS-1$\n\t\t\t\t\t\tTextFileInputMeta.TYPE_TRIM_BOTH,\n\t\t\t\t\t\tdata.df, data.dfs,\n\t\t\t\t\t\tdata.daf, data.dafs\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\tlogError(Messages.getString(\"FieldSplitter.Log.ErrorConvertingSplitValue\",split,meta.getSplitField()+\"]!\")); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t\t\tsetErrors(1);\n\t\t\t\t\tstopAll();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (insert) r.addValue(data.fieldnr+i, value); else r.addValue(value);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (log.isDebug()) logDebug(Messages.getString(\"FieldSplitter.Log.UsingPositionOfValue\")); //$NON-NLS-1$\n\t\t\tint prev=0;\n\t\t\tfor (int i=0;i<meta.getField().length;i++)\n\t\t\t{\n\t\t\t\tString pol = polNext(v.getString(), meta.getDelimiter(), prev);\n\t\t\t\tif (log.isDebug()) logDebug(Messages.getString(\"FieldSplitter.Log.SplitFieldsInfo\",pol,String.valueOf(prev))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tprev+=(pol==null?0:pol.length()) + meta.getDelimiter().length();\n\t\t\t\t\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvalue = TextFileInput.convertValue\n\t\t\t\t\t(\n\t\t\t\t\t\tpol,\n\t\t\t\t\t\tmeta.getField()[i],\n\t\t\t\t\t\tmeta.getFieldType()[i],\n\t\t\t\t\t\tmeta.getFieldFormat()[i],\n\t\t\t\t\t\tmeta.getFieldLength()[i],\n\t\t\t\t\t\tmeta.getFieldPrecision()[i],\n\t\t\t\t\t\tmeta.getFieldGroup()[i],\n\t\t\t\t\t\tmeta.getFieldDecimal()[i],\n\t\t\t\t\t\tmeta.getFieldCurrency()[i],\n\t\t\t\t\t\tmeta.getFieldDefault()[i],\n\t\t\t\t\t\t\"\", // --> The default String value in case a field is empty. //$NON-NLS-1$\n\t\t\t\t\t\tTextFileInputMeta.TYPE_TRIM_BOTH,\n\t\t\t\t\t\tdata.df, data.dfs,\n\t\t\t\t\t\tdata.daf, data.dafs\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\tlogError(Messages.getString(\"FieldSplitter.Log.ErrorConvertingSplitValue\",pol,meta.getSplitField()+\"]!\")); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t\t\tsetErrors(1);\n\t\t\t\t\tstopAll();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (insert) r.addValue(data.fieldnr+i, value); else r.addValue(value);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(\"Field splitter\");\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(\"Step name \");\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Typefield line\n\t\twlSplitfield=new Label(shell, SWT.RIGHT);\n\t\twlSplitfield.setText(\"Field to split \");\n \t\tprops.setLook(wlSplitfield);\n\t\tfdlSplitfield=new FormData();\n\t\tfdlSplitfield.left = new FormAttachment(0, 0);\n\t\tfdlSplitfield.right= new FormAttachment(middle, -margin);\n\t\tfdlSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\twlSplitfield.setLayoutData(fdlSplitfield);\n\t\twSplitfield=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSplitfield.setText(\"\");\n \t\tprops.setLook(wSplitfield);\n\t\twSplitfield.addModifyListener(lsMod);\n\t\tfdSplitfield=new FormData();\n\t\tfdSplitfield.left = new FormAttachment(middle, 0);\n\t\tfdSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\tfdSplitfield.right= new FormAttachment(100, 0);\n\t\twSplitfield.setLayoutData(fdSplitfield);\n\n\t\t// Typefield line\n\t\twlDelimiter=new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(\"Delimiter \");\n \t\tprops.setLook(wlDelimiter);\n\t\tfdlDelimiter=new FormData();\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\tfdlDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\n\t\twDelimiter=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twDelimiter.setText(\"\");\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tfdDelimiter=new FormData();\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\tfdDelimiter.right= new FormAttachment(100, 0);\n\t\twDelimiter.setLayoutData(fdDelimiter);\n\n\t\twlFields=new Label(shell, SWT.RIGHT);\n\t\twlFields.setText(\"Fields \");\n \t\tprops.setLook(wlFields);\n\t\tfdlFields=new FormData();\n\t\tfdlFields.left = new FormAttachment(0, 0);\n\t\tfdlFields.top  = new FormAttachment(wDelimiter, margin);\n\t\twlFields.setLayoutData(fdlFields);\n\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(\" &OK \");\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(\" &Cancel \");\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\n\n\t\tfinal int FieldsCols=11;\n\t\tfinal int FieldsRows=input.getField().length;\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\n\t\tcolinf[ 0]=new ColumnInfo(\"New field\",   ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[ 1]=new ColumnInfo(\"ID\",          ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[ 2]=new ColumnInfo(\"Remove ID?\",  ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"Y\", \"N\" } );\n\t\tcolinf[ 3]=new ColumnInfo(\"Type\",        ColumnInfo.COLUMN_TYPE_CCOMBO, Value.getTypes() );\n\t\tcolinf[ 4]=new ColumnInfo(\"Length\",      ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[ 5]=new ColumnInfo(\"Precision\",   ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[ 6]=new ColumnInfo(\"Format\",      ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[ 7]=new ColumnInfo(\"Group\",       ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[ 8]=new ColumnInfo(\"Decimal\",     ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[ 9]=new ColumnInfo(\"Currency\",    ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\tcolinf[10]=new ColumnInfo(\"Nullif\",      ColumnInfo.COLUMN_TYPE_TEXT,   false );\n\t\t\n\t\twFields=new TableView(shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t      colinf, \n\t\t\t\t\t\t      FieldsRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left = new FormAttachment(0, 0);\n\t\tfdFields.top  = new FormAttachment(wlFields, margin);\n\t\tfdFields.right  = new FormAttachment(100, 0);\n\t\tfdFields.bottom = new FormAttachment(wOK, -2*margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":98046,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"FieldSplitterDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"FieldSplitterDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Typefield line\n\t\twlSplitfield=new Label(shell, SWT.RIGHT);\n\t\twlSplitfield.setText(Messages.getString(\"FieldSplitterDialog.SplitField.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSplitfield);\n\t\tfdlSplitfield=new FormData();\n\t\tfdlSplitfield.left = new FormAttachment(0, 0);\n\t\tfdlSplitfield.right= new FormAttachment(middle, -margin);\n\t\tfdlSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\twlSplitfield.setLayoutData(fdlSplitfield);\n\t\twSplitfield=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSplitfield.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wSplitfield);\n\t\twSplitfield.addModifyListener(lsMod);\n\t\tfdSplitfield=new FormData();\n\t\tfdSplitfield.left = new FormAttachment(middle, 0);\n\t\tfdSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\tfdSplitfield.right= new FormAttachment(100, 0);\n\t\twSplitfield.setLayoutData(fdSplitfield);\n\n\t\t// Typefield line\n\t\twlDelimiter=new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(Messages.getString(\"FieldSplitterDialog.Delimiter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDelimiter);\n\t\tfdlDelimiter=new FormData();\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\tfdlDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\n\t\twDelimiter=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twDelimiter.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tfdDelimiter=new FormData();\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\tfdDelimiter.right= new FormAttachment(100, 0);\n\t\twDelimiter.setLayoutData(fdDelimiter);\n\n\t\twlFields=new Label(shell, SWT.RIGHT);\n\t\twlFields.setText(Messages.getString(\"FieldSplitterDialog.Fields.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlFields);\n\t\tfdlFields=new FormData();\n\t\tfdlFields.left = new FormAttachment(0, 0);\n\t\tfdlFields.top  = new FormAttachment(wDelimiter, margin);\n\t\twlFields.setLayoutData(fdlFields);\n\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"FieldSplitterDialog.OK.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"FieldSplitterDialog.Cancel.Button\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\n\n\t\tfinal int FieldsCols=11;\n\t\tfinal int FieldsRows=input.getField().length;\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\n\t\tcolinf[ 0]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.NewField\"),   ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[ 1]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.ID\"),          ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[ 2]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.RemoveID\"),  ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"Y\", \"N\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\tcolinf[ 3]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Type\"),        ColumnInfo.COLUMN_TYPE_CCOMBO, Value.getTypes() ); //$NON-NLS-1$\n\t\tcolinf[ 4]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Length\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[ 5]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Precision\"),   ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[ 6]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Format\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[ 7]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Group\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[ 8]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Decimal\"),     ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[ 9]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Currency\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\tcolinf[10]=new ColumnInfo(Messages.getString(\"FieldSplitterDialog.ColumnInfo.Nullif\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ); //$NON-NLS-1$\n\t\t\n\t\twFields=new TableView(shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t      colinf, \n\t\t\t\t\t\t      FieldsRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left = new FormAttachment(0, 0);\n\t\tfdFields.top  = new FormAttachment(wlFields, margin);\n\t\tfdFields.right  = new FormAttachment(100, 0);\n\t\tfdFields.bottom = new FormAttachment(wOK, -2*margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsplitField = XMLHandler.getTagValue(stepnode, \"splitfield\");\n\t\t\tdelimiter  = XMLHandler.getTagValue(stepnode, \"delimiter\");\n\t\t\t\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfields   = XMLHandler.countNodes(fields, \"field\");\n\t\n\t\t\tallocate(nrfields);\n\t\t\t\t\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\t\t\t\t\n\t\t\t\tfield     [i]  = XMLHandler.getTagValue(fnode, \"name\"); \n\t\t\t\tfieldID       [i]  = XMLHandler.getTagValue(fnode, \"id\");\n\t\t\t\tString sidrem  = XMLHandler.getTagValue(fnode, \"idrem\");\n\t\t\t\tString stype   = XMLHandler.getTagValue(fnode, \"type\");\n\t\t\t\tfieldFormat    [i]  = XMLHandler.getTagValue(fnode, \"format\");\n\t\t\t\tfieldGroup     [i]  = XMLHandler.getTagValue(fnode, \"group\");\n\t\t\t\tfieldDecimal   [i]  = XMLHandler.getTagValue(fnode, \"decimal\");\n\t\t\t\tfieldCurrency  [i]  = XMLHandler.getTagValue(fnode, \"currency\");\n\t\t\t\tString slen    = XMLHandler.getTagValue(fnode, \"length\");\n\t\t\t\tString sprc    = XMLHandler.getTagValue(fnode, \"precision\");\n\t\t\t\tfieldDefault    [i]  = XMLHandler.getTagValue(fnode, \"nullif\");\n\t\t\t\t\n\t\t\t\tremoveID[i] = \"Y\".equalsIgnoreCase(sidrem);\n\t\t\t\tfieldType[i]  = Value.getType(stype);\n\t\t\t\tfieldLength   [i]=Const.toInt(slen, -1); \n\t\t\t\tfieldPrecision[i]=Const.toInt(sprc, -1); \n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":98047,"modified_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsplitField = XMLHandler.getTagValue(stepnode, \"splitfield\"); //$NON-NLS-1$\n\t\t\tdelimiter  = XMLHandler.getTagValue(stepnode, \"delimiter\"); //$NON-NLS-1$\n\t\t\t\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\"); //$NON-NLS-1$\n\t\t\tint nrfields   = XMLHandler.countNodes(fields, \"field\"); //$NON-NLS-1$\n\t\n\t\t\tallocate(nrfields);\n\t\t\t\t\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i); //$NON-NLS-1$\n\t\t\t\t\n\t\t\t\tfield     [i]  = XMLHandler.getTagValue(fnode, \"name\");  //$NON-NLS-1$\n\t\t\t\tfieldID       [i]  = XMLHandler.getTagValue(fnode, \"id\"); //$NON-NLS-1$\n\t\t\t\tString sidrem  = XMLHandler.getTagValue(fnode, \"idrem\"); //$NON-NLS-1$\n\t\t\t\tString stype   = XMLHandler.getTagValue(fnode, \"type\"); //$NON-NLS-1$\n\t\t\t\tfieldFormat    [i]  = XMLHandler.getTagValue(fnode, \"format\"); //$NON-NLS-1$\n\t\t\t\tfieldGroup     [i]  = XMLHandler.getTagValue(fnode, \"group\"); //$NON-NLS-1$\n\t\t\t\tfieldDecimal   [i]  = XMLHandler.getTagValue(fnode, \"decimal\"); //$NON-NLS-1$\n\t\t\t\tfieldCurrency  [i]  = XMLHandler.getTagValue(fnode, \"currency\"); //$NON-NLS-1$\n\t\t\t\tString slen    = XMLHandler.getTagValue(fnode, \"length\"); //$NON-NLS-1$\n\t\t\t\tString sprc    = XMLHandler.getTagValue(fnode, \"precision\"); //$NON-NLS-1$\n\t\t\t\tfieldDefault    [i]  = XMLHandler.getTagValue(fnode, \"nullif\"); //$NON-NLS-1$\n\t\t\t\t\n\t\t\t\tremoveID[i] = \"Y\".equalsIgnoreCase(sidrem); //$NON-NLS-1$\n\t\t\t\tfieldType[i]  = Value.getType(stype);\n\t\t\t\tfieldLength   [i]=Const.toInt(slen, -1); \n\t\t\t\tfieldPrecision[i]=Const.toInt(sprc, -1); \n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"FieldSplitterMeta.Exception.UnableToLoadStepInfoFromXML\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"splitfield\", splitField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"delimiter\",  delimiter);\n\t\n\t\t\tfor (int i=0;i<field.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_id\",        fieldID[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_idrem\",     removeID[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      Value.getTypeDesc(fieldType[i]));\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    fieldFormat[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",     fieldGroup[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",   fieldDecimal[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    fieldLength[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", fieldPrecision[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\",    fieldDefault[i]);\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\n\t\t}\n\t}","id":98048,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"splitfield\", splitField); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"delimiter\",  delimiter); //$NON-NLS-1$\n\t\n\t\t\tfor (int i=0;i<field.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_id\",        fieldID[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_idrem\",     removeID[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      Value.getTypeDesc(fieldType[i])); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    fieldFormat[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",     fieldGroup[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",   fieldDecimal[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    fieldLength[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", fieldPrecision[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\",    fieldDefault[i]); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"FieldSplitterMeta.Exception.UnalbeToSaveStepInfoToRepository\")+id_step, e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsplitField  = rep.getStepAttributeString(id_step, \"splitfield\");\n\t\t\tdelimiter   = rep.getStepAttributeString(id_step, \"delimiter\");\n\t\t\t\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\n\t\t\t\n\t\t\tallocate(nrfields);\n\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfield[i]       =       rep.getStepAttributeString (id_step, i, \"field_name\");\n\t\t\t\tfieldID[i]         =       rep.getStepAttributeString (id_step, i, \"field_id\");\n\t\t\t\tremoveID[i]       =       rep.getStepAttributeBoolean(id_step, i, \"field_idrem\");\n\t\t\t\tfieldType[i]        =  Value.getType( rep.getStepAttributeString (id_step, i, \"field_type\") );\n\t\t\t\tfieldFormat[i]      =       rep.getStepAttributeString (id_step, i, \"field_format\");\n\t\t\t\tfieldGroup[i]       =       rep.getStepAttributeString (id_step, i, \"field_group\");\n\t\t\t\tfieldDecimal[i]     =       rep.getStepAttributeString (id_step, i, \"field_decimal\");\n\t\t\t\tfieldLength[i]      =  (int)rep.getStepAttributeInteger(id_step, i, \"field_length\");\n\t\t\t\tfieldPrecision[i]   =  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\");\n\t\t\t\tfieldDefault[i]      =       rep.getStepAttributeString (id_step, i, \"field_nullif\");\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":98049,"modified_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsplitField  = rep.getStepAttributeString(id_step, \"splitfield\"); //$NON-NLS-1$\n\t\t\tdelimiter   = rep.getStepAttributeString(id_step, \"delimiter\"); //$NON-NLS-1$\n\t\t\t\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\"); //$NON-NLS-1$\n\t\t\t\n\t\t\tallocate(nrfields);\n\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfield[i]       =       rep.getStepAttributeString (id_step, i, \"field_name\"); //$NON-NLS-1$\n\t\t\t\tfieldID[i]         =       rep.getStepAttributeString (id_step, i, \"field_id\"); //$NON-NLS-1$\n\t\t\t\tremoveID[i]       =       rep.getStepAttributeBoolean(id_step, i, \"field_idrem\"); //$NON-NLS-1$\n\t\t\t\tfieldType[i]        =  Value.getType( rep.getStepAttributeString (id_step, i, \"field_type\") ); //$NON-NLS-1$\n\t\t\t\tfieldFormat[i]      =       rep.getStepAttributeString (id_step, i, \"field_format\"); //$NON-NLS-1$\n\t\t\t\tfieldGroup[i]       =       rep.getStepAttributeString (id_step, i, \"field_group\"); //$NON-NLS-1$\n\t\t\t\tfieldDecimal[i]     =       rep.getStepAttributeString (id_step, i, \"field_decimal\"); //$NON-NLS-1$\n\t\t\t\tfieldLength[i]      =  (int)rep.getStepAttributeInteger(id_step, i, \"field_length\"); //$NON-NLS-1$\n\t\t\t\tfieldPrecision[i]   =  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\"); //$NON-NLS-1$\n\t\t\t\tfieldDefault[i]      =       rep.getStepAttributeString (id_step, i, \"field_nullif\"); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"FieldSplitterMeta.Exception.UnexpectedErrorInReadingStepInfo\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tString error_message=\"\";\n\t\tCheckResult cr;\n\t\t\n\t\t// Look up fields in the input stream <prev>\n\t\tif (prev!=null && prev.size()>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is connected to previous one, receiving \"+prev.size()+\" fields\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t\t\n\t\t\terror_message = \"\";\n\t\t\t\n\t\t\tValue v = prev.searchValue(splitField);\n\t\t\tif (v==null)\n\t\t\t{\n\t\t\t\terror_message=\"Field to split [\"+splitField+\"] is not present in the input stream!\";\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Splitfield [\"+splitField+\"]found in the input stream.\", stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message=\"Couldn't read fields from the previous step.\"+Const.CR;\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is receiving info from other steps.\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No input received from other steps!\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","id":98050,"modified_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tString error_message=\"\"; //$NON-NLS-1$\n\t\tCheckResult cr;\n\t\t\n\t\t// Look up fields in the input stream <prev>\n\t\tif (prev!=null && prev.size()>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"FieldSplitterMeta.CheckResult.StepReceivingFields\",prev.size()+\"\"), stepMeta); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tremarks.add(cr);\n\t\t\t\n\t\t\terror_message = \"\"; //$NON-NLS-1$\n\t\t\t\n\t\t\tValue v = prev.searchValue(splitField);\n\t\t\tif (v==null)\n\t\t\t{\n\t\t\t\terror_message=Messages.getString(\"FieldSplitterMeta.CheckResult.SplitedFieldNotPresentInInputStream\",splitField); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"FieldSplitterMeta.CheckResult.SplitedFieldFoundInInputStream\",splitField), stepMeta); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message=Messages.getString(\"FieldSplitterMeta.CheckResult.CouldNotReadFieldsFromPreviousStep\")+Const.CR; //$NON-NLS-1$\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"FieldSplitterMeta.CheckResult.StepReceivingInfoFromOtherStep\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"FieldSplitterMeta.CheckResult.NoInputReceivedFromOtherStep\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","commit_id":"5612521f61ffa808f683bd80f95cd0ffaf1b9604","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addModule(String moduleName, Class<?> typeClass) throws DatasetManagementException {\n    Location tempJarPath;\n    try {\n      tempJarPath = createDeploymentJar(typeClass);\n      try {\n        client.addModule(moduleName, typeClass.getName(), tempJarPath);\n      } finally {\n        tempJarPath.delete();\n      }\n    } catch (IOException e) {\n      String msg = String.format(\"Could not create jar for deploying dataset module %s with main class %s\",\n                                 moduleName, typeClass.getName());\n      LOG.error(msg, e);\n      throw new DatasetManagementException(msg, e);\n    }\n  }","id":98051,"modified_method":"private void addModule(String moduleName, Class<?> typeClass) throws DatasetManagementException {\n    try {\n      File tempFile = File.createTempFile(typeClass.getName(), \".jar\");\n      try {\n        Location tempJarPath = createDeploymentJar(typeClass, new LocalLocationFactory().create(tempFile.toURI()));\n        client.addModule(moduleName, typeClass.getName(), tempJarPath);\n      } finally {\n        tempFile.delete();\n      }\n    } catch (IOException e) {\n      String msg = String.format(\"Could not create jar for deploying dataset module %s with main class %s\",\n                                 moduleName, typeClass.getName());\n      LOG.error(msg, e);\n      throw new DatasetManagementException(msg, e);\n    }\n  }","commit_id":"a685910a3866f00406594d92157a72d661fbf3fd","url":"https://github.com/caskdata/cdap"},{"original_method":"private static Location createDeploymentJar(Class<?> clz) throws IOException {\n    File tempFile = File.createTempFile(clz.getName(), \".jar\");\n    Location tempJarLocation = new LocalLocationFactory().create(tempFile.getPath());\n\n    ClassLoader remembered = Thread.currentThread().getContextClassLoader();\n    Thread.currentThread().setContextClassLoader(clz.getClassLoader());\n    try {\n      ApplicationBundler bundler = new ApplicationBundler(ImmutableList.of(\"co.cask.cdap.api\",\n                                                                           \"org.apache.hadoop\",\n                                                                           \"org.apache.hbase\",\n                                                                           \"org.apache.hive\"));\n      bundler.createBundle(tempJarLocation, clz);\n    } finally {\n      Thread.currentThread().setContextClassLoader(remembered);\n    }\n\n    // Create the program jar for deployment. It removes the \"classes/\" prefix as that's the convention taken\n    // by the ApplicationBundler inside Twill.\n    File outFile = File.createTempFile(clz.getName(), \".jar\");\n    Location outJarLocation = new LocalLocationFactory().create(outFile.getPath());\n\n    JarOutputStream jarOutput = new JarOutputStream(outJarLocation.getOutputStream());\n    try {\n      JarInputStream jarInput = new JarInputStream(tempJarLocation.getInputStream());\n      try {\n        JarEntry jarEntry = jarInput.getNextJarEntry();\n        while (jarEntry != null) {\n          boolean isDir = jarEntry.isDirectory();\n          String entryName = jarEntry.getName();\n          if (!entryName.equals(\"classes/\")) {\n            if (entryName.startsWith(\"classes/\")) {\n              jarEntry = new JarEntry(entryName.substring(\"classes/\".length()));\n            } else {\n              jarEntry = new JarEntry(entryName);\n            }\n            jarOutput.putNextEntry(jarEntry);\n\n            if (!isDir) {\n              ByteStreams.copy(jarInput, jarOutput);\n            }\n          }\n\n          jarEntry = jarInput.getNextJarEntry();\n        }\n      } finally {\n        jarInput.close();\n      }\n\n    } finally {\n      jarOutput.close();\n    }\n\n    return outJarLocation;\n  }","id":98052,"modified_method":"private static Location createDeploymentJar(Class<?> clz, Location destination) throws IOException {\n    Location tempBundle = destination.getTempFile(\".jar\");\n    try {\n      ClassLoader remembered = Thread.currentThread().getContextClassLoader();\n      Thread.currentThread().setContextClassLoader(clz.getClassLoader());\n      try {\n        ApplicationBundler bundler = new ApplicationBundler(ImmutableList.of(\"co.cask.cdap.api\",\n                                                                             \"org.apache.hadoop\",\n                                                                             \"org.apache.hbase\",\n                                                                             \"org.apache.hive\"));\n        bundler.createBundle(tempBundle, clz);\n      } finally {\n        Thread.currentThread().setContextClassLoader(remembered);\n      }\n\n      // Create the program jar for deployment. It removes the \"classes/\" prefix as that's the convention taken\n      // by the ApplicationBundler inside Twill.\n      JarOutputStream jarOutput = new JarOutputStream(destination.getOutputStream());\n      try {\n        JarInputStream jarInput = new JarInputStream(tempBundle.getInputStream());\n        try {\n          Set<String> seen = Sets.newHashSet();\n          JarEntry jarEntry = jarInput.getNextJarEntry();\n          while (jarEntry != null) {\n            boolean isDir = jarEntry.isDirectory();\n            String entryName = jarEntry.getName();\n            if (!entryName.equals(\"classes/\")) {\n              if (entryName.startsWith(\"classes/\")) {\n                jarEntry = new JarEntry(entryName.substring(\"classes/\".length()));\n              } else {\n                jarEntry = new JarEntry(entryName);\n              }\n              if (seen.add(jarEntry.getName())) {\n                jarOutput.putNextEntry(jarEntry);\n\n                if (!isDir) {\n                  ByteStreams.copy(jarInput, jarOutput);\n                }\n              }\n            }\n\n            jarEntry = jarInput.getNextJarEntry();\n          }\n        } finally {\n          jarInput.close();\n        }\n\n      } finally {\n        jarOutput.close();\n      }\n\n      return destination;\n    } finally {\n      tempBundle.delete();\n    }\n  }","commit_id":"a685910a3866f00406594d92157a72d661fbf3fd","url":"https://github.com/caskdata/cdap"},{"original_method":"public static Location createDeploymentJar(LocationFactory locationFactory, Class<?> clz, Manifest manifest,\n                                             File... bundleEmbeddedJars) throws IOException {\n\n    ApplicationBundler bundler = new ApplicationBundler(ImmutableList.of(\"co.cask.cdap.api\",\n                                                                         \"org.apache.hadoop\",\n                                                                         \"org.apache.hive\",\n                                                                         \"org.apache.spark\"),\n                                                        ImmutableList.of(\"org.apache.hadoop.hbase\"));\n    Location jarLocation = locationFactory.create(clz.getName()).getTempFile(\".jar\");\n    ClassLoader oldClassLoader = ClassLoaders.setContextClassLoader(clz.getClassLoader());\n    try {\n      bundler.createBundle(jarLocation, clz);\n    } finally {\n      ClassLoaders.setContextClassLoader(oldClassLoader);\n    }\n\n    Location deployJar = locationFactory.create(clz.getName()).getTempFile(\".jar\");\n    Manifest jarManifest = new Manifest(manifest);\n    jarManifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n    jarManifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS, clz.getName());\n\n\n    // Create the program jar for deployment. It removes the \"classes/\" prefix as that's the convention taken\n    // by the ApplicationBundler inside Twill.\n    try (\n      JarOutputStream jarOutput = new JarOutputStream(deployJar.getOutputStream(), jarManifest);\n      JarInputStream jarInput = new JarInputStream(jarLocation.getInputStream())\n    ) {\n      JarEntry jarEntry = jarInput.getNextJarEntry();\n      while (jarEntry != null) {\n        boolean isDir = jarEntry.isDirectory();\n        String entryName = jarEntry.getName();\n        if (!entryName.equals(\"classes/\")) {\n          if (entryName.startsWith(\"classes/\")) {\n            jarEntry = new JarEntry(entryName.substring(\"classes/\".length()));\n          } else {\n            jarEntry = new JarEntry(entryName);\n          }\n\n          // TODO: this is due to manifest possibly already existing in the jar, but we also\n          // create a manifest programatically so it's possible to have a duplicate entry here\n          if (\"META-INF/MANIFEST.MF\".equalsIgnoreCase(jarEntry.getName())) {\n            jarEntry = jarInput.getNextJarEntry();\n            continue;\n          }\n\n          jarOutput.putNextEntry(jarEntry);\n          if (!isDir) {\n            ByteStreams.copy(jarInput, jarOutput);\n          }\n        }\n\n        jarEntry = jarInput.getNextJarEntry();\n      }\n\n      for (File embeddedJar : bundleEmbeddedJars) {\n        jarEntry = new JarEntry(\"lib/\" + embeddedJar.getName());\n        jarOutput.putNextEntry(jarEntry);\n        Files.copy(embeddedJar, jarOutput);\n      }\n    }\n\n    return deployJar;\n  }","id":98053,"modified_method":"public static Location createDeploymentJar(LocationFactory locationFactory, Class<?> clz, Manifest manifest,\n                                             File... bundleEmbeddedJars) throws IOException {\n\n    ApplicationBundler bundler = new ApplicationBundler(ImmutableList.of(\"co.cask.cdap.api\",\n                                                                         \"org.apache.hadoop\",\n                                                                         \"org.apache.hive\",\n                                                                         \"org.apache.spark\"),\n                                                        ImmutableList.of(\"org.apache.hadoop.hbase\"));\n    Location jarLocation = locationFactory.create(clz.getName()).getTempFile(\".jar\");\n    ClassLoader oldClassLoader = ClassLoaders.setContextClassLoader(clz.getClassLoader());\n    try {\n      bundler.createBundle(jarLocation, clz);\n    } finally {\n      ClassLoaders.setContextClassLoader(oldClassLoader);\n    }\n\n    Location deployJar = locationFactory.create(clz.getName()).getTempFile(\".jar\");\n    Manifest jarManifest = new Manifest(manifest);\n    jarManifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n    jarManifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS, clz.getName());\n\n\n    // Create the program jar for deployment. It removes the \"classes/\" prefix as that's the convention taken\n    // by the ApplicationBundler inside Twill.\n    Set<String> seenEntries = new HashSet<>();\n    try (\n      JarOutputStream jarOutput = new JarOutputStream(deployJar.getOutputStream(), jarManifest);\n      JarInputStream jarInput = new JarInputStream(jarLocation.getInputStream())\n    ) {\n      JarEntry jarEntry = jarInput.getNextJarEntry();\n      while (jarEntry != null) {\n        boolean isDir = jarEntry.isDirectory();\n        String entryName = jarEntry.getName();\n        if (!entryName.equals(\"classes/\")) {\n          if (entryName.startsWith(\"classes/\")) {\n            jarEntry = new JarEntry(entryName.substring(\"classes/\".length()));\n          } else {\n            jarEntry = new JarEntry(entryName);\n          }\n\n          // TODO: this is due to manifest possibly already existing in the jar, but we also\n          // create a manifest programatically so it's possible to have a duplicate entry here\n          if (\"META-INF/MANIFEST.MF\".equalsIgnoreCase(jarEntry.getName())) {\n            jarEntry = jarInput.getNextJarEntry();\n            continue;\n          }\n\n          if (seenEntries.add(jarEntry.getName())) {\n            jarOutput.putNextEntry(jarEntry);\n            if (!isDir) {\n              ByteStreams.copy(jarInput, jarOutput);\n            }\n          }\n        }\n\n        jarEntry = jarInput.getNextJarEntry();\n      }\n\n      for (File embeddedJar : bundleEmbeddedJars) {\n        jarEntry = new JarEntry(\"lib/\" + embeddedJar.getName());\n        if (seenEntries.add(jarEntry.getName())) {\n          jarOutput.putNextEntry(jarEntry);\n          Files.copy(embeddedJar, jarOutput);\n        }\n      }\n    }\n\n    return deployJar;\n  }","commit_id":"e89f6f08bff0f49ee1a496b56b1af1ddf739cbb6","url":"https://github.com/caskdata/cdap"},{"original_method":"private void updateNode( long nodeId, int value )\n    {\n        Transaction tx = db.beginTx();\n        try\n        {\n            Node node = db.getNodeById( nodeId );\n            node.setProperty( NUM_BANANAS_KEY, value );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n    }","id":98054,"modified_method":"private void updateNode( long nodeId, int value )\n    {\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            Node node = db.getNodeById( nodeId );\n            node.setProperty( NUM_BANANAS_KEY, value );\n            tx.success();\n        }\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createIndex( Label label )\n    {\n        Transaction tx = db.beginTx();\n        IndexDefinition definition = db.schema().indexFor( label ).on( NUM_BANANAS_KEY ).create();\n        tx.success();\n        tx.finish();\n\n        tx = db.beginTx();\n        db.schema().awaitIndexOnline( definition, 10, TimeUnit.SECONDS );\n        tx.finish();\n    }","id":98055,"modified_method":"private IndexDefinition createIndex( Label label )\n    {\n        try ( Transaction tx = db.beginTx() )\n        {\n            IndexDefinition definition = db.schema().indexFor( label ).on( NUM_BANANAS_KEY ).create();\n            tx.success();\n            return definition;\n        }\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotUpdateTwiceDuringRecovery() throws Exception\n    {\n        // Given\n        startDb(createLuceneIndexFactory());\n        Label myLabel = label( \"MyLabel\" );\n\n        createIndex( myLabel );\n\n        long nodeId = createNode( myLabel, 12 );\n        updateNode(nodeId, 14);\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        assertEquals( 0, doIndexLookup( myLabel, 12 ).size() );\n        assertEquals( 1, doIndexLookup( myLabel, 14 ).size() );\n    }","id":98056,"modified_method":"@Test\n    public void shouldNotUpdateTwiceDuringRecovery() throws Exception\n    {\n        // Given\n        startDb( createLuceneIndexFactory() );\n\n        IndexDefinition indexDefinition = createIndex( myLabel );\n        waitForIndex( indexDefinition );\n\n        long nodeId = createNode( myLabel, 12 );\n        updateNode( nodeId, 14 );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        assertEquals( 0, doIndexLookup( myLabel, 12 ).size() );\n        assertEquals( 1, doIndexLookup( myLabel, 14 ).size() );\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotAddTwiceDuringRecoveryIfCrashedDuringPopulation() throws Exception\n    {\n        // Given\n        startDb( createAlwaysInitiallyPopulatingLuceneIndexFactory() );\n        Label myLabel = label( \"MyLabel\" );\n\n        createIndex( myLabel );\n        long nodeId = createNode( myLabel, 12 );\n        assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createAlwaysInitiallyPopulatingLuceneIndexFactory() );\n\n        Transaction transaction = db.beginTx();\n        try\n        {\n            IndexDefinition indexDefinition = db.schema().getIndexes().iterator().next();\n            db.schema().awaitIndexOnline( indexDefinition, 10l, TimeUnit.SECONDS );\n\n            // Then\n            assertEquals( 12, db.getNodeById( nodeId ).getProperty( NUM_BANANAS_KEY ) );\n            assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n        }\n        finally\n        {\n            transaction.finish();\n        }\n    }","id":98057,"modified_method":"@Test\n    public void shouldNotAddTwiceDuringRecoveryIfCrashedDuringPopulation() throws Exception\n    {\n        // Given\n        startDb( createAlwaysInitiallyPopulatingLuceneIndexFactory() );\n\n        IndexDefinition indexDefinition = createIndex( myLabel );\n        waitForIndex( indexDefinition );\n\n        long nodeId = createNode( myLabel, 12 );\n        assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createAlwaysInitiallyPopulatingLuceneIndexFactory() );\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            IndexDefinition index = db.schema().getIndexes().iterator().next();\n            waitForIndex( index );\n\n            // Then\n            assertEquals( 12, db.getNodeById( nodeId ).getProperty( NUM_BANANAS_KEY ) );\n            assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n        }\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void removeShouldBeIdempotentWhenDoingRecovery() throws Exception\n    {\n        // Given\n        startDb(createLuceneIndexFactory());\n        Label myLabel = label( \"MyLabel\" );\n        createIndex( myLabel );\n        long node = createNode( myLabel, 12 );\n        rotateLogs();\n        \n        deleteNode( node );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        assertEquals( 0, doIndexLookup( myLabel, 12 ).size() );\n    }","id":98058,"modified_method":"@Test\n    public void removeShouldBeIdempotentWhenDoingRecovery() throws Exception\n    {\n        // Given\n        startDb( createLuceneIndexFactory() );\n\n        IndexDefinition indexDefinition = createIndex( myLabel );\n        waitForIndex( indexDefinition );\n\n        long node = createNode( myLabel, 12 );\n        rotateLogs();\n\n        deleteNode( node );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        assertEquals( 0, doIndexLookup( myLabel, 12 ).size() );\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void addShouldBeIdempotentWhenDoingRecovery() throws Exception\n    {\n        // Given\n        startDb(createLuceneIndexFactory());\n        Label myLabel = label( \"MyLabel\" );\n\n        createIndex( myLabel );\n\n        createNode( myLabel, 12 );\n        assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n    }","id":98059,"modified_method":"@Test\n    public void addShouldBeIdempotentWhenDoingRecovery() throws Exception\n    {\n        // Given\n        startDb( createLuceneIndexFactory() );\n\n        IndexDefinition index = createIndex( myLabel );\n        waitForIndex( index );\n\n        long nodeId = createNode( myLabel, 12 );\n        try(Transaction tx = db.beginTx())\n        {\n            assertNotNull( db.getNodeById( nodeId ) );\n        }\n        assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        try(Transaction tx = db.beginTx())\n        {\n            assertNotNull( db.getNodeById( nodeId ) );\n        }\n        assertEquals( 1, doIndexLookup( myLabel, 12 ).size() );\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private long createNode( Label label, int number )\n           throws PropertyKeyNotFoundException, LabelNotFoundKernelException\n    {\n       Transaction tx = db.beginTx();\n       try\n       {\n           Node node = db.createNode( label );\n           node.setProperty( NUM_BANANAS_KEY, number );\n           tx.success();\n           return node.getId();\n       }\n       finally\n       {\n           tx.finish();\n       }\n    }","id":98060,"modified_method":"private long createNode( Label label, int number ) throws PropertyKeyNotFoundException, LabelNotFoundKernelException\n    {\n        try ( Transaction tx = db.beginTx() )\n        {\n            Node node = db.createNode( label );\n            node.setProperty( NUM_BANANAS_KEY, number );\n            tx.success();\n            return node.getId();\n        }\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void rotateLogs()\n    {\n//       db.getDependencyResolver().resolveDependency( XaDataSourceManager.class ).rotateLogicalLogs();\n    }","id":98061,"modified_method":"private void rotateLogs() throws IOException\n    {\n        final NeoStoreXaDataSource ds = db.getDependencyResolver().resolveDependency( NeoStoreXaDataSource.class );\n        final PhysicalLogFile pLogFile = ds.getDependencyResolver().resolveDependency( PhysicalLogFile.class );\n        pLogFile.forceRotate();\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void changeShouldBeIdempotentWhenDoingRecovery() throws Exception\n    {\n        // Given\n        startDb(createLuceneIndexFactory());\n        Label myLabel = label( \"MyLabel\" );\n        createIndex( myLabel );\n        long node = createNode( myLabel, 12 );\n        rotateLogs();\n        \n        updateNode( node, 13 );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        assertEquals( 0, doIndexLookup( myLabel, 12 ).size() );\n        assertEquals( 1, doIndexLookup( myLabel, 13 ).size() );\n    }","id":98062,"modified_method":"@Test\n    public void changeShouldBeIdempotentWhenDoingRecovery() throws Exception\n    {\n        // Given\n        startDb( createLuceneIndexFactory() );\n\n        IndexDefinition indexDefinition = createIndex( myLabel );\n        waitForIndex( indexDefinition );\n\n        long node = createNode( myLabel, 12 );\n        rotateLogs();\n\n        updateNode( node, 13 );\n\n        // And Given\n        killDb();\n\n        // When\n        startDb( createLuceneIndexFactory() );\n\n        // Then\n        assertEquals( 0, doIndexLookup( myLabel, 12 ).size() );\n        assertEquals( 1, doIndexLookup( myLabel, 13 ).size() );\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void deleteNode( long node )\n    {\n        Transaction tx = db.beginTx();\n        try\n        {\n            db.getNodeById( node ).delete();\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n    }","id":98063,"modified_method":"private void deleteNode( long node )\n    {\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.getNodeById( node ).delete();\n            tx.success();\n        }\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Set<Node> doIndexLookup( Label myLabel, Object value )\n    {\n        Transaction tx = db.beginTx();\n        Iterable<Node> iter = db.findNodesByLabelAndProperty( myLabel, NUM_BANANAS_KEY, value );\n        Set<Node> nodes = asUniqueSet( iter );\n        tx.success();\n        tx.finish();\n        return nodes;\n    }","id":98064,"modified_method":"private Set<Node> doIndexLookup( Label myLabel, Object value )\n    {\n        try ( Transaction tx = db.beginTx() )\n        {\n            Iterable<Node> iter = db.findNodesByLabelAndProperty( myLabel, NUM_BANANAS_KEY, value );\n            Set<Node> nodes = asUniqueSet( iter );\n            tx.success();\n            return nodes;\n        }\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void start() throws IOException\n    {\n        life = new LifeSupport();\n        readOnly = config.get( Configuration.read_only );\n        storeDir = config.get( Configuration.store_dir );\n        File store = config.get( Configuration.neo_store );\n        if ( !storeFactory.storeExists() )\n        {\n            storeFactory.createNeoStore().close();\n        }\n        indexProvider = dependencyResolver.resolveDependency( SchemaIndexProvider.class,\n                SchemaIndexProvider.HIGHEST_PRIORITIZED_OR_NONE );\n        storeMigrationProcess.addParticipant( indexProvider.storeMigrationParticipant() );\n        // TODO: Build a real provider map\n        final DefaultSchemaIndexProviderMap providerMap = new DefaultSchemaIndexProviderMap( indexProvider );\n        storeMigrationProcess.migrateIfNeeded( store.getParentFile() );\n        neoStore = dependencies.satisfyDependency( storeFactory.newNeoStore( false ) );\n        dependencies.satisfyDependency( TransactionIdStore.class, neoStore );\n\n        schemaCache = new SchemaCache( Collections.<SchemaRule>emptyList() );\n\n        nodeCache = new AutoLoadingCache<>(\n                cacheProvider.node(), nodeLoader( neoStore.getNodeStore() ) );\n        relationshipCache = new AutoLoadingCache<>(\n                cacheProvider.relationship(),\n                relationshipLoader( neoStore.getRelationshipStore() ) );\n        RelationshipLoader relationshipLoader = new RelationshipLoader( relationshipCache, new RelationshipChainLoader(\n                neoStore ) );\n        PersistenceCache persistenceCache = new PersistenceCache( nodeCache, relationshipCache, nodeManager,\n                relationshipLoader, propertyKeyTokenHolder, relationshipTypeTokens, labelTokens );\n        CacheAccessBackDoor cacheAccess = new BridgingCacheAccess( schemaCache, updateableSchemaState,\n                persistenceCache );\n        try\n        {\n            indexingService = new IndexingService( scheduler, providerMap, new NeoStoreIndexStoreView(\n                    lockService, neoStore ), tokenNameLookup, updateableSchemaState, indexRuleLoader(), logging,\n                    indexingServiceMonitor ); // TODO 2.2-future What index rules should be\n            final IntegrityValidator integrityValidator = new IntegrityValidator( neoStore, indexingService );\n            labelScanStore = dependencyResolver.resolveDependency( LabelScanStoreProvider.class,\n                    LabelScanStoreProvider.HIGHEST_PRIORITIZED ).getLabelScanStore();\n            fileListing = new NeoStoreFileListing( storeDir, labelScanStore, indexingService,\n                    legacyIndexProviderLookup );\n            Provider<NeoStore> neoStoreProvider = new Provider<NeoStore>()\n            {\n                @Override\n                public NeoStore instance()\n                {\n                    return getNeoStore();\n                }\n            };\n            storeLayer = new CacheLayer( new DiskLayer( propertyKeyTokenHolder, labelTokens, relationshipTypeTokens,\n                    new SchemaStorage( neoStore.getSchemaStore() ), neoStoreProvider, indexingService ),\n                    persistenceCache, indexingService, schemaCache );\n\n            // CHANGE STARTS HERE\n            VersionAwareLogEntryReader logEntryReader =\n                    new VersionAwareLogEntryReader( CommandReaderFactory.DEFAULT );\n            // Recovery process ties log and commit process together\n\n            LegacyPropertyTrackers legacyPropertyTrackers = new LegacyPropertyTrackers( propertyKeyTokenHolder,\n                    nodeManager.getNodePropertyTrackers(), nodeManager.getRelationshipPropertyTrackers(), nodeManager );\n            StatisticsService statisticsService =\n                    new StatisticsServiceRepository( fs, config, storeLayer, scheduler ).loadStatistics();\n            final NeoStoreTransactionContextSupplier neoStoreTransactionContextSupplier =\n                    new NeoStoreTransactionContextSupplier( neoStore );\n\n            final TransactionHooks hooks = new TransactionHooks();\n            File directory = config.get( GraphDatabaseSettings.store_dir );\n            TransactionMetadataCache transactionMetadataCache = new TransactionMetadataCache( 1000, 100_000 );\n            PhysicalLogFiles logFiles = new PhysicalLogFiles( directory, PhysicalLogFile.DEFAULT_NAME, fs );\n\n            LogFileInformation logFileInformation = dependencies.satisfyDependency( LogFileInformation.class,\n                    new PhysicalLogFileInformation( logFiles, transactionMetadataCache, neoStore,\n                            new PhysicalLogFileInformation.SPI()\n                            {\n                                @Override\n                                public long getTimestampForVersion( long version ) throws IOException\n                                {\n\n                                    try ( ReadableLogChannel channel = logFile.getReader(\n                                            new LogPosition( version, VersionAwareLogEntryReader.LOG_HEADER_SIZE ) ) )\n                                    {\n                                        LogEntryReader<ReadableLogChannel> reader =\n                                                new VersionAwareLogEntryReader( CommandReaderFactory.DEFAULT );\n                                        LogEntry entry;\n                                        while ( (entry = reader.readLogEntry( channel )) != null )\n                                        {\n                                            if ( entry instanceof LogEntryStart )\n                                            {\n                                                return ((LogEntryStart) entry).getTimeWritten();\n                                            }\n                                        }\n                                    }\n                                    return -1;\n                                }\n                            }) );\n\n            LogPruneStrategy logPruneStrategy = LogPruneStrategyFactory.fromConfigValue( fs, logFileInformation,\n                    logFiles, neoStore, config.get( GraphDatabaseSettings.keep_logical_logs ) );\n\n            final TransactionRepresentationStoreApplier storeApplier = dependencies.satisfyDependency( new\n                    TransactionRepresentationStoreApplier(\n                    indexingService, labelScanStore, neoStore,\n                    cacheAccess, lockService, legacyIndexProviderLookup, indexConfigStore ) );\n\n            RecoveryVisitor recoveryVisitor = new RecoveryVisitor( neoStore, storeApplier, recoveredCount );\n            Visitor<ReadableLogChannel, IOException> logFileRecoverer =\n                    new LogFileRecoverer( logEntryReader, recoveryVisitor );\n            logFile = dependencies.satisfyDependency( new PhysicalLogFile( fs, logFiles,\n                    config.get( GraphDatabaseSettings.logical_log_rotation_threshold ), logPruneStrategy, neoStore,\n                    neoStore, new PhysicalLogFile.LoggingMonitor( logging.getMessagesLog( getClass() ) ),\n                    this, transactionMetadataCache, logFileRecoverer ) );\n\n            final LogicalTransactionStore logicalTransactionStore = dependencies.satisfyDependency(\n                    LogicalTransactionStore.class, new PhysicalLogicalTransactionStore( logFile, txIdGenerator,\n                            transactionMetadataCache, logEntryReader, neoStore ));\n\n            TransactionCommitProcess transactionCommitProcess = dependencies.satisfyDependency( TransactionCommitProcess.class,\n                                        commitProcessFactory.create( logicalTransactionStore, kernelHealth,\n                                                neoStore, storeApplier,\n                                                new NeoStoreInjectedTransactionValidator( integrityValidator ), false ));\n\n            /*\n             * This is used by legacy indexes and constraint indexes whenever a transaction is to be spawned\n             * from within an existing transaction. It smells, and we should look over alternatives when time permits.\n             */\n            Provider<KernelAPI> kernelProvider = new Provider<KernelAPI>()\n            {\n                @Override\n                public KernelAPI instance()\n                {\n                    return kernel;\n                }\n            };\n\n            ConstraintIndexCreator constraintIndexCreator = new ConstraintIndexCreator( kernelProvider, indexingService);\n\n            LegacyIndexStore legacyIndexStore = new LegacyIndexStore( config, indexConfigStore, kernelProvider,\n                    legacyIndexProviderLookup );\n\n            StatementOperationParts statementOperations = buildStatementOperations( storeLayer, legacyPropertyTrackers,\n                    constraintIndexCreator, updateableSchemaState, guard, legacyIndexStore );\n\n            kernelTransactions = life.add(new KernelTransactions( neoStoreTransactionContextSupplier,\n                    neoStore, locks, integrityValidator, constraintIndexCreator, indexingService, labelScanStore,\n                    statementOperations, updateableSchemaState, schemaWriteGuard, providerMap,\n                    transactionHeaderInformationFactory, persistenceCache, storeLayer, transactionCommitProcess, indexConfigStore,\n                    legacyIndexProviderLookup, hooks, transactionMonitor, life, readOnly ));\n\n            kernel = new Kernel( statisticsService, kernelTransactions, hooks, kernelHealth, transactionMonitor );\n\n            life.add( logFile );\n            life.add( logicalTransactionStore );\n            life.add( new LifecycleAdapter()\n            {\n                @Override\n                public void start() throws Throwable\n                {\n                    startupStatistics.setNumberOfRecoveredTransactions( recoveredCount.get() );\n                    recoveredCount.set( 0 );\n                    loadSchemaCache();\n                }\n            } );\n            life.add( statisticsService );\n            life.add( indexingService );\n            life.add( labelScanStore );\n\n            // ENDS HERE\n\n            kernel.registerTransactionHook( transactionEventHandlers );\n            neoStore.setRecoveredStatus( true );\n            try\n            {\n                life.start();\n            }\n            finally\n            {\n                neoStore.setRecoveredStatus( false );\n            }\n\n            neoStore.makeStoreOk();\n\n            propertyKeyTokenHolder.addTokens( ((TokenStore<?>) neoStore.getPropertyKeyTokenStore())\n                    .getTokens( Integer.MAX_VALUE ) );\n            relationshipTypeTokens.addTokens( ((TokenStore<?>) neoStore.getRelationshipTypeTokenStore())\n                    .getTokens( Integer.MAX_VALUE ) );\n            labelTokens.addTokens( ((TokenStore<?>) neoStore.getLabelTokenStore()).getTokens( Integer.MAX_VALUE ) );\n        }\n        catch ( Throwable e )\n        { // Something unexpected happened during startup\n            try\n            { // Close the neostore, so that locks are released properly\n                neoStore.close();\n            }\n            catch ( Exception closeException )\n            {\n                msgLog.logMessage( \"Couldn't close neostore after startup failure\" );\n            }\n            throw Exceptions.launderedException( e );\n        }\n    }","id":98065,"modified_method":"@Override\n    public void start() throws IOException\n    {\n        life = new LifeSupport();\n        readOnly = config.get( Configuration.read_only );\n        storeDir = config.get( Configuration.store_dir );\n        File store = config.get( Configuration.neo_store );\n        if ( !storeFactory.storeExists() )\n        {\n            storeFactory.createNeoStore().close();\n        }\n        indexProvider = dependencyResolver.resolveDependency( SchemaIndexProvider.class,\n                SchemaIndexProvider.HIGHEST_PRIORITIZED_OR_NONE );\n        storeMigrationProcess.addParticipant( indexProvider.storeMigrationParticipant() );\n        // TODO: Build a real provider map\n        final DefaultSchemaIndexProviderMap providerMap = new DefaultSchemaIndexProviderMap( indexProvider );\n        storeMigrationProcess.migrateIfNeeded( store.getParentFile() );\n        neoStore = dependencies.satisfyDependency( storeFactory.newNeoStore( false ) );\n        dependencies.satisfyDependency( TransactionIdStore.class, neoStore );\n\n        schemaCache = new SchemaCache( Collections.<SchemaRule>emptyList() );\n\n        nodeCache = new AutoLoadingCache<>(\n                cacheProvider.node(), nodeLoader( neoStore.getNodeStore() ) );\n        relationshipCache = new AutoLoadingCache<>(\n                cacheProvider.relationship(),\n                relationshipLoader( neoStore.getRelationshipStore() ) );\n        RelationshipLoader relationshipLoader = new RelationshipLoader( relationshipCache, new RelationshipChainLoader(\n                neoStore ) );\n        PersistenceCache persistenceCache = new PersistenceCache( nodeCache, relationshipCache, nodeManager,\n                relationshipLoader, propertyKeyTokenHolder, relationshipTypeTokens, labelTokens );\n        CacheAccessBackDoor cacheAccess = new BridgingCacheAccess( schemaCache, updateableSchemaState,\n                persistenceCache );\n        try\n        {\n            indexingService = new IndexingService( scheduler, providerMap, new NeoStoreIndexStoreView(\n                    lockService, neoStore ), tokenNameLookup, updateableSchemaState, indexRuleLoader(), logging,\n                    indexingServiceMonitor ); // TODO 2.2-future What index rules should be\n            final IntegrityValidator integrityValidator = new IntegrityValidator( neoStore, indexingService );\n            labelScanStore = dependencyResolver.resolveDependency( LabelScanStoreProvider.class,\n                    LabelScanStoreProvider.HIGHEST_PRIORITIZED ).getLabelScanStore();\n            fileListing = new NeoStoreFileListing( storeDir, labelScanStore, indexingService,\n                    legacyIndexProviderLookup );\n            Provider<NeoStore> neoStoreProvider = new Provider<NeoStore>()\n            {\n                @Override\n                public NeoStore instance()\n                {\n                    return getNeoStore();\n                }\n            };\n            storeLayer = new CacheLayer( new DiskLayer( propertyKeyTokenHolder, labelTokens, relationshipTypeTokens,\n                    new SchemaStorage( neoStore.getSchemaStore() ), neoStoreProvider, indexingService ),\n                    persistenceCache, indexingService, schemaCache );\n\n            // CHANGE STARTS HERE\n            VersionAwareLogEntryReader logEntryReader =\n                    new VersionAwareLogEntryReader( CommandReaderFactory.DEFAULT );\n            // Recovery process ties log and commit process together\n\n            LegacyPropertyTrackers legacyPropertyTrackers = new LegacyPropertyTrackers( propertyKeyTokenHolder,\n                    nodeManager.getNodePropertyTrackers(), nodeManager.getRelationshipPropertyTrackers(), nodeManager );\n            StatisticsService statisticsService =\n                    new StatisticsServiceRepository( fs, config, storeLayer, scheduler ).loadStatistics();\n            final NeoStoreTransactionContextSupplier neoStoreTransactionContextSupplier =\n                    new NeoStoreTransactionContextSupplier( neoStore );\n\n            final TransactionHooks hooks = new TransactionHooks();\n            File directory = config.get( GraphDatabaseSettings.store_dir );\n            TransactionMetadataCache transactionMetadataCache = new TransactionMetadataCache( 1000, 100_000 );\n            PhysicalLogFiles logFiles = new PhysicalLogFiles( directory, PhysicalLogFile.DEFAULT_NAME, fs );\n\n            LogFileInformation logFileInformation = dependencies.satisfyDependency( LogFileInformation.class,\n                    new PhysicalLogFileInformation( logFiles, transactionMetadataCache, neoStore,\n                            new PhysicalLogFileInformation.SPI()\n                            {\n                                @Override\n                                public long getTimestampForVersion( long version ) throws IOException\n                                {\n\n                                    try ( ReadableLogChannel channel = logFile.getReader(\n                                            new LogPosition( version, VersionAwareLogEntryReader.LOG_HEADER_SIZE ) ) )\n                                    {\n                                        LogEntryReader<ReadableLogChannel> reader =\n                                                new VersionAwareLogEntryReader( CommandReaderFactory.DEFAULT );\n                                        LogEntry entry;\n                                        while ( (entry = reader.readLogEntry( channel )) != null )\n                                        {\n                                            if ( entry instanceof LogEntryStart )\n                                            {\n                                                return ((LogEntryStart) entry).getTimeWritten();\n                                            }\n                                        }\n                                    }\n                                    return -1;\n                                }\n                            }) );\n\n            LogPruneStrategy logPruneStrategy = LogPruneStrategyFactory.fromConfigValue( fs, logFileInformation,\n                    logFiles, neoStore, config.get( GraphDatabaseSettings.keep_logical_logs ) );\n\n            final TransactionRepresentationStoreApplier storeApplier = dependencies.satisfyDependency( new\n                    TransactionRepresentationStoreApplier(\n                    indexingService, labelScanStore, neoStore,\n                    cacheAccess, lockService, legacyIndexProviderLookup, indexConfigStore ) );\n\n            RecoveryVisitor recoveryVisitor = new RecoveryVisitor( neoStore, storeApplier, recoveredCount );\n            Visitor<ReadableLogChannel, IOException> logFileRecoverer =\n                    new LogFileRecoverer( logEntryReader, recoveryVisitor );\n            logFile = dependencies.satisfyDependency( new PhysicalLogFile( fs, logFiles,\n                    config.get( GraphDatabaseSettings.logical_log_rotation_threshold ), logPruneStrategy, neoStore,\n                    neoStore, new PhysicalLogFile.LoggingMonitor( logging.getMessagesLog( getClass() ) ),\n                    this, transactionMetadataCache, logFileRecoverer ) );\n\n            final LogicalTransactionStore logicalTransactionStore = dependencies.satisfyDependency(\n                    LogicalTransactionStore.class, new PhysicalLogicalTransactionStore( logFile, txIdGenerator,\n                            transactionMetadataCache, logEntryReader, neoStore ));\n\n            TransactionCommitProcess transactionCommitProcess = dependencies.satisfyDependency( TransactionCommitProcess.class,\n                                        commitProcessFactory.create( logicalTransactionStore, kernelHealth,\n                                                neoStore, storeApplier,\n                                                new NeoStoreInjectedTransactionValidator( integrityValidator ), false ));\n\n            /*\n             * This is used by legacy indexes and constraint indexes whenever a transaction is to be spawned\n             * from within an existing transaction. It smells, and we should look over alternatives when time permits.\n             */\n            Provider<KernelAPI> kernelProvider = new Provider<KernelAPI>()\n            {\n                @Override\n                public KernelAPI instance()\n                {\n                    return kernel;\n                }\n            };\n\n            ConstraintIndexCreator constraintIndexCreator = new ConstraintIndexCreator( kernelProvider, indexingService);\n\n            LegacyIndexStore legacyIndexStore = new LegacyIndexStore( config, indexConfigStore, kernelProvider,\n                    legacyIndexProviderLookup );\n\n            StatementOperationParts statementOperations = buildStatementOperations( storeLayer, legacyPropertyTrackers,\n                    constraintIndexCreator, updateableSchemaState, guard, legacyIndexStore );\n\n            kernelTransactions = life.add(new KernelTransactions( neoStoreTransactionContextSupplier,\n                    neoStore, locks, integrityValidator, constraintIndexCreator, indexingService, labelScanStore,\n                    statementOperations, updateableSchemaState, schemaWriteGuard, providerMap,\n                    transactionHeaderInformationFactory, persistenceCache, storeLayer, transactionCommitProcess, indexConfigStore,\n                    legacyIndexProviderLookup, hooks, transactionMonitor, life, readOnly ));\n\n            kernel = new Kernel( statisticsService, kernelTransactions, hooks, kernelHealth, transactionMonitor );\n\n            life.add( logFile );\n            life.add( logicalTransactionStore );\n            life.add( new LifecycleAdapter()\n            {\n                @Override\n                public void start() throws Throwable\n                {\n                    startupStatistics.setNumberOfRecoveredTransactions( recoveredCount.get() );\n                    recoveredCount.set( 0 );\n                    loadSchemaCache();\n                }\n            } );\n            life.add( statisticsService );\n            life.add( new LifecycleAdapter()\n            {\n                public void start()\n                {\n                    neoStore.makeStoreOk();\n                }\n            } );\n            life.add( indexingService );\n            life.add( labelScanStore );\n\n            // ENDS HERE\n\n            kernel.registerTransactionHook( transactionEventHandlers );\n            neoStore.setRecoveredStatus( true );\n            try\n            {\n                life.start();\n            }\n            finally\n            {\n                neoStore.setRecoveredStatus( false );\n            }\n\n            propertyKeyTokenHolder.addTokens( neoStore.getPropertyKeyTokenStore().getTokens( Integer.MAX_VALUE ) );\n            relationshipTypeTokens.addTokens( neoStore.getRelationshipTypeTokenStore().getTokens( Integer.MAX_VALUE ) );\n            labelTokens.addTokens( neoStore.getLabelTokenStore().getTokens( Integer.MAX_VALUE ) );\n        }\n        catch ( Throwable e )\n        { // Something unexpected happened during startup\n            try\n            { // Close the neostore, so that locks are released properly\n                neoStore.close();\n            }\n            catch ( Exception closeException )\n            {\n                msgLog.logMessage( \"Couldn't close neostore after startup failure\" );\n            }\n            throw Exceptions.launderedException( e );\n        }\n    }","commit_id":"47674560f3446834d25e81227006d97edd45f5c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean execute(final ReferencesSearch.SearchParameters queryParameters, final Processor<PsiReference> consumer) {\n    final PsiElement refElement = queryParameters.getElementToSearch();\n    if (!(refElement instanceof PsiMethod)) return true;\n    PsiMethod method = (PsiMethod)refElement;\n    final String propertyName = PropertyUtil.getPropertyName(method);\n    if (propertyName != null) {\n      SearchScope searchScope = ApplicationManager.getApplication().runReadAction(new Computable<SearchScope>() {\n        public SearchScope compute() {\n          SearchScope searchScope = queryParameters.getEffectiveSearchScope();\n          if (searchScope instanceof GlobalSearchScope) {\n            searchScope = GlobalSearchScope.getScopeRestrictedByFileTypes((GlobalSearchScope)searchScope,\n                                                                          StdFileTypes.JSP,\n                                                                          StdFileTypes.JSPX,\n                                                                          StdFileTypes.XML,\n                                                                          StdFileTypes.XHTML);\n          }\n          return searchScope;\n        }\n      });\n\n      final PsiSearchHelper helper = PsiManager.getInstance(refElement.getProject()).getSearchHelper();\n      final TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n        public boolean execute(PsiElement element, int offsetInElement) {\n          final PsiReference[] refs = element.getReferences();\n          for (PsiReference ref : refs) {\n            if (ref.getRangeInElement().contains(offsetInElement)) {\n              if (ref.isReferenceTo(refElement)) {\n                return consumer.process(ref);\n              }\n            }\n          }\n          return true;\n        }\n      };\n\n      if (!helper.processElementsWithWord(processor,\n                                          searchScope,\n                                          propertyName,\n                                          UsageSearchContext.IN_FOREIGN_LANGUAGES,\n                                          false)) {\n        return false;\n      }\n    }\n    return true;\n  }","id":98066,"modified_method":"public boolean execute(final ReferencesSearch.SearchParameters queryParameters, final Processor<PsiReference> consumer) {\n    final PsiElement refElement = queryParameters.getElementToSearch();\n    if (!(refElement instanceof PsiMethod)) return true;\n    PsiMethod method = (PsiMethod)refElement;\n    final String propertyName = PropertyUtil.getPropertyName(method);\n    if (StringUtil.isEmptyOrSpaces(propertyName)) {\n      return true;\n    }\n    SearchScope searchScope = ApplicationManager.getApplication().runReadAction(new Computable<SearchScope>() {\n      public SearchScope compute() {\n        SearchScope searchScope = queryParameters.getEffectiveSearchScope();\n        if (searchScope instanceof GlobalSearchScope) {\n          searchScope = GlobalSearchScope.getScopeRestrictedByFileTypes((GlobalSearchScope)searchScope,\n                                                                        StdFileTypes.JSP,\n                                                                        StdFileTypes.JSPX,\n                                                                        StdFileTypes.XML,\n                                                                        StdFileTypes.XHTML);\n        }\n        return searchScope;\n      }\n    });\n\n    final PsiSearchHelper helper = PsiManager.getInstance(refElement.getProject()).getSearchHelper();\n    final TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        final PsiReference[] refs = element.getReferences();\n        for (PsiReference ref : refs) {\n          if (ref.getRangeInElement().contains(offsetInElement)) {\n            if (ref.isReferenceTo(refElement)) {\n              return consumer.process(ref);\n            }\n          }\n        }\n        return true;\n      }\n    };\n\n    return helper.processElementsWithWord(processor, searchScope, propertyName, UsageSearchContext.IN_FOREIGN_LANGUAGES, false);\n  }","commit_id":"4c227adeef1a984babf243ad5c9feb91ed1cd6cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean execute(final ReferencesSearch.SearchParameters p, final Processor<PsiReference> consumer) {\n    final PsiElement refElement = p.getElementToSearch();\n\n    String text = null;\n\n    if (refElement instanceof XmlAttributeValue) {\n      text = ((XmlAttributeValue)refElement).getValue();\n    }\n    else if (refElement instanceof PsiFile) {\n      final VirtualFile vFile = ((PsiFile)refElement).getVirtualFile();\n      if (vFile != null) {\n        text = vFile.getNameWithoutExtension();\n      }\n    }\n    else if (refElement instanceof PsiNamedElement) {\n      text = ((PsiNamedElement)refElement).getName();\n      if (refElement instanceof PsiMetaBaseOwner) {\n        final PsiMetaDataBase metaData = ((PsiMetaBaseOwner)refElement).getMetaData();\n        if (metaData != null) text = metaData.getName();\n      }\n    }\n\n    if (text == null && refElement instanceof PsiMetaBaseOwner) {\n      final PsiMetaDataBase metaData = ((PsiMetaBaseOwner)refElement).getMetaData();\n      if (metaData != null) text = metaData.getName();\n    }\n\n    if (StringUtil.isEmpty(text)) return true;\n\n    SearchScope searchScope = p.getEffectiveSearchScope();\n    final TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        final PsiReference[] refs = element.getReferences();\n        for (PsiReference ref : refs) {\n          if (ref.getRangeInElement().contains(offsetInElement)) {\n            if (ref.isReferenceTo(refElement)) {\n              return consumer.process(ref);\n            }\n          }\n        }\n        return true;\n      }\n    };\n\n    short searchContext;\n    if (refElement instanceof XmlEntityDecl) {\n      searchContext = UsageSearchContext.IN_PLAIN_TEXT;\n    }\n    else {\n      searchContext = UsageSearchContext.IN_CODE |\n                      UsageSearchContext.IN_FOREIGN_LANGUAGES |\n                      UsageSearchContext.IN_COMMENTS;\n    }\n\n    final PsiSearchHelper helper = PsiManager.getInstance(refElement.getProject()).getSearchHelper();\n\n    if (!helper.processElementsWithWord(processor,\n                                        searchScope,\n                                        text,\n                                        searchContext,\n                                        refElement.getLanguage() == StdLanguages.JAVA  //todo: temporary hack!!\n    )) {\n      return false;\n    }\n\n    return true;\n  }","id":98067,"modified_method":"public boolean execute(final ReferencesSearch.SearchParameters p, final Processor<PsiReference> consumer) {\n    final PsiElement refElement = p.getElementToSearch();\n\n    String text = null;\n\n    if (refElement instanceof XmlAttributeValue) {\n      text = ((XmlAttributeValue)refElement).getValue();\n    }\n    else if (refElement instanceof PsiFile) {\n      final VirtualFile vFile = ((PsiFile)refElement).getVirtualFile();\n      if (vFile != null) {\n        text = vFile.getNameWithoutExtension();\n      }\n    }\n    else if (refElement instanceof PsiNamedElement) {\n      text = ((PsiNamedElement)refElement).getName();\n      if (refElement instanceof PsiMetaBaseOwner) {\n        final PsiMetaDataBase metaData = ((PsiMetaBaseOwner)refElement).getMetaData();\n        if (metaData != null) text = metaData.getName();\n      }\n    }\n\n    if (text == null && refElement instanceof PsiMetaBaseOwner) {\n      final PsiMetaDataBase metaData = ((PsiMetaBaseOwner)refElement).getMetaData();\n      if (metaData != null) text = metaData.getName();\n    }\n\n    if (StringUtil.isEmpty(text)) return true;\n      \n    SearchScope searchScope = p.getEffectiveSearchScope();\n    final TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        final PsiReference[] refs = element.getReferences();\n        for (PsiReference ref : refs) {\n          if (ref.getRangeInElement().contains(offsetInElement)) {\n            if (ref.isReferenceTo(refElement)) {\n              return consumer.process(ref);\n            }\n          }\n        }\n        return true;\n      }\n    };\n\n    short searchContext;\n    if (refElement instanceof XmlEntityDecl) {\n      searchContext = UsageSearchContext.IN_PLAIN_TEXT;\n    }\n    else {\n      searchContext = UsageSearchContext.IN_CODE |\n                      UsageSearchContext.IN_FOREIGN_LANGUAGES |\n                      UsageSearchContext.IN_COMMENTS;\n    }\n\n    final PsiSearchHelper helper = PsiManager.getInstance(refElement.getProject()).getSearchHelper();\n\n    return helper.processElementsWithWord(processor, searchScope, text, searchContext, \n                                          refElement.getLanguage() == StdLanguages.JAVA //todo: temporary hack!!\n    );\n\n  }","commit_id":"a1ce9a69654bbd322442fe835ac5c5f571076f6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Lookup showLookup(\n      final Editor editor,\n      LookupItem[] items,\n      String prefix,\n      LookupItemPreferencePolicy itemPreferencePolicy,\n      CharFilter filter\n      ) {\n    hideActiveLookup();\n\n    final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n    items = items.clone();\n    if (!settings.SHOW_SIGNATURES_IN_LOOKUPS){\n      items = filterEqualSignatures(items);\n    }\n\n    final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(editor.getDocument());\n\n    if (sortItems(psiFile, items)) {\n      Arrays.sort(items, COMPARATOR);\n    }\n\n    final Alarm alarm = new Alarm();\n    final Runnable request = new Runnable(){\n      public void run() {\n        JavaDocManager.getInstance(myProject).showJavaDocInfo(editor, psiFile, false);\n      }\n    };\n    if (settings.AUTO_POPUP_JAVADOC_INFO){\n      alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n    }\n\n    final DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(myProject);\n    if (daemonCodeAnalyzer != null) {\n      daemonCodeAnalyzer.setUpdateByTimerEnabled(false);\n    }\n    myActiveLookup = new LookupImpl(myProject, editor, items, prefix, itemPreferencePolicy, filter);\n    myActiveLookupEditor = editor;\n    ((LookupImpl)myActiveLookup).show();\n    myActiveLookup.addLookupListener(\n      new LookupAdapter(){\n        public void itemSelected(LookupEvent event) {\n          dispose();\n        }\n\n        public void lookupCanceled(LookupEvent event) {\n          dispose();\n        }\n\n        public void currentItemChanged(LookupEvent event) {\n          alarm.cancelAllRequests();\n          if (settings.AUTO_POPUP_JAVADOC_INFO){\n            alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n          }\n        }\n\n        private void dispose(){\n          if (myActiveLookup == null) return;\n          alarm.cancelAllRequests();\n          if (daemonCodeAnalyzer != null) {\n            daemonCodeAnalyzer.setUpdateByTimerEnabled(true);\n          }\n          myActiveLookup.removeLookupListener(this);\n          Lookup lookup = myActiveLookup;\n          myActiveLookup = null;\n          myActiveLookupEditor = null;\n          myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, lookup, myActiveLookup);\n        }\n      }\n    );\n    myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, null, myActiveLookup);\n    return myActiveLookup;\n  }","id":98068,"modified_method":"public Lookup showLookup(\n      final Editor editor,\n      LookupItem[] items,\n      String prefix,\n      LookupItemPreferencePolicy itemPreferencePolicy,\n      CharFilter filter\n      ) {\n    hideActiveLookup();\n\n    final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n    items = items.clone();\n    if (!settings.SHOW_SIGNATURES_IN_LOOKUPS){\n      items = filterEqualSignatures(items);\n    }\n\n    final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(editor.getDocument());\n\n    if (sortItems(psiFile, items)) {\n      Arrays.sort(items, COMPARATOR);\n    }\n\n    final Alarm alarm = new Alarm();\n    final Runnable request = new Runnable(){\n      public void run() {\n        JavaDocManager.getInstance(myProject).showJavaDocInfo(editor, psiFile, false);\n      }\n    };\n    if (settings.AUTO_POPUP_JAVADOC_INFO){\n      alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n    }\n\n    final DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(myProject);\n    if (daemonCodeAnalyzer != null) {\n      daemonCodeAnalyzer.setUpdateByTimerEnabled(false);\n    }\n    myActiveLookup = new LookupImpl(myProject, editor, items, prefix, itemPreferencePolicy, filter);\n    myActiveLookupEditor = editor;\n    ((LookupImpl)myActiveLookup).show();\n    myActiveLookup.addLookupListener(\n      new LookupAdapter(){\n        public void itemSelected(LookupEvent event) {\n          dispose();\n        }\n\n        public void lookupCanceled(LookupEvent event) {\n          dispose();\n        }\n\n        public void currentItemChanged(LookupEvent event) {\n          alarm.cancelAllRequests();\n          if (settings.AUTO_POPUP_JAVADOC_INFO){\n            alarm.addRequest(request, settings.JAVADOC_INFO_DELAY);\n          }\n        }\n\n        private void dispose(){\n          alarm.cancelAllRequests();\n          if (daemonCodeAnalyzer != null) {\n            daemonCodeAnalyzer.setUpdateByTimerEnabled(true);\n          }\n          if (myActiveLookup == null) return;\n          myActiveLookup.removeLookupListener(this);\n          Lookup lookup = myActiveLookup;\n          myActiveLookup = null;\n          myActiveLookupEditor = null;\n          myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, lookup, myActiveLookup);\n        }\n      }\n    );\n    myPropertyChangeSupport.firePropertyChange(PROP_ACTIVE_LOOKUP, null, myActiveLookup);\n    return myActiveLookup;\n  }","commit_id":"a1ce9a69654bbd322442fe835ac5c5f571076f6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean execute(final MethodReferencesSearch.SearchParameters searchParameters, final Processor<PsiReference> consumer) {\n    final PsiMethod method = searchParameters.getMethod();\n    if (PropertyUtil.isSimplePropertyAccessor(method)) {\n      final String propertyName = PropertyUtil.getPropertyName(method);\n      assert propertyName != null;\n      SearchScope searchScope = PsiUtil.restrictScopeToGroovyFiles(searchParameters.getScope());\n\n      final PsiSearchHelper helper = PsiManager.getInstance(method.getProject()).getSearchHelper();\n      final TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n        public boolean execute(PsiElement element, int offsetInElement) {\n          final PsiReference[] refs = element.getReferences();\n          for (PsiReference ref : refs) {\n            if (ref.getRangeInElement().contains(offsetInElement)) {\n              if (ref.isReferenceTo(method)) {\n                return consumer.process(ref);\n              }\n            }\n          }\n          return true;\n        }\n      };\n\n      if (!helper.processElementsWithWord(processor,\n          searchScope,\n          propertyName,\n          UsageSearchContext.IN_CODE,\n          false)) {\n        return false;\n      }\n    }\n\n    return true;\n  }","id":98069,"modified_method":"public boolean execute(final MethodReferencesSearch.SearchParameters searchParameters, final Processor<PsiReference> consumer) {\n    final PsiMethod method = searchParameters.getMethod();\n    final String propertyName = getPropertyName(method);\n    if (propertyName == null) return true;\n\n    SearchScope searchScope = PsiUtil.restrictScopeToGroovyFiles(searchParameters.getScope());\n\n    final PsiSearchHelper helper = PsiManager.getInstance(method.getProject()).getSearchHelper();\n    final TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        final PsiReference[] refs = element.getReferences();\n        for (PsiReference ref : refs) {\n          if (ref.getRangeInElement().contains(offsetInElement)) {\n            if (ref.isReferenceTo(method)) {\n              return consumer.process(ref);\n            }\n          }\n        }\n        return true;\n      }\n    };\n\n    return helper.processElementsWithWord(processor,\n        searchScope,\n        propertyName,\n        UsageSearchContext.IN_CODE,\n        false);\n  }","commit_id":"f274cddc72f394150faa9deedaaa262b77200435","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Create a new hierarchical microscheduler to process the given reads and reference.\n     * @param reads Reads file(s) to process.\n     * @param refFile Reference for driving the traversal.\n     * @param nThreadsToUse maximum number of threads to use to do the work\n     */\n    protected HierarchicalMicroScheduler( List<File> reads, File refFile, List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods, int nThreadsToUse ) {\n        super( reads, refFile );\n\n\n        this.threadPool = Executors.newFixedThreadPool(nThreadsToUse);        \n        traversalEngine = new TraverseLociByReference( reads, refFile, rods );\n    }","id":98070,"modified_method":"/**\n     * Create a new hierarchical microscheduler to process the given reads and reference.\n     * @param reads Reads file(s) to process.\n     * @param refFile Reference for driving the traversal.\n     * @param nThreadsToUse maximum number of threads to use to do the work\n     */\n    protected HierarchicalMicroScheduler( Walker walker, List<File> reads, File refFile, List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods, int nThreadsToUse ) {\n        super( walker, reads, refFile, rods );\n        this.threadPool = Executors.newFixedThreadPool(nThreadsToUse);\n        if( !(traversalEngine instanceof TraverseLociByReference) )\n            throw new UnsupportedOperationException(\"Traversal engine supports only traverse loci by reference at this time.\");\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void execute( Walker walker, List<GenomeLoc> intervals ) {\n        // Fast fail for walkers not supporting TreeReducible interface.\n        if( !(walker instanceof TreeReducible) )\n            throw new IllegalArgumentException(\"Hierarchical microscheduler only works with TreeReducible walkers\");\n\n        ShardStrategy shardStrategy = getShardStrategy( reference, intervals );\n        SAMDataSource dataSource = getReadsDataSource();\n\n        ReduceTree reduceTree = new ReduceTree( this );        \n\n        walker.initialize();\n        \n        for(Shard shard: shardStrategy)\n            traverseTasks.add(shard);\n\n        while( isShardTraversePending() || isTreeReducePending() ) {\n            // Too many files sitting around taking up space?  Merge them.\n            if( isMergeLimitExceeded() )\n                mergeExistingOutput();\n\n            // Wait for the next slot in the queue to become free.\n            waitForFreeQueueSlot();\n\n            // Pick the next most appropriate task and run it.  In the interest of\n            // memory conservation, hierarchical reduces always run before traversals.\n            if( isTreeReduceReady() )\n                queueNextTreeReduce( walker );\n            else if( isShardTraversePending() )\n                queueNextShardTraverse( walker, dataSource, reduceTree );\n        }\n\n        // Merge any lingering output files.  If these files aren't ready,\n        // sit around and wait for them, then merge them.\n        mergeRemainingOutput();\n\n        threadPool.shutdown();\n\n        Object result = null;\n        try {\n            result = reduceTree.getResult().get();\n        }\n        catch(Exception ex) {\n            throw new StingException(\"Unable to retrieve result\", ex );\n        }\n        \n        traversalEngine.printOnTraversalDone(result);\n        walker.onTraversalDone(result);\n    }","id":98071,"modified_method":"public void execute( Walker walker, List<GenomeLoc> intervals ) {\n        // Fast fail for walkers not supporting TreeReducible interface.\n        if( !(walker instanceof TreeReducible) )\n            throw new IllegalArgumentException(\"Hierarchical microscheduler only works with TreeReducible walkers\");\n\n        ShardStrategy shardStrategy = getShardStrategy( reference, intervals );\n        ReduceTree reduceTree = new ReduceTree( this );        \n\n        walker.initialize();\n        \n        for(Shard shard: shardStrategy)\n            traverseTasks.add(shard);\n\n        while( isShardTraversePending() || isTreeReducePending() ) {\n            // Too many files sitting around taking up space?  Merge them.\n            if( isMergeLimitExceeded() )\n                mergeExistingOutput();\n\n            // Wait for the next slot in the queue to become free.\n            waitForFreeQueueSlot();\n\n            // Pick the next most appropriate task and run it.  In the interest of\n            // memory conservation, hierarchical reduces always run before traversals.\n            if( isTreeReduceReady() )\n                queueNextTreeReduce( walker );\n            else if( isShardTraversePending() )\n                queueNextShardTraverse( walker, reduceTree );\n        }\n\n        // Merge any lingering output files.  If these files aren't ready,\n        // sit around and wait for them, then merge them.\n        mergeRemainingOutput();\n\n        threadPool.shutdown();\n\n        Object result = null;\n        try {\n            result = reduceTree.getResult().get();\n        }\n        catch(Exception ex) {\n            throw new StingException(\"Unable to retrieve result\", ex );\n        }\n        \n        traversalEngine.printOnTraversalDone(result);\n        walker.onTraversalDone(result);\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Queues the next traversal of a walker from the traversal tasks queue.\n     * @param walker Walker to apply to the dataset.\n     * @param dataSource Source of the reads\n     */\n    protected Future queueNextShardTraverse( Walker walker, SAMDataSource dataSource, ReduceTree reduceTree ) {\n        if( traverseTasks.size() == 0 )\n            throw new IllegalStateException( \"Cannot traverse; no pending traversals exist.\");\n\n        OutputMerger outputMerger = new OutputMerger();\n\n        ShardTraverser traverser = new ShardTraverser( traversalEngine,\n                                                       walker,\n                                                       traverseTasks.remove(),\n                                                       reference,\n                                                       dataSource,\n                                                       outputMerger );\n\n        Future traverseResult = threadPool.submit(traverser);\n\n        // Add this traverse result to the reduce tree.  The reduce tree will call a callback to throw its entries on the queue.\n        reduceTree.addEntry( traverseResult );\n\n        // No more data?  Let the reduce tree know so it can finish processing what it's got.\n        if( !isShardTraversePending() )\n            reduceTree.complete();\n\n        outputMergeTasks.add(outputMerger);        \n\n        return traverseResult;\n    }","id":98072,"modified_method":"/**\n     * Queues the next traversal of a walker from the traversal tasks queue.\n     * @param walker Walker to apply to the dataset.\n     * @param reduceTree Tree of reduces to which to add this shard traverse.\n     */\n    protected Future queueNextShardTraverse( Walker walker, ReduceTree reduceTree ) {\n        if( traverseTasks.size() == 0 )\n            throw new IllegalStateException( \"Cannot traverse; no pending traversals exist.\");\n\n        Shard shard = traverseTasks.remove();\n        OutputMerger outputMerger = new OutputMerger();\n\n        ShardTraverser traverser = new ShardTraverser( traversalEngine,\n                                                       walker,\n                                                       shard,\n                                                       getShardDataProvider(shard),\n                                                       outputMerger );\n\n        Future traverseResult = threadPool.submit(traverser);\n\n        // Add this traverse result to the reduce tree.  The reduce tree will call a callback to throw its entries on the queue.\n        reduceTree.addEntry( traverseResult );\n\n        // No more data?  Let the reduce tree know so it can finish processing what it's got.\n        if( !isShardTraversePending() )\n            reduceTree.complete();\n\n        outputMergeTasks.add(outputMerger);        \n\n        return traverseResult;\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Run this traversal over the specified subsection of the dataset.\n     *\n     * @param walker    Computation to perform over dataset.\n     * @param locations Subset of the dataset over which to walk.\n     */\n    public void execute(Walker walker, List<GenomeLoc> locations) {\n        ShardStrategy shardStrategy = getShardStrategy(reference, locations);\n        SAMDataSource dataSource = getReadsDataSource();\n\n        walker.initialize();\n        Object accumulator = walker.reduceInit();\n\n        for (Shard shard : shardStrategy) {\n\n            StingSAMIterator readShard = dataSource.seek(shard);\n\n            ReferenceProvider referenceProvider = new ReferenceProvider(reference, shard);\n            LocusContextProvider locusProvider = new LocusContextProvider(readShard);\n\n            if (!isAReadWalker) {\n                accumulator = ((TraverseLociByReference) traversalEngine).traverse(walker, shard, referenceProvider, locusProvider, accumulator);\n            } else {\n                accumulator = ((TraverseReads) traversalEngine).traverse(walker, shard, readShard, accumulator);\n            }\n\n            readShard.close();\n        }\n\n        traversalEngine.printOnTraversalDone(accumulator);\n\n        walker.onTraversalDone(accumulator);\n    }","id":98073,"modified_method":"/**\n     * Run this traversal over the specified subsection of the dataset.\n     *\n     * @param walker    Computation to perform over dataset.\n     * @param locations Subset of the dataset over which to walk.\n     */\n    public void execute(Walker walker, List<GenomeLoc> locations) {\n        ShardStrategy shardStrategy = getShardStrategy(reference, locations);\n\n        walker.initialize();\n        Object accumulator = walker.reduceInit();\n\n        for (Shard shard : shardStrategy) {\n            ShardDataProvider dataProvider = getShardDataProvider( shard );\n            accumulator = traversalEngine.traverse(walker, shard, dataProvider, accumulator);\n            dataProvider.close();\n        }\n\n        traversalEngine.printOnTraversalDone(accumulator);\n\n        walker.onTraversalDone(accumulator);\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new linear microscheduler to process the given reads and reference.\n     *\n     * @param reads   Reads file(s) to process.\n     * @param refFile Reference for driving the traversal.\n     */\n    protected LinearMicroScheduler(List<File> reads, File refFile, List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods, Walker walker) {\n        super(reads, refFile);\n\n        // determine if we're a read walker: they get a slightly different, but not in any way worse execute methodology. I pinky swear...\n        isAReadWalker = (walker instanceof ReadWalker) ? true : false;\n\n        if (isAReadWalker) {\n            traversalEngine = new TraverseByReads(reads, refFile, rods);\n        } else {\n            traversalEngine = new TraverseLociByReference(reads, refFile, rods);\n        }\n    }","id":98074,"modified_method":"/**\n     * Create a new linear microscheduler to process the given reads and reference.\n     *\n     * @param reads   Reads file(s) to process.\n     * @param refFile Reference for driving the traversal.\n     */\n    protected LinearMicroScheduler( Walker walker, List<File> reads, File refFile, List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods ) {\n        super(walker, reads, refFile, rods);\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * MicroScheduler factory function.  Create a microscheduler appropriate for reducing the\n     * selected walker.\n     * @param walker Which walker to use.\n     * @param nThreadsToUse Number of threads to utilize.\n     * @return The best-fit microscheduler.\n     */\n    public static MicroScheduler create( Walker walker, List<File> reads, File ref, List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods, int nThreadsToUse ) {\n        if( walker instanceof TreeReducible && nThreadsToUse > 1 ) {\n            logger.info(\"Creating hierarchical microscheduler\");\n            return new HierarchicalMicroScheduler( reads, ref, rods, nThreadsToUse );\n        }\n        else {\n            logger.info(\"Creating linear microscheduler\");\n            return new LinearMicroScheduler( reads, ref, rods, walker );\n        }\n    }","id":98075,"modified_method":"/**\n     * MicroScheduler factory function.  Create a microscheduler appropriate for reducing the\n     * selected walker.\n     * @param walker Which walker to use.\n     * @param nThreadsToUse Number of threads to utilize.\n     * @return The best-fit microscheduler.\n     */\n    public static MicroScheduler create( Walker walker, List<File> reads, File ref, List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods, int nThreadsToUse ) {\n        if( walker instanceof TreeReducible && nThreadsToUse > 1 ) {\n            logger.info(\"Creating hierarchical microscheduler\");\n            return new HierarchicalMicroScheduler( walker, reads, ref, rods, nThreadsToUse );\n        }\n        else {\n            logger.info(\"Creating linear microscheduler\");\n            return new LinearMicroScheduler( walker, reads, ref, rods );\n        }\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets a data source for the given set of reads.\n     * @return A data source for the given set of reads.\n     */\n    protected SAMDataSource getReadsDataSource() {\n        SAMDataSource dataSource = null;\n        try {\n            dataSource = new SAMDataSource( TraversalEngine.unpackReads(reads) );\n        }\n        catch( SimpleDataSourceLoadException ex ) {\n            throw new RuntimeException( ex );\n        }\n        catch( FileNotFoundException ex ) {\n            throw new RuntimeException( ex );\n        }\n\n        // Side effect: initialize the traversal engine with reads data.\n        // TODO: Give users a dedicated way of getting the header so that the MicroScheduler\n        //       doesn't have to bend over backward providing legacy getters and setters.\n        traversalEngine.setSAMHeader(dataSource.getHeader());\n\n        return dataSource;\n    }","id":98076,"modified_method":"/**\n     * Gets a data source for the given set of reads.\n     * @return A data source for the given set of reads.\n     */\n    private SAMDataSource getReadsDataSource( List<File> reads ) {\n        List<File> unpackedReads = null;\n        try {\n            unpackedReads = TraversalEngine.unpackReads(reads);\n        }\n        catch( FileNotFoundException ex ) {\n            throw new StingException( \"Cannot unpack list of reads files\", ex );\n        }\n\n        SAMDataSource dataSource = new SAMDataSource( unpackedReads );\n\n        // Side effect: initialize the traversal engine with reads data.\n        // TODO: Give users a dedicated way of getting the header so that the MicroScheduler\n        //       doesn't have to bend over backward providing legacy getters and setters.\n        traversalEngine.setSAMHeader(dataSource.getHeader());\n\n        return dataSource;\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ShardTraverser( TraverseLociByReference traversalEngine,\n                           Walker walker,\n                           Shard shard,\n                           IndexedFastaSequenceFile reference,\n                           SAMDataSource reads,\n                           OutputMerger output ) {\n        this.walker = walker;\n        this.traversalEngine = traversalEngine;\n        this.shard = shard;\n        this.reference = reference;\n        this.reads = reads;\n        this.output = output;\n    }","id":98077,"modified_method":"public ShardTraverser( TraverseLociByReference traversalEngine,\n                           Walker walker,\n                           Shard shard,\n                           ShardDataProvider dataProvider,\n                           OutputMerger output ) {\n        this.walker = walker;\n        this.traversalEngine = traversalEngine;\n        this.shard = shard;\n        this.dataProvider = dataProvider;\n        this.output = output;\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Object call() {\n        Object accumulator = walker.reduceInit();\n\n        CloseableIterator<SAMRecord> readShard = null;\n        readShard = reads.seek( shard );\n\n        ReferenceProvider referenceProvider = new ReferenceProvider( reference, shard );\n        LocusContextProvider locusProvider = new LocusContextProvider( readShard );\n\n        OutputTracker outputTracker = GenomeAnalysisTK.Instance.getOutputTracker();\n\n        outputTracker.setLocalStreams( output.getOutStream(), output.getErrStream() );\n        try {\n            accumulator = traversalEngine.traverse( walker, shard, referenceProvider, locusProvider, accumulator );\n        }\n        finally {\n            readShard.close();\n\n            output.complete();\n            outputTracker.removeLocalStreams();            \n        }\n\n        return accumulator;\n    }","id":98078,"modified_method":"public Object call() {\n        Object accumulator = walker.reduceInit();\n        OutputTracker outputTracker = GenomeAnalysisTK.Instance.getOutputTracker();\n        outputTracker.setLocalStreams( output.getOutStream(), output.getErrStream() );\n\n        try {\n            accumulator = traversalEngine.traverse( walker, shard, dataProvider, accumulator );\n        }\n        finally {\n            dataProvider.close();\n            output.complete();\n            outputTracker.removeLocalStreams();            \n        }\n\n        return accumulator;\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * A passthrough method so that subclasses can report which types of traversals they're using.\n     * TODO: Make this method abstract once all traversals support it.\n     * @param sum Result of the computation.\n     * @param <T> Type of the computation.\n     */\n    public <T> void printOnTraversalDone( T sum ) {\n        throw new UnsupportedOperationException( \"This method should be overridden.\" );\n    }","id":98079,"modified_method":"/**\n     * A passthrough method so that subclasses can report which types of traversals they're using.\n     * TODO: Make this method abstract once all traversals support it.\n     * @param sum Result of the computation.\n     * @param <T> Type of the computation.\n     */\n    public <T> void printOnTraversalDone( T sum ) {\n        throw new UnsupportedOperationException( \"This method is a required override for new traversal engines.  Please port your traversal engine to the new style.\" );\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"public <M,T> T traverse( Walker<M,T> walker,\n                             Shard shard,\n                             ReferenceProvider referenceProvider,\n                             LocusContextProvider locusProvider,\n                             T sum ) {\n        logger.debug(String.format(\"TraverseLociByReference.traverse Genomic interval is %s\", shard.getGenomeLoc()));\n\n        if ( !(walker instanceof LocusWalker) )\n            throw new IllegalArgumentException(\"Walker isn't a loci walker!\");\n\n        LocusWalker<M, T> locusWalker = (LocusWalker<M, T>)walker;\n        GenomeLoc loc = shard.getGenomeLoc();\n\n        // We keep processing while the next reference location is within the interval\n        for( long pos = loc.getStart(); pos <= loc.getStop(); pos++ ) {\n            GenomeLoc site = new GenomeLoc( loc.getContig(), pos );\n\n            TraversalStatistics.nRecords++;\n\n            // Iterate forward to get all reference ordered data covering this locus\n            final RefMetaDataTracker tracker = getReferenceOrderedDataAtLocus( site );\n\n            LocusContext locus = locusProvider.getLocusContext( site );\n\n            char refBase = referenceProvider.getReferenceBase( site );\n\n            if ( DOWNSAMPLE_BY_COVERAGE )\n                locus.downsampleToCoverage(downsamplingCoverage);\n\n            final boolean keepMeP = locusWalker.filter(tracker, refBase, locus);\n            if (keepMeP) {\n                M x = locusWalker.map(tracker, refBase, locus);\n                sum = locusWalker.reduce(x, sum);\n            }\n\n            if (this.maxReads > 0 && TraversalStatistics.nRecords > this.maxReads) {\n                logger.warn(String.format(\"Maximum number of reads encountered, terminating traversal \" + TraversalStatistics.nRecords));\n                break;\n            }\n\n            printProgress(\"loci\", locus.getLocation());\n        }\n\n        return sum;\n    }","id":98080,"modified_method":"@Override\n    public <M,T> T traverse( Walker<M,T> walker,\n                             Shard shard,\n                             ShardDataProvider dataProvider,\n                             T sum ) {\n        logger.debug(String.format(\"TraverseLociByReference.traverse Genomic interval is %s\", shard.getGenomeLoc()));\n\n        if ( !(walker instanceof LocusWalker) )\n            throw new IllegalArgumentException(\"Walker isn't a loci walker!\");\n\n        LocusWalker<M, T> locusWalker = (LocusWalker<M, T>)walker;\n        GenomeLoc loc = shard.getGenomeLoc();\n\n        // We keep processing while the next reference location is within the interval\n        for( long pos = loc.getStart(); pos <= loc.getStop(); pos++ ) {\n            GenomeLoc site = new GenomeLoc( loc.getContig(), pos );\n\n            TraversalStatistics.nRecords++;\n\n            // Iterate forward to get all reference ordered data covering this locus\n            final RefMetaDataTracker tracker = getReferenceOrderedDataAtLocus( site );\n\n            LocusContext locus = dataProvider.getLocusContext( site );\n            char refBase = dataProvider.getReferenceBase( site );\n\n            if ( DOWNSAMPLE_BY_COVERAGE )\n                locus.downsampleToCoverage(downsamplingCoverage);\n\n            final boolean keepMeP = locusWalker.filter(tracker, refBase, locus);\n            if (keepMeP) {\n                M x = locusWalker.map(tracker, refBase, locus);\n                sum = locusWalker.reduce(x, sum);\n            }\n\n            if (this.maxReads > 0 && TraversalStatistics.nRecords > this.maxReads) {\n                logger.warn(String.format(\"Maximum number of reads encountered, terminating traversal \" + TraversalStatistics.nRecords));\n                break;\n            }\n\n            printProgress(\"loci\", locus.getLocation());\n        }\n\n        return sum;\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Traverse by reads, given the data and the walker\n     *\n     * @param walker the walker to execute over\n     * @param shard  the shard of data to feed the walker\n     * @param sum    of type T, the return from the walker\n     * @param <M>    the generic type\n     * @param <T>    the return type of the reduce function\n     * @return\n     */\n    public <M, T> T traverse(Walker<M, T> walker,\n                             Shard shard,\n                             StingSAMIterator iter,\n                             T sum) {\n\n        logger.debug(String.format(\"TraverseReads.traverse Genomic interval is %s\", ((ReadShard) shard).getSize()));\n\n        if (!(walker instanceof ReadWalker))\n            throw new IllegalArgumentException(\"Walker isn't a read walker!\");\n\n        ReadWalker<M, T> readWalker = (ReadWalker<M, T>) walker;\n\n        int readCNT = 0;\n\n        // while we still have more reads\n        for (SAMRecord read : iter) {\n\n            // our locus context\n            LocusContext locus = null;\n\n            if (read.getReferenceIndex() >= 0) {\n                // get the genome loc from the read\n                GenomeLoc site = new GenomeLoc(read);\n\n                // Jump forward in the reference to this locus location\n                locus = new LocusContext(site, Arrays.asList(read), Arrays.asList(0));\n            }\n\n            // update the number of reads we've seen\n            TraversalStatistics.nRecords++;\n\n\n            // we still have to fix the locus context provider to take care of this problem with > 1 length contexts\n            // LocusContext locus = locusProvider.getLocusContext(site);\n\n            final boolean keepMeP = readWalker.filter(locus, read);\n            if (keepMeP) {\n                M x = readWalker.map(locus, read);\n                sum = readWalker.reduce(x, sum);\n            }\n\n            if (locus != null) { printProgress(\"loci\", locus.getLocation()); }\n        }\n        //System.err.println(TraversalStatistics.nRecords);\n        return sum;\n    }","id":98081,"modified_method":"/**\n     * Traverse by reads, given the data and the walker\n     *\n     * @param walker the walker to execute over\n     * @param shard  the shard of data to feed the walker\n     * @param sum    of type T, the return from the walker\n     * @param <M>    the generic type\n     * @param <T>    the return type of the reduce function\n     * @return\n     */\n    public <M, T> T traverse(Walker<M, T> walker,\n                             Shard shard,\n                             ShardDataProvider dataProvider,\n                             T sum) {\n\n        logger.debug(String.format(\"TraverseReads.traverse Genomic interval is %s\", ((ReadShard) shard).getSize()));\n\n        if (!(walker instanceof ReadWalker))\n            throw new IllegalArgumentException(\"Walker isn't a read walker!\");\n\n        if( !dataProvider.hasReads() )\n            throw new IllegalArgumentException(\"Unable to traverse reads; no read data is available.\");\n\n        ReadWalker<M, T> readWalker = (ReadWalker<M, T>) walker;\n\n        int readCNT = 0;\n\n        // while we still have more reads\n        for (SAMRecord read : dataProvider.getReadIterator()) {\n\n            // our locus context\n            LocusContext locus = null;\n\n            if (read.getReferenceIndex() >= 0) {\n                // get the genome loc from the read\n                GenomeLoc site = new GenomeLoc(read);\n\n                // Jump forward in the reference to this locus location\n                locus = new LocusContext(site, Arrays.asList(read), Arrays.asList(0));\n            }\n\n            // update the number of reads we've seen\n            TraversalStatistics.nRecords++;\n\n\n            // we still have to fix the locus context provider to take care of this problem with > 1 length contexts\n            // LocusContext locus = locusProvider.getLocusContext(site);\n\n            final boolean keepMeP = readWalker.filter(locus, read);\n            if (keepMeP) {\n                M x = readWalker.map(locus, read);\n                sum = readWalker.reduce(x, sum);\n            }\n\n            if (locus != null) { printProgress(\"loci\", locus.getLocation()); }\n        }\n        //System.err.println(TraversalStatistics.nRecords);\n        return sum;\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Test out that we can shard the file and iterate over every read */\n    @Test\n    public void testUnmappedReadCount() {\n\n        IndexedFastaSequenceFile ref = null;\n        try {\n            ref = new IndexedFastaSequenceFile(refFile);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(\"File not found opening fasta file; please do this check before MicroManaging\", ex);\n        }\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n        GenomeLoc.setupRefContigOrdering(ref);\n\n        ShardStrategy shardStrategy = ShardStrategyFactory.shatter(ShardStrategyFactory.SHATTER_STRATEGY.READS,\n                ref.getSequenceDictionary(),\n                readSize);\n        SAMDataSource dataSource = null;\n        try {\n            dataSource = new SAMDataSource(TraversalEngine.unpackReads(bamList));\n            dataSource.viewUnmappedReads(true);\n            //dataSource.viewUnmappedReads(false);\n        }\n        catch (SimpleDataSourceLoadException ex) {\n            throw new RuntimeException(ex);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        dataSource.viewUnmappedReads(true);\n\n        boolean walkerInitialized = false;\n        Object accumulator = null;\n        while (shardStrategy.hasNext()) {\n            Shard shard = shardStrategy.next();\n            BoundedReadIterator readIter = null;\n            try {\n                readIter = (BoundedReadIterator) dataSource.seek(shard);\n            }\n            catch (SimpleDataSourceLoadException ex) {\n                throw new RuntimeException(ex);\n            }\n\n            //LocusContextProvider locusProvider = new LocusContextProvider( readIter );\n\n            // set the sam header of the traversal engine\n            traversalEngine.setSAMHeader(readIter.getHeader());\n\n            if (!walkerInitialized) {\n                countReadWalker.initialize();\n                accumulator = ((ReadWalker<?, ?>) countReadWalker).reduceInit();\n                walkerInitialized = true;\n\n            }\n            if (shard == null) {\n                fail(\"Shard == null\");\n            }\n\n\n            accumulator = traversalEngine.traverse(countReadWalker, shard, readIter, accumulator);\n            readIter.close();\n\n        }\n\n        traversalEngine.printOnTraversalDone(\"loci\", accumulator);\n        countReadWalker.onTraversalDone(accumulator);\n\n        if (!(accumulator instanceof Integer)) {\n            fail(\"Count read walker should return an interger.\");\n        }\n        if (((Integer) accumulator) != 10000) {\n            fail(\"there should be 9721 mapped reads in the index file\");\n        }\n    }","id":98082,"modified_method":"/** Test out that we can shard the file and iterate over every read */\n    @Test\n    public void testUnmappedReadCount() {\n\n        IndexedFastaSequenceFile ref = null;\n        try {\n            ref = new IndexedFastaSequenceFile(refFile);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(\"File not found opening fasta file; please do this check before MicroManaging\", ex);\n        }\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n        GenomeLoc.setupRefContigOrdering(ref);\n\n        ShardStrategy shardStrategy = ShardStrategyFactory.shatter(ShardStrategyFactory.SHATTER_STRATEGY.READS,\n                ref.getSequenceDictionary(),\n                readSize);\n        List<File> unpackedReads = null;\n        try {\n            unpackedReads = TraversalEngine.unpackReads(bamList);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        SAMDataSource dataSource = new SAMDataSource(unpackedReads);\n        dataSource.viewUnmappedReads(true);\n\n        countReadWalker.initialize();\n        Object accumulator = countReadWalker.reduceInit();\n\n        while (shardStrategy.hasNext()) {\n            Shard shard = shardStrategy.next();\n\n            if (shard == null) {\n                fail(\"Shard == null\");\n            }\n\n            ShardDataProvider dataProvider = new ShardDataProvider(shard,dataSource,null);\n            accumulator = traversalEngine.traverse(countReadWalker, shard, dataProvider, accumulator);\n            dataProvider.close();\n        }\n\n        traversalEngine.printOnTraversalDone(\"loci\", accumulator);\n        countReadWalker.onTraversalDone(accumulator);\n\n        if (!(accumulator instanceof Integer)) {\n            fail(\"Count read walker should return an interger.\");\n        }\n        if (((Integer) accumulator) != 10000) {\n            fail(\"there should be 10000 mapped reads in the index file\");\n        }\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Test out that we can shard the file and iterate over every read */\n    @Test\n    public void testMappedReadCount() {\n\n        IndexedFastaSequenceFile ref = null;\n        try {\n            ref = new IndexedFastaSequenceFile(refFile);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(\"File not found opening fasta file; please do this check before MicroManaging\", ex);\n        }\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n        GenomeLoc.setupRefContigOrdering(ref);\n\n        ShardStrategy shardStrategy = ShardStrategyFactory.shatter(ShardStrategyFactory.SHATTER_STRATEGY.READS,\n                ref.getSequenceDictionary(),\n                readSize);\n        SAMDataSource dataSource = null;\n        try {\n            dataSource = new SAMDataSource(TraversalEngine.unpackReads(bamList));\n            dataSource.viewUnmappedReads(true);\n            //dataSource.viewUnmappedReads(false);\n        }\n        catch (SimpleDataSourceLoadException ex) {\n            throw new RuntimeException(ex);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        dataSource.viewUnmappedReads(false);\n\n        boolean walkerInitialized = false;\n        Object accumulator = null;\n        while (shardStrategy.hasNext()) {\n            Shard shard = shardStrategy.next();\n            BoundedReadIterator readIter = null;\n            try {\n                readIter = (BoundedReadIterator) dataSource.seek(shard);\n            }\n            catch (SimpleDataSourceLoadException ex) {\n                throw new RuntimeException(ex);\n            }\n\n            //LocusContextProvider locusProvider = new LocusContextProvider( readIter );\n\n            // set the sam header of the traversal engine\n            traversalEngine.setSAMHeader(readIter.getHeader());\n\n            if (!walkerInitialized) {\n                countReadWalker.initialize();\n                accumulator = ((ReadWalker<?, ?>) countReadWalker).reduceInit();\n                walkerInitialized = true;\n\n            }\n            if (shard == null) {\n                fail(\"Shard == null\");\n            }\n\n\n            accumulator = traversalEngine.traverse(countReadWalker, shard, readIter, accumulator);\n            readIter.close();\n\n        }\n\n        traversalEngine.printOnTraversalDone(\"loci\", accumulator);\n        countReadWalker.onTraversalDone(accumulator);\n\n        if (!(accumulator instanceof Integer)) {\n            fail(\"Count read walker should return an interger.\");\n        }\n        if (((Integer) accumulator) != 9721) {\n            fail(\"there should be 9721 mapped reads in the index file\");\n        }\n    }","id":98083,"modified_method":"/** Test out that we can shard the file and iterate over every read */\n    @Test\n    public void testMappedReadCount() {\n\n        IndexedFastaSequenceFile ref = null;\n        try {\n            ref = new IndexedFastaSequenceFile(refFile);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(\"File not found opening fasta file; please do this check before MicroManaging\", ex);\n        }\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n        GenomeLoc.setupRefContigOrdering(ref);\n\n        ShardStrategy shardStrategy = ShardStrategyFactory.shatter(ShardStrategyFactory.SHATTER_STRATEGY.READS,\n                ref.getSequenceDictionary(),\n                readSize);\n\n        List<File> unpackedReads = null;\n        try {\n            unpackedReads = TraversalEngine.unpackReads(bamList);\n        }\n        catch (FileNotFoundException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        SAMDataSource dataSource = new SAMDataSource(unpackedReads);\n        dataSource.viewUnmappedReads(false);\n\n        countReadWalker.initialize();\n        Object accumulator = countReadWalker.reduceInit();\n\n        while (shardStrategy.hasNext()) {\n            Shard shard = shardStrategy.next();\n\n            if (shard == null) {\n                fail(\"Shard == null\");\n            }\n\n            ShardDataProvider dataProvider = new ShardDataProvider(shard,dataSource,null);\n            accumulator = traversalEngine.traverse(countReadWalker, shard, dataProvider, accumulator);\n            dataProvider.close();\n\n        }\n\n        traversalEngine.printOnTraversalDone(\"loci\", accumulator);\n        countReadWalker.onTraversalDone(accumulator);\n\n        if (!(accumulator instanceof Integer)) {\n            fail(\"Count read walker should return an interger.\");\n        }\n        if (((Integer) accumulator) != 9721) {\n            fail(\"there should be 9721 mapped reads in the index file\");\n        }\n    }","commit_id":"6e394490cb1666c0d0f92ce2958c8c6dbb648d85","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void sendGrantLockRequest(String lock_name, int lock_id, Owner owner, long timeout, boolean is_trylock) {\n        if(coord != null)\n            sendRequest(coord, Type.GRANT_LOCK, lock_name, lock_id, owner, timeout, is_trylock);\n    }","id":98084,"modified_method":"protected void sendGrantLockRequest(String lock_name, int lock_id, Owner owner, long timeout, boolean is_trylock) {\n        Address dest=coord;\n        if(dest == null)\n            throw new IllegalStateException(\"No coordinator available, cannot send GRANT-LOCK request\");\n        sendRequest(dest, Type.GRANT_LOCK, lock_name, lock_id, owner, timeout, is_trylock);\n    }","commit_id":"3d2443acfb7483289188f78ee3bb813e08746457","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void sendReleaseLockRequest(String lock_name, Owner owner) {\n        if(coord != null)\n            sendRequest(coord, Type.RELEASE_LOCK, lock_name, owner, 0, false);\n    }","id":98085,"modified_method":"protected void sendReleaseLockRequest(String lock_name, Owner owner) {\n        Address dest=coord;\n        if(dest == null)\n            throw new IllegalStateException(\"No coordinator available, cannot send RELEASE-LOCK request\");\n        sendRequest(dest, Type.RELEASE_LOCK, lock_name, owner, 0, false);\n    }","commit_id":"3d2443acfb7483289188f78ee3bb813e08746457","url":"https://github.com/belaban/JGroups"},{"original_method":"public String getName(Context ctx) {\n\t\t\tString fileName = file.getName();\n\t\t\tString desc = getDescriptionName(fileName);\n\t\t\tif (desc != null) {\n\t\t\t\treturn desc;\n\t\t\t} else if (this.isAudio()) {\n\t\t\t\tString time = AndroidUtils.formatDateTime(ctx, file.lastModified());\n\t\t\t\treturn ctx.getString(R.string.rec_audio_description, time).trim();\n\t\t\t} else if (this.isVideo()) {\n\t\t\t\tString time = AndroidUtils.formatDateTime(ctx, file.lastModified());\n\t\t\t\treturn ctx.getString(R.string.rec_video_description, time).trim();\n\t\t\t} else if (this.isPhoto()) {\n\t\t\t\tString time = AndroidUtils.formatDateTime(ctx, file.lastModified());\n\t\t\t\treturn ctx.getString(R.string.rec_photo_description, time).trim();\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}","id":98086,"modified_method":"public String getName(Context ctx) {\n\t\t\tString fileName = file.getName();\n\t\t\tString desc = getDescriptionName(fileName);\n\t\t\tif (desc != null) {\n\t\t\t\treturn desc;\n\t\t\t} else if (this.isAudio()) {\n\t\t\t\treturn ctx.getString(R.string.rec_audio_description, formatDateTime(ctx, file.lastModified()));\n\t\t\t} else if (this.isVideo()) {\n\t\t\t\treturn ctx.getString(R.string.rec_video_description, formatDateTime(ctx, file.lastModified()));\n\t\t\t} else if (this.isPhoto()) {\n\t\t\t\treturn ctx.getString(R.string.rec_photo_description, formatDateTime(ctx, file.lastModified()));\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}","commit_id":"257b6d93fb1505829b1fa9609fe18ef071b17946","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public int compare(FileEditorProvider provider1, FileEditorProvider provider2) {\n      return provider1.getPolicy().ordinal() - provider2.getPolicy().ordinal();\n    }","id":98087,"modified_method":"public int compare(FileEditorProvider provider1, FileEditorProvider provider2) {\n      final int i1 = provider1.getPolicy().ordinal();\n      final int i2 = provider2.getPolicy().ordinal();\n      if (i1 != i2) return i1 - i2;\n      final double value = getWeight(provider1) - getWeight(provider2);\n      return value > 0 ? 1 : value < 0 ? -1 : 0;\n    }","commit_id":"043b1114fd655c8f5c47836d7fbfeecc6b279169","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Requires({\"eval != null\",\"truth != null\"})\n    public void update(VariantContext eval, VariantContext truth) {\n        overallSiteConcordance.update(eval,truth);\n        Set<String> alleleTruth = new HashSet<String>(8);\n        String truthRef = truth.getReference().getBaseString();\n        alleleTruth.add(truthRef);\n        for ( Allele a : truth.getAlternateAlleles() ) {\n            alleleTruth.add(a.getBaseString());\n        }\n        for ( String sample : perSampleGenotypeConcordance.keySet() ) {\n            Genotype evalGenotype = eval.getGenotype(sample);\n            Genotype truthGenotype = truth.getGenotype(sample);\n            // ensure genotypes are either no-call (\".\"), missing (empty alleles), or diploid\n            if ( ( ! evalGenotype.isNoCall() && evalGenotype.getPloidy() != 2 && evalGenotype.getPloidy() > 0) ||\n                 ( ! truthGenotype.isNoCall() && truthGenotype.getPloidy() != 2 && truthGenotype.getPloidy() > 0) ) {\n                throw new UserException(String.format(\"Concordance Metrics is currently only implemented for DIPLOID genotypes, found eval ploidy: %d, comp ploidy: %d\",evalGenotype.getPloidy(),truthGenotype.getPloidy()));\n            }\n            perSampleGenotypeConcordance.get(sample).update(evalGenotype,truthGenotype,alleleTruth,truthRef);\n            overallGenotypeConcordance.update(evalGenotype,truthGenotype,alleleTruth,truthRef);\n        }\n    }","id":98088,"modified_method":"@Requires({\"eval != null\",\"truth != null\"})\n    public void update(VariantContext eval, VariantContext truth) {\n        Boolean doPrint = false;\n        overallSiteConcordance.update(eval,truth);\n        Set<String> alleleTruth = new HashSet<String>(8);\n        String truthRef = truth.getReference().getBaseString();\n        alleleTruth.add(truthRef);\n        for ( Allele a : truth.getAlternateAlleles() ) {\n            alleleTruth.add(a.getBaseString());\n        }\n        for ( String sample : perSampleGenotypeConcordance.keySet() ) {\n            Genotype evalGenotype = eval.getGenotype(sample);\n            Genotype truthGenotype = truth.getGenotype(sample);\n            // ensure genotypes are either no-call (\".\"), missing (empty alleles), or diploid\n            if ( ( ! evalGenotype.isNoCall() && evalGenotype.getPloidy() != 2 && evalGenotype.getPloidy() > 0) ||\n                 ( ! truthGenotype.isNoCall() && truthGenotype.getPloidy() != 2 && truthGenotype.getPloidy() > 0) ) {\n                throw new UserException(String.format(\"Concordance Metrics is currently only implemented for DIPLOID genotypes, found eval ploidy: %d, comp ploidy: %d\",evalGenotype.getPloidy(),truthGenotype.getPloidy()));\n            }\n            perSampleGenotypeConcordance.get(sample).update(evalGenotype,truthGenotype,alleleTruth,truthRef);\n            doPrint = overallGenotypeConcordance.update(evalGenotype,truthGenotype,alleleTruth,truthRef);\n            if(printInterestingSites && doPrint)\n                System.out.println(eval.getChr() + \":\" + eval.getStart() + \"\\t truth is:\" + truthGenotype.getType() + \"\\t eval is:\" + evalGenotype.getType());\n\n                //Below is code to print out mismatched alternate alleles\n                //System.out.println(eval.getChr() + \":\" + eval.getStart() + \"\\t truth is:\" + truthGenotype.getAlleles() + \"\\t eval is:\" + evalGenotype.getAlleles());\n        }\n    }","commit_id":"a3a9c38f769e71895dce48c187ee101712cf6e1f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires({\"eval!=null\",\"truth != null\",\"truthAlleles != null\"})\n        public void update(Genotype eval, Genotype truth, Set<String> truthAlleles, String truthRef) {\n            // this is slow but correct.\n\n            // NOTE: a reference call in \"truth\" is a special case, the eval can match *any* of the truth alleles\n            // that is, if the reference base is C, and a sample is C/C in truth, A/C, A/A, T/C, T/T will\n            // all match, so long as A and T are alleles in the truth callset.\n            boolean matchingAlt = true;\n            if ( eval.isCalled() && truth.isCalled() && truth.isHomRef() ) {\n                // by default, no-calls \"match\" between alleles, so if\n                // one or both sites are no-call or unavailable, the alt alleles match\n                // otherwise, check explicitly: if the eval has an allele that's not ref, no-call, or present in truth\n                // the alt allele is mismatching - regardless of whether the genotype is correct.\n                for ( Allele evalAllele : eval.getAlleles() ) {\n                    matchingAlt &= truthAlleles.contains(evalAllele.getBaseString());\n                }\n            } else if ( eval.isCalled() && truth.isCalled() ) {\n                // otherwise, the eval genotype has to match either the alleles in the truth genotype, or the truth reference allele\n                // todo -- this can be sped up by caching the truth allele sets\n                Set<String> genoAlleles = new HashSet<String>(3);\n                genoAlleles.add(truthRef);\n                for ( Allele truthGenoAl : truth.getAlleles() ) {\n                    genoAlleles.add(truthGenoAl.getBaseString());\n                }\n                for ( Allele evalAllele : eval.getAlleles() ) {\n                    matchingAlt &= genoAlleles.contains(evalAllele.getBaseString());\n                }\n            }\n\n            if ( matchingAlt ) {\n                genotypeCounts[eval.getType().ordinal()][truth.getType().ordinal()]++;\n            } else {\n                nMismatchingAlt++;\n            }\n        }","id":98089,"modified_method":"@Requires({\"eval!=null\",\"truth != null\",\"truthAlleles != null\"})\n        public Boolean update(Genotype eval, Genotype truth, Set<String> truthAlleles, String truthRef) {\n            // this is slow but correct.\n\n            // NOTE: a reference call in \"truth\" is a special case, the eval can match *any* of the truth alleles\n            // that is, if the reference base is C, and a sample is C/C in truth, A/C, A/A, T/C, T/T will\n            // all match, so long as A and T are alleles in the truth callset.\n            boolean matchingAlt = true;\n            int evalGT, truthGT;\n            if ( eval.isCalled() && truth.isCalled() && truth.isHomRef() ) {\n                // by default, no-calls \"match\" between alleles, so if\n                // one or both sites are no-call or unavailable, the alt alleles match\n                // otherwise, check explicitly: if the eval has an allele that's not ref, no-call, or present in truth\n                // the alt allele is mismatching - regardless of whether the genotype is correct.\n                for ( Allele evalAllele : eval.getAlleles() ) {\n                    matchingAlt &= truthAlleles.contains(evalAllele.getBaseString());\n                }\n            } else if ( eval.isCalled() && truth.isCalled() ) {\n                // otherwise, the eval genotype has to match either the alleles in the truth genotype, or the truth reference allele\n                // todo -- this can be sped up by caching the truth allele sets\n                Set<String> genoAlleles = new HashSet<String>(3);\n                genoAlleles.add(truthRef);\n                for ( Allele truthGenoAl : truth.getAlleles() ) {\n                    genoAlleles.add(truthGenoAl.getBaseString());\n                }\n                for ( Allele evalAllele : eval.getAlleles() ) {\n                    matchingAlt &= genoAlleles.contains(evalAllele.getBaseString());\n                }\n            }\n\n            if ( matchingAlt ) {\n                evalGT = eval.getType().ordinal();\n                truthGT = truth.getType().ordinal();\n                genotypeCounts[evalGT][truthGT]++;\n                if(evalGT != truthGT)  //report variants where genotypes don't match\n                    return true;\n            } else {\n                nMismatchingAlt++;\n                return false;\n                //return true; //alternatively, report variants where alt alleles don't match\n            }\n            return false;\n        }","commit_id":"a3a9c38f769e71895dce48c187ee101712cf6e1f","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ConcordanceMetrics(VCFHeader evaluate, VCFHeader truth) {\n        HashSet<String> overlappingSamples = new HashSet<String>(evaluate.getGenotypeSamples());\n        overlappingSamples.retainAll(truth.getGenotypeSamples());\n        perSampleGenotypeConcordance = new HashMap<String, GenotypeConcordanceTable>(overlappingSamples.size());\n        for ( String sample : overlappingSamples ) {\n            perSampleGenotypeConcordance.put(sample,new GenotypeConcordanceTable());\n        }\n        overallGenotypeConcordance = new GenotypeConcordanceTable();\n        overallSiteConcordance = new SiteConcordanceTable();\n    }","id":98090,"modified_method":"public ConcordanceMetrics(VCFHeader evaluate, VCFHeader truth, Boolean printSitesEnabled) {\n        HashSet<String> overlappingSamples = new HashSet<String>(evaluate.getGenotypeSamples());\n        overlappingSamples.retainAll(truth.getGenotypeSamples());\n        perSampleGenotypeConcordance = new HashMap<String, GenotypeConcordanceTable>(overlappingSamples.size());\n        for ( String sample : overlappingSamples ) {\n            perSampleGenotypeConcordance.put(sample,new GenotypeConcordanceTable());\n        }\n        overallGenotypeConcordance = new GenotypeConcordanceTable();\n        overallSiteConcordance = new SiteConcordanceTable();\n        printInterestingSites = printSitesEnabled;\n    }","commit_id":"a3a9c38f769e71895dce48c187ee101712cf6e1f","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ConcordanceMetrics reduceInit() {\n        Map<String,VCFHeader> headerMap = GATKVCFUtils.getVCFHeadersFromRods(getToolkit(), Arrays.asList(evalBinding,compBinding));\n        VCFHeader evalHeader = headerMap.get(evalBinding.getName());\n        evalSamples = evalHeader.getGenotypeSamples();\n        VCFHeader compHeader = headerMap.get(compBinding.getName());\n        compSamples = compHeader.getGenotypeSamples();\n        return new ConcordanceMetrics(evalHeader,compHeader);\n    }","id":98091,"modified_method":"public ConcordanceMetrics reduceInit() {\n        Map<String,VCFHeader> headerMap = GATKVCFUtils.getVCFHeadersFromRods(getToolkit(), Arrays.asList(evalBinding,compBinding));\n        VCFHeader evalHeader = headerMap.get(evalBinding.getName());\n        evalSamples = evalHeader.getGenotypeSamples();\n        VCFHeader compHeader = headerMap.get(compBinding.getName());\n        compSamples = compHeader.getGenotypeSamples();\n        return new ConcordanceMetrics(evalHeader,compHeader, printSites);\n    }","commit_id":"a3a9c38f769e71895dce48c187ee101712cf6e1f","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected String injectVirtualGroupURL(String layoutURL) {\n\t\ttry {\n\t\t\tGroup group = _sourceLayout.getGroup();\n\n\t\t\tString params = StringPool.BLANK;\n\n\t\t\tint paramsPos = layoutURL.indexOf(StringPool.QUESTION);\n\n\t\t\tif (paramsPos > 0) {\n\t\t\t\tparams = layoutURL.substring(paramsPos, layoutURL.length());\n\t\t\t}\n\n\t\t\tint pos = layoutURL.indexOf(group.getFriendlyURL());\n\n\t\t\treturn layoutURL.substring(0, pos).concat(\n\t\t\t\t_targetGroup.getFriendlyURL()).concat(getFriendlyURL()).concat(\n\t\t\t\t\tparams);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}","id":98092,"modified_method":"protected String injectVirtualGroupURL(String layoutURL) {\n\t\ttry {\n\t\t\tGroup group = _sourceLayout.getGroup();\n\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tint pos = layoutURL.indexOf(group.getFriendlyURL());\n\n\t\t\tsb.append(layoutURL.substring(0, pos));\n\t\t\tsb.append(_targetGroup.getFriendlyURL());\n\t\t\tsb.append(getFriendlyURL());\n\n\t\t\tpos = layoutURL.indexOf(StringPool.QUESTION);\n\n\t\t\tif (pos > 0) {\n\t\t\t\tsb.append(layoutURL.substring(pos, layoutURL.length()));\n\t\t\t}\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}","commit_id":"17b2f43f735636cbbfbca454f458e440188b79a0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importLayout(\n\t\t\tPortletDataContext context, User user, LayoutCache layoutCache,\n\t\t\tList<Layout> previousLayouts, List<Layout> newLayouts,\n\t\t\tMap<Long, Layout> newLayoutsMap, Set<Long> newLayoutIds,\n\t\t\tString portletsMergeMode, String themeId, String colorSchemeId,\n\t\t\tString layoutsImportMode, boolean privateLayout,\n\t\t\tboolean importPermissions, boolean importUserPermissions,\n\t\t\tboolean useThemeZip, Element rootElement, Element layoutElement)\n\t\tthrows Exception {\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tString layoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"layout-uuid\"));\n\n\t\tlong layoutId = GetterUtil.getInteger(\n\t\t\tlayoutElement.attributeValue(\"layout-id\"));\n\n\t\tlong oldLayoutId = layoutId;\n\n\t\tboolean deleteLayout = GetterUtil.getBoolean(\n\t\t\tlayoutElement.attributeValue(\"delete\"));\n\n\t\tif (deleteLayout) {\n\t\t\ttry {\n\t\t\t\tLayout layout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\tlayoutUuid, groupId);\n\n\t\t\t\tif (layout != null) {\n\t\t\t\t\tnewLayoutsMap.put(oldLayoutId, layout);\n\n\t\t\t\t\tLayoutLocalServiceUtil.deleteLayout(layout);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Error deleting layout for {\" + layoutUuid + \", \" +\n\t\t\t\t\t\tgroupId + \"}\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tString path = layoutElement.attributeValue(\"path\");\n\n\t\tif (!context.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLayout layout = (Layout)context.getZipEntryAsObject(path);\n\n\t\tLayout existingLayout = null;\n\t\tLayout importedLayout = null;\n\n\t\tString friendlyURL = layout.getFriendlyURL();\n\n\t\tif (layoutsImportMode.equals(\n\t\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_ADD_AS_NEW)) {\n\n\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\tgroupId, privateLayout);\n\t\t\tfriendlyURL = StringPool.SLASH + layoutId;\n\t\t}\n\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_NAME)) {\n\n\t\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\t\tString localizedName = layout.getName(locale);\n\n\t\t\tfor (Layout curLayout : previousLayouts) {\n\t\t\t\tif (curLayout.getName(locale).equals(localizedName)) {\n\t\t\t\t\texistingLayout = curLayout;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// The default behaviour of import mode is\n\t\t\t// PortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_ID\n\n\t\t\texistingLayout = LayoutUtil.fetchByUUID_G(\n\t\t\t\tlayout.getUuid(), groupId);\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\texistingLayout = LayoutUtil.fetchByG_P_F(\n\t\t\t\t\tgroupId, privateLayout, friendlyURL);\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (existingLayout == null) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\"} does not exist\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\"} exists\");\n\t\t\t}\n\t\t}\n\n\t\tif (existingLayout == null) {\n\t\t\tlong plid = CounterLocalServiceUtil.increment();\n\n\t\t\timportedLayout = LayoutUtil.create(plid);\n\n\t\t\timportedLayout.setUuid(layout.getUuid());\n\t\t\timportedLayout.setGroupId(groupId);\n\t\t\timportedLayout.setPrivateLayout(privateLayout);\n\t\t\timportedLayout.setLayoutId(layoutId);\n\n\t\t\tif (layout.isIconImage()) {\n\t\t\t\tlong iconImageId = CounterLocalServiceUtil.increment();\n\n\t\t\t\timportedLayout.setIconImageId(iconImageId);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedLayout = existingLayout;\n\t\t}\n\n\t\tnewLayoutsMap.put(oldLayoutId, importedLayout);\n\n\t\tlong parentLayoutId = layout.getParentLayoutId();\n\n\t\tNode parentLayoutNode = rootElement.selectSingleNode(\n\t\t\t\"./layouts/layout[@layout-id='\" + parentLayoutId + \"']\");\n\n\t\tString parentLayoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"parent-layout-uuid\"));\n\n\t\tif ((parentLayoutId != LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) &&\n\t\t\t(parentLayoutNode != null)) {\n\n\t\t\timportLayout(\n\t\t\t\tcontext, user, layoutCache, previousLayouts, newLayouts,\n\t\t\t\tnewLayoutsMap, newLayoutIds, portletsMergeMode, themeId,\n\t\t\t\tcolorSchemeId, layoutsImportMode, privateLayout,\n\t\t\t\timportPermissions, importUserPermissions, useThemeZip,\n\t\t\t\trootElement, (Element)parentLayoutNode);\n\n\t\t\tLayout parentLayout = newLayoutsMap.get(parentLayoutId);\n\n\t\t\tparentLayoutId = parentLayout.getLayoutId();\n\t\t}\n\t\telse if (Validator.isNotNull(parentLayoutUuid)) {\n\t\t\tLayout parentLayout =\n\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\tparentLayoutUuid, groupId);\n\n\t\t\tparentLayoutId = parentLayout.getLayoutId();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Importing layout with layout id \" + layoutId +\n\t\t\t\t\t\" and parent layout id \" + parentLayoutId);\n\t\t}\n\n\t\timportedLayout.setCompanyId(user.getCompanyId());\n\t\timportedLayout.setParentLayoutId(parentLayoutId);\n\t\timportedLayout.setName(layout.getName());\n\t\timportedLayout.setTitle(layout.getTitle());\n\t\timportedLayout.setDescription(layout.getDescription());\n\t\timportedLayout.setType(layout.getType());\n\n\t\tif (layout.isTypePortlet() &&\n\t\t\tValidator.isNotNull(layout.getTypeSettings()) &&\n\t\t\t!portletsMergeMode.equals(\n\t\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE)) {\n\n\t\t\tmergePortlets(\n\t\t\t\timportedLayout, layout.getTypeSettings(), portletsMergeMode);\n\t\t}\n\t\telse if (layout.isTypeLinkToLayout()) {\n\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\tlayout.getTypeSettingsProperties();\n\n\t\t\tlong linkToLayoutId = GetterUtil.getLong(\n\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\"linkToLayoutId\", StringPool.BLANK));\n\n\t\t\tif (linkToLayoutId > 0) {\n\t\t\t\tNode linkedLayoutNode = rootElement.selectSingleNode(\n\t\t\t\t\t\"./layouts/layout[@layout-id='\" + linkToLayoutId + \"']\");\n\n\t\t\t\tif (linkedLayoutNode != null) {\n\t\t\t\t\timportLayout(\n\t\t\t\t\t\tcontext, user, layoutCache, previousLayouts, newLayouts,\n\t\t\t\t\t\tnewLayoutsMap, newLayoutIds, portletsMergeMode, themeId,\n\t\t\t\t\t\tcolorSchemeId, layoutsImportMode, privateLayout,\n\t\t\t\t\t\timportPermissions, importUserPermissions, useThemeZip,\n\t\t\t\t\t\trootElement, (Element)linkedLayoutNode);\n\n\t\t\t\t\tLayout linkedLayout = newLayoutsMap.get(linkToLayoutId);\n\n\t\t\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\t\t\"linkToLayoutId\",\n\t\t\t\t\t\tString.valueOf(linkedLayout.getLayoutId()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"Unable to link layout with friendURL: \" +\n\t\t\t\t\t\t\tlayout.getFriendlyURL() + \" and layoutId:\" +\n\t\t\t\t\t\t\tlayout.getLayoutId() +\n\t\t\t\t\t\t\t\" to layout with layoutId: \" + linkToLayoutId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timportedLayout.setTypeSettings(layout.getTypeSettings());\n\t\t}\n\t\telse {\n\t\t\timportedLayout.setTypeSettings(layout.getTypeSettings());\n\t\t}\n\n\t\timportedLayout.setHidden(layout.isHidden());\n\t\timportedLayout.setFriendlyURL(friendlyURL);\n\n\t\tif (useThemeZip) {\n\t\t\timportedLayout.setThemeId(StringPool.BLANK);\n\t\t\timportedLayout.setColorSchemeId(StringPool.BLANK);\n\t\t}\n\t\telse {\n\t\t\timportedLayout.setThemeId(layout.getThemeId());\n\t\t\timportedLayout.setColorSchemeId(layout.getColorSchemeId());\n\t\t}\n\n\t\timportedLayout.setWapThemeId(layout.getWapThemeId());\n\t\timportedLayout.setWapColorSchemeId(layout.getWapColorSchemeId());\n\t\timportedLayout.setCss(layout.getCss());\n\t\timportedLayout.setPriority(layout.getPriority());\n\n\t\tfixTypeSettings(importedLayout);\n\n\t\tif (layout.isIconImage()) {\n\t\t\tString iconImagePath = layoutElement.elementText(\"icon-image-path\");\n\n\t\t\tbyte[] iconBytes = context.getZipEntryAsByteArray(iconImagePath);\n\n\t\t\tif ((iconBytes != null) && (iconBytes.length > 0)) {\n\t\t\t\timportedLayout.setIconImage(true);\n\n\t\t\t\tImageLocalServiceUtil.updateImage(\n\t\t\t\t\timportedLayout.getIconImageId(), iconBytes);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tImageLocalServiceUtil.deleteImage(importedLayout.getIconImageId());\n\t\t}\n\n\t\tLayoutUtil.update(importedLayout, false);\n\n\t\tcontext.setPlid(importedLayout.getPlid());\n\t\tcontext.setOldPlid(layout.getPlid());\n\n\t\tnewLayoutIds.add(importedLayout.getLayoutId());\n\n\t\tnewLayouts.add(importedLayout);\n\n\t\t// Layout permissions\n\n\t\tif (importPermissions) {\n\t\t\t_permissionImporter.importLayoutPermissions(\n\t\t\t\tlayoutCache, context.getCompanyId(), groupId, user.getUserId(),\n\t\t\t\timportedLayout, layoutElement, rootElement,\n\t\t\t\timportUserPermissions);\n\t\t}\n\n\t\t_portletImporter.importPortletData(\n\t\t\tcontext, PortletKeys.LAYOUT_CONFIGURATION, null, layoutElement);\n\t}","id":98093,"modified_method":"protected void importLayout(\n\t\t\tPortletDataContext context, User user, LayoutCache layoutCache,\n\t\t\tList<Layout> previousLayouts, List<Layout> newLayouts,\n\t\t\tMap<Long, Layout> newLayoutsMap, Set<Long> newLayoutIds,\n\t\t\tString portletsMergeMode, String themeId, String colorSchemeId,\n\t\t\tString layoutsImportMode, boolean privateLayout,\n\t\t\tboolean importPermissions, boolean importUserPermissions,\n\t\t\tboolean useThemeZip, Element rootElement, Element layoutElement)\n\t\tthrows Exception {\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tString layoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"layout-uuid\"));\n\n\t\tlong layoutId = GetterUtil.getInteger(\n\t\t\tlayoutElement.attributeValue(\"layout-id\"));\n\n\t\tlong oldLayoutId = layoutId;\n\n\t\tboolean deleteLayout = GetterUtil.getBoolean(\n\t\t\tlayoutElement.attributeValue(\"delete\"));\n\n\t\tif (deleteLayout) {\n\t\t\ttry {\n\t\t\t\tLayout layout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\tlayoutUuid, groupId);\n\n\t\t\t\tif (layout != null) {\n\t\t\t\t\tnewLayoutsMap.put(oldLayoutId, layout);\n\n\t\t\t\t\tLayoutLocalServiceUtil.deleteLayout(layout);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Error deleting layout for {\" + layoutUuid + \", \" +\n\t\t\t\t\t\tgroupId + \"}\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tString path = layoutElement.attributeValue(\"path\");\n\n\t\tif (!context.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLayout layout = (Layout)context.getZipEntryAsObject(path);\n\n\t\tLayout existingLayout = null;\n\t\tLayout importedLayout = null;\n\n\t\tString friendlyURL = layout.getFriendlyURL();\n\n\t\tif (layoutsImportMode.equals(\n\t\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_ADD_AS_NEW)) {\n\n\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\tgroupId, privateLayout);\n\t\t\tfriendlyURL = StringPool.SLASH + layoutId;\n\t\t}\n\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_NAME)) {\n\n\t\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\t\tString localizedName = layout.getName(locale);\n\n\t\t\tfor (Layout curLayout : previousLayouts) {\n\t\t\t\tif (curLayout.getName(locale).equals(localizedName)) {\n\t\t\t\t\texistingLayout = curLayout;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// The default behaviour of import mode is\n\t\t\t// PortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_ID\n\n\t\t\texistingLayout = LayoutUtil.fetchByUUID_G(\n\t\t\t\tlayout.getUuid(), groupId);\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\texistingLayout = LayoutUtil.fetchByG_P_F(\n\t\t\t\t\tgroupId, privateLayout, friendlyURL);\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (existingLayout == null) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\"} does not exist\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\"} exists\");\n\t\t\t}\n\t\t}\n\n\t\tif (existingLayout == null) {\n\t\t\tlong plid = CounterLocalServiceUtil.increment();\n\n\t\t\timportedLayout = LayoutUtil.create(plid);\n\n\t\t\timportedLayout.setUuid(layout.getUuid());\n\t\t\timportedLayout.setGroupId(groupId);\n\t\t\timportedLayout.setPrivateLayout(privateLayout);\n\t\t\timportedLayout.setLayoutId(layoutId);\n\n\t\t\tif (layout.isIconImage()) {\n\t\t\t\tlong iconImageId = CounterLocalServiceUtil.increment();\n\n\t\t\t\timportedLayout.setIconImageId(iconImageId);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedLayout = existingLayout;\n\t\t}\n\n\t\tnewLayoutsMap.put(oldLayoutId, importedLayout);\n\n\t\tlong parentLayoutId = layout.getParentLayoutId();\n\n\t\tNode parentLayoutNode = rootElement.selectSingleNode(\n\t\t\t\"./layouts/layout[@layout-id='\" + parentLayoutId + \"']\");\n\n\t\tString parentLayoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"parent-layout-uuid\"));\n\n\t\tif ((parentLayoutId != LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) &&\n\t\t\t(parentLayoutNode != null)) {\n\n\t\t\timportLayout(\n\t\t\t\tcontext, user, layoutCache, previousLayouts, newLayouts,\n\t\t\t\tnewLayoutsMap, newLayoutIds, portletsMergeMode, themeId,\n\t\t\t\tcolorSchemeId, layoutsImportMode, privateLayout,\n\t\t\t\timportPermissions, importUserPermissions, useThemeZip,\n\t\t\t\trootElement, (Element)parentLayoutNode);\n\n\t\t\tLayout parentLayout = newLayoutsMap.get(parentLayoutId);\n\n\t\t\tparentLayoutId = parentLayout.getLayoutId();\n\t\t}\n\t\telse if (Validator.isNotNull(parentLayoutUuid)) {\n\t\t\tLayout parentLayout =\n\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\tparentLayoutUuid, groupId);\n\n\t\t\tparentLayoutId = parentLayout.getLayoutId();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Importing layout with layout id \" + layoutId +\n\t\t\t\t\t\" and parent layout id \" + parentLayoutId);\n\t\t}\n\n\t\timportedLayout.setCompanyId(user.getCompanyId());\n\t\timportedLayout.setParentLayoutId(parentLayoutId);\n\t\timportedLayout.setName(layout.getName());\n\t\timportedLayout.setTitle(layout.getTitle());\n\t\timportedLayout.setDescription(layout.getDescription());\n\t\timportedLayout.setType(layout.getType());\n\n\t\tif (layout.isTypePortlet() &&\n\t\t\tValidator.isNotNull(layout.getTypeSettings()) &&\n\t\t\t!portletsMergeMode.equals(\n\t\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE)) {\n\n\t\t\tmergePortlets(\n\t\t\t\timportedLayout, layout.getTypeSettings(), portletsMergeMode);\n\t\t}\n\t\telse if (layout.isTypeLinkToLayout()) {\n\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\tlayout.getTypeSettingsProperties();\n\n\t\t\tlong linkToLayoutId = GetterUtil.getLong(\n\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\"linkToLayoutId\", StringPool.BLANK));\n\n\t\t\tif (linkToLayoutId > 0) {\n\t\t\t\tNode linkedLayoutNode = rootElement.selectSingleNode(\n\t\t\t\t\t\"./layouts/layout[@layout-id='\" + linkToLayoutId + \"']\");\n\n\t\t\t\tif (linkedLayoutNode != null) {\n\t\t\t\t\timportLayout(\n\t\t\t\t\t\tcontext, user, layoutCache, previousLayouts, newLayouts,\n\t\t\t\t\t\tnewLayoutsMap, newLayoutIds, portletsMergeMode, themeId,\n\t\t\t\t\t\tcolorSchemeId, layoutsImportMode, privateLayout,\n\t\t\t\t\t\timportPermissions, importUserPermissions, useThemeZip,\n\t\t\t\t\t\trootElement, (Element)linkedLayoutNode);\n\n\t\t\t\t\tLayout linkedLayout = newLayoutsMap.get(linkToLayoutId);\n\n\t\t\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\t\t\"linkToLayoutId\",\n\t\t\t\t\t\tString.valueOf(linkedLayout.getLayoutId()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\t\t\t\tsb.append(\"Unable to link layout with friendly URL \");\n\t\t\t\t\t\tsb.append(layout.getFriendlyURL());\n\t\t\t\t\t\tsb.append(\" and layout id \");\n\t\t\t\t\t\tsb.append(layout.getLayoutId());\n\t\t\t\t\t\tsb.append(\" to layout with layout id \");\n\t\t\t\t\t\tsb.append(linkToLayoutId);\n\n\t\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timportedLayout.setTypeSettings(layout.getTypeSettings());\n\t\t}\n\t\telse {\n\t\t\timportedLayout.setTypeSettings(layout.getTypeSettings());\n\t\t}\n\n\t\timportedLayout.setHidden(layout.isHidden());\n\t\timportedLayout.setFriendlyURL(friendlyURL);\n\n\t\tif (useThemeZip) {\n\t\t\timportedLayout.setThemeId(StringPool.BLANK);\n\t\t\timportedLayout.setColorSchemeId(StringPool.BLANK);\n\t\t}\n\t\telse {\n\t\t\timportedLayout.setThemeId(layout.getThemeId());\n\t\t\timportedLayout.setColorSchemeId(layout.getColorSchemeId());\n\t\t}\n\n\t\timportedLayout.setWapThemeId(layout.getWapThemeId());\n\t\timportedLayout.setWapColorSchemeId(layout.getWapColorSchemeId());\n\t\timportedLayout.setCss(layout.getCss());\n\t\timportedLayout.setPriority(layout.getPriority());\n\n\t\tfixTypeSettings(importedLayout);\n\n\t\tif (layout.isIconImage()) {\n\t\t\tString iconImagePath = layoutElement.elementText(\"icon-image-path\");\n\n\t\t\tbyte[] iconBytes = context.getZipEntryAsByteArray(iconImagePath);\n\n\t\t\tif ((iconBytes != null) && (iconBytes.length > 0)) {\n\t\t\t\timportedLayout.setIconImage(true);\n\n\t\t\t\tImageLocalServiceUtil.updateImage(\n\t\t\t\t\timportedLayout.getIconImageId(), iconBytes);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tImageLocalServiceUtil.deleteImage(importedLayout.getIconImageId());\n\t\t}\n\n\t\tLayoutUtil.update(importedLayout, false);\n\n\t\tcontext.setPlid(importedLayout.getPlid());\n\t\tcontext.setOldPlid(layout.getPlid());\n\n\t\tnewLayoutIds.add(importedLayout.getLayoutId());\n\n\t\tnewLayouts.add(importedLayout);\n\n\t\t// Layout permissions\n\n\t\tif (importPermissions) {\n\t\t\t_permissionImporter.importLayoutPermissions(\n\t\t\t\tlayoutCache, context.getCompanyId(), groupId, user.getUserId(),\n\t\t\t\timportedLayout, layoutElement, rootElement,\n\t\t\t\timportUserPermissions);\n\t\t}\n\n\t\t_portletImporter.importPortletData(\n\t\t\tcontext, PortletKeys.LAYOUT_CONFIGURATION, null, layoutElement);\n\t}","commit_id":"3ebe8b311c46bcff592d3e2e5c02cf8da2ca1d27","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Writes a message to the log\n   * @param the log level\n   * @param the message to write\n   */\n  public static void log (int iLogLevel, String sMessage)\n  {\n    try \n\t\t{\n\t\t  if (!bInitialized)\n\t\t    initialize ();\n\t\t    \n      if (iLogLevel <= iLogLevelSetting)\n      {\n        String sDate = getLogTimeStamp ();\n\t\t    PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (getPortalBaseDir () + sLogRelativePath, true)));\n\t\t\t  out.println (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" + sMessage);\n\t\t\t  out.close ();\n\t\t\t}\n\t\t}\t\n\t\tcatch (IllegalArgumentException iae)\n\t\t{\n\t\t  throw new IllegalArgumentException (sIllArgExMessage);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","id":98094,"modified_method":"public static synchronized void log (int iLogLevel, String sMessage)\n  {\n\n    if (iLogLevel <= iLogLevelSetting)\n    {\n      if (!bInitialized)\n      initialize ();\n      String sDate = getLogTimeStamp ();\n      String sPortalBaseDir = getPortalBaseDir ();\n\n      try\n      {\n\n        if (sPortalBaseDir != null && new File (sPortalBaseDir).exists ())\n        {\n          PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (sPortalBaseDir + sLogRelativePath, true)));\n          out.print (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" );\n          if ( sessionReference.get () != null )\n          {\n            printSession (out, ((HttpSession)(sessionReference.get () )).getId ());\n          }\n          else\n          {\n           out.print(\"No Session - \");\n          }\n          out.println (sMessage);\n          out.close ();\n        }\n      }\n\n      catch (IllegalArgumentException iae)\n      {\n        throw new IllegalArgumentException (sIllArgExMessage);\n      }\n      catch (Exception e)\n      {\n        System.err.println (\"Problem writing to log.\");\n        e.printStackTrace ();\n      }\n    }\n  }","commit_id":"ba7d7be46ff147ac9c3bc36ef254cb932d87d568","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Sets the current log level.  Use one of the static integer members\n   * of this class ranging from  Logger.DEBUG to Logger.NONE.  \n   * The log level setting will determine the severity threshold of all log\n   * messages.  The more lenient the log level, the more log messages will be logged.\n   * @param a log level\n   * @throws IllegalArgumentException if the log level is not one of the acceptable log levels \n   */\n  public static void setLogLevel (int iLogLevel) \n  {\n\t\tif (!bInitialized)\n\t\t  initialize ();\n\t\t  \n    if (iLogLevel <= DEBUG)\n      iLogLevelSetting = iLogLevel;\n    else\n      throw new IllegalArgumentException (sIllArgExMessage);\n  }","id":98095,"modified_method":"public static void setLogLevel (int iLogLevel)\n  {\n    if (!bInitialized)\n    initialize ();\n\n    if (iLogLevel <= DEBUG)\n    iLogLevelSetting = iLogLevel;\n    else\n    throw new IllegalArgumentException (sIllArgExMessage);\n  }","commit_id":"ba7d7be46ff147ac9c3bc36ef254cb932d87d568","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Writes an exception's stack trace to the log\n   * @param the log level\n   * @param an exception\n   * @throws IllegalArgumentException if the log level is not one of the acceptable log levels \n   */\n  public static void log (int iLogLevel, Throwable ex)\n  {\n    try \n\t\t{\n\t\t  if (!bInitialized)\n\t\t    initialize ();\n\t\t    \n      if (iLogLevel <= iLogLevelSetting)\n      {\n        String sDate = getLogTimeStamp ();\n\t\t    PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (getPortalBaseDir () + sLogRelativePath, true)));\n\t\t\t  out.println (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" + \"Stack trace:\");\n\t\t\t  out.println ();\n\t\t\t  ex.printStackTrace (out);\n\t\t\t  out.println ();\n\t\t\t  out.close ();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException iae)\n\t\t{\n\t\t  throw new IllegalArgumentException (sIllArgExMessage);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","id":98096,"modified_method":"/**\n   * Writes an exception's stack trace to the log\n   * @param the log level\n   * @param an exception\n   * @throws IllegalArgumentException if the log level is not one of the acceptable log levels\n   */\n  public static synchronized void log (int iLogLevel, Throwable ex)\n  {\n\n    if (iLogLevel <= iLogLevelSetting)\n    {\n      if (!bInitialized)\n      initialize ();\n\n      String sDate = getLogTimeStamp ();\n      String sPortalBaseDir = getPortalBaseDir ();\n\n      try\n      {\n        if (sPortalBaseDir != null && new File (sPortalBaseDir).exists ())\n        {\n          PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (sPortalBaseDir + sLogRelativePath, true)));\n          out.print (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" );\n          if ( sessionReference.get () != null )\n          {\n            printSession (out, ((HttpSession)(sessionReference.get () )).getId ());\n          }\n          else\n          {\n           out.print(\"No Session - \");\n          }\n          out.println ( \"Stack trace:\");\n          out.println ();\n          ex.printStackTrace (out);\n          out.println ();\n          out.close ();\n        }\n      }\n\n      catch (IllegalArgumentException iae)\n      {\n        throw new IllegalArgumentException (sIllArgExMessage);\n      }\n      catch (Exception e)\n      {\n        System.err.println (\"Problem writing to log.\");\n        e.printStackTrace ();\n      }\n    }\n  }","commit_id":"ba7d7be46ff147ac9c3bc36ef254cb932d87d568","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Increments the old logs and creates a new log with the \n   * current time and log level written at the top\n   */\n  public static void initialize ()\n  {\n    try \n\t\t{\n\t\t\t// Advance logs\t\t\t\n\t\t  advanceLogs ();\n\t\t  \n\t\t  // Print a header to the log containing the current time and log level\n      String sDate = getLogTimeStamp ();\n\t\t  PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (getPortalBaseDir () + sLogRelativePath, true)));\n\t\t\tout.println (\"Portal log service initiating on \" + sDate + \"  Log level: \" + getLogLevel (iLogLevelSetting));\n\t\t\tout.println ();\n\t\t\tout.close ();\n\t\t\t\n\t\t\t// Insures that initialization is only done once\n\t\t\tbInitialized = true;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","id":98097,"modified_method":"/**\n   * Increments the old logs and creates a new log with the\n   * current time and log level written at the top\n   */\n  public static void initialize ()\n  {\n    try\n    {\n      String sPortalBaseDir = getPortalBaseDir ();\n\n      if (sPortalBaseDir != null && new File (sPortalBaseDir).exists ())\n      {\n        // Advance logs\n        advanceLogs ();\n\n        loadDefaultLogLevel ();\n\n        // Print a header to the log containing the current time and log level\n        String sDate = getLogTimeStamp ();\n        PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (sPortalBaseDir + sLogRelativePath, true)));\n        out.println (\"Portal log service initiating on \" + sDate + \"  Log level: \" + getLogLevel (iLogLevelSetting));\n        out.println ();\n        out.close ();\n\n        // Insures that initialization is only done once\n        bInitialized = true;\n      }\n    }\n    catch (Exception e)\n    {\n      System.err.println (\"Problem writing to log.\");\n      e.printStackTrace ();\n    }\n\n  }","commit_id":"ba7d7be46ff147ac9c3bc36ef254cb932d87d568","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Writes a message to the log\n   * @param the log level\n   * @param the message to write\n   */\n  public static void log (int iLogLevel, String sMessage)\n  {\n    try \n\t\t{\n\t\t  if (!bInitialized)\n\t\t    initialize ();\n\t\t    \n      if (iLogLevel <= iLogLevelSetting)\n      {\n        String sDate = getLogTimeStamp ();\n\t\t    PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (getPortalBaseDir () + sLogRelativePath, true)));\n\t\t\t  out.println (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" + sMessage);\n\t\t\t  out.close ();\n\t\t\t}\n\t\t}\t\n\t\tcatch (IllegalArgumentException iae)\n\t\t{\n\t\t  throw new IllegalArgumentException (sIllArgExMessage);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","id":98098,"modified_method":"/**\n   * Writes a message to the log\n   * @param the log level\n   * @param the message to write\n   */\n  public static void log (int iLogLevel, String sMessage)\n  {\n    try \n\t\t{\n\t\t  if (!bInitialized)\n\t\t    initialize ();\n\t\t    \n      if (iLogLevel <= iLogLevelSetting)\n      {\n        String sDate = getLogTimeStamp ();\n        String sPortalBaseDir = getPortalBaseDir ();\n        \n        if (sPortalBaseDir != null && new File (sPortalBaseDir).exists ())        \n\t\t    {        \n\t\t      PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (sPortalBaseDir + sLogRelativePath, true)));\n\t\t\t    out.println (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" + sMessage);\n\t\t\t    out.close ();\n\t\t\t  }\n\t\t\t}\n\t\t}\t\n\t\tcatch (IllegalArgumentException iae)\n\t\t{\n\t\t  throw new IllegalArgumentException (sIllArgExMessage);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","commit_id":"f4cb01661108a47e913a9854e61e85234bd69e2e","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Increments the old logs and creates a new log with the \n   * current time and log level written at the top\n   */\n  public static void initialize ()\n  {\n    try \n\t\t{\n\t\t\t// Advance logs\t\t\t\n\t\t  advanceLogs ();\n\t\t  \n\t\t  // Print a header to the log containing the current time and log level\n      String sDate = getLogTimeStamp ();\n\t\t  PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (getPortalBaseDir () + sLogRelativePath, true)));\n\t\t\tout.println (\"Portal log service initiating on \" + sDate + \"  Log level: \" + getLogLevel (iLogLevelSetting));\n\t\t\tout.println ();\n\t\t\tout.close ();\n\t\t\t\n\t\t\t// Insures that initialization is only done once\n\t\t\tbInitialized = true;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","id":98099,"modified_method":"/**\n   * Increments the old logs and creates a new log with the \n   * current time and log level written at the top\n   */\n  public static void initialize ()\n  {\n    try \n\t\t{\n      String sPortalBaseDir = getPortalBaseDir ();\n      \n      if (sPortalBaseDir != null && new File (sPortalBaseDir).exists ())        \n\t\t  {\n\t\t\t  // Advance logs\t\t\t\n\t\t    advanceLogs ();\n  \t\t  \n\t\t    // Print a header to the log containing the current time and log level\n        String sDate = getLogTimeStamp ();\n\t\t    PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (sPortalBaseDir + sLogRelativePath, true)));\n\t\t\t  out.println (\"Portal log service initiating on \" + sDate + \"  Log level: \" + getLogLevel (iLogLevelSetting));\n\t\t\t  out.println ();\n\t\t\t  out.close ();\n\t\t\t\n\t\t\t  // Insures that initialization is only done once\n\t\t\t  bInitialized = true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","commit_id":"f4cb01661108a47e913a9854e61e85234bd69e2e","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Writes an exception's stack trace to the log\n   * @param the log level\n   * @param an exception\n   * @throws IllegalArgumentException if the log level is not one of the acceptable log levels \n   */\n  public static void log (int iLogLevel, Throwable ex)\n  {\n    try \n\t\t{\n\t\t  if (!bInitialized)\n\t\t    initialize ();\n\t\t    \n      if (iLogLevel <= iLogLevelSetting)\n      {\n        String sDate = getLogTimeStamp ();\n\t\t    PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (getPortalBaseDir () + sLogRelativePath, true)));\n\t\t\t  out.println (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" + \"Stack trace:\");\n\t\t\t  out.println ();\n\t\t\t  ex.printStackTrace (out);\n\t\t\t  out.println ();\n\t\t\t  out.close ();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException iae)\n\t\t{\n\t\t  throw new IllegalArgumentException (sIllArgExMessage);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","id":98100,"modified_method":"/**\n   * Writes an exception's stack trace to the log\n   * @param the log level\n   * @param an exception\n   * @throws IllegalArgumentException if the log level is not one of the acceptable log levels \n   */\n  public static void log (int iLogLevel, Throwable ex)\n  {\n    try \n\t\t{\n\t\t  if (!bInitialized)\n\t\t    initialize ();\n\t\t    \n      if (iLogLevel <= iLogLevelSetting)\n      {\n        String sDate = getLogTimeStamp ();\n        String sPortalBaseDir = getPortalBaseDir ();\n        \n        if (sPortalBaseDir != null && new File (sPortalBaseDir).exists ())        \n\t\t    {        \n\t\t      PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (sPortalBaseDir + sLogRelativePath, true)));\n\t\t\t    out.println (getLogLevel (iLogLevel) + \" - \" + sDate + \" - \" + \"Stack trace:\");\n\t\t\t    out.println ();\n\t\t\t    ex.printStackTrace (out);\n\t\t\t    out.println ();\n\t\t\t    out.close ();\n\t\t\t  }\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException iae)\n\t\t{\n\t\t  throw new IllegalArgumentException (sIllArgExMessage);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t  System.err.println (\"Problem writing to log.\");\n\t\t  e.printStackTrace ();\n\t\t}\n  }","commit_id":"f4cb01661108a47e913a9854e61e85234bd69e2e","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsaveTempImageFile(actionRequest);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.portal_settings.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98101,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = saveTempImageFile(actionRequest);\n\n\t\t\t\tSessionMessages.add(actionRequest, \"imageUploaded\", fileEntry);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.portal_settings.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"455873def54f5e37142c00881107b6d7b9deb52f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsaveTempImageFile(actionRequest);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchLayoutException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.layouts_admin.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98102,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = saveTempImageFile(actionRequest);\n\n\t\t\t\tSessionMessages.add(actionRequest, \"imageUploaded\", fileEntry);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchLayoutException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.layouts_admin.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"455873def54f5e37142c00881107b6d7b9deb52f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void saveTempImageFile(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tFileEntry tempFileEntry = null;\n\n\t\tInputStream tempImageStream = null;\n\n\t\ttry {\n\t\t\ttempFileEntry = getTempImageFileEntry(actionRequest);\n\n\t\t\ttempImageStream = tempFileEntry.getContentStream();\n\n\t\t\tImageBag imageBag = ImageToolUtil.read(tempImageStream);\n\n\t\t\tRenderedImage renderedImage = imageBag.getRenderedImage();\n\n\t\t\tString cropRegionJSON = ParamUtil.getString(\n\t\t\t\tactionRequest, \"cropRegion\");\n\n\t\t\tif (Validator.isNotNull(cropRegionJSON)) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\t\tcropRegionJSON);\n\n\t\t\t\tint height = jsonObject.getInt(\"height\");\n\t\t\t\tint width = jsonObject.getInt(\"width\");\n\t\t\t\tint x = jsonObject.getInt(\"x\");\n\t\t\t\tint y = jsonObject.getInt(\"y\");\n\n\t\t\t\trenderedImage = ImageToolUtil.crop(\n\t\t\t\t\trenderedImage, height, width, x, y);\n\t\t\t}\n\n\t\t\tbyte[] bytes = ImageToolUtil.getBytes(\n\t\t\t\trenderedImage, imageBag.getType());\n\n\t\t\tsaveTempImageFile(actionRequest, bytes);\n\t\t}\n\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\tthrow new UploadException(nsfee);\n\t\t}\n\t\tcatch (NoSuchRepositoryException nsre) {\n\t\t\tthrow new UploadException(nsre);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(tempImageStream);\n\n\t\t\tif (tempFileEntry != null) {\n\t\t\t\tTempFileUtil.deleteTempFile(tempFileEntry.getFileEntryId());\n\t\t\t}\n\t\t}\n\t}","id":98103,"modified_method":"protected FileEntry saveTempImageFile(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tFileEntry tempFileEntry = null;\n\n\t\tInputStream tempImageStream = null;\n\n\t\ttry {\n\t\t\ttempFileEntry = getTempImageFileEntry(actionRequest);\n\n\t\t\ttempImageStream = tempFileEntry.getContentStream();\n\n\t\t\tImageBag imageBag = ImageToolUtil.read(tempImageStream);\n\n\t\t\tRenderedImage renderedImage = imageBag.getRenderedImage();\n\n\t\t\tString cropRegionJSON = ParamUtil.getString(\n\t\t\t\tactionRequest, \"cropRegion\");\n\n\t\t\tif (Validator.isNotNull(cropRegionJSON)) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\t\tcropRegionJSON);\n\n\t\t\t\tint height = jsonObject.getInt(\"height\");\n\t\t\t\tint width = jsonObject.getInt(\"width\");\n\t\t\t\tint x = jsonObject.getInt(\"x\");\n\t\t\t\tint y = jsonObject.getInt(\"y\");\n\n\t\t\t\trenderedImage = ImageToolUtil.crop(\n\t\t\t\t\trenderedImage, height, width, x, y);\n\t\t\t}\n\n\t\t\tbyte[] bytes = ImageToolUtil.getBytes(\n\t\t\t\trenderedImage, imageBag.getType());\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tFile file = FileUtil.createTempFile(bytes);\n\n\t\t\ttry {\n\t\t\t\tTempFileUtil.deleteTempFile(\n\t\t\t\t\tthemeDisplay.getScopeGroupId(), themeDisplay.getUserId(),\n\t\t\t\t\tgetTempImageFileName(actionRequest),\n\t\t\t\t\tgetTempImageFolderName());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\treturn TempFileUtil.addTempFile(\n\t\t\t\tthemeDisplay.getScopeGroupId(), themeDisplay.getUserId(),\n\t\t\t\tgetTempImageFileName(actionRequest), getTempImageFolderName(),\n\t\t\t\tfile, tempFileEntry.getMimeType());\n\t\t}\n\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\tthrow new UploadException(nsfee);\n\t\t}\n\t\tcatch (NoSuchRepositoryException nsre) {\n\t\t\tthrow new UploadException(nsre);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(tempImageStream);\n\t\t}\n\t}","commit_id":"455873def54f5e37142c00881107b6d7b9deb52f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addTempImageFile(PortletRequest portletRequest)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(portletRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString contentType = uploadPortletRequest.getContentType(\"fileName\");\n\n\t\tif (!MimeTypesUtil.isWebImage(contentType)) {\n\t\t\tthrow new ImageTypeException();\n\t\t}\n\n\t\ttry {\n\t\t\tTempFileUtil.deleteTempFile(\n\t\t\t\tthemeDisplay.getScopeGroupId(), themeDisplay.getUserId(),\n\t\t\t\tgetTempImageFileName(portletRequest), getTempImageFolderName());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tinputStream = uploadPortletRequest.getFileAsStream(\"fileName\");\n\n\t\t\tTempFileUtil.addTempFile(\n\t\t\t\tthemeDisplay.getScopeGroupId(), themeDisplay.getUserId(),\n\t\t\t\tgetTempImageFileName(portletRequest), getTempImageFolderName(),\n\t\t\t\tinputStream, contentType);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","id":98104,"modified_method":"protected FileEntry addTempImageFile(PortletRequest portletRequest)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(portletRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString contentType = uploadPortletRequest.getContentType(\"fileName\");\n\n\t\tif (!MimeTypesUtil.isWebImage(contentType)) {\n\t\t\tthrow new ImageTypeException();\n\t\t}\n\n\t\ttry {\n\t\t\tTempFileUtil.deleteTempFile(\n\t\t\t\tthemeDisplay.getScopeGroupId(), themeDisplay.getUserId(),\n\t\t\t\tgetTempImageFileName(portletRequest), getTempImageFolderName());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tinputStream = uploadPortletRequest.getFileAsStream(\"fileName\");\n\n\t\t\treturn TempFileUtil.addTempFile(\n\t\t\t\tthemeDisplay.getScopeGroupId(), themeDisplay.getUserId(),\n\t\t\t\tgetTempImageFileName(portletRequest), getTempImageFolderName(),\n\t\t\t\tinputStream, contentType);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","commit_id":"455873def54f5e37142c00881107b6d7b9deb52f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsaveTempImageFile(actionRequest);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portal.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98105,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = saveTempImageFile(actionRequest);\n\n\t\t\t\tSessionMessages.add(actionRequest, \"imageUploaded\", fileEntry);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portal.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"455873def54f5e37142c00881107b6d7b9deb52f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsaveTempImageFile(actionRequest);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchOrganizationException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.users_admin.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98106,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = saveTempImageFile(actionRequest);\n\n\t\t\t\tSessionMessages.add(actionRequest, \"imageUploaded\", fileEntry);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchOrganizationException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.users_admin.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"455873def54f5e37142c00881107b6d7b9deb52f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsaveTempImageFile(actionRequest);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchUserException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.users_admin.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException ||\n\t\t\t\t\t e instanceof UserPortraitTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UserPortraitSizeException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98107,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = saveTempImageFile(actionRequest);\n\n\t\t\t\tSessionMessages.add(actionRequest, \"imageUploaded\", fileEntry);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchUserException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.users_admin.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException ||\n\t\t\t\t\t e instanceof UserPortraitTypeException) {\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UserPortraitSizeException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"455873def54f5e37142c00881107b6d7b9deb52f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addOpenDocumentMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (isOpenInMsOfficeButtonVisible()) {\n\t\t\tString webDavURL = DLUtil.getWebDavURL(\n\t\t\t\t_themeDisplay, _fileEntry.getFolder(), _fileEntry,\n\t\t\t\tPropsValues.\n\t\t\t\t\tDL_FILE_ENTRY_OPEN_IN_MS_OFFICE_MANUAL_CHECK_IN_REQUIRED,\n\t\t\t\ttrue);\n\n\t\t\tString onClick =\n\t\t\t\t_liferayPortletResponse.getNamespace() + \"openDocument('\" +\n\t\t\t\t\twebDavURL + \"');\";\n\n\t\t\tMap<String, String> context = new HashMap<String, String>();\n\n\t\t\tcontext.put(\"namespace\", _liferayPortletResponse.getNamespace());\n\n\t\t\tcontext.put(\n\t\t\t\t\"errorMessage\", UnicodeLanguageUtil.get(\n\t\t\t\t\t_request,\n\t\t\t\t\t\"cannot-open-the-requested-document-due-to-the-following-\" +\n\t\t\t\t\t\t\"reason\"));\n\n\t\t\tString javaScript = _processFreeMarkerTemplate(\n\t\t\t\t\"/com/liferay/portlet/documentlibrary/context/dependencies\" +\n\t\t\t\t\t\"open_document_js.ftl\", context);\n\n\t\t\tJavascriptMenuItem javaScriptMenuItem = new JavascriptMenuItem();\n\n\t\t\tjavaScriptMenuItem.setIconCssClass(\"icon-file-alt\");\n\t\t\tjavaScriptMenuItem.setId(DLMenuItems.MENU_ITEM_ID_OPEN_DOCUMENT);\n\t\t\tjavaScriptMenuItem.setJavascript(javaScript);\n\t\t\tjavaScriptMenuItem.setMessage(\"open-in-ms-office\");\n\t\t\tjavaScriptMenuItem.setOnClick(onClick);\n\n\t\t\tmenuItems.add(javaScriptMenuItem);\n\t\t}\n\t}","id":98108,"modified_method":"private void _addOpenDocumentMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!isOpenInMsOfficeButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString webDavURL = DLUtil.getWebDavURL(\n\t\t\t_themeDisplay, _fileEntry.getFolder(), _fileEntry,\n\t\t\tPropsValues.\n\t\t\t\tDL_FILE_ENTRY_OPEN_IN_MS_OFFICE_MANUAL_CHECK_IN_REQUIRED,\n\t\t\ttrue);\n\n\t\tString onClick =\n\t\t\t_liferayPortletResponse.getNamespace() + \"openDocument('\" +\n\t\t\t\twebDavURL + \"');\";\n\n\t\tMap<String, String> context = new HashMap<String, String>();\n\n\t\tcontext.put(\"namespace\", _liferayPortletResponse.getNamespace());\n\n\t\tcontext.put(\n\t\t\t\"errorMessage\", UnicodeLanguageUtil.get(\n\t\t\t\t_request,\n\t\t\t\t\"cannot-open-the-requested-document-due-to-the-following-\" +\n\t\t\t\t\t\"reason\"));\n\n\t\tString javaScript = _processFreeMarkerTemplate(\n\t\t\t\"/com/liferay/portlet/documentlibrary/context/dependencies\" +\n\t\t\t\t\"open_document_js.ftl\", context);\n\n\t\tJavascriptMenuItem javaScriptMenuItem = new JavascriptMenuItem();\n\n\t\tjavaScriptMenuItem.setIconCssClass(\"icon-file-alt\");\n\t\tjavaScriptMenuItem.setId(DLMenuItems.MENU_ITEM_ID_OPEN_DOCUMENT);\n\t\tjavaScriptMenuItem.setJavascript(javaScript);\n\t\tjavaScriptMenuItem.setMessage(\"open-in-ms-office\");\n\t\tjavaScriptMenuItem.setOnClick(onClick);\n\n\t\tmenuItems.add(javaScriptMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addMoveMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (_isShowActions() && isMoveButtonVisible()) {\n\t\t\tPortletURL moveURL = _liferayPortletResponse.createRenderURL();\n\n\t\t\tmoveURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/move_entry\");\n\t\t\tmoveURL.setParameter(\n\t\t\t\t\"fileEntryIds\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\tPortletURL viewFolderURL =\n\t\t\t\t_liferayPortletResponse.createRenderURL();\n\n\t\t\tviewFolderURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/view\");\n\t\t\tviewFolderURL.setParameter(\"folderId\", String.valueOf(_folderId));\n\n\t\t\tmoveURL.setParameter(\"redirect\", viewFolderURL.toString());\n\n\t\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\t\turlMenuItem.setIconCssClass(\"icon-move\");\n\t\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_MOVE);\n\t\t\turlMenuItem.setMessage(\"move\");\n\t\t\turlMenuItem.setTarget(\"_blank\");\n\t\t\turlMenuItem.setURL(moveURL.toString());\n\n\t\t\tmenuItems.add(urlMenuItem);\n\t\t}\n\t}","id":98109,"modified_method":"private void _addMoveMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!_isShowActions() || !isMoveButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletURL moveURL = _liferayPortletResponse.createRenderURL();\n\n\t\tmoveURL.setParameter(\"struts_action\", \"/document_library/move_entry\");\n\t\tmoveURL.setParameter(\n\t\t\t\"fileEntryIds\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\tPortletURL viewFolderURL = _liferayPortletResponse.createRenderURL();\n\n\t\tviewFolderURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\tviewFolderURL.setParameter(\"folderId\", String.valueOf(_folderId));\n\n\t\tmoveURL.setParameter(\"redirect\", viewFolderURL.toString());\n\n\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\turlMenuItem.setIconCssClass(\"icon-move\");\n\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_MOVE);\n\t\turlMenuItem.setMessage(\"move\");\n\t\turlMenuItem.setTarget(\"_blank\");\n\t\turlMenuItem.setURL(moveURL.toString());\n\n\t\tmenuItems.add(urlMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addCancelCheckoutMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (_isShowActions() && isCancelCheckoutDocumentButtonVisible()) {\n\t\t\tPortletURL cancelCheckoutURL =\n\t\t\t\t_liferayPortletResponse.createActionURL();\n\n\t\t\tcancelCheckoutURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\t\tcancelCheckoutURL.setParameter(\n\t\t\t\tConstants.CMD, Constants.CANCEL_CHECKOUT);\n\t\t\tcancelCheckoutURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\tcancelCheckoutURL.setParameter(\n\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\t\turlMenuItem.setIconCssClass(\"icon-remove\");\n\t\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_CANCEL_CHECKOUT);\n\t\t\turlMenuItem.setMessage(\"cancel-checkout[document]\");\n\t\t\turlMenuItem.setURL(cancelCheckoutURL.toString());\n\n\t\t\tmenuItems.add(urlMenuItem);\n\t\t}\n\t}","id":98110,"modified_method":"private void _addCancelCheckoutMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!_isShowActions() || !isCancelCheckoutDocumentButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletURL cancelCheckoutURL =\n\t\t\t_liferayPortletResponse.createActionURL();\n\n\t\tcancelCheckoutURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\tcancelCheckoutURL.setParameter(\n\t\t\tConstants.CMD, Constants.CANCEL_CHECKOUT);\n\t\tcancelCheckoutURL.setParameter(\"redirect\", _getCurrentURL());\n\t\tcancelCheckoutURL.setParameter(\n\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\turlMenuItem.setIconCssClass(\"icon-remove\");\n\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_CANCEL_CHECKOUT);\n\t\turlMenuItem.setMessage(\"cancel-checkout[document]\");\n\t\turlMenuItem.setURL(cancelCheckoutURL.toString());\n\n\t\tmenuItems.add(urlMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addDownloadMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (isDownloadButtonVisible()) {\n\t\t\tString message =\n\t\t\t\tLanguageUtil.get(_request, \"download\") + \" (\" +\n\t\t\t\t\tTextFormatter.formatStorageSize(\n\t\t\t\t\t\t_fileEntry.getSize(), _themeDisplay.getLocale()) + \")\";\n\n\t\t\tString url = DLUtil.getDownloadURL(\n\t\t\t\t_fileEntry, _fileVersion, _themeDisplay, StringPool.BLANK,\n\t\t\t\tfalse, true);\n\n\t\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\t\turlMenuItem.setIconCssClass(\"icon-download\");\n\t\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_DOWNLOAD);\n\t\t\turlMenuItem.setMessage(message);\n\t\t\turlMenuItem.setTarget(\"_blank\");\n\t\t\turlMenuItem.setURL(url);\n\n\t\t\tmenuItems.add(urlMenuItem);\n\t\t}\n\t}","id":98111,"modified_method":"private void _addDownloadMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!isDownloadButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString message =\n\t\t\tLanguageUtil.get(_request, \"download\") + \" (\" +\n\t\t\t\tTextFormatter.formatStorageSize(\n\t\t\t\t\t_fileEntry.getSize(), _themeDisplay.getLocale()) + \")\";\n\n\t\tString url = DLUtil.getDownloadURL(\n\t\t\t_fileEntry, _fileVersion, _themeDisplay, StringPool.BLANK, false,\n\t\t\ttrue);\n\n\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\turlMenuItem.setIconCssClass(\"icon-download\");\n\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_DOWNLOAD);\n\t\turlMenuItem.setMessage(message);\n\t\turlMenuItem.setTarget(\"_blank\");\n\t\turlMenuItem.setURL(url);\n\n\t\tmenuItems.add(urlMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addCheckoutMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (_isShowActions() && isCheckoutDocumentButtonVisible()) {\n\t\t\tPortletURL checkoutURL = _liferayPortletResponse.createActionURL();\n\n\t\t\tcheckoutURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\t\tcheckoutURL.setParameter(Constants.CMD, Constants.CHECKOUT);\n\t\t\tcheckoutURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\tcheckoutURL.setParameter(\n\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\t\turlMenuItem.setIconCssClass(\"icon-unlock\");\n\t\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_CHECKOUT);\n\t\t\turlMenuItem.setMessage(\"checkout[document]\");\n\t\t\turlMenuItem.setURL(checkoutURL.toString());\n\n\t\t\tmenuItems.add(urlMenuItem);\n\t\t}\n\t}","id":98112,"modified_method":"private void _addCheckoutMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!_isShowActions() || !isCheckoutDocumentButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletURL checkoutURL = _liferayPortletResponse.createActionURL();\n\n\t\tcheckoutURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\tcheckoutURL.setParameter(Constants.CMD, Constants.CHECKOUT);\n\t\tcheckoutURL.setParameter(\"redirect\", _getCurrentURL());\n\t\tcheckoutURL.setParameter(\n\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\turlMenuItem.setIconCssClass(\"icon-unlock\");\n\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_CHECKOUT);\n\t\turlMenuItem.setMessage(\"checkout[document]\");\n\t\turlMenuItem.setURL(checkoutURL.toString());\n\n\t\tmenuItems.add(urlMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addCheckinMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (_isShowActions() && isCheckinButtonVisible()) {\n\t\t\tPortletURL checkinURL = _liferayPortletResponse.createActionURL();\n\n\t\t\tcheckinURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\t\tcheckinURL.setParameter(Constants.CMD, Constants.CHECKIN);\n\t\t\tcheckinURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\tcheckinURL.setParameter(\n\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\t\turlMenuItem.setIconCssClass(\"icon-lock\");\n\t\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_CHECKIN);\n\t\t\turlMenuItem.setMessage(\"checkin\");\n\t\t\turlMenuItem.setURL(checkinURL.toString());\n\n\t\t\tmenuItems.add(urlMenuItem);\n\t\t}\n\t}","id":98113,"modified_method":"private void _addCheckinMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!_isShowActions() || !isCheckinButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletURL checkinURL = _liferayPortletResponse.createActionURL();\n\n\t\tcheckinURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\tcheckinURL.setParameter(Constants.CMD, Constants.CHECKIN);\n\t\tcheckinURL.setParameter(\"redirect\", _getCurrentURL());\n\t\tcheckinURL.setParameter(\n\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\turlMenuItem.setIconCssClass(\"icon-lock\");\n\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_CHECKIN);\n\t\turlMenuItem.setMessage(\"checkin\");\n\t\turlMenuItem.setURL(checkinURL.toString());\n\n\t\tmenuItems.add(urlMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addDeleteMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (_isShowActions()) {\n\t\t\tif (isDeleteButtonVisible()) {\n\t\t\t\tPortletURL deleteURL =\n\t\t\t\t\t_liferayPortletResponse.createActionURL();\n\n\t\t\t\tdeleteURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\n\t\t\t\tdeleteURL.setParameter(Constants.CMD, Constants.DELETE);\n\t\t\t\tdeleteURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\t\tdeleteURL.setParameter(\n\t\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\t\tDeleteMenuItem deleteMenuItem = new DeleteMenuItem();\n\n\t\t\t\tdeleteMenuItem.setId(DLMenuItems.MENU_ITEM_ID_DELETE);\n\t\t\t\tdeleteMenuItem.setURL(deleteURL.toString());\n\n\t\t\t\tmenuItems.add(deleteMenuItem);\n\t\t\t}\n\n\t\t\tif (isMoveToTheRecycleBinButtonVisible()) {\n\t\t\t\tPortletURL deleteURL =\n\t\t\t\t\t_liferayPortletResponse.createActionURL();\n\n\t\t\t\tdeleteURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\n\t\t\t\tdeleteURL.setParameter(Constants.CMD, Constants.MOVE_TO_TRASH);\n\t\t\t\tdeleteURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\t\tdeleteURL.setParameter(\n\t\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\t\tDeleteMenuItem deleteMenuItem = new DeleteMenuItem();\n\n\t\t\t\tdeleteMenuItem.setId(DLMenuItems.MENU_ITEM_ID_DELETE);\n\t\t\t\tdeleteMenuItem.setTrash(true);\n\t\t\t\tdeleteMenuItem.setURL(deleteURL.toString());\n\n\t\t\t\tmenuItems.add(deleteMenuItem);\n\t\t\t}\n\t\t}\n\t}","id":98114,"modified_method":"private void _addDeleteMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!_isShowActions()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isDeleteButtonVisible()) {\n\t\t\tPortletURL deleteURL = _liferayPortletResponse.createActionURL();\n\n\t\t\tdeleteURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\n\t\t\tdeleteURL.setParameter(Constants.CMD, Constants.DELETE);\n\t\t\tdeleteURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\tdeleteURL.setParameter(\n\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\tDeleteMenuItem deleteMenuItem = new DeleteMenuItem();\n\n\t\t\tdeleteMenuItem.setId(DLMenuItems.MENU_ITEM_ID_DELETE);\n\t\t\tdeleteMenuItem.setURL(deleteURL.toString());\n\n\t\t\tmenuItems.add(deleteMenuItem);\n\t\t}\n\n\t\tif (isMoveToTheRecycleBinButtonVisible()) {\n\t\t\tPortletURL deleteURL = _liferayPortletResponse.createActionURL();\n\n\t\t\tdeleteURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\n\t\t\tdeleteURL.setParameter(Constants.CMD, Constants.MOVE_TO_TRASH);\n\t\t\tdeleteURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\tdeleteURL.setParameter(\n\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\tDeleteMenuItem deleteMenuItem = new DeleteMenuItem();\n\n\t\t\tdeleteMenuItem.setId(DLMenuItems.MENU_ITEM_ID_DELETE);\n\t\t\tdeleteMenuItem.setTrash(true);\n\t\t\tdeleteMenuItem.setURL(deleteURL.toString());\n\n\t\t\tmenuItems.add(deleteMenuItem);\n\t\t}\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addEditMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (_isShowActions()) {\n\t\t\tif (isEditButtonVisible()) {\n\t\t\t\tPortletURL editURL = _liferayPortletResponse.createRenderURL();\n\n\t\t\t\teditURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\t\t\teditURL.setParameter(\"redirect\", _getCurrentURL());\n\t\t\t\teditURL.setParameter(\"backURL\", _getCurrentURL());\n\t\t\t\teditURL.setParameter(\n\t\t\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\t\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\t\t\turlMenuItem.setIconCssClass(\"icon-edit\");\n\t\t\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_EDIT);\n\t\t\t\turlMenuItem.setMessage(\"edit\");\n\t\t\t\turlMenuItem.setURL(editURL.toString());\n\n\t\t\t\tmenuItems.add(urlMenuItem);\n\t\t\t}\n\t\t}\n\t}","id":98115,"modified_method":"private void _addEditMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!_isShowActions() || !isEditButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletURL editURL = _liferayPortletResponse.createRenderURL();\n\n\t\teditURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/edit_file_entry\");\n\t\teditURL.setParameter(\"redirect\", _getCurrentURL());\n\t\teditURL.setParameter(\"backURL\", _getCurrentURL());\n\t\teditURL.setParameter(\n\t\t\t\"fileEntryId\", String.valueOf(_fileEntry.getFileEntryId()));\n\n\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\turlMenuItem.setIconCssClass(\"icon-edit\");\n\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_EDIT);\n\t\turlMenuItem.setMessage(\"edit\");\n\t\turlMenuItem.setURL(editURL.toString());\n\n\t\tmenuItems.add(urlMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addPermissionsMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (_isShowActions() && isPermissionsButtonVisible()) {\n\t\t\tString permissionsURL = null;\n\n\t\t\ttry {\n\t\t\t\tpermissionsURL = PermissionsURLTag.doTag(\n\t\t\t\t\tnull, DLFileEntryConstants.getClassName(),\n\t\t\t\t\tHtmlUtil.unescape(_fileEntry.getTitle()), null,\n\t\t\t\t\tString.valueOf(_fileEntry.getFileEntryId()),\n\t\t\t\t\tLiferayWindowState.POP_UP.toString(), null, _request);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"Unable to create permissions URL\", e);\n\t\t\t}\n\n\t\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\t\turlMenuItem.setIconCssClass(\"icon-lock\");\n\t\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_PERMISSIONS);\n\t\t\turlMenuItem.setMessage(\"permissions\");\n\t\t\turlMenuItem.setMethod(\"get\");\n\t\t\turlMenuItem.setURL(permissionsURL.toString());\n\t\t\turlMenuItem.setUseDialog(true);\n\n\t\t\tmenuItems.add(urlMenuItem);\n\t\t}\n\t}","id":98116,"modified_method":"private void _addPermissionsMenuItem(List<MenuItem> menuItems)\n\t\tthrows PortalException {\n\n\t\tif (!_isShowActions() || !isPermissionsButtonVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString permissionsURL = null;\n\n\t\ttry {\n\t\t\tpermissionsURL = PermissionsURLTag.doTag(\n\t\t\t\tnull, DLFileEntryConstants.getClassName(),\n\t\t\t\tHtmlUtil.unescape(_fileEntry.getTitle()), null,\n\t\t\t\tString.valueOf(_fileEntry.getFileEntryId()),\n\t\t\t\tLiferayWindowState.POP_UP.toString(), null, _request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(\"Unable to create permissions URL\", e);\n\t\t}\n\n\t\tURLMenuItem urlMenuItem = new URLMenuItem();\n\n\t\turlMenuItem.setIconCssClass(\"icon-lock\");\n\t\turlMenuItem.setId(DLMenuItems.MENU_ITEM_ID_PERMISSIONS);\n\t\turlMenuItem.setMessage(\"permissions\");\n\t\turlMenuItem.setMethod(\"get\");\n\t\turlMenuItem.setURL(permissionsURL.toString());\n\t\turlMenuItem.setUseDialog(true);\n\n\t\tmenuItems.add(urlMenuItem);\n\t}","commit_id":"29f44cf6e1504f18ae245ee09823c743e50d2c26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\r\n     * Notification rule to store usage statistics\r\n     * @param rule\r\n     * @param doc\r\n     * @param action\r\n     * @param context\r\n     */\r\n    public void notify(XWikiNotificationRule rule, XWikiDocument doc, String action, XWikiContext context) {\r\n\r\n        if (context.getWiki().isReadOnly()) {\r\n            // the server is in read-only mode, forget about the statistics\r\n            return;\r\n        }\r\n        // Unless this is a \"view\", \"save\" or \"download\" action, we are not interested\r\n        if (!(action.equals(\"view\")||action.equals(\"save\")||action.equals(\"download\")))\r\n            return;\r\n\r\n        if (findCookie(context)) {\r\n            return;\r\n        }\r\n\r\n        // Let's save in the session the last elements view, saved\r\n        synchronized (this) {\r\n            if (!action.equals(\"download\")) {\r\n                HttpSession session = context.getRequest().getSession();\r\n                Collection actions = (Collection) session.getAttribute(\"recent_\" + action);\r\n                if (actions==null) {\r\n                    actions = new CircularFifoBuffer(context.getWiki().getXWikiPreferenceAsInt(\"recent_visits_size\", 20, context));\r\n                    session.setAttribute(\"recent_\" + action, actions);\r\n                }\r\n                String element = context.getDatabase() + \":\" + doc.getFullName();\r\n                if (actions.contains(element))\r\n                    actions.remove(element);\r\n                actions.add(element);\r\n            }\r\n        }\r\n\r\n        // Let's check if this wiki should have statistics disabled\r\n        String statsdefault = context.getWiki().Param(\"xwiki.stats.default\");\r\n        String statsactive = context.getWiki().getXWikiPreference(\"statistics\", \"\", context);\r\n        if (\"0\".equals(statsactive))\r\n            return;\r\n        // If nothing is said we use the default parameter\r\n        if ((\"\".equals(statsactive))&&(\"0\".equals(statsdefault)))\r\n            return;\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        if (store == null) return;\r\n\r\n        VisitStats vobject = findVisit(context);\r\n            // We count page views in the sessions only for the \"view\" action\r\n            if (action.equals(\"view\"))\r\n                vobject.incPageViews();\r\n            // We count \"save\" and \"download\" actions separately\r\n            else if (action.equals(\"save\"))\r\n                vobject.incPageSaves();\r\n            else if (action.equals(\"download\"))\r\n                vobject.incDownloads();\r\n\r\n            vobject.setEndDate(new Date());\r\n            try {\r\n                // In case we have store the old object\r\n                // then we need to remove it\r\n                // before saving the other one\r\n                // because the ID info have changed\r\n                VisitStats oldObject  = vobject.getOldObject();\r\n                if (oldObject!=null) {\r\n                    // Catch exception to not fail here\r\n                    try {\r\n                     store.deleteXWikiCollection(oldObject, context, true, true);\r\n                    } catch (Exception e) {}\r\n                }\r\n\r\n                store.saveXWikiCollection(vobject, context, true);\r\n            } catch (XWikiException e) {\r\n                // Statistics should never make xwiki fail !\r\n                e.printStackTrace();\r\n            }\r\n\r\n        addPageView(doc.getFullName(), action, XWikiStats.PERIOD_MONTH, store, context, vobject);\r\n        addPageView(doc.getSpace(), action, XWikiStats.PERIOD_MONTH, store, context, vobject);\r\n        addPageView(\"\", action, XWikiStats.PERIOD_MONTH, store, context, vobject);\r\n        addPageView(doc.getFullName(), action, XWikiStats.PERIOD_DAY, store, context, vobject);\r\n        addPageView(doc.getSpace(), action, XWikiStats.PERIOD_DAY, store, context, vobject);\r\n        addPageView(\"\", action, XWikiStats.PERIOD_DAY, store, context, vobject);\r\n\r\n        // In case of a \"view\" action we want to store referer info\r\n        if (action.equals(\"view\")) {\r\n            String referer = getReferer(context);\r\n            if ((referer !=null)&&(!referer.equals(\"\"))) {\r\n                // Visits of the web\r\n                RefererStats robject = new RefererStats(doc.getFullName(), referer, new Date(), XWikiStats.PERIOD_MONTH);\r\n                try {\r\n                    store.loadXWikiCollection(robject, context, true);\r\n                } catch (XWikiException e) {\r\n                }\r\n\r\n                robject.incPageViews();\r\n                try {\r\n                    store.saveXWikiCollection(robject, context, true);\r\n                } catch (XWikiException e) {\r\n                    // Statistics should never make xwiki fail !\r\n                    e.printStackTrace();\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }","id":98117,"modified_method":"/**\r\n     * Notification rule to store usage statistics\r\n     * @param rule\r\n     * @param doc\r\n     * @param action\r\n     * @param context\r\n     */\r\n    public void notify(XWikiNotificationRule rule, XWikiDocument doc, String action, XWikiContext context) {\r\n\r\n        if (context.getWiki().isReadOnly()) {\r\n            // the server is in read-only mode, forget about the statistics\r\n            return;\r\n        }\r\n        // Unless this is a \"view\", \"save\" or \"download\" action, we are not interested\r\n        if (!(action.equals(\"view\")||action.equals(\"save\")||action.equals(\"download\")))\r\n            return;\r\n\r\n        if (findCookie(context)) {\r\n            return;\r\n        }\r\n\r\n        // Let's save in the session the last elements view, saved\r\n        synchronized (this) {\r\n            if (!action.equals(\"download\")) {\r\n                HttpSession session = context.getRequest().getSession();\r\n                Collection actions = (Collection) session.getAttribute(\"recent_\" + action);\r\n                if (actions==null) {\r\n                    actions = new CircularFifoBuffer(context.getWiki().getXWikiPreferenceAsInt(\"recent_visits_size\", 20, context));\r\n                    session.setAttribute(\"recent_\" + action, actions);\r\n                }\r\n                String element = context.getDatabase() + \":\" + doc.getFullName();\r\n                if (actions.contains(element))\r\n                    actions.remove(element);\r\n                actions.add(element);\r\n            }\r\n        }\r\n\r\n        // Let's check if this wiki should have statistics disabled\r\n        String statsdefault = context.getWiki().Param(\"xwiki.stats.default\");\r\n        String statsactive = context.getWiki().getXWikiPreference(\"statistics\", \"\", context);\r\n        if (\"0\".equals(statsactive))\r\n            return;\r\n        // If nothing is said we use the default parameter\r\n        if ((\"\".equals(statsactive))&&(\"0\".equals(statsdefault)))\r\n            return;\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        if (store == null) return;\r\n\r\n        VisitStats vobject = findVisit(context);\r\n        synchronized(vobject) {\r\n            // We count page views in the sessions only for the \"view\" action\r\n            if (action.equals(\"view\"))\r\n                vobject.incPageViews();\r\n                // We count \"save\" and \"download\" actions separately\r\n            else if (action.equals(\"save\"))\r\n                vobject.incPageSaves();\r\n            else if (action.equals(\"download\"))\r\n                vobject.incDownloads();\r\n\r\n            vobject.setEndDate(new Date());\r\n            try {\r\n                // In case we have store the old object\r\n                // then we need to remove it\r\n                // before saving the other one\r\n                // because the ID info have changed\r\n                VisitStats oldObject  = vobject.getOldObject();\r\n                if (oldObject!=null) {\r\n                    // Catch exception to not fail here\r\n                    try {\r\n                        store.deleteXWikiCollection(oldObject, context, true, true);\r\n                        vobject.unrememberOldObject();\r\n                    } catch (Exception e) {}\r\n                }\r\n\r\n                store.saveXWikiCollection(vobject, context, true);\r\n            } catch (XWikiException e) {\r\n                // Statistics should never make xwiki fail !\r\n                e.printStackTrace();\r\n            }\r\n\r\n            addPageView(doc.getFullName(), action, XWikiStats.PERIOD_MONTH, store, context, vobject);\r\n            addPageView(doc.getSpace(), action, XWikiStats.PERIOD_MONTH, store, context, vobject);\r\n            addPageView(\"\", action, XWikiStats.PERIOD_MONTH, store, context, vobject);\r\n            addPageView(doc.getFullName(), action, XWikiStats.PERIOD_DAY, store, context, vobject);\r\n            addPageView(doc.getSpace(), action, XWikiStats.PERIOD_DAY, store, context, vobject);\r\n            addPageView(\"\", action, XWikiStats.PERIOD_DAY, store, context, vobject);\r\n        }\r\n\r\n        // In case of a \"view\" action we want to store referer info\r\n        if (action.equals(\"view\")) {\r\n            String referer = getReferer(context);\r\n            if ((referer !=null)&&(!referer.equals(\"\"))) {\r\n                // Visits of the web\r\n                RefererStats robject = new RefererStats(doc.getFullName(), referer, new Date(), XWikiStats.PERIOD_MONTH);\r\n                synchronized(robject) {\r\n                    try {\r\n                        store.loadXWikiCollection(robject, context, true);\r\n                    } catch (XWikiException e) {\r\n                    }\r\n\r\n                    robject.incPageViews();\r\n                    try {\r\n                        store.saveXWikiCollection(robject, context, true);\r\n                    } catch (XWikiException e) {\r\n                        // Statistics should never make xwiki fail !\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }","commit_id":"6fb98ccd60e27466309db03fc323bb108919d29c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Map<Permanent, Integer> chosenCards = new HashMap<>(2);\r\n            int maxCount = 0;\r\n            FilterNonlandPermanent filter = new FilterNonlandPermanent(\"a nonland permanent \" + controller.getName() + \" doesn't control\");\r\n            filter.add(Predicates.not(new ControllerIdPredicate(controller.getId())));\r\n            //Players each choose a legal permanent\r\n            PlayerList playerList = game.getState().getPlayerList();\r\n            while (!playerList.get().equals(controller.getId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            do {\r\n                Player player = game.getPlayer(playerList.get());\r\n                if (player != null) {\r\n                    Target target = new TargetNonlandPermanent(filter);\r\n                    target.setNotTarget(true);\r\n                    if (player.choose(Outcome.Exile, target, source.getSourceId(), game)) {\r\n                        Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n                        if (permanent != null) {\r\n                            if (chosenCards.containsKey(permanent)) {\r\n                                int count = chosenCards.get(permanent) + 1;\r\n                                if (count > maxCount) {\r\n                                    maxCount = count;\r\n                                }\r\n                                chosenCards.put(permanent, count);\r\n                            }\r\n                            else {\r\n                                if (maxCount == 0) {\r\n                                    maxCount = 1;\r\n                                }\r\n                                chosenCards.put(permanent, 1);\r\n                            }\r\n                            game.informPlayers(player.getName() + \" has chosen: \" + permanent.getName());\r\n                        }\r\n                    }\r\n                }\r\n            } while (playerList.getNextInRange(controller, game) != controller && controller.isInGame());\r\n            //Exile the card(s) with the most votes.\r\n            for (Entry<Permanent, Integer> entry : chosenCards.entrySet()) {\r\n                if (entry.getValue() == maxCount) {\r\n                    Permanent permanent = entry.getKey();\r\n                    controller.moveCardToExileWithInfo(permanent, null, \"\", source.getSourceId(), game, Zone.BATTLEFIELD);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98118,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Map<Permanent, Integer> chosenCards = new HashMap<>(2);\r\n            int maxCount = 0;\r\n            FilterNonlandPermanent filter = new FilterNonlandPermanent(\"a nonland permanent \" + controller.getName() + \" doesn't control\");\r\n            filter.add(Predicates.not(new ControllerIdPredicate(controller.getId())));\r\n            //Players each choose a legal permanent\r\n            PlayerList playerList = game.getState().getPlayerList().copy();\r\n            while (!playerList.get().equals(controller.getId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            do {\r\n                Player player = game.getPlayer(playerList.get());\r\n                if (player != null && player.isInGame()) {\r\n                    Target target = new TargetNonlandPermanent(filter);\r\n                    target.setNotTarget(true);\r\n                    if (player.choose(Outcome.Exile, target, source.getSourceId(), game)) {\r\n                        Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n                        if (permanent != null) {\r\n                            if (chosenCards.containsKey(permanent)) {\r\n                                int count = chosenCards.get(permanent) + 1;\r\n                                if (count > maxCount) {\r\n                                    maxCount = count;\r\n                                }\r\n                                chosenCards.put(permanent, count);\r\n                            }\r\n                            else {\r\n                                if (maxCount == 0) {\r\n                                    maxCount = 1;\r\n                                }\r\n                                chosenCards.put(permanent, 1);\r\n                            }\r\n                            game.informPlayers(player.getName() + \" has chosen: \" + permanent.getName());\r\n                        }\r\n                    }\r\n                }\r\n            } while (playerList.getNextInRange(controller, game) != controller && controller.isInGame());\r\n            //Exile the card(s) with the most votes.\r\n            for (Entry<Permanent, Integer> entry : chosenCards.entrySet()) {\r\n                if (entry.getValue() == maxCount) {\r\n                    Permanent permanent = entry.getKey();\r\n                    controller.moveCardToExileWithInfo(permanent, null, \"\", source.getSourceId(), game, Zone.BATTLEFIELD);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"44f3ac8117cd88fd1e50b196399a33aaa0719822","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            PlayerList playerList = game.getState().getPlayerList();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            UUID firstInactivePlayer = null;\r\n            Target target = new TargetCardInHand(new FilterPermanentCard());\r\n\r\n            while (controller.isInGame()) {\r\n                if (currentPlayer != null && controller.getInRange().contains(currentPlayer.getId())) {\r\n                    if (firstInactivePlayer == null) {\r\n                        firstInactivePlayer = currentPlayer.getId();\r\n                    }\r\n                    target.clearChosen();\r\n                    if (target.canChoose(source.getSourceId(), currentPlayer.getId(), game)\r\n                            && currentPlayer.chooseUse(outcome, \"Put permanent from your hand to play?\", game)) {\r\n                        if (target.chooseTarget(outcome, currentPlayer.getId(), source, game)) {\r\n                            Card card = game.getCard(target.getFirstTarget());\r\n                            if (card != null) {\r\n                                currentPlayer.putOntoBattlefieldWithInfo(card, game, Zone.HAND, source.getSourceId());\r\n                                firstInactivePlayer = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // get next player\r\n                playerList.getNext();\r\n                currentPlayer = game.getPlayer(playerList.get());\r\n                // if all player since this player didn't put permanent in play finish the process\r\n                if (currentPlayer.getId().equals(firstInactivePlayer)) {\r\n                    break;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98119,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            PlayerList playerList = game.getState().getPlayerList().copy();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            UUID firstInactivePlayer = null;\r\n            Target target = new TargetCardInHand(new FilterPermanentCard());\r\n\r\n            while (controller.isInGame()) {\r\n                if (firstInactivePlayer == null) {\r\n                    firstInactivePlayer = currentPlayer.getId();\r\n                }\r\n                if (currentPlayer != null && currentPlayer.isInGame() && controller.getInRange().contains(currentPlayer.getId())) {\r\n\r\n                    target.clearChosen();\r\n                    if (target.canChoose(source.getSourceId(), currentPlayer.getId(), game)\r\n                            && currentPlayer.chooseUse(outcome, \"Put permanent from your hand to play?\", game)) {\r\n                        if (target.chooseTarget(outcome, currentPlayer.getId(), source, game)) {\r\n                            Card card = game.getCard(target.getFirstTarget());\r\n                            if (card != null) {\r\n                                currentPlayer.putOntoBattlefieldWithInfo(card, game, Zone.HAND, source.getSourceId());\r\n                                firstInactivePlayer = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // get next player\r\n                playerList.getNext();\r\n                currentPlayer = game.getPlayer(playerList.get());\r\n                // if all player since this player didn't put permanent in play finish the process\r\n                if (currentPlayer.getId().equals(firstInactivePlayer)) {\r\n                    break;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"44f3ac8117cd88fd1e50b196399a33aaa0719822","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            PlayerList playerList = game.getState().getPlayerList();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            UUID firstInactivePlayer = null;\r\n            Target target = new TargetCardInHand(filter);\r\n\r\n            while (controller.isInGame()) {\r\n                if (currentPlayer != null && controller.getInRange().contains(currentPlayer.getId())) {\r\n                    if (firstInactivePlayer == null) {\r\n                        firstInactivePlayer = currentPlayer.getId();\r\n                    }\r\n                    target.clearChosen();\r\n                    if (target.canChoose(source.getSourceId(), currentPlayer.getId(), game)\r\n                            && currentPlayer.chooseUse(outcome, \"Put card from your hand to play?\", game)) {\r\n                        if (target.chooseTarget(outcome, currentPlayer.getId(), source, game)) {\r\n                            Card card = game.getCard(target.getFirstTarget());\r\n                            if (card != null) {\r\n                                currentPlayer.putOntoBattlefieldWithInfo(card, game, Zone.HAND, source.getSourceId());\r\n                                firstInactivePlayer = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // get next player\r\n                playerList.getNext();\r\n                currentPlayer = game.getPlayer(playerList.get());\r\n                // if all player since this player didn't put permanent in play finish the process\r\n                if (currentPlayer.getId().equals(firstInactivePlayer)) {\r\n                    break;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98120,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            PlayerList playerList = game.getState().getPlayerList().copy();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            UUID firstInactivePlayer = null;\r\n            Target target = new TargetCardInHand(filter);\r\n\r\n            while (controller.isInGame()) {                \r\n                if (currentPlayer != null && currentPlayer.isInGame() && controller.getInRange().contains(currentPlayer.getId())) {\r\n                    if (firstInactivePlayer == null) {\r\n                        firstInactivePlayer = currentPlayer.getId();\r\n                    }\r\n                    target.clearChosen();\r\n                    if (target.canChoose(source.getSourceId(), currentPlayer.getId(), game)\r\n                            && currentPlayer.chooseUse(outcome, \"Put card from your hand to play?\", game)) {\r\n                        if (target.chooseTarget(outcome, currentPlayer.getId(), source, game)) {\r\n                            Card card = game.getCard(target.getFirstTarget());\r\n                            if (card != null) {\r\n                                currentPlayer.putOntoBattlefieldWithInfo(card, game, Zone.HAND, source.getSourceId());\r\n                                firstInactivePlayer = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // get next player\r\n                playerList.getNext();\r\n                currentPlayer = game.getPlayer(playerList.get());\r\n                // if all player since this player didn't put permanent in play finish the process\r\n                if (currentPlayer.getId().equals(firstInactivePlayer)) {\r\n                    break;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"44f3ac8117cd88fd1e50b196399a33aaa0719822","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Card sourceCard = game.getCard(source.getSourceId());\r\n        Map<UUID, Integer> payLife = new HashMap<>();\r\n        int currentLifePaid;\r\n        int totalPaidLife;\r\n        if (controller != null) {\r\n            PlayerList playerList = game.getState().getPlayerList();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            UUID firstInactivePlayer = null;\r\n\r\n            while (controller.isInGame()) {\r\n                if (currentPlayer != null && controller.getInRange().contains(currentPlayer.getId())) {\r\n                    if (firstInactivePlayer == null) {\r\n                        firstInactivePlayer = currentPlayer.getId();\r\n                    }\r\n                    currentLifePaid = 0;\r\n                    totalPaidLife = 0;\r\n                    if (currentPlayer.chooseUse(Outcome.AIDontUseIt, \"Pay life?\", game)) {\r\n                        totalPaidLife = currentPlayer.getAmount(0, controller.getLife(), \"Pay how many life?\", game);\r\n                        if (totalPaidLife > 0) {\r\n                            currentPlayer.loseLife(totalPaidLife, game);\r\n                            if (payLife.get(currentPlayer.getId()) == null) {\r\n                                payLife.put(currentPlayer.getId(), totalPaidLife);\r\n                            } else {\r\n                                currentLifePaid = payLife.get(currentPlayer.getId());\r\n                                payLife.put(currentPlayer.getId(), currentLifePaid + totalPaidLife);\r\n                            }\r\n                        }\r\n                        game.informPlayers(new StringBuilder(sourceCard.getName()).append(\": \").append(currentPlayer.getName()).append(\" pays \").append(payLife.get(currentPlayer.getId())).append(\" life\").toString());\r\n                        firstInactivePlayer = null;\r\n                    }\r\n                }\r\n                \r\n                // get next player\r\n                playerList.getNext();\r\n                currentPlayer = game.getPlayer(playerList.get());\r\n                \r\n                // if all player since this player didn't put permanent in play finish the process\r\n                if (currentPlayer.getId().equals(firstInactivePlayer)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // create tokens according to life spent by each player\r\n            RatToken token = new RatToken();\r\n            for (Map.Entry<UUID, Integer> entry\r\n                    : payLife.entrySet()) {\r\n                Player player = game.getPlayer(entry.getKey());\r\n                if (player != null) {\r\n                    token.putOntoBattlefield(entry.getValue(), game, source.getSourceId(), player.getId());\r\n                }\r\n            }\r\n\r\n        }\r\n        return true;\r\n    }","id":98121,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Card sourceCard = game.getCard(source.getSourceId());\r\n        Map<UUID, Integer> payLife = new HashMap<>();\r\n        int currentLifePaid;\r\n        int totalPaidLife;\r\n        if (controller != null) {\r\n            PlayerList playerList = game.getState().getPlayerList().copy();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            UUID firstInactivePlayer = null;\r\n\r\n            while (controller.isInGame()) {\r\n                if (firstInactivePlayer == null) {\r\n                    firstInactivePlayer = currentPlayer.getId();\r\n                }\r\n                if (currentPlayer != null && currentPlayer.isInGame() && controller.getInRange().contains(currentPlayer.getId())) {\r\n                    currentLifePaid = 0;\r\n                    totalPaidLife = 0;\r\n                    if (currentPlayer.chooseUse(Outcome.AIDontUseIt, \"Pay life?\", game)) {\r\n                        totalPaidLife = currentPlayer.getAmount(0, controller.getLife(), \"Pay how many life?\", game);\r\n                        if (totalPaidLife > 0) {\r\n                            currentPlayer.loseLife(totalPaidLife, game);\r\n                            if (payLife.get(currentPlayer.getId()) == null) {\r\n                                payLife.put(currentPlayer.getId(), totalPaidLife);\r\n                            } else {\r\n                                currentLifePaid = payLife.get(currentPlayer.getId());\r\n                                payLife.put(currentPlayer.getId(), currentLifePaid + totalPaidLife);\r\n                            }\r\n                        }\r\n                        game.informPlayers(new StringBuilder(sourceCard.getName()).append(\": \").append(currentPlayer.getName()).append(\" pays \").append(payLife.get(currentPlayer.getId())).append(\" life\").toString());\r\n                        firstInactivePlayer = null;\r\n                    }\r\n                }\r\n                \r\n                // get next player\r\n                playerList.getNext();\r\n                currentPlayer = game.getPlayer(playerList.get());\r\n                \r\n                // if all player since this player didn't put permanent in play finish the process\r\n                if (currentPlayer.getId().equals(firstInactivePlayer)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // create tokens according to life spent by each player\r\n            RatToken token = new RatToken();\r\n            for (Map.Entry<UUID, Integer> entry\r\n                    : payLife.entrySet()) {\r\n                Player player = game.getPlayer(entry.getKey());\r\n                if (player != null) {\r\n                    token.putOntoBattlefield(entry.getValue(), game, source.getSourceId(), player.getId());\r\n                }\r\n            }\r\n\r\n        }\r\n        return true;\r\n    }","commit_id":"44f3ac8117cd88fd1e50b196399a33aaa0719822","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n\r\n            // Map of players and their piles (1,2,3) with values of UUID of the permanents\r\n            Map<UUID, Map<Integer, Set<UUID>>> playerPermanents = new LinkedHashMap<>();\r\n\r\n            PlayerList playerList = game.getState().getPlayerList();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            Player nextPlayer;\r\n            UUID firstNextPlayer = null;\r\n\r\n            while (!getNextPlayerInDirection(true, playerList, game).equals(firstNextPlayer) && controller.isInGame()) {\r\n                nextPlayer = game.getPlayer(playerList.get());\r\n                if (nextPlayer == null) {\r\n                    return false;\r\n                }\r\n                if (firstNextPlayer == null) {\r\n                    firstNextPlayer = nextPlayer.getId();\r\n                }\r\n                // if player is in range of controller he chooses 3 piles with all its permanents\r\n                if (currentPlayer != null && controller.getInRange().contains(currentPlayer.getId())) {\r\n                    Map<Integer, Set<UUID>> playerPiles = new HashMap<>();\r\n                    for (int i = 1; i < 4; i++) {\r\n                        playerPiles.put(i, new LinkedHashSet<UUID>());\r\n                    }\r\n                    playerPermanents.put(currentPlayer.getId(), playerPiles);\r\n                    for (int i = 1; i < 3; i++) {\r\n                        FilterPermanent filter = new FilterPermanent(\r\n                                new StringBuilder(\"the permanents for the \").append(i == 1 ? \"first \" : \"second \").append(\"pile\").toString());\r\n                        filter.add(new ControllerIdPredicate(currentPlayer.getId()));\r\n                        Target target;\r\n                        if (i == 1) {\r\n                            target = new TargetPermanent(0, Integer.MAX_VALUE, filter, true);\r\n                        } else {\r\n                            target = new TargetSecondPilePermanent(playerPiles.get(1), filter);\r\n                        }\r\n                        target.setRequired(false);\r\n                        currentPlayer.chooseTarget(outcome, target, source, game);\r\n                        StringBuilder message = new StringBuilder(currentPlayer.getName()).append(\" pile \").append(i).append(\": \");\r\n                        if (target.getTargets().isEmpty()) {\r\n                            message.append(\" (empty)\");\r\n                        } else {\r\n                            for (UUID permanentId : target.getTargets()) {\r\n                                Permanent permanent = game.getPermanent(permanentId);\r\n                                if (permanent != null) {\r\n                                    message.append(permanent.getName()).append(\" \");\r\n                                }\r\n                            }\r\n                        }\r\n                        game.informPlayers(message.toString());\r\n                        playerPiles.get(i).addAll(target.getTargets());\r\n                    }\r\n\r\n                    // add all permanents not targeted yet to the third pile\r\n                    StringBuilder message = new StringBuilder(currentPlayer.getName()).append(\" pile 3: \");\r\n                    for (Permanent permanent : game.getState().getBattlefield().getAllActivePermanents(currentPlayer.getId())) {\r\n                        if (!playerPiles.get(1).contains(permanent.getId()) && !playerPiles.get(2).contains(permanent.getId())) {\r\n                            playerPiles.get(3).add(permanent.getId());\r\n                            message.append(permanent.getName()).append(\" \");\r\n                        }\r\n                    }\r\n                    if (playerPiles.get(3).isEmpty()) {\r\n                        message.append(\" (empty)\");\r\n                    }\r\n                    game.informPlayers(message.toString());\r\n                }\r\n                currentPlayer = nextPlayer;\r\n            }\r\n            // Sacrifice all permanents from a pile randomly selected \r\n            for (Map.Entry<UUID, Map<Integer, Set<UUID>>> playerPiles : playerPermanents.entrySet()) {\r\n                Player player = game.getPlayer(playerPiles.getKey());\r\n                if (player != null) {\r\n                    // decide which pile to sacrifice\r\n                    int sacrificePile = rnd.nextInt(3) + 1; // random number from 1 - 3\r\n                    game.informPlayers(new StringBuilder(player.getName()).append(\" sacrifices pile number \").append(sacrificePile).toString());\r\n                    for (UUID permanentId : playerPiles.getValue().get(sacrificePile)) {\r\n                        Permanent permanent = game.getPermanent(permanentId);\r\n                        if (permanent != null) {\r\n                            permanent.sacrifice(source.getSourceId(), game);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98122,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n\r\n            // Map of players and their piles (1,2,3) with values of UUID of the permanents\r\n            Map<UUID, Map<Integer, Set<UUID>>> playerPermanents = new LinkedHashMap<>();\r\n\r\n            PlayerList playerList = game.getState().getPlayerList().copy();\r\n            while (!playerList.get().equals(source.getControllerId()) && controller.isInGame()) {\r\n                playerList.getNext();\r\n            }\r\n            Player currentPlayer = game.getPlayer(playerList.get());\r\n            Player nextPlayer;\r\n            UUID firstNextPlayer = null;\r\n\r\n            while (!getNextPlayerInDirection(true, playerList, game).equals(firstNextPlayer) && controller.isInGame()) {\r\n                nextPlayer = game.getPlayer(playerList.get());\r\n                if (nextPlayer == null) {\r\n                    return false;\r\n                }\r\n                if (firstNextPlayer == null) {\r\n                    firstNextPlayer = nextPlayer.getId();\r\n                }\r\n                if (!nextPlayer.isInGame()) {\r\n                    continue;\r\n                }\r\n                // if player is in range of controller he chooses 3 piles with all its permanents\r\n                if (currentPlayer != null && controller.getInRange().contains(currentPlayer.getId())) {\r\n                    Map<Integer, Set<UUID>> playerPiles = new HashMap<>();\r\n                    for (int i = 1; i < 4; i++) {\r\n                        playerPiles.put(i, new LinkedHashSet<UUID>());\r\n                    }\r\n                    playerPermanents.put(currentPlayer.getId(), playerPiles);\r\n                    for (int i = 1; i < 3; i++) {\r\n                        FilterPermanent filter = new FilterPermanent(\r\n                                new StringBuilder(\"the permanents for the \").append(i == 1 ? \"first \" : \"second \").append(\"pile\").toString());\r\n                        filter.add(new ControllerIdPredicate(currentPlayer.getId()));\r\n                        Target target;\r\n                        if (i == 1) {\r\n                            target = new TargetPermanent(0, Integer.MAX_VALUE, filter, true);\r\n                        } else {\r\n                            target = new TargetSecondPilePermanent(playerPiles.get(1), filter);\r\n                        }\r\n                        target.setRequired(false);\r\n                        currentPlayer.chooseTarget(outcome, target, source, game);\r\n                        StringBuilder message = new StringBuilder(currentPlayer.getName()).append(\" pile \").append(i).append(\": \");\r\n                        if (target.getTargets().isEmpty()) {\r\n                            message.append(\" (empty)\");\r\n                        } else {\r\n                            for (UUID permanentId : target.getTargets()) {\r\n                                Permanent permanent = game.getPermanent(permanentId);\r\n                                if (permanent != null) {\r\n                                    message.append(permanent.getName()).append(\" \");\r\n                                }\r\n                            }\r\n                        }\r\n                        game.informPlayers(message.toString());\r\n                        playerPiles.get(i).addAll(target.getTargets());\r\n                    }\r\n\r\n                    // add all permanents not targeted yet to the third pile\r\n                    StringBuilder message = new StringBuilder(currentPlayer.getName()).append(\" pile 3: \");\r\n                    for (Permanent permanent : game.getState().getBattlefield().getAllActivePermanents(currentPlayer.getId())) {\r\n                        if (!playerPiles.get(1).contains(permanent.getId()) && !playerPiles.get(2).contains(permanent.getId())) {\r\n                            playerPiles.get(3).add(permanent.getId());\r\n                            message.append(permanent.getName()).append(\" \");\r\n                        }\r\n                    }\r\n                    if (playerPiles.get(3).isEmpty()) {\r\n                        message.append(\" (empty)\");\r\n                    }\r\n                    game.informPlayers(message.toString());\r\n                }\r\n                currentPlayer = nextPlayer;\r\n            }\r\n            // Sacrifice all permanents from a pile randomly selected \r\n            for (Map.Entry<UUID, Map<Integer, Set<UUID>>> playerPiles : playerPermanents.entrySet()) {\r\n                Player player = game.getPlayer(playerPiles.getKey());\r\n                if (player != null) {\r\n                    // decide which pile to sacrifice\r\n                    int sacrificePile = rnd.nextInt(3) + 1; // random number from 1 - 3\r\n                    game.informPlayers(new StringBuilder(player.getName()).append(\" sacrifices pile number \").append(sacrificePile).toString());\r\n                    for (UUID permanentId : playerPiles.getValue().get(sacrificePile)) {\r\n                        Permanent permanent = game.getPermanent(permanentId);\r\n                        if (permanent != null) {\r\n                            permanent.sacrifice(source.getSourceId(), game);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"44f3ac8117cd88fd1e50b196399a33aaa0719822","url":"https://github.com/magefree/mage"},{"original_method":"private String getPositionText(Editor editor) {\n    if (!editor.isDisposed() && myStatusBar != null) {\n      StringBuilder message = new StringBuilder();\n\n      SelectionModel selectionModel = editor.getSelectionModel();\n      int caretCount = editor.getCaretModel().getCaretCount();\n      if (caretCount > 1) {\n        message.append(caretCount).append(\" carets\");\n      }\n      else {\n        LogicalPosition caret = editor.getCaretModel().getLogicalPosition();\n\n        appendLogicalPosition(caret, message);\n        if (selectionModel.hasSelection()) {\n          int len = Math.abs(selectionModel.getSelectionStart() - selectionModel.getSelectionEnd());\n          if (len != 0) message.append(\"/\").append(len);\n        }\n      }\n\n      return message.toString();\n    }\n    else {\n      return \"\";\n    }\n  }","id":98123,"modified_method":"private String getPositionText(@NotNull Editor editor) {\n    if (!editor.isDisposed() && myStatusBar != null) {\n      StringBuilder message = new StringBuilder();\n\n      SelectionModel selectionModel = editor.getSelectionModel();\n      int caretCount = editor.getCaretModel().getCaretCount();\n      if (caretCount > 1) {\n        message.append(caretCount).append(\" carets\");\n      }\n      else {\n        if (selectionModel.hasSelection()) {\n          int selectionStart = selectionModel.getSelectionStart();\n          int selectionEnd = selectionModel.getSelectionEnd();\n          if (selectionEnd > selectionStart) {\n            message.append(selectionEnd - selectionStart).append(\" chars\");\n            int selectionStartLine = editor.getDocument().getLineNumber(selectionStart);\n            int selectionEndLine = editor.getDocument().getLineNumber(selectionEnd);\n            if (selectionEndLine > selectionStartLine) {\n              message.append(\", \").append(selectionEndLine - selectionStartLine + 1).append(\" lines\");\n            }\n            message.append(\"     \");\n          }\n        }\n        LogicalPosition caret = editor.getCaretModel().getLogicalPosition();\n        message.append(caret.line + 1).append(\":\").append(caret.column + 1);\n      }\n\n      return message.toString();\n    }\n    else {\n      return \"\";\n    }\n  }","commit_id":"9f5fe860bd6603ee5d8c57ab4ed83b412abf8973","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean selectionsIntersect(CaretImpl firstCaret, CaretImpl secondCaret) {\n    return firstCaret.getSelectionStart() < secondCaret.getSelectionStart() && firstCaret.getSelectionEnd() > secondCaret.getSelectionStart()\n      || firstCaret.getSelectionStart() > secondCaret.getSelectionStart() && firstCaret.getSelectionStart() < secondCaret.getSelectionEnd()\n      || firstCaret.getSelectionStart() == secondCaret.getSelectionStart() && secondCaret.getSelectionEnd() > secondCaret.getSelectionStart() && firstCaret.getSelectionEnd() > firstCaret.getSelectionStart()\n      || (firstCaret.getSelectionStart() == firstCaret.getSelectionEnd() && firstCaret.hasVirtualSelection() || secondCaret.getSelectionStart() == secondCaret.getSelectionEnd() && secondCaret.hasVirtualSelection())\n         && (firstCaret.getSelectionStart() == secondCaret.getSelectionStart() || firstCaret.getSelectionEnd() == secondCaret.getSelectionEnd());\n  }","id":98124,"modified_method":"private static boolean selectionsIntersect(CaretImpl firstCaret, CaretImpl secondCaret) {\n    int firstStart = firstCaret.getSelectionStart();\n    int secondStart = secondCaret.getSelectionStart();\n    int firstEnd = firstCaret.getSelectionEnd();\n    int secondEnd = secondCaret.getSelectionEnd();\n    return firstStart < secondStart && firstEnd > secondStart\n      || firstStart > secondStart && firstStart < secondEnd\n      || firstStart == secondStart && secondEnd != secondStart && firstEnd > firstStart\n      || (hasPureVirtualSelection(firstCaret) || hasPureVirtualSelection(secondCaret)) && (firstStart == secondStart || firstEnd == secondEnd);\n  }","commit_id":"09f5de3c2fb6ed3fccfe4cb482e9595d75b09eb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  PsiElement findMatchingElement(PsiFile file, Editor editor) {\n    if (!file.getViewProvider().getLanguages().contains(GroovyFileType.GROOVY_LANGUAGE)) {\n      return null;\n    }\n\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if (selectionModel.hasSelection() && !selectionModel.hasBlockSelection()) {\n      TextRange selectionRange = new TextRange(selectionModel.getSelectionStart(), selectionModel.getSelectionEnd());\n      PsiElement element = GroovyRefactoringUtil\n        .findElementInRange(file, selectionModel.getSelectionStart(), selectionModel.getSelectionEnd(), PsiElement.class);\n      while (element != null && element.getTextRange() != null && selectionRange.contains(element.getTextRange())) {\n        if (predicate.satisfiedBy(element)) return element;\n        element = element.getParent();\n      }\n    }\n\n    final int position = editor.getCaretModel().getOffset();\n    PsiElement element = file.findElementAt(position);\n    while (element != null) {\n      if (predicate.satisfiedBy(element)) return element;\n      if (isStopElement(element)) break;\n      element = element.getParent();\n    }\n\n    element = file.findElementAt(position - 1);\n    while (element != null) {\n      if (predicate.satisfiedBy(element)) return element;\n      if (isStopElement(element)) return null;\n      element = element.getParent();\n    }\n\n    return null;\n  }","id":98125,"modified_method":"@Nullable\n  PsiElement findMatchingElement(PsiFile file, Editor editor) {\n    if (!file.getViewProvider().getLanguages().contains(GroovyFileType.GROOVY_LANGUAGE)) {\n      return null;\n    }\n\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if (selectionModel.hasSelection() && !selectionModel.hasBlockSelection()) {\n      int start = selectionModel.getSelectionStart();\n      int end = selectionModel.getSelectionEnd();\n\n      if (0 <= start && start <= end) {\n        TextRange selectionRange = new TextRange(start, end);\n        PsiElement element = GroovyRefactoringUtil.findElementInRange(file, start, end, PsiElement.class);\n        while (element != null && element.getTextRange() != null && selectionRange.contains(element.getTextRange())) {\n          if (predicate.satisfiedBy(element)) return element;\n          element = element.getParent();\n        }\n      }\n    }\n\n    final int position = editor.getCaretModel().getOffset();\n    PsiElement element = file.findElementAt(position);\n    while (element != null) {\n      if (predicate.satisfiedBy(element)) return element;\n      if (isStopElement(element)) break;\n      element = element.getParent();\n    }\n\n    element = file.findElementAt(position - 1);\n    while (element != null) {\n      if (predicate.satisfiedBy(element)) return element;\n      if (isStopElement(element)) return null;\n      element = element.getParent();\n    }\n\n    return null;\n  }","commit_id":"48f76aeaa7aca185dfeed02e86ce161532750374","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private LoadingCache<Map<String, ?>, Pool<SshTool>> buildSshToolPoolCacheLoader() {\n        // TODO: Appropriate numbers for maximum size and expire after access\n        // At the moment every SshMachineLocation instance creates its own pool.\n        // It might make more sense to create one pool and inject it into all SshMachineLocations.\n        LoadingCache<Map<String, ?>, Pool<SshTool>> delegate = CacheBuilder.newBuilder()\n                .maximumSize(10)\n                .expireAfterAccess(5, TimeUnit.MINUTES)\n                .recordStats()\n                .removalListener(new RemovalListener<Map<String, ?>, Pool<SshTool>>() {\n                    // TODO: Does it matter that this is synchronous? - Can closing pools cause long delays?\n                    @Override\n                    public void onRemoval(RemovalNotification<Map<String, ?>, Pool<SshTool>> notification) {\n                        Pool<SshTool> removed = notification.getValue();\n                        if (removed == null) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Pool evicted from SshTool cache is null so we can't call pool.close(). \" +\n                                        \"It's probably already been garbage collected. Eviction cause: {} \",\n                                        notification.getCause().name());\n                            }\n                        } else {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"{} evicted from SshTool cache. Eviction cause: {}\",\n                                        removed, notification.getCause().name());\n                            }\n                            try {\n                                removed.close();\n                            } catch (IOException e) {\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Exception closing \"+removed, e);\n                                }\n                            }\n                        }\n                    }\n                })\n                .build(new CacheLoader<Map<String, ?>, Pool<SshTool>>() {\n                    public Pool<SshTool> load(Map<String, ?> properties) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"{} building ssh pool for {} with properties: {}\",\n                                    new Object[] {this, getSshHostAndPort(), properties});\n                        }\n                        return buildPool(properties);\n                    }\n                });\n\n        final Set<String> reusableSshProperties = ImmutableSet.copyOf(\n                Iterables.transform(REUSABLE_SSH_PROPS, new Function<ConfigKey<?>, String>() {\n                    @Override public String apply(ConfigKey<?> input) {\n                        return input.getName();\n                    }\n                }));\n        // Groovy-eclipse compiler refused to compile `KeyTransformingSameTypeLoadingCache.from(...)`\n        return new KeyTransformingSameTypeLoadingCache<Map<String, ?>, Pool<SshTool>>(\n                delegate,\n                new Function<Map<String, ?>, Map<String, ?>>() {\n                    @Override\n                    public Map<String, ?> apply(@Nullable Map<String, ?> input) {\n                        Map<String, Object> copy = new HashMap<String, Object>(input);\n                        copy.keySet().removeAll(reusableSshProperties);\n                        return copy;\n                    }\n                });\n    }","id":98126,"modified_method":"private LoadingCache<Map<String, ?>, Pool<SshTool>> buildSshToolPoolCacheLoader() {\n        // TODO: Appropriate numbers for maximum size and expire after access\n        // At the moment every SshMachineLocation instance creates its own pool.\n        // It might make more sense to create one pool and inject it into all SshMachineLocations.\n        Duration expiryDuration = getConfig(SSH_CACHE_EXPIRY_DURATION);\n        \n        LoadingCache<Map<String, ?>, Pool<SshTool>> delegate = CacheBuilder.newBuilder()\n                .maximumSize(10)\n                .expireAfterAccess(expiryDuration.toMilliseconds(), TimeUnit.MILLISECONDS)\n                .recordStats()\n                .removalListener(new RemovalListener<Map<String, ?>, Pool<SshTool>>() {\n                    // TODO: Does it matter that this is synchronous? - Can closing pools cause long delays?\n                    @Override\n                    public void onRemoval(RemovalNotification<Map<String, ?>, Pool<SshTool>> notification) {\n                        Pool<SshTool> removed = notification.getValue();\n                        if (removed == null) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Pool evicted from SshTool cache is null so we can't call pool.close(). \" +\n                                        \"It's probably already been garbage collected. Eviction cause: {} \",\n                                        notification.getCause().name());\n                            }\n                        } else {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"{} evicted from SshTool cache. Eviction cause: {}\",\n                                        removed, notification.getCause().name());\n                            }\n                            try {\n                                removed.close();\n                            } catch (IOException e) {\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Exception closing \"+removed, e);\n                                }\n                            }\n                        }\n                    }\n                })\n                .build(new CacheLoader<Map<String, ?>, Pool<SshTool>>() {\n                    public Pool<SshTool> load(Map<String, ?> properties) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"{} building ssh pool for {} with properties: {}\",\n                                    new Object[] {this, getSshHostAndPort(), properties});\n                        }\n                        return buildPool(properties);\n                    }\n                });\n\n        final Set<String> reusableSshProperties = ImmutableSet.copyOf(\n                Iterables.transform(REUSABLE_SSH_PROPS, new Function<ConfigKey<?>, String>() {\n                    @Override public String apply(ConfigKey<?> input) {\n                        return input.getName();\n                    }\n                }));\n        // Groovy-eclipse compiler refused to compile `KeyTransformingSameTypeLoadingCache.from(...)`\n        return new KeyTransformingSameTypeLoadingCache<Map<String, ?>, Pool<SshTool>>(\n                delegate,\n                new Function<Map<String, ?>, Map<String, ?>>() {\n                    @Override\n                    public Map<String, ?> apply(@Nullable Map<String, ?> input) {\n                        Map<String, Object> copy = new HashMap<String, Object>(input);\n                        copy.keySet().removeAll(reusableSshProperties);\n                        return copy;\n                    }\n                });\n    }","commit_id":"1187d2ad285c07d6f5df929fe8cd20c2477cfd15","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void close() throws IOException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"{} invalidating all entries in ssh pool cache. Final stats: {}\", this, sshPoolCache.stats());\n        }\n        sshPoolCache.invalidateAll();\n    }","id":98127,"modified_method":"@Override\n    public void close() throws IOException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"{} invalidating all entries in ssh pool cache. Final stats: {}\", this, sshPoolCache.stats());\n        }\n        sshPoolCache.invalidateAll();\n        if (cleanupTask != null) cleanupTask.cancel(false);\n    }","commit_id":"1187d2ad285c07d6f5df929fe8cd20c2477cfd15","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public SshMachineLocation(Map properties) {\n        super(properties);\n        usedPorts = (usedPorts != null) ? Sets.newLinkedHashSet(usedPorts) : Sets.<Integer>newLinkedHashSet();\n        sshPoolCache = buildSshToolPoolCacheLoader();\n    }","id":98128,"modified_method":"public SshMachineLocation(Map properties) {\n        super(properties);\n        usedPorts = (usedPorts != null) ? Sets.newLinkedHashSet(usedPorts) : Sets.<Integer>newLinkedHashSet();\n    }","commit_id":"1187d2ad285c07d6f5df929fe8cd20c2477cfd15","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@BeforeMethod(alwaysRun=true)\n    public void setUp() throws Exception {\n        host = new SshMachineLocation(MutableMap.of(\n                \"address\", InetAddress.getLocalHost(),\n                SshTool.PROP_TOOL_CLASS, RecordingSshjTool.class.getName()));\n    }","id":98129,"modified_method":"@BeforeMethod(alwaysRun=true)\n    public void setUp() throws Exception {\n        managementContext = new LocalManagementContext();\n        host = managementContext.getLocationManager().createLocation(LocationSpec.create(SshMachineLocation.class)\n                .configure(\"address\", InetAddress.getLocalHost())\n                .configure(SshTool.PROP_TOOL_CLASS, RecordingSshjTool.class.getName()));\n    }","commit_id":"1187d2ad285c07d6f5df929fe8cd20c2477cfd15","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void reset() {\n            RecordingSshjTool.connectionCount = 0;\n        }","id":98130,"modified_method":"public static void reset() {\n            connectionCount = 0;\n            disconnectionCount.set(0);\n        }","commit_id":"1187d2ad285c07d6f5df929fe8cd20c2477cfd15","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@AfterMethod(alwaysRun=true)\n    public void tearDown() throws Exception {\n        if (host != null) Streams.closeQuietly(host);\n        RecordingSshjTool.reset();\n    }","id":98131,"modified_method":"@AfterMethod(alwaysRun=true)\n    public void tearDown() throws Exception {\n        if (host != null) Streams.closeQuietly(host);\n        if (managementContext != null) Entities.destroyAll(managementContext);\n        RecordingSshjTool.reset();\n    }","commit_id":"1187d2ad285c07d6f5df929fe8cd20c2477cfd15","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups=\"Integration\")\n    public void testUsesCustomControllerSpec() {\n        EntitySpec<NginxController> controllerSpec = EntitySpec.create(NginxController.class).displayName(\"mycustom\");\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 0)\n                .configure(ControlledDynamicWebAppCluster.CONTROLLER_SPEC, controllerSpec)\n                .configure(\"factory\", new JBoss7ServerFactory(MutableMap.of(\"war\", warUrl.toString()))));\n        app.start(locs);\n        LoadBalancer controller = cluster.getController();\n        \n        EntityTestUtils.assertAttributeEqualsEventually(controller, NginxController.SERVICE_UP, true);\n        assertEquals(controller.getDisplayName(), \"mycustom\");\n\n        // Stopping cluster should stop the controller (because it created it)\n        cluster.stop();\n        EntityTestUtils.assertAttributeEquals(controller, NginxController.SERVICE_UP, false);\n    }","id":98132,"modified_method":"@Test(groups=\"Integration\")\n    public void testUsesCustomControllerSpec() {\n        EntitySpec<NginxController> controllerSpec = EntitySpec.create(NginxController.class).displayName(\"mycustom\");\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 0)\n                .configure(ControlledDynamicWebAppCluster.CONTROLLER_SPEC, controllerSpec)\n                .configure(\"memberSpec\", EntitySpec.create(JBoss7Server.class).configure(\"war\", warUrl.toString())));\n        app.start(locs);\n        LoadBalancer controller = cluster.getController();\n        \n        EntityTestUtils.assertAttributeEqualsEventually(controller, NginxController.SERVICE_UP, true);\n        assertEquals(controller.getDisplayName(), \"mycustom\");\n\n        // Stopping cluster should stop the controller (because it created it)\n        cluster.stop();\n        EntityTestUtils.assertAttributeEquals(controller, NginxController.SERVICE_UP, false);\n    }","commit_id":"28e6c8e75b5a52da369c4f5bf40f83574ea009e1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups=\"Integration\")\n    public void testSetsToplevelHostnameFromController() {\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 1)\n                .configure(\"factory\", new JBoss7ServerFactory(MutableMap.of(\"war\", warUrl.toString()))));\n        app.start(locs);\n\n        String expectedHostname = cluster.getController().getAttribute(LoadBalancer.HOSTNAME);\n        String expectedRootUrl = cluster.getController().getAttribute(LoadBalancer.ROOT_URL);\n        boolean expectedServiceUp = true;\n        \n        assertNotNull(expectedHostname);\n        assertNotNull(expectedRootUrl);\n        \n        EntityTestUtils.assertAttributeEqualsEventually(MutableMap.of(\"timeout\", TIMEOUT_MS), cluster, ControlledDynamicWebAppCluster.HOSTNAME, expectedHostname);\n        EntityTestUtils.assertAttributeEqualsEventually(MutableMap.of(\"timeout\", TIMEOUT_MS), cluster, ControlledDynamicWebAppCluster.ROOT_URL, expectedRootUrl);\n        EntityTestUtils.assertAttributeEqualsEventually(MutableMap.of(\"timeout\", TIMEOUT_MS), cluster, ControlledDynamicWebAppCluster.SERVICE_UP, expectedServiceUp);\n    }","id":98133,"modified_method":"@Test(groups=\"Integration\")\n    public void testSetsToplevelHostnameFromController() {\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 1)\n                .configure(\"memberSpec\", EntitySpec.create(JBoss7Server.class).configure(\"war\", warUrl.toString())));\n        app.start(locs);\n\n        String expectedHostname = cluster.getController().getAttribute(LoadBalancer.HOSTNAME);\n        String expectedRootUrl = cluster.getController().getAttribute(LoadBalancer.ROOT_URL);\n        boolean expectedServiceUp = true;\n        \n        assertNotNull(expectedHostname);\n        assertNotNull(expectedRootUrl);\n        \n        EntityTestUtils.assertAttributeEqualsEventually(MutableMap.of(\"timeout\", TIMEOUT_MS), cluster, ControlledDynamicWebAppCluster.HOSTNAME, expectedHostname);\n        EntityTestUtils.assertAttributeEqualsEventually(MutableMap.of(\"timeout\", TIMEOUT_MS), cluster, ControlledDynamicWebAppCluster.ROOT_URL, expectedRootUrl);\n        EntityTestUtils.assertAttributeEqualsEventually(MutableMap.of(\"timeout\", TIMEOUT_MS), cluster, ControlledDynamicWebAppCluster.SERVICE_UP, expectedServiceUp);\n    }","commit_id":"28e6c8e75b5a52da369c4f5bf40f83574ea009e1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups=\"Integration\")\n    public void testUsesCustomController() {\n        NginxController controller = app.createAndManageChild(EntitySpec.create(NginxController.class).displayName(\"mycustom\"));\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 0)\n                .configure(ControlledDynamicWebAppCluster.CONTROLLER, controller)\n                .configure(\"factory\", new JBoss7ServerFactory(MutableMap.of(\"war\", warUrl.toString()))));\n        app.start(locs);\n\n        EntityTestUtils.assertAttributeEqualsEventually(controller, NginxController.SERVICE_UP, true);\n        assertEquals(cluster.getController(), controller);\n\n        // Stopping cluster should not stop controller (because it didn't create it)\n        cluster.stop();\n        EntityTestUtils.assertAttributeEquals(controller, NginxController.SERVICE_UP, true);\n    }","id":98134,"modified_method":"@Test(groups=\"Integration\")\n    public void testUsesCustomController() {\n        NginxController controller = app.createAndManageChild(EntitySpec.create(NginxController.class).displayName(\"mycustom\"));\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 0)\n                .configure(ControlledDynamicWebAppCluster.CONTROLLER, controller)\n                .configure(\"memberSpec\", EntitySpec.create(JBoss7Server.class).configure(\"war\", warUrl.toString())));\n        app.start(locs);\n\n        EntityTestUtils.assertAttributeEqualsEventually(controller, NginxController.SERVICE_UP, true);\n        assertEquals(cluster.getController(), controller);\n\n        // Stopping cluster should not stop controller (because it didn't create it)\n        cluster.stop();\n        EntityTestUtils.assertAttributeEquals(controller, NginxController.SERVICE_UP, true);\n    }","commit_id":"28e6c8e75b5a52da369c4f5bf40f83574ea009e1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups=\"Integration\")\n    public void testConfiguresController() {\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 1)\n                .configure(\"factory\", new JBoss7ServerFactory(MutableMap.of(\"war\", warUrl.toString()))));\n        app.start(locs);\n\n        String url = cluster.getController().getAttribute(NginxController.ROOT_URL);\n        HttpTestUtils.assertHttpStatusCodeEventuallyEquals(url, 200);\n        HttpTestUtils.assertContentEventuallyContainsText(url, \"Hello\");\n    }","id":98135,"modified_method":"@Test(groups=\"Integration\")\n    public void testConfiguresController() {\n        ControlledDynamicWebAppCluster cluster = app.createAndManageChild(EntitySpec.create(ControlledDynamicWebAppCluster.class)\n                .configure(\"initialSize\", 1)\n                .configure(\"memberSpec\", EntitySpec.create(JBoss7Server.class).configure(\"war\", warUrl.toString())));\n        app.start(locs);\n\n        String url = cluster.getController().getAttribute(NginxController.ROOT_URL);\n        HttpTestUtils.assertHttpStatusCodeEventuallyEquals(url, 200);\n        HttpTestUtils.assertContentEventuallyContainsText(url, \"Hello\");\n    }","commit_id":"28e6c8e75b5a52da369c4f5bf40f83574ea009e1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\")\n    public void testRebindsToRunningCluster() throws Exception {\n        DynamicWebAppCluster origCluster = origApp.createAndManageChild(EntitySpec.create(DynamicWebAppCluster.class)\n                .configure(\"factory\", new JBoss7ServerFactory(MutableMap.of(\"war\", warUrl.toString())))\n\t\t\t\t.configure(\"initialSize\", 1));\n    \t\n        origApp.start(ImmutableList.of(localhostProvisioningLocation));\n        JBoss7Server origJboss = (JBoss7Server) Iterables.find(origCluster.getChildren(), Predicates.instanceOf(JBoss7Server.class));\n        String jbossUrl = origJboss.getAttribute(JBoss7Server.ROOT_URL);\n        \n        assertHttpStatusCodeEventuallyEquals(jbossUrl, 200);\n        WebAppMonitor monitor = newWebAppMonitor(jbossUrl);\n        \n        // Rebind\n        newApp = rebind();\n        DynamicWebAppCluster newCluster = (DynamicWebAppCluster) Iterables.find(newApp.getChildren(), Predicates.instanceOf(DynamicWebAppCluster.class));\n\n        assertHttpStatusCodeEquals(jbossUrl, 200);\n\n        // Confirm the cluster is usable: we can scale-up\n        assertEquals(newCluster.getCurrentSize(), (Integer)1);\n        newCluster.resize(2);\n\n        Iterable<Entity> newJbosses = Iterables.filter(newCluster.getChildren(), Predicates.instanceOf(JBoss7Server.class));\n        assertEquals(Iterables.size(newJbosses), 2);\n        for (Entity j : newJbosses) {\n            assertHttpStatusCodeEventuallyEquals(j.getAttribute(JBoss7Server.ROOT_URL), 200);\n        }\n\n        // Ensure while doing all of this the original jboss server remained reachable\n        assertEquals(monitor.getFailures(), 0);\n        \n        // Ensure cluster is usable: we can scale back to stop the original jboss server\n        newCluster.resize(0);\n        \n        assertUrlUnreachableEventually(jbossUrl);\n    }","id":98136,"modified_method":"@Test(groups = \"Integration\")\n    public void testRebindsToRunningCluster() throws Exception {\n        DynamicWebAppCluster origCluster = origApp.createAndManageChild(EntitySpec.create(DynamicWebAppCluster.class)\n                .configure(\"memberSpec\", EntitySpec.create(JBoss7Server.class).configure(\"war\", warUrl.toString()))\n\t\t\t\t.configure(\"initialSize\", 1));\n    \t\n        origApp.start(ImmutableList.of(localhostProvisioningLocation));\n        JBoss7Server origJboss = (JBoss7Server) Iterables.find(origCluster.getChildren(), Predicates.instanceOf(JBoss7Server.class));\n        String jbossUrl = origJboss.getAttribute(JBoss7Server.ROOT_URL);\n        \n        assertHttpStatusCodeEventuallyEquals(jbossUrl, 200);\n        WebAppMonitor monitor = newWebAppMonitor(jbossUrl);\n        \n        // Rebind\n        newApp = rebind();\n        DynamicWebAppCluster newCluster = (DynamicWebAppCluster) Iterables.find(newApp.getChildren(), Predicates.instanceOf(DynamicWebAppCluster.class));\n\n        assertHttpStatusCodeEquals(jbossUrl, 200);\n\n        // Confirm the cluster is usable: we can scale-up\n        assertEquals(newCluster.getCurrentSize(), (Integer)1);\n        newCluster.resize(2);\n\n        Iterable<Entity> newJbosses = Iterables.filter(newCluster.getChildren(), Predicates.instanceOf(JBoss7Server.class));\n        assertEquals(Iterables.size(newJbosses), 2);\n        for (Entity j : newJbosses) {\n            assertHttpStatusCodeEventuallyEquals(j.getAttribute(JBoss7Server.ROOT_URL), 200);\n        }\n\n        // Ensure while doing all of this the original jboss server remained reachable\n        assertEquals(monitor.getFailures(), 0);\n        \n        // Ensure cluster is usable: we can scale back to stop the original jboss server\n        newCluster.resize(0);\n        \n        assertUrlUnreachableEventually(jbossUrl);\n    }","commit_id":"28e6c8e75b5a52da369c4f5bf40f83574ea009e1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups=\"Integration\")\n    public void testMachineUsableAfterRebind() throws Exception {\n        origApp.start(ImmutableList.of(origLoc));\n\n        assertEquals(origLoc.execScript(Collections.<String,Object>emptyMap(), \"mysummary\", ImmutableList.of(\"true\")), 0);\n\n        newApp = (TestApplication) rebind();\n        SshMachineLocation newLoc = (SshMachineLocation) Iterables.getOnlyElement(newApp.getLocations(), 0);\n        \n        assertEquals(newLoc.execScript(Collections.<String,Object>emptyMap(), \"mysummary\", ImmutableList.of(\"true\")), 0);\n    }","id":98137,"modified_method":"@Test(groups=\"Integration\")\n    public void testMachineUsableAfterRebind() throws Exception {\n        origApp.start(ImmutableList.of(origLoc));\n\n        assertEquals(origChildLoc.execScript(Collections.<String,Object>emptyMap(), \"mysummary\", ImmutableList.of(\"true\")), 0);\n\n        newApp = (TestApplication) rebind();\n        FixedListMachineProvisioningLocation<SshMachineLocation> newLoc = (FixedListMachineProvisioningLocation<SshMachineLocation>) Iterables.getOnlyElement(newApp.getLocations(), 0);\n        SshMachineLocation newChildLoc = (SshMachineLocation) Iterables.get(newLoc.getChildren(), 0);\n        \n        assertEquals(newChildLoc.execScript(Collections.<String,Object>emptyMap(), \"mysummary\", ImmutableList.of(\"true\")), 0);\n    }","commit_id":"eafca55f0b4201d08740ed28e8f5b1b6396088b4","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@BeforeMethod(alwaysRun=true)\n    public void setUp() throws Exception {\n        mementoDir = Files.createTempDir();\n        origManagementContext = RebindTestUtils.newPersistingManagementContext(mementoDir, classLoader, 1);\n        origApp = ApplicationBuilder.newManagedApp(EntitySpec.create(TestApplication.class), origManagementContext);\n        //FIXME Getting NPE with user being null (before rebind!)\n        //origLoc = new SshMachineLocation(MutableMap.of(\"address\", \"localhost\"));\n        origLoc = new SshMachineLocation(MutableMap.of(\"address\", \"localhost\", \"user\", System.getProperty(\"user.name\")));\n    }","id":98138,"modified_method":"@BeforeMethod(alwaysRun=true)\n    public void setUp() throws Exception {\n        mementoDir = Files.createTempDir();\n        origManagementContext = RebindTestUtils.newPersistingManagementContext(mementoDir, classLoader, 1);\n        origApp = ApplicationBuilder.newManagedApp(EntitySpec.create(TestApplication.class), origManagementContext);\n        //FIXME Getting NPE with user being null (before rebind!)\n        //origLoc = new SshMachineLocation(MutableMap.of(\"address\", \"localhost\"));\n        origChildLoc = origManagementContext.getLocationManager().createLocation(LocationSpec.create(SshMachineLocation.class)\n                .configure(\"user\", System.getProperty(\"user.name\"))\n                .configure(\"address\", \"localhost\"));\n        origLoc = origManagementContext.getLocationManager().createLocation(LocationSpec.create(FixedListMachineProvisioningLocation.class)\n                .configure(\"machines\", ImmutableList.of(origChildLoc)));\n    }","commit_id":"eafca55f0b4201d08740ed28e8f5b1b6396088b4","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public ConceptTreeNode(IOperationContext operationContext, SNode node) {\n    super(operationContext);\n    myNode = node;\n\n    SNode concept = getSNode();\n    setIcon(IconManager.getIconFor(concept));\n    setNodeIdentifier(concept.getName());\n  }","id":98139,"modified_method":"public ConceptTreeNode(IOperationContext operationContext, SNode node) {\n    super(operationContext);\n    myNode = node;\n\n    SNode concept = getSNode();\n    if (concept != null) {\n      setIcon(IconManager.getIconFor(concept));\n      setNodeIdentifier(concept.getName());\n    } else {\n      setNodeIdentifier(myNode.getConceptFqName());\n    }\n  }","commit_id":"330fc938c0943b6a6ab8d0ce8699423011af183e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doubleClick() {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        SNode concept = getSNode();\n        Project project = getOperationContext().getProject();\n        new MPSEditorOpener(project).editNode(concept, ModuleContext.create(concept,project));\n      }\n    });\n  }","id":98140,"modified_method":"public void doubleClick() {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        SNode concept = getSNode();\n        if (concept == null) return;\n        Project project = getOperationContext().getProject();\n        new MPSEditorOpener(project).editNode(concept, ModuleContext.create(concept, project));\n      }\n    });\n  }","commit_id":"330fc938c0943b6a6ab8d0ce8699423011af183e","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Sets a new Systray icon.\n     * \n     * @param image the icon to set.\n     */\n    public void setSystrayIcon(byte[] image)\n    {\n        this.trayIcon.setIcon(new ImageIcon(image));\n    }","id":98141,"modified_method":"/**\n     * Sets a new Systray icon.\n     * \n     * @param image the icon to set.\n     */\n    public void setSystrayIcon(byte[] image)\n    {\n        if (image != null)\n            this.trayIcon.setIcon(new ImageIcon(image));\n    }","commit_id":"83b841bb408bf61f914c94c10fbbe29d6c70d7ed","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method. Returns this panel that\n     * has been configured to display a chat contact.\n     *\n     * @param list the source list\n     * @param value the value of the current cell\n     * @param index the index of the current cell in the source list\n     * @param isSelected indicates if this cell is selected\n     * @param cellHasFocus indicates if this cell is focused\n     * \n     * @return this panel\n     */\n    @Override\n    public Component getListCellRendererComponent(  JList list,\n                                                    Object value,\n                                                    int index,\n                                                    boolean isSelected,\n                                                    boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.rightLabel.setIcon(null);\n\n        final ChatContact chatContact = (ChatContact) value;\n        ChatRoomMember member = null;\n        \n        if (chatContact.getDescriptor() instanceof ChatRoomMember)\n            member = (ChatRoomMember) chatContact.getDescriptor();\n\n        this.setPreferredSize(new Dimension(20, 30));\n\n        String displayName = chatContact.getName();\n\n        if (displayName == null || displayName.length() < 1)\n        {\n            displayName = GuiActivator.getResources()\n                .getI18NString(\"service.gui.UNKNOWN\");\n        }\n\n        this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n        this.nameLabel.setText(displayName);\n\n        if(member != null)\n            if(member.getRole() != null)\n                this.nameLabel.setIcon(\n                    ChatContactRoleIcon.getRoleIcon(member.getRole()));\n\n        if (contactForegroundColor != null)\n            this.nameLabel.setForeground(contactForegroundColor);\n\n        this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 1));\n\n        ImageIcon avatar = chatContact.getAvatar();\n\n        if (avatar != null)\n            this.rightLabel.setIcon(avatar);\n        else if (member != null)\n        {\n            if(chatContact.getName().equals(\n                    member.getChatRoom().getUserNickname()))\n            {\n                // Try to retrieve local user avatar:\n                OperationSetServerStoredAccountInfo opSet\n                    = member.getChatRoom().getParentProvider().getOperationSet(\n                        OperationSetServerStoredAccountInfo.class);\n\n                Iterator<GenericDetail> itr = opSet.getAllAvailableDetails();\n                while(itr.hasNext())\n                {\n                    GenericDetail detail = itr.next();\n                    if(detail instanceof BinaryDetail)\n                    {\n                        BinaryDetail bin = (BinaryDetail)detail;\n                        if(bin.getBytes() != null)\n                            this.rightLabel.setIcon(\n                                ImageUtils.getScaledRoundedIcon(\n                                    bin.getBytes(), 25, 25));\n                        break;\n                    }\n                }\n                ChatRoomMemberRole role = member.getChatRoom().getUserRole();\n                if (role != null)\n                    this.nameLabel.setIcon(\n                        ChatContactRoleIcon.getRoleIcon(role));\n            }\n            else\n            {\n                // Try to retrieve participant avatar:\n                OperationSetPersistentPresence opSet\n                    = member.getChatRoom().getParentProvider().getOperationSet(\n                    OperationSetPersistentPresence.class);\n\n                Contact c = opSet.findContactByID(member.getContactAddress());\n\n                if(opSet != null && c != null && c.getImage() != null)\n                    this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(\n                            c.getImage(), 25, 25));\n            }\n        }\n\n        // We should set the bounds of the cell explicitly in order to\n        // make getComponentAt work properly.\n        this.setBounds(0, 0, list.getWidth() - 2, 30);\n\n        this.nameLabel.setBounds(\n                    0, 0, list.getWidth() - 28, 17);\n\n        this.rightLabel.setBounds(\n            list.getWidth() - 28, 0, 25, 30);\n\n        this.isLeaf = true;\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","id":98142,"modified_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method. Returns this panel that\n     * has been configured to display a chat contact.\n     *\n     * @param list the source list\n     * @param value the value of the current cell\n     * @param index the index of the current cell in the source list\n     * @param isSelected indicates if this cell is selected\n     * @param cellHasFocus indicates if this cell is focused\n     * \n     * @return this panel\n     */\n    @Override\n    public Component getListCellRendererComponent(  JList list,\n                                                    Object value,\n                                                    int index,\n                                                    boolean isSelected,\n                                                    boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.rightLabel.setIcon(null);\n\n        final ChatContact chatContact = (ChatContact) value;\n        ChatRoomMember member = null;\n        \n        if (chatContact.getDescriptor() instanceof ChatRoomMember)\n            member = (ChatRoomMember) chatContact.getDescriptor();\n\n        this.setPreferredSize(new Dimension(20, 30));\n\n        String displayName = chatContact.getName();\n\n        if (displayName == null || displayName.length() < 1)\n        {\n            displayName = GuiActivator.getResources()\n                .getI18NString(\"service.gui.UNKNOWN\");\n        }\n\n        this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n        this.nameLabel.setText(displayName);\n\n        if(member != null)\n        {\n            ChatRoomMemberRole memberRole = member.getRole();\n\n            if(memberRole != null)\n                this.nameLabel.setIcon(\n                    ChatContactRoleIcon.getRoleIcon(memberRole));\n        }\n\n        if (contactForegroundColor != null)\n            this.nameLabel.setForeground(contactForegroundColor);\n\n        this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 1));\n\n        ImageIcon avatar = chatContact.getAvatar();\n\n        if (avatar != null)\n            this.rightLabel.setIcon(avatar);\n        else if (member != null)\n        {\n            ChatRoom memberChatRoom = member.getChatRoom();\n            ProtocolProviderService protocolProvider\n                = memberChatRoom.getParentProvider();\n\n            if(chatContact.getName().equals(\n                    memberChatRoom.getUserNickname()))\n            {\n                // Try to retrieve local user avatar:\n                OperationSetServerStoredAccountInfo opSet\n                    = protocolProvider.getOperationSet(\n                        OperationSetServerStoredAccountInfo.class);\n\n                if (opSet != null)\n                {\n                    Iterator<GenericDetail> itr\n                        = opSet.getAllAvailableDetails();\n\n                    while(itr.hasNext())\n                    {\n                        GenericDetail detail = itr.next();\n\n                        if(detail instanceof BinaryDetail)\n                        {\n                            BinaryDetail bin = (BinaryDetail)detail;\n                            byte[] binBytes = bin.getBytes();\n\n                            if(binBytes != null)\n                                this.rightLabel.setIcon(\n                                    ImageUtils.getScaledRoundedIcon(\n                                        binBytes, 25, 25));\n                            break;\n                        }\n                    }\n                }\n\n                ChatRoomMemberRole role;\n\n                /*\n                 * XXX I don't know why ChatRoom#getUserRole() would not be\n                 * implemented when ChatRoomMember#getRole() is or why the\n                 * former would exist at all as anything else but as a\n                 * convenience delegating to the latter, but IRC seems to be the\n                 * case and the whole IRC channel painting fails because of it.\n                 */\n                try\n                {\n                    role = memberChatRoom.getUserRole();\n                }\n                catch (UnsupportedOperationException uoex)\n                {\n                    role = member.getRole();\n                }\n\n                if (role != null)\n                    this.nameLabel.setIcon(\n                        ChatContactRoleIcon.getRoleIcon(role));\n            }\n            else\n            {\n                // Try to retrieve participant avatar:\n                OperationSetPersistentPresence opSet\n                    = protocolProvider.getOperationSet(\n                    OperationSetPersistentPresence.class);\n\n                if (opSet != null)\n                {\n                    Contact c\n                        = opSet.findContactByID(member.getContactAddress());\n\n                    if (c != null)\n                    {\n                        byte[] cImage = c.getImage();\n\n                        if (cImage != null)\n                            this.rightLabel.setIcon(\n                                    ImageUtils.getScaledRoundedIcon(\n                                            cImage, 25, 25));\n                    }\n                }\n            }\n        }\n\n        // We should set the bounds of the cell explicitly in order to\n        // make getComponentAt work properly.\n        this.setBounds(0, 0, list.getWidth() - 2, 30);\n\n        this.nameLabel.setBounds(\n                    0, 0, list.getWidth() - 28, 17);\n\n        this.rightLabel.setBounds(\n            list.getWidth() - 28, 0, 25, 30);\n\n        this.isLeaf = true;\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","commit_id":"ab7546e2c64d91d615812165f4afc785c5a090d6","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile file = PlatformDataKeys.VIRTUAL_FILE.getData(dataContext);\n    final Presentation presentation = e.getPresentation();\n    final EnforcedPlainTextFileTypeManager typeManager = EnforcedPlainTextFileTypeManager.getInstance();\n    if (typeManager == null || file == null || file.isDirectory()) {\n      presentation.setVisible(false);\n      return;\n    }\n    if (typeManager.isMarkedAsPlainText(file)) {\n      presentation.setVisible(true);\n      FileType originalType = FileTypeManager.getInstance().getFileTypeByFileName(file.getName());\n      presentation.setText(ActionsBundle.actionText(\"MarkAsOriginalTypeAction\") + \" \" + originalType.getName());\n      presentation.setIcon(originalType.getIcon());\n    }\n    else {\n      presentation.setVisible(false);\n    }\n  }","id":98143,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile[] selectedFiles = PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n    final Presentation presentation = e.getPresentation();\n    final EnforcedPlainTextFileTypeManager typeManager = EnforcedPlainTextFileTypeManager.getInstance();\n    presentation.setVisible(false);\n    if (typeManager == null || selectedFiles == null || selectedFiles.length == 0) {\n      return;\n    }\n    FileType originalType = null;\n    for (VirtualFile file : selectedFiles) {\n      if (typeManager.isMarkedAsPlainText(file)) {\n        FileType fileType = FileTypeManager.getInstance().getFileTypeByFileName(file.getName());\n        if (originalType == null) {\n          originalType = fileType;\n        }\n        else if (fileType != originalType) {\n          return;\n        }\n      }\n      else {\n        return;\n      }\n    }\n    if (originalType == null) return;\n    presentation.setVisible(true);\n    presentation.setText(ActionsBundle.actionText(\"MarkAsOriginalTypeAction\") + \" \" + originalType.getName());\n    presentation.setIcon(originalType.getIcon());\n  }","commit_id":"ff650f89fd63b1fc23acfa14067a17021b580311","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile file = PlatformDataKeys.VIRTUAL_FILE.getData(dataContext);\n    if (file == null || file.isDirectory()) return;\n    unmarkPlainText(file);\n  }","id":98144,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile[] selectedFiles = PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n    if (selectedFiles == null || selectedFiles.length == 0) return;\n    for (VirtualFile file : selectedFiles) {\n      if (file != null && !file.isDirectory()) {\n        unmarkPlainText(file);\n      }\n    }\n  }","commit_id":"ff650f89fd63b1fc23acfa14067a17021b580311","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile file = PlatformDataKeys.VIRTUAL_FILE.getData(dataContext);\n    if (file == null || file.isDirectory()) return;\n    markAsPlainText(file);\n  }","id":98145,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile[] selectedFiles = PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n    if (selectedFiles == null || selectedFiles.length == 0) return;\n    for (VirtualFile file : selectedFiles) {\n      if (file != null && !file.isDirectory()) {\n        markAsPlainText(file);\n      }\n    }\n  }","commit_id":"ff650f89fd63b1fc23acfa14067a17021b580311","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void markAsPlainText(@NotNull VirtualFile file) {\n    EnforcedPlainTextFileTypeManager typeManager = EnforcedPlainTextFileTypeManager.getInstance();\n    if (typeManager != null) typeManager.markAsPlainText(file);\n  }","id":98146,"modified_method":"private static void markAsPlainText(@NotNull VirtualFile file) {\n    EnforcedPlainTextFileTypeManager typeManager = EnforcedPlainTextFileTypeManager.getInstance();\n    if (typeManager != null && !typeManager.isMarkedAsPlainText(file)) typeManager.markAsPlainText(file);\n  }","commit_id":"ff650f89fd63b1fc23acfa14067a17021b580311","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile file = PlatformDataKeys.VIRTUAL_FILE.getData(dataContext);\n    final Presentation presentation = e.getPresentation();\n    final EnforcedPlainTextFileTypeManager typeManager = EnforcedPlainTextFileTypeManager.getInstance();\n    presentation.setVisible(false);\n    if (typeManager == null || file == null) {\n      return;\n    }\n    if (EnforcedPlainTextFileTypeManager.isApplicableFor(file) && !typeManager.isMarkedAsPlainText(file)) {\n      presentation.setVisible(true);\n      presentation.setIcon(EnforcedPlainTextFileTypeFactory.ENFORCED_PLAIN_TEXT_ICON);\n    }\n  }","id":98147,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final VirtualFile[] selectedFiles = PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n    final Presentation presentation = e.getPresentation();\n    final EnforcedPlainTextFileTypeManager typeManager = EnforcedPlainTextFileTypeManager.getInstance();\n    presentation.setVisible(false);\n    if (typeManager == null || selectedFiles == null || selectedFiles.length == 0) {\n      return;\n    }\n    for (VirtualFile file : selectedFiles) {\n      if (!EnforcedPlainTextFileTypeManager.isApplicableFor(file) || typeManager.isMarkedAsPlainText(file)) {\n        return;\n      }\n    }\n    presentation.setVisible(true);\n    presentation.setIcon(EnforcedPlainTextFileTypeFactory.ENFORCED_PLAIN_TEXT_ICON);\n  }","commit_id":"ff650f89fd63b1fc23acfa14067a17021b580311","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * \n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     */\n    public Component getListCellRendererComponent(JList list, Object value,\n            int index, boolean isSelected, boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.photoLabel.setIcon(null);\n\n        ContactList contactList = (ContactList) list;\n        ContactListModel listModel = (ContactListModel) contactList.getModel();\n\n        if (value instanceof MetaContact)\n        {\n            this.setPreferredSize(new Dimension(20, 30));\n\n            MetaContact contactItem = (MetaContact) value;\n\n            String displayName = contactItem.getDisplayName();\n\n            if (displayName == null || displayName.length() < 1)\n            {\n                displayName = Messages.getI18NString(\"unknown\").getText();\n            }\n\n            this.nameLabel.setText(displayName);\n\n            this.nameLabel.setIcon(listModel\n                    .getMetaContactStatusIcon(contactItem));\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n\n            this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 1));\n\n            byte[] avatar = contactItem.getAvatar(true);\n            if (avatar != null && avatar.length > 0)\n            {\n                Image roundedAvatar = createRoundImage(avatar);\n                this.photoLabel.setIcon(new ImageIcon(roundedAvatar));\n            }\n\n            // We should set the bounds of the cell explicitely in order to\n            // make getComponentAt work properly.\n            this.setBounds(0, 0, list.getWidth() - 2, 30);\n\n            this.buttonsPanel.removeAll();\n\n            this.nameLabel.setBounds(\n                    0, 0, list.getWidth() - 28, 17);\n            this.photoLabel.setBounds(\n                list.getWidth() - 28, 0, 25, 30);\n\n            this.isLeaf = true;\n\n            this.setToolTipText(getContactToolTip(contactItem));\n        }\n        else if (value instanceof MetaContactGroup)\n        {\n            this.setPreferredSize(new Dimension(20, 20));\n\n            MetaContactGroup groupItem = (MetaContactGroup) value;\n\n            this.nameLabel.setText(groupItem.getGroupName() \n                    + \"  ( \" + groupItem.countChildContacts() + \" )\");\n\n            this.nameLabel.setIcon(new ImageIcon(ImageLoader\n                    .getImage(ImageLoader.GROUPS_16x16_ICON)));\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n\n            this.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 2));\n\n            // We should set the bounds of the cell explicitely in order to\n            // make getComponentAt work properly.\n            this.setBounds(0, 0, list.getWidth() - 2, 20);\n\n            JLabel groupContentIndicator = new JLabel();\n\n            if(((ContactListModel)list.getModel()).isGroupClosed(groupItem))\n                photoLabel.setIcon(new ImageIcon(ImageLoader\n                    .getImage(ImageLoader.CLOSED_GROUP)));\n            else\n                photoLabel.setIcon(new ImageIcon(ImageLoader\n                    .getImage(ImageLoader.OPENED_GROUP)));\n\n            //the width is fixed in \n            //order all the icons to be with the same size\n            groupContentIndicator.setBounds(0, 0, 12, 12);\n            this.buttonsPanel.setPreferredSize(\n                    new Dimension(17, 16));\n            this.buttonsPanel.setBounds(\n                    list.getWidth() - 2 - 17, 0,\n                    17, 16);\n\n            this.buttonsPanel.add(groupContentIndicator);\n\n            this.isLeaf = false;\n\n            this.setToolTipText(getGroupToolTip(groupItem));\n        }\n\n//        this.add(buttonsPanel, BorderLayout.EAST);\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","id":98148,"modified_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * \n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     */\n    public Component getListCellRendererComponent(JList list, Object value,\n            int index, boolean isSelected, boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.photoLabel.setIcon(null);\n\n        ContactList contactList = (ContactList) list;\n        ContactListModel listModel = (ContactListModel) contactList.getModel();\n\n        if (value instanceof MetaContact)\n        {\n            this.setPreferredSize(new Dimension(20, 30));\n\n            MetaContact contactItem = (MetaContact) value;\n\n            String displayName = contactItem.getDisplayName();\n\n            if (displayName == null || displayName.length() < 1)\n            {\n                displayName = Messages.getI18NString(\"unknown\").getText();\n            }\n\n            this.nameLabel.setText(displayName);\n\n            this.nameLabel.setIcon(listModel\n                    .getMetaContactStatusIcon(contactItem));\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n\n            this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 1));\n\n            byte[] avatar = contactItem.getAvatar(true);\n            if (avatar != null && avatar.length > 0)\n            {\n                Image roundedAvatar = createRoundImage(avatar);\n\n                if (roundedAvatar != null)\n                    this.photoLabel.setIcon(new ImageIcon(roundedAvatar));\n            }\n\n            // We should set the bounds of the cell explicitely in order to\n            // make getComponentAt work properly.\n            this.setBounds(0, 0, list.getWidth() - 2, 30);\n\n            this.buttonsPanel.removeAll();\n\n            this.nameLabel.setBounds(\n                    0, 0, list.getWidth() - 28, 17);\n            this.photoLabel.setBounds(\n                list.getWidth() - 28, 0, 25, 30);\n\n            this.isLeaf = true;\n\n            this.setToolTipText(getContactToolTip(contactItem));\n        }\n        else if (value instanceof MetaContactGroup)\n        {\n            this.setPreferredSize(new Dimension(20, 20));\n\n            MetaContactGroup groupItem = (MetaContactGroup) value;\n\n            this.nameLabel.setText(groupItem.getGroupName() \n                    + \"  ( \" + groupItem.countChildContacts() + \" )\");\n\n            this.nameLabel.setIcon(new ImageIcon(ImageLoader\n                    .getImage(ImageLoader.GROUPS_16x16_ICON)));\n\n            this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n\n            this.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 2));\n\n            // We should set the bounds of the cell explicitely in order to\n            // make getComponentAt work properly.\n            this.setBounds(0, 0, list.getWidth() - 2, 20);\n\n            JLabel groupContentIndicator = new JLabel();\n\n            if(((ContactListModel)list.getModel()).isGroupClosed(groupItem))\n                photoLabel.setIcon(new ImageIcon(ImageLoader\n                    .getImage(ImageLoader.CLOSED_GROUP)));\n            else\n                photoLabel.setIcon(new ImageIcon(ImageLoader\n                    .getImage(ImageLoader.OPENED_GROUP)));\n\n            //the width is fixed in \n            //order all the icons to be with the same size\n            groupContentIndicator.setBounds(0, 0, 12, 12);\n            this.buttonsPanel.setPreferredSize(\n                    new Dimension(17, 16));\n            this.buttonsPanel.setBounds(\n                    list.getWidth() - 2 - 17, 0,\n                    17, 16);\n\n            this.buttonsPanel.add(groupContentIndicator);\n\n            this.isLeaf = false;\n\n            this.setToolTipText(getGroupToolTip(groupItem));\n        }\n\n//        this.add(buttonsPanel, BorderLayout.EAST);\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","commit_id":"ca377085ade90fa237b169117abad105916c2440","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public boolean isAlwaysLeaf() {\n      return !getValue().isDirectory();\n    }","id":98149,"modified_method":"@Override\n    public boolean isAlwaysLeaf() {\n      PsiFileSystemItem value = getValue();\n      return value != null && !value.isDirectory();\n    }","commit_id":"6ec7f81fd95abfb699a6ccec3c96e73a2333fa85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    @Override\n    protected Collection<AbstractTreeNode> getChildrenImpl() {\n      if (isAlwaysLeaf()) return Collections.emptyList();\n      final List<AbstractTreeNode> list = ContainerUtil.newArrayList();\n      getValue().processChildren(new PsiElementProcessor<PsiFileSystemItem>() {\n        @Override\n        public boolean execute(@NotNull PsiFileSystemItem element) {\n          list.add(new MyPsiNode(getProject(), element));\n          return true;\n        }\n      });\n      return list;\n    }","id":98150,"modified_method":"@Nullable\n    @Override\n    protected Collection<AbstractTreeNode> getChildrenImpl() {\n      if (isAlwaysLeaf()) return Collections.emptyList();\n      final List<AbstractTreeNode> list = ContainerUtil.newArrayList();\n      PsiFileSystemItem value = getValue();\n      if (value != null) {\n        value.processChildren(new PsiElementProcessor<PsiFileSystemItem>() {\n          @Override\n          public boolean execute(@NotNull PsiFileSystemItem element) {\n            list.add(new MyPsiNode(getProject(), element));\n            return true;\n          }\n        });\n      }\n      return list;\n    }","commit_id":"6ec7f81fd95abfb699a6ccec3c96e73a2333fa85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void updateImpl(PresentationData data) {\n      PsiFileSystemItem value = getValue();\n      data.setIcon(value.getIcon(0));\n      data.setPresentableText(value.getName());\n    }","id":98151,"modified_method":"@Override\n    protected void updateImpl(PresentationData data) {\n      PsiFileSystemItem value = getValue();\n      if (value != null) {\n        data.setIcon(value.getIcon(0));\n        data.setPresentableText(value.getName());\n      }\n    }","commit_id":"6ec7f81fd95abfb699a6ccec3c96e73a2333fa85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addDDMStructures(\n\t\t\tlong userId, long groupId, long classNameId, String fileName,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tLocale locale = PortalUtil.getSiteDefaultLocale(groupId);\n\n\t\tList<Element> structureElements = getDDMStructures(fileName, locale);\n\n\t\tfor (Element structureElement : structureElements) {\n\t\t\tboolean dynamicStructure = GetterUtil.getBoolean(\n\t\t\t\tstructureElement.elementText(\"dynamic-structure\"));\n\n\t\t\tif (dynamicStructure) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString name = structureElement.elementText(\"name\");\n\n\t\t\tString description = structureElement.elementText(\"description\");\n\n\t\t\tString ddmStructureKey = name;\n\n\t\t\tDDMStructure ddmStructure =\n\t\t\t\tDDMStructureLocalServiceUtil.fetchStructure(\n\t\t\t\t\tgroupId, classNameId, ddmStructureKey);\n\n\t\t\tif (ddmStructure != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tElement structureElementRootElement = structureElement.element(\n\t\t\t\t\"root\");\n\n\t\t\tString definition = structureElementRootElement.asXML();\n\n\t\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\t\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\t\tLocale[] locales = LanguageUtil.getAvailableLocales(groupId);\n\n\t\t\tfor (Locale curLocale : locales) {\n\t\t\t\tnameMap.put(curLocale, LanguageUtil.get(curLocale, name));\n\t\t\t\tdescriptionMap.put(\n\t\t\t\t\tcurLocale, LanguageUtil.get(curLocale, description));\n\t\t\t}\n\n\t\t\tAttribute defaultLocaleAttribute =\n\t\t\t\tstructureElementRootElement.attribute(\"default-locale\");\n\n\t\t\tLocale ddmStructureDefaultLocale = LocaleUtil.fromLanguageId(\n\t\t\t\tdefaultLocaleAttribute.getValue());\n\n\t\t\tdefinition = DDMXMLUtil.updateXMLDefaultLocale(\n\t\t\t\tdefinition, ddmStructureDefaultLocale, locale);\n\n\t\t\tif (name.equals(DLFileEntryTypeConstants.NAME_IG_IMAGE) &&\n\t\t\t\t!UpgradeProcessUtil.isCreateIGImageDocumentType()) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tddmStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, groupId,\n\t\t\t\tDDMStructureConstants.DEFAULT_PARENT_STRUCTURE_ID, classNameId,\n\t\t\t\tddmStructureKey, nameMap, descriptionMap, definition, \"xml\",\n\t\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\n\t\t\tString templateFileName = structureElement.elementText(\"template\");\n\n\t\t\tif (Validator.isNotNull(templateFileName)) {\n\t\t\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\t\t\tuserId, groupId,\n\t\t\t\t\tPortalUtil.getClassNameId(DDMStructure.class),\n\t\t\t\t\tddmStructure.getStructureId(), nameMap, null,\n\t\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\t\t\tTemplateConstants.LANG_TYPE_FTL,\n\t\t\t\t\tgetContent(templateFileName), serviceContext);\n\t\t\t}\n\t\t}\n\t}","id":98152,"modified_method":"protected void addDDMStructures(\n\t\t\tlong userId, long groupId, long classNameId, String fileName,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tLocale locale = PortalUtil.getSiteDefaultLocale(groupId);\n\n\t\tList<Element> structureElements = getDDMStructures(fileName, locale);\n\n\t\tfor (Element structureElement : structureElements) {\n\t\t\tboolean dynamicStructure = GetterUtil.getBoolean(\n\t\t\t\tstructureElement.elementText(\"dynamic-structure\"));\n\n\t\t\tif (dynamicStructure) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString name = structureElement.elementText(\"name\");\n\n\t\t\tString description = structureElement.elementText(\"description\");\n\n\t\t\tString ddmStructureKey = name;\n\n\t\t\tDDMStructure ddmStructure =\n\t\t\t\tDDMStructureLocalServiceUtil.fetchStructure(\n\t\t\t\t\tgroupId, classNameId, ddmStructureKey);\n\n\t\t\tif (ddmStructure != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tElement structureElementRootElement = structureElement.element(\n\t\t\t\t\"root\");\n\n\t\t\tString definition = structureElementRootElement.asXML();\n\n\t\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\t\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\t\tLocale[] locales = LanguageUtil.getAvailableLocales(groupId);\n\n\t\t\tfor (Locale curLocale : locales) {\n\t\t\t\tnameMap.put(curLocale, LanguageUtil.get(curLocale, name));\n\t\t\t\tdescriptionMap.put(\n\t\t\t\t\tcurLocale, LanguageUtil.get(curLocale, description));\n\t\t\t}\n\n\t\t\tAttribute defaultLocaleAttribute =\n\t\t\t\tstructureElementRootElement.attribute(\"default-locale\");\n\n\t\t\tLocale ddmStructureDefaultLocale = LocaleUtil.fromLanguageId(\n\t\t\t\tdefaultLocaleAttribute.getValue());\n\n\t\t\tdefinition = DDMXMLUtil.updateXMLDefaultLocale(\n\t\t\t\tdefinition, ddmStructureDefaultLocale, locale);\n\n\t\t\tif (name.equals(DLFileEntryTypeConstants.NAME_IG_IMAGE) &&\n\t\t\t\t!UpgradeProcessUtil.isCreateIGImageDocumentType()) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tddmStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, groupId,\n\t\t\t\tDDMStructureConstants.DEFAULT_PARENT_STRUCTURE_ID, classNameId,\n\t\t\t\tddmStructureKey, nameMap, descriptionMap, definition, \"xml\",\n\t\t\t\tDDMStructureConstants.TYPE_DEFAULT, serviceContext);\n\n\t\t\tElement templateElement = structureElement.element(\"template\");\n\n\t\t\tif (templateElement == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString templateFileName = templateElement.elementText(\"file-name\");\n\n\t\t\tboolean templateCacheable = GetterUtil.getBoolean(\n\t\t\t\ttemplateElement.elementText(\"cacheable\"));\n\n\t\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\t\tuserId, groupId, PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\t\tddmStructure.getStructureId(), null, nameMap, null,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\t\tTemplateConstants.LANG_TYPE_FTL, getContent(templateFileName),\n\t\t\t\ttemplateCacheable, false, StringPool.BLANK, null,\n\t\t\t\tserviceContext);\n\t\t}\n\t}","commit_id":"93221712bf5ffb9882604d827aa44effcd3663d0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Ignore\n  @Test\n  public void faultTest() throws IOException {\n    int clients = 10;\n    List<Pair<Integer, TachyonURI>> answer = new ArrayList<Pair<Integer, TachyonURI>>();\n    for (int k = 0; k < clients; k ++) {\n      faultTestDataCreation(new TachyonURI(\"/data\" + k), answer);\n    }\n\n    faultTestDataCheck(answer);\n\n    for (int kills = 0; kills < 1; kills ++) {\n      Assert.assertTrue(mLocalTachyonClusterMultiMaster.killLeader());\n      CommonUtils.sleepMs(Constants.SECOND_MS * 3);\n      faultTestDataCheck(answer);\n    }\n\n    for (int kills = 1; kills < MASTERS - 1; kills ++) {\n      Assert.assertTrue(mLocalTachyonClusterMultiMaster.killLeader());\n      CommonUtils.sleepMs(null, Constants.SECOND_MS * 3);\n      faultTestDataCheck(answer);\n      // TODO Add the following line back\n      // faultTestDataCreation(\"/data\" + (clients + kills + 1), answer);\n    }\n  }","id":98153,"modified_method":"@Ignore\n  @Test\n  public void faultTest() throws IOException {\n    int clients = 10;\n    List<Pair<Long, TachyonURI>> answer = Lists.newArrayList();\n    for (int k = 0; k < clients; k ++) {\n      faultTestDataCreation(new TachyonURI(\"/data\" + k), answer);\n    }\n\n    faultTestDataCheck(answer);\n\n    for (int kills = 0; kills < 1; kills ++) {\n      Assert.assertTrue(mLocalTachyonClusterMultiMaster.killLeader());\n      CommonUtils.sleepMs(Constants.SECOND_MS * 3);\n      faultTestDataCheck(answer);\n    }\n\n    for (int kills = 1; kills < MASTERS - 1; kills ++) {\n      Assert.assertTrue(mLocalTachyonClusterMultiMaster.killLeader());\n      CommonUtils.sleepMs(null, Constants.SECOND_MS * 3);\n      faultTestDataCheck(answer);\n      // TODO Add the following line back\n      // faultTestDataCreation(\"/data\" + (clients + kills + 1), answer);\n    }\n  }","commit_id":"5a3acc623c6fcbe03425d0c3c76ace3879cf5dab","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tells if the results can match the answer\n   *\n   * @param answer the correct results\n   * @throws java.io.IOException\n   */\n  private void faultTestDataCheck(List<Pair<Integer, TachyonURI>> answer) throws IOException {\n    TachyonFS tfs = mLocalTachyonClusterMultiMaster.getClient();\n    List<String> files = TachyonFSTestUtils.listFiles(tfs, TachyonURI.SEPARATOR);\n    Assert.assertEquals(answer.size(), files.size());\n    for (int k = 0; k < answer.size(); k ++) {\n      Assert.assertEquals(answer.get(k).getSecond().toString(),\n          tfs.getFile(answer.get(k).getFirst()).getPath());\n      Assert.assertEquals(answer.get(k).getFirst().intValue(),\n          tfs.getFileId(answer.get(k).getSecond()));\n    }\n  }","id":98154,"modified_method":"/**\n   * Tells if the results can match the answer.\n   *\n   * @param answer the correct results\n   * @throws java.io.IOException\n   */\n  private void faultTestDataCheck(List<Pair<Long, TachyonURI>> answer) throws IOException {\n    List<String> files = TachyonFSTestUtils.listFiles(mTfs, new TachyonURI(TachyonURI.SEPARATOR));\n    Collections.sort(files);\n    Assert.assertEquals(answer.size(), files.size());\n    for (int k = 0; k < answer.size(); k ++) {\n      Assert.assertEquals(answer.get(k).getSecond().toString(),\n          mTfs.getInfo(new TachyonFile(answer.get(k).getFirst())).getPath());\n      Assert.assertEquals(answer.get(k).getFirst().intValue(),\n          mTfs.open(answer.get(k).getSecond()).getFileId());\n    }\n  }","commit_id":"5a3acc623c6fcbe03425d0c3c76ace3879cf5dab","url":"https://github.com/amplab/tachyon"},{"original_method":"@Ignore\n  @Test\n  public void getClientsTest() throws IOException {\n    int clients = 10;\n    mTfs.createFile(new TachyonURI(\"/0\"), 1024);\n    for (int k = 1; k < clients; k ++) {\n      TachyonFS tfs = mLocalTachyonClusterMultiMaster.getClient();\n      tfs.createFile(new TachyonURI(TachyonURI.SEPARATOR + k), 1024);\n    }\n    List<String> files = TachyonFSTestUtils.listFiles(mTfs, TachyonURI.SEPARATOR);\n    Assert.assertEquals(clients, files.size());\n    for (int k = 0; k < clients; k ++) {\n      Assert.assertEquals(TachyonURI.SEPARATOR + k, files.get(k));\n    }\n  }","id":98155,"modified_method":"@Ignore\n  @Test\n  public void getClientsTest() throws IOException {\n    int clients = 10;\n    ClientOptions option = new ClientOptions.Builder(new TachyonConf()).setBlockSize(1024).build();\n    for (int k = 0; k < clients; k ++) {\n      TachyonFS tfs = mLocalTachyonClusterMultiMaster.getClient();\n      tfs.getOutStream(new TachyonURI(TachyonURI.SEPARATOR + k), option).close();\n    }\n    List<String> files = TachyonFSTestUtils.listFiles(mTfs, new TachyonURI(TachyonURI.SEPARATOR));\n    Assert.assertEquals(clients, files.size());\n    Collections.sort(files);\n    for (int k = 0; k < clients; k ++) {\n      Assert.assertEquals(TachyonURI.SEPARATOR + k, files.get(k));\n    }\n  }","commit_id":"5a3acc623c6fcbe03425d0c3c76ace3879cf5dab","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Create 10 files in the folder\n   *\n   * @param folderName the folder name to create\n   * @param answer the results, the mapping from file id to file path\n   * @throws java.io.IOException\n   */\n  private void faultTestDataCreation(TachyonURI folderName, List<Pair<Integer, TachyonURI>> answer)\n      throws IOException {\n    TachyonFS tfs = mLocalTachyonClusterMultiMaster.getClient();\n    if (!tfs.exist(folderName)) {\n      tfs.mkdir(folderName);\n      answer.add(new Pair<Integer, TachyonURI>(tfs.getFileId(folderName), folderName));\n    }\n\n    for (int k = 0; k < 10; k ++) {\n      TachyonURI path =\n          new TachyonURI(\n              folderName + TachyonURI.SEPARATOR + folderName.toString().substring(1) + k);\n      answer.add(new Pair<Integer, TachyonURI>(tfs.createFile(path), path));\n    }\n  }","id":98156,"modified_method":"/**\n   * Creates 10 files in the folder.\n   *\n   * @param folderName the folder name to create\n   * @param answer the results, the mapping from file id to file path\n   * @throws java.io.IOException\n   */\n  private void faultTestDataCreation(TachyonURI folderName, List<Pair<Long, TachyonURI>> answer)\n      throws IOException {\n    mTfs.mkdirs(folderName);\n    answer.add(new Pair<Long, TachyonURI>(mTfs.open(folderName).getFileId(), folderName));\n\n    for (int k = 0; k < 10; k ++) {\n      TachyonURI path =\n          new TachyonURI(PathUtils.concatPath(folderName, folderName.toString().substring(1), k));\n      mTfs.getOutStream(path, ClientOptions.defaults()).close();\n      answer.add(new Pair<Long, TachyonURI>(mTfs.open(path).getFileId(), path));\n    }\n  }","commit_id":"5a3acc623c6fcbe03425d0c3c76ace3879cf5dab","url":"https://github.com/amplab/tachyon"},{"original_method":"@Before\n  public final void before() throws Exception {\n    mLocalTachyonClusterMultiMaster =\n        new LocalTachyonClusterMultiMaster(10000, MASTERS, BLOCK_SIZE);\n    mLocalTachyonClusterMultiMaster.start();\n    mTfs = mLocalTachyonClusterMultiMaster.getClient();\n  }","id":98157,"modified_method":"@Before\n  public final void before() throws Exception {\n    mLocalTachyonClusterMultiMaster =\n        new LocalTachyonClusterMultiMaster(WORKER_CAPACITY_BYTES, MASTERS, BLOCK_SIZE);\n    mLocalTachyonClusterMultiMaster.start();\n    mTfs = mLocalTachyonClusterMultiMaster.getClient();\n  }","commit_id":"5a3acc623c6fcbe03425d0c3c76ace3879cf5dab","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test journalling of inodes being pinned.\n   */\n  @Test\n  public void PinTest() throws Exception {\n    mTfs.mkdir(new TachyonURI(\"/myFolder\"));\n    int folderId = mTfs.getFileId(new TachyonURI(\"/myFolder\"));\n    mTfs.setPinned(folderId, true);\n    int file0Id = mTfs.createFile(new TachyonURI(\"/myFolder/file0\"), 64);\n    mTfs.setPinned(file0Id, false);\n    int file1Id = mTfs.createFile(new TachyonURI(\"/myFolder/file1\"), 64);\n    FileInfo folderInfo = mLocalTachyonCluster.getMasterInfo().getClientFileInfo(folderId);\n    FileInfo file0Info = mLocalTachyonCluster.getMasterInfo().getClientFileInfo(file0Id);\n    FileInfo file1Info = mLocalTachyonCluster.getMasterInfo().getClientFileInfo(file1Id);\n    mLocalTachyonCluster.stopTFS();\n    PinTestUtil(folderInfo, file0Info, file1Info);\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    PinTestUtil(folderInfo, file0Info, file1Info);\n  }","id":98158,"modified_method":"/**\n   * Test journalling of inodes being pinned.\n   */\n  @Test\n  public void PinTest() throws Exception {\n    mTfs.mkdirs(new TachyonURI(\"/myFolder\"));\n    TachyonFile folder = mTfs.open(new TachyonURI(\"/myFolder\"));\n    mTfs.setPin(folder, true);\n\n    TachyonURI file0Path = new TachyonURI(\"/myFolder/file0\");\n    ClientOptions op = new ClientOptions.Builder(mMasterTachyonConf).setBlockSize(64).build();\n    mTfs.getOutStream(file0Path, op).close();\n    TachyonFile file0 = mTfs.open(file0Path);\n    mTfs.setPin(file0, false);\n\n    TachyonURI file1Path = new TachyonURI(\"/myFolder/file1\");\n    mTfs.getOutStream(file1Path, op).close();\n\n    FileInfo folderInfo = mTfs.getInfo(folder);\n    FileInfo file0Info = mTfs.getInfo(file0);\n    FileInfo file1Info = mTfs.getInfo(mTfs.open(file1Path));\n\n    mLocalTachyonCluster.stopTFS();\n\n    PinTestUtil(folderInfo, file0Info, file1Info);\n    deleteFsMasterJournalLogs();\n    PinTestUtil(folderInfo, file0Info, file1Info);\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void FileTest() throws Exception {\n    mTfs.createFile(new TachyonURI(\"/xyz\"), 64);\n    FileInfo fInfo =\n        mLocalTachyonCluster.getMasterInfo().getClientFileInfo(new TachyonURI(\"/xyz\"));\n    mLocalTachyonCluster.stopTFS();\n    FileTestUtil(fInfo);\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    FileTestUtil(fInfo);\n  }","id":98159,"modified_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void FileTest() throws Exception {\n    ClientOptions option = new ClientOptions.Builder(mMasterTachyonConf).setBlockSize(64).build();\n    TachyonURI filePath = new TachyonURI(\"/xyz\");\n    mTfs.getOutStream(filePath, option).close();\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(filePath));\n    mLocalTachyonCluster.stopTFS();\n    FileTestUtil(fInfo);\n    deleteFsMasterJournalLogs();\n    FileTestUtil(fInfo);\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test completed Editlog deletion\n   *\n   * @throws Exception\n   */\n  @Test\n  public void CompletedEditLogDeletionTest() throws Exception {\n    Journal journal = mLocalTachyonCluster.getMasterInfo().getJournal();\n    journal.setMaxLogSize(Constants.KB);\n    for (int i = 0; i < 124; i ++) {\n      mTfs.createFile(new TachyonURI(\"/a\" + i), (i + 10) / 10 * 64);\n    }\n    mLocalTachyonCluster.stopTFS();\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    String completedPath =\n        editLogPath.substring(0, editLogPath.lastIndexOf(TachyonURI.SEPARATOR)) + \"/completed\";\n    Assert.assertTrue(UnderFileSystem.get(completedPath,\n        mMasterTachyonConf).list(completedPath).length > 1);\n    MultiEditLogTestUtil();\n    Assert.assertTrue(UnderFileSystem.get(completedPath,\n        mMasterTachyonConf).list(completedPath).length == 0);\n    MultiEditLogTestUtil();\n  }","id":98160,"modified_method":"/**\n   * Test completed Editlog deletion\n   *\n   * @throws Exception\n   */\n  @Test\n  public void CompletedEditLogDeletionTest() throws Exception {\n    JournalWriter.setMaxLogSize(Constants.KB);\n    for (int i = 0; i < 124; i ++) {\n      mTfs.getOutStream(new TachyonURI(\"/a\" + i), new ClientOptions.Builder(mMasterTachyonConf)\n        .setBlockSize((i + 10) / 10 * 64).build()).close();\n    }\n    mLocalTachyonCluster.stopTFS();\n\n    String journalFolder = mLocalTachyonCluster.getMaster().getJournalFolder();\n    Journal journal = new Journal(journalFolder, mMasterTachyonConf);\n    String completedPath = journal.getCompletedDirectory();\n    Assert.assertTrue(UnderFileSystem.get(completedPath,\n        mMasterTachyonConf).list(completedPath).length > 1);\n    MultiEditLogTestUtil();\n    Assert.assertTrue(UnderFileSystem.get(completedPath,\n        mMasterTachyonConf).list(completedPath).length == 0);\n    MultiEditLogTestUtil();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test file and folder creation, and rename;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void RenameTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.mkdir(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        mTfs.createFile(new TachyonURI(\"/i\" + i + \"/j\" + j), (i + j + 1) * 64);\n        mTfs.rename(new TachyonURI(\"/i\" + i + \"/j\" + j), new TachyonURI(\"/i\" + i + \"/jj\" + j));\n      }\n      mTfs.rename(new TachyonURI(\"/i\" + i), new TachyonURI(\"/ii\" + i));\n    }\n    mLocalTachyonCluster.stopTFS();\n    RenameTestUtil();\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    RenameTestUtil();\n  }","id":98161,"modified_method":"/**\n   * Test file and folder creation, and rename;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void RenameTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.mkdirs(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        ClientOptions option = new ClientOptions.Builder(mMasterTachyonConf).setBlockSize(\n            (i + j + 1) * 64).build();\n        TachyonURI path = new TachyonURI(\"/i\" + i + \"/j\" + j);\n        mTfs.getOutStream(path, option).close();\n        mTfs.rename(mTfs.open(path), new TachyonURI(\"/i\" + i + \"/jj\" + j));\n      }\n      mTfs.rename(mTfs.open(new TachyonURI(\"/i\" + i)), new TachyonURI(\"/ii\" + i));\n    }\n    mLocalTachyonCluster.stopTFS();\n    RenameTestUtil();\n    deleteFsMasterJournalLogs();\n    RenameTestUtil();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void AddBlockTestUtil(FileInfo fileInfo) throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    String masterJournal =\n        mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info =\n        new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService, mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(2, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    Assert.assertTrue(info.getFileId(new TachyonURI(\"/xyz\")) != -1);\n    int temp = fileInfo.inMemoryPercentage;\n    fileInfo.setInMemoryPercentage(0);\n    Assert.assertEquals(fileInfo, info.getClientFileInfo(info.getFileId(new TachyonURI(\"/xyz\"))));\n    fileInfo.setInMemoryPercentage(temp);\n    info.stop();\n  }","id":98162,"modified_method":"private void AddBlockTestUtil(FileInfo fileInfo) throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(2, fsMaster.getFileInfoList(rootId).size());\n    long xyzId = fsMaster.getFileId(new TachyonURI(\"/xyz\"));\n    Assert.assertTrue(xyzId != -1);\n    int temp = fileInfo.inMemoryPercentage;\n    fileInfo.setInMemoryPercentage(0);\n    Assert.assertEquals(fileInfo, fsMaster.getFileInfo(xyzId));\n    fileInfo.setInMemoryPercentage(temp);\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void EmptyImageTest() throws Exception {\n    mLocalTachyonCluster.stopTFS();\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(1, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    info.stop();\n  }","id":98163,"modified_method":"@Test\n  public void EmptyImageTest() throws Exception {\n    mLocalTachyonCluster.stopTFS();\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(1, fsMaster.getFileInfoList(rootId).size());\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test add block\n   *\n   * @throws Exception\n   */\n  @Test\n  public void AddBlockTest() throws Exception {\n    TachyonURI uri = new TachyonURI(\"/xyz\");\n    mTfs.createFile(uri, 64);\n    TachyonFile file = mTfs.getFile(uri);\n    OutputStream os = file.getOutStream(WriteType.MUST_CACHE);\n    for (int k = 0; k < 1000; k ++) {\n      os.write(k);\n    }\n    os.close();\n    FileInfo fInfo = mLocalTachyonCluster.getMasterInfo().getClientFileInfo(uri);\n    mLocalTachyonCluster.stopTFS();\n    AddBlockTestUtil(fInfo);\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    AddBlockTestUtil(fInfo);\n  }","id":98164,"modified_method":"/**\n   * Test add block\n   *\n   * @throws Exception\n   */\n  @Test\n  public void AddBlockTest() throws Exception {\n    TachyonURI uri = new TachyonURI(\"/xyz\");\n    ClientOptions options = new ClientOptions.Builder(mMasterTachyonConf).setBlockSize(64).build();\n    FileOutStream os = mTfs.getOutStream(uri, options);\n    for (int k = 0; k < 1000; k ++) {\n      os.write(k);\n    }\n    os.close();\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(uri));\n    mLocalTachyonCluster.stopTFS();\n    AddBlockTestUtil(fInfo);\n    String journalFolder = FileSystemMaster.getJournalDirectory(\n        mLocalTachyonCluster.getMaster().getJournalFolder());\n    UnderFileSystem.get(journalFolder, mMasterTachyonConf).delete(journalFolder, true);\n    AddBlockTestUtil(fInfo);\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void FileTestUtil(FileInfo fileInfo) throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(2, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    Assert.assertTrue(info.getFileId(new TachyonURI(\"/xyz\")) != -1);\n    Assert.assertEquals(fileInfo, info.getClientFileInfo(info.getFileId(new TachyonURI(\"/xyz\"))));\n    info.stop();\n  }","id":98165,"modified_method":"private void FileTestUtil(FileInfo fileInfo) throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(2, fsMaster.getFileInfoList(rootId).size());\n    long fileId = fsMaster.getFileId(new TachyonURI(\"/xyz\"));\n    Assert.assertTrue(fileId != -1);\n    Assert.assertEquals(fileInfo, fsMaster.getFileInfo(fileId));\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test reading multiple edit logs.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void MultiEditLogTest() throws Exception {\n    Journal journal = mLocalTachyonCluster.getMasterInfo().getJournal();\n    journal.setMaxLogSize(Constants.KB);\n    for (int i = 0; i < 124; i ++) {\n      mTfs.createFile(new TachyonURI(\"/a\" + i), (i + 10) / 10 * 64);\n    }\n    mLocalTachyonCluster.stopTFS();\n    MultiEditLogTestUtil();\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    MultiEditLogTestUtil();\n  }","id":98166,"modified_method":"/**\n   * Test reading multiple edit logs.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void MultiEditLogTest() throws Exception {\n    JournalWriter.setMaxLogSize(Constants.KB);\n    for (int i = 0; i < 124; i ++) {\n      ClientOptions op = new ClientOptions.Builder(mMasterTachyonConf).setBlockSize(\n          (i + 10) / 10 * 64).build();\n      mTfs.getOutStream(new TachyonURI(\"/a\" + i), op);\n    }\n    mLocalTachyonCluster.stopTFS();\n    MultiEditLogTestUtil();\n    deleteFsMasterJournalLogs();\n    MultiEditLogTestUtil();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void ManyFileTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.createFile(new TachyonURI(\"/a\" + i), (i + 1) * 64);\n    }\n    mLocalTachyonCluster.stopTFS();\n    ManyFileTestUtil();\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    ManyFileTestUtil();\n  }","id":98167,"modified_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void ManyFileTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      ClientOptions option = new ClientOptions.Builder(mMasterTachyonConf).setBlockSize(\n          (i + 1) * 64).build();\n      mTfs.getOutStream(new TachyonURI(\"/a\" + i), option).close();\n    }\n    mLocalTachyonCluster.stopTFS();\n    ManyFileTestUtil();\n    deleteFsMasterJournalLogs();\n    ManyFileTestUtil();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void AddCheckpointTestUtil(FileInfo fileInfo, FileInfo ckFileInfo)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(3, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    Assert.assertTrue(info.getFileId(new TachyonURI(\"/xyz\")) != -1);\n    Assert.assertTrue(info.getFileId(new TachyonURI(\"/xyz_ck\")) != -1);\n    Assert.assertEquals(fileInfo, info.getClientFileInfo(info.getFileId(new TachyonURI(\"/xyz\"))));\n    Assert.assertEquals(ckFileInfo,\n        info.getClientFileInfo(info.getFileId(new TachyonURI(\"/xyz_ck\"))));\n    info.stop();\n  }","id":98168,"modified_method":"private void AddCheckpointTestUtil(FileInfo fileInfo, FileInfo ckFileInfo)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(3, fsMaster.getFileInfoList(rootId).size());\n    Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/xyz\")) != -1);\n    Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/xyz_ck\")) != -1);\n    Assert.assertEquals(fileInfo, fsMaster.getFileInfo(fsMaster.getFileId(new TachyonURI(\"/xyz\"))));\n    Assert.assertEquals(ckFileInfo,\n        fsMaster.getFileInfo(fsMaster.getFileId(new TachyonURI(\"/xyz_ck\"))));\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void ManyFileTestUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(11, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    for (int k = 0; k < 10; k ++) {\n      Assert.assertTrue(info.getFileId(new TachyonURI(\"/a\" + k)) != -1);\n    }\n    info.stop();\n  }","id":98169,"modified_method":"private void ManyFileTestUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(11, fsMaster.getFileInfoList(rootId).size());\n    for (int k = 0; k < 10; k ++) {\n      Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/a\" + k)) != -1);\n    }\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test file and folder creation and deletion;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void DeleteTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.mkdir(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        mTfs.createFile(new TachyonURI(\"/i\" + i + \"/j\" + j), (i + j + 1) * 64);\n        if (j >= 5) {\n          mTfs.delete(new TachyonURI(\"/i\" + i + \"/j\" + j), false);\n        }\n      }\n      if (i >= 5) {\n        mTfs.delete(new TachyonURI(\"/i\" + i), true);\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    DeleteTestUtil();\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    DeleteTestUtil();\n  }","id":98170,"modified_method":"/**\n   * Test file and folder creation and deletion;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void DeleteTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      String dirPath = \"/i\" + i;\n      mTfs.mkdirs(new TachyonURI(dirPath));\n      for (int j = 0; j < 10; j ++) {\n        ClientOptions option =\n            new ClientOptions.Builder(mMasterTachyonConf).setBlockSize((i + j + 1) * 64).build();\n        String filePath = dirPath + \"/j\" + j;\n        mTfs.getOutStream(new TachyonURI(filePath), option).close();\n        if (j >= 5) {\n          mTfs.delete(mTfs.open(new TachyonURI(filePath)));\n        }\n      }\n      if (i >= 5) {\n        mTfs.delete(mTfs.open(new TachyonURI(dirPath)));\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    DeleteTestUtil();\n    deleteFsMasterJournalLogs();\n    DeleteTestUtil();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void DeleteTestUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(31, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    for (int i = 0; i < 5; i ++) {\n      for (int j = 0; j < 5; j ++) {\n        Assert.assertTrue(info.getFileId(new TachyonURI(\"/i\" + i + \"/j\" + j)) != -1);\n      }\n    }\n    info.stop();\n  }","id":98171,"modified_method":"private void DeleteTestUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(31, fsMaster.getFileBlockInfoList(rootId).size());\n    for (int i = 0; i < 5; i ++) {\n      for (int j = 0; j < 5; j ++) {\n        Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/i\" + i + \"/j\" + j)) != -1);\n      }\n    }\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void FileFolderUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    String masterJournal =\n        mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info =\n        new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService, mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(111, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    for (int i = 0; i < 10; i ++) {\n      for (int j = 0; j < 10; j ++) {\n        Assert.assertTrue(info.getFileId(new TachyonURI(\"/i\" + i + \"/j\" + j)) != -1);\n      }\n    }\n    info.stop();\n  }","id":98172,"modified_method":"private void FileFolderUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(111, fsMaster.getFileInfoList(rootId).size());\n    for (int i = 0; i < 10; i ++) {\n      for (int j = 0; j < 10; j ++) {\n        Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/i\" + i + \"/j\" + j)) != -1);\n      }\n    }\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test file and folder creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void FileFolderTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.mkdir(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        mTfs.createFile(new TachyonURI(\"/i\" + i + \"/j\" + j), (i + j + 1) * 64);\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    FileFolderUtil();\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    FileFolderUtil();\n  }","id":98173,"modified_method":"/**\n   * Test file and folder creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void FileFolderTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.mkdirs(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        ClientOptions option =\n            new ClientOptions.Builder(mMasterTachyonConf).setBlockSize((i + j + 1) * 64).build();\n        mTfs.getOutStream(new TachyonURI(\"/i\" + i + \"/j\" + j), option).close();\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    FileFolderUtil();\n    deleteFsMasterJournalLogs();\n    FileFolderUtil();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void MultiEditLogTestUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(125, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    for (int k = 0; k < 124; k ++) {\n      Assert.assertTrue(info.getFileId(new TachyonURI(\"/a\" + k)) != -1);\n    }\n    info.stop();\n  }","id":98174,"modified_method":"private void MultiEditLogTestUtil() throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(125, fsMaster.getFileInfoList(rootId).size());\n    for (int k = 0; k < 124; k ++) {\n      Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/a\" + k)) != -1);\n    }\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test add checkpoint\n   *\n   * @throws Exception\n   */\n  @Test\n  public void AddCheckpointTest() throws Exception {\n    TachyonFSTestUtils.createByteFile(mTfs, \"/xyz\", WriteType.THROUGH, 10);\n    FileInfo fInfo =\n        mLocalTachyonCluster.getMasterInfo().getClientFileInfo(new TachyonURI(\"/xyz\"));\n    mTfs.createFile(new TachyonURI(\"/xyz_ck\"), new TachyonURI(fInfo.getUfsPath()));\n    FileInfo ckFileInfo =\n        mLocalTachyonCluster.getMasterInfo().getClientFileInfo(new TachyonURI(\"/xyz_ck\"));\n    mLocalTachyonCluster.stopTFS();\n    AddCheckpointTestUtil(fInfo, ckFileInfo);\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    AddCheckpointTestUtil(fInfo, ckFileInfo);\n  }","id":98175,"modified_method":"/**\n   * Test add checkpoint\n   *\n   * @throws Exception\n   */\n  @Test\n  public void AddCheckpointTest() throws Exception {\n    ClientOptions options = new ClientOptions.Builder(mMasterTachyonConf)\n        .setCacheType(CacheType.NO_CACHE).setUnderStorageType(UnderStorageType.PERSIST).build();\n    TachyonFSTestUtils.createByteFile(mTfs, \"/xyz\", options, 10);\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(new TachyonURI(\"/xyz\")));\n    TachyonURI ckPath = new TachyonURI(\"/xyz_ck\");\n    // TODO(cc): what's the counterpart in the new client API for this?\n    //mTfs.createFile(new TachyonURI(\"/xyz_ck\"), new TachyonURI(fInfo.getUfsPath()));\n    FileInfo ckFileInfo = mTfs.getInfo(mTfs.open(ckPath));\n    mLocalTachyonCluster.stopTFS();\n    AddCheckpointTestUtil(fInfo, ckFileInfo);\n    deleteFsMasterJournalLogs();\n    AddCheckpointTestUtil(fInfo, ckFileInfo);\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test folder creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void FolderTest() throws Exception {\n    mTfs.mkdir(new TachyonURI(\"/xyz\"));\n    FileInfo fInfo =\n        mLocalTachyonCluster.getMasterInfo().getClientFileInfo(new TachyonURI(\"/xyz\"));\n    mLocalTachyonCluster.stopTFS();\n    FolderTest(fInfo);\n    String editLogPath = mLocalTachyonCluster.getEditLogPath();\n    UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true);\n    FolderTest(fInfo);\n  }","id":98176,"modified_method":"/**\n   * Test folder creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void FolderTest() throws Exception {\n    TachyonURI folderPath = new TachyonURI(\"/xyz\");\n    mTfs.mkdirs(folderPath);\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(folderPath));\n    mLocalTachyonCluster.stopTFS();\n    FolderTest(fInfo);\n    deleteFsMasterJournalLogs();\n    FolderTest(fInfo);\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void RenameTestUtil()\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(111, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    for (int i = 0; i < 10; i ++) {\n      for (int j = 0; j < 10; j ++) {\n        Assert.assertTrue(info.getFileId(new TachyonURI(\"/ii\" + i + \"/jj\" + j)) != -1);\n      }\n    }\n    info.stop();\n  }","id":98177,"modified_method":"private void RenameTestUtil()\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(111, fsMaster.getFileInfoList(rootId).size());\n    for (int i = 0; i < 10; i ++) {\n      for (int j = 0; j < 10; j ++) {\n        Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/ii\" + i + \"/jj\" + j)) != -1);\n      }\n    }\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void FolderTest(FileInfo fileInfo) throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    String masterJournal =\n        mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info =\n        new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService, mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(2, info.ls(mRootUri, true).size());\n    Assert.assertTrue(info.getFileId(mRootUri) != -1);\n    Assert.assertTrue(info.getFileId(new TachyonURI(\"/xyz\")) != -1);\n    Assert.assertEquals(fileInfo, info.getClientFileInfo(info.getFileId(new TachyonURI(\"/xyz\"))));\n    info.stop();\n  }","id":98178,"modified_method":"private void FolderTest(FileInfo fileInfo) throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != -1);\n    Assert.assertEquals(2, fsMaster.getFileInfoList(rootId).size());\n    long fileId = fsMaster.getFileId(new TachyonURI(\"/xyz\"));\n    Assert.assertTrue(fileId != -1);\n    Assert.assertEquals(fileInfo, fsMaster.getFileInfo(fileId));\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"private void PinTestUtil(FileInfo folder, FileInfo file0, FileInfo file1)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    String masterJournal = mMasterTachyonConf.get(Constants.MASTER_JOURNAL_FOLDER);\n    Journal journal = new Journal(masterJournal, \"image.data\", \"log.data\", mMasterTachyonConf);\n    MasterInfo info = new MasterInfo(new InetSocketAddress(9999), journal, mExecutorService,\n        mMasterTachyonConf);\n    info.init();\n    Assert.assertEquals(\n        folder, info.getClientFileInfo(info.getFileId(new TachyonURI(\"/myFolder\"))));\n    Assert.assertTrue(\n        info.getClientFileInfo(info.getFileId(new TachyonURI(\"/myFolder\"))).isPinned);\n    Assert.assertEquals(\n        file0, info.getClientFileInfo(info.getFileId(new TachyonURI(\"/myFolder/file0\"))));\n    Assert.assertFalse(\n        info.getClientFileInfo(info.getFileId(new TachyonURI(\"/myFolder/file0\"))).isPinned);\n    Assert.assertEquals(\n        file1, info.getClientFileInfo(info.getFileId(new TachyonURI(\"/myFolder/file1\"))));\n    Assert.assertTrue(\n        info.getClientFileInfo(info.getFileId(new TachyonURI(\"/myFolder/file1\"))).isPinned);\n    info.stop();\n  }","id":98179,"modified_method":"private void PinTestUtil(FileInfo folder, FileInfo file0, FileInfo file1)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n\n    FileInfo info = fsMaster.getFileInfo(fsMaster.getFileId(new TachyonURI(\"/myFolder\")));\n    Assert.assertEquals(folder, info);\n    Assert.assertTrue(info.isPinned);\n\n    info = fsMaster.getFileInfo(fsMaster.getFileId(new TachyonURI(\"/myFolder/file0\")));\n    Assert.assertEquals(file0, info);\n    Assert.assertFalse(info.isPinned);\n\n    info = fsMaster.getFileInfo(fsMaster.getFileId(new TachyonURI(\"/myFolder/file1\")));\n    Assert.assertEquals(file1, info);\n    Assert.assertTrue(info.isPinned);\n\n    fsMaster.stop();\n  }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public synchronized void flush() throws IOException {\n      if (mIsClosed) {\n        return;\n      }\n      mOutputStream.flush();\n      if (mOutputStream instanceof FSDataOutputStream) {\n        ((FSDataOutputStream) mOutputStream).sync();\n      }\n      if (mOutputStream.size() > MAX_LOG_SIZE) {\n        // rotate the current log.\n        mOutputStream.close();\n        completeCurrentLog();\n        mOutputStream = openCurrentLog();\n      }\n    }","id":98180,"modified_method":"@Override\n    public synchronized void flush() throws IOException {\n      if (mIsClosed) {\n        return;\n      }\n      mOutputStream.flush();\n      if (mOutputStream instanceof FSDataOutputStream) {\n        ((FSDataOutputStream) mOutputStream).sync();\n      }\n      if (mOutputStream.size() > sMaxLogSize) {\n        // rotate the current log.\n        mOutputStream.close();\n        completeCurrentLog();\n        mOutputStream = openCurrentLog();\n      }\n    }","commit_id":"0a56a44e961aef0d3d2aac99a5d7cd423d5fbb87","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    protected void registerComponents() throws Exception\n    {\n        super.registerComponents();\n\n        // Document Access Bridge Mock\n        this.mockDocumentAccessBridge = registerMockComponent(DocumentAccessBridge.class);\n\n        // Mock (default) string document name serializer.\n        this.mockDefaultStringEntityReferenceSerializer = getMockery().mock(EntityReferenceSerializer.class, \"s1\");\n        DefaultComponentDescriptor<EntityReferenceSerializer> descriptorDSRS =\n            new DefaultComponentDescriptor<EntityReferenceSerializer>();\n        descriptorDSRS.setRoleType(EntityReferenceSerializer.TYPE_STRING);\n        getComponentManager().registerComponent(descriptorDSRS, mockDefaultStringEntityReferenceSerializer);\n\n        // Mock (compactwiki) string document name serializer.\n        mockCompactWikiStringEntityReferenceSerializer = getMockery().mock(EntityReferenceSerializer.class, \"s2\");\n        DefaultComponentDescriptor<EntityReferenceSerializer> descriptorCWSRS =\n            new DefaultComponentDescriptor<EntityReferenceSerializer>();\n        descriptorCWSRS.setRoleType(EntityReferenceSerializer.TYPE_STRING);\n        descriptorCWSRS.setRoleHint(\"compactwiki\");\n        getComponentManager().registerComponent(descriptorCWSRS, mockCompactWikiStringEntityReferenceSerializer);\n\n        // Document name factory.\n        this.mockDocumentReferenceResolver = registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n\n        // Mock OpenOffice manager.\n        this.mockOpenOfficeManager = registerMockComponent(OpenOfficeManager.class);\n    }","id":98181,"modified_method":"@Override\n    protected void registerComponents() throws Exception\n    {\n        super.registerComponents();\n\n        this.mockDocumentAccessBridge = registerMockComponent(DocumentAccessBridge.class);\n        this.mockDefaultStringEntityReferenceSerializer =\n            registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"default\", \"s1\");\n        this.mockCompactWikiStringEntityReferenceSerializer =\n            registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\", \"s2\");\n        this.mockDocumentReferenceResolver =\n            registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        this.mockOpenOfficeManager = registerMockComponent(OpenOfficeManager.class);\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Test if default configuration values are present.\n     */\n    @Test\n    public void testDefaultConfiguration() throws Exception\n    {\n        OpenOfficeConfiguration configuration =\n            getComponentManager().getInstance(OpenOfficeConfiguration.class, \"default\");\n        Assert.assertEquals(OpenOfficeConfiguration.SERVER_TYPE_INTERNAL, configuration.getServerType());\n        Assert.assertEquals(8100, configuration.getServerPort());\n        Assert.assertNull(configuration.getProfilePath());\n        Assert.assertTrue(configuration.getMaxTasksPerProcess() > 0);\n        Assert.assertTrue(configuration.getTaskExecutionTimeout() > 0);\n    }","id":98182,"modified_method":"/**\n     * Test if default configuration values are present.\n     * \n     * @throws Exception if it fails to get the default {@link OpenOfficeConfiguration} implementation\n     */\n    @Test\n    public void testDefaultConfiguration() throws Exception\n    {\n        OpenOfficeConfiguration configuration = getComponentManager().getInstance(OpenOfficeConfiguration.class);\n        Assert.assertEquals(OpenOfficeConfiguration.SERVER_TYPE_INTERNAL, configuration.getServerType());\n        Assert.assertEquals(8100, configuration.getServerPort());\n        Assert.assertNull(configuration.getProfilePath());\n        Assert.assertTrue(configuration.getMaxTasksPerProcess() > 0);\n        Assert.assertTrue(configuration.getTaskExecutionTimeout() > 0);\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Test basic document splitting.\n     */\n    @org.junit.Test\n    public void testDocumentSplitting() throws Exception\n    {\n        // Create xwiki/2.0 document.\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"=Heading1=\").append(\"\\n\");\n        buffer.append(\"Content\").append(\"\\n\");\n        buffer.append(\"==Heading11==\").append(\"\\n\");\n        buffer.append(\"Content\").append(\"\\n\");\n        buffer.append(\"==Heading12==\").append(\"\\n\");\n        buffer.append(\"Content\").append(\"\\n\");\n        buffer.append(\"=Heading2=\").append(\"\\n\");\n        buffer.append(\"Content\").append(\"\\n\");\n        XDOM xdom = xwikiSyntaxParser.parse(new StringReader(buffer.toString()));\n\n        // Create xdom office document.\n        XDOMOfficeDocument officeDocument =\n            new XDOMOfficeDocument(xdom, new HashMap<String, byte[]>(), getComponentManager());\n        final DocumentReference baseDocument = new DocumentReference(\"xwiki\", \"Test\", \"Test\");\n\n        // Add expectations to mock document name serializer. \n        getMockery().checking(new Expectations() {{\n            allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(baseDocument);\n            will(returnValue(\"Test.Test\"));\n            allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(new DocumentReference(\"xwiki\", \"Test\", \"Heading1\"));\n            will(returnValue(\"Test.Heading1\"));\n            allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(new DocumentReference(\"xwiki\", \"Test\", \"Heading11\"));\n            will(returnValue(\"Test.Heading11\"));\n            allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(new DocumentReference(\"xwiki\", \"Test\", \"Heading12\"));\n            will(returnValue(\"Test.Heading12\"));\n            allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(new DocumentReference(\"xwiki\", \"Test\", \"Heading2\"));\n            will(returnValue(\"Test.Heading2\"));\n        }});\n        \n        // Add expectations to mock document name factory.         \n        getMockery().checking(new Expectations() {{\n            allowing(mockDocumentReferenceResolver).resolve(\"Test.Test\");\n            will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Test\")));\n            allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading1\");\n            will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading1\")));\n            allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading11\");\n            will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading11\")));\n            allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading12\");\n            will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading12\")));\n            allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading2\");\n            will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading2\")));\n        }});\n        \n        // Add expectations to mock document access bridge.\n        getMockery().checking(new Expectations() {{\n            allowing(mockDocumentAccessBridge).exists(\"Test.Heading1\");\n            will(returnValue(false));\n            allowing(mockDocumentAccessBridge).exists(\"Test.Heading11\");\n            will(returnValue(false));\n            allowing(mockDocumentAccessBridge).exists(\"Test.Heading12\");\n            will(returnValue(false));\n            allowing(mockDocumentAccessBridge).exists(\"Test.Heading2\");\n            will(returnValue(false));\n        }});\n\n        // Perform the split operation.\n        Map<TargetDocumentDescriptor, XDOMOfficeDocument> result =\n            officeDocumentSplitter.split(officeDocument, new int[] {1, 2, 3, 4, 5, 6}, \"headingNames\", baseDocument);\n        \n        // There should be five xdom office documents.\n        Assert.assertEquals(5, result.size());\n    }","id":98183,"modified_method":"/**\n     * Test basic document splitting.\n     * \n     * @throws Exception if it fails to parse the wiki syntax or if it fails to split the document\n     */\n    @Test\n    public void testDocumentSplitting() throws Exception\n    {\n        // Create xwiki/2.0 document.\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"=Heading1=\").append('\\n');\n        buffer.append(\"Content\").append('\\n');\n        buffer.append(\"==Heading11==\").append('\\n');\n        buffer.append(\"Content\").append('\\n');\n        buffer.append(\"==Heading12==\").append('\\n');\n        buffer.append(\"Content\").append('\\n');\n        buffer.append(\"=Heading2=\").append('\\n');\n        buffer.append(\"Content\").append('\\n');\n        XDOM xdom = xwikiSyntaxParser.parse(new StringReader(buffer.toString()));\n\n        // Create xdom office document.\n        XDOMOfficeDocument officeDocument =\n            new XDOMOfficeDocument(xdom, new HashMap<String, byte[]>(), getComponentManager());\n        final DocumentReference baseDocument = new DocumentReference(\"xwiki\", \"Test\", \"Test\");\n\n        // Add expectations to mock document name serializer.\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(baseDocument);\n                will(returnValue(\"Test.Test\"));\n                allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(\n                    new DocumentReference(\"xwiki\", \"Test\", \"Heading1\"));\n                will(returnValue(\"Test.Heading1\"));\n                allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(\n                    new DocumentReference(\"xwiki\", \"Test\", \"Heading11\"));\n                will(returnValue(\"Test.Heading11\"));\n                allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(\n                    new DocumentReference(\"xwiki\", \"Test\", \"Heading12\"));\n                will(returnValue(\"Test.Heading12\"));\n                allowing(mockCompactWikiStringEntityReferenceSerializer).serialize(\n                    new DocumentReference(\"xwiki\", \"Test\", \"Heading2\"));\n                will(returnValue(\"Test.Heading2\"));\n            }\n        });\n\n        // Add expectations to mock document name factory.\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockDocumentReferenceResolver).resolve(\"Test.Test\");\n                will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Test\")));\n                allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading1\");\n                will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading1\")));\n                allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading11\");\n                will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading11\")));\n                allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading12\");\n                will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading12\")));\n                allowing(mockDocumentReferenceResolver).resolve(\"Test.Heading2\");\n                will(returnValue(new DocumentReference(\"xwiki\", \"Test\", \"Heading2\")));\n            }\n        });\n\n        // Add expectations to mock document access bridge.\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockDocumentAccessBridge).exists(\"Test.Heading1\");\n                will(returnValue(false));\n                allowing(mockDocumentAccessBridge).exists(\"Test.Heading11\");\n                will(returnValue(false));\n                allowing(mockDocumentAccessBridge).exists(\"Test.Heading12\");\n                will(returnValue(false));\n                allowing(mockDocumentAccessBridge).exists(\"Test.Heading2\");\n                will(returnValue(false));\n            }\n        });\n\n        // Perform the split operation.\n        Map<TargetDocumentDescriptor, XDOMOfficeDocument> result =\n            officeDocumentSplitter.split(officeDocument, new int[] {1, 2, 3, 4, 5, 6}, \"headingNames\", baseDocument);\n\n        // There should be five XDOM office documents.\n        Assert.assertEquals(5, result.size());\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return target document reference as a string.\n     */\n    public String getDocumentReferenceAsString()\n    {\n        return serializeDocumentRefefence(getDocumentReference(), DEFAULT_COMPONENT_HINT);\n    }","id":98184,"modified_method":"/**\n     * @return target document reference as a string.\n     */\n    public String getDocumentReferenceAsString()\n    {\n        return serializer.serialize(getDocumentReference());\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return name of the parent document reference\n     */\n    public String getParentReferenceAsString()\n    {\n        return (null != getParentReference()) ? serializeDocumentRefefence(\n            getParentReference(), DEFAULT_COMPONENT_HINT) : null;\n    }","id":98185,"modified_method":"/**\n     * @return name of the parent document reference\n     */\n    public String getParentReferenceAsString()\n    {\n        return (null != getParentReference()) ? serializer.serialize(getParentReference()) : null;\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Creates a new {@link TargetDocumentDescriptor} instance.\n     * \n     * @param documentReference reference of the target document\n     * @param componentManager used to lookup for various name serializers.\n     */\n    public TargetDocumentDescriptor(DocumentReference documentReference, ComponentManager componentManager)\n    {\n        this.documentReference = documentReference;\n        this.componentManager = componentManager;\n    }","id":98186,"modified_method":"/**\n     * Creates a new {@link TargetDocumentDescriptor} instance.\n     * \n     * @param documentReference reference of the target document\n     * @param componentManager used to lookup the entity reference serializer\n     */\n    public TargetDocumentDescriptor(DocumentReference documentReference, ComponentManager componentManager)\n    {\n        this.documentReference = documentReference;\n        try {\n            this.serializer = componentManager.getInstance(EntityReferenceSerializer.TYPE_STRING);\n        } catch (ComponentLookupException e) {\n            // Shouldn't happen.\n            this.serializer = null;\n        }\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private XDOMOfficeDocument createOfficeDocument(String content, String syntax) throws Exception\n    {\n        Parser parser = getComponentManager().getInstance(Parser.class, syntax);\n        XDOM xdom = parser.parse(new StringReader(content));        \n        return new XDOMOfficeDocument(xdom, new HashMap<String, byte[]>(), getComponentManager());\n    }","id":98187,"modified_method":"/**\n     * Creates an {@link XDOMOfficeDocument} by parsing the given content.\n     * \n     * @param content the content to be parsed\n     * @param syntax the syntax of the given content\n     * @return the created {@link XDOMOfficeDocument}\n     * @throws Exception if it fails to parse the given content\n     */\n    private XDOMOfficeDocument createOfficeDocument(String content, String syntax) throws Exception\n    {\n        Parser parser = getComponentManager().getInstance(Parser.class, syntax);\n        XDOM xdom = parser.parse(new StringReader(content));\n        return new XDOMOfficeDocument(xdom, new HashMap<String, byte[]>(), getComponentManager());\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testTitleExtraction() throws Exception\n    {\n        String content = \"content before title\\n\" +\n        \t\t\"%s Title %s\\n\" +\n        \t\t\"content after title.\";\n        XDOMOfficeDocument doc = createOfficeDocument(String.format(content, \"=\", \"=\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n        \n        doc = createOfficeDocument(String.format(content, \"==\", \"==\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n        \n        doc = createOfficeDocument(String.format(content, \"===\", \"===\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n        \n        doc = createOfficeDocument(String.format(content, \"====\", \"====\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n        \n        doc = createOfficeDocument(String.format(content, \"=====\", \"=====\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n        \n        doc = createOfficeDocument(String.format(content, \"======\", \"======\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n    }","id":98188,"modified_method":"/**\n     * Tests how document title is extracted from the content of the imported document.\n     * \n     * @throws Exception if it fails to extract the title\n     */\n    @Test\n    public void testTitleExtraction() throws Exception\n    {\n        String content = \"content before title\\n\" + \"%s Title %s\\n\" + \"content after title.\";\n        XDOMOfficeDocument doc = createOfficeDocument(String.format(content, \"=\", \"=\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n\n        doc = createOfficeDocument(String.format(content, \"==\", \"==\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n\n        doc = createOfficeDocument(String.format(content, \"===\", \"===\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n\n        doc = createOfficeDocument(String.format(content, \"====\", \"====\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n\n        doc = createOfficeDocument(String.format(content, \"=====\", \"=====\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n\n        doc = createOfficeDocument(String.format(content, \"======\", \"======\"), \"xwiki/2.0\");\n        Assert.assertEquals(\"Title\", doc.getTitle());\n    }","commit_id":"14a6cfcb921751e7d251f29954e5846179bac762","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected MacroContentTableBlockDataSource getDataSource()\n    {\n        return source;\n    }","id":98189,"modified_method":"protected MacroContentTableBlockDataSource getDataSource()\n    {\n        return this.source;\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void buildDataset(String macroContent, Map<String, String> parameters)\n        throws MacroExecutionException\n    {\n        validateParameters(parameters);\n\n        TableBlock tableBlock = getTableBlock(macroContent);\n\n        int[] dataRange = getDataRange(tableBlock);\n\n        DatasetType datasetType = getDatasetType();\n\n        TableDatasetBuilder datasetBuilder;\n        setChartModel(new SimpleChartModel());\n\n        switch (getDatasetType()) {\n            case CATEGORY:\n                datasetBuilder = new TableCategoryDatasetBuilder();\n                break;\n            case PIE:\n                datasetBuilder = new TablePieDatasetBuilder();\n                break;\n            case TIMETABLE_XY:\n                datasetBuilder = new TableTimeTableXYBuilder();\n                break;\n            default:\n                throw new MacroExecutionException(String.format(\"Unsupported dataset type [%s]\",\n                    getDatasetType().getName()));\n        }\n\n        setAxes();\n\n        datasetBuilder.setLocaleConfiguration(getLocaleConfiguration());\n        datasetBuilder.setParameters(parameters);\n\n        if (SERIES_COLUMNS.equals(series)) {\n            datasetBuilder.setTranspose(true);\n        }\n\n        buildDataset(tableBlock, dataRange, datasetBuilder);\n\n        setDataset(datasetBuilder.getDataset());\n    }","id":98190,"modified_method":"@Override\n    public void buildDataset(String macroContent, Map<String, String> parameters, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        validateParameters(parameters);\n\n        TableBlock tableBlock = getTableBlock(macroContent, context);\n\n        int[] dataRange = getDataRange(tableBlock);\n\n        TableDatasetBuilder datasetBuilder;\n        setChartModel(new SimpleChartModel());\n\n        switch (getDatasetType()) {\n            case CATEGORY:\n                datasetBuilder = new TableCategoryDatasetBuilder();\n                break;\n            case PIE:\n                datasetBuilder = new TablePieDatasetBuilder();\n                break;\n            case TIMETABLE_XY:\n                datasetBuilder = new TableTimeTableXYBuilder();\n                break;\n            default:\n                throw new MacroExecutionException(String.format(\"Unsupported dataset type [%s]\",\n                    getDatasetType().getName()));\n        }\n\n        setAxes();\n\n        datasetBuilder.setLocaleConfiguration(getLocaleConfiguration());\n        datasetBuilder.setParameters(parameters);\n\n        if (SERIES_COLUMNS.equals(series)) {\n            datasetBuilder.setTranspose(true);\n        }\n\n        buildDataset(tableBlock, dataRange, datasetBuilder);\n\n        setDataset(datasetBuilder.getDataset());\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Builds the chart image according to the specifications passed in.\n     *\n     * @param parameters macro parameters\n     * @param content macro content\n     * @return the name of the generated image file\n     * @throws MacroExecutionException if an error occurs while generating / saving the chart image\n     */\n    private String generateChart(ChartMacroParameters parameters, String content)\n        throws MacroExecutionException\n    {\n        File chartFile;\n        try {\n            DataSource dataSource = this.componentManager.getInstance(DataSource.class, parameters.getSource());\n            Map<String, String> sourceParameters = getSourceParameters(parameters);\n\n            dataSource.buildDataset(content, sourceParameters);\n\n            byte[] chart = this.chartGenerator.generate(dataSource.getChartModel(), sourceParameters);\n            chartFile = getChartImageFile(parameters);\n            FileOutputStream fos = new FileOutputStream(chartFile);\n            fos.write(chart);\n            fos.close();\n        } catch (ComponentLookupException ex) {\n            throw new MacroExecutionException(String.format(\"Invalid source parameter [%s].\",\n                parameters.getSource()), ex);\n        } catch (ChartGeneratorException ex) {\n            throw new MacroExecutionException(\"Error while rendering chart.\", ex);\n        } catch (Exception ex) {\n            throw new MacroExecutionException(\"Error while saving chart image.\", ex);\n        }\n        return chartFile.getName();\n    }","id":98191,"modified_method":"/**\n     * Builds the chart image according to the specifications passed in.\n     *\n     * @param parameters the macro parameters\n     * @param content the macro content\n     * @param context the macro transformation context, used for example to find out the current document reference\n     * @throws MacroExecutionException if an error occurs while generating / saving the chart image\n     */\n    private void generateChart(ChartMacroParameters parameters, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        try {\n            DataSource dataSource = this.componentManager.getInstance(DataSource.class, parameters.getSource());\n            Map<String, String> sourceParameters = getSourceParameters(parameters);\n\n            dataSource.buildDataset(content, sourceParameters, context);\n\n            byte[] chart = this.chartGenerator.generate(dataSource.getChartModel(), sourceParameters);\n            File imageFile = this.imageLocator.getStorageLocation(new ImageId(parameters));\n            FileOutputStream fos = new FileOutputStream(imageFile);\n            fos.write(chart);\n            fos.close();\n        } catch (ComponentLookupException ex) {\n            throw new MacroExecutionException(String.format(\"Invalid source parameter [%s].\",\n                parameters.getSource()), ex);\n        } catch (ChartGeneratorException ex) {\n            throw new MacroExecutionException(\"Error while rendering chart.\", ex);\n        } catch (Exception ex) {\n            throw new MacroExecutionException(\"Error while saving chart image.\", ex);\n        }\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public List<Block> execute(ChartMacroParameters macroParams, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        String imageLocation =\n            this.documentAccessBridge.getDocumentURL(null, \"charting\", null, null)\n                + \"/\" + generateChart(macroParams, content);\n        String title = macroParams.getTitle();\n        ResourceReference reference = new ResourceReference(imageLocation, ResourceType.URL);\n        ImageBlock imageBlock = new ImageBlock(new ResourceReference(imageLocation, ResourceType.URL), true);\n        imageBlock.setParameter(\"alt\", title);\n        LinkBlock linkBlock = new LinkBlock(Collections.singletonList((Block) imageBlock), reference, true);\n        linkBlock.setParameter(\"title\", title);\n\n        // If the macro is used standalone then we need to wrap it in a paragraph block.\n        Block resultBlock;\n        if (context.isInline()) {\n            resultBlock = linkBlock;\n        } else {\n            resultBlock = new ParagraphBlock(Collections.singletonList((Block) linkBlock));\n        }\n\n        return Collections.singletonList(resultBlock);\n    }","id":98192,"modified_method":"@Override\n    public List<Block> execute(ChartMacroParameters macroParams, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        // Generate the chart image in a temporary location.\n        generateChart(macroParams, content, context);\n\n        String imageLocation = this.imageLocator.getURL(new ImageId(macroParams));\n        String title = macroParams.getTitle();\n        ResourceReference reference = new ResourceReference(imageLocation, ResourceType.URL);\n        ImageBlock imageBlock = new ImageBlock(new ResourceReference(imageLocation, ResourceType.URL), true);\n        imageBlock.setParameter(\"alt\", title);\n        LinkBlock linkBlock = new LinkBlock(Collections.singletonList((Block) imageBlock), reference, true);\n        linkBlock.setParameter(\"title\", title);\n\n        // If the macro is used standalone then we need to wrap it in a paragraph block.\n        Block resultBlock;\n        if (context.isInline()) {\n            resultBlock = linkBlock;\n        } else {\n            resultBlock = new ParagraphBlock(Collections.singletonList((Block) linkBlock));\n        }\n\n        return Collections.singletonList(resultBlock);\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected void validateParameters() throws MacroExecutionException\n    {\n        super.validateParameters();\n\n        if (null == documentRef) {\n            documentRef = this.docBridge.getCurrentDocumentReference();\n        } else if (!authorizationManager.hasAccess(Right.VIEW,\n            docBridge.getCurrentUserReference(),\n            documentRef))\n        {\n            throw new MacroExecutionException(\"You do not have permission to view the document.\");\n        }\n\n        if (!docBridge.exists(documentRef)) {\n            throw new MacroExecutionException(String.format(\"Document [%s] does not exist.\",\n                entityReferenceSerializer.serialize(documentRef)));\n        }\n    }","id":98193,"modified_method":"@Override\n    protected void validateParameters() throws MacroExecutionException\n    {\n        super.validateParameters();\n\n        if (null == this.documentRef) {\n            this.documentRef = this.docBridge.getCurrentDocumentReference();\n        } else if (!authorizationManager.hasAccess(Right.VIEW,\n            this.docBridge.getCurrentUserReference(),\n            this.documentRef))\n        {\n            throw new MacroExecutionException(\"You do not have permission to view the document.\");\n        }\n\n        if (!this.docBridge.exists(this.documentRef)) {\n            throw new MacroExecutionException(String.format(\"Document [%s] does not exist.\",\n                this.entityReferenceSerializer.serialize(this.documentRef)));\n        }\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected boolean setParameter(String key, String value) throws MacroExecutionException\n    {\n        if (DOCUMENT_PARAM.equals(key)) {\n            documentRef = documentReferenceResolver.resolve(value);\n            return true;\n        }\n\n        if (TABLE_PARAM.equals(key)) {\n            tableId = value;\n            return true;\n        }\n\n        return super.setParameter(key, value);\n    }","id":98194,"modified_method":"@Override\n    protected boolean setParameter(String key, String value) throws MacroExecutionException\n    {\n        if (DOCUMENT_PARAM.equals(key)) {\n            this.documentRef = this.documentReferenceResolver.resolve(value);\n            return true;\n        }\n\n        if (TABLE_PARAM.equals(key)) {\n            this.tableId = value;\n            return true;\n        }\n\n        return super.setParameter(key, value);\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        // Document Access Bridge Mock\n        final DocumentAccessBridge mockDocumentAccessBridge = mockery.mock(DocumentAccessBridge.class);\n        DefaultComponentDescriptor<DocumentAccessBridge> descriptorDAB =\n            new DefaultComponentDescriptor<DocumentAccessBridge>();\n        descriptorDAB.setRoleType(DocumentAccessBridge.class);\n        componentManager.registerComponent(descriptorDAB, mockDocumentAccessBridge);\n        final VelocityManager velocityManager = mockery.mock(VelocityManager.class);\n        DefaultComponentDescriptor<VelocityManager> descriptorVM =\n            new DefaultComponentDescriptor<VelocityManager>();\n        descriptorVM.setRoleType(VelocityManager.class);\n        componentManager.registerComponent(descriptorVM, velocityManager);\n        final AuthorizationManager authorizationManager = mockery.mock(AuthorizationManager.class);\n        DefaultComponentDescriptor<AuthorizationManager> descriptorAM =\n            new DefaultComponentDescriptor<AuthorizationManager>();\n        descriptorAM.setRoleType(AuthorizationManager.class);\n        componentManager.registerComponent(descriptorAM, authorizationManager);\n        final VelocityEngine velocityEngine = mockery.mock(VelocityEngine.class);\n        DefaultComponentDescriptor<VelocityEngine> descriptorVE =\n            new DefaultComponentDescriptor<VelocityEngine>();\n        descriptorVE.setRoleType(VelocityEngine.class);\n        componentManager.registerComponent(descriptorVE, velocityEngine);\n\n        final DocumentReference documentReference = new DocumentReference(\"xwiki\", \"Test\", \"Test\");\n        final DocumentModelBridge mockDocument = mockery.mock(DocumentModelBridge.class);\n\n        ExecutionContext executionContext = new ExecutionContext();\n        executionContext.setProperty(\"xwikicontext\", new HashMap<Object, Object>());\n\n        componentManager.<Execution>getInstance(Execution.class).setContext(executionContext);\n\n        final Parser parser = componentManager.getInstance(Parser.class, Syntax.XWIKI_2_0.toIdString());\n        final XDOM xdom =  parser.parse(new InputStreamReader(\n           getClass().getClassLoader().getResourceAsStream(WIKI_CONTENT_FILE)));\n\n        mockery.checking(new Expectations() {{\n            allowing(mockDocumentAccessBridge).getDocumentURL(with(any(DocumentReference.class)),\n                                                              with(equal(\"charting\")),\n                                                              with(any(String.class)),\n                                                              with(any(String.class)));\n                will(returnValue(\"http://localhost/charts\"));\n            allowing(mockDocumentAccessBridge).getCurrentDocumentReference();\n                will(returnValue(documentReference));\n            allowing(mockDocumentAccessBridge).getDocument(documentReference);\n                will(returnValue(mockDocument));\n            allowing(mockDocument).getDocumentReference();\n                will(returnValue(documentReference));\n            allowing(mockDocument).getSyntax();\n                will(returnValue(Syntax.XWIKI_2_0));\n            allowing(mockDocument).getRealLanguage();\n                will(returnValue(\"en\"));\n            allowing(mockDocumentAccessBridge).exists(with(any(DocumentReference.class)));\n                will(returnValue(true));\n            allowing(mockDocumentAccessBridge).getDocumentContent(with(documentReference), with(any(String.class)));\n                will(returnValue(IOUtils.toString(\n                    getClass().getClassLoader().getResourceAsStream(WIKI_CONTENT_FILE))));\n            allowing(mockDocumentAccessBridge).getCurrentUserReference();\n                will(returnValue(null));\n            allowing(authorizationManager).hasAccess(with(any(Right.class)),\n                                                     with(any(DocumentReference.class)),\n                                                     with(any(EntityReference.class)));\n                will(returnValue(true));\n            allowing(velocityManager).getVelocityEngine();\n                will(returnValue(velocityEngine));\n            allowing(velocityEngine).startedUsingMacroNamespace(with(any(String.class)));\n            allowing(velocityEngine).stoppedUsingMacroNamespace(with(any(String.class)));\n            allowing(mockDocument).getXDOM();\n                will(returnValue(xdom));\n\n            // Methods for Multiwiki component managers\n            allowing(mockDocumentAccessBridge).getCurrentUser();\n                will(returnValue(\"XWiki.UnknownUser\"));\n            allowing(mockDocumentAccessBridge).getCurrentWiki();\n                will(returnValue(\"wiki\"));\n       }});\n\n        // Document Name Serializer Mock\n        final EntityReferenceSerializer mockEntityReferenceSerializer = mockery.mock(EntityReferenceSerializer.class);\n        DefaultComponentDescriptor<EntityReferenceSerializer> descriptorERS =\n            new DefaultComponentDescriptor<EntityReferenceSerializer>();\n        descriptorERS.setRoleType(EntityReferenceSerializer.TYPE_STRING);\n        componentManager.registerComponent(descriptorERS, mockEntityReferenceSerializer);\n\n        mockery.checking(new Expectations() {{\n            allowing(mockEntityReferenceSerializer).serialize(documentReference); will(returnValue(\"Test.Test\"));\n        }});\n    }","id":98195,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        final ModelContext modelContext = componentManager.registerMockComponent(mockery, ModelContext.class);\n        mockery.checking(new Expectations() {{\n            allowing(modelContext).getCurrentEntityReference();\n                will(returnValue(new WikiReference(\"currentWiki\")));\n        }});\n\n        // Document Access Bridge Mock\n        final DocumentAccessBridge dab = componentManager.registerMockComponent(mockery, DocumentAccessBridge.class);\n        final DocumentReference documentReference = new DocumentReference(\"wiki\", \"space\", \"page\");\n        final DocumentModelBridge document = mockery.mock(DocumentModelBridge.class);\n        final DocumentDisplayer displayer = componentManager.registerMockComponent(mockery, DocumentDisplayer.class);\n\n        Parser parser = componentManager.getInstance(Parser.class, Syntax.XWIKI_2_0.toIdString());\n        final XDOM xdom = parser.parse(new InputStreamReader(\n            getClass().getClassLoader().getResourceAsStream(WIKI_CONTENT_FILE)));\n\n        final AuthorizationManager authorizationManager =\n            componentManager.registerMockComponent(mockery,  AuthorizationManager.class);\n\n        mockery.checking(new Expectations() {{\n            // Methods for Multiwiki component managers\n            allowing(dab).getCurrentUser();\n                will(returnValue(\"XWiki.CurrentUser\"));\n            allowing(dab).getCurrentWiki();\n                will(returnValue(\"currentWiki\"));\n\n            allowing(dab).getDocumentURL(new DocumentReference(\"unused\", \"space\", \"page\"), \"temp\", null, null);\n                will(returnValue(\"temppath\"));\n\n            allowing(dab).getCurrentDocumentReference();\n                will(returnValue(documentReference));\n            allowing(dab).exists(documentReference);\n                will(returnValue(true));\n            allowing(dab).getDocument(documentReference);\n                will(returnValue(document));\n            allowing(displayer).display(with(equal(document)), with(any(DocumentDisplayerParameters.class)));\n                will(returnValue(xdom));\n\n            allowing(dab).getCurrentUserReference();\n                will(returnValue(null));\n            allowing(authorizationManager).hasAccess(Right.VIEW, null, documentReference);\n                will(returnValue(true));\n        }});\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGetTableBlockWhenNullMacroContent() throws Exception\n    {\n        try {\n            getDataSource().getTableBlock(null);\n            Assert.fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            Assert.assertEquals(\"A Chart Macro using an inline source must have a data table defined in its content.\",\n                expected.getMessage());\n        }\n    }","id":98196,"modified_method":"@Test\n    public void testGetTableBlockWhenNullMacroContent() throws Exception\n    {\n        try {\n            getDataSource().getTableBlock(null, null);\n            Assert.fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            Assert.assertEquals(\"A Chart Macro using an inline source must have a data table defined in its content.\",\n                expected.getMessage());\n        }\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGetTableBlockWhenMacroContentDoesntContainTable() throws Exception\n    {\n        try {\n            getDataSource().getTableBlock(\"not a table\");\n            Assert.fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            Assert.assertEquals(\"Unable to locate a suitable data table.\", expected.getMessage());\n        }\n    }","id":98197,"modified_method":"@Test\n    public void testGetTableBlockWhenMacroContentDoesntContainTable() throws Exception\n    {\n        // Simulate a macro content of \"not a table\", i.e. not containing a table.\n        setUpContentExpectation(\"not a table\");\n\n        try {\n            getDataSource().getTableBlock(\"not a table\", null);\n            Assert.fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            Assert.assertEquals(\"Unable to locate a suitable data table.\", expected.getMessage());\n        }\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGetTableBlockWhenEmptyMacroContent() throws Exception\n    {\n        try {\n            getDataSource().getTableBlock(\"\");\n            Assert.fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            Assert.assertEquals(\"A Chart Macro using an inline source must have a data table defined in its content.\",\n                expected.getMessage());\n        }\n    }","id":98198,"modified_method":"@Test\n    public void testGetTableBlockWhenEmptyMacroContent() throws Exception\n    {\n        try {\n            getDataSource().getTableBlock(\"\", null);\n            Assert.fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            Assert.assertEquals(\"A Chart Macro using an inline source must have a data table defined in its content.\",\n                expected.getMessage());\n        }\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testBuildCategoryDatasetColumnsSeries() throws Exception {\n        getDataSource().buildDataset(\"| column 1 | column 2 | column 3 | column 4\\n\" +\n                                     \"| row 1 | 12 | 13 | 14 \\n\" +\n                                     \"| row 2 | 22 | 23 | 24 \\n\",\n                                     map(\"type\", \"line\",\n                                         \"range\", \"B2-D3\",\n                                         \"series\", \"columns\"));\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof CategoryDataset);\n        Assert.assertTrue(chartModel.getAxis(0) instanceof CategoryAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n\n        CategoryDataset categoryDataset = (CategoryDataset) dataset;\n\n        Assert.assertTrue(categoryDataset.getColumnKey(0).equals(\" row 1 \"));\n        Assert.assertTrue(categoryDataset.getColumnKey(1).equals(\" row 2 \"));\n\n        Assert.assertTrue(categoryDataset.getRowKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(categoryDataset.getRowKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(categoryDataset.getRowKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(categoryDataset.getValue(0, 0).intValue() == 12);\n        Assert.assertTrue(categoryDataset.getValue(1, 0).intValue() == 13);\n        Assert.assertTrue(categoryDataset.getValue(2, 0).intValue() == 14);\n        Assert.assertTrue(categoryDataset.getValue(0, 1).intValue() == 22);\n        Assert.assertTrue(categoryDataset.getValue(1, 1).intValue() == 23);\n        Assert.assertTrue(categoryDataset.getValue(2, 1).intValue() == 24);\n    }","id":98199,"modified_method":"@Test\n    public void testBuildCategoryDatasetColumnsSeries() throws Exception\n    {\n        String content =\n            \"| column 1 | column 2 | column 3 | column 4\\n\" +\n            \"| row 1 | 12 | 13 | 14 \\n\" +\n            \"| row 2 | 22 | 23 | 24 \\n\";\n        setUpContentExpectation(content);\n\n        getDataSource().buildDataset(content, map(\"type\", \"line\", \"range\", \"B2-D3\", \"series\", \"columns\"), null);\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof CategoryDataset);\n        Assert.assertTrue(chartModel.getAxis(0) instanceof CategoryAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n\n        CategoryDataset categoryDataset = (CategoryDataset) dataset;\n\n        Assert.assertTrue(categoryDataset.getColumnKey(0).equals(\" row 1 \"));\n        Assert.assertTrue(categoryDataset.getColumnKey(1).equals(\" row 2 \"));\n\n        Assert.assertTrue(categoryDataset.getRowKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(categoryDataset.getRowKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(categoryDataset.getRowKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(categoryDataset.getValue(0, 0).intValue() == 12);\n        Assert.assertTrue(categoryDataset.getValue(1, 0).intValue() == 13);\n        Assert.assertTrue(categoryDataset.getValue(2, 0).intValue() == 14);\n        Assert.assertTrue(categoryDataset.getValue(0, 1).intValue() == 22);\n        Assert.assertTrue(categoryDataset.getValue(1, 1).intValue() == 23);\n        Assert.assertTrue(categoryDataset.getValue(2, 1).intValue() == 24);\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testBuildCategoryDataset() throws Exception {\n        getDataSource().buildDataset(\"| column 1 | column 2 | column 3 | column 4\\n\" +\n                                     \"| row 1 | 12 | 13 | 14 \\n\" +\n                                     \"| row 2 | 22 | 23 | 24 \\n\",\n                                     map(\"type\",  \"line\",\n                                         \"range\", \"B2-D3\"));\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof CategoryDataset);\n        Assert.assertTrue(chartModel.getAxis(0) instanceof CategoryAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n\n        CategoryDataset categoryDataset = (CategoryDataset) dataset;\n\n        Assert.assertTrue(categoryDataset.getRowKey(0).equals(\" row 1 \"));\n        Assert.assertTrue(categoryDataset.getRowKey(1).equals(\" row 2 \"));\n\n        Assert.assertTrue(categoryDataset.getColumnKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(categoryDataset.getColumnKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(categoryDataset.getColumnKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(categoryDataset.getValue(0, 0).intValue() == 12);\n        Assert.assertTrue(categoryDataset.getValue(0, 1).intValue() == 13);\n        Assert.assertTrue(categoryDataset.getValue(0, 2).intValue() == 14);\n        Assert.assertTrue(categoryDataset.getValue(1, 0).intValue() == 22);\n        Assert.assertTrue(categoryDataset.getValue(1, 1).intValue() == 23);\n        Assert.assertTrue(categoryDataset.getValue(1, 2).intValue() == 24);\n    }","id":98200,"modified_method":"@Test\n    public void testBuildCategoryDataset() throws Exception\n    {\n        String content =\n            \"| column 1 | column 2 | column 3 | column 4\\n\" +\n            \"| row 1 | 12 | 13 | 14 \\n\" +\n            \"| row 2 | 22 | 23 | 24 \\n\";\n        setUpContentExpectation(content);\n\n        getDataSource().buildDataset(content, map(\"type\", \"line\", \"range\", \"B2-D3\"), null);\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof CategoryDataset);\n        Assert.assertTrue(chartModel.getAxis(0) instanceof CategoryAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n\n        CategoryDataset categoryDataset = (CategoryDataset) dataset;\n\n        Assert.assertTrue(categoryDataset.getRowKey(0).equals(\" row 1 \"));\n        Assert.assertTrue(categoryDataset.getRowKey(1).equals(\" row 2 \"));\n\n        Assert.assertTrue(categoryDataset.getColumnKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(categoryDataset.getColumnKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(categoryDataset.getColumnKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(categoryDataset.getValue(0, 0).intValue() == 12);\n        Assert.assertTrue(categoryDataset.getValue(0, 1).intValue() == 13);\n        Assert.assertTrue(categoryDataset.getValue(0, 2).intValue() == 14);\n        Assert.assertTrue(categoryDataset.getValue(1, 0).intValue() == 22);\n        Assert.assertTrue(categoryDataset.getValue(1, 1).intValue() == 23);\n        Assert.assertTrue(categoryDataset.getValue(1, 2).intValue() == 24);\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testBuildPieDataset() throws Exception {\n        getDataSource().buildDataset(\"| column 1 | column 2 | column 3 | column 4\\n\" +\n                                     \"| row 1 | 12 | 13 | 14 \\n\" +\n                                     \"| row 2 | 22 | 23 | 24 \\n\",\n                                     map(\"type\",  \"pie\",\n                                         \"range\", \"B2-D3\"));\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof PieDataset);\n\n        PieDataset pieDataset = (PieDataset) dataset;\n\n        Assert.assertTrue(pieDataset.getKey(0).equals(\" row 1 \"));\n        Assert.assertTrue(pieDataset.getKey(1).equals(\" row 2 \"));\n\n        Assert.assertTrue(pieDataset.getValue(0).intValue() == 12);\n        Assert.assertTrue(pieDataset.getValue(1).intValue() == 22);\n    }","id":98201,"modified_method":"@Test\n    public void testBuildPieDataset() throws Exception\n    {\n        String content =\n            \"| column 1 | column 2 | column 3 | column 4\\n\" +\n            \"| row 1 | 12 | 13 | 14 \\n\" +\n            \"| row 2 | 22 | 23 | 24 \\n\";\n        setUpContentExpectation(content);\n\n        getDataSource().buildDataset(content, map(\"type\", \"pie\", \"range\", \"B2-D3\"), null);\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof PieDataset);\n\n        PieDataset pieDataset = (PieDataset) dataset;\n\n        Assert.assertTrue(pieDataset.getKey(0).equals(\" row 1 \"));\n        Assert.assertTrue(pieDataset.getKey(1).equals(\" row 2 \"));\n\n        Assert.assertTrue(pieDataset.getValue(0).intValue() == 12);\n        Assert.assertTrue(pieDataset.getValue(1).intValue() == 22);\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testBuildPieDatasetRowsSeries() throws Exception {\n        getDataSource().buildDataset(\"| column 1 | column 2 | column 3 | column 4\\n\" +\n                                     \"| row 1 | 12 | 13 | 14 \\n\" +\n                                     \"| row 2 | 22 | 23 | 24 \\n\",\n                                     map(\"type\", \"pie\",\n                                         \"range\", \"B2-D3\",\n                                         \"series\", \"rows\"));\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof PieDataset);\n\n        PieDataset pieDataset = (PieDataset) dataset;\n\n        Assert.assertTrue(pieDataset.getKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(pieDataset.getKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(pieDataset.getKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(pieDataset.getValue(0).intValue() == 12);\n        Assert.assertTrue(pieDataset.getValue(1).intValue() == 13);\n        Assert.assertTrue(pieDataset.getValue(2).intValue() == 14);\n\n    }","id":98202,"modified_method":"@Test\n    public void testBuildPieDatasetRowsSeries() throws Exception\n    {\n        String content =\n            \"| column 1 | column 2 | column 3 | column 4\\n\" +\n            \"| row 1 | 12 | 13 | 14 \\n\" +\n            \"| row 2 | 22 | 23 | 24 \\n\";\n        setUpContentExpectation(content);\n\n        getDataSource().buildDataset(content, map(\"type\", \"pie\", \"range\", \"B2-D3\", \"series\", \"rows\"), null);\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Dataset dataset = chartModel.getDataset();\n\n        Assert.assertTrue(dataset instanceof PieDataset);\n\n        PieDataset pieDataset = (PieDataset) dataset;\n\n        Assert.assertTrue(pieDataset.getKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(pieDataset.getKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(pieDataset.getKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(pieDataset.getValue(0).intValue() == 12);\n        Assert.assertTrue(pieDataset.getValue(1).intValue() == 13);\n        Assert.assertTrue(pieDataset.getValue(2).intValue() == 14);\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testYearInterval() throws Exception\n    {\n        getDataSource().buildDataset(\"| Date | column 2 | column 3 | column 4\\n\" +\n                                     \"| 1970  | 12 | 13 | 14 \\n\" +\n                                     \"| 1971 |  22 | 23 | 24 \\n\",\n                                     map(\"type\",  \"xy_line_and_shape\",\n                                         \"dataset\", \"timetable_xy\",\n                                         \"range\", \"A2-D3\",\n                                         \"locale\", \"en_US\",\n                                         \"date_format\", \"yyyy\",\n                                         \"domain_axis_type\", \"date\",\n                                         \"time_period\", \"year\"));\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy\", new Locale(\"en\"));\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Assert.assertTrue(chartModel.getDataset() instanceof TimeTableXYDataset);\n\n        Assert.assertTrue(chartModel.getAxis(0) instanceof DateAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n\n        TimeTableXYDataset dataset = (TimeTableXYDataset) chartModel.getDataset();\n\n    }","id":98203,"modified_method":"@Test\n    public void testYearInterval() throws Exception\n    {\n        String content =\n            \"| Date | column 2 | column 3 | column 4\\n\" +\n            \"| 1970  | 12 | 13 | 14 \\n\" +\n            \"| 1971 |  22 | 23 | 24 \\n\";\n        setUpContentExpectation(content);\n\n        getDataSource().buildDataset(content, map(\n            \"type\", \"xy_line_and_shape\",\n            \"dataset\", \"timetable_xy\",\n            \"range\", \"A2-D3\",\n            \"locale\", \"en_US\",\n            \"date_format\", \"yyyy\",\n            \"domain_axis_type\", \"date\",\n            \"time_period\", \"year\"), null);\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Assert.assertTrue(chartModel.getDataset() instanceof TimeTableXYDataset);\n\n        Assert.assertTrue(chartModel.getAxis(0) instanceof DateAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testBuildTimeTableXY() throws Exception\n    {\n        getDataSource().buildDataset(\"| Date | column 2 | column 3 | column 4\\n\" +\n                                     \"| 2012-01-01 10:30:10 | 12 | 13 | 14 \\n\" +\n                                     \"| 2012-01-01 10:30:20 |  22 | 23 | 24 \\n\",\n                                     map(\"type\",  \"xy_line_and_shape\",\n                                         \"dataset\", \"timetable_xy\",\n                                         \"range\", \"A2-D3\",\n                                         \"locale\", \"en_US\",\n                                         \"date_format\", \"yyyy-MM-dd kk:mm:ss\",\n                                         \"domain_axis_type\", \"date\"));\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd kk:mm:ss\", new Locale(\"en\"));\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Assert.assertTrue(chartModel.getDataset() instanceof TimeTableXYDataset);\n\n        Assert.assertTrue(chartModel.getAxis(0) instanceof DateAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n\n        TimeTableXYDataset dataset = (TimeTableXYDataset) chartModel.getDataset();\n\n        Assert.assertTrue(dataset.getSeriesCount() == 3);\n\n        Assert.assertTrue(dataset.getSeriesKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(dataset.getSeriesKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(dataset.getSeriesKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(dataset.getTimePeriod(0).getStart().equals(new Date(0)));\n        Assert.assertTrue(dataset.getTimePeriod(0).getEnd().equals(dateFormat.parse(\"2012-01-01 10:30:10\")));\n\n        Assert.assertTrue(dataset.getTimePeriod(1).getStart().equals(dateFormat.parse(\"2012-01-01 10:30:10\")));\n        Assert.assertTrue(dataset.getTimePeriod(1).getEnd().equals(dateFormat.parse(\"2012-01-01 10:30:20\")));\n        \n\n    }","id":98204,"modified_method":"@Test\n    public void testBuildTimeTableXY() throws Exception\n    {\n        String content =\n            \"| Date | column 2 | column 3 | column 4\\n\" +\n            \"| 2012-01-01 10:30:10 | 12 | 13 | 14 \\n\" +\n            \"| 2012-01-01 10:30:20 |  22 | 23 | 24 \\n\";\n        setUpContentExpectation(content);\n\n        getDataSource().buildDataset(content, map(\n            \"type\", \"xy_line_and_shape\",\n            \"dataset\", \"timetable_xy\",\n            \"range\", \"A2-D3\",\n            \"locale\", \"en_US\",\n            \"date_format\", \"yyyy-MM-dd kk:mm:ss\",\n            \"domain_axis_type\", \"date\"), null);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd kk:mm:ss\", new Locale(\"en\"));\n\n        ChartModel chartModel = getDataSource().getChartModel();\n\n        Assert.assertTrue(chartModel.getDataset() instanceof TimeTableXYDataset);\n\n        Assert.assertTrue(chartModel.getAxis(0) instanceof DateAxis);\n        Assert.assertTrue(chartModel.getAxis(1) instanceof ValueAxis);\n\n        TimeTableXYDataset dataset = (TimeTableXYDataset) chartModel.getDataset();\n\n        Assert.assertTrue(dataset.getSeriesCount() == 3);\n\n        Assert.assertTrue(dataset.getSeriesKey(0).equals(\" column 2 \"));\n        Assert.assertTrue(dataset.getSeriesKey(1).equals(\" column 3 \"));\n        Assert.assertTrue(dataset.getSeriesKey(2).equals(\" column 4\"));\n\n        Assert.assertTrue(dataset.getTimePeriod(0).getStart().equals(new Date(0)));\n        Assert.assertTrue(dataset.getTimePeriod(0).getEnd().equals(dateFormat.parse(\"2012-01-01 10:30:10\")));\n\n        Assert.assertTrue(dataset.getTimePeriod(1).getStart().equals(dateFormat.parse(\"2012-01-01 10:30:10\")));\n        Assert.assertTrue(dataset.getTimePeriod(1).getEnd().equals(dateFormat.parse(\"2012-01-01 10:30:20\")));\n    }","commit_id":"e19a83dd75cf29980e878ee56b93b5f101e21256","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        new ScriptMockSetup(componentManager);\n\n        // Note: We're using a static Mock for the VelocityManager since it leads to a cleaner code\n        // (the Include Macro is reusing it too). We register this mock as real component in components.txt.\n    }","id":98205,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        new ScriptMockSetup(componentManager);\n\n        // Note: We're using a static Mock for the VelocityManager since it leads to a cleaner code\n        // (the Include Macro is reusing it too). We register this mock as real component in components.txt.\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n        new ScriptMockSetup(mockery, componentManager);\n\n        // fake nested script validator never fails\n        final EventListener nestedValidator\n            = mockery.mock(EventListener.class, \"nestedscriptmacrovalidator\");\n        mockery.checking(new Expectations() {{\n            atLeast(1).of(nestedValidator).onEvent(with(any(Event.class)), with(any(MacroTransformationContext.class)),\n                with(any(ScriptMacroParameters.class)));\n            allowing(nestedValidator).getName();\n                will(returnValue(\"nestedscriptmacrovalidator\"));\n            allowing(nestedValidator).getEvents();\n                will(returnValue(Collections.singletonList((Event) new ScriptEvaluatingEvent())));\n        }});\n        DefaultComponentDescriptor<EventListener> validatorDescriptor\n            = new DefaultComponentDescriptor<EventListener>();\n        validatorDescriptor.setRole(EventListener.class);\n        validatorDescriptor.setRoleHint(\"nestedscriptmacrovalidator\");\n        componentManager.registerComponent(validatorDescriptor, nestedValidator);\n    }","id":98206,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager cm) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n        new ScriptMockSetup(mockery, cm);\n\n        // fake nested script validator never fails\n        final EventListener nestedValidator =\n            cm.registerMockComponent(mockery, EventListener.class, \"nestedscriptmacrovalidator\");\n        mockery.checking(new Expectations() {{\n            atLeast(1).of(nestedValidator).onEvent(with(any(Event.class)), with(any(MacroTransformationContext.class)),\n                with(any(ScriptMacroParameters.class)));\n            allowing(nestedValidator).getName();\n                will(returnValue(\"nestedscriptmacrovalidator\"));\n            allowing(nestedValidator).getEvents();\n                will(returnValue(Collections.singletonList((Event) new ScriptEvaluatingEvent())));\n        }});\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        final SkinExtension ssfxMock = mockery.mock(SkinExtension.class, \"ssfxMock\");\n\n        mockery.checking(new Expectations()\n        {\n            {\n                String cssPath = \"uicomponents/container/columns.css\";\n                allowing(ssfxMock).use(with(cssPath));\n                allowing(ssfxMock).use(with(cssPath), with(any(Map.class)));\n            }\n        });\n\n        // and inject these in the test setup\n        DefaultComponentDescriptor<SkinExtension> ssfxDesc = new DefaultComponentDescriptor<SkinExtension>();\n        ssfxDesc.setRole(SkinExtension.class);\n        ssfxDesc.setRoleHint(\"ssfx\");\n\n        componentManager.registerComponent(ssfxDesc, ssfxMock);\n    }","id":98207,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        final SkinExtension ssfxMock = componentManager.registerMockComponent(mockery, SkinExtension.class, \"ssfx\");\n\n        mockery.checking(new Expectations()\n        {\n            {\n                String cssPath = \"uicomponents/container/columns.css\";\n                allowing(ssfxMock).use(with(cssPath));\n                allowing(ssfxMock).use(with(cssPath), with(any(Map.class)));\n            }\n        });\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        new ScriptMockSetup(componentManager);\n    }","id":98208,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        new ScriptMockSetup(componentManager);\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        // Document Access Bridge Mock\n        final DocumentAccessBridge mockDocumentAccessBridge = mockery.mock(DocumentAccessBridge.class);\n        DefaultComponentDescriptor<DocumentAccessBridge> descriptorDAB =\n            new DefaultComponentDescriptor<DocumentAccessBridge>();\n        descriptorDAB.setRoleType(DocumentAccessBridge.class);\n        componentManager.registerComponent(descriptorDAB, mockDocumentAccessBridge);\n\n        // Image Storage Mock\n        final ImageStorage mockImageStorage = mockery.mock(ImageStorage.class);\n        DefaultComponentDescriptor<ImageStorage> descriptorIS = new DefaultComponentDescriptor<ImageStorage>();\n        descriptorIS.setRoleType(ImageStorage.class);\n        componentManager.registerComponent(descriptorIS, mockImageStorage);\n\n        // Configuration Mock\n        final FormulaMacroConfiguration mockConfiguration = mockery.mock(FormulaMacroConfiguration.class);\n        DefaultComponentDescriptor<FormulaMacroConfiguration> descriptorEMC =\n            new DefaultComponentDescriptor<FormulaMacroConfiguration>();\n        descriptorEMC.setRoleType(FormulaMacroConfiguration.class);\n        componentManager.registerComponent(descriptorEMC, mockConfiguration);\n\n        mockery.checking(new Expectations()\n        {\n            {\n                atLeast(2).of(mockDocumentAccessBridge).getDocumentURL(null, \"tex\", null, null);\n                will(returnValue(\"/xwiki/bin/view/Main/\"));\n\n                atLeast(2).of(mockConfiguration).getRenderer();\n                will(returnValue(\"snuggletex\"));\n\n                atLeast(2).of(mockImageStorage).get(with(any(String.class)));\n                will(returnValue(null));\n\n                atLeast(2).of(mockImageStorage).put(with(any(String.class)), with(any(ImageData.class)));\n            }\n        });\n    }","id":98209,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        // Document Access Bridge Mock\n        final DocumentAccessBridge mockDocumentAccessBridge =\n            componentManager.registerMockComponent(mockery, DocumentAccessBridge.class);\n\n        // Image Storage Mock\n        final ImageStorage mockImageStorage = componentManager.registerMockComponent(mockery, ImageStorage.class);\n\n        // Configuration Mock\n        final FormulaMacroConfiguration mockConfiguration =\n            componentManager.registerMockComponent(mockery, FormulaMacroConfiguration.class);\n\n        mockery.checking(new Expectations()\n        {\n            {\n                atLeast(2).of(mockDocumentAccessBridge).getDocumentURL(null, \"tex\", null, null);\n                will(returnValue(\"/xwiki/bin/view/Main/\"));\n\n                atLeast(2).of(mockConfiguration).getRenderer();\n                will(returnValue(\"snuggletex\"));\n\n                atLeast(2).of(mockImageStorage).get(with(any(String.class)));\n                will(returnValue(null));\n\n                atLeast(2).of(mockImageStorage).put(with(any(String.class)), with(any(ImageData.class)));\n            }\n        });\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        new ScriptMockSetup(mockery, componentManager);\n\n        // Script Context Mock\n        final ScriptContextManager mockScriptContextManager = mockery.mock(ScriptContextManager.class);\n        final SimpleScriptContext scriptContext = new SimpleScriptContext();\n        scriptContext.setAttribute(\"var\", \"value\", ScriptContext.ENGINE_SCOPE);\n        mockery.checking(new Expectations() {{\n            allowing(mockScriptContextManager).getScriptContext(); will(returnValue(scriptContext));\n        }});\n        DefaultComponentDescriptor<ScriptContextManager> descriptorSCM =\n            new DefaultComponentDescriptor<ScriptContextManager>();\n        descriptorSCM.setRole(ScriptContextManager.class);\n        componentManager.registerComponent(descriptorSCM, mockScriptContextManager);\n    }","id":98210,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager cm) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        new ScriptMockSetup(mockery, cm);\n\n        // Script Context Mock\n        final ScriptContextManager scm = cm.registerMockComponent(mockery, ScriptContextManager.class);\n        final SimpleScriptContext scriptContext = new SimpleScriptContext();\n        scriptContext.setAttribute(\"var\", \"value\", ScriptContext.ENGINE_SCOPE);\n        mockery.checking(new Expectations() {{\n            allowing(scm).getScriptContext(); will(returnValue(scriptContext));\n        }});\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        new ScriptMockSetup(mockery, componentManager);\n\n        // Script Context Mock\n        final ScriptContextManager mockScriptContextManager = mockery.mock(ScriptContextManager.class);\n        final SimpleScriptContext scriptContext = new SimpleScriptContext();\n        scriptContext.setAttribute(\"var\", \"value\", ScriptContext.ENGINE_SCOPE);\n        mockery.checking(new Expectations() {{\n            allowing(mockScriptContextManager).getScriptContext(); will(returnValue(scriptContext));\n        }});\n        DefaultComponentDescriptor<ScriptContextManager> descriptorSCM =\n            new DefaultComponentDescriptor<ScriptContextManager>();\n        descriptorSCM.setRole(ScriptContextManager.class);\n        componentManager.registerComponent(descriptorSCM, mockScriptContextManager);\n    }","id":98211,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        new ScriptMockSetup(mockery, componentManager);\n\n        // Script Context Mock\n        final ScriptContextManager scm = componentManager.registerMockComponent(mockery, ScriptContextManager.class);\n        final SimpleScriptContext scriptContext = new SimpleScriptContext();\n        scriptContext.setAttribute(\"var\", \"value\", ScriptContext.ENGINE_SCOPE);\n        mockery.checking(new Expectations() {{\n            allowing(scm).getScriptContext(); will(returnValue(scriptContext));\n        }});\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n        registerMockSkinExtension(componentManager, mockery, \"jsfx\");\n        registerMockSkinExtension(componentManager, mockery, \"ssfx\");\n    }","id":98212,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        final SkinExtension jsfx = componentManager.registerMockComponent(mockery, SkinExtension.class, \"jsfx\", \"jsfx\");\n        final SkinExtension ssfx = componentManager.registerMockComponent(mockery, SkinExtension.class, \"ssfx\", \"ssfx\");\n\n        mockery.checking(new Expectations()\n        {\n            {\n                allowing(jsfx).use(with(aNonNull(String.class)), with(aNonNull(Map.class)));\n                allowing(ssfx).use(with(aNonNull(String.class)), with(aNonNull(Map.class)));\n            }\n        });\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        new ScriptMockSetup(componentManager);\n    }","id":98213,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(MockingComponentManager componentManager) throws Exception\n    {\n        new ScriptMockSetup(componentManager);\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @since 2.4RC1\n     */\n    public ScriptMockSetup(ComponentManager componentManager) throws Exception\n    {\n        this(new JUnit4Mockery(), componentManager);\n    }","id":98214,"modified_method":"public ScriptMockSetup(MockingComponentManager componentManager) throws Exception\n    {\n        this(new JUnit4Mockery(), componentManager);\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public ScriptMockSetup(Mockery mockery, ComponentManager componentManager) throws Exception\n    {\n        // Document Access Bridge Mock setup\n        bridge = mockery.mock(DocumentAccessBridge.class);\n        mockery.checking(new Expectations() {{\n            allowing(bridge).hasProgrammingRights(); will(returnValue(true));\n        }});\n\n        DefaultComponentDescriptor<DocumentAccessBridge> descriptorDAB =\n            new DefaultComponentDescriptor<DocumentAccessBridge>();\n        descriptorDAB.setRole(DocumentAccessBridge.class);\n        componentManager.registerComponent(descriptorDAB, bridge);\n\n        // Register a WikiModel mock so that we're in wiki mode (otherwise links will be considered as URLs for ex).\n        wikiModel = mockery.mock(WikiModel.class);\n        DefaultComponentDescriptor<WikiModel> descriptorWM =\n            new DefaultComponentDescriptor<WikiModel>();\n        descriptorWM.setRole(WikiModel.class);\n        componentManager.registerComponent(descriptorWM, wikiModel);\n\n        // Use a mock for the AttachmentReference Resolver\n        attachmentReferenceResolver = mockery.mock(AttachmentReferenceResolver.class);\n        DefaultComponentDescriptor<AttachmentReferenceResolver<String>> descriptorARF =\n            new DefaultComponentDescriptor<AttachmentReferenceResolver<String>>();\n        descriptorARF.setRoleType(AttachmentReferenceResolver.TYPE_STRING);\n        descriptorARF.setRoleHint(\"current\");\n        componentManager.registerComponent(descriptorARF, attachmentReferenceResolver);\n\n        // Use a mock for the DocumentReference Resolver\n        documentReferenceResolver = mockery.mock(DocumentReferenceResolver.class);\n        DefaultComponentDescriptor<DocumentReferenceResolver<String>> descriptorDRF =\n            new DefaultComponentDescriptor<DocumentReferenceResolver<String>>();\n        descriptorDRF.setRoleType(DocumentReferenceResolver.TYPE_STRING);\n        descriptorDRF.setRoleHint(\"current\");\n        componentManager.registerComponent(descriptorDRF, documentReferenceResolver);\n    }","id":98215,"modified_method":"public ScriptMockSetup(Mockery mockery, MockingComponentManager cm) throws Exception\n    {\n        // Document Access Bridge Mock setup\n        this.bridge = cm.registerMockComponent(mockery, DocumentAccessBridge.class);\n        mockery.checking(new Expectations() {{\n            allowing(bridge).hasProgrammingRights(); will(returnValue(true));\n        }});\n\n        // Register a WikiModel mock so that we're in wiki mode (otherwise links will be considered as URLs for ex).\n        this.wikiModel = cm.registerMockComponent(mockery, WikiModel.class);\n\n        // Use a mock for the AttachmentReference Resolver\n        this.attachmentReferenceResolver =\n            cm.registerMockComponent(mockery, AttachmentReferenceResolver.TYPE_STRING, \"current\");\n\n        // Use a mock for the DocumentReference Resolver\n        this.documentReferenceResolver =\n            cm.registerMockComponent(mockery, DocumentReferenceResolver.TYPE_STRING, \"current\");\n    }","commit_id":"5fd745ab1a0f8948a34cda891aaa06eba454dea4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public <T extends Script, M> CompiledScript<T, M> loadFromDir(ScriptSource source, ClassLoader classLoader, File scriptCacheDir,\n                                                                  File metadataCacheDir, CompileOperation<M> transformer, Class<T> scriptBaseClass,\n                                                                  ClassLoaderId classLoaderId) {\n        File metadataFile = new File(metadataCacheDir, METADATA_FILE_NAME);\n        try {\n            KryoBackedDecoder decoder = new KryoBackedDecoder(new FileInputStream(metadataFile));\n            try {\n                byte flags = decoder.readByte();\n                boolean isEmpty = (flags & EMPTY_FLAG) != 0;\n                boolean hasMethods = (flags & HAS_METHODS_FLAG) != 0;\n                if (isEmpty) {\n                    classLoaderCache.remove(classLoaderId);\n                }\n                M data;\n                if (transformer != null && transformer.getDataSerializer() != null) {\n                    data = transformer.getDataSerializer().read(decoder);\n                } else {\n                    data = null;\n                }\n                return new ClassCachingCompiledScript<T, M>(new ClassesDirCompiledScript<T, M>(isEmpty, hasMethods, classLoaderId, scriptBaseClass, scriptCacheDir, classLoader, source, data));\n            } finally {\n                decoder.close();\n            }\n        } catch (Exception e) {\n            throw new IllegalStateException(String.format(\"Failed to deserialize script metadata extracted for %s\", source.getDisplayName()), e);\n        }\n    }","id":98216,"modified_method":"public <T extends Script, M> CompiledScript<T, M> loadFromDir(ScriptSource source, ClassLoader classLoader, File scriptCacheDir,\n                                                                  File metadataCacheDir, CompileOperation<M> transformer, Class<T> scriptBaseClass,\n                                                                  ClassLoaderId classLoaderId) {\n        File metadataFile = new File(metadataCacheDir, METADATA_FILE_NAME);\n        try {\n            KryoBackedDecoder decoder = new KryoBackedDecoder(new FileInputStream(metadataFile));\n            try {\n                byte flags = decoder.readByte();\n                boolean isEmpty = (flags & EMPTY_FLAG) != 0;\n                boolean hasMethods = (flags & HAS_METHODS_FLAG) != 0;\n                if (isEmpty) {\n                    classLoaderCache.remove(classLoaderId);\n                }\n                M data;\n                if (transformer != null && transformer.getDataSerializer() != null) {\n                    data = transformer.getDataSerializer().read(decoder);\n                } else {\n                    data = null;\n                }\n                return new ClassesDirCompiledScript<T, M>(isEmpty, hasMethods, classLoaderId, scriptBaseClass, scriptCacheDir, classLoader, source, data);\n            } finally {\n                decoder.close();\n            }\n        } catch (Exception e) {\n            throw new IllegalStateException(String.format(\"Failed to deserialize script metadata extracted for %s\", source.getDisplayName()), e);\n        }\n    }","commit_id":"3d45670b89c507ebb7fa15d4c57b09311f2d8be6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public Class<? extends T> loadClass() {\n            if (isEmpty && !hasMethods) {\n                throw new UnsupportedOperationException(\"Cannot load script that does nothing.\");\n            }\n\n            try {\n                ClassLoader loader = classLoaderCache.get(classLoaderId, new DefaultClassPath(scriptCacheDir), classLoader, null);\n                return loader.loadClass(source.getClassName()).asSubclass(scriptBaseClass);\n            } catch (Exception e) {\n                File expectedClassFile = new File(scriptCacheDir, source.getClassName() + \".class\");\n                if (!expectedClassFile.exists()) {\n                    throw new GradleException(String.format(\"Could not load compiled classes for %s from cache. Expected class file %s does not exist.\", source.getDisplayName(), expectedClassFile.getAbsolutePath()), e);\n                }\n                throw new GradleException(String.format(\"Could not load compiled classes for %s from cache.\", source.getDisplayName()), e);\n            }\n        }","id":98217,"modified_method":"@Override\n        public Class<? extends T> loadClass() {\n            if (scriptClass == null) {\n                if (isEmpty && !hasMethods) {\n                    throw new UnsupportedOperationException(\"Cannot load script that does nothing.\");\n                }\n                try {\n                    ClassLoader loader = classLoaderCache.get(classLoaderId, new DefaultClassPath(scriptCacheDir), classLoader, null);\n                    scriptClass = loader.loadClass(source.getClassName()).asSubclass(scriptBaseClass);\n                } catch (Exception e) {\n                    File expectedClassFile = new File(scriptCacheDir, source.getClassName() + \".class\");\n                    if (!expectedClassFile.exists()) {\n                        throw new GradleException(String.format(\"Could not load compiled classes for %s from cache. Expected class file %s does not exist.\", source.getDisplayName(), expectedClassFile.getAbsolutePath()), e);\n                    }\n                    throw new GradleException(String.format(\"Could not load compiled classes for %s from cache.\", source.getDisplayName()), e);\n                }\n            }\n            return scriptClass;\n        }","commit_id":"3d45670b89c507ebb7fa15d4c57b09311f2d8be6","url":"https://github.com/gradle/gradle"},{"original_method":"protected DefaultPluginCollection(Class<T> type, NamedObjectStore<T> store) {\n        super(type, store);\n    }","id":98218,"modified_method":"protected DefaultPluginCollection(Class<T> type, ObjectStore<T> store) {\n        super(type, store);\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public Class<? extends Plugin> getTypeForId(String pluginId) {\n        if (parent != null) {\n            try {\n                return parent.getTypeForId(pluginId);\n            } catch (UnknownPluginException e) {\n                // Ignore\n            }\n        }\n\n        String implClassName = properties.get(pluginId);\n        if (!GUtil.isTrue(implClassName)) {\n            throw new UnknownPluginException(\"Plugin with id '\" + pluginId + \"' not found.\");\n        }\n        \n        try {\n            return classLoader.loadClass(implClassName).asSubclass(Plugin.class);\n        } catch (ClassNotFoundException e) {\n            throw new PluginInstantiationException(String.format(\"Could not find implementation class '%s' for plugin '%s'.\", implClassName, pluginId), e);\n        }\n    }","id":98219,"modified_method":"public Class<? extends Plugin> getTypeForId(String pluginId) {\n        if (parent != null) {\n            try {\n                return parent.getTypeForId(pluginId);\n            } catch (UnknownPluginException e) {\n                // Ignore\n            }\n        }\n\n        Class<? extends Plugin> implClass = idMappings.get(pluginId);\n        if (implClass != null) {\n            return implClass;\n        }\n\n        URL resource = classLoader.getResource(String.format(\"META-INF/gradle-plugins/%s.properties\", pluginId));\n        if (resource == null) {\n            throw new UnknownPluginException(\"Plugin with id '\" + pluginId + \"' not found.\");\n        }\n\n        Properties properties = GUtil.loadProperties(resource);\n        String implClassName = properties.getProperty(\"implementation-class\");\n        if (!GUtil.isTrue(implClassName)) {\n            throw new PluginInstantiationException(String.format(\"No implementation class specified for plugin '%s' in %s.\", pluginId, resource));\n        }\n\n        try {\n            implClass= classLoader.loadClass(implClassName).asSubclass(Plugin.class);\n        } catch (ClassNotFoundException e) {\n            throw new PluginInstantiationException(String.format(\"Could not find implementation class '%s' for plugin '%s' specified in %s.\", implClass, pluginId, resource), e);\n        }\n\n        idMappings.put(pluginId, implClass);\n        return implClass;\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"private DefaultPluginRegistry(DefaultPluginRegistry parent, ClassLoader classLoader) {\n        this.parent = parent;\n        this.classLoader = classLoader;\n        buildProperties(classLoader);\n        if (classLoader instanceof ObservableUrlClassLoader) {\n            ObservableUrlClassLoader observableUrlClassLoader = (ObservableUrlClassLoader) classLoader;\n            observableUrlClassLoader.whenUrlAdded(new Action<ClassLoader>() {\n                public void execute(ClassLoader classLoader) {\n                    buildProperties(classLoader);\n                }\n            });\n        }\n    }","id":98220,"modified_method":"private DefaultPluginRegistry(DefaultPluginRegistry parent, ClassLoader classLoader) {\n        this.parent = parent;\n        this.classLoader = classLoader;\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void parentIdMappingHasPrecedenceOverChildIdMapping() throws Exception {\n        expectClassLoaded(classLoader, TestPlugin1.class);\n        ClassLoader childClassLoader = createClassLoader(toMap(pluginId, \"no-such-class\"), \"child\");\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(pluginId), sameInstance(pluginRegistry.loadPlugin(pluginId)));\n    }","id":98221,"modified_method":"@Test\n    public void parentIdMappingHasPrecedenceOverChildIdMapping() throws Exception {\n        expectClassLoaded(classLoader, TestPlugin1.class);\n        ClassLoader childClassLoader = createClassLoader(pluginId, \"no-such-class\", \"child\");\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(pluginId), sameInstance(pluginRegistry.loadPlugin(pluginId)));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void childClasspathCanContainAdditionalPlugins() throws Exception {\n        expectClassesNotFound(classLoader);\n\n        ClassLoader childClassLoader = createClassLoader(toMap(\"other\", TestPlugin2.class.getName()), \"child\");\n        expectClassLoaded(childClassLoader, TestPlugin2.class);\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(\"other\"), instanceOf(TestPlugin2.class));\n    }","id":98222,"modified_method":"@Test\n    public void childClasspathCanContainAdditionalPlugins() throws Exception {\n        expectClassesNotFound(classLoader);\n        expectResourceNotFound(classLoader, \"other\");\n\n        ClassLoader childClassLoader = createClassLoader(\"other\", TestPlugin2.class.getName(), \"child\");\n        expectClassLoaded(childClassLoader, TestPlugin2.class);\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(\"other\"), instanceOf(TestPlugin2.class));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void childDelegatesToParentRegistryToLoadPlugin() throws Exception {\n        expectClassLoaded(classLoader, TestPlugin1.class);\n\n        ClassLoader childClassLoader = createClassLoader(toMap(\"other\", TestPlugin1.class.getName()), \"child\");\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(pluginId), sameInstance(pluginRegistry.loadPlugin(pluginId)));\n    }","id":98223,"modified_method":"@Test\n    public void childDelegatesToParentRegistryToLoadPlugin() throws Exception {\n        expectClassLoaded(classLoader, TestPlugin1.class);\n\n        ClassLoader childClassLoader = createClassLoader(\"other\", TestPlugin1.class.getName(), \"child\");\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(pluginId), sameInstance(pluginRegistry.loadPlugin(pluginId)));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void childClasspathCanContainAdditionalMappingsForPlugins() throws Exception {\n        ClassLoader childClassLoader = createClassLoader(toMap(\"other\", TestPlugin1.class.getName()), \"child\");\n        expectClassLoaded(childClassLoader, TestPlugin1.class);\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(\"other\"), sameInstance((Plugin) pluginRegistry.loadPlugin(TestPlugin1.class)));\n    }","id":98224,"modified_method":"@Test\n    public void childClasspathCanContainAdditionalMappingsForPlugins() throws Exception {\n        expectResourceNotFound(classLoader, \"other\");\n\n        ClassLoader childClassLoader = createClassLoader(\"other\", TestPlugin1.class.getName(), \"child\");\n        expectClassLoaded(childClassLoader, TestPlugin1.class);\n\n        PluginRegistry child = pluginRegistry.createChild(childClassLoader);\n        assertThat(child.loadPlugin(\"other\"), sameInstance((Plugin) pluginRegistry.loadPlugin(TestPlugin1.class)));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void failsForUnknownId() {\n        try {\n            pluginRegistry.loadPlugin(\"unknownId\");\n            fail();\n        } catch (UnknownPluginException e) {\n            assertThat(e.getMessage(), equalTo(\"Plugin with id 'unknownId' not found.\"));\n        }\n    }","id":98225,"modified_method":"@Test\n    public void failsForUnknownId() {\n        expectResourceNotFound(classLoader, \"unknownId\");\n\n        try {\n            pluginRegistry.loadPlugin(\"unknownId\");\n            fail();\n        } catch (UnknownPluginException e) {\n            assertThat(e.getMessage(), equalTo(\"Plugin with id 'unknownId' not found.\"));\n        }\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"private ClassLoader createClassLoader(Map<String, String> properties, String name) throws IOException {\n        TestFile classPath = testDir.createDir(name);\n        Properties props = new Properties();\n        props.putAll(properties);\n        final TestFile propertiesFile = classPath.file(\"META-INF/gradle-plugins.properties\");\n        propertiesFile.getParentFile().mkdirs();\n        GUtil.saveProperties(props, propertiesFile);\n        final ClassLoader classLoader = context.mock(ClassLoader.class, name);\n        context.checking(new Expectations() {{\n            allowing(classLoader).getResources(\"META-INF/gradle-plugins.properties\");\n            will(returnEnumeration(propertiesFile.toURI().toURL()));\n        }});\n        return classLoader;\n    }","id":98226,"modified_method":"private ClassLoader createClassLoader(final String id, String implClass, String name) throws IOException {\n        TestFile classPath = testDir.createDir(name);\n        Properties props = new Properties();\n        props.setProperty(\"implementation-class\", implClass);\n        final TestFile propertiesFile = classPath.file(id + \".properties\");\n        propertiesFile.getParentFile().mkdirs();\n        GUtil.saveProperties(props, propertiesFile);\n        final ClassLoader classLoader = context.mock(ClassLoader.class, name);\n        context.checking(new Expectations() {{\n            allowing(classLoader).getResource(\"META-INF/gradle-plugins/\" + id + \".properties\");\n            will(returnValue(propertiesFile.toURI().toURL()));\n        }});\n        return classLoader;\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Before\n    public void setup() throws Exception {\n        classLoader = createClassLoader(toMap(pluginId, TestPlugin1.class.getName()), \"parent\");\n\n        pluginRegistry = new DefaultPluginRegistry(classLoader);\n    }","id":98227,"modified_method":"@Before\n    public void setup() throws Exception {\n        classLoader = createClassLoader(pluginId, TestPlugin1.class.getName(), \"parent\");\n        pluginRegistry = new DefaultPluginRegistry(classLoader);\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public Plugin findPlugin(Class<? extends Plugin> type) {\n        return findByName(getNameForType(type));\n    }","id":98228,"modified_method":"public <T extends Plugin> T findPlugin(Class<T> type) {\n        for (Plugin plugin : getAll()) {\n            if (plugin.getClass().equals(type)) {\n                return type.cast(plugin);\n            }\n        }\n        return null;\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public Plugin usePlugin(String id) {\n        return addPluginInternal(getTypeForId(id), id);\n    }","id":98229,"modified_method":"public Plugin usePlugin(String id) {\n        return addPluginInternal(getTypeForId(id));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends Plugin> T usePlugin(Class<T> type) {\n        return addPluginInternal(type, getNameForType(type));\n    }","id":98230,"modified_method":"public <T extends Plugin> T usePlugin(Class<T> type) {\n        return addPluginInternal(type);\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public Plugin getPlugin(String id) {\n        Plugin plugin = findByName(id);\n        if (plugin == null) {\n            throw new UnknownPluginException(\"Plugin with id \" + id + \" has not been used.\");\n        }\n        return plugin;\n    }","id":98231,"modified_method":"public Plugin getPlugin(String id) {\n        Plugin plugin = findPlugin(id);\n        if (plugin == null) {\n            throw new UnknownPluginException(\"Plugin with id \" + id + \" has not been used.\");\n        }\n        return plugin;\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public Plugin findPlugin(String name) {\n        return findByName(name);\n    }","id":98232,"modified_method":"public Plugin findPlugin(String id) {\n        return findPlugin(getTypeForId(id));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"private <T extends Plugin> T addPluginInternal(Class<T> type, String name) {\n        if (findByName(name) == null) {\n            Plugin plugin = providePlugin(type);\n            addObject(name, plugin);\n        }\n        return (T) findByName(name);\n    }","id":98233,"modified_method":"private <T extends Plugin> T addPluginInternal(Class<T> type) {\n        if (findPlugin(type) == null) {\n            Plugin plugin = providePlugin(type);\n            addObject(plugin);\n        }\n        return type.cast(findPlugin(type));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public Plugin getPlugin(Class<? extends Plugin> type) {\n        Plugin plugin = findByName(getNameForType(type));\n        if (plugin == null) {\n            throw new UnknownPluginException(\"Plugin with type \" + type + \" has not been used.\");\n        }\n        return plugin;\n    }","id":98234,"modified_method":"public <T extends Plugin> T getPlugin(Class<T> type) throws UnknownPluginException {\n        Plugin plugin = findPlugin(type);\n        if (plugin == null) {\n            throw new UnknownPluginException(\"Plugin with type \" + type + \" has not been used.\");\n        }\n        return type.cast(plugin);\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean hasPlugin(String name) {\n        return findPlugin(name) != null;\n    }","id":98235,"modified_method":"public boolean hasPlugin(String id) {\n        return findPlugin(id) != null;\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void hasAndFindForPluginWithoutId() {\n        Plugin plugin = pluginWithoutIdMock;\n        Class<? extends Plugin> pluginType = plugin.getClass();\n        projectsPluginHandler.usePlugin(pluginType);\n        assertThat(projectsPluginHandler.hasPlugin(pluginType.getName()), equalTo(true));\n        assertThat(projectsPluginHandler.hasPlugin(pluginType), equalTo(true));\n        assertThat(projectsPluginHandler.findPlugin(pluginType), sameInstance(plugin));\n        assertThat(projectsPluginHandler.findPlugin(pluginType.getName()), sameInstance(plugin));\n    }","id":98236,"modified_method":"@Test\n    public void hasAndFindForPluginWithoutId() {\n        Plugin plugin = pluginWithoutIdMock;\n        Class<? extends Plugin> pluginType = plugin.getClass();\n        projectsPluginHandler.usePlugin(pluginType);\n        assertThat(projectsPluginHandler.hasPlugin(pluginType), equalTo(true));\n        assertThat(projectsPluginHandler.findPlugin(pluginType), sameInstance(plugin));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void addPluginWithIdByType() {\n        Class<? extends Plugin> type = pluginWithIdMock.getClass();\n        Plugin addedPlugin = projectsPluginHandler.usePlugin(type);\n        assertThat(pluginWithIdMock, sameInstance(addedPlugin));\n        assertThat(addedPlugin, sameInstance((Plugin) projectsPluginHandler.usePlugin(type)));\n        assertThat(addedPlugin, sameInstance(projectsPluginHandler.usePlugin(pluginId)));\n        assertThat(addedPlugin, sameInstance(projectsPluginHandler.findByName(pluginId)));\n    }","id":98237,"modified_method":"@Test\n    public void usePluginWithIdByType() {\n        Class<? extends Plugin> type = pluginWithIdMock.getClass();\n\n        Plugin addedPlugin = projectsPluginHandler.usePlugin(type);\n        assertThat(pluginWithIdMock, sameInstance(addedPlugin));\n        assertThat(projectsPluginHandler.usePlugin(type), sameInstance(addedPlugin));\n        assertThat(projectsPluginHandler.usePlugin(pluginId), sameInstance(addedPlugin));\n\n        assertThat(projectsPluginHandler.findPlugin(type), sameInstance(addedPlugin));\n        assertThat(projectsPluginHandler.findPlugin(pluginId), sameInstance(addedPlugin));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void hasAndFindForPluginWithId() {\n        projectsPluginHandler.usePlugin(pluginId);\n        assertThat(projectsPluginHandler.hasPlugin(pluginId), equalTo(true));\n        assertThat(projectsPluginHandler.hasPlugin(pluginWithIdMock.getClass()), equalTo(true));\n        assertThat((TestPlugin1) projectsPluginHandler.findPlugin(pluginId),\n                sameInstance((Plugin) pluginWithIdMock));\n        assertThat((TestPlugin1) projectsPluginHandler.findPlugin(pluginWithIdMock.getClass()),\n                sameInstance((Plugin) pluginWithIdMock));\n    }","id":98238,"modified_method":"@Test\n    public void hasAndFindForPluginWithId() {\n        projectsPluginHandler.usePlugin(pluginId);\n        assertThat(projectsPluginHandler.hasPlugin(pluginId), equalTo(true));\n        assertThat(projectsPluginHandler.hasPlugin(pluginWithIdMock.getClass()), equalTo(true));\n        assertThat(projectsPluginHandler.findPlugin(pluginId), sameInstance((Plugin) pluginWithIdMock));\n        assertThat(projectsPluginHandler.findPlugin(pluginWithIdMock.getClass()), sameInstance((Plugin) pluginWithIdMock));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@Before\n    public void setUp() {\n        context.checking(new Expectations() {{\n            allowing(pluginRegistryStub).getTypeForId(pluginId); will(returnValue(TestPlugin1.class));\n            allowing(pluginRegistryStub).getNameForType(TestPlugin1.class); will(returnValue(pluginId));\n            allowing(pluginRegistryStub).loadPlugin(TestPlugin1.class); will(returnValue(pluginWithIdMock));\n            allowing(pluginRegistryStub).loadPlugin(TestPlugin2.class); will(returnValue(pluginWithoutIdMock));\n            allowing(pluginRegistryStub).getNameForType(TestPlugin2.class); will(returnValue(TestPlugin2.class.getName()));\n        }});\n    }","id":98239,"modified_method":"@Before\n    public void setUp() {\n        context.checking(new Expectations() {{\n            allowing(pluginRegistryStub).getTypeForId(pluginId); will(returnValue(TestPlugin1.class));\n            allowing(pluginRegistryStub).loadPlugin(TestPlugin1.class); will(returnValue(pluginWithIdMock));\n            allowing(pluginRegistryStub).loadPlugin(TestPlugin2.class); will(returnValue(pluginWithoutIdMock));\n        }});\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"@org.junit.Test\n    public void usePluginWithId() {\n        projectsPluginHandler.usePlugin(pluginId);\n        projectsPluginHandler.usePlugin(pluginId);\n        assertThat(pluginWithIdMock.getApplyCounter(), equalTo(1));\n        assertThat((TestPlugin1) projectsPluginHandler.getPlugin(pluginId), sameInstance(pluginWithIdMock));\n    }","id":98240,"modified_method":"@Test\n    public void usePluginWithoutId() {\n        Class<? extends Plugin> type = pluginWithoutIdMock.getClass();\n        Plugin addedPlugin = projectsPluginHandler.usePlugin(type);\n        assertThat(pluginWithoutIdMock, sameInstance(addedPlugin));\n        assertThat(projectsPluginHandler.usePlugin(type), sameInstance(addedPlugin));\n\n        assertThat(projectsPluginHandler.findPlugin(type), sameInstance(addedPlugin));\n    }","commit_id":"4b73789b20c93bd1ea67aec2b9ede3a8236cf90e","url":"https://github.com/gradle/gradle"},{"original_method":"public Bucket readFilter(Bucket data, BucketFactory bf, String charset,\n\t\tHashMap otherParams, FilterCallback cb, boolean deleteText, boolean deleteTimestamp, boolean checkCRCs, OutputStream output) throws DataFilterException,\n\t\tIOException {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tboolean logDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\tInputStream is = null;\n\t\tBufferedInputStream bis = null;\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tis = data.getInputStream();\n\t\t\tbis = new BufferedInputStream(is);\n\t\t\tdis = new DataInputStream(bis);\n\t\t\t// Check the header\n\t\t\tbyte[] headerCheck = new byte[pngHeader.length];\n\t\t\tdis.read(headerCheck);\n\t\t\tif(!Arrays.equals(headerCheck, pngHeader)) {\n\t\t\t\t// Throw an exception\n\t\t\t\tString message = l10n(\"invalidHeader\");\n\t\t\t\tString title = l10n(\"invalidHeaderTitle\");\n\t\t\t\tthrow new DataFilterException(title, title,\n\t\t\t\t\t\"<p>\" + message + \"<\/p>\", new HTMLNode(\"p\").addChild(\"#\", message));\n\t\t\t}\n\n\t\t\tByteArrayOutputStream baos = null;\n\t\t\tDataOutputStream dos = null;\n\t\t\tif(output != null) {\n\t\t\t\tbaos = new ByteArrayOutputStream();\n\t\t\t\tdos = new DataOutputStream(baos);\n\t\t\t\toutput.write(pngHeader);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Writing the PNG header to the output bucket\");\n\t\t\t}\n\n\t\t\t// Check the chunks :\n\t\t\t// @see http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Summary-of-standard-chunks\n\t\t\tboolean finished = false;\n\t\t\tboolean hasSeenIHDR = false;\n\t\t\tboolean hasSeenIEND = false;\n\t\t\tboolean hasSeenPLTE = false;\n\t\t\tboolean hasSeenIDAT = false;\n\t\t\tString lastChunkType = \"\";\n\t\t\t\n\t\t\twhile(!finished) {\n\t\t\t\tboolean skip = false;\n\t\t\t\tif(baos != null)\n\t\t\t\t\tbaos.reset();\n\t\t\t\tString chunkTypeString = null;\n\t\t\t\t// Length of the chunk\n\t\t\t\tbyte[] lengthBytes = new byte[4];\n\t\t\t\tif(dis.read(lengthBytes) < 4)\n\t\t\t\t\tthrow new IOException(\"The length of the chunk is invalid!\");\n\t\t\t\t\n\t\t\t\tint length = ((lengthBytes[0] & 0xff) << 24) + ((lengthBytes[1] & 0xff) << 16) + ((lengthBytes[2] & 0xff) << 8) + (lengthBytes[3] & 0xff);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"length \" + length);\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(lengthBytes);\n\n\t\t\t\t// Type of the chunk : Should match [a-zA-Z]{4}\n\t\t\t\tif(dis.read(lengthBytes) < 4)\n\t\t\t\t\tthrow new IOException(\"The name of the chunk is invalid!\");\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tbyte[] chunkTypeBytes = new byte[4];\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tchar val = (char) lengthBytes[i];\n\t\t\t\t\tif((val >= 65 && val <= 99) || (val >= 97 && val <= 122)) {\n\t\t\t\t\t\tchunkTypeBytes[i] = lengthBytes[i];\n\t\t\t\t\t\tsb.append(val);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new IOException(\"The name of the chunk is invalid!\");\n\t\t\t\t}\n\t\t\t\tchunkTypeString = sb.toString();\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"name \" + chunkTypeString);\n\n\t\t\t\t// Content of the chunk\n\t\t\t\tbyte[] chunkData = new byte[length];\n\t\t\t\tint readLength = dis.read(chunkData, 0, length);\n\t\t\t\tif(readLength < length)\n\t\t\t\t\tthrow new IOException(\"The data in the chunk '\" + chunkTypeString + \"' is \" + readLength + \" but should be \" + length);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tif(logDEBUG)\n\t\t\t\t\t\tLogger.minor(this, \"data \" + (chunkData.length == 0 ? \"null\" : HexUtil.bytesToHex(chunkData)));\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.minor(this, \"data \" + chunkData.length);\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(chunkTypeBytes);\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(chunkData);\n\n\t\t\t\t// CRC of the chunk\n\t\t\t\tbyte[] crcLengthBytes = new byte[4];\n\t\t\t\tif(dis.read(crcLengthBytes) < 4)\n\t\t\t\t\tthrow new IOException(\"The length of the CRC is invalid!\");\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(crcLengthBytes);\n\n\t\t\t\tif(checkCRCs) {\n\t\t\t\t\tlong readCRC = (((crcLengthBytes[0] & 0xff) << 24) + ((crcLengthBytes[1] & 0xff) << 16) + ((crcLengthBytes[2] & 0xff) << 8) + (crcLengthBytes[3] & 0xff)) & 0x00000000ffffffffL;\n\t\t\t\t\tCRC32 crc = new CRC32();\n\t\t\t\t\tcrc.update(chunkTypeBytes);\n\t\t\t\t\tcrc.update(chunkData);\n\t\t\t\t\tlong computedCRC = crc.getValue();\n\t\t\t\t\t\n\t\t\t\t\tif(readCRC != computedCRC) {\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"CRC of the chunk \" + chunkTypeString + \" doesn't match (\" + Long.toHexString(readCRC) + \" but should be \" + Long.toHexString(computedCRC) + \")!\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tboolean validChunkType = true;\n\t\t\t\t\n\t\t\t\tif(!skip && \"IHDR\".equals(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIHDR)\n\t\t\t\t\t\tthrow new IOException(\"Two IHDR chunks detected!!\");\n\t\t\t\t\thasSeenIHDR = true;\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t}\n\n\t\t\t\tif(!hasSeenIHDR)\n\t\t\t\t\tthrow new IOException(\"No IHDR chunk!\");\n\n\t\t\t\tif(!skip && \"IEND\".equals(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIEND)\n\t\t\t\t\t\tthrow new IOException(\"Two IEND chunks detected!!\");\n\t\t\t\t\thasSeenIEND = true;\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!skip && \"PLTE\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIDAT)\n\t\t\t\t\t\tthrow new IOException(\"PLTE must be before IDAT\");\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t\thasSeenPLTE = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!skip && \"IDAT\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIDAT && !\"IDAT\".equalsIgnoreCase(lastChunkType))\n\t\t\t\t\t\tthrow new IOException(\"Multiple IDAT chunks must be consecutive!\");\n\t\t\t\t\thasSeenIDAT = true;\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!validChunkType) {\n\t\t\t\t\tfor(int i=0;i<HARMLESS_CHUNK_TYPES.length;i++) {\n\t\t\t\t\t\tif(HARMLESS_CHUNK_TYPES[i].equals(chunkTypeString))\n\t\t\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dis.available() < 1) {\n\t\t\t\t\tif(!(hasSeenIEND && hasSeenIHDR))\n\t\t\t\t\t\tthrow new IOException(\"Missing IEND or IHDR!\");\n\t\t\t\t\tfinished = true;\n\t\t\t\t}\n\n\t\t\t\tif(\"text\".equalsIgnoreCase(chunkTypeString) || \"itxt\".equalsIgnoreCase(chunkTypeString)\n\t\t\t\t\t\t|| \"ztxt\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(deleteText) skip = true;\n\t\t\t\t\telse validChunkType = true;\n\t\t\t\t} else if(deleteTimestamp && \"time\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(deleteTimestamp) skip = true;\n\t\t\t\t\telse validChunkType = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!validChunkType) {\n\t\t\t\t\tif(output == null)\n\t\t\t\t\t\tthrow new IOException(\"Unknown chunk type\");\n\t\t\t\t\tskip = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(skip && output == null)\n\t\t\t\t\treturn null;\n\t\t\t\telse if(!skip && output != null) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Writing \" + chunkTypeString + \" (\" + baos.size() + \") to the output bucket\");\n\t\t\t\t\tbaos.writeTo(output);\n\t\t\t\t\tbaos.flush();\n\t\t\t\t}\n\t\t\t\tlastChunkType = chunkTypeString;\n\t\t\t}\n\t\t\tif(finished && dis.available() > 0 && output == null)\n\t\t\t\tthrow new IOException(\"IEND not last chunk\");\n\t\t\t\n\t\t\tdis.close();\n\t\t} finally {\n\t\t\tCloser.close(dis);\n\t\t\tCloser.close(bis);\n\t\t\tCloser.close(is);\n\t\t}\n\t\treturn data;\n\t}","id":98241,"modified_method":"public Bucket readFilter(Bucket data, BucketFactory bf, String charset,\n\t\tHashMap otherParams, FilterCallback cb, boolean deleteText, boolean deleteTimestamp, boolean checkCRCs, OutputStream output) throws DataFilterException,\n\t\tIOException {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tboolean logDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\tInputStream is = null;\n\t\tBufferedInputStream bis = null;\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tis = data.getInputStream();\n\t\t\tbis = new BufferedInputStream(is);\n\t\t\tdis = new DataInputStream(bis);\n\t\t\t// Check the header\n\t\t\tbyte[] headerCheck = new byte[pngHeader.length];\n\t\t\tdis.read(headerCheck);\n\t\t\tif(!Arrays.equals(headerCheck, pngHeader)) {\n\t\t\t\t// Throw an exception\n\t\t\t\tString message = l10n(\"invalidHeader\");\n\t\t\t\tString title = l10n(\"invalidHeaderTitle\");\n\t\t\t\tthrow new DataFilterException(title, title,\n\t\t\t\t\t\"<p>\" + message + \"<\/p>\", new HTMLNode(\"p\").addChild(\"#\", message));\n\t\t\t}\n\n\t\t\tByteArrayOutputStream baos = null;\n\t\t\tDataOutputStream dos = null;\n\t\t\tif(output != null) {\n\t\t\t\tbaos = new ByteArrayOutputStream();\n\t\t\t\tdos = new DataOutputStream(baos);\n\t\t\t\toutput.write(pngHeader);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Writing the PNG header to the output bucket\");\n\t\t\t}\n\n\t\t\t// Check the chunks :\n\t\t\t// @see http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Summary-of-standard-chunks\n\t\t\tboolean finished = false;\n\t\t\tboolean hasSeenIHDR = false;\n\t\t\tboolean hasSeenIEND = false;\n\t\t\tboolean hasSeenPLTE = false;\n\t\t\tboolean hasSeenIDAT = false;\n\t\t\tString lastChunkType = \"\";\n\t\t\t\n\t\t\twhile(!finished) {\n\t\t\t\tboolean skip = false;\n\t\t\t\tif(baos != null)\n\t\t\t\t\tbaos.reset();\n\t\t\t\tString chunkTypeString = null;\n\t\t\t\t// Length of the chunk\n\t\t\t\tbyte[] lengthBytes = new byte[4];\n\t\t\t\tdis.readFully(lengthBytes);\n\t\t\t\t\n\t\t\t\tint length = ((lengthBytes[0] & 0xff) << 24) + ((lengthBytes[1] & 0xff) << 16) + ((lengthBytes[2] & 0xff) << 8) + (lengthBytes[3] & 0xff);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"length \" + length);\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(lengthBytes);\n\n\t\t\t\t// Type of the chunk : Should match [a-zA-Z]{4}\n\t\t\t\tdis.readFully(lengthBytes);\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tbyte[] chunkTypeBytes = new byte[4];\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tchar val = (char) lengthBytes[i];\n\t\t\t\t\tif((val >= 65 && val <= 99) || (val >= 97 && val <= 122)) {\n\t\t\t\t\t\tchunkTypeBytes[i] = lengthBytes[i];\n\t\t\t\t\t\tsb.append(val);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new IOException(\"The name of the chunk is invalid!\");\n\t\t\t\t}\n\t\t\t\tchunkTypeString = sb.toString();\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"name \" + chunkTypeString);\n\n\t\t\t\t// Content of the chunk\n\t\t\t\tbyte[] chunkData = new byte[length];\n\t\t\t\tdis.readFully(chunkData, 0, length);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tif(logDEBUG)\n\t\t\t\t\t\tLogger.minor(this, \"data \" + (chunkData.length == 0 ? \"null\" : HexUtil.bytesToHex(chunkData)));\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.minor(this, \"data \" + chunkData.length);\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(chunkTypeBytes);\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(chunkData);\n\n\t\t\t\t// CRC of the chunk\n\t\t\t\tbyte[] crcLengthBytes = new byte[4];\n\t\t\t\tdis.readFully(crcLengthBytes);\n\t\t\t\tif(dos != null)\n\t\t\t\t\tdos.write(crcLengthBytes);\n\n\t\t\t\tif(checkCRCs) {\n\t\t\t\t\tlong readCRC = (((crcLengthBytes[0] & 0xff) << 24) + ((crcLengthBytes[1] & 0xff) << 16) + ((crcLengthBytes[2] & 0xff) << 8) + (crcLengthBytes[3] & 0xff)) & 0x00000000ffffffffL;\n\t\t\t\t\tCRC32 crc = new CRC32();\n\t\t\t\t\tcrc.update(chunkTypeBytes);\n\t\t\t\t\tcrc.update(chunkData);\n\t\t\t\t\tlong computedCRC = crc.getValue();\n\t\t\t\t\t\n\t\t\t\t\tif(readCRC != computedCRC) {\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"CRC of the chunk \" + chunkTypeString + \" doesn't match (\" + Long.toHexString(readCRC) + \" but should be \" + Long.toHexString(computedCRC) + \")!\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tboolean validChunkType = true;\n\t\t\t\t\n\t\t\t\tif(!skip && \"IHDR\".equals(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIHDR)\n\t\t\t\t\t\tthrow new IOException(\"Two IHDR chunks detected!!\");\n\t\t\t\t\thasSeenIHDR = true;\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t}\n\n\t\t\t\tif(!hasSeenIHDR)\n\t\t\t\t\tthrow new IOException(\"No IHDR chunk!\");\n\n\t\t\t\tif(!skip && \"IEND\".equals(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIEND)\n\t\t\t\t\t\tthrow new IOException(\"Two IEND chunks detected!!\");\n\t\t\t\t\thasSeenIEND = true;\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!skip && \"PLTE\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIDAT)\n\t\t\t\t\t\tthrow new IOException(\"PLTE must be before IDAT\");\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t\thasSeenPLTE = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!skip && \"IDAT\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(hasSeenIDAT && !\"IDAT\".equalsIgnoreCase(lastChunkType))\n\t\t\t\t\t\tthrow new IOException(\"Multiple IDAT chunks must be consecutive!\");\n\t\t\t\t\thasSeenIDAT = true;\n\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!validChunkType) {\n\t\t\t\t\tfor(int i=0;i<HARMLESS_CHUNK_TYPES.length;i++) {\n\t\t\t\t\t\tif(HARMLESS_CHUNK_TYPES[i].equals(chunkTypeString))\n\t\t\t\t\t\t\tvalidChunkType = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dis.available() < 1) {\n\t\t\t\t\tif(!(hasSeenIEND && hasSeenIHDR))\n\t\t\t\t\t\tthrow new IOException(\"Missing IEND or IHDR!\");\n\t\t\t\t\tfinished = true;\n\t\t\t\t}\n\n\t\t\t\tif(\"text\".equalsIgnoreCase(chunkTypeString) || \"itxt\".equalsIgnoreCase(chunkTypeString)\n\t\t\t\t\t\t|| \"ztxt\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(deleteText) skip = true;\n\t\t\t\t\telse validChunkType = true;\n\t\t\t\t} else if(deleteTimestamp && \"time\".equalsIgnoreCase(chunkTypeString)) {\n\t\t\t\t\tif(deleteTimestamp) skip = true;\n\t\t\t\t\telse validChunkType = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!validChunkType) {\n\t\t\t\t\tif(output == null)\n\t\t\t\t\t\tthrow new IOException(\"Unknown chunk type\");\n\t\t\t\t\tskip = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(skip && output == null)\n\t\t\t\t\treturn null;\n\t\t\t\telse if(!skip && output != null) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Writing \" + chunkTypeString + \" (\" + baos.size() + \") to the output bucket\");\n\t\t\t\t\tbaos.writeTo(output);\n\t\t\t\t\tbaos.flush();\n\t\t\t\t}\n\t\t\t\tlastChunkType = chunkTypeString;\n\t\t\t}\n\t\t\tif(finished && dis.available() > 0 && output == null)\n\t\t\t\tthrow new IOException(\"IEND not last chunk\");\n\t\t\t\n\t\t\tdis.close();\n\t\t} finally {\n\t\t\tCloser.close(dis);\n\t\t\tCloser.close(bis);\n\t\t\tCloser.close(is);\n\t\t}\n\t\treturn data;\n\t}","commit_id":"225e2f51f58dc992dfdcd0a85b9bdd72a6baf7af","url":"https://github.com/freenet/fred"},{"original_method":"public void resetCooldownTimes(ObjectContainer container, ClientContext context) {\n\t\tif(logMINOR) Logger.minor(this, \"Resetting cooldown times on \"+this);\n\t\tif(getter != null)\n\t\t\tcontext.cooldownTracker.clearCachedWakeup(getter, persistent, container);\n\t\tcontext.getChkFetchScheduler().wakeStarter();\n\t\t// FIXME need a more efficient way to get maxTries!\n\t\tif(persistent) {\n\t\t\tcontainer.activate(blockFetchContext, 1);\n\t\t}\n\t\tsynchronized(this) {\n\t\t\tMyCooldownTrackerItem tracker = makeCooldownTrackerItem(container, context);\n\t\t\tlong[] dataCooldownTimes = tracker.dataCooldownTimes;\n\t\t\tlong[] checkCooldownTimes = tracker.checkCooldownTimes;\n\t\t\tfor(int i=0;i<dataCooldownTimes.length;i++)\n\t\t\t\tdataCooldownTimes[i] = -1;\n\t\t\tfor(int i=0;i<checkCooldownTimes.length;i++)\n\t\t\t\tcheckCooldownTimes[i] = -1;\n\t\t}\n\t}","id":98242,"modified_method":"public void resetCooldownTimes(ObjectContainer container, ClientContext context) {\n\t\tif(logMINOR) Logger.minor(this, \"Resetting cooldown times on \"+this);\n\t\tif(getter != null) {\n\t\t\tcontext.cooldownTracker.clearCachedWakeup(getter, persistent, container);\n\t\t\tcontext.cooldownTracker.clearCachedWakeup(getter.getParentGrabArray(), persistent, container);\n\t\t}\n\t\tcontext.getChkFetchScheduler().wakeStarter();\n\t\t// FIXME need a more efficient way to get maxTries!\n\t\tif(persistent) {\n\t\t\tcontainer.activate(blockFetchContext, 1);\n\t\t}\n\t\tsynchronized(this) {\n\t\t\tMyCooldownTrackerItem tracker = makeCooldownTrackerItem(container, context);\n\t\t\tlong[] dataCooldownTimes = tracker.dataCooldownTimes;\n\t\t\tlong[] checkCooldownTimes = tracker.checkCooldownTimes;\n\t\t\tfor(int i=0;i<dataCooldownTimes.length;i++)\n\t\t\t\tdataCooldownTimes[i] = -1;\n\t\t\tfor(int i=0;i<checkCooldownTimes.length;i++)\n\t\t\t\tcheckCooldownTimes[i] = -1;\n\t\t}\n\t}","commit_id":"525a4a9d962274c55beee1214d609095c3534ab3","url":"https://github.com/freenet/fred"},{"original_method":"/** Add directly to a RandomGrabArrayWithClient under us. */\n\tpublic synchronized void add(Object client, RandomGrabArrayItem item, ObjectContainer container, ClientContext context) {\n\t\tif(item.persistent() != persistent) throw new IllegalArgumentException(\"item.persistent()=\"+item.persistent()+\" but array.persistent=\"+persistent+\" item=\"+item+\" array=\"+this);\n\t\tRandomGrabArrayWithClient rga;\n\t\tint clientIndex = haveClient(client);\n\t\tif(clientIndex == -1) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Adding new RGAWithClient for \"+client+\" on \"+this+\" for \"+item);\n\t\t\trga = new RandomGrabArrayWithClient(client, persistent, container, this);\n\t\t\taddElement(client, rga);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(rga);\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\t\t} else {\n\t\t\trga = (RandomGrabArrayWithClient) grabArrays[clientIndex];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Adding \"+item+\" to RGA \"+rga+\" for \"+client);\n\t\trga.add(item, container, context);\n\t\tif(persistent)\n\t\t\tcontainer.deactivate(rga, 1);\n\t\tif(context != null)\n\t\t\tcontext.cooldownTracker.clearCachedWakeup(this, persistent, container);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Size now \"+grabArrays.length+\" on \"+this);\n\t}","id":98243,"modified_method":"/** Add directly to a RandomGrabArrayWithClient under us. */\n\tpublic synchronized void add(Object client, RandomGrabArrayItem item, ObjectContainer container, ClientContext context) {\n\t\tif(item.persistent() != persistent) throw new IllegalArgumentException(\"item.persistent()=\"+item.persistent()+\" but array.persistent=\"+persistent+\" item=\"+item+\" array=\"+this);\n\t\tRandomGrabArrayWithClient rga;\n\t\tint clientIndex = haveClient(client);\n\t\tif(clientIndex == -1) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Adding new RGAWithClient for \"+client+\" on \"+this+\" for \"+item);\n\t\t\trga = new RandomGrabArrayWithClient(client, persistent, container, this);\n\t\t\taddElement(client, rga);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(rga);\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\t\t} else {\n\t\t\trga = (RandomGrabArrayWithClient) grabArrays[clientIndex];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Adding \"+item+\" to RGA \"+rga+\" for \"+client);\n\t\trga.add(item, container, context);\n\t\tif(persistent)\n\t\t\tcontainer.deactivate(rga, 1);\n\t\tif(context != null) {\n\t\t\tcontext.cooldownTracker.clearCachedWakeup(this, persistent, container);\n\t\t\tif(parent != null)\n\t\t\t\tcontext.cooldownTracker.clearCachedWakeup(parent, persistent, container);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Size now \"+grabArrays.length+\" on \"+this);\n\t}","commit_id":"a5c9fab7fbdfcacb842ec4035781ae29bc3d92ff","url":"https://github.com/freenet/fred"},{"original_method":"public void add(RandomGrabArrayItem req, ObjectContainer container, ClientContext context) {\n\t\tif(req.persistent() != persistent) throw new IllegalArgumentException(\"req.persistent()=\"+req.persistent()+\" but array.persistent=\"+persistent+\" item=\"+req+\" array=\"+this);\n\t\tif(context != null && req.getCooldownTime(container, context, System.currentTimeMillis()) < 0) { \n\t\t\tif(logMINOR) Logger.minor(this, \"Is finished already: \"+req);\n\t\t\treturn;\n\t\t}\n\t\treq.setParentGrabArray(this, container); // will store() self\n\t\tsynchronized(this) {\n\t\t\tif(context != null) {\n\t\t\t\tcontext.cooldownTracker.clearCachedWakeup(req, persistent, container);\n\t\t\t\tcontext.cooldownTracker.clearCachedWakeup(this, persistent, container);\n\t\t\t}\n\t\t\tint x = 0;\n\t\t\tif(blocks.length == 1 && index < BLOCK_SIZE) {\n\t\t\t\tif(persistent) container.activate(blocks[0], 1);\n\t\t\t\tfor(int i=0;i<index;i++) {\n\t\t\t\t\tif(blocks[0].reqs[i] == req) {\n\t\t\t\t\t\tif(persistent) container.deactivate(blocks[0], 1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(index >= blocks[0].reqs.length) {\n\t\t\t\t\tint newSize = Math.min(BLOCK_SIZE, blocks[0].reqs.length*2);\n\t\t\t\t\tRandomGrabArrayItem[] newReqs = new RandomGrabArrayItem[newSize];\n\t\t\t\t\tSystem.arraycopy(blocks[0].reqs, 0, newReqs, 0, blocks[0].reqs.length);\n\t\t\t\t\tblocks[0].reqs = newReqs;\n\t\t\t\t}\n\t\t\t\tblocks[0].reqs[index++] = req;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Added \"+req+\" before index \"+index);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\tcontainer.deactivate(blocks[0], 1);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint targetBlock = index / BLOCK_SIZE;\n\t\t\tfor(int i=0;i<blocks.length;i++) {\n\t\t\t\tBlock block = blocks[i];\n\t\t\t\tif(persistent) container.activate(block, 1);\n\t\t\t\tif(i != (blocks.length - 1) && block.reqs.length != BLOCK_SIZE) {\n\t\t\t\t\tLogger.error(this, \"Block \"+i+\" of \"+blocks.length+\" is wrong size: \"+block.reqs.length+\" should be \"+BLOCK_SIZE);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<block.reqs.length;j++) {\n\t\t\t\t\tif(x >= index) break;\n\t\t\t\t\tif(block.reqs[j] == req) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Already contains \"+req+\" : \"+this+\" size now \"+index);\n\t\t\t\t\t\tif(persistent) container.deactivate(block, 1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(block.reqs[j] == null) {\n\t\t\t\t\t\tLogger.error(this, \"reqs[\"+i+\".\"+j+\"] = null on \"+this);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(persistent && i != targetBlock) container.deactivate(block, 1);\n\t\t\t}\n\t\t\tint oldBlockLen = blocks.length;\n\t\t\tif(blocks.length <= targetBlock) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Adding blocks on \"+this);\n\t\t\t\tBlock[] newBlocks = new Block[targetBlock + 1];\n\t\t\t\tSystem.arraycopy(blocks, 0, newBlocks, 0, blocks.length);\n\t\t\t\tfor(int i=blocks.length;i<newBlocks.length;i++) {\n\t\t\t\t\tnewBlocks[i] = new Block();\n\t\t\t\t\tnewBlocks[i].reqs = new RandomGrabArrayItem[BLOCK_SIZE];\n\t\t\t\t}\n\t\t\t\tblocks = newBlocks;\n\t\t\t} else {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(blocks[targetBlock], 1);\n\t\t\t}\n\t\t\tBlock target = blocks[targetBlock];\n\t\t\ttarget.reqs[index++ % BLOCK_SIZE] = req;\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=oldBlockLen;i<blocks.length;i++)\n\t\t\t\t\tcontainer.store(blocks[i]);\n\t\t\t\tcontainer.store(this);\n\t\t\t\tcontainer.store(target);\n\t\t\t\tfor(int i=oldBlockLen;i<blocks.length;i++)\n\t\t\t\t\tcontainer.deactivate(blocks[i], 1);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Added: \"+req+\" to \"+this+\" size now \"+index);\n\t\t}\n\t}","id":98244,"modified_method":"public void add(RandomGrabArrayItem req, ObjectContainer container, ClientContext context) {\n\t\tif(req.persistent() != persistent) throw new IllegalArgumentException(\"req.persistent()=\"+req.persistent()+\" but array.persistent=\"+persistent+\" item=\"+req+\" array=\"+this);\n\t\tif(context != null && req.getCooldownTime(container, context, System.currentTimeMillis()) < 0) { \n\t\t\tif(logMINOR) Logger.minor(this, \"Is finished already: \"+req);\n\t\t\treturn;\n\t\t}\n\t\treq.setParentGrabArray(this, container); // will store() self\n\t\tsynchronized(this) {\n\t\t\tif(context != null) {\n\t\t\t\tcontext.cooldownTracker.clearCachedWakeup(req, persistent, container);\n\t\t\t\tcontext.cooldownTracker.clearCachedWakeup(this, persistent, container);\n\t\t\t\tif(parent != null)\n\t\t\t\t\tcontext.cooldownTracker.clearCachedWakeup(parent, persistent, container);\n\t\t\t}\n\t\t\tint x = 0;\n\t\t\tif(blocks.length == 1 && index < BLOCK_SIZE) {\n\t\t\t\tif(persistent) container.activate(blocks[0], 1);\n\t\t\t\tfor(int i=0;i<index;i++) {\n\t\t\t\t\tif(blocks[0].reqs[i] == req) {\n\t\t\t\t\t\tif(persistent) container.deactivate(blocks[0], 1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(index >= blocks[0].reqs.length) {\n\t\t\t\t\tint newSize = Math.min(BLOCK_SIZE, blocks[0].reqs.length*2);\n\t\t\t\t\tRandomGrabArrayItem[] newReqs = new RandomGrabArrayItem[newSize];\n\t\t\t\t\tSystem.arraycopy(blocks[0].reqs, 0, newReqs, 0, blocks[0].reqs.length);\n\t\t\t\t\tblocks[0].reqs = newReqs;\n\t\t\t\t}\n\t\t\t\tblocks[0].reqs[index++] = req;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Added \"+req+\" before index \"+index);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\tcontainer.deactivate(blocks[0], 1);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint targetBlock = index / BLOCK_SIZE;\n\t\t\tfor(int i=0;i<blocks.length;i++) {\n\t\t\t\tBlock block = blocks[i];\n\t\t\t\tif(persistent) container.activate(block, 1);\n\t\t\t\tif(i != (blocks.length - 1) && block.reqs.length != BLOCK_SIZE) {\n\t\t\t\t\tLogger.error(this, \"Block \"+i+\" of \"+blocks.length+\" is wrong size: \"+block.reqs.length+\" should be \"+BLOCK_SIZE);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<block.reqs.length;j++) {\n\t\t\t\t\tif(x >= index) break;\n\t\t\t\t\tif(block.reqs[j] == req) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Already contains \"+req+\" : \"+this+\" size now \"+index);\n\t\t\t\t\t\tif(persistent) container.deactivate(block, 1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(block.reqs[j] == null) {\n\t\t\t\t\t\tLogger.error(this, \"reqs[\"+i+\".\"+j+\"] = null on \"+this);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(persistent && i != targetBlock) container.deactivate(block, 1);\n\t\t\t}\n\t\t\tint oldBlockLen = blocks.length;\n\t\t\tif(blocks.length <= targetBlock) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Adding blocks on \"+this);\n\t\t\t\tBlock[] newBlocks = new Block[targetBlock + 1];\n\t\t\t\tSystem.arraycopy(blocks, 0, newBlocks, 0, blocks.length);\n\t\t\t\tfor(int i=blocks.length;i<newBlocks.length;i++) {\n\t\t\t\t\tnewBlocks[i] = new Block();\n\t\t\t\t\tnewBlocks[i].reqs = new RandomGrabArrayItem[BLOCK_SIZE];\n\t\t\t\t}\n\t\t\t\tblocks = newBlocks;\n\t\t\t} else {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(blocks[targetBlock], 1);\n\t\t\t}\n\t\t\tBlock target = blocks[targetBlock];\n\t\t\ttarget.reqs[index++ % BLOCK_SIZE] = req;\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=oldBlockLen;i<blocks.length;i++)\n\t\t\t\t\tcontainer.store(blocks[i]);\n\t\t\t\tcontainer.store(this);\n\t\t\t\tcontainer.store(target);\n\t\t\t\tfor(int i=oldBlockLen;i<blocks.length;i++)\n\t\t\t\t\tcontainer.deactivate(blocks[i], 1);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Added: \"+req+\" to \"+this+\" size now \"+index);\n\t\t}\n\t}","commit_id":"40d48d4b017ff6dbbd1a28db66b2765d6d9a7bcc","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Put a grabber. This lets us use things other than RandomGrabArrayWithClient's, so don't mix calls\n\t * to add() with calls to getGrabber/addGrabber!\n\t */\n\tpublic synchronized void addGrabber(Object client, RemoveRandomWithObject requestGrabber, ObjectContainer container, ClientContext context) {\n\t\tif(requestGrabber.getObject() != client)\n\t\t\tthrow new IllegalArgumentException(\"Client not equal to RemoveRandomWithObject's client: client=\"+client+\" rr=\"+requestGrabber+\" his object=\"+requestGrabber.getObject());\n\t\taddElement(client, requestGrabber);\n\t\tif(persistent) container.store(this);\n\t\tif(context != null)\n\t\t\tcontext.cooldownTracker.clearCachedWakeup(this, persistent, container);\n\t}","id":98245,"modified_method":"/**\n\t * Put a grabber. This lets us use things other than RandomGrabArrayWithClient's, so don't mix calls\n\t * to add() with calls to getGrabber/addGrabber!\n\t */\n\tpublic synchronized void addGrabber(Object client, RemoveRandomWithObject requestGrabber, ObjectContainer container, ClientContext context) {\n\t\tif(requestGrabber.getObject() != client)\n\t\t\tthrow new IllegalArgumentException(\"Client not equal to RemoveRandomWithObject's client: client=\"+client+\" rr=\"+requestGrabber+\" his object=\"+requestGrabber.getObject());\n\t\taddElement(client, requestGrabber);\n\t\tif(persistent) container.store(this);\n\t\tif(context != null) {\n\t\t\tcontext.cooldownTracker.clearCachedWakeup(this, persistent, container);\n\t\t\tif(parent != null)\n\t\t\t\tcontext.cooldownTracker.clearCachedWakeup(parent, persistent, container);\n\t\t}\n\t}","commit_id":"40d48d4b017ff6dbbd1a28db66b2765d6d9a7bcc","url":"https://github.com/freenet/fred"},{"original_method":"private void removeAndCleanupPartition(int pid) {\n        tmLog.info(\"Removing and cleanup up partition info for partition \" + pid);\n        if (m_removedPartitionsAtPromotionTime != null) {\n            m_removedPartitionsAtPromotionTime.add(pid);\n            tmLog.info(\"Partition \" + pid + \" was cleaned up during LeaderAppointer promotion and should be skipped\");\n        }\n        BabySitter sitter = m_partitionWatchers.remove(pid);\n        if (sitter != null) {\n            sitter.shutdown();\n        }\n        m_callbacks.remove(pid);\n        try {\n            try {\n                m_zk.delete(ZKUtil.joinZKPath(VoltZK.iv2masters, String.valueOf(pid)), -1);\n            } catch (KeeperException.NoNodeException e) {}\n            try {\n                m_zk.delete(ZKUtil.joinZKPath(VoltZK.iv2appointees, String.valueOf(pid)), -1);\n            } catch (KeeperException.NoNodeException e) {}\n            try {\n                m_zk.delete(ZKUtil.joinZKPath(VoltZK.leaders_initiators, \"partition_\" + String.valueOf(pid)), -1);\n            } catch (KeeperException.NoNodeException e) {}\n        } catch (Exception e) {\n            tmLog.error(\"Error removing partition info\", e);\n        }\n    }","id":98246,"modified_method":"private void removeAndCleanupPartition(int pid) {\n        tmLog.info(\"Removing and cleanup up partition info for partition \" + pid);\n        if (m_removedPartitionsAtPromotionTime != null) {\n            m_removedPartitionsAtPromotionTime.add(pid);\n            tmLog.info(\"Partition \" + pid + \" was cleaned up during LeaderAppointer promotion and should be skipped\");\n        }\n        BabySitter sitter = m_partitionWatchers.remove(pid);\n        if (sitter != null) {\n            sitter.shutdown();\n        }\n        m_callbacks.remove(pid);\n        try {\n            ZKUtil.asyncDeleteRecursively(m_zk, ZKUtil.joinZKPath(VoltZK.iv2masters, String.valueOf(pid)));\n            ZKUtil.asyncDeleteRecursively(m_zk, ZKUtil.joinZKPath(VoltZK.iv2appointees, String.valueOf(pid)));\n            ZKUtil.asyncDeleteRecursively(m_zk, ZKUtil.joinZKPath(VoltZK.leaders_initiators, \"partition_\" + String.valueOf(pid)));\n        } catch (Exception e) {\n            tmLog.error(\"Error removing partition info\", e);\n        }\n    }","commit_id":"0094a9436d88018bc65fb299584f69ad351360d3","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private boolean doAddRootsToWatch(@NotNull final Collection<String> recursiveRoots,\n                                    @NotNull final Collection<String> flatRoots,\n                                    @NotNull final Set<WatchRequest> results,\n                                    @NotNull final Set<VirtualFile> filesToSync) {\n    boolean update = false;\n\n    for (String root : recursiveRoots) {\n      final WatchRequestImpl request = new WatchRequestImpl(root, true);\n      final boolean alreadyWatched = isAlreadyWatched(request);\n\n      request.myDominated = alreadyWatched;\n      myRootsToWatch.add(request);\n      results.add(request);\n\n      update |= !alreadyWatched;\n    }\n\n    for (String root : flatRoots) {\n      final WatchRequestImpl request = new WatchRequestImpl(root, false);\n      final boolean alreadyWatched = isAlreadyWatched(request);\n\n      if (!alreadyWatched) {\n        final VirtualFile existingFile = findFileByPathIfCached(root);\n        if (existingFile != null && existingFile.isDirectory() && existingFile instanceof NewVirtualFile) {\n          filesToSync.addAll(((NewVirtualFile)existingFile).getCachedChildren());\n        }\n      }\n\n      request.myDominated = alreadyWatched;\n      myRootsToWatch.add(request);\n      results.add(request);\n\n      update |= !alreadyWatched;\n    }\n\n    return update;\n  }","id":98247,"modified_method":"private boolean doAddRootsToWatch(@NotNull final Collection<String> recursiveRoots,\n                                    @NotNull final Collection<String> flatRoots,\n                                    @NotNull final Set<WatchRequest> results,\n                                    @NotNull final Set<VirtualFile> filesToSync) {\n    boolean update = false;\n\n    for (String root : recursiveRoots) {\n      final WatchRequestImpl request = watch(root, true);\n      if (request == null) continue;\n      final boolean alreadyWatched = isAlreadyWatched(request);\n\n      request.myDominated = alreadyWatched;\n      myRootsToWatch.add(request);\n      results.add(request);\n\n      update |= !alreadyWatched;\n    }\n\n    for (String root : flatRoots) {\n      final WatchRequestImpl request = watch(root, false);\n      if (request == null) continue;\n      final boolean alreadyWatched = isAlreadyWatched(request);\n\n      if (!alreadyWatched) {\n        final VirtualFile existingFile = findFileByPathIfCached(root);\n        if (existingFile != null && existingFile.isDirectory() && existingFile instanceof NewVirtualFile) {\n          filesToSync.addAll(((NewVirtualFile)existingFile).getCachedChildren());\n        }\n      }\n\n      request.myDominated = alreadyWatched;\n      myRootsToWatch.add(request);\n      results.add(request);\n\n      update |= !alreadyWatched;\n    }\n\n    return update;\n  }","commit_id":"fcacee79e7892dae4cc34828dbb953a2a2035d50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public WatchRequestImpl(String rootPath, final boolean toWatchRecursively) {\n      final int index = rootPath.indexOf(JarFileSystem.JAR_SEPARATOR);\n      if (index >= 0) rootPath = rootPath.substring(0, index);\n\n      File rootFile = new File(FileUtil.toSystemDependentName(rootPath));\n      if (index > 0 || !rootFile.isDirectory()) {\n        rootFile = rootFile.getParentFile();\n        assert rootFile != null : rootPath;\n      }\n\n      myFSRootPath = rootFile.getAbsolutePath();\n      myRootPath = FileUtil.toSystemIndependentName(myFSRootPath);\n      myToWatchRecursively = toWatchRecursively;\n    }","id":98248,"modified_method":"public WatchRequestImpl(String rootPath, final boolean toWatchRecursively) throws FileNotFoundException {\n      final int index = rootPath.indexOf(JarFileSystem.JAR_SEPARATOR);\n      if (index >= 0) rootPath = rootPath.substring(0, index);\n\n      File rootFile = new File(FileUtil.toSystemDependentName(rootPath));\n      if (index > 0 || !rootFile.isDirectory()) {\n        final File parentFile = rootFile.getParentFile();\n        if (parentFile == null) {\n          throw new FileNotFoundException(rootPath);\n        }\n        rootFile = parentFile;\n      }\n\n      myFSRootPath = rootFile.getAbsolutePath();\n      myRootPath = FileUtil.toSystemIndependentName(myFSRootPath);\n      myToWatchRecursively = toWatchRecursively;\n    }","commit_id":"fcacee79e7892dae4cc34828dbb953a2a2035d50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * builds a StressTester object using the command line arguments\n   *\n   * @param args\n   * @return\n   * @throws Exception\n   */\n  public static OStressTester getStressTester(String[] args) throws Exception {\n\n    Map<String, String> options = checkOptions(readOptions(args));\n    String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n    OMode mode = OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n    String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n    String resultOutputFile = options.get(OConstants.OPTION_OUTPUT_FILE);\n    int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n    int operationsPerTransaction = getNumber(options.get(OConstants.OPTION_TRANSACTIONS), \"transactions\");\n    int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n    OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS), threadsNumber, iterationsNumber);\n    String remoteIp = options.get(OConstants.OPTION_REMOTE_IP);\n    int remotePort = 2424;\n\n    if (resultOutputFile != null) {\n      File outputFile = new File(resultOutputFile);\n      if (outputFile.exists()) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXISTING_OUTPUT_FILE, resultOutputFile));\n      }\n      if (!outputFile.getParentFile().exists()) {\n        throw new OInitException(\n            String.format(OErrorMessages.COMMAND_LINE_PARSER_NOT_EXISTING_OUTPUT_DIRECTORY, outputFile.getParentFile().getAbsoluteFile()));\n      }\n      if (!outputFile.getParentFile().canWrite()) {\n        throw new OInitException(\n            String.format(OErrorMessages.COMMAND_LINE_PARSER_NO_WRITE_PERMISSION_OUTPUT_FILE, outputFile.getParentFile().getAbsoluteFile()));\n      }\n    }\n\n    if (operationsPerTransaction > operationsSet.getNumberOfCreates()) {\n      throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_TX_GREATER_THAN_CREATES, operationsPerTransaction,\n          operationsSet.getNumberOfCreates()));\n    }\n\n    if (options.get(OConstants.OPTION_REMOTE_PORT) != null) {\n      remotePort = getNumber(options.get(OConstants.OPTION_REMOTE_PORT), \"remotePort\");\n      if (remotePort > 65535) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_REMOTE_PORT_NUMBER, remotePort));\n      }\n    }\n\n    if (mode == OMode.DISTRIBUTED) {\n      throw new OInitException(String.format(\"OMode [%s] not yet supported.\", mode));\n    }\n\n    if (mode == OMode.REMOTE && remoteIp == null) {\n      throw new OInitException(OErrorMessages.COMMAND_LINE_PARSER_MISSING_REMOTE_IP);\n    }\n\n    if (rootPassword == null && mode == OMode.REMOTE) {\n      Console console = System.console();\n      if (console != null) {\n        rootPassword = String\n            .valueOf(console.readPassword(String.format(OConstants.CONSOLE_REMOTE_PASSWORD_PROMPT, remoteIp, remotePort)));\n      } else {\n        throw new Exception(OErrorMessages.ERROR_OPENING_CONSOLE);\n      }\n    }\n\n    ODatabaseIdentifier databaseIdentifier = new ODatabaseIdentifier(mode, dbName, rootPassword, remoteIp, remotePort);\n    return new OStressTester(databaseIdentifier, operationsSet, iterationsNumber, threadsNumber, operationsPerTransaction,\n        resultOutputFile);\n  }","id":98249,"modified_method":"/**\n   * builds a StressTester object using the command line arguments\n   *\n   * @param args\n   * @return\n   * @throws Exception\n   */\n  public static OStressTester getStressTester(String[] args) throws Exception {\n\n    Map<String, String> options = checkOptions(readOptions(args));\n    String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n    OMode mode = OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n    String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n    String resultOutputFile = options.get(OConstants.OPTION_OUTPUT_FILE);\n    int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n    int operationsPerTransaction = getNumber(options.get(OConstants.OPTION_TRANSACTIONS), \"transactions\");\n    int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n    OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS), threadsNumber, iterationsNumber);\n    String remoteIp = options.get(OConstants.OPTION_REMOTE_IP);\n    int remotePort = 2424;\n\n    if (resultOutputFile != null) {\n      File outputFile = new File(resultOutputFile);\n      if (outputFile.exists()) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXISTING_OUTPUT_FILE, resultOutputFile));\n      }\n\n      File parentFile = outputFile.getParentFile();\n\n      // if the filename does not contain a path (both relative and absolute)\n      if (parentFile == null) {\n        parentFile = new File(\".\");\n      }\n\n      if (!parentFile.exists()) {\n        throw new OInitException(\n            String.format(OErrorMessages.COMMAND_LINE_PARSER_NOT_EXISTING_OUTPUT_DIRECTORY, parentFile.getAbsoluteFile()));\n      }\n      if (!parentFile.canWrite()) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_NO_WRITE_PERMISSION_OUTPUT_FILE,\n            parentFile.getAbsoluteFile()));\n      }\n    }\n\n    if (operationsPerTransaction > operationsSet.getNumberOfCreates()) {\n      throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_TX_GREATER_THAN_CREATES, operationsPerTransaction,\n          operationsSet.getNumberOfCreates()));\n    }\n\n    if (options.get(OConstants.OPTION_REMOTE_PORT) != null) {\n      remotePort = getNumber(options.get(OConstants.OPTION_REMOTE_PORT), \"remotePort\");\n      if (remotePort > 65535) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_REMOTE_PORT_NUMBER, remotePort));\n      }\n    }\n\n    if (mode == OMode.DISTRIBUTED) {\n      throw new OInitException(String.format(\"OMode [%s] not yet supported.\", mode));\n    }\n\n    if (mode == OMode.REMOTE && remoteIp == null) {\n      throw new OInitException(OErrorMessages.COMMAND_LINE_PARSER_MISSING_REMOTE_IP);\n    }\n\n    if (rootPassword == null && mode == OMode.REMOTE) {\n      Console console = System.console();\n      if (console != null) {\n        rootPassword = String\n            .valueOf(console.readPassword(String.format(OConstants.CONSOLE_REMOTE_PASSWORD_PROMPT, remoteIp, remotePort)));\n      } else {\n        throw new Exception(OErrorMessages.ERROR_OPENING_CONSOLE);\n      }\n    }\n\n    ODatabaseIdentifier databaseIdentifier = new ODatabaseIdentifier(mode, dbName, rootPassword, remoteIp, remotePort);\n    return new OStressTester(databaseIdentifier, operationsSet, iterationsNumber, threadsNumber, operationsPerTransaction,\n        resultOutputFile);\n  }","commit_id":"be4ded3b828f09776955a3a242a4b63ffe56a635","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public AtomicDependency(File filename, FreenetURI key, long size, byte[] expectedHash, boolean executable) throws IOException {\n            this.filename = filename;\n            this.key = key;\n            this.size = size;\n            this.expectedHash = expectedHash;\n            this.executable = executable;\n            this.tempFilename = File.createTempFile(filename.getName(), \".tmp\", filename.getAbsoluteFile().getParentFile());\n            tempFilename.deleteOnExit();\n            this.backupFilename = File.createTempFile(filename.getName(), \".tmp\", filename.getAbsoluteFile().getParentFile());\n            backupFilename.deleteOnExit();\n        }","id":98250,"modified_method":"public AtomicDependency(File filename, FreenetURI key, long size, byte[] expectedHash, boolean executable) throws IOException {\n            this.filename = filename;\n            this.key = key;\n            this.size = size;\n            this.expectedHash = expectedHash;\n            this.executable = executable;\n            File parent = filename.getAbsoluteFile().getParentFile();\n            if(parent == null) parent = new File(\".\");\n            File[] list = parent.listFiles();\n            for(File f : list) {\n                String name = f.getName();\n                if(name.startsWith(filename.getName()) && name.endsWith(UPDATER_BACKUP_SUFFIX)) \n                    f.delete();\n            }\n            this.tempFilename = File.createTempFile(filename.getName(), \".tmp\", parent);\n            tempFilename.deleteOnExit();\n            this.backupFilename = File.createTempFile(filename.getName(), UPDATER_BACKUP_SUFFIX, parent);\n        }","commit_id":"196c5843008a4e2101f2fe6d843021dcad021fa8","url":"https://github.com/freenet/fred"},{"original_method":"public void init(){\n      LOG.info(\"init()\");\n\t\t\t\t\t\t\n    // run ddl            \n    if (autoDdl.booleanValue()){\n      try\n      {                        \n         sqlService.ddl(this.getClass().getClassLoader(), \"mfr\");\n      }       \n      catch (Throwable t)\n      {\n        LOG.warn(this + \".init(): \", t);\n      }\n    }  \n    \n    try {\n       loadInitialDefaultPermissionLevel();\n    }\n    catch (Exception e) {\n       LOG.warn(\"Error loading initial default permissions\", e);\n    }\n    \n    /** test creation of permission mask and author level\n    PermissionsMask mask = new PermissionsMask();\n    mask.put(PermissionLevel.NEW_FORUM, Boolean.TRUE); \n    mask.put(PermissionLevel.NEW_TOPIC, Boolean.TRUE);\n    mask.put(PermissionLevel.NEW_RESPONSE, Boolean.TRUE);\n    mask.put(PermissionLevel.RESPONSE_TO_RESPONSE, Boolean.TRUE);\n    mask.put(PermissionLevel.MOVE_POSTING, Boolean.TRUE);\n    mask.put(PermissionLevel.CHANGE_SETTINGS, Boolean.TRUE);\n    mask.put(PermissionLevel.POST_GRADES, Boolean.TRUE);\n    mask.put(PermissionLevel.READ, Boolean.TRUE);\n    mask.put(PermissionLevel.MARK_AS_READ, Boolean.TRUE);\n    mask.put(PermissionLevel.MODERATE_POSTINGS, Boolean.TRUE);\n    mask.put(PermissionLevel.DELETE_OWN, Boolean.TRUE);\n    mask.put(PermissionLevel.DELETE_ANY, Boolean.TRUE);\n    mask.put(PermissionLevel.REVISE_OWN, Boolean.TRUE);\n    mask.put(PermissionLevel.REVISE_ANY, Boolean.TRUE);\n    DBMembershipItem membershipItem = createDBMembershipItem(\"jlannan\", DBMembershipItemImpl.TYPE_USER);\n    PermissionLevel level = createPermissionLevel(\"Author\", typeManager.getAuthorLevelType(), mask);    \n    Area area = areaManager.createArea(typeManager.getPrivateMessageAreaType());\n    \n    membershipItem.setPermissionLevel(level);\n    \n    // save DBMembershiptItem here to get an id so we can add to the set\n    saveDBMembershipItem(membershipItem);\n    area.addMembershipItem(membershipItem);\n           \n    area.setName(\"test\");\n    area.setHidden(Boolean.FALSE);\n    area.setEnabled(Boolean.TRUE);\n    area.setLocked(Boolean.FALSE);\n    //area.addPermissionLevel(level);\n    areaManager.saveArea(area); \n    \n    List l = getOrderedPermissionLevelNames();\n    **/\n    \n\t}","id":98251,"modified_method":"public void init(){\n    LOG.info(\"init()\");\n    \n    try {\n       loadInitialDefaultPermissionLevel();\n    }\n    catch (Exception e) {\n       LOG.warn(\"Error loading initial default permissions\", e);\n    }\n    \n    /** test creation of permission mask and author level\n    PermissionsMask mask = new PermissionsMask();\n    mask.put(PermissionLevel.NEW_FORUM, Boolean.TRUE); \n    mask.put(PermissionLevel.NEW_TOPIC, Boolean.TRUE);\n    mask.put(PermissionLevel.NEW_RESPONSE, Boolean.TRUE);\n    mask.put(PermissionLevel.RESPONSE_TO_RESPONSE, Boolean.TRUE);\n    mask.put(PermissionLevel.MOVE_POSTING, Boolean.TRUE);\n    mask.put(PermissionLevel.CHANGE_SETTINGS, Boolean.TRUE);\n    mask.put(PermissionLevel.POST_GRADES, Boolean.TRUE);\n    mask.put(PermissionLevel.READ, Boolean.TRUE);\n    mask.put(PermissionLevel.MARK_AS_READ, Boolean.TRUE);\n    mask.put(PermissionLevel.MODERATE_POSTINGS, Boolean.TRUE);\n    mask.put(PermissionLevel.DELETE_OWN, Boolean.TRUE);\n    mask.put(PermissionLevel.DELETE_ANY, Boolean.TRUE);\n    mask.put(PermissionLevel.REVISE_OWN, Boolean.TRUE);\n    mask.put(PermissionLevel.REVISE_ANY, Boolean.TRUE);\n    DBMembershipItem membershipItem = createDBMembershipItem(\"jlannan\", DBMembershipItemImpl.TYPE_USER);\n    PermissionLevel level = createPermissionLevel(\"Author\", typeManager.getAuthorLevelType(), mask);    \n    Area area = areaManager.createArea(typeManager.getPrivateMessageAreaType());\n    \n    membershipItem.setPermissionLevel(level);\n    \n    // save DBMembershiptItem here to get an id so we can add to the set\n    saveDBMembershipItem(membershipItem);\n    area.addMembershipItem(membershipItem);\n           \n    area.setName(\"test\");\n    area.setHidden(Boolean.FALSE);\n    area.setEnabled(Boolean.TRUE);\n    area.setLocked(Boolean.FALSE);\n    //area.addPermissionLevel(level);\n    areaManager.saveArea(area); \n    \n    List l = getOrderedPermissionLevelNames();\n    **/\n    \n\t}","commit_id":"55031d31eb65ee360f08dd709f79e1ee03196b58","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultNoneditingAuthorPermissionLevel(){\n\t\t\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"getDefaultNoneditingAuthorPermissionLevel executing\");\n\t\t}\n\t\t\t\t\t\t\n\t\tString typeUuid = typeManager.getNoneditingAuthorLevelType();\n\t\t\n\t\tif (typeUuid == null) {      \n      throw new IllegalStateException(\"type cannot be null\");\n\t\t}\t\t\n\t\tPermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\t\t\n    if(level == null)\n    {\n      PermissionsMask mask = new PermissionsMask();                \n      mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n      mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n      mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n      mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n      mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n      mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n      mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n      mask.put(PermissionLevel.READ, new Boolean(true));\n      mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n      mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n      mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n      mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n      mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n      mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t\treturn createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONEDITING_AUTHOR, typeUuid, mask);\n    }\n\t\telse\n\t\t\treturn level;\n\t}","id":98252,"modified_method":"public PermissionLevel getDefaultNoneditingAuthorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultNoneditingAuthorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getNoneditingAuthorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONEDITING_AUTHOR, typeUuid, mask, \"00000000-0000-0000-0000-333333333333\");\n\t\t  savePermissionLevel(newLevel);\n\n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"55031d31eb65ee360f08dd709f79e1ee03196b58","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultReviewerPermissionLevel(){\n\t\t\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"getDefaultReviewerPermissionLevel executing\");\n\t\t}\n\t\t\t\t\t\t\n\t\tString typeUuid = typeManager.getReviewerLevelType();\n\t\t\n\t\tif (typeUuid == null) {      \n      throw new IllegalStateException(\"type cannot be null\");\n\t\t}\t\t\n\t\tPermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\t\t\n    if(level == null)\n    {\n      PermissionsMask mask = new PermissionsMask();                \n      mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n      mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n      mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n      mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n      mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n      mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n      mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n      mask.put(PermissionLevel.READ, new Boolean(true));\n      mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n      mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n      mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n      mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n      mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n      mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n      return createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_REVIEWER, typeUuid, mask);\n    }\n\t\telse\n\t\t\treturn level;\n\n\t}","id":98253,"modified_method":"public PermissionLevel getDefaultReviewerPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultReviewerPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getReviewerLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_REVIEWER, typeUuid, mask, \"00000000-0000-0000-0000-555555555555\");\n\t\t  savePermissionLevel(newLevel);\n\t\t  \n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n\n  }","commit_id":"55031d31eb65ee360f08dd709f79e1ee03196b58","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultNonePermissionLevel(){\n\t\t\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"getDefaultNonePermissionLevel executing\");\n\t\t}\n\t\t\t\t\t\t\n\t\tString typeUuid = typeManager.getNoneLevelType();\n\t\t\n\t\tif (typeUuid == null) {      \n      throw new IllegalStateException(\"type cannot be null\");\n\t\t}\t\t\n\t\tPermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\t\t\n\t\tif(level == null)\n\t\t{    \n\t\t\tPermissionsMask mask = new PermissionsMask();                \n\t\t\tmask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t\tmask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t\tmask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.READ, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.MARK_AS_READ,new Boolean(false));\n\t\t\tmask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t\tmask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t\treturn createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONE, typeUuid, mask);\n\t\t}\n\t\telse\n\t\t\treturn level;\n\t}","id":98254,"modified_method":"public PermissionLevel getDefaultNonePermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultNonePermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getNoneLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {    \n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(false));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONE, typeUuid, mask, \"00000000-0000-0000-0000-666666666666\");\n\t\t  savePermissionLevel(newLevel);\n\t\t  \n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"55031d31eb65ee360f08dd709f79e1ee03196b58","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultOwnerPermissionLevel(){\n\t\t\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"getDefaultOwnerPermissionLevel executing\");\n\t\t}\n\t\t\t\t\t\t\n\t\tString typeUuid = typeManager.getOwnerLevelType();\n\t\t\n\t\tif (typeUuid == null) {      \n      throw new IllegalStateException(\"type cannot be null\");\n\t\t}\t\t\n\t\tPermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\t\t\n    if(level == null)\n    {    \n    \tPermissionsMask mask = new PermissionsMask();                \n    \tmask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n    \tmask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n    \tmask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n    \tmask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n    \tmask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n    \tmask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n    \tmask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n    \tmask.put(PermissionLevel.READ, new Boolean(true));\n    \tmask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n    \tmask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(true));\n    \tmask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n    \tmask.put(PermissionLevel.DELETE_ANY, new Boolean(true));\n    \tmask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n    \tmask.put(PermissionLevel.REVISE_ANY, new Boolean(true));\n\n\t\t\treturn createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_OWNER, typeUuid, mask);\n    }\n\t\telse\n\t\t\treturn level;\n\t}","id":98255,"modified_method":"public PermissionLevel getDefaultOwnerPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultOwnerPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getOwnerLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {    \n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(true));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(true));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_OWNER, typeUuid, mask, \"00000000-0000-0000-0000-111111111111\");\n\t\t  savePermissionLevel(newLevel);\n\n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"55031d31eb65ee360f08dd709f79e1ee03196b58","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultContributorPermissionLevel(){\n\t\t\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"getDefaultContributorPermissionLevel executing\");\n\t\t}\n\t\t\t\t\t\t\n\t\tString typeUuid = typeManager.getContributorLevelType();\n\t\t\n\t\tif (typeUuid == null) {      \n      throw new IllegalStateException(\"type cannot be null\");\n\t\t}\t\t\n\t\tPermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n    if(level == null)\n    {\n      PermissionsMask mask = new PermissionsMask();                \n      mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n      mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n      mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n      mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n      mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n      mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n      mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n      mask.put(PermissionLevel.READ, new Boolean(true));\n      mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n      mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n      mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n      mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n      mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n      mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\t\t\treturn createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_CONTRIBUTOR, typeUuid, mask);\n\n    }\n\t\telse\n\t\t\treturn level;\t\n  }","id":98256,"modified_method":"public PermissionLevel getDefaultContributorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultContributorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getContributorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\t\t  \n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_CONTRIBUTOR, typeUuid, mask, \"00000000-0000-0000-0000-444444444444\");\n\t\t  savePermissionLevel(newLevel);\n\t\t  \n\t\t  return newLevel;\n\n\t  }\n\t  else\n\t\t  return level;\t\n  }","commit_id":"55031d31eb65ee360f08dd709f79e1ee03196b58","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultAuthorPermissionLevel(){\n\t\t\t\t\t\t\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"getDefaultAuthorPermissionLevel executing\");\n\t\t}\n\t\t\t\t\t\t\n\t\tString typeUuid = typeManager.getAuthorLevelType();\n\t\t\n\t\tif (typeUuid == null) {      \n      throw new IllegalStateException(\"type cannot be null\");\n\t\t}\t\t\n\t\tPermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n    if(level == null)\n    {\n  \t\t\n      PermissionsMask mask = new PermissionsMask();                \n      mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n      mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n      mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n      mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n      mask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n      mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n      mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n      mask.put(PermissionLevel.READ, new Boolean(true));\n      mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n      mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n      mask.put(PermissionLevel.DELETE_OWN, new Boolean(true));\n      mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n      mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n      mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t\treturn createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_AUTHOR, typeUuid, mask);\n    }\n\t\telse\n\t\t\treturn level;\n\t}","id":98257,"modified_method":"public PermissionLevel getDefaultAuthorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultAuthorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getAuthorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_AUTHOR, typeUuid, mask, \"00000000-0000-0000-0000-222222222222\");\n\t\t  savePermissionLevel(newLevel);\n\n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"55031d31eb65ee360f08dd709f79e1ee03196b58","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The portion of the\r\n\t * {@link Texture} given by u, v and u2, v2 are used. These coordinates and sizes are given in texture size percentage. The\r\n\t * rectangle will have the given tint {@link Color}.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels */\r\n\tpublic void draw (Texture texture, float x, float y, float width, float height, float u, float v, float u2, float v2) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) renderMesh();\r\n\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":98258,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The portion of the\r\n\t * {@link Texture} given by u, v and u2, v2 are used. These coordinates and sizes are given in texture size percentage. The\r\n\t * rectangle will have the given tint {@link Color}.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels */\r\n\tpublic void draw (Texture texture, float x, float y, float width, float height, float u, float v, float u2, float v2) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tif (texture != lastTexture)\r\n\t\t\tswitchTexture(texture);\r\n\t\telse if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Constructs a new SpriteBatch. Sets the projection matrix to an orthographic projection with y-axis point upwards, x-axis\r\n\t * point to the right and the origin being in the bottom left corner of the screen. The projection will be pixel perfect with\r\n\t * respect to the screen resolution.\r\n\t * <p>\r\n\t * The size parameter specifies the maximum size of a single batch in number of sprites\r\n\t * <p>\r\n\t * The defaultShader specifies the shader to use. Note that the names for uniforms for this default shader are different than\r\n\t * the ones expect for shaders set with {@link #setShader(ShaderProgram)}. See the {@link #createDefaultShader()} method.\r\n\t * @param size the batch size in number of sprites\r\n\t * @param buffers the number of buffers to use. only makes sense with VBOs. This is an expert function.\r\n\t * @param defaultShader the default shader to use. This is not owned by the SpriteBatch and must be disposed separately. */\r\n\tpublic SpriteBatch (int size, int buffers, ShaderProgram defaultShader) {\r\n\t\tif (size > 5460) {\r\n\t\t\tthrow new GdxRuntimeException(\"Can't have more than 5460 sprites per batch\");\r\n\t\t}\r\n\t\tthis.buffers = new Mesh[buffers];\r\n\r\n\t\tfor (int i = 0; i < buffers; i++) {\r\n\t\t\tthis.buffers[i] = new Mesh(VertexDataType.VertexArray, false, size * 4, size * 6, new VertexAttribute(Usage.Position, 2,\r\n\t\t\t\tShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE),\r\n\t\t\t\tnew VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + \"0\"));\r\n\t\t}\r\n\r\n\t\tprojectionMatrix.setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\r\n\t\tvertices = new float[size * Sprite.SPRITE_SIZE];\r\n\r\n\t\tint len = size * 6;\r\n\t\tshort[] indices = new short[len];\r\n\t\tshort j = 0;\r\n\t\tfor (int i = 0; i < len; i += 6, j += 4) {\r\n\t\t\tindices[i + 0] = (short)(j + 0);\r\n\t\t\tindices[i + 1] = (short)(j + 1);\r\n\t\t\tindices[i + 2] = (short)(j + 2);\r\n\t\t\tindices[i + 3] = (short)(j + 2);\r\n\t\t\tindices[i + 4] = (short)(j + 3);\r\n\t\t\tindices[i + 5] = (short)(j + 0);\r\n\t\t}\r\n\t\tfor (int i = 0; i < buffers; i++) {\r\n\t\t\tthis.buffers[i].setIndices(indices);\r\n\t\t}\r\n\t\tmesh = this.buffers[0];\r\n\r\n\t\tif (Gdx.graphics.isGL20Available() && defaultShader == null) {\r\n\t\t\tshader = createDefaultShader();\r\n\t\t\townsShader = true;\r\n\t\t} else\r\n\t\t\tshader = defaultShader;\r\n\t}","id":98259,"modified_method":"/** Constructs a new SpriteBatch. Sets the projection matrix to an orthographic projection with y-axis point upwards, x-axis\r\n\t * point to the right and the origin being in the bottom left corner of the screen. The projection will be pixel perfect with\r\n\t * respect to the screen resolution.\r\n\t * <p>\r\n\t * The size parameter specifies the maximum size of a single batch in number of sprites\r\n\t * <p>\r\n\t * The defaultShader specifies the shader to use. Note that the names for uniforms for this default shader are different than\r\n\t * the ones expect for shaders set with {@link #setShader(ShaderProgram)}. See the {@link #createDefaultShader()} method.\r\n\t * @param size the batch size in number of sprites\r\n\t * @param buffers the number of buffers to use. only makes sense with VBOs. This is an expert function.\r\n\t * @param defaultShader the default shader to use. This is not owned by the SpriteBatch and must be disposed separately. */\r\n\tpublic SpriteBatch (int size, int buffers, ShaderProgram defaultShader) {\r\n\t\tif (size > 5460) throw new IllegalArgumentException(\"Can't have more than 5460 sprites per batch: \" + size);\r\n\r\n\t\tthis.buffers = new Mesh[buffers];\r\n\t\tfor (int i = 0; i < buffers; i++) {\r\n\t\t\tthis.buffers[i] = new Mesh(VertexDataType.VertexArray, false, size * 4, size * 6, new VertexAttribute(Usage.Position, 2,\r\n\t\t\t\tShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE),\r\n\t\t\t\tnew VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + \"0\"));\r\n\t\t}\r\n\r\n\t\tprojectionMatrix.setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\r\n\t\tvertices = new float[size * Sprite.SPRITE_SIZE];\r\n\r\n\t\tint len = size * 6;\r\n\t\tshort[] indices = new short[len];\r\n\t\tshort j = 0;\r\n\t\tfor (int i = 0; i < len; i += 6, j += 4) {\r\n\t\t\tindices[i + 0] = (short)(j + 0);\r\n\t\t\tindices[i + 1] = (short)(j + 1);\r\n\t\t\tindices[i + 2] = (short)(j + 2);\r\n\t\t\tindices[i + 3] = (short)(j + 2);\r\n\t\t\tindices[i + 4] = (short)(j + 3);\r\n\t\t\tindices[i + 5] = (short)(j + 0);\r\n\t\t}\r\n\t\tfor (int i = 0; i < buffers; i++) {\r\n\t\t\tthis.buffers[i].setIndices(indices);\r\n\t\t}\r\n\t\tmesh = this.buffers[0];\r\n\r\n\t\tif (Gdx.graphics.isGL20Available() && defaultShader == null) {\r\n\t\t\tshader = createDefaultShader();\r\n\t\t\townsShader = true;\r\n\t\t} else\r\n\t\t\tshader = defaultShader;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y having the width and height of the texture.\r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space */\r\n\tpublic void draw (Texture texture, float x, float y) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) renderMesh();\r\n\r\n\t\tfinal float fx2 = x + texture.getWidth();\r\n\t\tfinal float fy2 = y + texture.getHeight();\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 0;\r\n\t\tvertices[idx++] = 1;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 0;\r\n\t\tvertices[idx++] = 0;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 1;\r\n\t\tvertices[idx++] = 0;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 1;\r\n\t\tvertices[idx++] = 1;\r\n\t}","id":98260,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y having the width and height of the texture.\r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space */\r\n\tpublic void draw (Texture texture, float x, float y) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tif (texture != lastTexture)\r\n\t\t\tswitchTexture(texture);\r\n\t\telse if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfinal float fx2 = x + texture.getWidth();\r\n\t\tfinal float fy2 = y + texture.getHeight();\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 0;\r\n\t\tvertices[idx++] = 1;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 0;\r\n\t\tvertices[idx++] = 0;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 1;\r\n\t\tvertices[idx++] = 0;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = 1;\r\n\t\tvertices[idx++] = 1;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y and stretching the region to cover the given width and height. */\r\n\tpublic void draw (TextureRegion region, float x, float y, float width, float height) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tTexture texture = region.texture;\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\t\tfinal float u = region.u;\r\n\t\tfinal float v = region.v2;\r\n\t\tfinal float u2 = region.u2;\r\n\t\tfinal float v2 = region.v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":98261,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y and stretching the region to cover the given width and height. */\r\n\tpublic void draw (TextureRegion region, float x, float y, float width, float height) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tTexture texture = region.texture;\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\t\tfinal float u = region.u;\r\n\t\tfinal float v = region.v2;\r\n\t\tfinal float u2 = region.u2;\r\n\t\tfinal float v2 = region.v;\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The rectangle is offset by\r\n\t * originX, originY relative to the origin. Scale specifies the scaling factor by which the rectangle should be scaled around\r\n\t * originX, originY. Rotation specifies the angle of counter clockwise rotation of the rectangle around originX, originY. The\r\n\t * portion of the {@link Texture} given by srcX, srcY and srcWidth, srcHeight is used. These coordinates and sizes are given in\r\n\t * texels. FlipX and flipY specify whether the texture portion should be fliped horizontally or vertically.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param originX the x-coordinate of the scaling and rotation origin relative to the screen space coordinates\r\n\t * @param originY the y-coordinate of the scaling and rotation origin relative to the screen space coordinates\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels\r\n\t * @param scaleX the scale of the rectangle around originX/originY in x\r\n\t * @param scaleY the scale of the rectangle around originX/originY in y\r\n\t * @param rotation the angle of counter clockwise rotation of the rectangle around originX/originY\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels\r\n\t * @param flipX whether to flip the sprite horizontally\r\n\t * @param flipY whether to flip the sprite vertically */\r\n\tpublic void draw (Texture texture, float x, float y, float originX, float originY, float width, float height, float scaleX,\r\n\t\tfloat scaleY, float rotation, int srcX, int srcY, int srcWidth, int srcHeight, boolean flipX, boolean flipY) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) renderMesh();\r\n\r\n\t\t// bottom left and top right corner points relative to origin\r\n\t\tfinal float worldOriginX = x + originX;\r\n\t\tfinal float worldOriginY = y + originY;\r\n\t\tfloat fx = -originX;\r\n\t\tfloat fy = -originY;\r\n\t\tfloat fx2 = width - originX;\r\n\t\tfloat fy2 = height - originY;\r\n\r\n\t\t// scale\r\n\t\tif (scaleX != 1 || scaleY != 1) {\r\n\t\t\tfx *= scaleX;\r\n\t\t\tfy *= scaleY;\r\n\t\t\tfx2 *= scaleX;\r\n\t\t\tfy2 *= scaleY;\r\n\t\t}\r\n\r\n\t\t// construct corner points, start from top left and go counter clockwise\r\n\t\tfinal float p1x = fx;\r\n\t\tfinal float p1y = fy;\r\n\t\tfinal float p2x = fx;\r\n\t\tfinal float p2y = fy2;\r\n\t\tfinal float p3x = fx2;\r\n\t\tfinal float p3y = fy2;\r\n\t\tfinal float p4x = fx2;\r\n\t\tfinal float p4y = fy;\r\n\r\n\t\tfloat x1;\r\n\t\tfloat y1;\r\n\t\tfloat x2;\r\n\t\tfloat y2;\r\n\t\tfloat x3;\r\n\t\tfloat y3;\r\n\t\tfloat x4;\r\n\t\tfloat y4;\r\n\r\n\t\t// rotate\r\n\t\tif (rotation != 0) {\r\n\t\t\tfinal float cos = MathUtils.cosDeg(rotation);\r\n\t\t\tfinal float sin = MathUtils.sinDeg(rotation);\r\n\r\n\t\t\tx1 = cos * p1x - sin * p1y;\r\n\t\t\ty1 = sin * p1x + cos * p1y;\r\n\r\n\t\t\tx2 = cos * p2x - sin * p2y;\r\n\t\t\ty2 = sin * p2x + cos * p2y;\r\n\r\n\t\t\tx3 = cos * p3x - sin * p3y;\r\n\t\t\ty3 = sin * p3x + cos * p3y;\r\n\r\n\t\t\tx4 = x1 + (x3 - x2);\r\n\t\t\ty4 = y3 - (y2 - y1);\r\n\t\t} else {\r\n\t\t\tx1 = p1x;\r\n\t\t\ty1 = p1y;\r\n\r\n\t\t\tx2 = p2x;\r\n\t\t\ty2 = p2y;\r\n\r\n\t\t\tx3 = p3x;\r\n\t\t\ty3 = p3y;\r\n\r\n\t\t\tx4 = p4x;\r\n\t\t\ty4 = p4y;\r\n\t\t}\r\n\r\n\t\tx1 += worldOriginX;\r\n\t\ty1 += worldOriginY;\r\n\t\tx2 += worldOriginX;\r\n\t\ty2 += worldOriginY;\r\n\t\tx3 += worldOriginX;\r\n\t\ty3 += worldOriginY;\r\n\t\tx4 += worldOriginX;\r\n\t\ty4 += worldOriginY;\r\n\r\n\t\tfloat u = srcX * invTexWidth;\r\n\t\tfloat v = (srcY + srcHeight) * invTexHeight;\r\n\t\tfloat u2 = (srcX + srcWidth) * invTexWidth;\r\n\t\tfloat v2 = srcY * invTexHeight;\r\n\r\n\t\tif (flipX) {\r\n\t\t\tfloat tmp = u;\r\n\t\t\tu = u2;\r\n\t\t\tu2 = tmp;\r\n\t\t}\r\n\r\n\t\tif (flipY) {\r\n\t\t\tfloat tmp = v;\r\n\t\t\tv = v2;\r\n\t\t\tv2 = tmp;\r\n\t\t}\r\n\r\n\t\tvertices[idx++] = x1;\r\n\t\tvertices[idx++] = y1;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x3;\r\n\t\tvertices[idx++] = y3;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x4;\r\n\t\tvertices[idx++] = y4;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":98262,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The rectangle is offset by\r\n\t * originX, originY relative to the origin. Scale specifies the scaling factor by which the rectangle should be scaled around\r\n\t * originX, originY. Rotation specifies the angle of counter clockwise rotation of the rectangle around originX, originY. The\r\n\t * portion of the {@link Texture} given by srcX, srcY and srcWidth, srcHeight is used. These coordinates and sizes are given in\r\n\t * texels. FlipX and flipY specify whether the texture portion should be fliped horizontally or vertically.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param originX the x-coordinate of the scaling and rotation origin relative to the screen space coordinates\r\n\t * @param originY the y-coordinate of the scaling and rotation origin relative to the screen space coordinates\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels\r\n\t * @param scaleX the scale of the rectangle around originX/originY in x\r\n\t * @param scaleY the scale of the rectangle around originX/originY in y\r\n\t * @param rotation the angle of counter clockwise rotation of the rectangle around originX/originY\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels\r\n\t * @param flipX whether to flip the sprite horizontally\r\n\t * @param flipY whether to flip the sprite vertically */\r\n\tpublic void draw (Texture texture, float x, float y, float originX, float originY, float width, float height, float scaleX,\r\n\t\tfloat scaleY, float rotation, int srcX, int srcY, int srcWidth, int srcHeight, boolean flipX, boolean flipY) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tif (texture != lastTexture)\r\n\t\t\tswitchTexture(texture);\r\n\t\telse if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\t// bottom left and top right corner points relative to origin\r\n\t\tfinal float worldOriginX = x + originX;\r\n\t\tfinal float worldOriginY = y + originY;\r\n\t\tfloat fx = -originX;\r\n\t\tfloat fy = -originY;\r\n\t\tfloat fx2 = width - originX;\r\n\t\tfloat fy2 = height - originY;\r\n\r\n\t\t// scale\r\n\t\tif (scaleX != 1 || scaleY != 1) {\r\n\t\t\tfx *= scaleX;\r\n\t\t\tfy *= scaleY;\r\n\t\t\tfx2 *= scaleX;\r\n\t\t\tfy2 *= scaleY;\r\n\t\t}\r\n\r\n\t\t// construct corner points, start from top left and go counter clockwise\r\n\t\tfinal float p1x = fx;\r\n\t\tfinal float p1y = fy;\r\n\t\tfinal float p2x = fx;\r\n\t\tfinal float p2y = fy2;\r\n\t\tfinal float p3x = fx2;\r\n\t\tfinal float p3y = fy2;\r\n\t\tfinal float p4x = fx2;\r\n\t\tfinal float p4y = fy;\r\n\r\n\t\tfloat x1;\r\n\t\tfloat y1;\r\n\t\tfloat x2;\r\n\t\tfloat y2;\r\n\t\tfloat x3;\r\n\t\tfloat y3;\r\n\t\tfloat x4;\r\n\t\tfloat y4;\r\n\r\n\t\t// rotate\r\n\t\tif (rotation != 0) {\r\n\t\t\tfinal float cos = MathUtils.cosDeg(rotation);\r\n\t\t\tfinal float sin = MathUtils.sinDeg(rotation);\r\n\r\n\t\t\tx1 = cos * p1x - sin * p1y;\r\n\t\t\ty1 = sin * p1x + cos * p1y;\r\n\r\n\t\t\tx2 = cos * p2x - sin * p2y;\r\n\t\t\ty2 = sin * p2x + cos * p2y;\r\n\r\n\t\t\tx3 = cos * p3x - sin * p3y;\r\n\t\t\ty3 = sin * p3x + cos * p3y;\r\n\r\n\t\t\tx4 = x1 + (x3 - x2);\r\n\t\t\ty4 = y3 - (y2 - y1);\r\n\t\t} else {\r\n\t\t\tx1 = p1x;\r\n\t\t\ty1 = p1y;\r\n\r\n\t\t\tx2 = p2x;\r\n\t\t\ty2 = p2y;\r\n\r\n\t\t\tx3 = p3x;\r\n\t\t\ty3 = p3y;\r\n\r\n\t\t\tx4 = p4x;\r\n\t\t\ty4 = p4y;\r\n\t\t}\r\n\r\n\t\tx1 += worldOriginX;\r\n\t\ty1 += worldOriginY;\r\n\t\tx2 += worldOriginX;\r\n\t\ty2 += worldOriginY;\r\n\t\tx3 += worldOriginX;\r\n\t\ty3 += worldOriginY;\r\n\t\tx4 += worldOriginX;\r\n\t\ty4 += worldOriginY;\r\n\r\n\t\tfloat u = srcX * invTexWidth;\r\n\t\tfloat v = (srcY + srcHeight) * invTexHeight;\r\n\t\tfloat u2 = (srcX + srcWidth) * invTexWidth;\r\n\t\tfloat v2 = srcY * invTexHeight;\r\n\r\n\t\tif (flipX) {\r\n\t\t\tfloat tmp = u;\r\n\t\t\tu = u2;\r\n\t\t\tu2 = tmp;\r\n\t\t}\r\n\r\n\t\tif (flipY) {\r\n\t\t\tfloat tmp = v;\r\n\t\t\tv = v2;\r\n\t\t\tv2 = tmp;\r\n\t\t}\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x1;\r\n\t\tvertices[idx++] = y1;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x3;\r\n\t\tvertices[idx++] = y3;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x4;\r\n\t\tvertices[idx++] = y4;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderMesh () {\r\n\t\tif (idx == 0) return;\r\n\r\n\t\trenderCalls++;\r\n\t\ttotalRenderCalls++;\r\n\t\tint spritesInBatch = idx / 20;\r\n\t\tif (spritesInBatch > maxSpritesInBatch) maxSpritesInBatch = spritesInBatch;\r\n\r\n\t\tlastTexture.bind();\r\n\t\tmesh.setVertices(vertices, 0, idx);\r\n\t\tmesh.getIndicesBuffer().position(0);\r\n\t\tmesh.getIndicesBuffer().limit(spritesInBatch * 6);\r\n\r\n\t\tif (blendingDisabled) {\r\n\t\t\tGdx.gl.glDisable(GL20.GL_BLEND);\r\n\t\t} else {\r\n\t\t\tGdx.gl.glEnable(GL20.GL_BLEND);\r\n\t\t\tif (blendSrcFunc != -1) Gdx.gl.glBlendFunc(blendSrcFunc, blendDstFunc);\r\n\t\t}\r\n\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tif (customShader != null)\r\n\t\t\t\tmesh.render(customShader, GL10.GL_TRIANGLES, 0, spritesInBatch * 6);\r\n\t\t\telse\r\n\t\t\t\tmesh.render(shader, GL10.GL_TRIANGLES, 0, spritesInBatch * 6);\r\n\t\t} else {\r\n\t\t\tmesh.render(GL10.GL_TRIANGLES, 0, spritesInBatch * 6);\r\n\t\t}\r\n\r\n\t\tidx = 0;\r\n\t\tcurrBufferIdx++;\r\n\t\tif (currBufferIdx == buffers.length) currBufferIdx = 0;\r\n\t\tmesh = buffers[currBufferIdx];\r\n\t}","id":98263,"modified_method":"private void renderMesh () {\r\n\t\tif (idx == 0) return;\r\n\r\n\t\trenderCalls++;\r\n\t\ttotalRenderCalls++;\r\n\t\tint spritesInBatch = idx / 20;\r\n\t\tif (spritesInBatch > maxSpritesInBatch) maxSpritesInBatch = spritesInBatch;\r\n\t\tint count = spritesInBatch * 6;\r\n\r\n\t\tlastTexture.bind();\r\n\t\tMesh mesh = this.mesh;\r\n\t\tmesh.setVertices(vertices, 0, idx);\r\n\t\tmesh.getIndicesBuffer().position(0);\r\n\t\tmesh.getIndicesBuffer().limit(count);\r\n\r\n\t\tif (blendingDisabled) {\r\n\t\t\tGdx.gl.glDisable(GL20.GL_BLEND);\r\n\t\t} else {\r\n\t\t\tGdx.gl.glEnable(GL20.GL_BLEND);\r\n\t\t\tif (blendSrcFunc != -1) Gdx.gl.glBlendFunc(blendSrcFunc, blendDstFunc);\r\n\t\t}\r\n\r\n\t\tif (Gdx.graphics.isGL20Available())\r\n\t\t\tmesh.render(customShader != null ? customShader : shader, GL10.GL_TRIANGLES, 0, count);\r\n\t\telse\r\n\t\t\tmesh.render(GL10.GL_TRIANGLES, 0, count);\r\n\r\n\t\tidx = 0;\r\n\t\tcurrBufferIdx++;\r\n\t\tif (currBufferIdx == buffers.length) currBufferIdx = 0;\r\n\t\tthis.mesh = buffers[currBufferIdx];\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y and stretching the region to cover the given width and height. */\r\n\tpublic void draw (Texture texture, float x, float y, float width, float height) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\t\tfinal float u = 0;\r\n\t\tfinal float v = 1;\r\n\t\tfinal float u2 = 1;\r\n\t\tfinal float v2 = 0;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":98264,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y and stretching the region to cover the given width and height. */\r\n\tpublic void draw (Texture texture, float x, float y, float width, float height) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tif (texture != lastTexture)\r\n\t\t\tswitchTexture(texture);\r\n\t\telse if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\t\tfinal float u = 0;\r\n\t\tfinal float v = 1;\r\n\t\tfinal float u2 = 1;\r\n\t\tfinal float v2 = 0;\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y and stretching the region to cover the given width and height. The\r\n\t * rectangle is offset by originX, originY relative to the origin. Scale specifies the scaling factor by which the rectangle\r\n\t * should be scaled around originX, originY. Rotation specifies the angle of counter clockwise rotation of the rectangle around\r\n\t * originX, originY. */\r\n\tpublic void draw (TextureRegion region, float x, float y, float originX, float originY, float width, float height,\r\n\t\tfloat scaleX, float scaleY, float rotation) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tTexture texture = region.texture;\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\t// bottom left and top right corner points relative to origin\r\n\t\tfinal float worldOriginX = x + originX;\r\n\t\tfinal float worldOriginY = y + originY;\r\n\t\tfloat fx = -originX;\r\n\t\tfloat fy = -originY;\r\n\t\tfloat fx2 = width - originX;\r\n\t\tfloat fy2 = height - originY;\r\n\r\n\t\t// scale\r\n\t\tif (scaleX != 1 || scaleY != 1) {\r\n\t\t\tfx *= scaleX;\r\n\t\t\tfy *= scaleY;\r\n\t\t\tfx2 *= scaleX;\r\n\t\t\tfy2 *= scaleY;\r\n\t\t}\r\n\r\n\t\t// construct corner points, start from top left and go counter clockwise\r\n\t\tfinal float p1x = fx;\r\n\t\tfinal float p1y = fy;\r\n\t\tfinal float p2x = fx;\r\n\t\tfinal float p2y = fy2;\r\n\t\tfinal float p3x = fx2;\r\n\t\tfinal float p3y = fy2;\r\n\t\tfinal float p4x = fx2;\r\n\t\tfinal float p4y = fy;\r\n\r\n\t\tfloat x1;\r\n\t\tfloat y1;\r\n\t\tfloat x2;\r\n\t\tfloat y2;\r\n\t\tfloat x3;\r\n\t\tfloat y3;\r\n\t\tfloat x4;\r\n\t\tfloat y4;\r\n\r\n\t\t// rotate\r\n\t\tif (rotation != 0) {\r\n\t\t\tfinal float cos = MathUtils.cosDeg(rotation);\r\n\t\t\tfinal float sin = MathUtils.sinDeg(rotation);\r\n\r\n\t\t\tx1 = cos * p1x - sin * p1y;\r\n\t\t\ty1 = sin * p1x + cos * p1y;\r\n\r\n\t\t\tx2 = cos * p2x - sin * p2y;\r\n\t\t\ty2 = sin * p2x + cos * p2y;\r\n\r\n\t\t\tx3 = cos * p3x - sin * p3y;\r\n\t\t\ty3 = sin * p3x + cos * p3y;\r\n\r\n\t\t\tx4 = x1 + (x3 - x2);\r\n\t\t\ty4 = y3 - (y2 - y1);\r\n\t\t} else {\r\n\t\t\tx1 = p1x;\r\n\t\t\ty1 = p1y;\r\n\r\n\t\t\tx2 = p2x;\r\n\t\t\ty2 = p2y;\r\n\r\n\t\t\tx3 = p3x;\r\n\t\t\ty3 = p3y;\r\n\r\n\t\t\tx4 = p4x;\r\n\t\t\ty4 = p4y;\r\n\t\t}\r\n\r\n\t\tx1 += worldOriginX;\r\n\t\ty1 += worldOriginY;\r\n\t\tx2 += worldOriginX;\r\n\t\ty2 += worldOriginY;\r\n\t\tx3 += worldOriginX;\r\n\t\ty3 += worldOriginY;\r\n\t\tx4 += worldOriginX;\r\n\t\ty4 += worldOriginY;\r\n\r\n\t\tfinal float u = region.u;\r\n\t\tfinal float v = region.v2;\r\n\t\tfinal float u2 = region.u2;\r\n\t\tfinal float v2 = region.v;\r\n\r\n\t\tvertices[idx++] = x1;\r\n\t\tvertices[idx++] = y1;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x3;\r\n\t\tvertices[idx++] = y3;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x4;\r\n\t\tvertices[idx++] = y4;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":98265,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y and stretching the region to cover the given width and height. The\r\n\t * rectangle is offset by originX, originY relative to the origin. Scale specifies the scaling factor by which the rectangle\r\n\t * should be scaled around originX, originY. Rotation specifies the angle of counter clockwise rotation of the rectangle around\r\n\t * originX, originY. */\r\n\tpublic void draw (TextureRegion region, float x, float y, float originX, float originY, float width, float height,\r\n\t\tfloat scaleX, float scaleY, float rotation) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tTexture texture = region.texture;\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\t// bottom left and top right corner points relative to origin\r\n\t\tfinal float worldOriginX = x + originX;\r\n\t\tfinal float worldOriginY = y + originY;\r\n\t\tfloat fx = -originX;\r\n\t\tfloat fy = -originY;\r\n\t\tfloat fx2 = width - originX;\r\n\t\tfloat fy2 = height - originY;\r\n\r\n\t\t// scale\r\n\t\tif (scaleX != 1 || scaleY != 1) {\r\n\t\t\tfx *= scaleX;\r\n\t\t\tfy *= scaleY;\r\n\t\t\tfx2 *= scaleX;\r\n\t\t\tfy2 *= scaleY;\r\n\t\t}\r\n\r\n\t\t// construct corner points, start from top left and go counter clockwise\r\n\t\tfinal float p1x = fx;\r\n\t\tfinal float p1y = fy;\r\n\t\tfinal float p2x = fx;\r\n\t\tfinal float p2y = fy2;\r\n\t\tfinal float p3x = fx2;\r\n\t\tfinal float p3y = fy2;\r\n\t\tfinal float p4x = fx2;\r\n\t\tfinal float p4y = fy;\r\n\r\n\t\tfloat x1;\r\n\t\tfloat y1;\r\n\t\tfloat x2;\r\n\t\tfloat y2;\r\n\t\tfloat x3;\r\n\t\tfloat y3;\r\n\t\tfloat x4;\r\n\t\tfloat y4;\r\n\r\n\t\t// rotate\r\n\t\tif (rotation != 0) {\r\n\t\t\tfinal float cos = MathUtils.cosDeg(rotation);\r\n\t\t\tfinal float sin = MathUtils.sinDeg(rotation);\r\n\r\n\t\t\tx1 = cos * p1x - sin * p1y;\r\n\t\t\ty1 = sin * p1x + cos * p1y;\r\n\r\n\t\t\tx2 = cos * p2x - sin * p2y;\r\n\t\t\ty2 = sin * p2x + cos * p2y;\r\n\r\n\t\t\tx3 = cos * p3x - sin * p3y;\r\n\t\t\ty3 = sin * p3x + cos * p3y;\r\n\r\n\t\t\tx4 = x1 + (x3 - x2);\r\n\t\t\ty4 = y3 - (y2 - y1);\r\n\t\t} else {\r\n\t\t\tx1 = p1x;\r\n\t\t\ty1 = p1y;\r\n\r\n\t\t\tx2 = p2x;\r\n\t\t\ty2 = p2y;\r\n\r\n\t\t\tx3 = p3x;\r\n\t\t\ty3 = p3y;\r\n\r\n\t\t\tx4 = p4x;\r\n\t\t\ty4 = p4y;\r\n\t\t}\r\n\r\n\t\tx1 += worldOriginX;\r\n\t\ty1 += worldOriginY;\r\n\t\tx2 += worldOriginX;\r\n\t\ty2 += worldOriginY;\r\n\t\tx3 += worldOriginX;\r\n\t\ty3 += worldOriginY;\r\n\t\tx4 += worldOriginX;\r\n\t\ty4 += worldOriginY;\r\n\r\n\t\tfinal float u = region.u;\r\n\t\tfinal float v = region.v2;\r\n\t\tfinal float u2 = region.u2;\r\n\t\tfinal float v2 = region.v;\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x1;\r\n\t\tvertices[idx++] = y1;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x3;\r\n\t\tvertices[idx++] = y3;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x4;\r\n\t\tvertices[idx++] = y4;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the texture coordinates rotated 90 degrees. The bottom left corner at x,y and stretching the region\r\n\t * to cover the given width and height. The rectangle is offset by originX, originY relative to the origin. Scale specifies the\r\n\t * scaling factor by which the rectangle should be scaled around originX, originY. Rotation specifies the angle of counter\r\n\t * clockwise rotation of the rectangle around originX, originY.\r\n\t * @param clockwise If true, the texture coordinates are rotated 90 degrees clockwise. If false, they are rotated 90 degrees\r\n\t *           counter clockwise. */\r\n\tpublic void draw (TextureRegion region, float x, float y, float originX, float originY, float width, float height,\r\n\t\tfloat scaleX, float scaleY, float rotation, boolean clockwise) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tTexture texture = region.texture;\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\t// bottom left and top right corner points relative to origin\r\n\t\tfinal float worldOriginX = x + originX;\r\n\t\tfinal float worldOriginY = y + originY;\r\n\t\tfloat fx = -originX;\r\n\t\tfloat fy = -originY;\r\n\t\tfloat fx2 = width - originX;\r\n\t\tfloat fy2 = height - originY;\r\n\r\n\t\t// scale\r\n\t\tif (scaleX != 1 || scaleY != 1) {\r\n\t\t\tfx *= scaleX;\r\n\t\t\tfy *= scaleY;\r\n\t\t\tfx2 *= scaleX;\r\n\t\t\tfy2 *= scaleY;\r\n\t\t}\r\n\r\n\t\t// construct corner points, start from top left and go counter clockwise\r\n\t\tfinal float p1x = fx;\r\n\t\tfinal float p1y = fy;\r\n\t\tfinal float p2x = fx;\r\n\t\tfinal float p2y = fy2;\r\n\t\tfinal float p3x = fx2;\r\n\t\tfinal float p3y = fy2;\r\n\t\tfinal float p4x = fx2;\r\n\t\tfinal float p4y = fy;\r\n\r\n\t\tfloat x1;\r\n\t\tfloat y1;\r\n\t\tfloat x2;\r\n\t\tfloat y2;\r\n\t\tfloat x3;\r\n\t\tfloat y3;\r\n\t\tfloat x4;\r\n\t\tfloat y4;\r\n\r\n\t\t// rotate\r\n\t\tif (rotation != 0) {\r\n\t\t\tfinal float cos = MathUtils.cosDeg(rotation);\r\n\t\t\tfinal float sin = MathUtils.sinDeg(rotation);\r\n\r\n\t\t\tx1 = cos * p1x - sin * p1y;\r\n\t\t\ty1 = sin * p1x + cos * p1y;\r\n\r\n\t\t\tx2 = cos * p2x - sin * p2y;\r\n\t\t\ty2 = sin * p2x + cos * p2y;\r\n\r\n\t\t\tx3 = cos * p3x - sin * p3y;\r\n\t\t\ty3 = sin * p3x + cos * p3y;\r\n\r\n\t\t\tx4 = x1 + (x3 - x2);\r\n\t\t\ty4 = y3 - (y2 - y1);\r\n\t\t} else {\r\n\t\t\tx1 = p1x;\r\n\t\t\ty1 = p1y;\r\n\r\n\t\t\tx2 = p2x;\r\n\t\t\ty2 = p2y;\r\n\r\n\t\t\tx3 = p3x;\r\n\t\t\ty3 = p3y;\r\n\r\n\t\t\tx4 = p4x;\r\n\t\t\ty4 = p4y;\r\n\t\t}\r\n\r\n\t\tx1 += worldOriginX;\r\n\t\ty1 += worldOriginY;\r\n\t\tx2 += worldOriginX;\r\n\t\ty2 += worldOriginY;\r\n\t\tx3 += worldOriginX;\r\n\t\ty3 += worldOriginY;\r\n\t\tx4 += worldOriginX;\r\n\t\ty4 += worldOriginY;\r\n\r\n\t\tfloat u1, v1, u2, v2, u3, v3, u4, v4;\r\n\t\tif (clockwise) {\r\n\t\t\tu1 = region.u2;\r\n\t\t\tv1 = region.v2;\r\n\t\t\tu2 = region.u;\r\n\t\t\tv2 = region.v2;\r\n\t\t\tu3 = region.u;\r\n\t\t\tv3 = region.v;\r\n\t\t\tu4 = region.u2;\r\n\t\t\tv4 = region.v;\r\n\t\t} else {\r\n\t\t\tu1 = region.u;\r\n\t\t\tv1 = region.v;\r\n\t\t\tu2 = region.u2;\r\n\t\t\tv2 = region.v;\r\n\t\t\tu3 = region.u2;\r\n\t\t\tv3 = region.v2;\r\n\t\t\tu4 = region.u;\r\n\t\t\tv4 = region.v2;\r\n\t\t}\r\n\r\n\t\tvertices[idx++] = x1;\r\n\t\tvertices[idx++] = y1;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u1;\r\n\t\tvertices[idx++] = v1;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x3;\r\n\t\tvertices[idx++] = y3;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u3;\r\n\t\tvertices[idx++] = v3;\r\n\r\n\t\tvertices[idx++] = x4;\r\n\t\tvertices[idx++] = y4;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u4;\r\n\t\tvertices[idx++] = v4;\r\n\t}","id":98266,"modified_method":"/** Draws a rectangle with the texture coordinates rotated 90 degrees. The bottom left corner at x,y and stretching the region\r\n\t * to cover the given width and height. The rectangle is offset by originX, originY relative to the origin. Scale specifies the\r\n\t * scaling factor by which the rectangle should be scaled around originX, originY. Rotation specifies the angle of counter\r\n\t * clockwise rotation of the rectangle around originX, originY.\r\n\t * @param clockwise If true, the texture coordinates are rotated 90 degrees clockwise. If false, they are rotated 90 degrees\r\n\t *           counter clockwise. */\r\n\tpublic void draw (TextureRegion region, float x, float y, float originX, float originY, float width, float height,\r\n\t\tfloat scaleX, float scaleY, float rotation, boolean clockwise) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tTexture texture = region.texture;\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\t// bottom left and top right corner points relative to origin\r\n\t\tfinal float worldOriginX = x + originX;\r\n\t\tfinal float worldOriginY = y + originY;\r\n\t\tfloat fx = -originX;\r\n\t\tfloat fy = -originY;\r\n\t\tfloat fx2 = width - originX;\r\n\t\tfloat fy2 = height - originY;\r\n\r\n\t\t// scale\r\n\t\tif (scaleX != 1 || scaleY != 1) {\r\n\t\t\tfx *= scaleX;\r\n\t\t\tfy *= scaleY;\r\n\t\t\tfx2 *= scaleX;\r\n\t\t\tfy2 *= scaleY;\r\n\t\t}\r\n\r\n\t\t// construct corner points, start from top left and go counter clockwise\r\n\t\tfinal float p1x = fx;\r\n\t\tfinal float p1y = fy;\r\n\t\tfinal float p2x = fx;\r\n\t\tfinal float p2y = fy2;\r\n\t\tfinal float p3x = fx2;\r\n\t\tfinal float p3y = fy2;\r\n\t\tfinal float p4x = fx2;\r\n\t\tfinal float p4y = fy;\r\n\r\n\t\tfloat x1;\r\n\t\tfloat y1;\r\n\t\tfloat x2;\r\n\t\tfloat y2;\r\n\t\tfloat x3;\r\n\t\tfloat y3;\r\n\t\tfloat x4;\r\n\t\tfloat y4;\r\n\r\n\t\t// rotate\r\n\t\tif (rotation != 0) {\r\n\t\t\tfinal float cos = MathUtils.cosDeg(rotation);\r\n\t\t\tfinal float sin = MathUtils.sinDeg(rotation);\r\n\r\n\t\t\tx1 = cos * p1x - sin * p1y;\r\n\t\t\ty1 = sin * p1x + cos * p1y;\r\n\r\n\t\t\tx2 = cos * p2x - sin * p2y;\r\n\t\t\ty2 = sin * p2x + cos * p2y;\r\n\r\n\t\t\tx3 = cos * p3x - sin * p3y;\r\n\t\t\ty3 = sin * p3x + cos * p3y;\r\n\r\n\t\t\tx4 = x1 + (x3 - x2);\r\n\t\t\ty4 = y3 - (y2 - y1);\r\n\t\t} else {\r\n\t\t\tx1 = p1x;\r\n\t\t\ty1 = p1y;\r\n\r\n\t\t\tx2 = p2x;\r\n\t\t\ty2 = p2y;\r\n\r\n\t\t\tx3 = p3x;\r\n\t\t\ty3 = p3y;\r\n\r\n\t\t\tx4 = p4x;\r\n\t\t\ty4 = p4y;\r\n\t\t}\r\n\r\n\t\tx1 += worldOriginX;\r\n\t\ty1 += worldOriginY;\r\n\t\tx2 += worldOriginX;\r\n\t\ty2 += worldOriginY;\r\n\t\tx3 += worldOriginX;\r\n\t\ty3 += worldOriginY;\r\n\t\tx4 += worldOriginX;\r\n\t\ty4 += worldOriginY;\r\n\r\n\t\tfloat u1, v1, u2, v2, u3, v3, u4, v4;\r\n\t\tif (clockwise) {\r\n\t\t\tu1 = region.u2;\r\n\t\t\tv1 = region.v2;\r\n\t\t\tu2 = region.u;\r\n\t\t\tv2 = region.v2;\r\n\t\t\tu3 = region.u;\r\n\t\t\tv3 = region.v;\r\n\t\t\tu4 = region.u2;\r\n\t\t\tv4 = region.v;\r\n\t\t} else {\r\n\t\t\tu1 = region.u;\r\n\t\t\tv1 = region.v;\r\n\t\t\tu2 = region.u2;\r\n\t\t\tv2 = region.v;\r\n\t\t\tu3 = region.u2;\r\n\t\t\tv3 = region.v2;\r\n\t\t\tu4 = region.u;\r\n\t\t\tv4 = region.v2;\r\n\t\t}\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x1;\r\n\t\tvertices[idx++] = y1;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u1;\r\n\t\tvertices[idx++] = v1;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x3;\r\n\t\tvertices[idx++] = y3;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u3;\r\n\t\tvertices[idx++] = v3;\r\n\r\n\t\tvertices[idx++] = x4;\r\n\t\tvertices[idx++] = y4;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u4;\r\n\t\tvertices[idx++] = v4;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle using the given vertices. There must be 4 vertices, each made up of 5 elements in this order: x, y, color,\r\n\t * u, v. The {@link #getColor()} from the SpriteBatch is not applied. */\r\n\tpublic void draw (Texture texture, float[] spriteVertices, int offset, int count) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t}\r\n\r\n\t\tint remainingVertices = vertices.length - idx;\r\n\t\tif (remainingVertices == 0) {\r\n\t\t\trenderMesh();\r\n\t\t\tremainingVertices = vertices.length;\r\n\t\t}\r\n\t\tint copyCount = Math.min(remainingVertices, count);\r\n\t\tSystem.arraycopy(spriteVertices, offset, vertices, idx, copyCount);\r\n\t\tidx += copyCount;\r\n\t\tcount -= copyCount;\r\n\t\twhile (count > 0) {\r\n\t\t\toffset += copyCount;\r\n\t\t\trenderMesh();\r\n\t\t\tcopyCount = Math.min(vertices.length, count);\r\n\t\t\tSystem.arraycopy(spriteVertices, offset, vertices, 0, copyCount);\r\n\t\t\tidx += copyCount;\r\n\t\t\tcount -= copyCount;\r\n\t\t}\r\n\t}","id":98267,"modified_method":"/** Draws a rectangle using the given vertices. There must be 4 vertices, each made up of 5 elements in this order: x, y, color,\r\n\t * u, v. The {@link #getColor()} from the SpriteBatch is not applied. */\r\n\tpublic void draw (Texture texture, float[] spriteVertices, int offset, int count) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tint verticesLength = vertices.length;\r\n\t\tint remainingVertices = verticesLength;\r\n\t\tif (texture != lastTexture)\r\n\t\t\tswitchTexture(texture);\r\n\t\telse {\r\n\t\t\tremainingVertices -= idx;\r\n\t\t\tif (remainingVertices == 0) {\r\n\t\t\t\trenderMesh();\r\n\t\t\t\tremainingVertices = verticesLength;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint copyCount = Math.min(remainingVertices, count);\r\n\r\n\t\tSystem.arraycopy(spriteVertices, offset, vertices, idx, copyCount);\r\n\t\tidx += copyCount;\r\n\t\tcount -= copyCount;\r\n\t\twhile (count > 0) {\r\n\t\t\toffset += copyCount;\r\n\t\t\trenderMesh();\r\n\t\t\tcopyCount = Math.min(verticesLength, count);\r\n\t\t\tSystem.arraycopy(spriteVertices, offset, vertices, 0, copyCount);\r\n\t\t\tidx += copyCount;\r\n\t\t\tcount -= copyCount;\r\n\t\t}\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Sets up the SpriteBatch for drawing. This will disable depth buffer writting. It enables blending and texturing. If you have\r\n\t * more texture units enabled than the first one you have to disable them before calling this. Uses a screen coordinate system\r\n\t * by default where everything is given in pixels. You can specify your own projection and modelview matrices via\r\n\t * {@link #setProjectionMatrix(Matrix4)} and {@link #setTransformMatrix(Matrix4)}. */\r\n\tpublic void begin () {\r\n\t\tif (drawing) throw new IllegalStateException(\"you have to call SpriteBatch.end() first\");\r\n\t\trenderCalls = 0;\r\n\r\n\t\tGdx.gl.glDepthMask(false);\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tif (customShader != null)\r\n\t\t\t\tcustomShader.begin();\r\n\t\t\telse\r\n\t\t\t\tshader.begin();\r\n\t\t} else {\r\n\t\t\tGdx.gl.glEnable(GL10.GL_TEXTURE_2D);\r\n\t\t}\r\n\t\tsetupMatrices();\r\n\r\n\t\tidx = 0;\r\n\t\tlastTexture = null;\r\n\t\tdrawing = true;\r\n\t}","id":98268,"modified_method":"/** Sets up the SpriteBatch for drawing. This will disable depth buffer writting. It enables blending and texturing. If you have\r\n\t * more texture units enabled than the first one you have to disable them before calling this. Uses a screen coordinate system\r\n\t * by default where everything is given in pixels. You can specify your own projection and modelview matrices via\r\n\t * {@link #setProjectionMatrix(Matrix4)} and {@link #setTransformMatrix(Matrix4)}. */\r\n\tpublic void begin () {\r\n\t\tif (drawing) throw new IllegalStateException(\"SpriteBatch.end must be called before begin.\");\r\n\t\trenderCalls = 0;\r\n\r\n\t\tGdx.gl.glDepthMask(false);\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tif (customShader != null)\r\n\t\t\t\tcustomShader.begin();\r\n\t\t\telse\r\n\t\t\t\tshader.begin();\r\n\t\t} else {\r\n\t\t\tGdx.gl.glEnable(GL10.GL_TEXTURE_2D);\r\n\t\t}\r\n\t\tsetupMatrices();\r\n\r\n\t\tdrawing = true;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Finishes off rendering. Enables depth writes, disables blending and texturing. Must always be called after a call to\r\n\t * {@link #begin()} */\r\n\tpublic void end () {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before end.\");\r\n\t\tif (idx > 0) renderMesh();\r\n\t\tlastTexture = null;\r\n\t\tidx = 0;\r\n\t\tdrawing = false;\r\n\r\n\t\tGLCommon gl = Gdx.gl;\r\n\t\tgl.glDepthMask(true);\r\n\t\tif (isBlendingEnabled()) gl.glDisable(GL10.GL_BLEND);\r\n\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tif (customShader != null)\r\n\t\t\t\tcustomShader.end();\r\n\t\t\telse\r\n\t\t\t\tshader.end();\r\n\t\t} else {\r\n\t\t\tgl.glDisable(GL10.GL_TEXTURE_2D);\r\n\t\t}\r\n\t}","id":98269,"modified_method":"/** Finishes off rendering. Enables depth writes, disables blending and texturing. Must always be called after a call to\r\n\t * {@link #begin()} */\r\n\tpublic void end () {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before end.\");\r\n\t\tif (idx > 0) renderMesh();\r\n\t\tlastTexture = null;\r\n\t\tdrawing = false;\r\n\r\n\t\tGLCommon gl = Gdx.gl;\r\n\t\tgl.glDepthMask(true);\r\n\t\tif (isBlendingEnabled()) gl.glDisable(GL10.GL_BLEND);\r\n\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tif (customShader != null)\r\n\t\t\t\tcustomShader.end();\r\n\t\t\telse\r\n\t\t\t\tshader.end();\r\n\t\t} else {\r\n\t\t\tgl.glDisable(GL10.GL_TEXTURE_2D);\r\n\t\t}\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The portion of the\r\n\t * {@link Texture} given by srcX, srcY and srcWidth, srcHeight are used. These coordinates and sizes are given in texels.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels */\r\n\tpublic void draw (Texture texture, float x, float y, int srcX, int srcY, int srcWidth, int srcHeight) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) renderMesh();\r\n\r\n\t\tfinal float u = srcX * invTexWidth;\r\n\t\tfinal float v = (srcY + srcHeight) * invTexHeight;\r\n\t\tfinal float u2 = (srcX + srcWidth) * invTexWidth;\r\n\t\tfinal float v2 = srcY * invTexHeight;\r\n\t\tfinal float fx2 = x + srcWidth;\r\n\t\tfinal float fy2 = y + srcHeight;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":98270,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The portion of the\r\n\t * {@link Texture} given by srcX, srcY and srcWidth, srcHeight are used. These coordinates and sizes are given in texels.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels */\r\n\tpublic void draw (Texture texture, float x, float y, int srcX, int srcY, int srcWidth, int srcHeight) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tif (texture != lastTexture)\r\n\t\t\tswitchTexture(texture);\r\n\t\telse if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfinal float u = srcX * invTexWidth;\r\n\t\tfinal float v = (srcY + srcHeight) * invTexHeight;\r\n\t\tfinal float u2 = (srcX + srcWidth) * invTexWidth;\r\n\t\tfinal float v2 = srcY * invTexHeight;\r\n\t\tfinal float fx2 = x + srcWidth;\r\n\t\tfinal float fy2 = y + srcHeight;\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The portion of the\r\n\t * {@link Texture} given by srcX, srcY and srcWidth, srcHeight is used. These coordinates and sizes are given in texels. FlipX\r\n\t * and flipY specify whether the texture portion should be fliped horizontally or vertically.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels\r\n\t * @param flipX whether to flip the sprite horizontally\r\n\t * @param flipY whether to flip the sprite vertically */\r\n\tpublic void draw (Texture texture, float x, float y, float width, float height, int srcX, int srcY, int srcWidth,\r\n\t\tint srcHeight, boolean flipX, boolean flipY) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tif (texture != lastTexture) {\r\n\t\t\tswitchTexture(texture);\r\n\t\t} else if (idx == vertices.length) renderMesh();\r\n\r\n\t\tfloat u = srcX * invTexWidth;\r\n\t\tfloat v = (srcY + srcHeight) * invTexHeight;\r\n\t\tfloat u2 = (srcX + srcWidth) * invTexWidth;\r\n\t\tfloat v2 = srcY * invTexHeight;\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\r\n\t\tif (flipX) {\r\n\t\t\tfloat tmp = u;\r\n\t\t\tu = u2;\r\n\t\t\tu2 = tmp;\r\n\t\t}\r\n\r\n\t\tif (flipY) {\r\n\t\t\tfloat tmp = v;\r\n\t\t\tv = v2;\r\n\t\t\tv2 = tmp;\r\n\t\t}\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":98271,"modified_method":"/** Draws a rectangle with the bottom left corner at x,y having the given width and height in pixels. The portion of the\r\n\t * {@link Texture} given by srcX, srcY and srcWidth, srcHeight is used. These coordinates and sizes are given in texels. FlipX\r\n\t * and flipY specify whether the texture portion should be fliped horizontally or vertically.\r\n\t * \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels\r\n\t * @param flipX whether to flip the sprite horizontally\r\n\t * @param flipY whether to flip the sprite vertically */\r\n\tpublic void draw (Texture texture, float x, float y, float width, float height, int srcX, int srcY, int srcWidth,\r\n\t\tint srcHeight, boolean flipX, boolean flipY) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteBatch.begin must be called before draw.\");\r\n\r\n\t\tfloat[] vertices = this.vertices;\r\n\r\n\t\tif (texture != lastTexture)\r\n\t\t\tswitchTexture(texture);\r\n\t\telse if (idx == vertices.length) //\r\n\t\t\trenderMesh();\r\n\r\n\t\tfloat u = srcX * invTexWidth;\r\n\t\tfloat v = (srcY + srcHeight) * invTexHeight;\r\n\t\tfloat u2 = (srcX + srcWidth) * invTexWidth;\r\n\t\tfloat v2 = srcY * invTexHeight;\r\n\t\tfinal float fx2 = x + width;\r\n\t\tfinal float fy2 = y + height;\r\n\r\n\t\tif (flipX) {\r\n\t\t\tfloat tmp = u;\r\n\t\t\tu = u2;\r\n\t\t\tu2 = tmp;\r\n\t\t}\r\n\r\n\t\tif (flipY) {\r\n\t\t\tfloat tmp = v;\r\n\t\t\tv = v2;\r\n\t\t\tv2 = tmp;\r\n\t\t}\r\n\r\n\t\tint idx = this.idx;\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t\tthis.idx = idx;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns a new instance of the default shader used by SpriteBatch for GL2 when no shader is specified. */\r\n\tstatic public ShaderProgram createDefaultShader () {\r\n\t\tString vertexShader = \"attribute vec4 \" + ShaderProgram.POSITION_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"attribute vec4 \" + ShaderProgram.COLOR_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"attribute vec2 \" + ShaderProgram.TEXCOORD_ATTRIBUTE + \"0;\\n\" //\r\n\t\t\t+ \"uniform mat4 u_projTrans;\\n\" //\r\n\t\t\t+ \"varying vec4 v_color;\\n\" //\r\n\t\t\t+ \"varying vec2 v_texCoords;\\n\" //\r\n\t\t\t+ \"\\n\" //\r\n\t\t\t+ \"void main()\\n\" //\r\n\t\t\t+ \"{\\n\" //\r\n\t\t\t+ \"   v_color = \" + ShaderProgram.COLOR_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"   v_texCoords = \" + ShaderProgram.TEXCOORD_ATTRIBUTE + \"0;\\n\" //\r\n\t\t\t+ \"   gl_Position =  u_projTrans * \" + ShaderProgram.POSITION_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"}\\n\";\r\n\t\tString fragmentShader = \"#ifdef GL_ES\\n\" //\r\n\t\t\t+ \"#define LOWP lowp\\n\" //\r\n\t\t\t+ \"precision mediump float;\\n\" //\r\n\t\t\t+ \"#else\\n\" //\r\n\t\t\t+ \"#define LOWP \\n\" //\r\n\t\t\t+ \"#endif\\n\" //\r\n\t\t\t+ \"varying LOWP vec4 v_color;\\n\" //\r\n\t\t\t+ \"varying vec2 v_texCoords;\\n\" //\r\n\t\t\t+ \"uniform sampler2D u_texture;\\n\" //\r\n\t\t\t+ \"void main()\\n\"//\r\n\t\t\t+ \"{\\n\" //\r\n\t\t\t+ \"  gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\\n\" //\r\n\t\t\t+ \"}\";\r\n\r\n\t\tShaderProgram shader = new ShaderProgram(vertexShader, fragmentShader);\r\n\t\tif (shader.isCompiled() == false) throw new IllegalArgumentException(\"couldn't compile shader: \" + shader.getLog());\r\n\t\treturn shader;\r\n\t}","id":98272,"modified_method":"/** Returns a new instance of the default shader used by SpriteBatch for GL2 when no shader is specified. */\r\n\tstatic public ShaderProgram createDefaultShader () {\r\n\t\tString vertexShader = \"attribute vec4 \" + ShaderProgram.POSITION_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"attribute vec4 \" + ShaderProgram.COLOR_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"attribute vec2 \" + ShaderProgram.TEXCOORD_ATTRIBUTE + \"0;\\n\" //\r\n\t\t\t+ \"uniform mat4 u_projTrans;\\n\" //\r\n\t\t\t+ \"varying vec4 v_color;\\n\" //\r\n\t\t\t+ \"varying vec2 v_texCoords;\\n\" //\r\n\t\t\t+ \"\\n\" //\r\n\t\t\t+ \"void main()\\n\" //\r\n\t\t\t+ \"{\\n\" //\r\n\t\t\t+ \"   v_color = \" + ShaderProgram.COLOR_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"   v_texCoords = \" + ShaderProgram.TEXCOORD_ATTRIBUTE + \"0;\\n\" //\r\n\t\t\t+ \"   gl_Position =  u_projTrans * \" + ShaderProgram.POSITION_ATTRIBUTE + \";\\n\" //\r\n\t\t\t+ \"}\\n\";\r\n\t\tString fragmentShader = \"#ifdef GL_ES\\n\" //\r\n\t\t\t+ \"#define LOWP lowp\\n\" //\r\n\t\t\t+ \"precision mediump float;\\n\" //\r\n\t\t\t+ \"#else\\n\" //\r\n\t\t\t+ \"#define LOWP \\n\" //\r\n\t\t\t+ \"#endif\\n\" //\r\n\t\t\t+ \"varying LOWP vec4 v_color;\\n\" //\r\n\t\t\t+ \"varying vec2 v_texCoords;\\n\" //\r\n\t\t\t+ \"uniform sampler2D u_texture;\\n\" //\r\n\t\t\t+ \"void main()\\n\"//\r\n\t\t\t+ \"{\\n\" //\r\n\t\t\t+ \"  gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\\n\" //\r\n\t\t\t+ \"}\";\r\n\r\n\t\tShaderProgram shader = new ShaderProgram(vertexShader, fragmentShader);\r\n\t\tif (shader.isCompiled() == false) throw new IllegalArgumentException(\"Error compiling shader: \" + shader.getLog());\r\n\t\treturn shader;\r\n\t}","commit_id":"61c60842f357e0e7e4be812c6e2b52053c4c6134","url":"https://github.com/libgdx/libgdx"},{"original_method":"public boolean strictContained(BridgeTopologyLinkCandidate portcandidate) {\n        \tfor (String mac: getMacs()) {\n        \t\tif (!portcandidate.getMacs().contains(mac))\n        \t\t\treturn false;\n        \t}\n        \treturn true;\n        }","id":98273,"modified_method":"public boolean strictContained(BridgeTopologyLinkCandidate portcandidate) {\n        \tif (portcandidate.getBridgeTopologyPort().getMacs().size() <= getBridgeTopologyPort().getMacs().size())\n        \t\treturn false;\n        \tfor (String mac: getBridgeTopologyPort().getMacs()) {\n        \t\tif (!portcandidate.getBridgeTopologyPort().getMacs().contains(mac))\n        \t\t\treturn false;\n        \t}\n        \treturn true;\n        }","commit_id":"ae43e7dce5abfe8206dc51ebc5854643cbd7cab1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BridgeTopologyLinkCandidate parseBFTEntry(BridgeTopologyLinkCandidate topologyLinkCandidate) {\n    \t/* \n    \t * This class is designed to get the topology on one bridge forwarding table at a time\n    \t * so this means that the rules are written considering port1 belonging \n    \t * always to the same bridge.\n    \t * \n    \t * \n    \t * We assume the following:\n    \t * \n    \t * 1) there where no loops into the network (so there is a hierarchy)\n    \t * \n    \t * Corollary 1\n    \t * \n    \t * If exists there is only one backbone port from sw1 and sw2\n    \t * If exists there is only one backbone port from sw2 and sw1\n    \t * \n    \t * Corollary 2\n    \t * There is only one \"pseudo device\" containing the bridge\n    \t * \n    \t * Corollary 3\n    \t * on a backbone port two different mac address must belong to the same pseudo device\n    \t * \n    \t */\n        for (BridgeTopologyLinkCandidate linkcandidate: bridgeTopologyPortCandidates) {\n            LOG.info(\"parseBFTEntry: checking node {}, port {}: mac {}\",linkcandidate.getBridgeTopologyPort().getNodeid(),linkcandidate.getBridgeTopologyPort().getBridgePort(), linkcandidate.getMacs());\n\n            // regola intersezione nulla non faccio niente\n            // regola intersezione nulla non faccio niente\n        \tif (linkcandidate.getBridgeTopologyPort().getNodeid().intValue() ==\n        \t\t\ttopologyLinkCandidate.getBridgeTopologyPort().getNodeid().intValue()) {\n        \t\tLOG.info(\"parseBFTEntry: rule 00: same node: do nothing\");\n        \t\tcontinue;\n        \t} \n        \tif (linkcandidate.intersectionNull(topologyLinkCandidate)) {\n        \t\tLOG.info(\"parseBFTEntry: rule 0: intesection null: do nothing\");\n        \t\tcontinue;\n        \t} \n\n        \tif (linkcandidate.getRole() == BridgePortRole.BACKBONE) {\n        \t\tLOG.info(\"parseBFTEntry: rule 1: found old backbone port: setting new port to DIRECT\");\n        \t\tlinkcandidate.removeMacs(topologyLinkCandidate.getMacs());\n            \ttopologyLinkCandidate.setRole(BridgePortRole.DIRECT);\n            \tcontinue;\n        \t}\n\n        \tif (topologyLinkCandidate.getRole() == BridgePortRole.BACKBONE) {\n        \t\tLOG.info(\"parseBFTEntry: rule 2: found new backbone port: setting old port to DIRECT\");\n        \t\ttopologyLinkCandidate.removeMacs(linkcandidate.getMacs());\n            \tlinkcandidate.setRole(BridgePortRole.DIRECT);\n            \tcontinue;\n        \t}\n\n           // regola della dipendenza assoluta direzione avanti\n        \tif (linkcandidate.strictContained(topologyLinkCandidate)) {\n                LOG.info(\"parseBFTEntry: rule 3: old contained in new: adding target {} to node {}, backbone port {}\", linkcandidate.getBridgeTopologyPort().getNodeid(),\n                \t\ttopologyLinkCandidate.getBridgeTopologyPort().getNodeid(),topologyLinkCandidate.getBridgeTopologyPort().getBridgePort());\n            \ttopologyLinkCandidate.setRole(BridgePortRole.BACKBONE);\n            \ttopologyLinkCandidate.removeMacs(linkcandidate.getMacs());\n            \ttopologyLinkCandidate.addTarget(linkcandidate.getBridgeTopologyPort().getNodeid());\n            \tlinkcandidate.setRole(BridgePortRole.DIRECT);\n            \tcontinue;\n        \t} \n        \t// regola della dipendenza assoluta direzione dietro\n        \tif (topologyLinkCandidate.strictContained(linkcandidate)) {\n                LOG.info(\"parseBFTEntry: rule 4: new contained in old: adding target {} to node {},backbone port {}\", topologyLinkCandidate.getBridgeTopologyPort().getNodeid(),\n                \t\tlinkcandidate.getBridgeTopologyPort().getNodeid(),linkcandidate.getBridgeTopologyPort().getBridgePort());\n            \tlinkcandidate.setRole(BridgePortRole.BACKBONE);\n        \t\tlinkcandidate.removeMacs(topologyLinkCandidate.getMacs());\n            \tlinkcandidate.addTarget(topologyLinkCandidate.getBridgeTopologyPort().getNodeid());\n            \ttopologyLinkCandidate.setRole(BridgePortRole.DIRECT);\n        \t\tcontinue;\n        \t}\n        \t\n         \tif (linkcandidate.getLinkPortCandidate() == null) {\n                LOG.info(\"parseBFTEntry: rule 5: no suitable data: setting candidate each other\");\n        \t\tlinkcandidate.setLinkPortCandidate(topologyLinkCandidate.getBridgeTopologyPort());\n        \t\ttopologyLinkCandidate.setLinkPortCandidate(linkcandidate.getBridgeTopologyPort());\n        \t\tcontinue;\n        \t} \n\n        \tif (linkcandidate.getBridgeTopologyPort().getNodeid().intValue() == topologyLinkCandidate.getLinkPortCandidate().getNodeid().intValue()\n        \t\t\t&& linkcandidate.getBridgeTopologyPort().getBridgePort().intValue() != topologyLinkCandidate.getLinkPortCandidate().getBridgePort().intValue()) {\n                LOG.info(\"parseBFTEntry: rule 6: old contained in new: adding target {} to node {}, backbone port {}\", linkcandidate.getBridgeTopologyPort().getNodeid(),\n                \t\ttopologyLinkCandidate.getBridgeTopologyPort().getNodeid(),topologyLinkCandidate.getBridgeTopologyPort().getBridgePort());\n           \t\ttopologyLinkCandidate.setRole(BridgePortRole.BACKBONE);\n        \t\ttopologyLinkCandidate.removeMacs(linkcandidate.getMacs());\n        \t\ttopologyLinkCandidate.addTarget(linkcandidate.getBridgeTopologyPort().getNodeid());\n        \t\t\n        \t\tlinkcandidate.setRole(BridgePortRole.DIRECT);\n        \t\tlinkcandidate.setLinkPortCandidate(null);\n        \t\tcontinue;\n        \t}\n\n        \tif (topologyLinkCandidate.getBridgeTopologyPort().getNodeid().intValue() == linkcandidate.getLinkPortCandidate().getNodeid().intValue()  \n        \t\t\t&& topologyLinkCandidate.getBridgeTopologyPort().getBridgePort().intValue() != linkcandidate.getLinkPortCandidate().getBridgePort().intValue()) {\n                LOG.info(\"parseBFTEntry: rule 7: new contained in old: adding target {} to node {},backbone port {}\", topologyLinkCandidate.getBridgeTopologyPort().getNodeid(),\n                \t\tlinkcandidate.getBridgeTopologyPort().getNodeid(),linkcandidate.getBridgeTopologyPort().getBridgePort());\n        \t\tlinkcandidate.setRole(BridgePortRole.BACKBONE);\n        \t\tlinkcandidate.removeMacs(topologyLinkCandidate.getMacs());\n            \tlinkcandidate.addTarget(topologyLinkCandidate.getBridgeTopologyPort().getNodeid());\n\t\n        \t\ttopologyLinkCandidate.setRole(BridgePortRole.DIRECT);\n            \ttopologyLinkCandidate.setLinkPortCandidate(null);\n            \tcontinue;\n        \t}\n\n        }\n        return topologyLinkCandidate;\n\t}","id":98274,"modified_method":"public BridgeTopologyLinkCandidate parseBFTEntry(BridgeTopologyLinkCandidate topologyLinkCandidate) {\n    \t/* \n    \t * This class is designed to get the topology on one bridge forwarding table at a time\n    \t * so this means that the rules are written considering port1 belonging \n    \t * always to the same bridge.\n    \t * \n    \t * \n    \t * We assume the following:\n    \t * \n    \t * 1) there where no loops into the network (so there is a hierarchy)\n    \t * \n    \t * Corollary 1\n    \t * \n    \t * If exists there is only one backbone port from sw1 and sw2\n    \t * If exists there is only one backbone port from sw2 and sw1\n    \t * \n    \t * Corollary 2\n    \t * There is only one \"pseudo device\" containing the bridge\n    \t * \n    \t * Corollary 3\n    \t * on a backbone port two different mac address must belong to the same pseudo device\n    \t * \n    \t */\n        for (BridgeTopologyLinkCandidate linkcandidate: bridgeTopologyPortCandidates) {\n            LOG.info(\"parseBFTEntry: checking node {}, port {}: mac {}\",linkcandidate.getBridgeTopologyPort().getNodeid(),linkcandidate.getBridgeTopologyPort().getBridgePort(), linkcandidate.getMacs());\n\n            // regola intersezione nulla non faccio niente\n            // regola intersezione nulla non faccio niente\n        \tif (linkcandidate.getBridgeTopologyPort().getNodeid().intValue() ==\n        \t\t\ttopologyLinkCandidate.getBridgeTopologyPort().getNodeid().intValue()) {\n        \t\tLOG.info(\"parseBFTEntry: rule 00: same node: do nothing\");\n        \t\tcontinue;\n        \t} \n        \tif (linkcandidate.intersectionNull(topologyLinkCandidate)) {\n        \t\tLOG.info(\"parseBFTEntry: rule 0: intesection null: do nothing\");\n        \t\tcontinue;\n        \t} \n        \t// regola della dipendenza assoluta new\n        \tif (topologyLinkCandidate.strictContained(linkcandidate)) {\n                LOG.info(\"parseBFTEntry: rule 1: new contained in old: adding target {} to node {},backbone port {}\", topologyLinkCandidate.getBridgeTopologyPort().getNodeid(),\n                \t\tlinkcandidate.getBridgeTopologyPort().getNodeid(),linkcandidate.getBridgeTopologyPort().getBridgePort());\n            \tlinkcandidate.setRole(BridgePortRole.BACKBONE);\n        \t\tlinkcandidate.removeMacs(topologyLinkCandidate.getMacs());\n            \tlinkcandidate.addTarget(topologyLinkCandidate.getBridgeTopologyPort().getNodeid());\n            \ttopologyLinkCandidate.setRole(BridgePortRole.DIRECT);\n        \t\tcontinue;\n        \t}\n\n            // regola della dipendenza assoluta old\n         \tif (linkcandidate.strictContained(topologyLinkCandidate)) {\n                 LOG.info(\"parseBFTEntry: rule 2: old contained in new: adding target {} to node {}, backbone port {}\", linkcandidate.getBridgeTopologyPort().getNodeid(),\n                 \t\ttopologyLinkCandidate.getBridgeTopologyPort().getNodeid(),topologyLinkCandidate.getBridgeTopologyPort().getBridgePort());\n             \ttopologyLinkCandidate.setRole(BridgePortRole.BACKBONE);\n             \ttopologyLinkCandidate.removeMacs(linkcandidate.getMacs());\n             \ttopologyLinkCandidate.addTarget(linkcandidate.getBridgeTopologyPort().getNodeid());\n             \tlinkcandidate.setRole(BridgePortRole.DIRECT);\n             \tcontinue;\n         \t} \n\n        \tif (linkcandidate.getRole() == BridgePortRole.BACKBONE) {\n        \t\tLOG.info(\"parseBFTEntry: rule 3: found old backbone port: setting new port to DIRECT\");\n        \t\tlinkcandidate.removeMacs(topologyLinkCandidate.getMacs());\n            \ttopologyLinkCandidate.setRole(BridgePortRole.DIRECT);\n            \tcontinue;\n        \t}\n\n        \tif (topologyLinkCandidate.getRole() == BridgePortRole.BACKBONE) {\n        \t\tLOG.info(\"parseBFTEntry: rule 4: found new backbone port: setting old port to DIRECT\");\n        \t\ttopologyLinkCandidate.removeMacs(linkcandidate.getMacs());\n            \tlinkcandidate.setRole(BridgePortRole.DIRECT);\n            \tcontinue;\n        \t}\n\n         \tif (linkcandidate.getLinkPortCandidate() == null && topologyLinkCandidate.getLinkPortCandidate() == null) {\n                LOG.info(\"parseBFTEntry: rule 5: no suitable data: setting candidate each other\");\n        \t\tlinkcandidate.setLinkPortCandidate(topologyLinkCandidate.getBridgeTopologyPort());\n        \t\ttopologyLinkCandidate.setLinkPortCandidate(linkcandidate.getBridgeTopologyPort());\n        \t\tcontinue;\n        \t} \n\n        \tif (linkcandidate.getLinkPortCandidate() != null && topologyLinkCandidate.getBridgeTopologyPort().getNodeid().intValue() == linkcandidate.getLinkPortCandidate().getNodeid().intValue()  \n        \t\t\t&& topologyLinkCandidate.getBridgeTopologyPort().getBridgePort().intValue() != linkcandidate.getLinkPortCandidate().getBridgePort().intValue()) {\n                LOG.info(\"parseBFTEntry: rule 6: new contained in old: adding target {} to node {},backbone port {}\", topologyLinkCandidate.getBridgeTopologyPort().getNodeid(),\n                \t\tlinkcandidate.getBridgeTopologyPort().getNodeid(),linkcandidate.getBridgeTopologyPort().getBridgePort());\n        \t\tlinkcandidate.setRole(BridgePortRole.BACKBONE);\n        \t\tlinkcandidate.removeMacs(topologyLinkCandidate.getMacs());\n            \tlinkcandidate.addTarget(topologyLinkCandidate.getBridgeTopologyPort().getNodeid());\n\t\n        \t\ttopologyLinkCandidate.setRole(BridgePortRole.DIRECT);\n            \ttopologyLinkCandidate.setLinkPortCandidate(null);\n            \tcontinue;\n        \t}\n        \t\n        \tif (topologyLinkCandidate.getLinkPortCandidate() != null && linkcandidate.getBridgeTopologyPort().getNodeid().intValue() == topologyLinkCandidate.getLinkPortCandidate().getNodeid().intValue()\n        \t\t\t&& linkcandidate.getBridgeTopologyPort().getBridgePort().intValue() != topologyLinkCandidate.getLinkPortCandidate().getBridgePort().intValue()) {\n                LOG.info(\"parseBFTEntry: rule 7: old contained in new: adding target {} to node {}, backbone port {}\", linkcandidate.getBridgeTopologyPort().getNodeid(),\n                \t\ttopologyLinkCandidate.getBridgeTopologyPort().getNodeid(),topologyLinkCandidate.getBridgeTopologyPort().getBridgePort());\n           \t\ttopologyLinkCandidate.setRole(BridgePortRole.BACKBONE);\n        \t\ttopologyLinkCandidate.removeMacs(linkcandidate.getMacs());\n        \t\ttopologyLinkCandidate.addTarget(linkcandidate.getBridgeTopologyPort().getNodeid());\n        \t\t\n        \t\tlinkcandidate.setRole(BridgePortRole.DIRECT);\n        \t\tlinkcandidate.setLinkPortCandidate(null);\n        \t\tcontinue;\n        \t}\n\n\n        }\n        return topologyLinkCandidate;\n\t}","commit_id":"ae43e7dce5abfe8206dc51ebc5854643cbd7cab1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RowMutation(ByteBuffer key, ColumnFamily cf)\n    {\n        this(Schema.instance.getCFMetaData(cf.id()).ksName, key, cf);\n    }","id":98275,"modified_method":"public RowMutation(ByteBuffer key, ColumnFamily cf)\n    {\n        this(cf.metadata().ksName, key, cf);\n    }","commit_id":"f04359d91ae3ea3adca6e13f74a7c54e3845cab7","url":"https://github.com/apache/cassandra"},{"original_method":"public long serializedSize(RowMutation rm, int version)\n        {\n            TypeSizes sizes = TypeSizes.NATIVE;\n            int size = sizes.sizeof(rm.getTable());\n            int keySize = rm.key().remaining();\n            size += sizes.sizeof((short) keySize) + keySize;\n\n            size += sizes.sizeof(rm.modifications.size());\n            for (Map.Entry<UUID,ColumnFamily> entry : rm.modifications.entrySet())\n            {\n                if (version < MessagingService.VERSION_12)\n                    size += ColumnFamily.serializer.cfIdSerializedSize(entry.getValue().id(), sizes, version);\n                size += ColumnFamily.serializer.serializedSize(entry.getValue(), TypeSizes.NATIVE, version);\n            }\n\n            return size;\n        }","id":98276,"modified_method":"public long serializedSize(RowMutation rm, int version)\n        {\n            TypeSizes sizes = TypeSizes.NATIVE;\n            int size = 0;\n\n            if (version < MessagingService.VERSION_20)\n                size += sizes.sizeof(rm.getTable());\n\n            int keySize = rm.key().remaining();\n            size += sizes.sizeof((short) keySize) + keySize;\n\n            size += sizes.sizeof(rm.modifications.size());\n            for (Map.Entry<UUID,ColumnFamily> entry : rm.modifications.entrySet())\n            {\n                if (version < MessagingService.VERSION_12)\n                    size += ColumnFamily.serializer.cfIdSerializedSize(entry.getValue().id(), sizes, version);\n                size += ColumnFamily.serializer.serializedSize(entry.getValue(), TypeSizes.NATIVE, version);\n            }\n\n            return size;\n        }","commit_id":"f04359d91ae3ea3adca6e13f74a7c54e3845cab7","url":"https://github.com/apache/cassandra"},{"original_method":"public void serialize(RowMutation rm, DataOutput out, int version) throws IOException\n        {\n            out.writeUTF(rm.getTable());\n            ByteBufferUtil.writeWithShortLength(rm.key(), out);\n\n            /* serialize the modifications in the mutation */\n            int size = rm.modifications.size();\n            out.writeInt(size);\n            assert size >= 0;\n            for (Map.Entry<UUID, ColumnFamily> entry : rm.modifications.entrySet())\n            {\n                if (version < MessagingService.VERSION_12)\n                    ColumnFamily.serializer.serializeCfId(entry.getKey(), out, version);\n                ColumnFamily.serializer.serialize(entry.getValue(), out, version);\n            }\n        }","id":98277,"modified_method":"public void serialize(RowMutation rm, DataOutput out, int version) throws IOException\n        {\n            if (version < MessagingService.VERSION_20)\n                out.writeUTF(rm.getTable());\n\n            ByteBufferUtil.writeWithShortLength(rm.key(), out);\n\n            /* serialize the modifications in the mutation */\n            int size = rm.modifications.size();\n            out.writeInt(size);\n            assert size > 0;\n            for (Map.Entry<UUID, ColumnFamily> entry : rm.modifications.entrySet())\n            {\n                if (version < MessagingService.VERSION_12)\n                    ColumnFamily.serializer.serializeCfId(entry.getKey(), out, version);\n                ColumnFamily.serializer.serialize(entry.getValue(), out, version);\n            }\n        }","commit_id":"f04359d91ae3ea3adca6e13f74a7c54e3845cab7","url":"https://github.com/apache/cassandra"},{"original_method":"public RowMutation deserialize(DataInput in, int version, ColumnSerializer.Flag flag) throws IOException\n        {\n            String table = in.readUTF();\n            ByteBuffer key = ByteBufferUtil.readWithShortLength(in);\n            int size = in.readInt();\n\n            Map<UUID, ColumnFamily> modifications;\n            if (size == 1)\n            {\n                ColumnFamily cf = deserializeOneCf(in, version, flag);\n                modifications = Collections.singletonMap(cf.id(), cf);\n            }\n            else\n            {\n                modifications = new HashMap<UUID, ColumnFamily>();\n                for (int i = 0; i < size; ++i)\n                {\n                    ColumnFamily cf = deserializeOneCf(in, version, flag);\n                    modifications.put(cf.id(), cf);\n                }\n            }\n\n            return new RowMutation(table, key, modifications);\n        }","id":98278,"modified_method":"public RowMutation deserialize(DataInput in, int version, ColumnSerializer.Flag flag) throws IOException\n        {\n            String table = null; // will always be set from cf.metadata but javac isn't smart enough to see that\n            if (version < MessagingService.VERSION_20)\n                table = in.readUTF();\n\n            ByteBuffer key = ByteBufferUtil.readWithShortLength(in);\n            int size = in.readInt();\n            assert size > 0;\n\n            Map<UUID, ColumnFamily> modifications;\n            if (size == 1)\n            {\n                ColumnFamily cf = deserializeOneCf(in, version, flag);\n                modifications = Collections.singletonMap(cf.id(), cf);\n                table = cf.metadata().ksName;\n            }\n            else\n            {\n                modifications = new HashMap<UUID, ColumnFamily>();\n                for (int i = 0; i < size; ++i)\n                {\n                    ColumnFamily cf = deserializeOneCf(in, version, flag);\n                    modifications.put(cf.id(), cf);\n                    table = cf.metadata().ksName;\n                }\n            }\n\n            return new RowMutation(table, key, modifications);\n        }","commit_id":"f04359d91ae3ea3adca6e13f74a7c54e3845cab7","url":"https://github.com/apache/cassandra"},{"original_method":"public void doVerb(MessageIn<CounterMutation> message, String id)\n    {\n        try\n        {\n            CounterMutation cm = message.payload;\n            if (logger.isDebugEnabled())\n              logger.debug(\"Applying forwarded \" + cm);\n\n            String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());\n            StorageProxy.applyCounterMutationOnLeader(cm, localDataCenter).get();\n            WriteResponse response = new WriteResponse(cm.getTable(), cm.key(), true);\n            MessagingService.instance().sendReply(response.createMessage(), id, message.from);\n        }\n        catch (UnavailableException e)\n        {\n            // We check for UnavailableException in the coordinator now. It is\n            // hence reasonable to let the coordinator timeout in the very\n            // unlikely case we arrive here\n            logger.debug(\"counter unavailable\", e);\n        }\n        catch (TimedOutException e)\n        {\n            // The coordinator node will have timeout itself so we let that goes\n            logger.debug(\"counter timeout\", e);\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Error in counter mutation\", e);\n        }\n    }","id":98279,"modified_method":"public void doVerb(MessageIn<CounterMutation> message, String id)\n    {\n        try\n        {\n            CounterMutation cm = message.payload;\n            if (logger.isDebugEnabled())\n              logger.debug(\"Applying forwarded \" + cm);\n\n            String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());\n            StorageProxy.applyCounterMutationOnLeader(cm, localDataCenter).get();\n            WriteResponse response = new WriteResponse();\n            MessagingService.instance().sendReply(response.createMessage(), id, message.from);\n        }\n        catch (UnavailableException e)\n        {\n            // We check for UnavailableException in the coordinator now. It is\n            // hence reasonable to let the coordinator timeout in the very\n            // unlikely case we arrive here\n            logger.debug(\"counter unavailable\", e);\n        }\n        catch (TimedOutException e)\n        {\n            // The coordinator node will have timeout itself so we let that goes\n            logger.debug(\"counter timeout\", e);\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Error in counter mutation\", e);\n        }\n    }","commit_id":"fd2ddb5c3e628d4406761b9359112f6d18fa64b6","url":"https://github.com/apache/cassandra"},{"original_method":"public void doVerb(MessageIn<RowMutation> message, String id)\n    {\n        RowMutation rm = message.payload;\n        rm.apply();\n        WriteResponse response = new WriteResponse(rm.getTable(), rm.key(), true);\n        MessagingService.instance().sendReply(response.createMessage(), id, message.from);\n    }","id":98280,"modified_method":"public void doVerb(MessageIn<RowMutation> message, String id)\n    {\n        RowMutation rm = message.payload;\n        rm.apply();\n        WriteResponse response = new WriteResponse();\n        MessagingService.instance().sendReply(response.createMessage(), id, message.from);\n    }","commit_id":"fd2ddb5c3e628d4406761b9359112f6d18fa64b6","url":"https://github.com/apache/cassandra"},{"original_method":"public void doVerb(MessageIn<RowMutation> message, String id)\n    {\n        try\n        {\n            RowMutation rm = message.payload;\n            if (logger.isDebugEnabled())\n              logger.debug(\"Applying \" + rm);\n\n            // Check if there were any forwarding headers in this message\n            InetAddress replyTo = message.from;\n            byte[] from = message.parameters.get(RowMutation.FORWARD_FROM);\n            if (from == null)\n            {\n                byte[] forwardBytes = message.parameters.get(RowMutation.FORWARD_TO);\n                if (forwardBytes != null && message.version >= MessagingService.VERSION_11)\n                    forwardToLocalNodes(rm, message.verb, forwardBytes, message.from);\n            }\n            else\n            {\n                replyTo = InetAddress.getByAddress(from);\n            }\n\n            rm.apply();\n            WriteResponse response = new WriteResponse(rm.getTable(), rm.key(), true);\n            if (logger.isDebugEnabled())\n              logger.debug(rm + \" applied.  Sending response to \" + id + \"@\" + replyTo);\n            MessagingService.instance().sendReply(response.createMessage(), id, replyTo);\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Error in row mutation\", e);\n        }\n    }","id":98281,"modified_method":"public void doVerb(MessageIn<RowMutation> message, String id)\n    {\n        try\n        {\n            RowMutation rm = message.payload;\n            if (logger.isDebugEnabled())\n              logger.debug(\"Applying \" + rm);\n\n            // Check if there were any forwarding headers in this message\n            InetAddress replyTo = message.from;\n            byte[] from = message.parameters.get(RowMutation.FORWARD_FROM);\n            if (from == null)\n            {\n                byte[] forwardBytes = message.parameters.get(RowMutation.FORWARD_TO);\n                if (forwardBytes != null && message.version >= MessagingService.VERSION_11)\n                    forwardToLocalNodes(rm, message.verb, forwardBytes, message.from);\n            }\n            else\n            {\n                replyTo = InetAddress.getByAddress(from);\n            }\n\n            rm.apply();\n            WriteResponse response = new WriteResponse();\n            if (logger.isDebugEnabled())\n              logger.debug(rm + \" applied.  Sending response to \" + id + \"@\" + replyTo);\n            MessagingService.instance().sendReply(response.createMessage(), id, replyTo);\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Error in row mutation\", e);\n        }\n    }","commit_id":"fd2ddb5c3e628d4406761b9359112f6d18fa64b6","url":"https://github.com/apache/cassandra"},{"original_method":"private void testWriteResponseWrite() throws IOException\n    {\n        WriteResponse aff = new WriteResponse(Statics.KS, Statics.Key, true);\n        WriteResponse neg = new WriteResponse(Statics.KS, Statics.Key, false);\n        DataOutputStream out = getOutput(\"db.WriteResponse.bin\");\n        WriteResponse.serializer.serialize(aff, out, getVersion());\n        WriteResponse.serializer.serialize(neg, out, getVersion());\n        out.close();\n\n        // test serializedSize\n        testSerializedSize(aff, WriteResponse.serializer);\n        testSerializedSize(neg, WriteResponse.serializer);\n    }","id":98282,"modified_method":"private void testWriteResponseWrite() throws IOException\n    {\n        WriteResponse aff = new WriteResponse();\n        WriteResponse neg = new WriteResponse();\n        DataOutputStream out = getOutput(\"db.WriteResponse.bin\");\n        WriteResponse.serializer.serialize(aff, out, getVersion());\n        WriteResponse.serializer.serialize(neg, out, getVersion());\n        out.close();\n\n        // test serializedSize\n        testSerializedSize(aff, WriteResponse.serializer);\n        testSerializedSize(neg, WriteResponse.serializer);\n    }","commit_id":"fd2ddb5c3e628d4406761b9359112f6d18fa64b6","url":"https://github.com/apache/cassandra"},{"original_method":"public void serialize(WriteResponse wm, DataOutput dos, int version) throws IOException\n        {\n            dos.writeUTF(wm.table());\n            ByteBufferUtil.writeWithShortLength(wm.key(), dos);\n            dos.writeBoolean(wm.isSuccess());\n        }","id":98283,"modified_method":"public void serialize(WriteResponse wm, DataOutput dos, int version) throws IOException\n        {\n            if (version < MessagingService.VERSION_12)\n            {\n                dos.writeUTF(\"\");\n                ByteBufferUtil.writeWithShortLength(ByteBufferUtil.EMPTY_BYTE_BUFFER, dos);\n                dos.writeBoolean(true);\n            }\n        }","commit_id":"fd2ddb5c3e628d4406761b9359112f6d18fa64b6","url":"https://github.com/apache/cassandra"},{"original_method":"public long serializedSize(WriteResponse response, int version)\n        {\n            TypeSizes sizes = TypeSizes.NATIVE;\n            int keySize = response.key().remaining();\n            int size = sizes.sizeof(response.table());\n            size += sizes.sizeof((short) keySize) + keySize;\n            size += sizes.sizeof(response.isSuccess());\n            return size;\n        }","id":98284,"modified_method":"public long serializedSize(WriteResponse response, int version)\n        {\n            TypeSizes sizes = TypeSizes.NATIVE;\n            if (version < MessagingService.VERSION_12)\n                return sizes.sizeof(\"\") + sizes.sizeof((short) 0) + sizes.sizeof(true);\n            return 0;\n        }","commit_id":"fd2ddb5c3e628d4406761b9359112f6d18fa64b6","url":"https://github.com/apache/cassandra"},{"original_method":"public WriteResponse deserialize(DataInput dis, int version) throws IOException\n        {\n            String table = dis.readUTF();\n            ByteBuffer key = ByteBufferUtil.readWithShortLength(dis);\n            boolean status = dis.readBoolean();\n            return new WriteResponse(table, key, status);\n        }","id":98285,"modified_method":"public WriteResponse deserialize(DataInput dis, int version) throws IOException\n        {\n            if (version < MessagingService.VERSION_12)\n            {\n                dis.readUTF();\n                ByteBufferUtil.readWithShortLength(dis);\n                dis.readBoolean();\n            }\n            return new WriteResponse();\n        }","commit_id":"fd2ddb5c3e628d4406761b9359112f6d18fa64b6","url":"https://github.com/apache/cassandra"},{"original_method":"private String editLine(String input)\n\t{\n\t\tif (input == null) { return null; }\n\n\t\t//System.out.println(\"input : \" + input);\n\n\t\t/////////\n\t\t// Header corrections\n\t\tif (input.startsWith(\"##format=VCFv3.2\")) { return \"##format=VCRv3.2\\n\"; }\n\t\tif (input.startsWith(\"#CHROM\")) { return input.replaceAll(\"PROB\", \"QUAL\"); }\n\t\tif (input.startsWith(\"#\")) { return input; }\n\n\t\t/////////\n\t\t// Line-level corrections\n\t\t\n\t\t// make \"nan\" into \"NaN\"\n\t\tinput = input.replaceAll(\"nan\", \"NaN\");\n\t\tinput = input.replaceAll(\"DB(\\\\;|\\\\s)\", \"DB=1$1\");\n\t\tinput = input.replaceAll(\"HM2(\\\\;|\\\\s)\", \"HM2=1$1\");\n\t\tinput = input.replaceAll(\"HM3(\\\\;|\\\\s)\", \"HM3=1$1\");\n\n\t\tString[] tokens = input.split(\"\\\\s+\");\n\n\t\t/////////\n\t\t// Token-level corrections\n\n\t\t// if alt is \"N\", make it \".\"\n\t\tif (tokens[4].equals(\"N\")) { tokens[4] = \".\"; }\n\n\t\tString ref = tokens[3];\n\t\tString alt = tokens[4];\n\t\tString[] alts = alt.split(\",\");\n\n\t\tfor (int i = 9; i < tokens.length; i++)\n\t\t{\n\t\t\tif (tokens[i].equals(\".\")) { tokens[i] = \"./.:0\"; }\n\n\t\t\ttokens[i] = tokens[i].replaceAll(ref, \"0\");\n\t\t\tif (! alt.equals(\".\")) \n\t\t\t{ \n\t\t\t\tif (alts.length == 1)\n\t\t\t\t{\n\t\t\t\t\ttokens[i] = tokens[i].replaceAll(alt, \"1\"); \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < alts.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttokens[i] = tokens[i].replaceAll(alts[j], \"1\"); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/////////\n\t\t// Info-level corrections\n\n\t\tString info = tokens[7];\n\t\tString new_info = \"\";\n\t\tString[] info_tokens = info.split(\";\");\t\t\t\t\n\t\tfor (int i = 0; i < info_tokens.length; i++)\n\t\t{\n\n\t\t\t// Fix the case where AC includes the ref count first.\n\t\t\tif (info_tokens[i].startsWith(\"AC=\"))\n\t\t\t{\n\t\t\t\tString[] ACs  = info_tokens[i].replaceAll(\"^AC=\", \"\").split(\",\");\n\t\t\t\tif (ACs.length == alts.length+1)\n\t\t\t\t{\n\t\t\t\t\tString new_ACs = \"\";\n\t\t\t\t\tfor (int j = 1; j < ACs.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnew_ACs += ACs[j];\n\t\t\t\t\t\tif (j != (ACs.length-1)) { new_ACs += \",\"; }\n\t\t\t\t\t}\t\n\t\t\t\t\tinfo_tokens[i] = \"AC=\" + new_ACs;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnew_info += info_tokens[i];\n\t\t\tif (i != (info_tokens.length-1)) { new_info += \";\"; }\n\t\t}\n\t\ttokens[7] = new_info;\n\n\n\t\t/////////\n\t\t// Now put it back together and emit.\n\t\tString output = tokens[0];\n\t\tfor (int i = 1; i < tokens.length; i++)\n\t\t{\n\t\t\toutput = output + \"\\t\" + tokens[i];\n\t\t}\n\t\toutput = output + \"\\n\";\n\n\t\t//System.out.println(\"output: \" + output);\n\n\t\treturn output;\n\t}","id":98286,"modified_method":"private String editLine(String input)\n\t{\n\t\tif (input == null) { return null; }\n\n\t\t//System.out.println(\"input : \" + input);\n\n\t\t// Make it tab-delimited\n\t\tinput = input.replaceAll(\" +\", \"\\t\");\n\t\t\n\t\t/////////\n\t\t// Header corrections\n\t\tif (input.startsWith(\"##format=VCFv3.2\")) { return \"##format=VCRv3.2\\n\"; }\n\t\tif (input.startsWith(\"#CHROM\")) { return input.replaceAll(\"PROB\", \"QUAL\"); }\n\t\tif (input.startsWith(\"#\")) { return input; }\n\n\t\t/////////\n\t\t// Line-level corrections\n\t\t\n\t\t// make \"nan\" into \"NaN\"\n\t\tinput = input.replaceAll(\"nan\", \"NaN\");\n\t\tinput = input.replaceAll(\"DB(\\\\;|\\\\s)\", \"DB=1$1\");\n\t\tinput = input.replaceAll(\"HM2(\\\\;|\\\\s)\", \"HM2=1$1\");\n\t\tinput = input.replaceAll(\"HM3(\\\\;|\\\\s)\", \"HM3=1$1\");\n\n\t\tString[] tokens = input.split(\"\\\\s+\");\n\n\t\t/////////\n\t\t// Token-level corrections\n\n\t\t// if alt is \"N\", make it \".\"\n\t\tif (tokens[4].equals(\"N\")) { tokens[4] = \".\"; }\n\t\tif (tokens[5].equals(\".\")) { tokens[5] = \"-1\"; }\n\n\t\tString ref = tokens[3];\n\t\tString alt = tokens[4];\n\t\tString[] alts = alt.split(\",\");\n\n\t\tfor (int i = 9; i < tokens.length; i++)\n\t\t{\n\t\t\tif (tokens[i].equals(\".\")) { tokens[i] = \"./.:0\"; }\n\n\t\t\ttokens[i] = tokens[i].replaceAll(ref, \"0\");\n\t\t\tif (! alt.equals(\".\")) \n\t\t\t{ \n\t\t\t\tif (alts.length == 1)\n\t\t\t\t{\n\t\t\t\t\ttokens[i] = tokens[i].replaceAll(alt, \"1\"); \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < alts.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttokens[i] = tokens[i].replaceAll(alts[j], \"1\"); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/////////\n\t\t// Info-level corrections\n\n\t\tString info = tokens[7];\n\t\tString new_info = \"\";\n\t\tString[] info_tokens = info.split(\";\");\t\t\t\t\n\t\tfor (int i = 0; i < info_tokens.length; i++)\n\t\t{\n\t\t\tif (info_tokens[i].startsWith(\"R2=\"))\n\t\t\t{\n\t\t\t\t// Fix NaN's in RNaN's in R2.\n\t\t\t\tString new_token = info_tokens[i].replace(\"NaN\", \"0.0\");\n\t\t\t\tinfo_tokens[i] = new_token;\n\t\t\t}\n\t\t\telse if (info_tokens[i].startsWith(\"AC=\"))\n\t\t\t{\n\t\t\t\t// Fix the case where AC includes the ref count first.\n\t\t\t\tString[] ACs  = info_tokens[i].replaceAll(\"^AC=\", \"\").split(\",\");\n\t\t\t\tif (ACs.length == alts.length+1)\n\t\t\t\t{\n\t\t\t\t\tString new_ACs = \"\";\n\t\t\t\t\tfor (int j = 1; j < ACs.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnew_ACs += ACs[j];\n\t\t\t\t\t\tif (j != (ACs.length-1)) { new_ACs += \",\"; }\n\t\t\t\t\t}\t\n\t\t\t\t\tinfo_tokens[i] = \"AC=\" + new_ACs;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnew_info += info_tokens[i];\n\t\t\tif (i != (info_tokens.length-1)) { new_info += \";\"; }\n\t\t}\n\t\ttokens[7] = new_info;\n\n\n\t\t/////////\n\t\t// Now put it back together and emit.\n\t\tString output = tokens[0];\n\t\tfor (int i = 1; i < tokens.length; i++)\n\t\t{\n\t\t\toutput = output + \"\\t\" + tokens[i];\n\t\t}\n\t\toutput = output + \"\\n\";\n\n\t\t//System.out.println(\"output: \" + output);\n\n\t\treturn output;\n\t}","commit_id":"0ef50bcae726ff778f4f86bbb5d22549a7edcd5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Cut optimize(OptimizationRecord[] records, double min_TsTv, int freq)\n\t\t{\n\t\t\tdouble best_lod       = Double.NaN;\n\t\t\tdouble best_slod      = Double.NaN;\t\t\t\n\t\t\tdouble best_tstv      = Double.NEGATIVE_INFINITY;\n\t\t\tdouble best_num_calls = Double.NEGATIVE_INFINITY;\n\t\t\tboolean flag = false;\n\n\n\t\t\tdouble[] lods  = new double[records.length];\n\t\t\tdouble[] slods = new double[records.length];\n\t\t\tfor (int i = 0; i < lods.length; i++)\n\t\t\t{\n\t\t\t\tlods[i]  = records[i].features[0];\n\t\t\t\tslods[i] = records[i].features[1];\n\t\t\t}\n\n\t\t\tArrays.sort(lods);\n\t\t\tArrays.sort(slods);\n\n\t\t\tint num_breaks = 100;\n\t\t\tdouble[] lod_breaks  = new double[num_breaks];\n\t\t\tdouble[] slod_breaks = new double[num_breaks];\n\t\t\tint bin_size = 1 + (records.length / num_breaks);\n\n\t\t\t//System.out.printf(\"BREAKS i j lod slod\\n\");\n\t\t\tint j = 0;\n\t\t\tfor (int i = 0; i < records.length; i += bin_size)\n\t\t\t{\n\t\t\t\tlod_breaks[j] = lods[i];\n\t\t\t\tslod_breaks[j] = slods[i];\n\t\t\t\tj += 1;\n\t\t\t\t//System.out.printf(\"BREAKS %d %d %f %f\\n\", i, j, lods[i], slods[i]);\n\t\t\t}\n\t\t\t//System.out.printf(\"\\n\");\n\n\n\t\t\t//for (double lod = 0; lod < 8000; lod += 10)\n\t\t\tfor (int lod_idx = 0; lod_idx < num_breaks; lod_idx += 1)\n\t\t\t{\n\t\t\t\tdouble lod = lod_breaks[lod_idx];\n\t\t\t\t//for (double slod = -4000; slod < 1000; slod += 10)\n\t\t\t\tfor (int slod_idx = 0; slod_idx < num_breaks; slod_idx += 1)\n\t\t\t\t{\n\t\t\t\t\tdouble slod = slod_breaks[slod_idx];\n\n\t\t\t\t\tdouble[] point = new double[2];\n\t\t\t\t\tpoint[0] = lod;\n\t\t\t\t\tpoint[1] = slod;\n\t\t\t\t\tdouble tstv      = tstv(point, records);\n\t\t\t\t\tdouble num_calls = num_calls(point, records);\n\t\t\t\t\tif ((tstv >= min_TsTv) && (num_calls > best_num_calls)) \n\t\t\t\t\t{ \n\t\t\t\t\t\tbest_lod=lod; \n\t\t\t\t\t\tbest_slod=slod; \n\t\t\t\t\t\tbest_tstv=tstv; \n\t\t\t\t\t\tbest_num_calls=num_calls; \n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tstv >= best_tstv) && (!flag)) \n\t\t\t\t\t{ \n\t\t\t\t\t\tbest_lod=lod; \n\t\t\t\t\t\tbest_slod=slod; \n\t\t\t\t\t\tbest_tstv=tstv; \n\t\t\t\t\t\tbest_num_calls=num_calls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.printf(\"Found optimum: lod=%f slod=%f num_calls=%f tstv=%f\\n\", best_lod, best_slod, best_num_calls, best_tstv);\n\t\t\tSystem.out.printf(\"%d %f %f %f %f\\n\", freq, best_lod, best_slod, best_num_calls, best_tstv);\n\n\t\t\treturn new Cut(best_lod, best_slod);\n\t\t}","id":98287,"modified_method":"private Cut optimize(OptimizationRecord[] records, double min_TsTv, int freq)\n\t\t{\n\n\n\t\t\tdouble[] lods  = new double[records.length];\n\t\t\tdouble[] slods = new double[records.length];\n\t\t\tfor (int i = 0; i < lods.length; i++)\n\t\t\t{\n\t\t\t\tlods[i]  = records[i].features[0];\n\t\t\t\tslods[i] = records[i].features[1];\n\t\t\t}\n\n\t\t\tArrays.sort(lods);\n\t\t\tArrays.sort(slods);\n\n\t\t\tdouble[] lod_breaks  = new double[num_breaks];\n\t\t\tdouble[] slod_breaks = new double[num_breaks];\n\t\t\tint bin_size = 1 + (records.length / num_breaks);\n\n\t\t\t//System.out.printf(\"BREAKS i j lod slod\\n\");\n\t\t\tint j = 0;\n\t\t\tfor (int i = 0; i < records.length; i += bin_size)\n\t\t\t{\n\t\t\t\tlod_breaks[j] = lods[i];\n\t\t\t\tslod_breaks[j] = slods[i];\n\t\t\t\tj += 1;\n\t\t\t\t//System.out.printf(\"BREAKS %d %d %f %f\\n\", i, j, lods[i], slods[i]);\n\t\t\t}\n\t\t\t//System.out.printf(\"\\n\");\n\n\t\t\tdouble best_lod       = lod_breaks[0];\n\t\t\tdouble best_slod      = slod_breaks[0];\n\n\t\t\tint best_lod_idx       = 0;\n\t\t\tint best_slod_idx      = 0;\n\n\t\t\tdouble[] point = new double[2];\n\t\t\tpoint[0] = best_lod;\n\t\t\tpoint[1] = best_slod;\n\n\t\t\tdouble best_tstv      = tstv(point, records);\n\t\t\tdouble best_num_calls = num_calls(point, records);\n\t\t\tboolean flag = false;\n\n\t\t\t//for (double lod = 0; lod < 8000; lod += 10)\n\t\t\tfor (int lod_idx = 0; lod_idx < num_breaks; lod_idx += 1)\n\t\t\t{\n\t\t\t\tdouble lod = lod_breaks[lod_idx];\n\t\t\t\t//for (double slod = -4000; slod < 1000; slod += 10)\n\t\t\t\tfor (int slod_idx = 0; slod_idx < num_breaks; slod_idx += 1)\n\t\t\t\t{\n\t\t\t\t\tdouble slod = slod_breaks[slod_idx];\n\n\t\t\t\t\tpoint = new double[2];\n\t\t\t\t\tpoint[0] = lod;\n\t\t\t\t\tpoint[1] = slod;\n\t\t\t\t\tdouble tstv      = tstv(point, records);\n\t\t\t\t\tdouble num_calls = num_calls(point, records);\n\t\t\t\t\t\n\t\t\t\t\tif (num_calls < min_calls) { continue; }\n\n\t\t\t\t\tif ((tstv >= min_TsTv) && (num_calls > best_num_calls)) \n\t\t\t\t\t{ \n\t\t\t\t\t\tbest_lod=lod; \n\t\t\t\t\t\tbest_slod=slod; \n\t\t\t\t\t\tbest_tstv=tstv; \n\t\t\t\t\t\tbest_num_calls=num_calls; \n\t\t\t\t\t\tbest_lod_idx = lod_idx;\n\t\t\t\t\t\tbest_slod_idx = slod_idx;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tstv >= best_tstv) && (!flag)) \n\t\t\t\t\t{ \n\t\t\t\t\t\tbest_lod=lod; \n\t\t\t\t\t\tbest_slod=slod; \n\t\t\t\t\t\tbest_tstv=tstv; \n\t\t\t\t\t\tbest_num_calls=num_calls;\n\t\t\t\t\t\tbest_lod_idx = lod_idx;\n\t\t\t\t\t\tbest_slod_idx = slod_idx;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (verbose)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.printf(\"DEBUG: %d | %d %d | %f %f %f %f | %f %f %f %f\\n\", \n\t\t\t\t\t\t\t\t\tfreq, \n\t\t\t\t\t\t\t\t\tlod_idx, slod_idx,\n\t\t\t\t\t\t\t\t\tlod, slod, num_calls, tstv,\n\t\t\t\t\t\t\t\t\tbest_lod, best_slod, best_num_calls, best_tstv);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.printf(\"Found optimum: lod=%f slod=%f num_calls=%f tstv=%f\\n\", best_lod, best_slod, best_num_calls, best_tstv);\n\t\t\tSystem.out.printf(\"%d %d %d %f %f %f %f\\n\", freq, best_lod_idx, best_slod_idx, best_lod, best_slod, best_num_calls, best_tstv);\n\n\t\t\treturn new Cut(best_lod, best_slod);\n\t\t}","commit_id":"0ef50bcae726ff778f4f86bbb5d22549a7edcd5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void main(String args[]) \n\t\t{\n\t\t\tSetupSequenceDictionary();\n\n\t\t\tString mode = args[0];\n\t\t\tString[] realArgs = Arrays.copyOfRange(args, 1, args.length);\n\n\t\t\tif (mode.equals(\"validate\"))\n\t\t\t{\n\t\t\t\tVCFValidate cm = new VCFValidate();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"grep\"))\n\t\t\t{\n\t\t\t\tVCFGrep cm = new VCFGrep();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"concordance\"))\n\t\t\t{\n\t\t\t\tVCFConcordance cm = new VCFConcordance();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"simple_stats\"))\n\t\t\t{\n\t\t\t\tVCFSimpleStats cm = new VCFSimpleStats();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"printGQ\"))\n\t\t\t{\n\t\t\t\tPrintGQ cm = new PrintGQ();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"fix_ref_fields\"))\n\t\t\t{\n\t\t\t\tFixRefFields cm = new FixRefFields();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"check_ref_fields\"))\n\t\t\t{\n\t\t\t\tCheckRefFields cm = new CheckRefFields();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"stats\"))\n\t\t\t{\n\t\t\t\tVCFStats cm = new VCFStats();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"sequenom\"))\n\t\t\t{\n\t\t\t\tVCFSequenomAnalysis cm = new VCFSequenomAnalysis();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"sequenom2\"))\n\t\t\t{\n\t\t\t\tVCFSequenomAnalysis2 cm = new VCFSequenomAnalysis2();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"call_rates\"))\n\t\t\t{\n\t\t\t\tVCFCallRates cm = new VCFCallRates();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"optimize\"))\n\t\t\t{\n\t\t\t\tVCFOptimize cm = new VCFOptimize();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"apply_cuts\"))\n\t\t\t{\n\t\t\t\tVCFApplyCuts cm = new VCFApplyCuts();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"ERROR: mode %s not defined.\\n\", mode);\t\t\t\n\t\t\tSystem.exit(-1);\n\n\t\t}","id":98288,"modified_method":"public static void main(String args[]) \n\t\t{\n\t\t\t// silence log4j messages.\n\t\t\t//appender = new FileAppender(layout, clp.toFile, false);\n\t\t\t//logger.addAppender(appender);\n\n\t\t\tSetupSequenceDictionary();\n\n\t\t\tString mode = args[0];\n\t\t\tString[] realArgs = Arrays.copyOfRange(args, 1, args.length);\n\n\t\t\tif (mode.equals(\"validate\"))\n\t\t\t{\n\t\t\t\tVCFValidate cm = new VCFValidate();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"grep\"))\n\t\t\t{\n\t\t\t\tVCFGrep cm = new VCFGrep();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"concordance\"))\n\t\t\t{\n\t\t\t\tVCFConcordance cm = new VCFConcordance();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"simple_stats\"))\n\t\t\t{\n\t\t\t\tVCFSimpleStats cm = new VCFSimpleStats();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"printGQ\"))\n\t\t\t{\n\t\t\t\tPrintGQ cm = new PrintGQ();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"fix_ref_fields\"))\n\t\t\t{\n\t\t\t\tFixRefFields cm = new FixRefFields();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"check_ref_fields\"))\n\t\t\t{\n\t\t\t\tCheckRefFields cm = new CheckRefFields();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"stats\"))\n\t\t\t{\n\t\t\t\tVCFStats cm = new VCFStats();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"sequenom\"))\n\t\t\t{\n\t\t\t\tVCFSequenomAnalysis cm = new VCFSequenomAnalysis();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"sequenom2\"))\n\t\t\t{\n\t\t\t\tVCFSequenomAnalysis2 cm = new VCFSequenomAnalysis2();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"call_rates\"))\n\t\t\t{\n\t\t\t\tVCFCallRates cm = new VCFCallRates();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"optimize\"))\n\t\t\t{\n\t\t\t\tVCFOptimize cm = new VCFOptimize();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"apply_cuts\"))\n\t\t\t{\n\t\t\t\tVCFApplyCuts cm = new VCFApplyCuts();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tif (mode.equals(\"merge\"))\n\t\t\t{\n\t\t\t\tVCFMerge cm = new VCFMerge();\n\t\t\t\tCommandLineProgram.start(cm,realArgs);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"ERROR: mode %s not defined.\\n\", mode);\t\t\t\n\t\t\tSystem.exit(-1);\n\n\t\t}","commit_id":"0ef50bcae726ff778f4f86bbb5d22549a7edcd5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\t\tprotected int execute() \n\t\t{\n\t\t\tHashSet<String> loci = new HashSet<String>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tScanner loci_reader = new Scanner(new File(loci_filename));\n\t\t\t\twhile(loci_reader.hasNextLine())\n\t\t\t\t{\n\t\t\t\t\tString line = loci_reader.nextLine();\n\t\t\t\t\tline = line.replaceAll(\"\\\\s+\", \"\");\n\t\t\t\t\tloci.add(line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPrintStream output = new PrintStream(new File(out_filename));\n\n\t\t\t\tScanner reader = new Scanner(new File(in_filename));\n\t\t\t\twhile(reader.hasNextLine())\n\t\t\t\t{\n\t\t\t\t\tString line = reader.nextLine();\n\n\t\t\t\t\tif (line.matches(\"^\\\\#.*$\")) { output.print(line + \"\\n\"); continue; }\n\n\t\t\t\t\tString[] tokens = line.split(\"\\\\s+\");\n\t\t\t\t\tString locus = tokens[0] + \":\" + tokens[1];\n\t\t\t\t\tif (loci.contains(locus)) { output.print(line + \"\\n\"); continue; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}","id":98289,"modified_method":"@Override\n\t\tprotected int execute() \n\t\t{\n\t\t\tHashSet<String> loci = new HashSet<String>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tScanner loci_reader;\n\n\t\t\t\tif (loci_filename.endsWith(\".gz\")) { loci_reader = new Scanner(new GZIPInputStream(new FileInputStream(loci_filename))); }\n\t\t\t\telse { loci_reader = new Scanner(new File(loci_filename)); }\n\n\t\t\t\twhile(loci_reader.hasNextLine())\n\t\t\t\t{\n\t\t\t\t\tString line = loci_reader.nextLine();\n\t\t\t\t\tline = line.replaceAll(\"\\\\s+\", \"\");\n\t\t\t\t\tloci.add(line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPrintStream output = new PrintStream(new File(out_filename));\n\n\t\t\t\tScanner reader;\n\t\t\t\tif (in_filename.endsWith(\".gz\")) { reader = new Scanner(new GZIPInputStream(new FileInputStream(in_filename))); }\n\t\t\t\telse { reader = new Scanner(new File(in_filename)); }\n\t\t\t\twhile(reader.hasNextLine())\n\t\t\t\t{\n\t\t\t\t\tString line = reader.nextLine();\n\n\t\t\t\t\tif (line.matches(\"^\\\\#.*$\")) { output.print(line + \"\\n\"); continue; }\n\n\t\t\t\t\tString[] tokens = line.split(\"\\\\s+\");\n\t\t\t\t\tString locus = tokens[0] + \":\" + tokens[1];\n\t\t\t\t\tif (loci.contains(locus)) { output.print(line + \"\\n\"); continue; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}","commit_id":"0ef50bcae726ff778f4f86bbb5d22549a7edcd5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\t\tprotected int execute() \n\t\t{\n\t\t\tSystem.out.println(\"Validating \" + filename + \"...\");\n\t\t\n\t\t\tVCFReader reader = null;\n\n\t\t\tif (autocorrect) { reader = new VCFReader(VCFHomogenizer.create(filename)); }\n\t\t\telse { reader = new VCFReader(new File(filename)); }\n\n\t\t\tVCFHeader header = reader.getHeader();\n\n\t\t\tDate start_time = new Date();\n\t\t\tint n_records_processed = 0;\n\t\t\twhile(reader.hasNext())\n\t\t\t{\n\t\t\t\tVCFRecord record = reader.next();\n\t\t\t\tif (print) { System.out.println(record.toStringEncoding(header)); }\n\n\t\t\t\tif ((profile) && (n_records_processed % 10000 == 0))\n\t\t\t\t{\n\t\t\t\t\tDate current_time = new Date();\n\t\t\t\t\tlong elapsed = current_time.getTime() - start_time.getTime();\n\t\t\t\t\tSystem.out.printf(\"RUNTIME: %d records processed in %f seconds; %f seconds per record.\\n\",\n\t\t\t\t\t\tn_records_processed,\n\t\t\t\t\t\t(double)elapsed/1000.0,\n\t\t\t\t\t\t((double)elapsed/1000.0)/(double)n_records_processed);\n\t\t\t\t}\n\t\t\t\tn_records_processed += 1;\n\t\t\t}\n\n\t\t\tif (autocorrect) { System.out.println(filename + \" is VALID (after auto-correction).\"); }\n\t\t\telse { System.out.println(filename + \" is VALID.\"); }\n\t\t\t\n\t\t\treturn 0;\n\t\t}","id":98290,"modified_method":"@Override\n\t\tprotected int execute() \n\t\t{\n\t\t\tSystem.out.println(\"Validating \" + filename + \"...\");\n\t\t\n\t\t\tVCFReader reader = null;\n\n\t\t\tif (autocorrect) { reader = new VCFReader(VCFHomogenizer.create(filename)); }\n\t\t\telse { reader = new VCFReader(new File(filename)); }\n\n\t\t\tVCFHeader header = reader.getHeader();\n\n\t\t\tVCFWriter writer = null;\n\t\t\tif (print) \n\t\t\t{ \n\t\t\t\twriter = new VCFWriter(new File(out)); \n\t\t\t\twriter.writeHeader(header);\n\t\t\t}\n\n\t\t\tDate start_time = new Date();\n\t\t\tint n_records_processed = 0;\n\t\t\twhile(reader.hasNext())\n\t\t\t{\n\t\t\t\tVCFRecord record = reader.next();\n\t\t\t\tif (print) { writer.addRecord(record); }\n\n\t\t\t\tif ((profile) && (n_records_processed % 10000 == 0))\n\t\t\t\t{\n\t\t\t\t\tDate current_time = new Date();\n\t\t\t\t\tlong elapsed = current_time.getTime() - start_time.getTime();\n\t\t\t\t\tSystem.out.printf(\"RUNTIME: %d records processed in %f seconds; %f seconds per record.\\n\",\n\t\t\t\t\t\tn_records_processed,\n\t\t\t\t\t\t(double)elapsed/1000.0,\n\t\t\t\t\t\t((double)elapsed/1000.0)/(double)n_records_processed);\n\t\t\t\t}\n\t\t\t\tn_records_processed += 1;\n\t\t\t}\n\n\t\t\tif (print) { writer.close(); }\n\n\t\t\tif (autocorrect) { System.out.println(filename + \" is VALID (after auto-correction).\"); }\n\t\t\telse { System.out.println(filename + \" is VALID.\"); }\n\t\t\t\n\t\t\treturn 0;\n\t\t}","commit_id":"0ef50bcae726ff778f4f86bbb5d22549a7edcd5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\t\tprotected int execute() \n\t\t{\n\t\t\t//System.out.println(\"Loading \" + filename + \"...\");\n\t\t\n\t\t\t/////////////////////////////////\n\t\t\t// All the various concordance counters\n\t\t\n\t\t\tHashMap<String,GenotypeConcordance> individual = new HashMap<String,GenotypeConcordance>();\n\t\t\tHashMap<Long,GenotypeConcordance>   AAF        = new HashMap<Long,GenotypeConcordance>();\n\t\t\tHashMap<Long,GenotypeConcordance>   Qual       = new HashMap<Long,GenotypeConcordance>();\n\n\t\t\t// \n\t\t\t/////////////////////////////////\n\n\t\t\tHashSet<String> sample_mask = new HashSet<String>();\n\t\t\tif (samples_filename != null)\n\t\t\t{\n\t\t\t\tScanner samples_reader = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsamples_reader = new Scanner(new File(samples_filename));\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\twhile(samples_reader.hasNextLine())\n\t\t\t\t{\n\t\t\t\t\tString line = samples_reader.nextLine();\n\t\t\t\t\tline.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n\t\t\t\t\tsample_mask.add(line);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tPrintStream output = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\toutput = new PrintStream(new FileOutputStream(output_filename));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\n\t\t\tVCFReader reader1;\n\t\t\tVCFReader reader2;\n\n\t\t\tif (autocorrect) \n\t\t\t{ \n\t\t\t\treader1 = new VCFReader(VCFHomogenizer.create(filename1)); \n\t\t\t\treader2 = new VCFReader(VCFHomogenizer.create(filename2)); \n\t\t\t}\n\t\t\telse \n\t\t\t{ \n\t\t\t\treader1 = new VCFReader(new File(filename1)); \n\t\t\t\treader2 = new VCFReader(new File(filename2)); \n\t\t\t}\n\t\t\n\t\t\tVCFHeader header1 = reader1.getHeader();\n\t\t\tVCFHeader header2 = reader2.getHeader();\n\n\t\t\tVCFRecord record1 = reader1.next();\n\t\t\tVCFRecord record2 = reader2.next();\n\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif (record1 == null) { break; }\n\t\t\t\tif (record2 == null) { break; }\n\n\n\t\t\t\tInterval interval1 = VCFTool.getIntervalFromRecord(record1);\n\t\t\t\tInterval interval2 = VCFTool.getIntervalFromRecord(record2);\n\n\t\t\t\tint comparison = interval1.compareTo(interval2);\n\n\t\t\t\t//System.out.println(\"DBG: \" + interval1 + \" \" + interval2);\n\t\t\t\t\n\t\t\t\tif (comparison == 0)\n\t\t\t\t{\n\t\t\t\t\t// records match! compute concordance.\n\t\t\t\t\t\n\t\t\t\t\t// (unless one of them is \"filtered\")\n\t\t\t\t\tif (record1.isFiltered() || record2.isFiltered())\n\t\t\t\t\t{\n\t\t\t\t\t\trecord1 = reader1.next();\n\t\t\t\t\t\trecord2 = reader2.next();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tchar ref = record1.getReferenceBase();\n\t\t\t\t\t\n\t\t\t\t\tString[] sample_names1 = record1.getSampleNames();\n\t\t\t\t\tString[] sample_names2 = record2.getSampleNames();\n\n\t\t\t\t\tList<VCFGenotypeRecord> genotypes1 = record1.getVCFGenotypeRecords();\n\t\t\t\t\tList<VCFGenotypeRecord> genotypes2 = record2.getVCFGenotypeRecords();\n\n\t\t\t\t\tMap<String, VCFGenotypeRecord> map2 = new HashMap<String, VCFGenotypeRecord>();\n\t\t\t\t\tfor (int i = 0; i < genotypes2.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap2.put(genotypes2.get(i).getSampleName(), genotypes2.get(i));\n\t\t\t\t\t}\n\n\t\t\t\t\tGenotypeConcordance SNP = new GenotypeConcordance(interval1.toString());\n\n\t\t\t\t\tlong n_ref = 0;\n\t\t\t\t\tlong n_alt = 0;\n\n\t\t\t\t\tfor (int i = 0; i < sample_names1.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((samples_filename != null) &&\n\t\t\t\t\t\t\t(! sample_mask.contains(sample_names1[i])))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tVCFGenotypeRecord rec1 = genotypes1.get(i);\n\t\t\t\t\t\tVCFGenotypeRecord rec2 = map2.get(sample_names1[i]);\n\n\t\t\t\t\t\tif (rec2 == null) { continue; }\n\n\t\t\t\t\t\tLong gq1;\n\t\t\t\t\t\tif (rec1.getFields().get(\"GQ\") != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDouble gq1_double = Double.parseDouble(rec1.getFields().get(\"GQ\"));\n\t\t\t\t\t\t\tgq1 = gq1_double.longValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgq1 = 0L;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLong gq2;\n\t\t\t\t\t\tif (rec2.getFields().get(\"GQ\") != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDouble gq2_double = Double.parseDouble(rec2.getFields().get(\"GQ\"));\n\t\t\t\t\t\t\tgq2 = gq2_double.longValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgq2 = 0L;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tList<VCFGenotypeEncoding> alleles1 = rec1.getAlleles();\n\t\t\t\t\t\tList<VCFGenotypeEncoding> alleles2 = rec2.getAlleles();\n\n\t\t\t\t\t\tString g1 = \"\";\n\t\t\t\t\t\tString g2 = \"\";\n\n\t\t\t\t\t\tfor (int j = 0; j < alleles1.size(); j++) { g1 += alleles1.get(j).getBases(); }\n\t\t\t\t\t\tfor (int j = 0; j < alleles2.size(); j++) { g2 += alleles2.get(j).getBases(); }\n\n\t\t\t\t\t\tchar[] c1 = g1.toCharArray();\n\t\t\t\t\t\tchar[] c2 = g2.toCharArray();\n\n\t\t\t\t\t\tArrays.sort(c1);\n\t\t\t\t\t\tArrays.sort(c2);\n\n\t\t\t\t\t\tg1 = new String(c1);\n\t\t\t\t\t\tg2 = new String(c2);\n\n\t\t\t\t\t\tif (list_genotypes) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tString flag = \"\";\n\t\t\t\t\t\t\tif (! g1.equals(g2)) { flag = \"X\"; }\n\t\t\t\t\t\t\toutput.printf(\"GENOTYPES \" \n\t\t\t\t\t\t\t\t\t\t\t\t+ interval1.toString() \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + sample_names1[i] \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + g1 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + g2 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + gq1 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + gq2 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + flag +  \"\\n\"); \n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((g1.equals(\"..\")) ||\n\t\t\t\t\t\t\t(g2.equals(\"..\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (g1.charAt(0) == ref) { n_ref += 1; } else { n_alt += 1; }\n\t\t\t\t\t\tif (g1.charAt(1) == ref) { n_ref += 1; } else { n_alt += 1; }\n\n\t\t\t\t\t\tif (! individual.containsKey(sample_names1[i])) { individual.put(sample_names1[i], new GenotypeConcordance(sample_names1[i])); }\n\t\t\t\t\t\tif (! Qual.containsKey(gq1)) { Qual.put(gq1, new GenotypeConcordance(Long.toString(gq1))); }\n\n\t\t\t\t\t\tindividual.get(sample_names1[i]).add(ref, g1, g2);\n\t\t\t\t\t\tQual.get(gq1).add(ref, g1, g2);\n\t\t\t\t\t\tSNP.add(ref, g1, g2);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (verbose) \n\t\t\t\t\t{ \n\t\t\t\t\t\toutput.printf(\"SNP \" + SNP.toString()); \n\t\t\t\t\t}\n\n\t\t\t\t\tif (! AAF.containsKey(n_alt)) { AAF.put(n_alt, new GenotypeConcordance(Long.toString(n_alt))); }\n\t\t\t\t\tAAF.get(n_alt).add(SNP);\n\n\t\t\t\t\trecord1 = reader1.next();\n\t\t\t\t\trecord2 = reader2.next();\n\t\t\t\t}\n\t\t\t\telse if (comparison > 0)\n\t\t\t\t{\n\t\t\t\t\t// interval1 is later than interval2.\n\t\t\t\t\trecord2 = reader2.next();\n\t\t\t\t}\n\t\t\t\telse if (comparison < 0)\n\t\t\t\t{\n\t\t\t\t\t// interval2 is later than interval1.\n\t\t\t\t\trecord1 = reader1.next();\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Now output the statistics.\n\t\t\t{\n\t\t\t\tif (verbose)\n\t\t\t\t{\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t\tObject[] individuals = individual.keySet().toArray();\n\t\t\t\t\tfor (int i = 0; i < individuals.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tString ind = (String)individuals[i];\n\t\t\t\t\t\toutput.print(\"INDIVIDUAL \" + individual.get(ind).toString());\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t\tObject[] AAFs = AAF.keySet().toArray();\n\t\t\t\t\tfor (int i = 0; i < AAFs.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tLong aaf = (Long)AAFs[i];\n\t\t\t\t\t\toutput.print(\"AAF \" + AAF.get(aaf).toString());\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t\tObject[] quals = Qual.keySet().toArray();\n\t\t\t\t\tfor (int i = 0; i < quals.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tLong qual = (Long)quals[i];\n\t\t\t\t\t\toutput.print(\"QUAL \" + Qual.get(qual).toString());\n\t\t\t\t\t}\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\tObject[] individuals = individual.keySet().toArray();\n\t\t\t\tfor (int i = 0; i < individuals.length; i++)\n\t\t\t\t{\n\t\t\t\t\tString ind = (String)individuals[i];\n\t\t\t\t\toutput.printf(\"INDIVIDUAL %s %f %d %d\\n\", ind, individual.get(ind).errorRate(), individual.get(ind).total(), individual.get(ind).totalNonHomRef());\n\t\t\t\t}\n\n\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\tObject[] AAFs = AAF.keySet().toArray();\n\t\t\t\tfor (int i = 0; i < AAFs.length; i++)\n\t\t\t\t{\n\t\t\t\t\tLong aaf = (Long)AAFs[i];\n\t\t\t\t\toutput.printf(\"AAF %d %f %d %d\\n\", aaf, AAF.get(aaf).errorRate(), AAF.get(aaf).total(), AAF.get(aaf).totalNonHomRef());\n\t\t\t\t}\n\n\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\tObject[] quals = Qual.keySet().toArray();\n\t\t\t\tfor (int i = 0; i < quals.length; i++)\n\t\t\t\t{\n\t\t\t\t\tLong qual = (Long)quals[i];\n\t\t\t\t\toutput.printf(\"QUAL %d %f %d %d\\n\", qual, Qual.get(qual).errorRate(), Qual.get(qual).total(), Qual.get(qual).totalNonHomRef());\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.flush();\n\t\t\toutput.close();\n\n\n\t\t\treturn 0;\n\t\t}","id":98291,"modified_method":"@Override\n\t\tprotected int execute() \n\t\t{\n\t\t\t//System.out.println(\"Loading \" + filename + \"...\");\n\t\t\n\t\t\t/////////////////////////////////\n\t\t\t// All the various concordance counters\n\t\t\n\t\t\tHashMap<String,GenotypeConcordance> individual = new HashMap<String,GenotypeConcordance>();\n\t\t\tHashMap<Long,GenotypeConcordance>   AAF        = new HashMap<Long,GenotypeConcordance>();\n\t\t\tHashMap<Long,GenotypeConcordance>   Qual       = new HashMap<Long,GenotypeConcordance>();\n\t\t\tHashMap<Long,GenotypeConcordance>   R2         = new HashMap<Long,GenotypeConcordance>();\n\n\t\t\tint shared_ts    = 0;\n\t\t\tint shared_tv    = 0;\n\t\t\tint shared_dbsnp = 0;\n\t\t\tint shared_total = 0;\n\n\t\t\tint unique1_ts    = 0;\n\t\t\tint unique1_tv    = 0;\n\t\t\tint unique1_dbsnp = 0;\n\t\t\tint unique1_total = 0;\n\n\t\t\tint unique2_ts    = 0;\n\t\t\tint unique2_tv    = 0;\n\t\t\tint unique2_dbsnp = 0;\n\t\t\tint unique2_total = 0;\n\n\t\t\t// \n\t\t\t/////////////////////////////////\n\n\t\t\tHashSet<String> sample_mask = new HashSet<String>();\n\t\t\tif (samples_filename != null)\n\t\t\t{\n\t\t\t\tScanner samples_reader = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsamples_reader = new Scanner(new File(samples_filename));\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\twhile(samples_reader.hasNextLine())\n\t\t\t\t{\n\t\t\t\t\tString line = samples_reader.nextLine();\n\t\t\t\t\tline.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n\t\t\t\t\tsample_mask.add(line);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tPrintStream output = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\toutput = new PrintStream(new FileOutputStream(output_filename));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\n\t\t\tVCFReader reader1;\n\t\t\tVCFReader reader2;\n\n\t\t\tif (autocorrect) \n\t\t\t{ \n\t\t\t\treader1 = new VCFReader(VCFHomogenizer.create(filename1)); \n\t\t\t\treader2 = new VCFReader(VCFHomogenizer.create(filename2)); \n\t\t\t}\n\t\t\telse \n\t\t\t{ \n\t\t\t\treader1 = new VCFReader(new File(filename1)); \n\t\t\t\treader2 = new VCFReader(new File(filename2)); \n\t\t\t}\n\t\t\n\t\t\tVCFHeader header1 = reader1.getHeader();\n\t\t\tVCFHeader header2 = reader2.getHeader();\n\n\t\t\tVCFRecord record1 = reader1.next();\n\t\t\tVCFRecord record2 = reader2.next();\n\n\t\t\tint number_sites_unique_to_file1 = 0;\n\t\t\tint number_sites_unique_to_file2 = 0;\n\t\t\tint number_sites_shared          = 0;\n\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif (record1 == null) { break; }\n\t\t\t\tif (record2 == null) { break; }\n\n\n\t\t\t\tInterval interval1 = VCFTool.getIntervalFromRecord(record1);\n\t\t\t\tInterval interval2 = VCFTool.getIntervalFromRecord(record2);\n\n\t\t\t\t//int comparison = interval1.compareTo(interval2);\n\t\t\t\tint comparison = VCFTool.compareIntervals(interval1, interval2);\n\n\t\t\t\t//System.out.println(\"DBG: \" + interval1 + \" \" + interval2 + \" \" + comparison);\n\t\t\t\t\n\t\t\t\tif (comparison == 0)\n\t\t\t\t{\n\t\t\t\t\t// records match! compute concordance.\n\t\t\t\t\t\n\t\t\t\t\t// (unless one of them is \"filtered\")\n\t\t\t\t\tif (record1.isFiltered() || record2.isFiltered())\n\t\t\t\t\t{\n\t\t\t\t\t\trecord1 = reader1.next();\n\t\t\t\t\t\trecord2 = reader2.next();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\tchar ref = record1.getReferenceBase();\n\t\t\t\t\t\n\t\t\t\t\tString[] sample_names1 = record1.getSampleNames();\n\t\t\t\t\tString[] sample_names2 = record2.getSampleNames();\n\n\n\t\t\t\t\tMap<String,String> info1 = record1.getInfoValues();\n\t\t\t\t\tMap<String,String> info2 = record2.getInfoValues();\n\t\t\t\t\tdouble r2_1 = 0;\n\t\t\t\t\tdouble r2_2 = 0;\n\t\t\t\t\tif (info1.containsKey(\"R2\")) { r2_1 = Double.parseDouble(info1.get(\"R2\")); }\n\t\t\t\t\tif (info2.containsKey(\"R2\")) { r2_2 = Double.parseDouble(info2.get(\"R2\")); }\n\n\n\t\t\t\t\tnumber_sites_shared += 1;\n\t\t\t\t\tif (VCFTool.isTransition(record1)) { shared_ts += 1; }\n\t\t\t\t\telse { shared_tv += 1; }\n\t\t\t\t\tif ((info1.get(\"DB\") != null) && (Integer.parseInt(info1.get(\"DB\")) == 1)) { shared_dbsnp += 1; }\n\t\t\t\t\tshared_total += 1;\n\n\n\t\t\t\t\tList<VCFGenotypeRecord> genotypes1 = record1.getVCFGenotypeRecords();\n\t\t\t\t\tList<VCFGenotypeRecord> genotypes2 = record2.getVCFGenotypeRecords();\n\n\t\t\t\t\tMap<String, VCFGenotypeRecord> map2 = new HashMap<String, VCFGenotypeRecord>();\n\t\t\t\t\tfor (int i = 0; i < genotypes2.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap2.put(genotypes2.get(i).getSampleName(), genotypes2.get(i));\n\t\t\t\t\t}\n\n\t\t\t\t\tGenotypeConcordance SNP = new GenotypeConcordance(interval1.toString());\n\n\t\t\t\t\tlong n_ref = 0;\n\t\t\t\t\tlong n_alt = 0;\n\n\t\t\t\t\tfor (int i = 0; i < sample_names1.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((samples_filename != null) &&\n\t\t\t\t\t\t\t(! sample_mask.contains(sample_names1[i])))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tVCFGenotypeRecord rec1 = genotypes1.get(i);\n\t\t\t\t\t\tVCFGenotypeRecord rec2 = map2.get(sample_names1[i]);\n\n\t\t\t\t\t\tif (rec2 == null) { continue; }\n\n\t\t\t\t\t\tLong gq1;\n\t\t\t\t\t\tif (rec1.getFields().get(\"GQ\") != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDouble gq1_double = Double.parseDouble(rec1.getFields().get(\"GQ\"));\n\t\t\t\t\t\t\tgq1 = gq1_double.longValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgq1 = 0L;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLong gq2;\n\t\t\t\t\t\tif (rec2.getFields().get(\"GQ\") != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDouble gq2_double = Double.parseDouble(rec2.getFields().get(\"GQ\"));\n\t\t\t\t\t\t\tgq2 = gq2_double.longValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgq2 = 0L;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tList<VCFGenotypeEncoding> alleles1 = rec1.getAlleles();\n\t\t\t\t\t\tList<VCFGenotypeEncoding> alleles2 = rec2.getAlleles();\n\n\t\t\t\t\t\tString g1 = \"\";\n\t\t\t\t\t\tString g2 = \"\";\n\n\t\t\t\t\t\tfor (int j = 0; j < alleles1.size(); j++) { g1 += alleles1.get(j).getBases(); }\n\t\t\t\t\t\tfor (int j = 0; j < alleles2.size(); j++) { g2 += alleles2.get(j).getBases(); }\n\n\t\t\t\t\t\tchar[] c1 = g1.toCharArray();\n\t\t\t\t\t\tchar[] c2 = g2.toCharArray();\n\n\t\t\t\t\t\tArrays.sort(c1);\n\t\t\t\t\t\tArrays.sort(c2);\n\n\t\t\t\t\t\tg1 = new String(c1);\n\t\t\t\t\t\tg2 = new String(c2);\n\n\t\t\t\t\t\tif (list_genotypes) \n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tString flag = \"\";\n\t\t\t\t\t\t\tif (! g1.equals(g2)) { flag = \"X\"; }\n\t\t\t\t\t\t\toutput.printf(\"GENOTYPES \" \n\t\t\t\t\t\t\t\t\t\t\t\t+ interval1.toString() \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + sample_names1[i] \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + g1 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + g2 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + gq1 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + gq2 \n\t\t\t\t\t\t\t\t\t\t\t\t+ \" \" + flag +  \"\\n\"); \n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((g1.equals(\"..\")) ||\n\t\t\t\t\t\t\t(g2.equals(\"..\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (g1.charAt(0) == ref) { n_ref += 1; } else { n_alt += 1; }\n\t\t\t\t\t\tif (g1.charAt(1) == ref) { n_ref += 1; } else { n_alt += 1; }\n\n\t\t\t\t\t\tif (! individual.containsKey(sample_names1[i])) { individual.put(sample_names1[i], new GenotypeConcordance(sample_names1[i])); }\n\t\t\t\t\t\tif (! Qual.containsKey(gq1)) { Qual.put(gq1, new GenotypeConcordance(Long.toString(gq1))); }\n\n\t\t\t\t\t\tindividual.get(sample_names1[i]).add(ref, g1, g2);\n\t\t\t\t\t\tQual.get(gq1).add(ref, g1, g2);\n\t\t\t\t\t\tSNP.add(ref, g1, g2);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (verbose) \n\t\t\t\t\t{ \n\t\t\t\t\t\t//output.printf(\"SNP \" + SNP.toString()); \n\t\t\t\t\t\toutput.printf(\"SNP \" + SNP.toLine()); \n\t\t\t\t\t}\n\n\t\t\t\t\tif (! AAF.containsKey(n_alt)) { AAF.put(n_alt, new GenotypeConcordance(Long.toString(n_alt))); }\n\t\t\t\t\tAAF.get(n_alt).add(SNP);\n\n\t\t\t\t\tlong r2_index = (long)(r2_1 / r2_bin_size);\n\t\t\t\t\tif (! R2.containsKey(r2_index)) { R2.put(r2_index, new GenotypeConcordance(Double.toString(r2_1))); }\n\t\t\t\t\tR2.get(r2_index).add(SNP);\n\n\t\t\t\t\t//System.out.printf(\"DBG: %f %f\\n\", r2_1, r2_2);\n\t\t\t\t\t//System.out.printf(\"DBG: %f %d %s\\n\", r2_1, r2_index, SNP.toString());\n\n\t\t\t\t\trecord1 = reader1.next();\n\t\t\t\t\trecord2 = reader2.next();\n\t\t\t\t}\n\t\t\t\telse if (comparison > 0)\n\t\t\t\t{\n\t\t\t\t\tif (record2.isFiltered()) { record2 = reader2.next(); continue; }\n\n\t\t\t\t\t// interval1 is later than interval2.\n\t\t\t\t\tMap<String,String> info2 = record2.getInfoValues();\n\t\t\t\t\tnumber_sites_unique_to_file2 += 1;\n\t\t\t\t\tif (VCFTool.isTransition(record2)) { unique2_ts += 1; }\n\t\t\t\t\telse { unique2_tv += 1; }\n\t\t\t\t\tif ((info2.get(\"DB\") != null) && (Integer.parseInt(info2.get(\"DB\")) == 1)) { unique2_dbsnp += 1; }\n\t\t\t\t\tunique2_total += 1;\n\n\t\t\t\t\t//if (verbose) { output.printf(\"DBG: skipping %s\\n\", record2.toStringEncoding(header2)); }\n\n\t\t\t\t\trecord2 = reader2.next();\n\t\t\t\t}\n\t\t\t\telse if (comparison < 0)\n\t\t\t\t{\n\t\t\t\t\tif (record1.isFiltered()) { record1 = reader1.next(); continue; }\n\n\t\t\t\t\t// interval2 is later than interval1.\n\t\t\t\t\tMap<String,String> info1 = record1.getInfoValues();\n\t\t\t\t\tnumber_sites_unique_to_file1 += 1;\n\t\t\t\t\tif (VCFTool.isTransition(record1)) { unique1_ts += 1; }\n\t\t\t\t\telse { unique1_tv += 1; }\n\t\t\t\t\tif ((info1.get(\"DB\") != null) && (Integer.parseInt(info1.get(\"DB\")) == 1)) { unique1_dbsnp += 1; }\n\t\t\t\t\tunique1_total += 1;\n\n\t\t\t\t\t//if (verbose) { output.printf(\"DBG: skipping %s\\n\", record1.toStringEncoding(header1)); }\n\n\t\t\t\t\trecord1 = reader1.next();\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// Now output the statistics.\n\t\t\t\tif (verbose)\n\t\t\t\t{\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t\tObject[] individuals = individual.keySet().toArray();\n\t\t\t\t\tfor (int i = 0; i < individuals.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tString ind = (String)individuals[i];\n\t\t\t\t\t\toutput.print(\"INDIVIDUAL \" + individual.get(ind).toString());\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t\tObject[] AAFs = AAF.keySet().toArray();\n\t\t\t\t\tfor (int i = 0; i < AAFs.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tLong aaf = (Long)AAFs[i];\n\t\t\t\t\t\toutput.print(\"AAF \" + AAF.get(aaf).toString());\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t\tObject[] quals = Qual.keySet().toArray();\n\t\t\t\t\tfor (int i = 0; i < quals.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tLong qual = (Long)quals[i];\n\t\t\t\t\t\toutput.print(\"QUAL \" + Qual.get(qual).toString());\n\t\t\t\t\t}\n\t\t\t\t\toutput.printf(\"\\n\");\n\n\t\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\t\tObject[] R2s = R2.keySet().toArray();\n\t\t\t\t\tfor (int i = 0; i < AAFs.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tLong r2 = (Long)R2s[i];\n\t\t\t\t\t\toutput.print(\"R2 \" + R2.get(r2).toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toutput.printf(\"Number of sites shared          : %d %f %f\\n\", number_sites_shared, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double)shared_ts/(double)shared_tv, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double)shared_dbsnp/(double)(shared_ts+shared_tv));\n\n\t\t\t\toutput.printf(\"Number of sites unique to %s: %d %f %f\\n\", filename1, number_sites_unique_to_file1, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double)unique1_ts/(double)unique1_tv, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double)unique1_dbsnp/(double)(unique1_ts+unique1_tv));\n\n\t\t\t\toutput.printf(\"Number of sites unique to %s: %d %f %f\\n\", filename2, number_sites_unique_to_file2, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double)unique2_ts/(double)unique2_tv, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double)unique2_dbsnp/(double)(unique2_ts+unique2_tv));\n\n\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\tObject[] individuals = individual.keySet().toArray();\n\t\t\t\tfor (int i = 0; i < individuals.length; i++)\n\t\t\t\t{\n\t\t\t\t\tString ind = (String)individuals[i];\n\t\t\t\t\toutput.printf(\"INDIVIDUAL %s %f %d %d\\n\", ind, individual.get(ind).errorRate(), individual.get(ind).total(), individual.get(ind).totalNonHomRef());\n\t\t\t\t}\n\n\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\tObject[] AAFs = AAF.keySet().toArray();\n\t\t\t\tfor (int i = 0; i < AAFs.length; i++)\n\t\t\t\t{\n\t\t\t\t\tLong aaf = (Long)AAFs[i];\n\t\t\t\t\toutput.printf(\"AAF %d %f %d %d %f\\n\", aaf, AAF.get(aaf).errorRate(), AAF.get(aaf).total(), AAF.get(aaf).totalNonHomRef(), AAF.get(aaf).hetErrorRate());\n\t\t\t\t}\n\n\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\tObject[] quals = Qual.keySet().toArray();\n\t\t\t\tfor (int i = 0; i < quals.length; i++)\n\t\t\t\t{\n\t\t\t\t\tLong qual = (Long)quals[i];\n\t\t\t\t\toutput.printf(\"QUAL %d %f %d %d\\n\", qual, Qual.get(qual).errorRate(), Qual.get(qual).total(), Qual.get(qual).totalNonHomRef());\n\t\t\t\t}\n\n\t\t\t\toutput.printf(\"\\n\");\n\t\t\t\tObject[] R2s = R2.keySet().toArray();\n\t\t\t\tfor (int i = 0; i < R2s.length; i++)\n\t\t\t\t{\n\t\t\t\t\tLong r2 = (Long)R2s[i];\n\t\t\t\t\toutput.printf(\"R2 %f %f %d %d\\n\", (double)r2 * r2_bin_size, R2.get(r2).errorRate(), R2.get(r2).total(), R2.get(r2).totalNonHomRef());\n\t\t\t\t}\n\n\t\t\toutput.flush();\n\t\t\toutput.close();\n\n\n\t\t\treturn 0;\n\t\t}","commit_id":"0ef50bcae726ff778f4f86bbb5d22549a7edcd5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n  public boolean canApply(Configuration c, String t) {\n    if (t.startsWith(\"L\") || t.startsWith(\"R\")) {\n      String label = t.substring(2, t.length() - 1);\n      int h = t.startsWith(\"L\") ? c.getStack(0) : c.getStack(1);\n      if (h < 0) return false;\n      if (h == 0 && !label.equals(rootLabel)) return false;\n      if (h > 0 && label.equals(rootLabel)) return false;\n    }\n\n    int nStack = c.getStackSize();\n    int nBuffer = c.getBufferSize();\n\n    if (t.startsWith(\"L\"))\n      return nStack > 2;\n    else if (t.startsWith(\"R\")) {\n      if (singleRoot)\n        return (nStack > 2) || (nStack == 2 && nBuffer == 0);\n      else\n        return nStack >= 2;\n    } else\n      return nBuffer > 0;\n  }","id":98292,"modified_method":"@Override\n  public boolean canApply(Configuration c, String t) {\n    if (t.startsWith(\"L\") || t.startsWith(\"R\")) {\n      String label = t.substring(2, t.length() - 1);\n      int h = t.startsWith(\"L\") ? c.getStack(0) : c.getStack(1);\n      if (h < 0) return false;\n      if (h == 0 && !label.equals(rootLabel)) return false;\n      //if (h > 0 && label.equals(rootLabel)) return false;\n    }\n\n    int nStack = c.getStackSize();\n    int nBuffer = c.getBufferSize();\n\n    if (t.startsWith(\"L\"))\n      return nStack > 2;\n    else if (t.startsWith(\"R\")) {\n      if (singleRoot)\n        return (nStack > 2) || (nStack == 2 && nBuffer == 0);\n      else\n        return nStack >= 2;\n    } else\n      return nBuffer > 0;\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void printParameters() {\n    System.err.printf(\"language = %s%n\", language);\n    System.err.printf(\"trainingThreads = %d%n\", trainingThreads);\n    System.err.printf(\"wordCutOff = %d%n\", wordCutOff);\n    System.err.printf(\"initRange = %.2g%n\", initRange);\n    System.err.printf(\"maxIter = %d%n\", maxIter);\n    System.err.printf(\"batchSize = %d%n\", batchSize);\n    System.err.printf(\"adaEps = %.2g%n\", adaEps);\n    System.err.printf(\"adaAlpha = %.2g%n\", adaAlpha);\n    System.err.printf(\"regParameter = %.2g%n\", regParameter);\n    System.err.printf(\"dropProb = %.2g%n\", dropProb);\n    System.err.printf(\"hiddenSize = %d%n\", hiddenSize);\n    System.err.printf(\"embeddingSize = %d%n\", embeddingSize);\n    System.err.printf(\"numPreComputed = %d%n\", numPreComputed);\n    System.err.printf(\"evalPerIter = %d%n\", evalPerIter);\n    System.err.printf(\"clearGradientsPerIter = %d%n\", clearGradientsPerIter);\n    System.err.printf(\"saveItermediate = %b%n\", saveIntermediate);\n  }","id":98293,"modified_method":"public void printParameters() {\n    System.err.printf(\"language = %s%n\", language);\n    System.err.printf(\"trainingThreads = %d%n\", trainingThreads);\n    System.err.printf(\"wordCutOff = %d%n\", wordCutOff);\n    System.err.printf(\"initRange = %.2g%n\", initRange);\n    System.err.printf(\"maxIter = %d%n\", maxIter);\n    System.err.printf(\"batchSize = %d%n\", batchSize);\n    System.err.printf(\"adaEps = %.2g%n\", adaEps);\n    System.err.printf(\"adaAlpha = %.2g%n\", adaAlpha);\n    System.err.printf(\"regParameter = %.2g%n\", regParameter);\n    System.err.printf(\"dropProb = %.2g%n\", dropProb);\n    System.err.printf(\"hiddenSize = %d%n\", hiddenSize);\n    System.err.printf(\"embeddingSize = %d%n\", embeddingSize);\n    System.err.printf(\"numPreComputed = %d%n\", numPreComputed);\n    System.err.printf(\"evalPerIter = %d%n\", evalPerIter);\n    System.err.printf(\"clearGradientsPerIter = %d%n\", clearGradientsPerIter);\n    System.err.printf(\"saveItermediate = %b%n\", saveIntermediate);\n    System.err.printf(\"unlabeled = %b%n\", unlabeled);\n    System.err.printf(\"cPOS = %b%n\", cPOS);\n    System.err.printf(\"noPunc = %b%n\", noPunc);\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void setProperties(Properties props) {\n    trainingThreads = PropertiesUtils.getInt(props, \"trainingThreads\", trainingThreads);\n    wordCutOff = PropertiesUtils.getInt(props, \"wordCutOff\", wordCutOff);\n    initRange = PropertiesUtils.getDouble(props, \"initRange\", initRange);\n    maxIter = PropertiesUtils.getInt(props, \"maxIter\", maxIter);\n    batchSize = PropertiesUtils.getInt(props, \"batchSize\", batchSize);\n    adaEps = PropertiesUtils.getDouble(props, \"adaEps\", adaEps);\n    adaAlpha = PropertiesUtils.getDouble(props, \"adaAlpha\", adaAlpha);\n    regParameter = PropertiesUtils.getDouble(props, \"regParameter\", regParameter);\n    dropProb = PropertiesUtils.getDouble(props, \"dropProb\", dropProb);\n    hiddenSize = PropertiesUtils.getInt(props, \"hiddenSize\", hiddenSize);\n    embeddingSize = PropertiesUtils.getInt(props, \"embeddingSize\", embeddingSize);\n    numPreComputed = PropertiesUtils.getInt(props, \"numPreComputed\", numPreComputed);\n    evalPerIter = PropertiesUtils.getInt(props, \"evalPerIter\", evalPerIter);\n    clearGradientsPerIter = PropertiesUtils.getInt(props, \"clearGradientsPerIter\", clearGradientsPerIter);\n    saveIntermediate = PropertiesUtils.getBool(props, \"saveIntermediate\", saveIntermediate);\n\n    // Runtime parsing options\n    sentenceDelimiter = PropertiesUtils.getString(props, \"sentenceDelimiter\", sentenceDelimiter);\n    tagger = PropertiesUtils.getString(props, \"tagger.model\", tagger);\n\n    String escaperClass = props.getProperty(\"escaper\");\n    escaper = escaperClass != null ? ReflectionLoading.loadByReflection(escaperClass) : null;\n\n    // Language options\n    language = props.containsKey(\"language\")\n               ? getLanguage(props.getProperty(\"language\"))\n               : language;\n    tlp = Languages.getLanguageParams(language).treebankLanguagePack();\n  }","id":98294,"modified_method":"private void setProperties(Properties props) {\n    trainingThreads = PropertiesUtils.getInt(props, \"trainingThreads\", trainingThreads);\n    wordCutOff = PropertiesUtils.getInt(props, \"wordCutOff\", wordCutOff);\n    initRange = PropertiesUtils.getDouble(props, \"initRange\", initRange);\n    maxIter = PropertiesUtils.getInt(props, \"maxIter\", maxIter);\n    batchSize = PropertiesUtils.getInt(props, \"batchSize\", batchSize);\n    adaEps = PropertiesUtils.getDouble(props, \"adaEps\", adaEps);\n    adaAlpha = PropertiesUtils.getDouble(props, \"adaAlpha\", adaAlpha);\n    regParameter = PropertiesUtils.getDouble(props, \"regParameter\", regParameter);\n    dropProb = PropertiesUtils.getDouble(props, \"dropProb\", dropProb);\n    hiddenSize = PropertiesUtils.getInt(props, \"hiddenSize\", hiddenSize);\n    embeddingSize = PropertiesUtils.getInt(props, \"embeddingSize\", embeddingSize);\n    numPreComputed = PropertiesUtils.getInt(props, \"numPreComputed\", numPreComputed);\n    evalPerIter = PropertiesUtils.getInt(props, \"evalPerIter\", evalPerIter);\n    clearGradientsPerIter = PropertiesUtils.getInt(props, \"clearGradientsPerIter\", clearGradientsPerIter);\n    saveIntermediate = PropertiesUtils.getBool(props, \"saveIntermediate\", saveIntermediate);\n    unlabeled = PropertiesUtils.getBool(props, \"unlabeled\", unlabeled);\n    cPOS = PropertiesUtils.getBool(props, \"cPOS\", cPOS);\n    noPunc = PropertiesUtils.getBool(props, \"noPunc\", noPunc);\n\n    // Runtime parsing options\n    sentenceDelimiter = PropertiesUtils.getString(props, \"sentenceDelimiter\", sentenceDelimiter);\n    tagger = PropertiesUtils.getString(props, \"tagger.model\", tagger);\n\n    String escaperClass = props.getProperty(\"escaper\");\n    escaper = escaperClass != null ? ReflectionLoading.loadByReflection(escaperClass) : null;\n\n    // Language options\n    language = props.containsKey(\"language\")\n               ? getLanguage(props.getProperty(\"language\"))\n               : language;\n    tlp = Languages.getLanguageParams(language).treebankLanguagePack();\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Run the parser in the modelFile on a testFile and perhaps save output.\n   *\n   *  @param testFile File to parse. In CoNLL-X format. Assumed to have gold answers included.\n   *  @param outFile File to write results to in CoNLL-X format.  If null, no output is written\n   *  @return The LAS score on the dataset\n   */\n  public double testCoNLL(String testFile, String outFile) {\n    System.err.println(\"Test File: \" + testFile);\n    Timing timer = new Timing();\n    List<CoreMap> testSents = new ArrayList<>();\n    List<DependencyTree> testTrees = new ArrayList<DependencyTree>();\n    Util.loadConllFile(testFile, testSents, testTrees);\n    // count how much to parse\n    int numWords = 0;\n    int numSentences = 0;\n    for (CoreMap testSent : testSents) {\n      numSentences += 1;\n      numWords += testSent.get(CoreAnnotations.TokensAnnotation.class).size();\n    }\n\n    List<DependencyTree> predicted = testSents.stream().map(this::predictInner).collect(toList());\n    Map<String, Double> result = system.evaluate(testSents, predicted, testTrees);\n    \n    double uasNoPunc = result.get(\"UASwoPunc\");\n    double lasNoPunc = result.get(\"LASwoPunc\");\n    System.err.printf(\"UAS = %.4f%n\", uasNoPunc);\n    System.err.printf(\"LAS = %.4f%n\", lasNoPunc);\n\n    long millis = timer.stop();\n    double wordspersec = numWords / (((double) millis) / 1000);\n    double sentspersec = numSentences / (((double) millis) / 1000);\n    System.err.printf(\"%s parsed %d words in %d sentences in %.1fs at %.1f w/s, %.1f sent/s.%n\",\n            StringUtils.getShortClassName(this), numWords, numSentences, millis / 1000.0, wordspersec, sentspersec);\n\n    if (outFile != null) {\n        Util.writeConllFile(outFile, testSents, predicted);\n    }\n    return lasNoPunc;\n  }","id":98295,"modified_method":"/** Run the parser in the modelFile on a testFile and perhaps save output.\n   *\n   *  @param testFile File to parse. In CoNLL-X format. Assumed to have gold answers included.\n   *  @param outFile File to write results to in CoNLL-X format.  If null, no output is written\n   *  @return The LAS score on the dataset\n   */\n  public double testCoNLL(String testFile, String outFile) {\n    System.err.println(\"Test File: \" + testFile);\n    Timing timer = new Timing();\n    List<CoreMap> testSents = new ArrayList<>();\n    List<DependencyTree> testTrees = new ArrayList<DependencyTree>();\n    Util.loadConllFile(testFile, testSents, testTrees, config.unlabeled, config.cPOS);\n\n    // count how much to parse\n    int numWords = 0;\n    int numOOVWords = 0;\n    int numSentences = 0;\n    for (CoreMap testSent : testSents) {\n      numSentences += 1;\n      List<CoreLabel> tokens = testSent.get(CoreAnnotations.TokensAnnotation.class);\n      for (int k = 0; k < tokens.size(); ++ k) {  \n        String word = tokens.get(k).word();\n        numWords += 1;\n        if (!wordIDs.containsKey(word))\n          numOOVWords += 1;\n      }\n    }\n    System.err.printf(\"OOV Words: %d / %d = %.2f%%\\n\", numOOVWords, numWords, numOOVWords * 100.0 / numWords);\n\n    List<DependencyTree> predicted = testSents.stream().map(this::predictInner).collect(toList());\n    Map<String, Double> result = system.evaluate(testSents, predicted, testTrees);\n    \n    double uas = config.noPunc ? result.get(\"UASnoPunc\") : result.get(\"UAS\");\n    double las = config.noPunc ? result.get(\"LASnoPunc\") : result.get(\"LAS\");\n    System.err.printf(\"UAS = %.4f%n\", uas);\n    System.err.printf(\"LAS = %.4f%n\", las);\n\n    long millis = timer.stop();\n    double wordspersec = numWords / (((double) millis) / 1000);\n    double sentspersec = numSentences / (((double) millis) / 1000);\n    System.err.printf(\"%s parsed %d words in %d sentences in %.1fs at %.1f w/s, %.1f sent/s.%n\",\n            StringUtils.getShortClassName(this), numWords, numSentences, millis / 1000.0, wordspersec, sentspersec);\n\n    if (outFile != null) {\n        Util.writeConllFile(outFile, testSents, predicted);\n    }\n    return las;\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void loadModelFile(String modelFile, boolean verbose) {\n    Timing t = new Timing();\n    try {\n\n      System.err.println(\"Loading depparse model file: \" + modelFile + \" ... \");\n      String s;\n      BufferedReader input = IOUtils.readerFromString(modelFile);\n\n      int nDict, nPOS, nLabel;\n      int eSize, hSize, nTokens, nPreComputed;\n      nDict = nPOS = nLabel = eSize = hSize = nTokens = nPreComputed = 0;\n\n      for (int k = 0; k < 7; ++k) {\n        s = input.readLine();\n        if (verbose) {\n          System.err.println(s);\n        }\n        int number = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n        switch (k) {\n          case 0:\n            nDict = number;\n            break;\n          case 1:\n            nPOS = number;\n            break;\n          case 2:\n            nLabel = number;\n            break;\n          case 3:\n            eSize = number;\n            break;\n          case 4:\n            hSize = number;\n            break;\n          case 5:\n            nTokens = number;\n            break;\n          case 6:\n            nPreComputed = number;\n            break;\n          default:\n            break;\n        }\n      }\n\n\n      knownWords = new ArrayList<String>();\n      knownPos = new ArrayList<String>();\n      knownLabels = new ArrayList<String>();\n      double[][] E = new double[nDict + nPOS + nLabel][eSize];\n      String[] splits;\n      int index = 0;\n\n      for (int k = 0; k < nDict; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        knownWords.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      for (int k = 0; k < nPOS; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        knownPos.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      for (int k = 0; k < nLabel; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        knownLabels.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      generateIDs();\n\n      double[][] W1 = new double[hSize][eSize * nTokens];\n      for (int j = 0; j < W1[0].length; ++j) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (int i = 0; i < W1.length; ++i)\n          W1[i][j] = Double.parseDouble(splits[i]);\n      }\n\n      double[] b1 = new double[hSize];\n      s = input.readLine();\n      splits = s.split(\" \");\n      for (int i = 0; i < b1.length; ++i)\n        b1[i] = Double.parseDouble(splits[i]);\n\n      double[][] W2 = new double[nLabel * 2 - 1][hSize];\n      for (int j = 0; j < W2[0].length; ++j) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (int i = 0; i < W2.length; ++i)\n          W2[i][j] = Double.parseDouble(splits[i]);\n      }\n\n      preComputed = new ArrayList<Integer>();\n      while (preComputed.size() < nPreComputed) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (String split : splits) {\n          preComputed.add(Integer.parseInt(split));\n        }\n      }\n      input.close();\n      classifier = new Classifier(config, E, W1, b1, W2, preComputed);\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n\n    // initialize the loaded parser\n    initialize(verbose);\n    t.done(\"Initializing dependency parser\");\n  }","id":98296,"modified_method":"private void loadModelFile(String modelFile, boolean verbose) {\n    Timing t = new Timing();\n    try {\n\n      System.err.println(\"Loading depparse model file: \" + modelFile + \" ... \");\n      String s;\n      BufferedReader input = IOUtils.readerFromString(modelFile);\n\n      s = input.readLine();\n      int nDict = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n      s = input.readLine();\n      int nPOS = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n      s = input.readLine();\n      int nLabel = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n      s = input.readLine();\n      int eSize = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n      s = input.readLine();\n      int hSize = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n      s = input.readLine();\n      int nTokens = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n      s = input.readLine();\n      int nPreComputed = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n\n      knownWords = new ArrayList<String>();\n      knownPos = new ArrayList<String>();\n      knownLabels = new ArrayList<String>();\n      double[][] E = new double[nDict + nPOS + nLabel][eSize];\n      String[] splits;\n      int index = 0;\n\n      for (int k = 0; k < nDict; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        knownWords.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      for (int k = 0; k < nPOS; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        knownPos.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      for (int k = 0; k < nLabel; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        knownLabels.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      generateIDs();\n\n      double[][] W1 = new double[hSize][eSize * nTokens];\n      for (int j = 0; j < W1[0].length; ++j) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (int i = 0; i < W1.length; ++i)\n          W1[i][j] = Double.parseDouble(splits[i]);\n      }\n\n      double[] b1 = new double[hSize];\n      s = input.readLine();\n      splits = s.split(\" \");\n      for (int i = 0; i < b1.length; ++i)\n        b1[i] = Double.parseDouble(splits[i]);\n\n      double[][] W2 = new double[nLabel * 2 - 1][hSize];\n      for (int j = 0; j < W2[0].length; ++j) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (int i = 0; i < W2.length; ++i)\n          W2[i][j] = Double.parseDouble(splits[i]);\n      }\n\n      preComputed = new ArrayList<Integer>();\n      while (preComputed.size() < nPreComputed) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (String split : splits) {\n          preComputed.add(Integer.parseInt(split));\n        }\n      }\n      input.close();\n      classifier = new Classifier(config, E, W1, b1, W2, preComputed);\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n\n    // initialize the loaded parser\n    initialize(verbose);\n    t.done(\"Initializing dependency parser\");\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Prepare a classifier for training with the given dataset.\n   */\n  private void setupClassifierForTraining(List<CoreMap> trainSents, List<DependencyTree> trainTrees, String embedFile) {\n    double[][] E = new double[knownWords.size() + knownPos.size() + knownLabels.size()][config.embeddingSize];\n    double[][] W1 = new double[config.hiddenSize][config.embeddingSize * config.numTokens];\n    double[] b1 = new double[config.hiddenSize];\n    double[][] W2 = new double[knownLabels.size() * 2 - 1][config.hiddenSize];\n\n    // Randomly initialize weight matrices / vectors\n    Random random = Util.getRandom();\n    for (int i = 0; i < W1.length; ++i)\n      for (int j = 0; j < W1[i].length; ++j)\n        W1[i][j] = random.nextDouble() * 2 * config.initRange - config.initRange;\n\n    for (int i = 0; i < b1.length; ++i)\n      b1[i] = random.nextDouble() * 2 * config.initRange - config.initRange;\n\n    for (int i = 0; i < W2.length; ++i)\n      for (int j = 0; j < W2[i].length; ++j)\n        W2[i][j] = random.nextDouble() * 2 * config.initRange - config.initRange;\n\n    // Read embeddings into `embedID`, `embeddings`\n    readEmbedFile(embedFile);\n\n    // Try to match loaded embeddings with words in dictionary\n    int foundEmbed = 0;\n    for (int i = 0; i < E.length; ++i) {\n      int index = -1;\n      if (i < knownWords.size()) {\n        String str = knownWords.get(i);\n        //NOTE: exact match first, and then try lower case..\n        if (embedID.containsKey(str)) index = embedID.get(str);\n        else if (embedID.containsKey(str.toLowerCase())) index = embedID.get(str.toLowerCase());\n      }\n\n      if (index >= 0) {\n        ++foundEmbed;\n        for (int j = 0; j < E[i].length; ++j)\n          E[i][j] = embeddings[index][j];\n      } else {\n        for (int j = 0; j < E[i].length; ++j)\n          E[i][j] = random.nextDouble() * config.initRange * 2 - config.initRange;\n      }\n    }\n    System.err.println(\"Found embeddings: \" + foundEmbed + \" / \" + knownWords.size());\n\n    Dataset trainSet = genTrainExamples(trainSents, trainTrees);\n    classifier = new Classifier(config, trainSet, E, W1, b1, W2, preComputed);\n  }","id":98297,"modified_method":"/**\n   * Prepare a classifier for training with the given dataset.\n   */\n  private void setupClassifierForTraining(List<CoreMap> trainSents, List<DependencyTree> trainTrees, String embedFile, String preModel) {\n    double[][] E = new double[knownWords.size() + knownPos.size() + knownLabels.size()][config.embeddingSize];\n    double[][] W1 = new double[config.hiddenSize][config.embeddingSize * config.numTokens];\n    double[] b1 = new double[config.hiddenSize];\n    double[][] W2 = new double[system.numTransitions()][config.hiddenSize];\n\n    // Randomly initialize weight matrices / vectors\n    Random random = Util.getRandom();\n    for (int i = 0; i < W1.length; ++i)\n      for (int j = 0; j < W1[i].length; ++j)\n        W1[i][j] = random.nextDouble() * 2 * config.initRange - config.initRange;\n\n    for (int i = 0; i < b1.length; ++i)\n      b1[i] = random.nextDouble() * 2 * config.initRange - config.initRange;\n\n    for (int i = 0; i < W2.length; ++i)\n      for (int j = 0; j < W2[i].length; ++j)\n        W2[i][j] = random.nextDouble() * 2 * config.initRange - config.initRange;\n\n    // Read embeddings into `embedID`, `embeddings`\n     Map<String, Integer> embedID = new HashMap<String, Integer>();\n     double[][] embeddings = readEmbedFile(embedFile, embedID);\n\n    // Try to match loaded embeddings with words in dictionary\n    int foundEmbed = 0;\n    for (int i = 0; i < E.length; ++i) {\n      int index = -1;\n      if (i < knownWords.size()) {\n        String str = knownWords.get(i);\n        //NOTE: exact match first, and then try lower case..\n        if (embedID.containsKey(str)) index = embedID.get(str);\n        else if (embedID.containsKey(str.toLowerCase())) index = embedID.get(str.toLowerCase());\n      }\n      if (index >= 0) {\n        ++foundEmbed;\n        for (int j = 0; j < E[i].length; ++j)\n          E[i][j] = embeddings[index][j];\n      } else {\n        for (int j = 0; j < E[i].length; ++j)\n          //E[i][j] = random.nextDouble() * config.initRange * 2 - config.initRange;\n          //E[i][j] = random.nextDouble() * 0.2 - 0.1;\n          //E[i][j] = random.nextGaussian() * Math.sqrt(0.1);\n          E[i][j] = random.nextDouble() * 0.02 - 0.01;\n      }\n    }\n    System.err.println(\"Found embeddings: \" + foundEmbed + \" / \" + knownWords.size());\n\n    if (preModel != null) {\n        try {\n          System.err.println(\"Loading pre-trained model file: \" + preModel + \" ... \");\n          String s;\n          BufferedReader input = IOUtils.readerFromString(preModel);\n\n          s = input.readLine();\n          int nDict = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n          s = input.readLine();\n          int nPOS = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n          s = input.readLine();\n          int nLabel = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n          s = input.readLine();\n          int eSize = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n          s = input.readLine();\n          int hSize = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n          s = input.readLine();\n          int nTokens = Integer.parseInt(s.substring(s.indexOf('=') + 1));\n          s = input.readLine();\n\n          String[] splits;\n          for (int k = 0; k < nDict; ++k) {\n            s = input.readLine();\n            splits = s.split(\" \");\n            if (wordIDs.containsKey(splits[0]) && eSize == config.embeddingSize) {\n              int index = getWordID(splits[0]);\n              for (int i = 0; i < eSize; ++i)\n                E[index][i] = Double.parseDouble(splits[i + 1]);\n            }\n          }\n\n          for (int k = 0; k < nPOS; ++k) {\n            s = input.readLine();\n            splits = s.split(\" \");\n            if (posIDs.containsKey(splits[0]) && eSize == config.embeddingSize) {\n              int index = getPosID(splits[0]);\n              for (int i = 0; i < eSize; ++i)\n                E[index][i] = Double.parseDouble(splits[i + 1]);\n            }\n          }\n\n          for (int k = 0; k < nLabel; ++k) {\n            s = input.readLine();\n            splits = s.split(\" \");\n            if (labelIDs.containsKey(splits[0]) && eSize == config.embeddingSize) {\n              int index = getLabelID(splits[0]);\n              for (int i = 0; i < eSize; ++i)\n                E[index][i] = Double.parseDouble(splits[i + 1]);\n            }\n          }\n\n          boolean copyLayer1 = hSize == config.hiddenSize && config.embeddingSize == eSize && config.numTokens == nTokens;\n          if (copyLayer1) {\n            System.err.println(\"Copying parameters W1 && b1...\");\n          }\n          for (int j = 0; j < eSize * nTokens; ++j) {\n            s = input.readLine();\n            if (copyLayer1) {\n              splits = s.split(\" \");\n              for (int i = 0; i < hSize; ++i)\n                    W1[i][j] = Double.parseDouble(splits[i]);\n            }\n          }\n\n          s = input.readLine();\n          if (copyLayer1) {\n            splits = s.split(\" \");\n            for (int i = 0; i < hSize; ++i)\n              b1[i] = Double.parseDouble(splits[i]);\n          }\n\n          boolean copyLayer2 = (nLabel * 2 - 1 == system.numTransitions()) && hSize == config.hiddenSize;\n          if (copyLayer2)\n            System.err.println(\"Copying parameters W2...\");\n          for (int j = 0; j < hSize; ++j) {\n              s = input.readLine();\n              if (copyLayer2) {\n                splits = s.split(\" \");\n                for (int i = 0; i < nLabel * 2 - 1; ++i)\n                  W2[i][j] = Double.parseDouble(splits[i]);\n              }\n          }\n          input.close();\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n    }\n    Dataset trainSet = genTrainExamples(trainSents, trainTrees);\n    classifier = new Classifier(config, trainSet, E, W1, b1, W2, preComputed);\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Determine the dependency parse of the given sentence.\n   * <p>\n   * This \"inner\" method returns a structure unique to this package; use {@link #predict(edu.stanford.nlp.util.CoreMap)}\n   * for general parsing purposes.\n   */\n  private DependencyTree predictInner(CoreMap sentence) {\n    int numTrans = system.transitions.size();\n\n    Configuration c = system.initialConfiguration(sentence);\n    while (!system.isTerminal(c)) {\n      double[] scores = classifier.computeScores(getFeatureArray(c));\n\n      double optScore = Double.NEGATIVE_INFINITY;\n      String optTrans = null;\n\n      for (int j = 0; j < numTrans; ++j) {\n        if (scores[j] > optScore && system.canApply(c, system.transitions.get(j))) {\n          optScore = scores[j];\n          optTrans = system.transitions.get(j);\n        }\n      }\n      system.apply(c, optTrans);\n    }\n    return c.tree;\n  }","id":98298,"modified_method":"/**\n   * Determine the dependency parse of the given sentence.\n   * <p>\n   * This \"inner\" method returns a structure unique to this package; use {@link #predict(edu.stanford.nlp.util.CoreMap)}\n   * for general parsing purposes.\n   */\n  private DependencyTree predictInner(CoreMap sentence) {\n    int numTrans = system.numTransitions();\n\n    Configuration c = system.initialConfiguration(sentence);\n    while (!system.isTerminal(c)) {\n      double[] scores = classifier.computeScores(getFeatureArray(c));\n\n      double optScore = Double.NEGATIVE_INFINITY;\n      String optTrans = null;\n\n      for (int j = 0; j < numTrans; ++j) {\n        if (scores[j] > optScore && system.canApply(c, system.transitions.get(j))) {\n          optScore = scores[j];\n          optTrans = system.transitions.get(j);\n        }\n      }\n      system.apply(c, optTrans);\n    }\n    return c.tree;\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Scan a corpus and store all words, part-of-speech tags, and\n   * dependency relation labels observed. Prepare other structures\n   * which support word / POS / label lookup at train- / run-time.\n   */\n  private void genDictionaries(List<CoreMap> sents, List<DependencyTree> trees) {\n    // Collect all words (!), etc. in lists, tacking on one sentence\n    // after the other\n    List<String> word = new ArrayList<>();\n    List<String> pos = new ArrayList<>();\n    List<String> label = new ArrayList<>();\n\n    for (CoreMap sentence : sents) {\n      List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n\n      for (CoreLabel token : tokens) {\n        word.add(token.word());\n        pos.add(token.tag());\n      }\n    }\n\n    String rootLabel = null;\n    for (DependencyTree tree : trees)\n      for (int k = 1; k <= tree.n; ++k)\n        if (tree.getHead(k) == 0)\n          rootLabel = tree.getLabel(k);\n        else\n          label.add(tree.getLabel(k));\n\n    // Generate \"dictionaries,\" possibly with frequency cutoff\n    knownWords = Util.generateDict(word, config.wordCutOff);\n    knownPos = Util.generateDict(pos);\n    knownLabels = Util.generateDict(label);\n    knownLabels.add(0, rootLabel);\n\n    knownWords.add(0, Config.UNKNOWN);\n    knownWords.add(1, Config.NULL);\n    knownWords.add(2, Config.ROOT);\n\n    knownPos.add(0, Config.UNKNOWN);\n    knownPos.add(1, Config.NULL);\n    knownPos.add(2, Config.ROOT);\n\n    knownLabels.add(0, Config.NULL);\n    generateIDs();\n\n    System.out.println(Config.SEPARATOR);\n    System.out.println(\"#Word: \" + knownWords.size());\n    System.out.println(\"#POS:\" + knownPos.size());\n    System.out.println(\"#Label: \" + knownLabels.size());\n  }","id":98299,"modified_method":"/**\n   * Scan a corpus and store all words, part-of-speech tags, and\n   * dependency relation labels observed. Prepare other structures\n   * which support word / POS / label lookup at train- / run-time.\n   */\n  private void genDictionaries(List<CoreMap> sents, List<DependencyTree> trees) {\n    // Collect all words (!), etc. in lists, tacking on one sentence\n    // after the other\n    List<String> word = new ArrayList<>();\n    List<String> pos = new ArrayList<>();\n    List<String> label = new ArrayList<>();\n\n    for (CoreMap sentence : sents) {\n      List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n\n      for (CoreLabel token : tokens) {\n        word.add(token.word());\n        pos.add(token.tag());\n      }\n    }\n\n    String rootLabel = null;\n    for (DependencyTree tree : trees)\n      for (int k = 1; k <= tree.n; ++k)\n        if (tree.getHead(k) == 0)\n          rootLabel = tree.getLabel(k);\n        else\n          label.add(tree.getLabel(k));\n\n    // Generate \"dictionaries,\" possibly with frequency cutoff\n    knownWords = Util.generateDict(word, config.wordCutOff);\n    knownPos = Util.generateDict(pos);\n    knownLabels = Util.generateDict(label);\n    knownLabels.add(0, rootLabel);\n\n    // Avoid the case that rootLabel equals to one of the other labels\n    for (int k = 1; k < knownLabels.size(); ++ k)\n      if (knownLabels.get(k).equals(rootLabel)) {\n        knownLabels.remove(k);\n        break;\n      }\n\n    knownWords.add(0, Config.UNKNOWN);\n    knownWords.add(1, Config.NULL);\n    knownWords.add(2, Config.ROOT);\n\n    knownPos.add(0, Config.UNKNOWN);\n    knownPos.add(1, Config.NULL);\n    knownPos.add(2, Config.ROOT);\n\n    knownLabels.add(0, Config.NULL);\n    generateIDs();\n\n    System.err.println(Config.SEPARATOR);\n    System.err.println(\"#Word: \" + knownWords.size());\n    System.err.println(\"#POS:\" + knownPos.size());\n    System.err.println(\"#Label: \" + knownLabels.size());\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void writeModelFile(String modelFile) {\n    try {\n      double[][] W1 = classifier.getW1();\n      double[] b1 = classifier.getb1();\n      double[][] W2 = classifier.getW2();\n      double[][] E = classifier.getE();\n\n      Writer output = IOUtils.getPrintWriter(modelFile);\n\n      output.write(\"dict=\" + knownWords.size() + \"\\n\");\n      output.write(\"pos=\" + knownPos.size() + \"\\n\");\n      output.write(\"label=\" + knownLabels.size() + \"\\n\");\n      output.write(\"embeddingSize=\" + E[0].length + \"\\n\");\n      output.write(\"hiddenSize=\" + b1.length + \"\\n\");\n      output.write(\"numTokens=\" + (W1[0].length / E[0].length) + \"\\n\");\n      output.write(\"preComputed=\" + preComputed.size() + \"\\n\");\n\n      int index = 0;\n\n      // First write word / POS / label embeddings\n      for (String word : knownWords) {\n        output.write(word);\n        for (int k = 0; k < E[index].length; ++k)\n          output.write(\" \" + E[index][k]);\n        output.write(\"\\n\");\n        index = index + 1;\n      }\n      for (String pos : knownPos) {\n        output.write(pos);\n        for (int k = 0; k < E[index].length; ++k)\n          output.write(\" \" + E[index][k]);\n        output.write(\"\\n\");\n        index = index + 1;\n      }\n      for (String label : knownLabels) {\n        output.write(label);\n        for (int k = 0; k < E[index].length; ++k)\n          output.write(\" \" + E[index][k]);\n        output.write(\"\\n\");\n        index = index + 1;\n      }\n\n      // Now write classifier weights\n      for (int j = 0; j < W1[0].length; ++j)\n        for (int i = 0; i < W1.length; ++i) {\n          output.write(\"\" + W1[i][j]);\n          if (i == W1.length - 1)\n            output.write(\"\\n\");\n          else\n            output.write(\" \");\n        }\n      for (int i = 0; i < b1.length; ++i) {\n        output.write(\"\" + b1[i]);\n        if (i == b1.length - 1)\n          output.write(\"\\n\");\n        else\n          output.write(\" \");\n      }\n      for (int j = 0; j < W2[0].length; ++j)\n        for (int i = 0; i < W2.length; ++i) {\n          output.write(\"\" + W2[i][j]);\n          if (i == W2.length - 1)\n            output.write(\"\\n\");\n          else\n            output.write(\" \");\n        }\n\n      // Finish with pre-computation info\n      for (int i = 0; i < preComputed.size(); ++i) {\n        output.write(\"\" + preComputed.get(i));\n        if ((i + 1) % 100 == 0 || i == preComputed.size() - 1)\n          output.write(\"\\n\");\n        else\n          output.write(\" \");\n      }\n\n      output.close();\n    } catch (IOException e) {\n      System.out.println(e);\n    }\n  }","id":98300,"modified_method":"public void writeModelFile(String modelFile) {\n    try {\n      double[][] W1 = classifier.getW1();\n      double[] b1 = classifier.getb1();\n      double[][] W2 = classifier.getW2();\n      double[][] E = classifier.getE();\n\n      Writer output = IOUtils.getPrintWriter(modelFile);\n\n      output.write(\"dict=\" + knownWords.size() + \"\\n\");\n      output.write(\"pos=\" + knownPos.size() + \"\\n\");\n      output.write(\"label=\" + knownLabels.size() + \"\\n\");\n      output.write(\"embeddingSize=\" + E[0].length + \"\\n\");\n      output.write(\"hiddenSize=\" + b1.length + \"\\n\");\n      output.write(\"numTokens=\" + (W1[0].length / E[0].length) + \"\\n\");\n      output.write(\"preComputed=\" + preComputed.size() + \"\\n\");\n\n      int index = 0;\n\n      // First write word / POS / label embeddings\n      for (String word : knownWords) {\n        output.write(word);\n        for (int k = 0; k < E[index].length; ++k)\n          output.write(\" \" + E[index][k]);\n        output.write(\"\\n\");\n        index = index + 1;\n      }\n      for (String pos : knownPos) {\n        output.write(pos);\n        for (int k = 0; k < E[index].length; ++k)\n          output.write(\" \" + E[index][k]);\n        output.write(\"\\n\");\n        index = index + 1;\n      }\n      for (String label : knownLabels) {\n        output.write(label);\n        for (int k = 0; k < E[index].length; ++k)\n          output.write(\" \" + E[index][k]);\n        output.write(\"\\n\");\n        index = index + 1;\n      }\n\n      // Now write classifier weights\n      for (int j = 0; j < W1[0].length; ++j)\n        for (int i = 0; i < W1.length; ++i) {\n          output.write(\"\" + W1[i][j]);\n          if (i == W1.length - 1)\n            output.write(\"\\n\");\n          else\n            output.write(\" \");\n        }\n      for (int i = 0; i < b1.length; ++i) {\n        output.write(\"\" + b1[i]);\n        if (i == b1.length - 1)\n          output.write(\"\\n\");\n        else\n          output.write(\" \");\n      }\n      for (int j = 0; j < W2[0].length; ++j)\n        for (int i = 0; i < W2.length; ++i) {\n          output.write(\"\" + W2[i][j]);\n          if (i == W2.length - 1)\n            output.write(\"\\n\");\n          else\n            output.write(\" \");\n        }\n\n      // Finish with pre-computation info\n      for (int i = 0; i < preComputed.size(); ++i) {\n        output.write(\"\" + preComputed.get(i));\n        if ((i + 1) % 100 == 0 || i == preComputed.size() - 1)\n          output.write(\"\\n\");\n        else\n          output.write(\" \");\n      }\n\n      output.close();\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * A main program for training, testing and using the parser.\n   *\n   * <p>\n   * You can use this program to train new parsers from treebank data,\n   * evaluate on test treebank data, or parse raw text input.\n   *\n   * <p>\n   * Sample usages:\n   * <ul>\n   *   <li>\n   *     <strong>Train a parser with CoNLL treebank data:<\/strong>\n   *     <code>java edu.stanford.nlp.parser.nndep.DependencyParser -trainFile trainPath -devFile devPath -embedFile wordEmbeddingFile -embeddingSize wordEmbeddingDimensionality -model modelOutputFile.txt.gz<\/code>\n   *   <\/li>\n   *   <li>\n   *     <strong>Parse raw text from a file:<\/strong>\n   *     <code>java edu.stanford.nlp.parser.nndep.DependencyParser -model modelOutputFile.txt.gz -textFile rawTextToParse -outFile dependenciesOutputFile.txt<\/code>\n   *   <\/li>\n   *   <li>\n   *     <strong>Parse raw text from standard input, writing to standard output:<\/strong>\n   *     <code>java edu.stanford.nlp.parser.nndep.DependencyParser -model modelOutputFile.txt.gz -textFile - -outFile -<\/code>\n   *   <\/li>\n   * <\/ul>\n   *\n   * <p>\n   * See below for more information on all of these training / test options and more.\n   *\n   * <p>\n   * Input / output options:\n   * <table>\n   *   <tr><th>Option<\/th><th>Required for training<\/th><th>Required for testing / parsing<\/th><th>Description<\/th><\/tr>\n   *   <tr><td><tt>&#8209;devFile<\/tt><\/td><td>Optional<\/td><td>No<\/td><td>Path to a development-set treebank in <a href=\"http://ilk.uvt.nl/conll/#dataformat\">CoNLL-X format<\/a>. If provided, the <\/td><\/tr>\n   *   <tr><td><tt>&#8209;embedFile<\/tt><\/td><td>Optional (highly recommended!)<\/td><td>No<\/td><td>A word embedding file, containing distributed representations of English words. Each line of the provided file should contain a single word followed by the elements of the corresponding word embedding (space-delimited). It is not absolutely necessary that all words in the treebank be covered by this embedding file, though the parser's performance will generally improve if you are able to provide better embeddings for more words.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;model<\/tt><\/td><td>Yes<\/td><td>Yes<\/td><td>Path to a model file. If the path ends in <tt>.gz<\/tt>, the model will be read as a Gzipped model file. During training, we write to this path; at test time we read a pre-trained model from this path.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;textFile<\/tt><\/td><td>No<\/td><td>Yes (or <tt>testFile<\/tt>)<\/td><td>Path to a plaintext file containing sentences to be parsed.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;testFile<\/tt><\/td><td>No<\/td><td>Yes (or <tt>textFile<\/tt>)<\/td><td>Path to a test-set treebank in <a href=\"http://ilk.uvt.nl/conll/#dataformat\">CoNLL-X format<\/a> for final evaluation of the parser.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;trainFile<\/tt><\/td><td>Yes<\/td><td>No<\/td><td>Path to a training treebank in <a href=\"http://ilk.uvt.nl/conll/#dataformat\">CoNLL-X format<\/a><\/td><\/tr>\n   * <\/table>\n   *\n   * Training options:\n   * <table>\n   *   <tr><th>Option<\/th><th>Default<\/th><th>Description<\/th><\/tr>\n   *   <tr><td><tt>&#8209;adaAlpha<\/tt><\/td><td>0.01<\/td><td>Global learning rate for AdaGrad training<\/td><\/tr>\n   *   <tr><td><tt>&#8209;adaEps<\/tt><\/td><td>1e-6<\/td><td>Epsilon value added to the denominator of AdaGrad update expression for numerical stability<\/td><\/tr>\n   *   <tr><td><tt>&#8209;batchSize<\/tt><\/td><td>10000<\/td><td>Size of mini-batch used for training<\/td><\/tr>\n   *   <tr><td><tt>&#8209;clearGradientsPerIter<\/tt><\/td><td>0<\/td><td>Clear AdaGrad gradient histories every <em>n<\/em> iterations. If zero, no gradient clearing is performed.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;dropProb<\/tt><\/td><td>0.5<\/td><td>Dropout probability. For each training example we randomly choose some amount of units to disable in the neural network classifier. This parameter controls the proportion of units \"dropped out.\"<\/td><\/tr>\n   *   <tr><td><tt>&#8209;embeddingSize<\/tt><\/td><td>50<\/td><td>Dimensionality of word embeddings provided<\/td><\/tr>\n   *   <tr><td><tt>&#8209;evalPerIter<\/tt><\/td><td>100<\/td><td>Run full UAS (unlabeled attachment score) evaluation every time we finish this number of iterations. (Only valid if a development treebank is provided with <tt>&#8209;devFile<\/tt>.)<\/td><\/tr>\n   *   <tr><td><tt>&#8209;hiddenSize<\/tt><\/td><td>200<\/td><td>Dimensionality of hidden layer in neural network classifier<\/td><\/tr>\n   *   <tr><td><tt>&#8209;initRange<\/tt><\/td><td>0.01<\/td><td>Bounds of range within which weight matrix elements should be initialized. Each element is drawn from a uniform distribution over the range <tt>[-initRange, initRange]<\/tt>.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;maxIter<\/tt><\/td><td>20000<\/td><td>Number of training iterations to complete before stopping and saving the final model.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;numPreComputed<\/tt><\/td><td>100000<\/td><td>The parser pre-computes hidden-layer unit activations for particular inputs words at both training and testing time in order to speed up feedforward computation in the neural network. This parameter determines how many words for which we should compute hidden-layer activations.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;regParameter<\/tt><\/td><td>1e-8<\/td><td>Regularization parameter for training<\/td><\/tr>\n   *   <tr><td><tt>&#8209;saveIntermediate<\/tt><\/td><td><tt>true<\/tt><\/td><td>If <tt>true<\/tt>, continually save the model version which gets the highest UAS value on the dev set. (Only valid if a development treebank is provided with <tt>&#8209;devFile<\/tt>.)<\/td><\/tr>\n   *   <tr><td><tt>&#8209;trainingThreads<\/tt><\/td><td>1<\/td><td>Number of threads to use during training. Note that depending on training batch size, it may be unwise to simply choose the maximum amount of threads for your machine. On our 16-core test machines: a batch size of 10,000 runs fastest with around 6 threads; a batch size of 100,000 runs best with around 10 threads.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;wordCutOff<\/tt><\/td><td>1<\/td><td>The parser can optionally ignore rare words by simply choosing an arbitrary \"unknown\" feature representation for words that appear with frequency less than <em>n<\/em> in the corpus. This <em>n<\/em> is controlled by the <tt>wordCutOff<\/tt> parameter.<\/td><\/tr>\n   * <\/table>\n   *\n   * Runtime parsing options:\n   * <table>\n   *   <tr><th>Option<\/th><th>Default<\/th><th>Description<\/th><\/tr>\n   *   <tr><td><tt>&#8209;escaper<\/tt><\/td><td>N/A<\/td><td>Only applicable for testing with <tt>-textFile<\/tt>. If provided, use this word-escaper when parsing raw sentences. (Should be a fully-qualified class name like <tt>edu.stanford.nlp.trees.international.arabic.ATBEscaper<\/tt>.)<\/td><\/tr>\n   *   <tr><td><tt>&#8209;numPreComputed<\/tt><\/td><td>100000<\/td><td>The parser pre-computes hidden-layer unit activations for particular inputs words at both training and testing time in order to speed up feedforward computation in the neural network. This parameter determines how many words for which we should compute hidden-layer activations.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;sentenceDelimiter<\/tt><\/td><td>N/A<\/td><td>Only applicable for testing with <tt>-textFile<\/tt>.  If provided, assume that the given <tt>textFile<\/tt> has already been sentence-split, and that sentences are separated by this delimiter.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;tagger.model<\/tt><\/td><td>edu/stanford/nlp/models/pos-tagger/english-left3words/english-left3words-distsim.tagger<\/td><td>Only applicable for testing with <tt>-textFile<\/tt>. Path to a part-of-speech tagger to use to pre-tag the raw sentences before parsing.<\/td><\/tr>\n   * <\/table>\n   */\n  public static void main(String[] args) {\n    Properties props = StringUtils.argsToProperties(args, numArgs);\n    DependencyParser parser = new DependencyParser(props);\n\n    // Train with CoNLL-X data\n    if (props.containsKey(\"trainFile\"))\n      parser.train(props.getProperty(\"trainFile\"), props.getProperty(\"devFile\"), props.getProperty(\"model\"),\n          props.getProperty(\"embedFile\"));\n\n    boolean loaded = false;\n    // Test with CoNLL-X data\n    if (props.containsKey(\"testFile\")) {\n      parser.loadModelFile(props.getProperty(\"model\"));\n      loaded = true;\n      parser.testCoNLL(props.getProperty(\"testFile\"), props.getProperty(\"outFile\"));\n    }\n\n    // Parse raw text data\n    if (props.containsKey(\"textFile\")) {\n      if (!loaded) {\n        parser.loadModelFile(props.getProperty(\"model\"));\n        loaded = true;\n      }\n\n      String encoding = parser.config.tlp.getEncoding();\n      String inputFilename = props.getProperty(\"textFile\");\n      BufferedReader input;\n      try {\n        input = inputFilename.equals(\"-\")\n                ? IOUtils.readerFromStdin(encoding)\n                : IOUtils.readerFromString(inputFilename, encoding);\n      } catch (IOException e) {\n        throw new RuntimeIOException(\"No input file provided (use -textFile)\", e);\n      }\n\n      String outputFilename = props.getProperty(\"outFile\");\n      PrintWriter output;\n      try {\n        output = outputFilename == null || outputFilename.equals(\"-\")\n            ? IOUtils.encodedOutputStreamPrintWriter(System.out, encoding, true)\n            : IOUtils.getPrintWriter(outputFilename, encoding);\n      } catch (IOException e) {\n        throw new RuntimeIOException(\"Error opening output file\", e);\n      }\n\n      parser.parseTextFile(input, output);\n    }\n  }","id":98301,"modified_method":"/**\n   * A main program for training, testing and using the parser.\n   *\n   * <p>\n   * You can use this program to train new parsers from treebank data,\n   * evaluate on test treebank data, or parse raw text input.\n   *\n   * <p>\n   * Sample usages:\n   * <ul>\n   *   <li>\n   *     <strong>Train a parser with CoNLL treebank data:<\/strong>\n   *     <code>java edu.stanford.nlp.parser.nndep.DependencyParser -trainFile trainPath -devFile devPath -embedFile wordEmbeddingFile -embeddingSize wordEmbeddingDimensionality -model modelOutputFile.txt.gz<\/code>\n   *   <\/li>\n   *   <li>\n   *     <strong>Parse raw text from a file:<\/strong>\n   *     <code>java edu.stanford.nlp.parser.nndep.DependencyParser -model modelOutputFile.txt.gz -textFile rawTextToParse -outFile dependenciesOutputFile.txt<\/code>\n   *   <\/li>\n   *   <li>\n   *     <strong>Parse raw text from standard input, writing to standard output:<\/strong>\n   *     <code>java edu.stanford.nlp.parser.nndep.DependencyParser -model modelOutputFile.txt.gz -textFile - -outFile -<\/code>\n   *   <\/li>\n   * <\/ul>\n   *\n   * <p>\n   * See below for more information on all of these training / test options and more.\n   *\n   * <p>\n   * Input / output options:\n   * <table>\n   *   <tr><th>Option<\/th><th>Required for training<\/th><th>Required for testing / parsing<\/th><th>Description<\/th><\/tr>\n   *   <tr><td><tt>&#8209;devFile<\/tt><\/td><td>Optional<\/td><td>No<\/td><td>Path to a development-set treebank in <a href=\"http://ilk.uvt.nl/conll/#dataformat\">CoNLL-X format<\/a>. If provided, the <\/td><\/tr>\n   *   <tr><td><tt>&#8209;embedFile<\/tt><\/td><td>Optional (highly recommended!)<\/td><td>No<\/td><td>A word embedding file, containing distributed representations of English words. Each line of the provided file should contain a single word followed by the elements of the corresponding word embedding (space-delimited). It is not absolutely necessary that all words in the treebank be covered by this embedding file, though the parser's performance will generally improve if you are able to provide better embeddings for more words.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;model<\/tt><\/td><td>Yes<\/td><td>Yes<\/td><td>Path to a model file. If the path ends in <tt>.gz<\/tt>, the model will be read as a Gzipped model file. During training, we write to this path; at test time we read a pre-trained model from this path.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;textFile<\/tt><\/td><td>No<\/td><td>Yes (or <tt>testFile<\/tt>)<\/td><td>Path to a plaintext file containing sentences to be parsed.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;testFile<\/tt><\/td><td>No<\/td><td>Yes (or <tt>textFile<\/tt>)<\/td><td>Path to a test-set treebank in <a href=\"http://ilk.uvt.nl/conll/#dataformat\">CoNLL-X format<\/a> for final evaluation of the parser.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;trainFile<\/tt><\/td><td>Yes<\/td><td>No<\/td><td>Path to a training treebank in <a href=\"http://ilk.uvt.nl/conll/#dataformat\">CoNLL-X format<\/a><\/td><\/tr>\n   * <\/table>\n   *\n   * Training options:\n   * <table>\n   *   <tr><th>Option<\/th><th>Default<\/th><th>Description<\/th><\/tr>\n   *   <tr><td><tt>&#8209;adaAlpha<\/tt><\/td><td>0.01<\/td><td>Global learning rate for AdaGrad training<\/td><\/tr>\n   *   <tr><td><tt>&#8209;adaEps<\/tt><\/td><td>1e-6<\/td><td>Epsilon value added to the denominator of AdaGrad update expression for numerical stability<\/td><\/tr>\n   *   <tr><td><tt>&#8209;batchSize<\/tt><\/td><td>10000<\/td><td>Size of mini-batch used for training<\/td><\/tr>\n   *   <tr><td><tt>&#8209;clearGradientsPerIter<\/tt><\/td><td>0<\/td><td>Clear AdaGrad gradient histories every <em>n<\/em> iterations. If zero, no gradient clearing is performed.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;dropProb<\/tt><\/td><td>0.5<\/td><td>Dropout probability. For each training example we randomly choose some amount of units to disable in the neural network classifier. This parameter controls the proportion of units \"dropped out.\"<\/td><\/tr>\n   *   <tr><td><tt>&#8209;embeddingSize<\/tt><\/td><td>50<\/td><td>Dimensionality of word embeddings provided<\/td><\/tr>\n   *   <tr><td><tt>&#8209;evalPerIter<\/tt><\/td><td>100<\/td><td>Run full UAS (unlabeled attachment score) evaluation every time we finish this number of iterations. (Only valid if a development treebank is provided with <tt>&#8209;devFile<\/tt>.)<\/td><\/tr>\n   *   <tr><td><tt>&#8209;hiddenSize<\/tt><\/td><td>200<\/td><td>Dimensionality of hidden layer in neural network classifier<\/td><\/tr>\n   *   <tr><td><tt>&#8209;initRange<\/tt><\/td><td>0.01<\/td><td>Bounds of range within which weight matrix elements should be initialized. Each element is drawn from a uniform distribution over the range <tt>[-initRange, initRange]<\/tt>.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;maxIter<\/tt><\/td><td>20000<\/td><td>Number of training iterations to complete before stopping and saving the final model.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;numPreComputed<\/tt><\/td><td>100000<\/td><td>The parser pre-computes hidden-layer unit activations for particular inputs words at both training and testing time in order to speed up feedforward computation in the neural network. This parameter determines how many words for which we should compute hidden-layer activations.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;regParameter<\/tt><\/td><td>1e-8<\/td><td>Regularization parameter for training<\/td><\/tr>\n   *   <tr><td><tt>&#8209;saveIntermediate<\/tt><\/td><td><tt>true<\/tt><\/td><td>If <tt>true<\/tt>, continually save the model version which gets the highest UAS value on the dev set. (Only valid if a development treebank is provided with <tt>&#8209;devFile<\/tt>.)<\/td><\/tr>\n   *   <tr><td><tt>&#8209;trainingThreads<\/tt><\/td><td>1<\/td><td>Number of threads to use during training. Note that depending on training batch size, it may be unwise to simply choose the maximum amount of threads for your machine. On our 16-core test machines: a batch size of 10,000 runs fastest with around 6 threads; a batch size of 100,000 runs best with around 10 threads.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;wordCutOff<\/tt><\/td><td>1<\/td><td>The parser can optionally ignore rare words by simply choosing an arbitrary \"unknown\" feature representation for words that appear with frequency less than <em>n<\/em> in the corpus. This <em>n<\/em> is controlled by the <tt>wordCutOff<\/tt> parameter.<\/td><\/tr>\n   * <\/table>\n   *\n   * Runtime parsing options:\n   * <table>\n   *   <tr><th>Option<\/th><th>Default<\/th><th>Description<\/th><\/tr>\n   *   <tr><td><tt>&#8209;escaper<\/tt><\/td><td>N/A<\/td><td>Only applicable for testing with <tt>-textFile<\/tt>. If provided, use this word-escaper when parsing raw sentences. (Should be a fully-qualified class name like <tt>edu.stanford.nlp.trees.international.arabic.ATBEscaper<\/tt>.)<\/td><\/tr>\n   *   <tr><td><tt>&#8209;numPreComputed<\/tt><\/td><td>100000<\/td><td>The parser pre-computes hidden-layer unit activations for particular inputs words at both training and testing time in order to speed up feedforward computation in the neural network. This parameter determines how many words for which we should compute hidden-layer activations.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;sentenceDelimiter<\/tt><\/td><td>N/A<\/td><td>Only applicable for testing with <tt>-textFile<\/tt>.  If provided, assume that the given <tt>textFile<\/tt> has already been sentence-split, and that sentences are separated by this delimiter.<\/td><\/tr>\n   *   <tr><td><tt>&#8209;tagger.model<\/tt><\/td><td>edu/stanford/nlp/models/pos-tagger/english-left3words/english-left3words-distsim.tagger<\/td><td>Only applicable for testing with <tt>-textFile<\/tt>. Path to a part-of-speech tagger to use to pre-tag the raw sentences before parsing.<\/td><\/tr>\n   * <\/table>\n   */\n  public static void main(String[] args) {\n    Properties props = StringUtils.argsToProperties(args, numArgs);\n    DependencyParser parser = new DependencyParser(props);\n\n    // Train with CoNLL-X data\n    if (props.containsKey(\"trainFile\"))\n      parser.train(props.getProperty(\"trainFile\"), props.getProperty(\"devFile\"), props.getProperty(\"model\"),\n          props.getProperty(\"embedFile\"), props.getProperty(\"preModel\"));\n\n    boolean loaded = false;\n    // Test with CoNLL-X data\n    if (props.containsKey(\"testFile\")) {\n      parser.loadModelFile(props.getProperty(\"model\"));\n      loaded = true;\n      parser.testCoNLL(props.getProperty(\"testFile\"), props.getProperty(\"outFile\"));\n    }\n\n    // Parse raw text data\n    if (props.containsKey(\"textFile\")) {\n      if (!loaded) {\n        parser.loadModelFile(props.getProperty(\"model\"));\n        loaded = true;\n      }\n\n      String encoding = parser.config.tlp.getEncoding();\n      String inputFilename = props.getProperty(\"textFile\");\n      BufferedReader input;\n      try {\n        input = inputFilename.equals(\"-\")\n                ? IOUtils.readerFromStdin(encoding)\n                : IOUtils.readerFromString(inputFilename, encoding);\n      } catch (IOException e) {\n        throw new RuntimeIOException(\"No input file provided (use -textFile)\", e);\n      }\n\n      String outputFilename = props.getProperty(\"outFile\");\n      PrintWriter output;\n      try {\n        output = outputFilename == null || outputFilename.equals(\"-\")\n            ? IOUtils.encodedOutputStreamPrintWriter(System.out, encoding, true)\n            : IOUtils.getPrintWriter(outputFilename, encoding);\n      } catch (IOException e) {\n        throw new RuntimeIOException(\"Error opening output file\", e);\n      }\n\n      parser.parseTextFile(input, output);\n    }\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void readEmbedFile(String embedFile) {\n    embedID = new HashMap<String, Integer>();\n    if (embedFile == null)\n      return;\n    BufferedReader input = null;\n    try {\n      input = IOUtils.readerFromString(embedFile);\n      List<String> lines = new ArrayList<String>();\n      for (String s; (s = input.readLine()) != null; ) {\n        lines.add(s);\n      }\n\n      int nWords = lines.size();\n      String[] splits = lines.get(0).split(\"\\\\s+\");\n\n      int dim = splits.length - 1;\n      embeddings = new double[nWords][dim];\n      System.err.println(\"Embedding File \" + embedFile + \": #Words = \" + nWords + \", dim = \" + dim);\n\n      if (dim != config.embeddingSize)\n          throw new IllegalArgumentException(\"The dimension of embedding file does not match config.embeddingSize\");\n\n      for (int i = 0; i < lines.size(); ++i) {\n        splits = lines.get(i).split(\"\\\\s+\");\n        embedID.put(splits[0], i);\n        for (int j = 0; j < dim; ++j)\n          embeddings[i][j] = Double.parseDouble(splits[j + 1]);\n      }\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(input);\n    }\n  }","id":98302,"modified_method":"private double[][] readEmbedFile(String embedFile, Map<String, Integer> embedID) {\n\n    double[][] embeddings = null;\n    if (embedFile != null) {\n      BufferedReader input = null;\n      try {\n        input = IOUtils.readerFromString(embedFile);\n        List<String> lines = new ArrayList<String>();\n        for (String s; (s = input.readLine()) != null; ) {\n          lines.add(s);\n        }\n\n        int nWords = lines.size();\n        String[] splits = lines.get(0).split(\"\\\\s+\");\n\n        int dim = splits.length - 1;\n        embeddings = new double[nWords][dim];\n        System.err.println(\"Embedding File \" + embedFile + \": #Words = \" + nWords + \", dim = \" + dim);\n\n        if (dim != config.embeddingSize)\n            throw new IllegalArgumentException(\"The dimension of embedding file does not match config.embeddingSize\");\n\n        for (int i = 0; i < lines.size(); ++i) {\n          splits = lines.get(i).split(\"\\\\s+\");\n          embedID.put(splits[0], i);\n          for (int j = 0; j < dim; ++j)\n            embeddings[i][j] = Double.parseDouble(splits[j + 1]);\n        }\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      } finally {\n        IOUtils.closeIgnoringExceptions(input);\n      }\n    }\n    return embeddings;\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Dataset genTrainExamples(List<CoreMap> sents, List<DependencyTree> trees) {\n    Dataset ret = new Dataset(config.numTokens, system.transitions.size());\n\n    Counter<Integer> tokPosCount = new IntCounter<>();\n    System.err.println(Config.SEPARATOR);\n    System.err.println(\"Generate training examples...\");\n\n    for (int i = 0; i < sents.size(); ++i) {\n\n      if (i > 0) {\n        if (i % 1000 == 0)\n          System.err.print(i + \" \");\n        if (i % 10000 == 0 || i == sents.size() - 1)\n          System.err.println();\n      }\n\n      if (trees.get(i).isProjective()) {\n        Configuration c = system.initialConfiguration(sents.get(i));\n\n        while (!system.isTerminal(c)) {\n          String oracle = system.getOracle(c, trees.get(i));\n          List<Integer> feature = getFeatures(c);\n          List<Integer> label = new ArrayList<>();\n          for (int j = 0; j < system.transitions.size(); ++j) {\n            String str = system.transitions.get(j);\n            if (str.equals(oracle)) label.add(1);\n            else if (system.canApply(c, str)) label.add(0);\n            else label.add(-1);\n          }\n\n          ret.addExample(feature, label);\n          for (int j = 0; j < feature.size(); ++j)\n            tokPosCount.incrementCount(feature.get(j) * feature.size() + j);\n          system.apply(c, oracle);\n        }\n      }\n    }\n    System.err.println(\"#Train Examples: \" + ret.n);\n\n    preComputed = new ArrayList<>(config.numPreComputed);\n    List<Integer> sortedTokens = Counters.toSortedList(tokPosCount, false);\n\n    preComputed = new ArrayList<>(sortedTokens.subList(0, Math.min(config.numPreComputed, sortedTokens.size())));\n\n    return ret;\n  }","id":98303,"modified_method":"public Dataset genTrainExamples(List<CoreMap> sents, List<DependencyTree> trees) {\n    int numTrans = system.numTransitions();\n    Dataset ret = new Dataset(config.numTokens, numTrans);\n\n    Counter<Integer> tokPosCount = new IntCounter<>();\n    System.err.println(Config.SEPARATOR);\n    System.err.println(\"Generate training examples...\");\n\n    for (int i = 0; i < sents.size(); ++i) {\n\n      if (i > 0) {\n        if (i % 1000 == 0)\n          System.err.print(i + \" \");\n        if (i % 10000 == 0 || i == sents.size() - 1)\n          System.err.println();\n      }\n\n      if (trees.get(i).isProjective()) {\n        Configuration c = system.initialConfiguration(sents.get(i));\n\n        while (!system.isTerminal(c)) {\n          String oracle = system.getOracle(c, trees.get(i));\n          List<Integer> feature = getFeatures(c);\n          List<Integer> label = new ArrayList<>();\n          for (int j = 0; j < numTrans; ++j) {\n            String str = system.transitions.get(j);\n            if (str.equals(oracle)) label.add(1);\n            else if (system.canApply(c, str)) label.add(0);\n            else label.add(-1);\n          }\n\n          ret.addExample(feature, label);\n          for (int j = 0; j < feature.size(); ++j)\n            tokPosCount.incrementCount(feature.get(j) * feature.size() + j);\n          system.apply(c, oracle);\n        }\n      }\n    }\n    System.err.println(\"#Train Examples: \" + ret.n);\n\n    List<Integer> sortedTokens = Counters.toSortedList(tokPosCount, false);\n    preComputed = new ArrayList<>(sortedTokens.subList(0, Math.min(config.numPreComputed, sortedTokens.size())));\n\n    return ret;\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * @see #train(String, String, String, String)\n   */\n  public void train(String trainFile, String modelFile) {\n    train(trainFile, null, modelFile);\n  }","id":98304,"modified_method":"/**\n   * @see #train(String, String, String)\n   */\n  public void train(String trainFile, String modelFile) {\n    train(trainFile, null, modelFile);\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Train a new dependency parser model.\n   *\n   * @param trainFile Training data\n   * @param devFile Development data (used for regular UAS evaluation\n   *                of model)\n   * @param modelFile String to which model should be saved\n   * @param embedFile File containing word embeddings for words used in\n   *                  training corpus\n   */\n  public void train(String trainFile, String devFile, String modelFile, String embedFile) {\n    System.err.println(\"Train File: \" + trainFile);\n    System.err.println(\"Dev File: \" + devFile);\n    System.err.println(\"Model File: \" + modelFile);\n    System.err.println(\"Embedding File: \" + embedFile);\n\n    List<CoreMap> trainSents = new ArrayList<>();\n    List<DependencyTree> trainTrees = new ArrayList<DependencyTree>();\n    Util.loadConllFile(trainFile, trainSents, trainTrees);\n    Util.printTreeStats(\"Train\", trainTrees);\n\n    List<CoreMap> devSents = new ArrayList<CoreMap>();\n    List<DependencyTree> devTrees = new ArrayList<DependencyTree>();\n    if (devFile != null) {\n      Util.loadConllFile(devFile, devSents, devTrees);\n      Util.printTreeStats(\"Dev\", devTrees);\n    }\n    genDictionaries(trainSents, trainTrees);\n\n    //NOTE: remove -NULL-, and the pass it to ParsingSystem\n    List<String> lDict = new ArrayList<String>(knownLabels);\n    lDict.remove(0);\n    system = new ArcStandard(config.tlp, lDict, true);\n\n    // Initialize a classifier; prepare for training\n    setupClassifierForTraining(trainSents, trainTrees, embedFile);\n\n    System.err.println(Config.SEPARATOR);\n    config.printParameters();\n\n    long startTime = System.currentTimeMillis();\n    /**\n     * Track the best UAS performance we've seen.\n     */\n    double bestUAS = 0;\n\n    for (int iter = 0; iter < config.maxIter; ++iter) {\n      System.err.println(\"##### Iteration \" + iter);\n\n      Classifier.Cost cost = classifier.computeCostFunction(config.batchSize, config.regParameter, config.dropProb);\n      System.err.println(\"Cost = \" + cost.getCost() + \", Correct(%) = \" + cost.getPercentCorrect());\n      classifier.takeAdaGradientStep(cost, config.adaAlpha, config.adaEps);\n\n      System.err.println(\"Elapsed Time: \" + (System.currentTimeMillis() - startTime) / 1000.0 + \" (s)\");\n\n      // UAS evaluation\n      if (devFile != null && iter % config.evalPerIter == 0) {\n        // Redo precomputation with updated weights. This is only\n        // necessary because we're updating weights -- for normal\n        // prediction, we just do this once in #initialize\n        classifier.preCompute();\n\n        List<DependencyTree> predicted = devSents.stream().map(this::predictInner).collect(toList());\n\n        double uas = system.getUASScore(devSents, predicted, devTrees);\n        System.err.println(\"UAS: \" + uas);\n\n        if (config.saveIntermediate && uas > bestUAS) {\n          System.err.printf(\"Exceeds best previous UAS of %f. Saving model file..%n\", bestUAS);\n\n          bestUAS = uas;\n          writeModelFile(modelFile);\n        }\n      }\n\n      // Clear gradients\n      if (config.clearGradientsPerIter > 0 && iter % config.clearGradientsPerIter == 0) {\n        System.err.println(\"Clearing gradient histories..\");\n        classifier.clearGradientHistories();\n      }\n    }\n\n    classifier.finalizeTraining();\n\n    if (devFile != null) {\n      // Do final UAS evaluation and save if final model beats the\n      // best intermediate one\n      List<DependencyTree> predicted = devSents.stream().map(this::predictInner).collect(toList());\n      double uas = system.getUASScore(devSents, predicted, devTrees);\n\n      if (uas > bestUAS) {\n        System.err.printf(\"Final model UAS: %f%n\", uas);\n        System.err.printf(\"Exceeds best previous UAS of %f. Saving model file..%n\", bestUAS);\n\n        writeModelFile(modelFile);\n      }\n    } else {\n      writeModelFile(modelFile);\n    }\n  }","id":98305,"modified_method":"/**\n  * @see #train(String, String, String, String, String)\n  */\n  public void train(String trainFile, String devFile, String modelFile, String embedFile) {\n    train(trainFile, devFile, modelFile, embedFile, null);\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Evaluate performance on a list of sentences, predicted parses,\n   * and gold parses.\n   *\n   * @return A map from metric name to metric value\n   */\n  public Map<String, Double> evaluate(List<CoreMap> sentences, List<DependencyTree> trees,\n                                      List<DependencyTree> goldTrees) {\n    Map<String, Double> result = new HashMap<String, Double>();\n\n    // We'll skip words which are punctuation. Retrieve tags indicating\n    // punctuation in this treebank.\n    Set<String> punctuationTags = getPunctuationTags();\n\n    if (trees.size() != goldTrees.size()) {\n      System.err.println(\"[Error] Incorrect number of trees.\");\n      return null;\n    }\n\n    int correctArcs = 0;\n    int correctArcsWoPunc = 0;\n    int correctHeads = 0;\n    int correctHeadsWoPunc = 0;\n\n    int correctTrees = 0;\n    int correctTreesWoPunc = 0;\n    int correctRoot = 0;\n\n    int sumArcs = 0;\n    int sumArcsWoPunc = 0;\n\n    for (int i = 0; i < trees.size(); ++i) {\n      List<CoreLabel> tokens = sentences.get(i).get(CoreAnnotations.TokensAnnotation.class);\n\n      if (trees.get(i).n != goldTrees.get(i).n) {\n        System.err.println(\"[Error] Tree \" + (i + 1) + \": incorrect number of nodes.\");\n        return null;\n      }\n      if (!trees.get(i).isTree()) {\n        System.err.println(\"[Error] Tree \" + (i + 1) + \": illegal.\");\n        return null;\n      }\n\n      int nCorrectHead = 0;\n      int nCorrectHeadwoPunc = 0;\n      int nonPunc = 0;\n\n      for (int j = 1; j <= trees.get(i).n; ++j) {\n        if (trees.get(i).getHead(j) == goldTrees.get(i).getHead(j)) {\n          ++correctHeads;\n          ++nCorrectHead;\n          if (trees.get(i).getLabel(j).equals(goldTrees.get(i).getLabel(j)))\n            ++correctArcs;\n        }\n        ++sumArcs;\n\n        String tag = tokens.get(j - 1).tag();\n        if (!punctuationTags.contains(tag)) {\n          ++sumArcsWoPunc;\n          ++nonPunc;\n          if (trees.get(i).getHead(j) == goldTrees.get(i).getHead(j)) {\n            ++correctHeadsWoPunc;\n            ++nCorrectHeadwoPunc;\n            if (trees.get(i).getLabel(j).equals(goldTrees.get(i).getLabel(j)))\n              ++correctArcsWoPunc;\n          }\n        }\n      }\n      if (nCorrectHead == trees.get(i).n)\n        ++correctTrees;\n      if (nCorrectHeadwoPunc == nonPunc)\n        ++correctTreesWoPunc;\n      if (trees.get(i).getRoot() == goldTrees.get(i).getRoot())\n        ++correctRoot;\n    }\n\n    result.put(\"UAS\", correctHeads * 100.0 / sumArcs);\n    result.put(\"UASwoPunc\", correctHeadsWoPunc * 100.0 / sumArcsWoPunc);\n    result.put(\"LAS\", correctArcs * 100.0 / sumArcs);\n    result.put(\"LASwoPunc\", correctArcsWoPunc * 100.0 / sumArcsWoPunc);\n\n    result.put(\"UEM\", correctTrees * 100.0 / trees.size());\n    result.put(\"UEMwoPunc\", correctTreesWoPunc * 100.0 / trees.size());\n    result.put(\"ROOT\", correctRoot * 100.0 / trees.size());\n\n\n    return result;\n  }","id":98306,"modified_method":"/**\n   * Evaluate performance on a list of sentences, predicted parses,\n   * and gold parses.\n   *\n   * @return A map from metric name to metric value\n   */\n  public Map<String, Double> evaluate(List<CoreMap> sentences, List<DependencyTree> trees,\n                                      List<DependencyTree> goldTrees) {\n    Map<String, Double> result = new HashMap<String, Double>();\n\n    // We'll skip words which are punctuation. Retrieve tags indicating\n    // punctuation in this treebank.\n    Set<String> punctuationTags = getPunctuationTags();\n\n    if (trees.size() != goldTrees.size()) {\n      System.err.println(\"ERROR: Incorrect number of trees.\");\n      return null;\n    }\n\n    int correctArcs = 0;\n    int correctArcsNoPunc = 0;\n    int correctHeads = 0;\n    int correctHeadsNoPunc = 0;\n\n    int correctTrees = 0;\n    int correctTreesNoPunc = 0;\n    int correctRoot = 0;\n\n    int sumArcs = 0;\n    int sumArcsNoPunc = 0;\n\n    for (int i = 0; i < trees.size(); ++i) {\n      List<CoreLabel> tokens = sentences.get(i).get(CoreAnnotations.TokensAnnotation.class);\n\n      if (trees.get(i).n != goldTrees.get(i).n) {\n        System.err.println(\"ERROR: Tree \" + (i + 1) + \": incorrect number of nodes.\");\n        return null;\n      }\n      if (!trees.get(i).isTree()) {\n        System.err.println(\"ERROR: Tree \" + (i + 1) + \": illegal.\");\n        return null;\n      }\n\n      int nCorrectHead = 0;\n      int nCorrectHeadNoPunc = 0;\n      int nNoPunc = 0;\n\n      for (int j = 1; j <= trees.get(i).n; ++j) {\n        if (trees.get(i).getHead(j) == goldTrees.get(i).getHead(j)) {\n          ++correctHeads;\n          ++nCorrectHead;\n          if (trees.get(i).getLabel(j).equals(goldTrees.get(i).getLabel(j)))\n            ++correctArcs;\n        }\n        ++sumArcs;\n\n        String tag = tokens.get(j - 1).tag();\n        if (!punctuationTags.contains(tag)) {\n          ++sumArcsNoPunc;\n          ++nNoPunc;\n          if (trees.get(i).getHead(j) == goldTrees.get(i).getHead(j)) {\n            ++correctHeadsNoPunc;\n            ++nCorrectHeadNoPunc;\n            if (trees.get(i).getLabel(j).equals(goldTrees.get(i).getLabel(j)))\n              ++correctArcsNoPunc;\n          }\n        }\n      }\n      if (nCorrectHead == trees.get(i).n)\n        ++correctTrees;\n      if (nCorrectHeadNoPunc == nNoPunc)\n        ++correctTreesNoPunc;\n      if (trees.get(i).getRoot() == goldTrees.get(i).getRoot())\n        ++correctRoot;\n    }\n\n    result.put(\"UAS\", correctHeads * 100.0 / sumArcs);\n    result.put(\"UASnoPunc\", correctHeadsNoPunc * 100.0 / sumArcsNoPunc);\n    result.put(\"LAS\", correctArcs * 100.0 / sumArcs);\n    result.put(\"LASnoPunc\", correctArcsNoPunc * 100.0 / sumArcsNoPunc);\n\n    result.put(\"UEM\", correctTrees * 100.0 / trees.size());\n    result.put(\"UEMnoPunc\", correctTreesNoPunc * 100.0 / trees.size());\n    result.put(\"ROOT\", correctRoot * 100.0 / trees.size());\n\n\n    return result;\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * @param tlp TreebankLanguagePack describing the language being\n   *            parsed\n   * @param labels A list of possible dependency relation labels, with\n   *               the ROOT relation label as the first element\n   */\n  public ParsingSystem(TreebankLanguagePack tlp, List<String> labels, boolean verbose) {\n    this.tlp = tlp;\n    this.labels = new ArrayList<>(labels);\n\n    //NOTE: assume that the first element of labels is rootLabel\n    rootLabel = labels.get(0);\n    makeTransitions();\n\n    if (verbose) {\n      System.err.println(Config.SEPARATOR);\n      System.err.println(\"#Transitions: \" + transitions.size());\n      System.err.println(\"#Labels: \" + labels.size());\n      System.err.println(\"ROOTLABEL: \" + rootLabel);\n    }\n  }","id":98307,"modified_method":"/**\n   * @param tlp TreebankLanguagePack describing the language being\n   *            parsed\n   * @param labels A list of possible dependency relation labels, with\n   *               the ROOT relation label as the first element\n   */\n  public ParsingSystem(TreebankLanguagePack tlp, List<String> labels, boolean verbose) {\n    this.tlp = tlp;\n    this.labels = new ArrayList<>(labels);\n\n    //NOTE: assume that the first element of labels is rootLabel\n    rootLabel = labels.get(0);\n    makeTransitions();\n\n    if (verbose) {\n      System.err.println(Config.SEPARATOR);\n      System.err.println(\"#Transitions: \" + numTransitions());\n      System.err.println(\"#Labels: \" + labels.size());\n      System.err.println(\"ROOTLABEL: \" + rootLabel);\n    }\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getTransitionID(String s) {\n    for (int k = 0; k < transitions.size(); ++k)\n      if (transitions.get(k).equals(s))\n        return k;\n    return -1;\n  }","id":98308,"modified_method":"public int getTransitionID(String s) {\n    int numTrans = numTransitions();\n    for (int k = 0; k < numTrans; ++k)\n      if (transitions.get(k).equals(s))\n        return k;\n    return -1;\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public double getUASScore(List<CoreMap> sentences, List<DependencyTree> trees, List<DependencyTree> goldTrees) {\n    Map<String, Double> result = evaluate(sentences, trees, goldTrees);\n    return result == null || !result.containsKey(\"UASwoPunc\") ? -1.0 : result.get(\"UASwoPunc\");\n  }","id":98309,"modified_method":"public double getUAS(List<CoreMap> sentences, List<DependencyTree> trees, List<DependencyTree> goldTrees) {\n    Map<String, Double> result = evaluate(sentences, trees, goldTrees);\n    return result == null || !result.containsKey(\"UAS\") ? -1.0 : result.get(\"UAS\");\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void loadConllFile(String inFile, List<CoreMap> sents, List<DependencyTree> trees)\n  {\n    loadConllFile(inFile, sents, trees, true);\n  }","id":98310,"modified_method":"public static void loadConllFile(String inFile, List<CoreMap> sents, List<DependencyTree> trees)\n  {\n    loadConllFile(inFile, sents, trees, false, false);\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void loadConllFile(String inFile, List<CoreMap> sents, List<DependencyTree> trees, boolean labeled)\n  {\n    CoreLabelTokenFactory tf = new CoreLabelTokenFactory(false);\n\n    BufferedReader reader = null;\n    try {\n      reader = IOUtils.readerFromString(inFile);\n\n      CoreMap sentence = new CoreLabel();\n      List<CoreLabel> sentenceTokens = new ArrayList<>();\n\n      DependencyTree tree = new DependencyTree();\n\n      for (String line : IOUtils.getLineIterable(reader, false)) {\n        String[] splits = line.split(\"\\t\");\n        if (splits.length < 10) {\n          trees.add(tree);\n          sentence.set(CoreAnnotations.TokensAnnotation.class, sentenceTokens);\n          sents.add(sentence);\n\n          tree = new DependencyTree();\n          sentence = new CoreLabel();\n          sentenceTokens = new ArrayList<>();\n        } else {\n          String word = splits[1],\n                  pos = splits[4],\n                  depType = splits[7];\n          int head = Integer.parseInt(splits[6]);\n\n          CoreLabel token = tf.makeToken(word, 0, 0);\n          token.setTag(pos);\n          token.set(CoreAnnotations.CoNLLDepParentIndexAnnotation.class, head);\n          token.set(CoreAnnotations.CoNLLDepTypeAnnotation.class, depType);\n          sentenceTokens.add(token);\n\n          if (labeled)\n            tree.add(head, depType);\n          else\n            tree.add(head, Config.UNKNOWN);\n        }\n      }    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(reader);\n    }\n  }","id":98311,"modified_method":"public static void loadConllFile(String inFile, List<CoreMap> sents, List<DependencyTree> trees, boolean unlabeled, boolean cPOS)\n  {\n    CoreLabelTokenFactory tf = new CoreLabelTokenFactory(false);\n\n    BufferedReader reader = null;\n    try {\n      reader = IOUtils.readerFromString(inFile);\n\n      CoreMap sentence = new CoreLabel();\n      List<CoreLabel> sentenceTokens = new ArrayList<>();\n\n      DependencyTree tree = new DependencyTree();\n\n      for (String line : IOUtils.getLineIterable(reader, false)) {\n        String[] splits = line.split(\"\\t\");\n        if (splits.length < 10) {\n          trees.add(tree);\n          sentence.set(CoreAnnotations.TokensAnnotation.class, sentenceTokens);\n          sents.add(sentence);\n\n          tree = new DependencyTree();\n          sentence = new CoreLabel();\n          sentenceTokens = new ArrayList<>();\n        } else {\n          String word = splits[1],\n                  pos = cPOS ? splits[3] : splits[4],\n                  depType = splits[7];\n          int head = Integer.parseInt(splits[6]);\n\n          CoreLabel token = tf.makeToken(word, 0, 0);\n          token.setTag(pos);\n          token.set(CoreAnnotations.CoNLLDepParentIndexAnnotation.class, head);\n          token.set(CoreAnnotations.CoNLLDepTypeAnnotation.class, depType);\n          sentenceTokens.add(token);\n\n          if (!unlabeled)\n            tree.add(head, depType);\n          else\n            tree.add(head, Config.UNKNOWN);\n        }\n      }    \n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(reader);\n    }\n  }","commit_id":"d7473c0a4ed724818128a8cdc72865d3932d89d4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"protected int doWork() {\n        ReferenceOrderedData rod = new ReferenceOrderedData(new File(\"trunk/data/gFFTest.gff\"));\n        rod.testMe();\n\n        this.engine = new TraversalEngine(INPUT_FILE, REF_FILE_ARG);\n\n        ValidationStringency strictness;\n    \tif ( STRICTNESS_ARG == null ) {\n            strictness = ValidationStringency.STRICT;\n    \t}\n    \telse if ( STRICTNESS_ARG.toLowerCase().equals(\"lenient\") ) {\n    \t\tstrictness = ValidationStringency.LENIENT;\n    \t}\n    \telse if ( STRICTNESS_ARG.toLowerCase().equals(\"silent\") ) {\n    \t\tstrictness = ValidationStringency.SILENT;\n    \t}\n    \telse {\n            strictness = ValidationStringency.STRICT;\n    \t}\n        System.err.println(\"Strictness is \" + strictness);\n        engine.setStrictness(strictness);\n\n        engine.setDebugging(! ( DEBUGGING_STR == null || DEBUGGING_STR.toLowerCase().equals(\"true\")));\n        engine.setMaxReads(Integer.parseInt(MAX_READS_ARG));\n\n        //LocusWalker<Integer,Integer> walker = new PileupWalker();\n        engine.initialize();\n        try {\n            LocusWalker<?, ?> walker = (LocusWalker<?, ?>)MODULES.get(Analysis_Name);\n            engine.traverseByLoci(walker);\n        }\n        catch ( java.lang.ClassCastException e ) {\n            // I guess we're a read walker LOL\n            ReadWalker<?, ?> walker = (ReadWalker<?, ?>)MODULES.get(Analysis_Name);\n            engine.traverseByRead(walker);\n        }\n\n        return 0;\n    }","id":98312,"modified_method":"protected int doWork() {\n        final boolean TEST_ROD = false;\n        ReferenceOrderedData[] rods = null;\n\n        if ( TEST_ROD ) {\n            ReferenceOrderedData gff = new ReferenceOrderedData(new File(\"trunk/data/gFFTest.gff\"), rodGFF.class );\n            gff.testMe();\n\n            //ReferenceOrderedData dbsnp = new ReferenceOrderedData(new File(\"trunk/data/dbSNP_head.txt\"), rodDbSNP.class );\n            ReferenceOrderedData dbsnp = new ReferenceOrderedData(new File(\"/Volumes/Users/mdepristo/broad/ATK/exampleSAMs/dbSNP_chr20.txt\"), rodDbSNP.class );\n            //dbsnp.testMe();\n            rods = new ReferenceOrderedData[] { dbsnp }; // { gff, dbsnp };\n        }\n        else {\n            rods = new ReferenceOrderedData[] {}; // { gff, dbsnp };\n        }\n\n        this.engine = new TraversalEngine(INPUT_FILE, REF_FILE_ARG, rods);\n\n        ValidationStringency strictness;\n    \tif ( STRICTNESS_ARG == null ) {\n            strictness = ValidationStringency.STRICT;\n    \t}\n    \telse if ( STRICTNESS_ARG.toLowerCase().equals(\"lenient\") ) {\n    \t\tstrictness = ValidationStringency.LENIENT;\n    \t}\n    \telse if ( STRICTNESS_ARG.toLowerCase().equals(\"silent\") ) {\n    \t\tstrictness = ValidationStringency.SILENT;\n    \t}\n    \telse {\n            strictness = ValidationStringency.STRICT;\n    \t}\n        System.err.println(\"Strictness is \" + strictness);\n        engine.setStrictness(strictness);\n\n        engine.setDebugging(! ( DEBUGGING_STR == null || DEBUGGING_STR.toLowerCase().equals(\"true\")));\n        engine.setMaxReads(Integer.parseInt(MAX_READS_ARG));\n\n        //LocusWalker<Integer,Integer> walker = new PileupWalker();\n        engine.initialize();\n        try {\n            LocusWalker<?, ?> walker = (LocusWalker<?, ?>)MODULES.get(Analysis_Name);\n            engine.traverseByLoci(walker);\n        }\n        catch ( java.lang.ClassCastException e ) {\n            // I guess we're a read walker LOL\n            ReadWalker<?, ?> walker = (ReadWalker<?, ?>)MODULES.get(Analysis_Name);\n            engine.traverseByRead(walker);\n        }\n\n        return 0;\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(char ref, LocusIterator context) {\n        return 1;\n    }","id":98313,"modified_method":"public Integer map(List<ReferenceOrderedDatum> rodData, char ref, LocusIterator context) {\n        return 1;\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean filter(char ref, LocusIterator context) {\n        return true;    // We are keeping all the reads\n    }","id":98314,"modified_method":"public boolean filter(List<ReferenceOrderedDatum> rodData, char ref, LocusIterator context) {\n        return true;    // We are keeping all the reads\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean filter(char ref, LocusIterator context) {\n        return true;    // We are keeping all the reads\n    }","id":98315,"modified_method":"public boolean filter(List<ReferenceOrderedDatum> rodData, char ref, LocusIterator context) {\n        return true;    // We are keeping all the reads\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(char ref, LocusIterator context) {\n        //System.out.printf(\"Reads %s:%d %d%n\", context.getContig(), context.getPosition(), context.getReads().size());\n        //for ( SAMRecord read : context.getReads() ) {\n        //    System.out.println(\"  -> \" + read.getReadName());\n        //}\n\n        List<SAMRecord> reads = context.getReads();\n        List<Integer> offsets = context.getOffsets();\n        String bases = \"\";\n        String quals = \"\";\n        //String offsetString = \"\";\n        for ( int i = 0; i < reads.size(); i++ ) {\n            SAMRecord read = reads.get(i);\n            int offset = offsets.get(i);\n\n            //if ( offset >= read.getReadString().length() )\n            //    System.out.printf(\"  [%2d] [%s] %s%n\", offset, read.format(), read.getReadString());\n\n            bases += read.getReadString().charAt(offset);\n            quals += read.getBaseQualityString().charAt(offset);\n            //offsetString += i;\n            //System.out.printf(\"  [%2d] [%s] %s%n\", offset, read.getReadString().charAt(offset), read.getReadString());\n        }\n\n        if ( context.getPosition() % 10 == 0 )\n            System.out.printf(\"%s:%d: %s %s %s%n\", context.getContig(), context.getPosition(), ref, bases, quals);\n\n        //for ( int offset : context.getOffsets() ) {\n        //    System.out.println(\"  -> \" + read.getReadName());\n        //}\n        return 1;\n    }","id":98316,"modified_method":"public Integer map(List<ReferenceOrderedDatum> rodData, char ref, LocusIterator context) {\n        //System.out.printf(\"Reads %s:%d %d%n\", context.getContig(), context.getPosition(), context.getReads().size());\n        //for ( SAMRecord read : context.getReads() ) {\n        //    System.out.println(\"  -> \" + read.getReadName());\n        //}\n\n        List<SAMRecord> reads = context.getReads();\n        List<Integer> offsets = context.getOffsets();\n        String bases = \"\";\n        String quals = \"\";\n        //String offsetString = \"\";\n        for ( int i = 0; i < reads.size(); i++ ) {\n            SAMRecord read = reads.get(i);\n            int offset = offsets.get(i);\n\n            //if ( offset >= read.getReadString().length() )\n            //    System.out.printf(\"  [%2d] [%s] %s%n\", offset, read.format(), read.getReadString());\n\n            bases += read.getReadString().charAt(offset);\n            quals += read.getBaseQualityString().charAt(offset);\n            //offsetString += i;\n            //System.out.printf(\"  [%2d] [%s] %s%n\", offset, read.getReadString().charAt(offset), read.getReadString());\n        }\n\n        String rodString = \"\";\n        for ( ReferenceOrderedDatum datum : rodData ) {\n            if ( datum != null ) {\n                rodString += datum.toSimpleString();\n            }\n        }\n        if ( rodString != \"\" )\n            rodString = \"[ROD: \" + rodString + \"]\";\n\n        if ( context.getPosition() % 1 == 0 ) {\n            System.out.printf(\"%s:%d: %s %s %s %s%n\", context.getContig(), context.getPosition(), ref, bases, quals, rodString);\n        }\n\n        //for ( int offset : context.getOffsets() ) {\n        //    System.out.println(\"  -> \" + read.getReadName());\n        //}\n        return 1;\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ReferenceOrderedData(File file) {\n        this.file = file;\n    }","id":98317,"modified_method":"public ReferenceOrderedData(File file, Class<ROD> type ) {\n        this.file = file;\n        this.type = type;\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"ReferenceOrderedDatum parseGFFLine(final String[] parts) {\n        //System.out.printf(\"Parsing GFFLine %s%n\", Utils.join(\" \", parts));\n\n        final String contig = parts[0];\n        final String source = parts[1];\n        final String feature = parts[2];\n        final long start = Long.parseLong(parts[3]);\n        final long stop = Long.parseLong(parts[4]);\n\n        double score = Double.NaN;\n        if ( ! parts[5].equals(\".\") )\n            score = Double.parseDouble(parts[5]);\n\n        final String strand = parts[6];\n        final String frame = parts[7];\n        HashMap<String, String> attributes = null;\n        return new ReferenceOrderedDatum(contig, source, feature, start, stop, score, strand, frame, attributes);\n    }","id":98318,"modified_method":"ROD parseLine(final String[] parts) {\n        //System.out.printf(\"Parsing GFFLine %s%n\", Utils.join(\" \", parts));\n        try {\n            ROD obj = type.newInstance();\n            obj.parseLine(parts);\n            return obj;\n        } catch ( java.lang.InstantiationException e ) {\n            System.out.println(e);\n            return null; // wow, unsafe!\n        } catch ( java.lang.IllegalAccessException e ) {\n            System.out.println(e);\n            return null; // wow, unsafe!\n        }       \n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ReferenceOrderedDatum next() {\n            String parts[] = parser.next();\n            return parseGFFLine(parts);\n        }","id":98319,"modified_method":"public ROD next() {\n            prev = it.next();\n            return prev; \n        }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public RODIterator iterator() {\n        return new RODIterator();\n    }","id":98320,"modified_method":"public RODIterator iterator() {\n        return new RODIterator(new SimpleRODIterator());\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public RODIterator() {\n            parser = new TabbedTextFileParser(true, file);\n        }","id":98321,"modified_method":"public RODIterator(SimpleRODIterator it) {\n            this.it = new PushbackIterator<ROD>(it);\n        }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean hasNext() {\n            return parser.hasNext();\n        }","id":98322,"modified_method":"public boolean hasNext() { return it.hasNext(); }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String getContig() {\n        return this.contig;\n    }","id":98323,"modified_method":"public abstract String getContig();","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public long getStart() {\n        return start;\n    }","id":98324,"modified_method":"public abstract long getStart();","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public long getStop() {\n        return stop;\n    }","id":98325,"modified_method":"public abstract long getStop();","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String toString() {\n        return String.format(\"%s\\t%s\\t%s\\t%d\\t%d\\t%f\\t%s\\t%s\", contig, source, feature, start, stop, score, strand, frame);\n    }","id":98326,"modified_method":"public abstract String toString();","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"public TraversalEngine(File reads, File ref) {\n        readsFile = reads;\n        refFileName = ref;\n    }","id":98327,"modified_method":"public TraversalEngine(File reads, File ref, ReferenceOrderedData[] rods ) {\n        readsFile = reads;\n        refFileName = ref;\n        this.rods = Arrays.asList(rods);\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected <M,T> int traverseByLoci(LocusWalker<M,T> walker) {\n        walker.initialize();\n        FilteringIterator filterIter = new FilteringIterator(readStream.iterator(), new locusStreamFilterFunc());\n        CloseableIterator<LocusIterator> iter = new LocusIterator(filterIter);\n\n        T sum = walker.reduceInit();\n        while ( iter.hasNext() ) {\n            this.nRecords++;\n\n            // actually get the read and hand it to the walker\n            final LocusIterator locus = iter.next();\n            final ReferenceIterator refSite = refIter.seekForward(locus.getContig(), locus.getPosition());\n            final char refBase = refSite.getBaseAsChar();\n\n            if ( DEBUGGING )\n                System.out.printf(\"  Reference: %s:%d %c%n\", refSite.getCurrentContig().getName(), refSite.getPosition(), refBase);\n\n            final boolean keepMeP = walker.filter(refBase, locus);\n            if ( keepMeP ) {\n                M x = walker.map(refBase, locus);\n                sum = walker.reduce(x, sum);\n            }\n\n            if ( this.maxReads > 0 && this.nRecords > this.maxReads ) {\n                System.out.println(\"Maximum number of reads encountered, terminating traversal \" + this.nRecords);\n                break;\n            }\n\n            printProgress(\"loci\");\n        }\n\n        printProgress( true, \"loci\" );\n        System.out.println(\"Traversal reduce result is \" + sum);\n        System.out.printf(\"Traversal skipped %d reads out of %d total (%.2f%%)%n\", nSkippedReads, nReads, (nSkippedReads * 100.0) / nReads);\n        System.out.printf(\"  -> %d unmapped reads%n\", nUnmappedReads );\n        System.out.printf(\"  -> %d non-primary reads%n\", nNotPrimary );\n        System.out.printf(\"  -> %d reads with bad alignments%n\", nBadAlignments );\n        System.out.printf(\"  -> %d reads with indels%n\", nSkippedIndels );\n        walker.onTraveralDone();\n        return 0;\n    }","id":98328,"modified_method":"protected <M,T> int traverseByLoci(LocusWalker<M,T> walker) {\n        walker.initialize();\n        FilteringIterator filterIter = new FilteringIterator(readStream.iterator(), new locusStreamFilterFunc());\n        CloseableIterator<LocusIterator> iter = new LocusIterator(filterIter);\n\n        List<ReferenceOrderedData.RODIterator> rodIters = initializeRODs();\n\n        T sum = walker.reduceInit();\n        while ( iter.hasNext() ) {\n            this.nRecords++;\n\n            // actually get the read and hand it to the walker\n            final LocusIterator locus = iter.next();\n            final ReferenceIterator refSite = refIter.seekForward(locus.getContig(), locus.getPosition());\n            final char refBase = refSite.getBaseAsChar();\n            final List<ReferenceOrderedDatum> rodData = getReferenceOrderedDataAtLocus(rodIters, locus.getContig(), locus.getPosition());\n\n            if ( DEBUGGING )\n                System.out.printf(\"  Reference: %s:%d %c%n\", refSite.getCurrentContig().getName(), refSite.getPosition(), refBase);\n\n            final boolean keepMeP = walker.filter(rodData, refBase, locus);\n            if ( keepMeP ) {\n                M x = walker.map(rodData, refBase, locus);\n                sum = walker.reduce(x, sum);\n            }\n\n            if ( this.maxReads > 0 && this.nRecords > this.maxReads ) {\n                System.out.println(\"Maximum number of reads encountered, terminating traversal \" + this.nRecords);\n                break;\n            }\n\n            printProgress(\"loci\");\n        }\n\n        printProgress( true, \"loci\" );\n        System.out.println(\"Traversal reduce result is \" + sum);\n        System.out.printf(\"Traversal skipped %d reads out of %d total (%.2f%%)%n\", nSkippedReads, nReads, (nSkippedReads * 100.0) / nReads);\n        System.out.printf(\"  -> %d unmapped reads%n\", nUnmappedReads );\n        System.out.printf(\"  -> %d non-primary reads%n\", nNotPrimary );\n        System.out.printf(\"  -> %d reads with bad alignments%n\", nBadAlignments );\n        System.out.printf(\"  -> %d reads with indels%n\", nSkippedIndels );\n        walker.onTraveralDone();\n        return 0;\n    }","commit_id":"f64f3e2d90f6962de3d7db86f05e4cfc6c7f0f43","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Inject\n  public DefaultCommands(Injector injector) {\n    this.commands = ImmutableList.<Command>builder()\n      .add(injector.getInstance(VersionCommand.class))\n      .add(injector.getInstance(ExitCommand.class))\n      .add(injector.getInstance(CallProcedureCommand.class))\n      .add(injector.getInstance(ConnectCommand.class))\n      .add(injector.getInstance(CreateDatasetInstanceCommand.class))\n      .add(injector.getInstance(CreateStreamCommand.class))\n      .add(injector.getInstance(DeleteAppCommand.class))\n      .add(injector.getInstance(DeleteDatasetInstanceCommand.class))\n      .add(injector.getInstance(DeleteDatasetModuleCommand.class))\n      .add(injector.getInstance(DeployAppCommand.class))\n      .add(injector.getInstance(DeployDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeAppCommand.class))\n      .add(injector.getInstance(DescribeDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeDatasetTypeCommand.class))\n      .add(injector.getInstance(DescribeStreamCommand.class))\n      .add(injector.getInstance(ExecuteQueryCommand.class))\n      .addAll(injector.getInstance(GetProgramRunsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramInstancesCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLiveInfoCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLogsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramStatusCommandSet.class).getCommands())\n      .add(injector.getInstance(GetStreamEventsCommand.class))\n      .add(injector.getInstance(ListAllProgramsCommand.class))\n      .add(injector.getInstance(ListAppsCommand.class))\n      .add(injector.getInstance(ListDatasetInstancesCommand.class))\n      .add(injector.getInstance(ListDatasetModulesCommand.class))\n      .add(injector.getInstance(ListDatasetTypesCommand.class))\n      .addAll(injector.getInstance(ListProgramsCommandSet.class).getCommands())\n      .add(injector.getInstance(ListStreamsCommand.class))\n      .add(injector.getInstance(SendStreamEventCommand.class))\n      .addAll(injector.getInstance(SetProgramInstancesCommandSet.class).getCommands())\n      .add(injector.getInstance(SetStreamTTLCommand.class))\n      .addAll(injector.getInstance(StartProgramCommandSet.class).getCommands())\n      .addAll(injector.getInstance(StopProgramCommandSet.class).getCommands())\n      .add(injector.getInstance(TruncateDatasetInstanceCommand.class))\n      .add(injector.getInstance(TruncateStreamCommand.class))\n      .add(injector.getInstance(CallServiceCommand.class))\n      .add(injector.getInstance(GetServiceEndpointsCommand.class))\n      .build();\n  }","id":98329,"modified_method":"@Inject\n  public DefaultCommands(Injector injector) {\n    this.commands = ImmutableList.<Command>builder()\n      .add(injector.getInstance(VersionCommand.class))\n      .add(injector.getInstance(ExitCommand.class))\n      .add(injector.getInstance(CallProcedureCommand.class))\n      .add(injector.getInstance(ConnectCommand.class))\n      .add(injector.getInstance(CreateDatasetInstanceCommand.class))\n      .add(injector.getInstance(CreateStreamCommand.class))\n      .add(injector.getInstance(DeleteAppCommand.class))\n      .add(injector.getInstance(DeleteDatasetInstanceCommand.class))\n      .add(injector.getInstance(DeleteDatasetModuleCommand.class))\n      .add(injector.getInstance(DeployAppCommand.class))\n      .add(injector.getInstance(DeployDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeAppCommand.class))\n      .add(injector.getInstance(DescribeDatasetModuleCommand.class))\n      .add(injector.getInstance(DescribeDatasetTypeCommand.class))\n      .add(injector.getInstance(DescribeStreamCommand.class))\n      .add(injector.getInstance(ExecuteQueryCommand.class))\n      .addAll(injector.getInstance(GetProgramRunsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramInstancesCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLiveInfoCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramLogsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramStatusCommandSet.class).getCommands())\n      .addAll(injector.getInstance(GetProgramRuntimeArgsCommandSet.class).getCommands())\n      .addAll(injector.getInstance(SetProgramRuntimeArgsCommandSet.class).getCommands())\n      .add(injector.getInstance(GetStreamEventsCommand.class))\n      .add(injector.getInstance(ListAllProgramsCommand.class))\n      .add(injector.getInstance(ListAppsCommand.class))\n      .add(injector.getInstance(ListDatasetInstancesCommand.class))\n      .add(injector.getInstance(ListDatasetModulesCommand.class))\n      .add(injector.getInstance(ListDatasetTypesCommand.class))\n      .addAll(injector.getInstance(ListProgramsCommandSet.class).getCommands())\n      .add(injector.getInstance(ListStreamsCommand.class))\n      .add(injector.getInstance(SendStreamEventCommand.class))\n      .addAll(injector.getInstance(SetProgramInstancesCommandSet.class).getCommands())\n      .add(injector.getInstance(SetStreamTTLCommand.class))\n      .addAll(injector.getInstance(StartProgramCommandSet.class).getCommands())\n      .addAll(injector.getInstance(StopProgramCommandSet.class).getCommands())\n      .add(injector.getInstance(TruncateDatasetInstanceCommand.class))\n      .add(injector.getInstance(TruncateStreamCommand.class))\n      .add(injector.getInstance(CallServiceCommand.class))\n      .add(injector.getInstance(GetServiceEndpointsCommand.class))\n      .build();\n  }","commit_id":"056b34e16b001adbb27f52d40fd734181ce924aa","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure() {\n    setName(NAME);\n    addStream(new Stream(STREAM_NAME));\n    addDatasetModule(FakeDatasetModule.NAME, FakeDatasetModule.class);\n    createDataset(DS_NAME, FakeDataset.class.getName());\n    addProcedure(new FakeProcedure());\n    addFlow(new FakeFlow());\n    addSpark(new FakeSpark());\n    addService(EchoHandler.NAME, new EchoHandler());\n  }","id":98330,"modified_method":"@Override\n  public void configure() {\n    setName(NAME);\n    addStream(new Stream(STREAM_NAME));\n    addDatasetModule(FakeDatasetModule.NAME, FakeDatasetModule.class);\n    createDataset(DS_NAME, FakeDataset.class.getName());\n    addProcedure(new FakeProcedure());\n    addFlow(new FakeFlow());\n    addSpark(new FakeSpark());\n    addService(PrefixedEchoHandler.NAME, new PrefixedEchoHandler());\n  }","commit_id":"056b34e16b001adbb27f52d40fd734181ce924aa","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Starts a program.\n   *\n   * @param appId ID of the application that the program belongs to\n   * @param programType type of the program\n   * @param programName name of the program\n   * @throws IOException if a network error occurred\n   * @throws ProgramNotFoundException if the program with the specified name could not be found\n   * @throws UnAuthorizedAccessTokenException if the request is not authorized successfully in the gateway server\n   */\n  public void start(String appId, ProgramType programType, String programName)\n    throws IOException, ProgramNotFoundException, UnAuthorizedAccessTokenException {\n\n    URL url = config.resolveURL(String.format(\"apps/%s/%s/%s/start\",\n                                              appId, programType.getCategoryName(), programName));\n    HttpResponse response = restClient.execute(HttpMethod.POST, url, config.getAccessToken(),\n                                               HttpURLConnection.HTTP_NOT_FOUND);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new ProgramNotFoundException(programType, appId, programName);\n    }\n  }","id":98331,"modified_method":"/**\n   * Starts a program using the stored runtime arguments.\n   *\n   * @param appId ID of the application that the program belongs to\n   * @param programType type of the program\n   * @param programName name of the program\n   * @throws IOException if a network error occurred\n   * @throws ProgramNotFoundException if the program with the specified name could not be found\n   * @throws UnAuthorizedAccessTokenException if the request is not authorized successfully in the gateway server\n   */\n  public void start(String appId, ProgramType programType, String programName)\n    throws IOException, ProgramNotFoundException, UnAuthorizedAccessTokenException {\n\n    URL url = config.resolveURL(String.format(\"apps/%s/%s/%s/start\",\n                                              appId, programType.getCategoryName(), programName));\n    HttpRequest request = HttpRequest.post(url).build();\n    HttpResponse response = restClient.execute(request, config.getAccessToken(), HttpURLConnection.HTTP_NOT_FOUND);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new ProgramNotFoundException(programType, appId, programName);\n    }\n  }","commit_id":"056b34e16b001adbb27f52d40fd734181ce924aa","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void setUpClass() throws Throwable {\n    testStackIndex++;\n    if (standaloneMain == null) {\n      try {\n        CConfiguration cConf = CConfiguration.create();\n        cConf.set(Constants.CFG_LOCAL_DATA_DIR, tmpFolder.newFolder().getAbsolutePath());\n\n        // Start without UI\n        standaloneMain = StandaloneMain.create(null, cConf, new Configuration());\n        standaloneMain.startUp();\n      } catch (Throwable e) {\n        LOG.error(\"Failed to start standalone\", e);\n        if (standaloneMain != null) {\n          standaloneMain.shutDown();\n        }\n        throw e;\n      }\n    }\n  }","id":98332,"modified_method":"@BeforeClass\n  public static void setUpClass() throws Exception {\n    testStackIndex++;\n    if (standaloneMain == null) {\n      try {\n        CConfiguration cConf = CConfiguration.create();\n        cConf.set(Constants.CFG_LOCAL_DATA_DIR, tmpFolder.newFolder().getAbsolutePath());\n\n        // Start without UI\n        standaloneMain = StandaloneMain.create(null, cConf, new Configuration());\n        standaloneMain.startUp();\n      } catch (Exception e) {\n        LOG.error(\"Failed to start standalone\", e);\n        if (standaloneMain != null) {\n          standaloneMain.shutDown();\n        }\n        throw e;\n      }\n    }\n  }","commit_id":"056b34e16b001adbb27f52d40fd734181ce924aa","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String getPattern() {\n    return String.format(\"start %s <%s>\", elementType.getName(), elementType.getArgumentName());\n  }","id":98333,"modified_method":"@Override\n  public String getPattern() {\n    return String.format(\"start %s <%s> [<%s>]\", elementType.getName(), elementType.getArgumentName(),\n                         ArgumentName.RUNTIME_ARGS);\n  }","commit_id":"056b34e16b001adbb27f52d40fd734181ce924aa","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String getDescription() {\n    return \"Starts a \" + elementType.getPrettyName();\n  }","id":98334,"modified_method":"@Override\n  public String getDescription() {\n    return \"Starts a \" + elementType.getPrettyName() + \".\" +\n      \" <\" + ArgumentName.RUNTIME_ARGS + \"> is specified in the format \\\"key1=a key2=b\\\"\";\n  }","commit_id":"056b34e16b001adbb27f52d40fd734181ce924aa","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void execute(Arguments arguments, PrintStream output) throws Exception {\n    String[] programIdParts = arguments.get(elementType.getArgumentName().toString()).split(\"\\\\.\");\n    if (programIdParts.length < 2) {\n      throw new CommandInputError(this);\n    }\n\n    String appId = programIdParts[0];\n    String programId = programIdParts[1];\n\n    programClient.start(appId, elementType.getProgramType(), programId);\n    output.printf(\"Successfully started %s '%s' of application '%s'\\n\", elementType.getPrettyName(), programId, appId);\n  }","id":98335,"modified_method":"@Override\n  public void execute(Arguments arguments, PrintStream output) throws Exception {\n    String[] programIdParts = arguments.get(elementType.getArgumentName().toString()).split(\"\\\\.\");\n    if (programIdParts.length < 2) {\n      throw new CommandInputError(this);\n    }\n\n    String appId = programIdParts[0];\n    String programId = programIdParts[1];\n\n    String runtimeArgsString = arguments.get(ArgumentName.RUNTIME_ARGS.toString(), \"\");\n    if (runtimeArgsString == null || runtimeArgsString.isEmpty()) {\n      // run with stored runtime args\n      programClient.start(appId, elementType.getProgramType(), programId);\n      runtimeArgsString = GSON.toJson(programClient.getRuntimeArgs(appId, elementType.getProgramType(), programId));\n      output.printf(\"Successfully started %s '%s' of application '%s' with stored runtime arguments '%s'\\n\",\n                    elementType.getPrettyName(), programId, appId, runtimeArgsString);\n    } else {\n      // run with user-provided runtime args\n      Map<String, String> runtimeArgs = Splitter.on(\" \").withKeyValueSeparator(\"=\").split(runtimeArgsString);\n      programClient.start(appId, elementType.getProgramType(), programId, runtimeArgs);\n      output.printf(\"Successfully started %s '%s' of application '%s' with provided runtime arguments '%s'\\n\",\n                    elementType.getPrettyName(), programId, appId, runtimeArgsString);\n    }\n\n  }","commit_id":"056b34e16b001adbb27f52d40fd734181ce924aa","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tString path = uri.getPath();\n\t\t\n\t\tif (!path.startsWith(ROOT_URL)) {\n\t\t\t// we should never get any other path anyway\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tpath = path.substring(ROOT_URL.length());\n\t\t} catch (IndexOutOfBoundsException ioobe) {\n\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// be very strict about what characters we allow in the path, since\n\t\tif (!path.matches(\"^[A-Za-z0-9\\\\._\\\\/\\\\-]*$\") || (path.indexOf(\"..\") != -1)) {\n\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathInvalidChars\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tInputStream strm = getClass().getResourceAsStream(ROOT_PATH+path);\n\t\tif (strm == null) {\n\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\treturn;\n\t\t}\n\t\tBucket data = ctx.getBucketFactory().makeBucket(strm.available());\n\t\tOutputStream os = data.getOutputStream();\n\t\tbyte[] cbuf = new byte[4096];\n\t\twhile(true) {\n\t\t\tint r = strm.read(cbuf);\n\t\t\tif(r == -1) break;\n\t\t\tos.write(cbuf, 0, r);\n\t\t}\n\t\tstrm.close();\n\t\tos.close();\n\t\t\n\t\tString mimeType = DefaultMIMETypes.guessMIMEType(path, false);\n\t\t\n\t\tif(mimeType.equals(\"text/css\")) {\n\t\t\t// Easiest way to fix the links is just to pass it through the content filter.\n\t\t\tFilterOutput fo = ContentFilter.filter(data, ctx.getBucketFactory(), mimeType, uri, null, container);\n\t\t\tdata.free();\n\t\t\tdata = fo.data;\n\t\t}\n\t\t\n\t\tURL url = getClass().getResource(ROOT_PATH+path);\n\t\tDate mTime = getUrlMTime(url);\n\t\t\n\t\tctx.sendReplyHeaders(200, \"OK\", null, mimeType, data.size(), mTime);\n\n\t\tctx.writeData(data);\n\t\tdata.free();\n\t}","id":98336,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tString path = uri.getPath();\n\t\t\n\t\tif (!path.startsWith(ROOT_URL)) {\n\t\t\t// we should never get any other path anyway\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tpath = path.substring(ROOT_URL.length());\n\t\t} catch (IndexOutOfBoundsException ioobe) {\n\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// be very strict about what characters we allow in the path, since\n\t\tif (!path.matches(\"^[A-Za-z0-9\\\\._\\\\/\\\\-]*$\") || (path.indexOf(\"..\") != -1)) {\n\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathInvalidChars\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tInputStream strm = getClass().getResourceAsStream(ROOT_PATH+path);\n\t\tif (strm == null) {\n\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\treturn;\n\t\t}\n\t\tBucket data = ctx.getBucketFactory().makeBucket(strm.available());\n\t\tOutputStream os = data.getOutputStream();\n\t\tbyte[] cbuf = new byte[4096];\n\t\twhile(true) {\n\t\t\tint r = strm.read(cbuf);\n\t\t\tif(r == -1) break;\n\t\t\tos.write(cbuf, 0, r);\n\t\t}\n\t\tstrm.close();\n\t\tos.close();\n\t\t\n\t\tString mimeType = DefaultMIMETypes.guessMIMEType(path, false);\n\t\t\n\t\tif(mimeType.equals(\"text/css\")) {\n\t\t\t// Easiest way to fix the links is just to pass it through the content filter.\n\t\t\tFilterOutput fo = ContentFilter.filter(data, ctx.getBucketFactory(), mimeType, uri, null, container);\n\t\t\tif(data != fo.data)\n\t\t\t\tdata.free();\n\t\t\tdata = fo.data;\n\t\t}\n\t\t\n\t\tURL url = getClass().getResource(ROOT_PATH+path);\n\t\tDate mTime = getUrlMTime(url);\n\t\t\n\t\tctx.sendReplyHeaders(200, \"OK\", null, mimeType, data.size(), mTime);\n\n\t\tctx.writeData(data);\n\t\tdata.free();\n\t}","commit_id":"c4b86e92e3161066a836956375adfd21cbe85a43","url":"https://github.com/freenet/fred"},{"original_method":"@SuppressWarnings({\"unchecked\"})\n    @Inject public RabbitmqRiver(RiverName riverName, RiverSettings settings, Client client) {\n        super(riverName, settings);\n        this.client = client;\n\n        if (settings.settings().containsKey(\"rabbitmq\")) {\n            Map<String, Object> rabbitSettings = (Map<String, Object>) settings.settings().get(\"rabbitmq\");\n            rabbitHost = XContentMapValues.nodeStringValue(rabbitSettings.get(\"host\"), ConnectionFactory.DEFAULT_HOST);\n            rabbitPort = XContentMapValues.nodeIntegerValue(rabbitSettings.get(\"port\"), ConnectionFactory.DEFAULT_AMQP_PORT);\n            rabbitUser = XContentMapValues.nodeStringValue(rabbitSettings.get(\"user\"), ConnectionFactory.DEFAULT_USER);\n            rabbitPassword = XContentMapValues.nodeStringValue(rabbitSettings.get(\"pass\"), ConnectionFactory.DEFAULT_PASS);\n            rabbitVhost = XContentMapValues.nodeStringValue(rabbitSettings.get(\"vhost\"), ConnectionFactory.DEFAULT_VHOST);\n\n\n            rabbitQueue = XContentMapValues.nodeStringValue(rabbitSettings.get(\"queue\"), \"elasticsearch\");\n            rabbitExchange = XContentMapValues.nodeStringValue(rabbitSettings.get(\"exchange\"), \"elasticsearch\");\n            rabbitExchangeType = XContentMapValues.nodeStringValue(rabbitSettings.get(\"exchange_type\"), \"direct\");\n            rabbitRoutingKey = XContentMapValues.nodeStringValue(rabbitSettings.get(\"routing_key\"), \"elasticsearch\");\n            rabbitExchangeDurable = Boolean.valueOf(XContentMapValues.nodeStringValue(rabbitSettings.get(\"exchange_durable\"), \"true\")).booleanValue();\n            rabbitQueueDurable = Boolean.valueOf(XContentMapValues.nodeStringValue(rabbitSettings.get(\"queue_durable\"), \"true\")).booleanValue();\n            rabbitQueueAutoDelete = Boolean.valueOf(XContentMapValues.nodeStringValue(rabbitSettings.get(\"queue_auto_delete\"), \"false\")).booleanValue();\n        } else {\n            rabbitHost = ConnectionFactory.DEFAULT_HOST;\n            rabbitPort = ConnectionFactory.DEFAULT_AMQP_PORT;\n            rabbitUser = ConnectionFactory.DEFAULT_USER;\n            rabbitPassword = ConnectionFactory.DEFAULT_PASS;\n            rabbitVhost = ConnectionFactory.DEFAULT_VHOST;\n\n            rabbitQueue = \"elasticsearch\";\n            rabbitQueueAutoDelete = false;\n            rabbitQueueDurable = true;\n            rabbitExchange = \"elasticsearch\";\n            rabbitExchangeType = \"direct\";\n            rabbitExchangeDurable = true;\n            rabbitRoutingKey = \"elasticsearch\";\n        }\n\n        if (settings.settings().containsKey(\"index\")) {\n            Map<String, Object> indexSettings = (Map<String, Object>) settings.settings().get(\"index\");\n            bulkSize = XContentMapValues.nodeIntegerValue(indexSettings.get(\"bulk_size\"), 100);\n            if (indexSettings.containsKey(\"bulk_timeout\")) {\n                bulkTimeout = TimeValue.parseTimeValue(XContentMapValues.nodeStringValue(indexSettings.get(\"bulk_timeout\"), \"10ms\"), TimeValue.timeValueMillis(10));\n            } else {\n                bulkTimeout = TimeValue.timeValueMillis(10);\n            }\n            ordered = XContentMapValues.nodeBooleanValue(indexSettings.get(\"ordered\"), false);\n        } else {\n            bulkSize = 100;\n            bulkTimeout = TimeValue.timeValueMillis(10);\n            ordered = false;\n        }\n    }","id":98337,"modified_method":"@SuppressWarnings({\"unchecked\"})\n    @Inject public RabbitmqRiver(RiverName riverName, RiverSettings settings, Client client) {\n        super(riverName, settings);\n        this.client = client;\n\n        if (settings.settings().containsKey(\"rabbitmq\")) {\n            Map<String, Object> rabbitSettings = (Map<String, Object>) settings.settings().get(\"rabbitmq\");\n            rabbitHost = XContentMapValues.nodeStringValue(rabbitSettings.get(\"host\"), ConnectionFactory.DEFAULT_HOST);\n            rabbitPort = XContentMapValues.nodeIntegerValue(rabbitSettings.get(\"port\"), ConnectionFactory.DEFAULT_AMQP_PORT);\n            rabbitUser = XContentMapValues.nodeStringValue(rabbitSettings.get(\"user\"), ConnectionFactory.DEFAULT_USER);\n            rabbitPassword = XContentMapValues.nodeStringValue(rabbitSettings.get(\"pass\"), ConnectionFactory.DEFAULT_PASS);\n            rabbitVhost = XContentMapValues.nodeStringValue(rabbitSettings.get(\"vhost\"), ConnectionFactory.DEFAULT_VHOST);\n\n\n            rabbitQueue = XContentMapValues.nodeStringValue(rabbitSettings.get(\"queue\"), \"elasticsearch\");\n            rabbitExchange = XContentMapValues.nodeStringValue(rabbitSettings.get(\"exchange\"), \"elasticsearch\");\n            rabbitExchangeType = XContentMapValues.nodeStringValue(rabbitSettings.get(\"exchange_type\"), \"direct\");\n            rabbitRoutingKey = XContentMapValues.nodeStringValue(rabbitSettings.get(\"routing_key\"), \"elasticsearch\");\n            rabbitExchangeDurable = XContentMapValues.nodeBooleanValue(rabbitSettings.get(\"exchange_durable\"), true);\n            rabbitQueueDurable = XContentMapValues.nodeBooleanValue(rabbitSettings.get(\"queue_durable\"), true);\n            rabbitQueueAutoDelete = XContentMapValues.nodeBooleanValue(rabbitSettings.get(\"queue_auto_delete\"), false);\n        } else {\n            rabbitHost = ConnectionFactory.DEFAULT_HOST;\n            rabbitPort = ConnectionFactory.DEFAULT_AMQP_PORT;\n            rabbitUser = ConnectionFactory.DEFAULT_USER;\n            rabbitPassword = ConnectionFactory.DEFAULT_PASS;\n            rabbitVhost = ConnectionFactory.DEFAULT_VHOST;\n\n            rabbitQueue = \"elasticsearch\";\n            rabbitQueueAutoDelete = false;\n            rabbitQueueDurable = true;\n            rabbitExchange = \"elasticsearch\";\n            rabbitExchangeType = \"direct\";\n            rabbitExchangeDurable = true;\n            rabbitRoutingKey = \"elasticsearch\";\n        }\n\n        if (settings.settings().containsKey(\"index\")) {\n            Map<String, Object> indexSettings = (Map<String, Object>) settings.settings().get(\"index\");\n            bulkSize = XContentMapValues.nodeIntegerValue(indexSettings.get(\"bulk_size\"), 100);\n            if (indexSettings.containsKey(\"bulk_timeout\")) {\n                bulkTimeout = TimeValue.parseTimeValue(XContentMapValues.nodeStringValue(indexSettings.get(\"bulk_timeout\"), \"10ms\"), TimeValue.timeValueMillis(10));\n            } else {\n                bulkTimeout = TimeValue.timeValueMillis(10);\n            }\n            ordered = XContentMapValues.nodeBooleanValue(indexSettings.get(\"ordered\"), false);\n        } else {\n            bulkSize = 100;\n            bulkTimeout = TimeValue.timeValueMillis(10);\n            ordered = false;\n        }\n    }","commit_id":"a4978bc67e6bace384bd9cc8620aa83b82e0d6b4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void run() {\n            while (true) {\n                if (closed) {\n                    return;\n                }\n                try {\n                    connection = connectionFactory.newConnection();\n                    channel = connection.createChannel();\n                } catch (Exception e) {\n                    if (!closed) {\n                        logger.warn(\"failed to created a connection / channel\", e);\n                    } else {\n                        continue;\n                    }\n                    cleanup(0, \"failed to connect\");\n                    try {\n                        Thread.sleep(5000);\n                    } catch (InterruptedException e1) {\n                        // ignore, if we are closing, we will exit later\n                    }\n                }\n\n                QueueingConsumer consumer = new QueueingConsumer(channel);\n                // define the queue\n                try {\n                    channel.exchangeDeclare(rabbitExchange/*exchange*/, rabbitExchangeType/*type*/, true /*durable*/);\n                    channel.queueDeclare(rabbitQueue/*queue*/, rabbitQueueDurable/*durable*/, false/*exclusive*/, rabbitQueueAutoDelete/*autoDelete*/, null);\n                    channel.queueBind(rabbitQueue/*queue*/, rabbitExchange/*exchange*/, rabbitRoutingKey/*routingKey*/);\n                    channel.basicConsume(rabbitQueue/*queue*/, false/*noAck*/, consumer);\n                } catch (Exception e) {\n                    if (!closed) {\n                        logger.warn(\"failed to create queue [{}]\", e, rabbitQueue);\n                    }\n                    cleanup(0, \"failed to create queue\");\n                    continue;\n                }\n\n                // now use the queue to listen for messages\n                while (true) {\n                    if (closed) {\n                        break;\n                    }\n                    QueueingConsumer.Delivery task;\n                    try {\n                        task = consumer.nextDelivery();\n                    } catch (Exception e) {\n                        if (!closed) {\n                            logger.error(\"failed to get next message, reconnecting...\", e);\n                        }\n                        cleanup(0, \"failed to get message\");\n                        break;\n                    }\n\n                    if (task != null && task.getBody() != null) {\n                        final List<Long> deliveryTags = Lists.newArrayList();\n\n                        BulkRequestBuilder bulkRequestBuilder = client.prepareBulk();\n\n                        try {\n                            bulkRequestBuilder.add(task.getBody(), 0, task.getBody().length, false);\n                        } catch (Exception e) {\n                            logger.warn(\"failed to parse request for delivery tag [{}], ack'ing...\", e, task.getEnvelope().getDeliveryTag());\n                            try {\n                                channel.basicAck(task.getEnvelope().getDeliveryTag(), false);\n                            } catch (IOException e1) {\n                                logger.warn(\"failed to ack [{}]\", e1, task.getEnvelope().getDeliveryTag());\n                            }\n                            continue;\n                        }\n\n                        deliveryTags.add(task.getEnvelope().getDeliveryTag());\n\n                        if (bulkRequestBuilder.numberOfActions() < bulkSize) {\n                            // try and spin some more of those without timeout, so we have a bigger bulk (bounded by the bulk size)\n                            try {\n                                while ((task = consumer.nextDelivery(bulkTimeout.millis())) != null) {\n                                    try {\n                                        bulkRequestBuilder.add(task.getBody(), 0, task.getBody().length, false);\n                                    } catch (Exception e) {\n                                        logger.warn(\"failed to parse request for delivery tag [{}], ack'ing...\", e, task.getEnvelope().getDeliveryTag());\n                                        try {\n                                            channel.basicAck(task.getEnvelope().getDeliveryTag(), false);\n                                        } catch (IOException e1) {\n                                            logger.warn(\"failed to ack on failure [{}]\", e1, task.getEnvelope().getDeliveryTag());\n                                        }\n                                    }\n                                    deliveryTags.add(task.getEnvelope().getDeliveryTag());\n                                    if (bulkRequestBuilder.numberOfActions() >= bulkSize) {\n                                        break;\n                                    }\n                                }\n                            } catch (InterruptedException e) {\n                                if (closed) {\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"executing bulk with [{}] actions\", bulkRequestBuilder.numberOfActions());\n                        }\n\n                        if (ordered) {\n                            try {\n                                BulkResponse response = bulkRequestBuilder.execute().actionGet();\n                                if (response.hasFailures()) {\n                                    // TODO write to exception queue?\n                                    logger.warn(\"failed to execute\" + response.buildFailureMessage());\n                                }\n                                for (Long deliveryTag : deliveryTags) {\n                                    try {\n                                        channel.basicAck(deliveryTag, false);\n                                    } catch (IOException e1) {\n                                        logger.warn(\"failed to ack [{}]\", e1, deliveryTag);\n                                    }\n                                }\n                            } catch (Exception e) {\n                                logger.warn(\"failed to execute bulk\", e);\n                            }\n                        } else {\n                            bulkRequestBuilder.execute(new ActionListener<BulkResponse>() {\n                                @Override public void onResponse(BulkResponse response) {\n                                    if (response.hasFailures()) {\n                                        // TODO write to exception queue?\n                                        logger.warn(\"failed to execute\" + response.buildFailureMessage());\n                                    }\n                                    for (Long deliveryTag : deliveryTags) {\n                                        try {\n                                            channel.basicAck(deliveryTag, false);\n                                        } catch (IOException e1) {\n                                            logger.warn(\"failed to ack [{}]\", e1, deliveryTag);\n                                        }\n                                    }\n                                }\n\n                                @Override public void onFailure(Throwable e) {\n                                    logger.warn(\"failed to execute bulk for delivery tags [{}], not ack'ing\", e, deliveryTags);\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }","id":98338,"modified_method":"@Override public void run() {\n            while (true) {\n                if (closed) {\n                    return;\n                }\n                try {\n                    connection = connectionFactory.newConnection();\n                    channel = connection.createChannel();\n                } catch (Exception e) {\n                    if (!closed) {\n                        logger.warn(\"failed to created a connection / channel\", e);\n                    } else {\n                        continue;\n                    }\n                    cleanup(0, \"failed to connect\");\n                    try {\n                        Thread.sleep(5000);\n                    } catch (InterruptedException e1) {\n                        // ignore, if we are closing, we will exit later\n                    }\n                }\n\n                QueueingConsumer consumer = new QueueingConsumer(channel);\n                // define the queue\n                try {\n                    channel.exchangeDeclare(rabbitExchange/*exchange*/, rabbitExchangeType/*type*/, rabbitExchangeDurable);\n                    channel.queueDeclare(rabbitQueue/*queue*/, rabbitQueueDurable/*durable*/, false/*exclusive*/, rabbitQueueAutoDelete/*autoDelete*/, null);\n                    channel.queueBind(rabbitQueue/*queue*/, rabbitExchange/*exchange*/, rabbitRoutingKey/*routingKey*/);\n                    channel.basicConsume(rabbitQueue/*queue*/, false/*noAck*/, consumer);\n                } catch (Exception e) {\n                    if (!closed) {\n                        logger.warn(\"failed to create queue [{}]\", e, rabbitQueue);\n                    }\n                    cleanup(0, \"failed to create queue\");\n                    continue;\n                }\n\n                // now use the queue to listen for messages\n                while (true) {\n                    if (closed) {\n                        break;\n                    }\n                    QueueingConsumer.Delivery task;\n                    try {\n                        task = consumer.nextDelivery();\n                    } catch (Exception e) {\n                        if (!closed) {\n                            logger.error(\"failed to get next message, reconnecting...\", e);\n                        }\n                        cleanup(0, \"failed to get message\");\n                        break;\n                    }\n\n                    if (task != null && task.getBody() != null) {\n                        final List<Long> deliveryTags = Lists.newArrayList();\n\n                        BulkRequestBuilder bulkRequestBuilder = client.prepareBulk();\n\n                        try {\n                            bulkRequestBuilder.add(task.getBody(), 0, task.getBody().length, false);\n                        } catch (Exception e) {\n                            logger.warn(\"failed to parse request for delivery tag [{}], ack'ing...\", e, task.getEnvelope().getDeliveryTag());\n                            try {\n                                channel.basicAck(task.getEnvelope().getDeliveryTag(), false);\n                            } catch (IOException e1) {\n                                logger.warn(\"failed to ack [{}]\", e1, task.getEnvelope().getDeliveryTag());\n                            }\n                            continue;\n                        }\n\n                        deliveryTags.add(task.getEnvelope().getDeliveryTag());\n\n                        if (bulkRequestBuilder.numberOfActions() < bulkSize) {\n                            // try and spin some more of those without timeout, so we have a bigger bulk (bounded by the bulk size)\n                            try {\n                                while ((task = consumer.nextDelivery(bulkTimeout.millis())) != null) {\n                                    try {\n                                        bulkRequestBuilder.add(task.getBody(), 0, task.getBody().length, false);\n                                    } catch (Exception e) {\n                                        logger.warn(\"failed to parse request for delivery tag [{}], ack'ing...\", e, task.getEnvelope().getDeliveryTag());\n                                        try {\n                                            channel.basicAck(task.getEnvelope().getDeliveryTag(), false);\n                                        } catch (IOException e1) {\n                                            logger.warn(\"failed to ack on failure [{}]\", e1, task.getEnvelope().getDeliveryTag());\n                                        }\n                                    }\n                                    deliveryTags.add(task.getEnvelope().getDeliveryTag());\n                                    if (bulkRequestBuilder.numberOfActions() >= bulkSize) {\n                                        break;\n                                    }\n                                }\n                            } catch (InterruptedException e) {\n                                if (closed) {\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"executing bulk with [{}] actions\", bulkRequestBuilder.numberOfActions());\n                        }\n\n                        if (ordered) {\n                            try {\n                                BulkResponse response = bulkRequestBuilder.execute().actionGet();\n                                if (response.hasFailures()) {\n                                    // TODO write to exception queue?\n                                    logger.warn(\"failed to execute\" + response.buildFailureMessage());\n                                }\n                                for (Long deliveryTag : deliveryTags) {\n                                    try {\n                                        channel.basicAck(deliveryTag, false);\n                                    } catch (IOException e1) {\n                                        logger.warn(\"failed to ack [{}]\", e1, deliveryTag);\n                                    }\n                                }\n                            } catch (Exception e) {\n                                logger.warn(\"failed to execute bulk\", e);\n                            }\n                        } else {\n                            bulkRequestBuilder.execute(new ActionListener<BulkResponse>() {\n                                @Override public void onResponse(BulkResponse response) {\n                                    if (response.hasFailures()) {\n                                        // TODO write to exception queue?\n                                        logger.warn(\"failed to execute\" + response.buildFailureMessage());\n                                    }\n                                    for (Long deliveryTag : deliveryTags) {\n                                        try {\n                                            channel.basicAck(deliveryTag, false);\n                                        } catch (IOException e1) {\n                                            logger.warn(\"failed to ack [{}]\", e1, deliveryTag);\n                                        }\n                                    }\n                                }\n\n                                @Override public void onFailure(Throwable e) {\n                                    logger.warn(\"failed to execute bulk for delivery tags [{}], not ack'ing\", e, deliveryTags);\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }","commit_id":"a4978bc67e6bace384bd9cc8620aa83b82e0d6b4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ProblemDescriptor[] checkClass(PsiClass aClass, InspectionManager manager, boolean isOnTheFly) {\n    PsiManager psiManager = aClass.getManager();\n    final Set<PsiField> candidates = new LinkedHashSet<PsiField>();\n    final PsiClass topLevelClass = PsiUtil.getTopLevelClass(aClass);\n    if (topLevelClass == null) return null;\n    final PsiField[] fields = aClass.getFields();\n    NextField:\n    for (PsiField field : fields) {\n      if (field.hasModifierProperty(PsiModifier.PRIVATE)) {\n        if (HighlightUtil.isSerializationImplicitlyUsedField(field)) continue;\n        final PsiReference[] refs = psiManager.getSearchHelper().findReferences(field, new LocalSearchScope(field.getContainingFile()),\n                                                                                true);\n        if (refs.length == 0) continue;\n        for (PsiReference ref : refs) {\n          PsiElement element = ref.getElement();\n          final PsiMember parentOfType = PsiTreeUtil.getParentOfType(element, PsiMember.class);\n          if (!(parentOfType instanceof PsiMethod) &&\n              !(parentOfType instanceof PsiClassInitializer)) {\n            continue NextField;\n          }\n        }\n        candidates.add(field);\n      }\n    }\n    topLevelClass.accept(new PsiRecursiveElementVisitor() {\n      public void visitElement(PsiElement element) {\n        if (candidates.size() > 0) super.visitElement(element);\n      }\n\n      public void visitMethod(PsiMethod method) {\n        super.visitMethod(method);\n\n        final PsiCodeBlock body = method.getBody();\n        if (body != null) {\n          checkCodeBlock(body, candidates);\n        }\n      }\n\n      public void visitClassInitializer(PsiClassInitializer initializer) {\n        super.visitClassInitializer(initializer);\n\n        checkCodeBlock(initializer.getBody(), candidates);\n      }\n\n      private void checkCodeBlock(final PsiCodeBlock body, final Set<PsiField> candidates) {\n        try {\n          final ControlFlow controlFlow = ControlFlowFactory.getControlFlow(body, AllVariablesControlFlowPolicy.getInstance());\n          final List<PsiReferenceExpression> readBeforeWrites = ControlFlowUtil.getReadBeforeWrite(controlFlow);\n          for (final PsiReferenceExpression readBeforeWrite : readBeforeWrites) {\n            final PsiElement resolved = readBeforeWrite.resolve();\n            if (resolved instanceof PsiField) {\n              final PsiField field = (PsiField)resolved;\n              candidates.remove(field);\n            }\n          }\n        }\n        catch (AnalysisCanceledException e) {\n          candidates.clear();\n        }\n      }\n    });\n\n    if (candidates.isEmpty()) return null;\n    ProblemDescriptor[] result = new ProblemDescriptor[candidates.size()];\n    int i = 0;\n    for (Iterator<PsiField> iterator = candidates.iterator(); iterator.hasNext(); i++) {\n      PsiField field = iterator.next();\n      final String message = InspectionsBundle.message(\"inspection.field.can.be.local.problem.descriptor\");\n      result[i] = manager.createProblemDescriptor(field.getNameIdentifier(), message, new MyQuickFix(field), ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n    }\n    return result;\n  }","id":98339,"modified_method":"public ProblemDescriptor[] checkClass(PsiClass aClass, InspectionManager manager, boolean isOnTheFly) {\n    final Set<PsiField> candidates = new LinkedHashSet<PsiField>();\n    final PsiClass topLevelClass = PsiUtil.getTopLevelClass(aClass);\n    if (topLevelClass == null) return null;\n    final PsiField[] fields = aClass.getFields();\n    NextField:\n    for (PsiField field : fields) {\n      if (field.hasModifierProperty(PsiModifier.PRIVATE)) {\n        if (HighlightUtil.isSerializationImplicitlyUsedField(field)) continue;\n        final Collection<PsiReference> refs = PsiReferenceSearch.search(field, new LocalSearchScope(field.getContainingFile()), true).findAll();\n        if (refs.size() == 0) continue;\n        for (PsiReference ref : refs) {\n          PsiElement element = ref.getElement();\n          final PsiMember parentOfType = PsiTreeUtil.getParentOfType(element, PsiMember.class);\n          if (!(parentOfType instanceof PsiMethod) &&\n              !(parentOfType instanceof PsiClassInitializer)) {\n            continue NextField;\n          }\n        }\n        candidates.add(field);\n      }\n    }\n    topLevelClass.accept(new PsiRecursiveElementVisitor() {\n      public void visitElement(PsiElement element) {\n        if (candidates.size() > 0) super.visitElement(element);\n      }\n\n      public void visitMethod(PsiMethod method) {\n        super.visitMethod(method);\n\n        final PsiCodeBlock body = method.getBody();\n        if (body != null) {\n          checkCodeBlock(body, candidates);\n        }\n      }\n\n      public void visitClassInitializer(PsiClassInitializer initializer) {\n        super.visitClassInitializer(initializer);\n\n        checkCodeBlock(initializer.getBody(), candidates);\n      }\n\n      private void checkCodeBlock(final PsiCodeBlock body, final Set<PsiField> candidates) {\n        try {\n          final ControlFlow controlFlow = ControlFlowFactory.getControlFlow(body, AllVariablesControlFlowPolicy.getInstance());\n          final List<PsiReferenceExpression> readBeforeWrites = ControlFlowUtil.getReadBeforeWrite(controlFlow);\n          for (final PsiReferenceExpression readBeforeWrite : readBeforeWrites) {\n            final PsiElement resolved = readBeforeWrite.resolve();\n            if (resolved instanceof PsiField) {\n              final PsiField field = (PsiField)resolved;\n              candidates.remove(field);\n            }\n          }\n        }\n        catch (AnalysisCanceledException e) {\n          candidates.clear();\n        }\n      }\n    });\n\n    if (candidates.isEmpty()) return null;\n    ProblemDescriptor[] result = new ProblemDescriptor[candidates.size()];\n    int i = 0;\n    for (Iterator<PsiField> iterator = candidates.iterator(); iterator.hasNext(); i++) {\n      PsiField field = iterator.next();\n      final String message = InspectionsBundle.message(\"inspection.field.can.be.local.problem.descriptor\");\n      result[i] = manager.createProblemDescriptor(field.getNameIdentifier(), message, new MyQuickFix(field), ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n    }\n    return result;\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiCodeBlock findAnchorBlock(final PsiReference[] refs) {\n      PsiCodeBlock result = null;\n      for (PsiReference psiReference : refs) {\n        final PsiElement element = psiReference.getElement();\n        PsiCodeBlock block = PsiTreeUtil.getParentOfType(element, PsiCodeBlock.class);\n        if (result == null) {\n          result = block;\n        }\n        else {\n          final PsiElement commonParent = PsiTreeUtil.findCommonParent(result, block);\n          result = PsiTreeUtil.getParentOfType(commonParent, PsiCodeBlock.class, false);\n        }\n      }\n      return result;\n    }","id":98340,"modified_method":"private static PsiCodeBlock findAnchorBlock(final Collection<PsiReference> refs) {\n      PsiCodeBlock result = null;\n      for (PsiReference psiReference : refs) {\n        final PsiElement element = psiReference.getElement();\n        PsiCodeBlock block = PsiTreeUtil.getParentOfType(element, PsiCodeBlock.class);\n        if (result == null) {\n          result = block;\n        }\n        else {\n          final PsiElement commonParent = PsiTreeUtil.findCommonParent(result, block);\n          result = PsiTreeUtil.getParentOfType(commonParent, PsiCodeBlock.class, false);\n        }\n      }\n      return result;\n    }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiElement getAnchorElement(final PsiCodeBlock anchorBlock, final PsiReference[] refs) {\n      PsiElement firstElement = null;\n      for (PsiReference reference : refs) {\n        final PsiElement element = reference.getElement();\n        if (firstElement == null || firstElement.getTextRange().getStartOffset() > element.getTextRange().getStartOffset()) {\n          firstElement = element;\n        }\n      }\n      LOG.assertTrue(firstElement != null);\n      while (firstElement.getParent() != anchorBlock) {\n        firstElement = firstElement.getParent();\n      }\n\n      return firstElement;\n    }","id":98341,"modified_method":"private static PsiElement getAnchorElement(final PsiCodeBlock anchorBlock, final Collection<PsiReference> refs) {\n      PsiElement firstElement = null;\n      for (PsiReference reference : refs) {\n        final PsiElement element = reference.getElement();\n        if (firstElement == null || firstElement.getTextRange().getStartOffset() > element.getTextRange().getStartOffset()) {\n          firstElement = element;\n        }\n      }\n      LOG.assertTrue(firstElement != null);\n      while (firstElement.getParent() != anchorBlock) {\n        firstElement = firstElement.getParent();\n      }\n\n      return firstElement;\n    }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n      if (!myField.isValid()) return; //weird. should not get here when field becomes invalid\n\n      PsiManager manager = PsiManager.getInstance(project);\n      PsiSearchHelper helper = manager.getSearchHelper();\n      Set<PsiMember> methodSet = new HashSet<PsiMember>();\n      final PsiReference[] allRefs = helper.findReferences(myField, new LocalSearchScope(myField.getContainingFile()), true);\n      for (PsiReference ref : allRefs) {\n        if (ref instanceof PsiReferenceExpression) {\n          final PsiMember member = PsiTreeUtil.getParentOfType((PsiReferenceExpression)ref, PsiMethod.class, PsiClassInitializer.class);\n          if (member != null) {\n            methodSet.add(member);\n          }\n        }\n      }\n\n      PsiElement newCaretPosition = null;\n      for (PsiMember member : methodSet) {\n        final PsiReference[] refs = helper.findReferences(myField, new LocalSearchScope(member), true);\n        LOG.assertTrue(refs.length > 0);\n        Set<PsiReference> refsSet = new HashSet<PsiReference>(Arrays.asList(refs));\n        PsiCodeBlock anchorBlock = findAnchorBlock(refs);\n        LOG.assertTrue(anchorBlock != null);\n        final PsiElementFactory elementFactory = manager.getElementFactory();\n        final CodeStyleManager styleManager = manager.getCodeStyleManager();\n        final String propertyName = styleManager.variableNameToPropertyName(myField.getName(), VariableKind.FIELD);\n        String localName = styleManager.propertyNameToVariableName(propertyName, VariableKind.LOCAL_VARIABLE);\n        localName = RefactoringUtil.suggestUniqueVariableName(localName, anchorBlock, myField);\n        try {\n\n          final PsiElement anchor = getAnchorElement(anchorBlock, refs);\n          final PsiElement newDeclaration;\n          if (anchor instanceof PsiExpressionStatement &&\n              ((PsiExpressionStatement)anchor).getExpression() instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression expression = (PsiAssignmentExpression)((PsiExpressionStatement)anchor).getExpression();\n            if (expression.getLExpression() instanceof PsiReferenceExpression &&\n                ((PsiReferenceExpression)expression.getLExpression()).isReferenceTo(myField)) {\n              final PsiExpression initializer = expression.getRExpression();\n              final PsiDeclarationStatement decl = elementFactory.createVariableDeclarationStatement(localName, myField.getType(), initializer);\n              newDeclaration = anchor.replace(decl);\n              refsSet.remove(expression.getLExpression());\n              retargetReferences(elementFactory, localName, refsSet);\n            }\n            else {\n              newDeclaration = addDeclarationWithoutInitializerAndRetargetReferences(elementFactory, localName, anchorBlock, anchor, refsSet);\n            }\n          } else {\n            newDeclaration = addDeclarationWithoutInitializerAndRetargetReferences(elementFactory, localName, anchorBlock, anchor, refsSet);\n          }\n          if (newCaretPosition == null) {\n            newCaretPosition = newDeclaration;\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      if (newCaretPosition != null) {\n        final PsiFile psiFile = myField.getContainingFile();\n        final Editor editor = FileEditorManager.getInstance(project).getSelectedTextEditor();\n        if (editor != null && IJSwingUtilities.hasFocus(editor.getComponent())) {\n          final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n          if (file == psiFile) {\n            editor.getCaretModel().moveToOffset(newCaretPosition.getTextOffset());\n            editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n          }\n        }\n      }\n\n      try {\n        myField.normalizeDeclaration();\n        myField.delete();\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n\n    }","id":98342,"modified_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n      if (!myField.isValid()) return; //weird. should not get here when field becomes invalid\n\n      PsiManager manager = PsiManager.getInstance(project);\n      Set<PsiMember> methodSet = new HashSet<PsiMember>();\n      for (PsiReference ref : PsiReferenceSearch.search(myField, new LocalSearchScope(myField.getContainingFile()), true)) {\n        if (ref instanceof PsiReferenceExpression) {\n          final PsiMember member = PsiTreeUtil.getParentOfType((PsiReferenceExpression)ref, PsiMethod.class, PsiClassInitializer.class);\n          if (member != null) {\n            methodSet.add(member);\n          }\n        }\n      }\n\n      PsiElement newCaretPosition = null;\n      for (PsiMember member : methodSet) {\n        final Collection<PsiReference> refs = PsiReferenceSearch.search(myField, new LocalSearchScope(member), true).findAll();\n        LOG.assertTrue(refs.size() > 0);\n        Set<PsiReference> refsSet = new HashSet<PsiReference>(refs);\n        PsiCodeBlock anchorBlock = findAnchorBlock(refs);\n        LOG.assertTrue(anchorBlock != null);\n        final PsiElementFactory elementFactory = manager.getElementFactory();\n        final CodeStyleManager styleManager = manager.getCodeStyleManager();\n        final String propertyName = styleManager.variableNameToPropertyName(myField.getName(), VariableKind.FIELD);\n        String localName = styleManager.propertyNameToVariableName(propertyName, VariableKind.LOCAL_VARIABLE);\n        localName = RefactoringUtil.suggestUniqueVariableName(localName, anchorBlock, myField);\n        try {\n\n          final PsiElement anchor = getAnchorElement(anchorBlock, refs);\n          final PsiElement newDeclaration;\n          if (anchor instanceof PsiExpressionStatement &&\n              ((PsiExpressionStatement)anchor).getExpression() instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression expression = (PsiAssignmentExpression)((PsiExpressionStatement)anchor).getExpression();\n            if (expression.getLExpression() instanceof PsiReferenceExpression &&\n                ((PsiReferenceExpression)expression.getLExpression()).isReferenceTo(myField)) {\n              final PsiExpression initializer = expression.getRExpression();\n              final PsiDeclarationStatement decl = elementFactory.createVariableDeclarationStatement(localName, myField.getType(), initializer);\n              newDeclaration = anchor.replace(decl);\n              refsSet.remove(expression.getLExpression());\n              retargetReferences(elementFactory, localName, refsSet);\n            }\n            else {\n              newDeclaration = addDeclarationWithoutInitializerAndRetargetReferences(elementFactory, localName, anchorBlock, anchor, refsSet);\n            }\n          } else {\n            newDeclaration = addDeclarationWithoutInitializerAndRetargetReferences(elementFactory, localName, anchorBlock, anchor, refsSet);\n          }\n          if (newCaretPosition == null) {\n            newCaretPosition = newDeclaration;\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      if (newCaretPosition != null) {\n        final PsiFile psiFile = myField.getContainingFile();\n        final Editor editor = FileEditorManager.getInstance(project).getSelectedTextEditor();\n        if (editor != null && IJSwingUtilities.hasFocus(editor.getComponent())) {\n          final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n          if (file == psiFile) {\n            editor.getCaretModel().moveToOffset(newCaretPosition.getTextOffset());\n            editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n          }\n        }\n      }\n\n      try {\n        myField.normalizeDeclaration();\n        myField.delete();\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n\n    }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processElementsContainingWordInElement(PsiElementProcessorEx processor,\n                                                               PsiElement scope,\n                                                               StringSearcher searcher,\n                                                               ProgressIndicator progress,\n                                                               final short searchContext) {\n    return processElementsContainingWordInElement(processor, SourceTreeToPsiMap.psiElementToTree(scope), searcher, progress, searchContext);\n  }","id":98343,"modified_method":"public static boolean processElementsContainingWordInElement(TextOccurenceProcessor processor,\n                                                               PsiElement scope,\n                                                               StringSearcher searcher,\n                                                               ProgressIndicator progress,\n                                                               final short searchContext) {\n    return processElementsContainingWordInElement(processor, SourceTreeToPsiMap.psiElementToTree(scope), searcher, progress, searchContext);\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean processChildren(ASTNode scope,\n                                         StringSearcher searcher,\n                                         PsiElementProcessorEx processor,\n                                         ProgressIndicator progress,\n                                         final short searchContext) {\n    synchronized (PsiLock.LOCK) {\n      ASTNode child = scope.getFirstChildNode();\n      while (child != null) {\n        if (child instanceof LeafElement && ((LeafElement)child).isChameleon()) {\n          LeafElement leaf = (LeafElement)child;\n          if (leaf.searchWord(0, searcher) >= 0) {\n            ASTNode next = child.getTreeNext();\n            child = ChameleonTransforming.transform((LeafElement)child);\n            if (child == null) {\n              child = next;\n            }\n          continue;\n          }\n        }\n        child = child.getTreeNext();\n      }\n    }\n\n    ASTNode child = null;\n    while (true) {\n      synchronized (PsiLock.LOCK) {\n        child = child != null ? child.getTreeNext() : scope.getFirstChildNode();\n        while (child instanceof LeafElement && ((LeafElement)child).isChameleon()) {\n          child = child.getTreeNext();\n        }\n        if (child == null) break;\n      }\n\n      if (!processElementsContainingWordInElement(processor, child, searcher, progress, searchContext)) {\n        return false;\n      }\n    }\n    return true;\n  }","id":98344,"modified_method":"private static boolean processChildren(ASTNode scope,\n                                         StringSearcher searcher,\n                                         TextOccurenceProcessor processor,\n                                         ProgressIndicator progress,\n                                         final short searchContext) {\n    synchronized (PsiLock.LOCK) {\n      ASTNode child = scope.getFirstChildNode();\n      while (child != null) {\n        if (child instanceof LeafElement && ((LeafElement)child).isChameleon()) {\n          LeafElement leaf = (LeafElement)child;\n          if (leaf.searchWord(0, searcher) >= 0) {\n            ASTNode next = child.getTreeNext();\n            child = ChameleonTransforming.transform((LeafElement)child);\n            if (child == null) {\n              child = next;\n            }\n          continue;\n          }\n        }\n        child = child.getTreeNext();\n      }\n    }\n\n    ASTNode child = null;\n    while (true) {\n      synchronized (PsiLock.LOCK) {\n        child = child != null ? child.getTreeNext() : scope.getFirstChildNode();\n        while (child instanceof LeafElement && ((LeafElement)child).isChameleon()) {\n          child = child.getTreeNext();\n        }\n        if (child == null) break;\n      }\n\n      if (!processElementsContainingWordInElement(processor, child, searcher, progress, searchContext)) {\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean processElementsContainingWordInElement(PsiElementProcessorEx processor,\n                                                                ASTNode scope,\n                                                                StringSearcher searcher,\n                                                                ProgressIndicator progress,\n                                                                final short searchContext) {\n    ProgressManager.getInstance().checkCanceled();\n    final PsiElement scopePsi = SourceTreeToPsiMap.treeElementToPsi(scope);\n    if (scopePsi instanceof PsiWhiteSpace) {\n      // Optimization. Taking language from whitespace may expand a chameleon next to this whitespace\n      // As we know for sure whitespaces may not have words in them this optimization is safe.\n      return true;\n    }\n\n    final Language lang = scopePsi.getLanguage();\n    //TODO[ven]: lang is null for PsiPlainText for example. Should be reviewed.\n    if (lang == null || lang.getFindUsagesProvider().mayHaveReferences(scope.getElementType(), searchContext)) {\n      int startOffset;\n      int endOffset;\n      if (scope instanceof LeafElement) {\n        LeafElement leaf = (LeafElement)scope;\n        startOffset = 0;\n        endOffset = leaf.getTextLength();\n        do {\n          int i = leaf.searchWord(startOffset, searcher);\n          if (i >= 0) {\n            if (!processor.execute(scopePsi, i)) return false;\n            startOffset = i + 1;\n          }\n          else {\n            return true;\n          }\n        }\n        while (startOffset < endOffset);\n        endOffset = startOffset + leaf.getTextLength();\n      }\n      else {\n        char[] buffer = ((CompositeElement)scope).textToCharArray();\n\n        // This is hack. Need to be fixed and optimized. current code's extremely slow\n        // LeafElement leaf = SourceUtil.findLeafToFetchCharArrayRange(scope);\n        //if (leaf != null) {\n        //  buffer = leaf.buffer;\n        //  startOffset = leaf.offset;\n        //  endOffset = leaf.offset + scope.getTextLength();\n        //}\n        //else {\n        //  buffer = scope.textToCharArray();\n        //  startOffset = 0;\n        //  endOffset = buffer.length;\n        //}\n        startOffset = 0;\n        endOffset = buffer.length;\n\n        final int originalStartOffset = startOffset;\n        do {\n          int i = searchWord(buffer, startOffset, endOffset, searcher);\n          if (i >= 0) {\n            if (!processor.execute(scopePsi, i - originalStartOffset)) return false;\n            startOffset = i + 1;\n          }\n          else {\n            return true;\n          }\n        }\n        while (startOffset < endOffset);\n      }\n    }\n\n    if (scope instanceof CompositeElement) {\n      return processChildren(scope, searcher, processor, progress, searchContext);\n    }\n\n    return true;\n  }","id":98345,"modified_method":"private static boolean processElementsContainingWordInElement(TextOccurenceProcessor processor,\n                                                                ASTNode scope,\n                                                                StringSearcher searcher,\n                                                                ProgressIndicator progress,\n                                                                final short searchContext) {\n    ProgressManager.getInstance().checkCanceled();\n    final PsiElement scopePsi = SourceTreeToPsiMap.treeElementToPsi(scope);\n    if (scopePsi instanceof PsiWhiteSpace) {\n      // Optimization. Taking language from whitespace may expand a chameleon next to this whitespace\n      // As we know for sure whitespaces may not have words in them this optimization is safe.\n      return true;\n    }\n\n    final Language lang = scopePsi.getLanguage();\n    //TODO[ven]: lang is null for PsiPlainText for example. Should be reviewed.\n    if (lang == null || lang.getFindUsagesProvider().mayHaveReferences(scope.getElementType(), searchContext)) {\n      int startOffset;\n      int endOffset;\n      if (scope instanceof LeafElement) {\n        LeafElement leaf = (LeafElement)scope;\n        startOffset = 0;\n        endOffset = leaf.getTextLength();\n        do {\n          int i = leaf.searchWord(startOffset, searcher);\n          if (i >= 0) {\n            if (!processor.execute(scopePsi, i)) return false;\n            startOffset = i + 1;\n          }\n          else {\n            return true;\n          }\n        }\n        while (startOffset < endOffset);\n        endOffset = startOffset + leaf.getTextLength();\n      }\n      else {\n        char[] buffer = ((CompositeElement)scope).textToCharArray();\n\n        // This is hack. Need to be fixed and optimized. current code's extremely slow\n        // LeafElement leaf = SourceUtil.findLeafToFetchCharArrayRange(scope);\n        //if (leaf != null) {\n        //  buffer = leaf.buffer;\n        //  startOffset = leaf.offset;\n        //  endOffset = leaf.offset + scope.getTextLength();\n        //}\n        //else {\n        //  buffer = scope.textToCharArray();\n        //  startOffset = 0;\n        //  endOffset = buffer.length;\n        //}\n        startOffset = 0;\n        endOffset = buffer.length;\n\n        final int originalStartOffset = startOffset;\n        do {\n          int i = searchWord(buffer, startOffset, endOffset, searcher);\n          if (i >= 0) {\n            if (!processor.execute(scopePsi, i - originalStartOffset)) return false;\n            startOffset = i + 1;\n          }\n          else {\n            return true;\n          }\n        }\n        while (startOffset < endOffset);\n      }\n    }\n\n    if (scope instanceof CompositeElement) {\n      return processChildren(scope, searcher, processor, progress, searchContext);\n    }\n\n    return true;\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean processElementsWithWordInScopeElement(PsiElement scopeElement,\n                                                               PsiElementProcessorEx processor,\n                                                               String word,\n                                                               boolean caseSensitive,\n                                                               final short searchContext) {\n    if (SourceTreeToPsiMap.hasTreeElement(scopeElement)) {\n      StringSearcher searcher = new StringSearcher(word);\n      searcher.setCaseSensitive(caseSensitive);\n\n      return LowLevelSearchUtil.processElementsContainingWordInElement(processor,\n                                                                       scopeElement,\n                                                                       searcher,\n                                                                       null, searchContext);\n    }\n    else {\n      return true;\n    }\n  }","id":98346,"modified_method":"private static boolean processElementsWithWordInScopeElement(PsiElement scopeElement,\n                                                               TextOccurenceProcessor processor,\n                                                               String word,\n                                                               boolean caseSensitive,\n                                                               final short searchContext) {\n    if (SourceTreeToPsiMap.hasTreeElement(scopeElement)) {\n      StringSearcher searcher = new StringSearcher(word);\n      searcher.setCaseSensitive(caseSensitive);\n\n      return LowLevelSearchUtil.processElementsContainingWordInElement(processor,\n                                                                       scopeElement,\n                                                                       searcher,\n                                                                       null, searchContext);\n    }\n    else {\n      return true;\n    }\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processReferencesIncludingOverriding(final PsiReferenceProcessor processor,\n                                                      final PsiMethod method,\n                                                      SearchScope searchScope,\n                                                      final boolean isStrictSignatureSearch) {\n    LOG.assertTrue(searchScope != null);\n\n    PsiClass parentClass = method.getContainingClass();\n    if (method.isConstructor()) {\n      if (!processConstructorReferences(processor, method, searchScope, !isStrictSignatureSearch,\n                                        isStrictSignatureSearch)) {\n        return false;\n      }\n    }\n\n    if (isStrictSignatureSearch && (parentClass == null\n                                    || parentClass instanceof PsiAnonymousClass\n                                    || parentClass.hasModifierProperty(PsiModifier.FINAL)\n                                    || method.hasModifierProperty(PsiModifier.STATIC)\n                                    || method.hasModifierProperty(PsiModifier.FINAL)\n                                    || method.hasModifierProperty(PsiModifier.PRIVATE))\n    ) {\n      return processReferences(processor, method, searchScope, false);\n    }\n\n    final String text = method.getName();\n    final PsiMethod[] methods = isStrictSignatureSearch ? new PsiMethod[]{method} : getOverloadsMayBeOverriden(method);\n\n    SearchScope accessScope = methods[0].getUseScope();\n    for (int i = 1; i < methods.length; i++) {\n      PsiMethod method1 = methods[i];\n      SearchScope someScope = PsiSearchScopeUtil.scopesUnion(accessScope, method1.getUseScope());\n      accessScope = someScope == null ? accessScope : someScope;\n    }\n\n    final PsiClass aClass = method.getContainingClass();\n\n    final PsiElementProcessorEx processor1 = new PsiElementProcessorEx() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        PsiReference reference = element.findReferenceAt(offsetInElement);\n\n        if (reference != null) {\n          for (PsiMethod method : methods) {\n            if (reference.isReferenceTo(method)) {\n              return processor.execute(reference);\n            }\n            PsiElement refElement = reference.resolve();\n\n            if (refElement instanceof PsiMethod) {\n              PsiMethod refMethod = (PsiMethod)refElement;\n              PsiClass refMethodClass = refMethod.getContainingClass();\n              if (refMethodClass == null) return true;\n\n              if (!refMethod.hasModifierProperty(PsiModifier.STATIC)) {\n                PsiSubstitutor substitutor = TypeConversionUtil.getClassSubstitutor(aClass, refMethodClass, PsiSubstitutor.EMPTY);\n                if (substitutor != null) {\n                  if (refMethod.getSignature(PsiSubstitutor.EMPTY).equals(method.getSignature(substitutor))) {\n                    if (!processor.execute(reference)) return false;\n                  }\n                }\n              }\n\n              if (!isStrictSignatureSearch) {\n                PsiManager manager = method.getManager();\n                if (manager.areElementsEquivalent(refMethodClass, aClass)) {\n                  return processor.execute(reference);\n                }\n              }\n            }\n            else {\n              return true;\n            }\n          }\n        }\n\n        return true;\n      }\n    };\n\n    searchScope = searchScope.intersectWith(accessScope);\n\n    short searchContext = UsageSearchContext.IN_CODE | UsageSearchContext.IN_COMMENTS;\n    boolean toContinue = processElementsWithWord(processor1,\n                                                 searchScope,\n                                                 text,\n                                                 searchContext, true);\n    if (!toContinue) return false;\n\n    if (PropertyUtil.isSimplePropertyAccessor(method)) {\n      final String propertyName = PropertyUtil.getPropertyName(method);\n\n      //if (myManager.getNameHelper().isIdentifier(propertyName)) {\n        if (searchScope instanceof GlobalSearchScope) {\n          searchScope = GlobalSearchScope.getScopeRestrictedByFileTypes(\n            (GlobalSearchScope)searchScope,\n            StdFileTypes.JSP,\n            StdFileTypes.JSPX,\n            StdFileTypes.XML\n          );\n        }\n        toContinue = processElementsWithWord(processor1,\n                                             searchScope,\n                                             propertyName,\n                                             UsageSearchContext.IN_FOREIGN_LANGUAGES, true);\n        if (!toContinue) return false;\n      //}\n    }\n\n    return true;\n  }","id":98347,"modified_method":"public boolean processReferencesIncludingOverriding(final PsiReferenceProcessor processor,\n                                                      final PsiMethod method,\n                                                      SearchScope searchScope,\n                                                      final boolean isStrictSignatureSearch) {\n    LOG.assertTrue(searchScope != null);\n\n    if (method.isConstructor()) {\n      Processor<PsiReference> adapter = new Processor<PsiReference>() {\n        public boolean process(final PsiReference t) {\n          return processor.execute(t);\n        }\n      };\n\n      final ConstructorReferencesSearchHelper helper = new ConstructorReferencesSearchHelper(myManager);\n      if (!helper. processConstructorReferences(adapter, method, searchScope, !isStrictSignatureSearch, isStrictSignatureSearch)) {\n        return false;\n      }\n    }\n\n    PsiClass parentClass = method.getContainingClass();\n    if (isStrictSignatureSearch && (parentClass == null\n                                    || parentClass instanceof PsiAnonymousClass\n                                    || parentClass.hasModifierProperty(PsiModifier.FINAL)\n                                    || method.hasModifierProperty(PsiModifier.STATIC)\n                                    || method.hasModifierProperty(PsiModifier.FINAL)\n                                    || method.hasModifierProperty(PsiModifier.PRIVATE))\n    ) {\n      return processReferences(processor, method, searchScope, false);\n    }\n\n    final String text = method.getName();\n    final PsiMethod[] methods = isStrictSignatureSearch ? new PsiMethod[]{method} : getOverloadsMayBeOverriden(method);\n\n    SearchScope accessScope = methods[0].getUseScope();\n    for (int i = 1; i < methods.length; i++) {\n      PsiMethod method1 = methods[i];\n      SearchScope someScope = PsiSearchScopeUtil.scopesUnion(accessScope, method1.getUseScope());\n      accessScope = someScope == null ? accessScope : someScope;\n    }\n\n    final PsiClass aClass = method.getContainingClass();\n\n    final TextOccurenceProcessor processor1 = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        PsiReference reference = element.findReferenceAt(offsetInElement);\n\n        if (reference != null) {\n          for (PsiMethod method : methods) {\n            if (reference.isReferenceTo(method)) {\n              return processor.execute(reference);\n            }\n            PsiElement refElement = reference.resolve();\n\n            if (refElement instanceof PsiMethod) {\n              PsiMethod refMethod = (PsiMethod)refElement;\n              PsiClass refMethodClass = refMethod.getContainingClass();\n              if (refMethodClass == null) return true;\n\n              if (!refMethod.hasModifierProperty(PsiModifier.STATIC)) {\n                PsiSubstitutor substitutor = TypeConversionUtil.getClassSubstitutor(aClass, refMethodClass, PsiSubstitutor.EMPTY);\n                if (substitutor != null) {\n                  if (refMethod.getSignature(PsiSubstitutor.EMPTY).equals(method.getSignature(substitutor))) {\n                    if (!processor.execute(reference)) return false;\n                  }\n                }\n              }\n\n              if (!isStrictSignatureSearch) {\n                PsiManager manager = method.getManager();\n                if (manager.areElementsEquivalent(refMethodClass, aClass)) {\n                  return processor.execute(reference);\n                }\n              }\n            }\n            else {\n              return true;\n            }\n          }\n        }\n\n        return true;\n      }\n    };\n\n    searchScope = searchScope.intersectWith(accessScope);\n\n    short searchContext = UsageSearchContext.IN_CODE | UsageSearchContext.IN_COMMENTS;\n    boolean toContinue = processElementsWithWord(processor1,\n                                                 searchScope,\n                                                 text,\n                                                 searchContext, true);\n    if (!toContinue) return false;\n\n    if (PropertyUtil.isSimplePropertyAccessor(method)) {\n      final String propertyName = PropertyUtil.getPropertyName(method);\n\n      //if (myManager.getNameHelper().isIdentifier(propertyName)) {\n        if (searchScope instanceof GlobalSearchScope) {\n          searchScope = GlobalSearchScope.getScopeRestrictedByFileTypes(\n            (GlobalSearchScope)searchScope,\n            StdFileTypes.JSP,\n            StdFileTypes.JSPX,\n            StdFileTypes.XML\n          );\n        }\n        toContinue = processElementsWithWord(processor1,\n                                             searchScope,\n                                             propertyName,\n                                             UsageSearchContext.IN_FOREIGN_LANGUAGES, true);\n        if (!toContinue) return false;\n      //}\n    }\n\n    return true;\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiLiteralExpression[] findStringLiteralsContainingIdentifier(String identifier, SearchScope searchScope) {\n    LOG.assertTrue(searchScope != null);\n\n    final ArrayList<PsiLiteralExpression> results = new ArrayList<PsiLiteralExpression>();\n    PsiElementProcessorEx processor = new PsiElementProcessorEx() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        if (element instanceof PsiLiteralExpression) {\n          results.add((PsiLiteralExpression)element);\n        }\n        return true;\n      }\n    };\n    processElementsWithWord(processor,\n                            searchScope,\n                            identifier,\n                            UsageSearchContext.IN_STRINGS,\n                            true);\n    return results.toArray(new PsiLiteralExpression[results.size()]);\n  }","id":98348,"modified_method":"public PsiLiteralExpression[] findStringLiteralsContainingIdentifier(String identifier, SearchScope searchScope) {\n    LOG.assertTrue(searchScope != null);\n\n    final ArrayList<PsiLiteralExpression> results = new ArrayList<PsiLiteralExpression>();\n    TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        if (element instanceof PsiLiteralExpression) {\n          results.add((PsiLiteralExpression)element);\n        }\n        return true;\n      }\n    };\n    processElementsWithWord(processor,\n                            searchScope,\n                            identifier,\n                            UsageSearchContext.IN_STRINGS,\n                            true);\n    return results.toArray(new PsiLiteralExpression[results.size()]);\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processReferences(final PsiReferenceProcessor processor,\n                                   final PsiElement refElement,\n                                   SearchScope searchScope,\n                                   boolean ignoreAccessScope) {\n    return processReferences(processor, refElement, searchScope, ignoreAccessScope, true);\n  }","id":98349,"modified_method":"public boolean processReferences(final PsiReferenceProcessor processor,\n                                   final PsiElement refElement,\n                                   SearchScope originalScope,\n                                   boolean ignoreAccessScope) {\n    LOG.assertTrue(originalScope != null);\n\n    final Query<PsiReference> query = PsiReferenceSearch.search(refElement, originalScope, ignoreAccessScope);\n    return query.forEach(new Processor<PsiReference>() {\n      public boolean process(final PsiReference t) {\n        return processor.execute(t);\n      }\n    });\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement[] findCommentsContainingIdentifier(String identifier, SearchScope searchScope) {\n    LOG.assertTrue(searchScope != null);\n\n    final ArrayList<PsiElement> results = new ArrayList<PsiElement>();\n    PsiElementProcessorEx processor = new PsiElementProcessorEx() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        if (element.getContainingFile().findReferenceAt(element.getTextRange().getStartOffset() + offsetInElement) == null) {\n          results.add(element);\n        }\n        return true;\n      }\n    };\n    processElementsWithWord(processor, searchScope, identifier, UsageSearchContext.IN_COMMENTS, true);\n    return results.toArray(new PsiElement[results.size()]);\n  }","id":98350,"modified_method":"public PsiElement[] findCommentsContainingIdentifier(String identifier, SearchScope searchScope) {\n    LOG.assertTrue(searchScope != null);\n\n    final ArrayList<PsiElement> results = new ArrayList<PsiElement>();\n    TextOccurenceProcessor processor = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        if (element.getContainingFile().findReferenceAt(element.getTextRange().getStartOffset() + offsetInElement) == null) {\n          results.add(element);\n        }\n        return true;\n      }\n    };\n    processElementsWithWord(processor, searchScope, identifier, UsageSearchContext.IN_COMMENTS, true);\n    return results.toArray(new PsiElement[results.size()]);\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processElementsWithWord(PsiElementProcessorEx processor,\n                                          SearchScope searchScope,\n                                          String text,\n                                          short searchContext,\n                                          boolean caseSensitive) {\n    LOG.assertTrue(searchScope != null);\n\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text);\n      searcher.setCaseSensitive(caseSensitive);\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext);\n    }\n    else {\n      LocalSearchScope _scope = (LocalSearchScope)searchScope;\n      PsiElement[] scopeElements = _scope.getScope();\n\n      for (final PsiElement scopeElement : scopeElements) {\n        if (!processElementsWithWordInScopeElement(scopeElement, processor, text, caseSensitive, searchContext)) return false;\n      }\n      return true;\n    }\n  }","id":98351,"modified_method":"public boolean processElementsWithWord(TextOccurenceProcessor processor,\n                                          SearchScope searchScope,\n                                          String text,\n                                          short searchContext,\n                                          boolean caseSensitive) {\n    LOG.assertTrue(searchScope != null);\n\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text);\n      searcher.setCaseSensitive(caseSensitive);\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext);\n    }\n    else {\n      LocalSearchScope _scope = (LocalSearchScope)searchScope;\n      PsiElement[] scopeElements = _scope.getScope();\n\n      for (final PsiElement scopeElement : scopeElements) {\n        if (!processElementsWithWordInScopeElement(scopeElement, processor, text, caseSensitive, searchContext)) return false;\n      }\n      return true;\n    }\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processIdentifiers(final PsiElementProcessor<PsiIdentifier> processor,\n                                    final String identifier,\n                                    SearchScope searchScope,\n                                    short searchContext) {\n    LOG.assertTrue(searchScope != null);\n\n    PsiElementProcessorEx processor1 = new PsiElementProcessorEx() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        if (element instanceof PsiIdentifier) {\n          return processor.execute((PsiIdentifier)element);\n        }\n        return true;\n      }\n    };\n    return processElementsWithWord(processor1, searchScope, identifier, searchContext, true);\n  }","id":98352,"modified_method":"public boolean processIdentifiers(final PsiElementProcessor<PsiIdentifier> processor,\n                                    final String identifier,\n                                    SearchScope searchScope,\n                                    short searchContext) {\n    LOG.assertTrue(searchScope != null);\n\n    TextOccurenceProcessor processor1 = new TextOccurenceProcessor() {\n      public boolean execute(PsiElement element, int offsetInElement) {\n        if (element instanceof PsiIdentifier) {\n          return processor.execute((PsiIdentifier)element);\n        }\n        return true;\n      }\n    };\n    return processElementsWithWord(processor1, searchScope, identifier, searchContext, true);\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processElementsWithTextInGlobalScope(PsiElementProcessorEx processor,\n                                                       GlobalSearchScope scope,\n                                                       StringSearcher searcher,\n                                                       short searchContext) {\n\n    ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n    myManager.startBatchFilesProcessingMode();\n\n    try {\n      String[] words = StringUtil.getWordsIn(searcher.getPattern()).toArray(ArrayUtil.EMPTY_STRING_ARRAY);\n      if(words.length == 0) return true;\n\n      Set<PsiFile> fileSet = new HashSet<PsiFile>();\n      fileSet.addAll(Arrays.asList(myManager.getCacheManager().getFilesWithWord(words[0], searchContext, scope)));\n      for (int i = 1; i < words.length; i++) {\n        fileSet.retainAll(Arrays.asList(myManager.getCacheManager().getFilesWithWord(words[i], searchContext, scope)));\n      }\n      PsiFile[] files = fileSet.toArray(new PsiFile[fileSet.size()]);\n\n      if (progress != null) {\n        progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", searcher.getPattern()));\n      }\n\n      for (int i = 0; i < files.length; i++) {\n        ProgressManager.getInstance().checkCanceled();\n\n        PsiFile file = files[i];\n        PsiElement[] psiRoots = file.getPsiRoots();\n        for (PsiElement psiRoot : psiRoots) {\n          if (!LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, progress, searchContext)) {\n            return false;\n          }\n        }\n\n        if (progress != null) {\n          double fraction = (double)i / files.length;\n          progress.setFraction(fraction);\n        }\n\n        myManager.dropResolveCaches();\n      }\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n      myManager.finishBatchFilesProcessingMode();\n    }\n\n    return true;\n  }","id":98353,"modified_method":"private boolean processElementsWithTextInGlobalScope(TextOccurenceProcessor processor,\n                                                       GlobalSearchScope scope,\n                                                       StringSearcher searcher,\n                                                       short searchContext) {\n\n    ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n    myManager.startBatchFilesProcessingMode();\n\n    try {\n      String[] words = StringUtil.getWordsIn(searcher.getPattern()).toArray(ArrayUtil.EMPTY_STRING_ARRAY);\n      if(words.length == 0) return true;\n\n      Set<PsiFile> fileSet = new HashSet<PsiFile>();\n      fileSet.addAll(Arrays.asList(myManager.getCacheManager().getFilesWithWord(words[0], searchContext, scope)));\n      for (int i = 1; i < words.length; i++) {\n        fileSet.retainAll(Arrays.asList(myManager.getCacheManager().getFilesWithWord(words[i], searchContext, scope)));\n      }\n      PsiFile[] files = fileSet.toArray(new PsiFile[fileSet.size()]);\n\n      if (progress != null) {\n        progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", searcher.getPattern()));\n      }\n\n      for (int i = 0; i < files.length; i++) {\n        ProgressManager.getInstance().checkCanceled();\n\n        PsiFile file = files[i];\n        PsiElement[] psiRoots = file.getPsiRoots();\n        for (PsiElement psiRoot : psiRoots) {\n          if (!LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, progress, searchContext)) {\n            return false;\n          }\n        }\n\n        if (progress != null) {\n          double fraction = (double)i / files.length;\n          progress.setFraction(fraction);\n        }\n\n        myManager.dropResolveCaches();\n      }\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n      myManager.finishBatchFilesProcessingMode();\n    }\n\n    return true;\n  }","commit_id":"9c4f34b34d209ac0355bed1b7252edd0ddb8d0e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateEditorTexts(final MethodNode node) {\n    final MethodNode parentNode = (MethodNode)node.getParent();\n    final String callerText = node != myRoot ? getText(node.getMethod()) : \"\";\n    final Document callerDocument = myCallerEditor.getDocument();\n    final String calleeText = node != myRoot ? getText(parentNode.getMethod()) : \"\";\n    final Document calleeDocument = myCalleeEditor.getDocument();\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        callerDocument.replaceString(0, callerDocument.getTextLength(), callerText);\n        calleeDocument.replaceString(0, calleeDocument.getTextLength(), calleeText);\n      }\n    });\n\n    final PsiMethod caller = node.getMethod();\n    final PsiMethod callee = parentNode != null ? parentNode.getMethod() : null;\n    if (caller != null && callee != null) {\n      final PsiReference[] refs = myMethod.getManager().getSearchHelper().findReferences(callee, new LocalSearchScope(caller), false);\n      HighlightManager highlighter = HighlightManager.getInstance(myProject);\n      EditorColorsManager colorManager = EditorColorsManager.getInstance();\n      TextAttributes attributes = colorManager.getGlobalScheme().getAttributes(EditorColors.TEXT_SEARCH_RESULT_ATTRIBUTES);\n      int start = getStartOffset(caller);\n      for (PsiReference ref : refs) {\n        final PsiElement element = ref.getElement();\n        if (element != null) {\n          highlighter.addRangeHighlight(myCallerEditor, element.getTextRange().getStartOffset() - start,\n                                        element.getTextRange().getEndOffset() - start, attributes, false, null);\n        }\n      }\n    }\n  }","id":98354,"modified_method":"private void updateEditorTexts(final MethodNode node) {\n    final MethodNode parentNode = (MethodNode)node.getParent();\n    final String callerText = node != myRoot ? getText(node.getMethod()) : \"\";\n    final Document callerDocument = myCallerEditor.getDocument();\n    final String calleeText = node != myRoot ? getText(parentNode.getMethod()) : \"\";\n    final Document calleeDocument = myCalleeEditor.getDocument();\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        callerDocument.replaceString(0, callerDocument.getTextLength(), callerText);\n        calleeDocument.replaceString(0, calleeDocument.getTextLength(), calleeText);\n      }\n    });\n\n    final PsiMethod caller = node.getMethod();\n    final PsiMethod callee = parentNode != null ? parentNode.getMethod() : null;\n    if (caller != null && callee != null) {\n      HighlightManager highlighter = HighlightManager.getInstance(myProject);\n      EditorColorsManager colorManager = EditorColorsManager.getInstance();\n      TextAttributes attributes = colorManager.getGlobalScheme().getAttributes(EditorColors.TEXT_SEARCH_RESULT_ATTRIBUTES);\n      int start = getStartOffset(caller);\n      for (PsiReference ref : ReferencesSearch.search(callee, new LocalSearchScope(caller), false).findAll()) {\n        final PsiElement element = ref.getElement();\n        if (element != null) {\n          highlighter.addRangeHighlight(myCallerEditor, element.getTextRange().getStartOffset() - start,\n                                        element.getTextRange().getEndOffset() - start, attributes, false, null);\n        }\n      }\n    }\n  }","commit_id":"ebdeb7f1339a51cdad9fdfd8b540956eb9ab5895","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findPublicClassConflicts(PsiClass aClass, MyClassInstanceReferenceVisitor instanceReferenceVisitor) {\n    NonPublicClassMemberWrappersSet members = new NonPublicClassMemberWrappersSet();\n\n    members.addElements(aClass.getFields());\n    members.addElements(aClass.getMethods());\n    members.addElements(aClass.getInnerClasses());\n\n    final PsiSearchHelper searchHelper = aClass.getManager().getSearchHelper();\n    RefactoringUtil.IsDescendantOf isDescendantOf = new RefactoringUtil.IsDescendantOf(aClass);\n    final PsiPackage aPackage = aClass.getContainingFile().getContainingDirectory().getPackage();\n    final GlobalSearchScope packageScope = GlobalSearchScope.packageScopeWithoutLibraries(aPackage, false);\n    for (ClassMemberWrapper memberWrapper : members) {\n      final PsiReference[] references = searchHelper.findReferences(memberWrapper.getMember(), packageScope, false);\n      for (PsiReference reference : references) {\n        final PsiElement element = reference.getElement();\n        if (element instanceof PsiReferenceExpression) {\n          final PsiReferenceExpression expression = ((PsiReferenceExpression)element);\n          final PsiExpression qualifierExpression = expression.getQualifierExpression();\n          if (qualifierExpression != null) {\n            final PsiType type = qualifierExpression.getType();\n            if (type != null) {\n              final PsiClass resolvedTypeClass = PsiUtil.resolveClassInType(type);\n              if (isDescendantOf.value(resolvedTypeClass)) {\n                instanceReferenceVisitor.visitMemberReference(memberWrapper.getMember(), expression, isDescendantOf);\n              }\n            }\n          }\n          else {\n            instanceReferenceVisitor.visitMemberReference(memberWrapper.getMember(), expression, isDescendantOf);\n          }\n        }\n      }\n    }\n  }","id":98355,"modified_method":"private static void findPublicClassConflicts(PsiClass aClass, MyClassInstanceReferenceVisitor instanceReferenceVisitor) {\n    NonPublicClassMemberWrappersSet members = new NonPublicClassMemberWrappersSet();\n\n    members.addElements(aClass.getFields());\n    members.addElements(aClass.getMethods());\n    members.addElements(aClass.getInnerClasses());\n\n    RefactoringUtil.IsDescendantOf isDescendantOf = new RefactoringUtil.IsDescendantOf(aClass);\n    final PsiPackage aPackage = aClass.getContainingFile().getContainingDirectory().getPackage();\n    final GlobalSearchScope packageScope = GlobalSearchScope.packageScopeWithoutLibraries(aPackage, false);\n    for (ClassMemberWrapper memberWrapper : members) {\n      for (PsiReference reference : ReferencesSearch.search(memberWrapper.getMember(), packageScope, false).findAll()) {\n        final PsiElement element = reference.getElement();\n        if (element instanceof PsiReferenceExpression) {\n          final PsiReferenceExpression expression = ((PsiReferenceExpression)element);\n          final PsiExpression qualifierExpression = expression.getQualifierExpression();\n          if (qualifierExpression != null) {\n            final PsiType type = qualifierExpression.getType();\n            if (type != null) {\n              final PsiClass resolvedTypeClass = PsiUtil.resolveClassInType(type);\n              if (isDescendantOf.value(resolvedTypeClass)) {\n                instanceReferenceVisitor.visitMemberReference(memberWrapper.getMember(), expression, isDescendantOf);\n              }\n            }\n          }\n          else {\n            instanceReferenceVisitor.visitMemberReference(memberWrapper.getMember(), expression, isDescendantOf);\n          }\n        }\n      }\n    }\n  }","commit_id":"8577dad67e696c30829ff4354c2cc5d092253eec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object o) {\n      if (this == o) return true;\n      if (!(o instanceof ClassMemberWrapper)) return false;\n\n      ClassMemberWrapper wrapper = (ClassMemberWrapper)o;\n\n      if (myElement instanceof PsiMethod) {\n        if (!(wrapper.myElement instanceof PsiMethod)) return false;\n        return MethodSignatureUtil.areSignaturesEqual((PsiMethod)myElement, (PsiMethod)wrapper.myElement);\n      }\n\n\n      return Comparing.equal(myElement.getName(), wrapper.myElement.getName());\n    }","id":98356,"modified_method":"public boolean equals(Object o) {\n      if (this == o) return true;\n      if (!(o instanceof ClassMemberWrapper)) return false;\n\n      ClassMemberWrapper wrapper = (ClassMemberWrapper)o;\n\n      if (myElement instanceof PsiMethod) {\n        return wrapper.myElement instanceof PsiMethod &&\n            MethodSignatureUtil.areSignaturesEqual((PsiMethod) myElement, (PsiMethod) wrapper.myElement);\n      }\n\n\n      return Comparing.equal(myElement.getName(), wrapper.myElement.getName());\n    }","commit_id":"8577dad67e696c30829ff4354c2cc5d092253eec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected UsageViewDescriptor createUsageViewDescriptor(UsageInfo[] usages) {\n    PsiElement[] elements = new PsiElement[myElementsToMove.length];\n    for (int idx = 0; idx < myElementsToMove.length; idx++) {\n      elements[idx] = myElementsToMove[idx];\n    }\n    return new MoveClassesOrPackagesViewDescriptor(elements, mySearchInComments, mySearchInNonJavaFiles, myTargetPackage\n    );\n  }","id":98357,"modified_method":"protected UsageViewDescriptor createUsageViewDescriptor(UsageInfo[] usages) {\n    PsiElement[] elements = new PsiElement[myElementsToMove.length];\n    System.arraycopy(myElementsToMove, 0, elements, 0, myElementsToMove.length);\n    return new MoveClassesOrPackagesViewDescriptor(elements, mySearchInComments, mySearchInNonJavaFiles, myTargetPackage\n    );\n  }","commit_id":"8577dad67e696c30829ff4354c2cc5d092253eec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void detectPackageLocalsMoved(final UsageInfo[] usages, final ArrayList<String> conflicts) {\n//    final HashSet reportedPackageLocalUsed = new HashSet();\n    final HashSet<PsiClass> movedClasses = new HashSet<PsiClass>();\n    final HashMap<PsiClass,HashSet<PsiElement>> reportedClassToContainers = new com.intellij.util.containers.HashMap<PsiClass, HashSet<PsiElement>>();\n    final PackageWrapper aPackage = myTargetPackage;\n    for (UsageInfo usage : usages) {\n      if (usage instanceof MoveRenameUsageInfo && !(usage instanceof NonCodeUsageInfo) &&\n          ((MoveRenameUsageInfo)usage).referencedElement instanceof PsiClass) {\n        PsiClass aClass = (PsiClass)((MoveRenameUsageInfo)usage).referencedElement;\n        if (!movedClasses.contains(aClass)) {\n          movedClasses.add(aClass);\n        }\n        String visibility = VisibilityUtil.getVisibilityModifier(aClass.getModifierList());\n        if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {\n          if (PsiTreeUtil.getParentOfType(usage.getElement(), PsiImportStatement.class) != null) continue;\n          PsiElement container = ConflictsUtil.getContainer(usage.getElement());\n          if (container == null) continue;\n          HashSet<PsiElement> reported = reportedClassToContainers.get(aClass);\n          if (reported == null) {\n            reported = new HashSet<PsiElement>();\n            reportedClassToContainers.put(aClass, reported);\n          }\n\n          if (!reported.contains(container)) {\n            reported.add(container);\n            PsiFile containingFile = usage.getElement().getContainingFile();\n            if (containingFile != null && !isInsideMoved(usage.getElement())) {\n              PsiDirectory directory = containingFile.getContainingDirectory();\n              if (directory != null) {\n                PsiPackage usagePackage = directory.getPackage();\n                if (aPackage != null && usagePackage != null && !aPackage.equalToPackage(usagePackage)) {\n\n                  final String message = RefactoringBundle.message(\"a.package.local.class.0.will.no.longer.be.accessible.from.1\",\n                                                                   CommonRefactoringUtil.htmlEmphasize(aClass.getName()),\n                                                                   ConflictsUtil.getDescription(\n                                                                   container, true));\n                  conflicts.add(message);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    final MyClassInstanceReferenceVisitor instanceReferenceVisitor = new MyClassInstanceReferenceVisitor(conflicts);\n    for (final PsiClass aClass : movedClasses) {\n      String visibility = VisibilityUtil.getVisibilityModifier(aClass.getModifierList());\n      if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {\n        findInstancesOfPackageLocal(aClass, usages, instanceReferenceVisitor);\n      }\n      else {\n        // public classes\n        findPublicClassConflicts(aClass, instanceReferenceVisitor);\n      }\n    }\n  }","id":98358,"modified_method":"private void detectPackageLocalsMoved(final UsageInfo[] usages, final ArrayList<String> conflicts) {\n//    final HashSet reportedPackageLocalUsed = new HashSet();\n    final HashSet<PsiClass> movedClasses = new HashSet<PsiClass>();\n    final HashMap<PsiClass,HashSet<PsiElement>> reportedClassToContainers = new HashMap<PsiClass, HashSet<PsiElement>>();\n    final PackageWrapper aPackage = myTargetPackage;\n    for (UsageInfo usage : usages) {\n      PsiElement element = usage.getElement();\n      if (element == null) continue;\n      if (usage instanceof MoveRenameUsageInfo && !(usage instanceof NonCodeUsageInfo) &&\n          ((MoveRenameUsageInfo)usage).referencedElement instanceof PsiClass) {\n        PsiClass aClass = (PsiClass)((MoveRenameUsageInfo)usage).referencedElement;\n        if (!movedClasses.contains(aClass)) {\n          movedClasses.add(aClass);\n        }\n        String visibility = VisibilityUtil.getVisibilityModifier(aClass.getModifierList());\n        if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {\n          if (PsiTreeUtil.getParentOfType(element, PsiImportStatement.class) != null) continue;\n          PsiElement container = ConflictsUtil.getContainer(element);\n          if (container == null) continue;\n          HashSet<PsiElement> reported = reportedClassToContainers.get(aClass);\n          if (reported == null) {\n            reported = new HashSet<PsiElement>();\n            reportedClassToContainers.put(aClass, reported);\n          }\n\n          if (!reported.contains(container)) {\n            reported.add(container);\n            PsiFile containingFile = element.getContainingFile();\n            if (containingFile != null && !isInsideMoved(element)) {\n              PsiDirectory directory = containingFile.getContainingDirectory();\n              if (directory != null) {\n                PsiPackage usagePackage = directory.getPackage();\n                if (aPackage != null && usagePackage != null && !aPackage.equalToPackage(usagePackage)) {\n\n                  final String message = RefactoringBundle.message(\"a.package.local.class.0.will.no.longer.be.accessible.from.1\",\n                                                                   CommonRefactoringUtil.htmlEmphasize(aClass.getName()),\n                                                                   ConflictsUtil.getDescription(\n                                                                   container, true));\n                  conflicts.add(message);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    final MyClassInstanceReferenceVisitor instanceReferenceVisitor = new MyClassInstanceReferenceVisitor(conflicts);\n    for (final PsiClass aClass : movedClasses) {\n      String visibility = VisibilityUtil.getVisibilityModifier(aClass.getModifierList());\n      if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {\n        findInstancesOfPackageLocal(aClass, usages, instanceReferenceVisitor);\n      }\n      else {\n        // public classes\n        findPublicClassConflicts(aClass, instanceReferenceVisitor);\n      }\n    }\n  }","commit_id":"8577dad67e696c30829ff4354c2cc5d092253eec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getNewQName(PsiElement element) {\n    final String qualifiedName = myTargetPackage.getQualifiedName();\n    if (element instanceof PsiClass) {\n      return qualifiedName + (qualifiedName.equals(\"\") ? \"\" : \".\") + ((PsiClass)element).getName();\n    }\n    else if (element instanceof PsiPackage) {\n      return qualifiedName + (qualifiedName.equals(\"\") ? \"\" : \".\") + ((PsiPackage)element).getName();\n    }\n    else {\n      LOG.assertTrue(false);\n      return null;\n    }\n  }","id":98359,"modified_method":"private String getNewQName(PsiElement element) {\n    final String qualifiedName = myTargetPackage.getQualifiedName();\n    if (element instanceof PsiClass) {\n      return qualifiedName + (qualifiedName.length() == 0 ? \"\" : \".\") + ((PsiClass)element).getName();\n    }\n    else if (element instanceof PsiPackage) {\n      return qualifiedName + (qualifiedName.length() == 0 ? \"\" : \".\") + ((PsiPackage)element).getName();\n    }\n    else {\n      LOG.assertTrue(false);\n      return null;\n    }\n  }","commit_id":"8577dad67e696c30829ff4354c2cc5d092253eec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void refreshElements(PsiElement[] elements) {\n    LOG.assertTrue(elements.length == myElementsToMove.length);\n    for (int idx = 0; idx < elements.length; idx++) {\n      myElementsToMove[idx] = elements[idx];\n    }\n  }","id":98360,"modified_method":"protected void refreshElements(PsiElement[] elements) {\n    LOG.assertTrue(elements.length == myElementsToMove.length);\n    System.arraycopy(elements, 0, myElementsToMove, 0, elements.length);\n  }","commit_id":"8577dad67e696c30829ff4354c2cc5d092253eec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * \n\t * Further processing (filtering in this case) of internal proposal objects\n\t * before they are added to the list of ICompletionProposal returned from\n\t * {@link #getProposals(org.eclipse.xtext.ui.service.IProposalsProvider.ICompletionContext)}\n\t * \n\t * @param proposal\n\t *            the current proposal to process\n\t * @param currentLeafNode\n\t *            the node from the current parsetree\n\t * @param offset\n\t *            the current offset\n\t * @param completionProposalList\n\t *            list containing all 'processed'\n\t *            <code>ICompletionProposal<\/code> items\n\t */\n\tprotected void processProposal(Proposal proposal, LeafNode currentLeafNode,\n\t\t\tint offset, List<ICompletionProposal> completionProposalList) {\n\t\t// filter proposals\n\t\tif (currentLeafNode != null\n\t\t\t\t&& !\"\".equals(currentLeafNode.getText().trim())\n\t\t\t\t&& (currentLeafNode.isHidden())) {\n\t\t\tif (proposal.getText().startsWith(currentLeafNode.getText())) {\n\t\t\t\tproposal.setText(proposal.getText().replaceFirst(\n\t\t\t\t\t\tcurrentLeafNode.getText(), \"\"));\n\t\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n\t\t\t\t\t\t.getText(), proposal.getLabel(), proposal\n\t\t\t\t\t\t.getDescription(), proposal.getImage(),\n\t\t\t\t\t\tthis.namespaceIdentifier, offset));\n\t\t\t}\n\t\t} else {\n\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n\t\t\t\t\t.getText(), proposal.getLabel(), proposal.getDescription(),\n\t\t\t\t\tproposal.getImage(), this.namespaceIdentifier, offset));\n\t\t}\n\t}","id":98361,"modified_method":"/**\n\t * \n\t * Further processing (filtering in this case) of internal proposal objects\n\t * before they are added to the list of ICompletionProposal returned from\n\t * {@link #getProposals(org.eclipse.xtext.ui.service.IProposalsProvider.ICompletionContext)}\n\t * \n\t * @param proposal\n\t *            the current proposal to process\n\t * @param currentLeafNode\n\t *            the node from the current parsetree\n\t * @param offset\n\t *            the current offset\n\t * @param completionProposalList\n\t *            list containing all 'processed'\n\t *            <code>ICompletionProposal<\/code> items\n\t */\n\tprotected void processProposal(Proposal proposal, LeafNode currentLeafNode,\n\t\t\tint offset, List<ICompletionProposal> completionProposalList) {\n\t\t// filter proposals\n//\t\tif (currentLeafNode != null\n//\t\t\t\t&& !\"\".equals(currentLeafNode.getText().trim())\n//\t\t\t\t&& (currentLeafNode.isHidden())) {\n//\t\t\tif (proposal.getText().startsWith(currentLeafNode.getText())) {\n//\t\t\t\tproposal.setText(proposal.getText().replaceFirst(\n//\t\t\t\t\t\tcurrentLeafNode.getText(), \"\"));\n//\t\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n//\t\t\t\t\t\t.getText(), proposal.getLabel(), proposal\n//\t\t\t\t\t\t.getDescription(), proposal.getImage(),\n//\t\t\t\t\t\tthis.namespaceIdentifier, offset));\n//\t\t\t}\n//\t\t} else {\n//\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n//\t\t\t\t\t.getText(), proposal.getLabel(), proposal.getDescription(),\n//\t\t\t\t\tproposal.getImage(), this.namespaceIdentifier, offset));\n//\t\t}\n\t}","commit_id":"f52ea33709b087828a8e5b276ff40d7d47c1266c","url":"https://github.com/eclipse/xtext"},{"original_method":"private final Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n\t\tAssert.isNotNull(clazz, \"Class must not be null\");\n\t\tAssert.isNotNull(name, \"Method name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (!Object.class.equals(searchType) && searchType != null) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() : searchType.getDeclaredMethods());\n\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\tMethod method = methods[i];\n\t\t\t\tif (name.equals(method.getName())\n\t\t\t\t\t\t&& (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}","id":98362,"modified_method":"private final Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n\t\tAssert.isNotNull(clazz, \"Class must not be null\");\n\t\tAssert.isNotNull(name, \"Method name must not be null\");\n\t\tMethod result = methodLookupMap.get(name);\n\t\tClass<?> searchType = clazz;\n\t\twhile (!Object.class.equals(searchType) && searchType != null && null == result) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() : searchType.getDeclaredMethods());\n\t\t\tfor (int i = 0; i < methods.length && null == result; i++) {\n\t\t\t\tMethod method = methods[i];\n\t\t\t\tif (name.equals(method.getName())\n\t\t\t\t\t\t&& (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {\n\t\t\t\t\tresult = method;\n\t\t\t\t\tmethodLookupMap.put(name, method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn result;\n\t}","commit_id":"f52ea33709b087828a8e5b276ff40d7d47c1266c","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\tif (proposalProvider != null) {\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\t// last COMPLETE node element (node with associated grammar element)\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\t\t\t\t// node at the CURRENT cursor position (node with or without grammar element)\n\t\t\t\tLeafNode currentLeafNode = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\t\t\t\t// get associated grammar element\n\t\t\t\tAbstractElement grammarElement = ParseTreeUtil.getGrammarElementFromNode(lastCompleteNode);\n\n\t\t\t\tString prefix = viewer.getTextWidget().getText(currentLeafNode.getOffset(), offset);\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tfor (Iterator<AbstractElement> iterator = calculatePossibleElementSet(lastCompleteNode, grammarElement)\n\t\t\t\t\t\t.iterator(); iterator.hasNext();) {\n\t\t\t\t\tAbstractElement nextElement = iterator.next();\n\n\t\t\t\t\tList<EObject> resolvedElementOrRuleList = resolveElement(nextElement);\n\n\t\t\t\t\tfor (Iterator<EObject> elementOrRuleIterator = resolvedElementOrRuleList.iterator(); elementOrRuleIterator\n\t\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\t\tEObject abstractElement = elementOrRuleIterator.next();\n\n\t\t\t\t\t\tif (abstractElement instanceof Keyword) {\n\t\t\t\t\t\t\tcompletionProposalList.addAll(proposalProvider.completeKeyword((Keyword) abstractElement,\n\t\t\t\t\t\t\t\t\tcurrentLeafNode, prefix, xtextDocument, offset));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof Assignment) {\n\n\t\t\t\t\t\t\tAssignment assignment = (Assignment) abstractElement;\n\n\t\t\t\t\t\t\tParserRule lexerRule = GrammarUtil.containingParserRule(assignment);\n\n\t\t\t\t\t\t\tMethod method = findMethod(proposalProvider.getClass(), \"complete\"\n\t\t\t\t\t\t\t\t\t+ firstLetterCapitalized(lexerRule.getName())\n\t\t\t\t\t\t\t\t\t+ firstLetterCapitalized(assignment.getFeature()), Assignment.class, EObject.class,\n\t\t\t\t\t\t\t\t\tString.class, IDocument.class, int.class);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCollection<? extends ICompletionProposal> assignmentProposalList = (Collection<? extends ICompletionProposal>) invokeMethod(method, proposalProvider, assignment, currentLeafNode, prefix, xtextDocument,\n\t\t\t\t\t\t\t\t\toffset);\n\n\t\t\t\t\t\t\tcompletionProposalList.addAll(assignmentProposalList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof LexerRule) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof RuleCall) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof CrossReference) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof Action) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList);\n\t\t\t\t\treturn (ICompletionProposal[]) sortAndFilter.toArray(new ICompletionProposal[] {});\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":98363,"modified_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\tif (proposalProvider != null) {\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\t// last COMPLETE node element with associated grammar element\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\t\t\t\t// node at CURRENT cursor pos. with or without grammar element\n\t\t\t\tLeafNode currentLeafNode = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\t\t\t\t// get associated grammar element\n\t\t\t\tAbstractElement grammarElement = ParseTreeUtil.getGrammarElementFromNode(lastCompleteNode);\n\n\t\t\t\tString prefix = viewer.getTextWidget().getText(currentLeafNode.getOffset(), offset);\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tfor (Iterator<AbstractElement> iterator = calculatePossibleElementSet(lastCompleteNode, grammarElement)\n\t\t\t\t\t\t.iterator(); iterator.hasNext();) {\n\t\t\t\t\tAbstractElement nextElement = iterator.next();\n\n\t\t\t\t\tList<EObject> resolvedElementOrRuleList = resolveElement(nextElement, true);\n\n\t\t\t\t\tcollectCompletionProposalList(resolvedElementOrRuleList, completionProposalList, xtextDocument,\n\t\t\t\t\t\t\tcurrentLeafNode, prefix, offset);\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList);\n\t\t\t\t\treturn (ICompletionProposal[]) sortAndFilter.toArray(new ICompletionProposal[] {});\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"f52ea33709b087828a8e5b276ff40d7d47c1266c","url":"https://github.com/eclipse/xtext"},{"original_method":"private final Object invokeMethod(Method method, Object target, Object... args) {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"huh?\");\n\t}","id":98364,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate final Collection<ICompletionProposal> invokeMethod(Method method, Object target, Object... args) {\n\t\ttry {\n\t\t\treturn (Collection<ICompletionProposal>) method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"huh?\");\n\t}","commit_id":"f52ea33709b087828a8e5b276ff40d7d47c1266c","url":"https://github.com/eclipse/xtext"},{"original_method":"protected final List<EObject> resolveElement(AbstractElement abstractElement) {\n\n\t\tList<EObject> elementList = new ArrayList<EObject>();\n\n\t\tif (abstractElement instanceof Alternatives) {\n\t\t\tfor (AbstractElement alternativeElement : ((Alternatives) abstractElement).getGroups()) {\n\t\t\t\telementList.addAll(resolveElement(alternativeElement));\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof Assignment) {\n\n\t\t\tAssignment assignment = (Assignment) abstractElement;\n\n\t\t\tif (assignment.getTerminal() instanceof RuleCall) {\n\n\t\t\t\tAbstractRule abstractRule = GrammarUtil.calledRule((RuleCall) assignment.getTerminal());\n\n\t\t\t\tif (abstractRule instanceof ParserRule) {\n\t\t\t\t\telementList.addAll(resolveElement(assignment.getTerminal()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\telementList.add(assignment);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementList.add(assignment);\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof RuleCall) {\n\t\t\tAbstractRule abstractRule = GrammarUtil.calledRule((RuleCall) abstractElement);\n\n\t\t\tif (null == abstractRule) {\n\t\t\t\telementList.add(abstractElement);\n\t\t\t}\n\t\t\telse if (abstractRule instanceof LexerRule) {\n\t\t\t\telementList.add(abstractRule);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resolveElement(((ParserRule) abstractRule).getAlternatives());\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof Group) {\n\t\t\tboolean includeNext = true;\n\t\t\tfor (Iterator<AbstractElement> iterator = ((Group) abstractElement).getAbstractTokens().iterator(); iterator\n\t\t\t\t\t.hasNext()\n\t\t\t\t\t&& includeNext;) {\n\t\t\t\tAbstractElement groupElement = iterator.next();\n\t\t\t\telementList.addAll(resolveElement(groupElement));\n\t\t\t\tincludeNext = GrammarUtil.isOptionalCardinality(groupElement);\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\telementList.add(abstractElement);\n\t\t}\n\t\treturn elementList;\n\t}","id":98365,"modified_method":"protected final List<EObject> resolveElement(AbstractElement abstractElement, boolean resolveRuleCall) {\n\n\t\tList<EObject> elementList = new ArrayList<EObject>();\n\n\t\tif (abstractElement instanceof Alternatives) {\n\t\t\tfor (AbstractElement alternativeElement : ((Alternatives) abstractElement).getGroups()) {\n\t\t\t\telementList.addAll(resolveElement(alternativeElement, resolveRuleCall));\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof Group) {\n\t\t\tboolean includeNext = true;\n\t\t\tfor (Iterator<AbstractElement> iterator = ((Group) abstractElement).getAbstractTokens().iterator(); iterator\n\t\t\t\t\t.hasNext()\n\t\t\t\t\t&& includeNext;) {\n\t\t\t\tAbstractElement groupElement = iterator.next();\n\t\t\t\telementList.addAll(resolveElement(groupElement, resolveRuleCall));\n\t\t\t\tincludeNext = GrammarUtil.isOptionalCardinality(groupElement);\n\t\t\t}\n\n\t\t}\n\t\telse if (abstractElement instanceof Assignment) {\n\n\t\t\tAssignment assignment = (Assignment) abstractElement;\n\n\t\t\tif (assignment.getTerminal() instanceof RuleCall && resolveRuleCall) {\n\t\t\t\telementList.addAll(resolveElement(assignment.getTerminal(), resolveRuleCall));\n\t\t\t}\n\t\t\telse if (assignment.getTerminal() instanceof Alternatives) {\n\t\t\t\telementList.addAll(resolveElement(assignment.getTerminal(), resolveRuleCall));\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementList.add(assignment);\n\t\t\t}\n\n\t\t}\n\t\telse if (abstractElement instanceof RuleCall) {\n\n\t\t\tAbstractRule abstractRule = GrammarUtil.calledRule((RuleCall) abstractElement);\n\n\t\t\tif (abstractRule instanceof ParserRule) {\n\t\t\t\telementList.addAll(resolveElement(((ParserRule) abstractRule).getAlternatives(), resolveRuleCall));\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementList.add(abstractElement);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\telementList.add(abstractElement);\n\t\t}\n\t\treturn elementList;\n\t}","commit_id":"f52ea33709b087828a8e5b276ff40d7d47c1266c","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * \n\t * Further processing (filtering in this case) of internal proposal objects\n\t * before they are added to the list of ICompletionProposal returned from\n\t * {@link #getProposals(org.eclipse.xtext.ui.service.IProposalsProvider.ICompletionContext)}\n\t * \n\t * @param proposal\n\t *            the current proposal to process\n\t * @param currentLeafNode\n\t *            the node from the current parsetree\n\t * @param offset\n\t *            the current offset\n\t * @param completionProposalList\n\t *            list containing all 'processed'\n\t *            <code>ICompletionProposal<\/code> items\n\t */\n\tprotected void processProposal(Proposal proposal, LeafNode currentLeafNode,\n\t\t\tint offset, List<ICompletionProposal> completionProposalList) {\n\t\t// filter proposals\n\t\tif (currentLeafNode != null\n\t\t\t\t&& !\"\".equals(currentLeafNode.getText().trim())\n\t\t\t\t&& (currentLeafNode.isHidden())) {\n\t\t\tif (proposal.getText().startsWith(currentLeafNode.getText())) {\n\t\t\t\tproposal.setText(proposal.getText().replaceFirst(\n\t\t\t\t\t\tcurrentLeafNode.getText(), \"\"));\n\t\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n\t\t\t\t\t\t.getText(), proposal.getLabel(), proposal\n\t\t\t\t\t\t.getDescription(), proposal.getImage(),\n\t\t\t\t\t\tthis.namespaceIdentifier, offset));\n\t\t\t}\n\t\t} else {\n\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n\t\t\t\t\t.getText(), proposal.getLabel(), proposal.getDescription(),\n\t\t\t\t\tproposal.getImage(), this.namespaceIdentifier, offset));\n\t\t}\n\t}","id":98366,"modified_method":"/**\n\t * \n\t * Further processing (filtering in this case) of internal proposal objects\n\t * before they are added to the list of ICompletionProposal returned from\n\t * {@link #getProposals(org.eclipse.xtext.ui.service.IProposalsProvider.ICompletionContext)}\n\t * \n\t * @param proposal\n\t *            the current proposal to process\n\t * @param currentLeafNode\n\t *            the node from the current parsetree\n\t * @param offset\n\t *            the current offset\n\t * @param completionProposalList\n\t *            list containing all 'processed'\n\t *            <code>ICompletionProposal<\/code> items\n\t */\n\tprotected void processProposal(Proposal proposal, LeafNode currentLeafNode,\n\t\t\tint offset, List<ICompletionProposal> completionProposalList) {\n\t\t// filter proposals\n//\t\tif (currentLeafNode != null\n//\t\t\t\t&& !\"\".equals(currentLeafNode.getText().trim())\n//\t\t\t\t&& (currentLeafNode.isHidden())) {\n//\t\t\tif (proposal.getText().startsWith(currentLeafNode.getText())) {\n//\t\t\t\tproposal.setText(proposal.getText().replaceFirst(\n//\t\t\t\t\t\tcurrentLeafNode.getText(), \"\"));\n//\t\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n//\t\t\t\t\t\t.getText(), proposal.getLabel(), proposal\n//\t\t\t\t\t\t.getDescription(), proposal.getImage(),\n//\t\t\t\t\t\tthis.namespaceIdentifier, offset));\n//\t\t\t}\n//\t\t} else {\n//\t\t\tcompletionProposalList.add(new XtextCompletionProposal(proposal\n//\t\t\t\t\t.getText(), proposal.getLabel(), proposal.getDescription(),\n//\t\t\t\t\tproposal.getImage(), this.namespaceIdentifier, offset));\n//\t\t}\n\t}","commit_id":"6e9b6e0326a355db3a5a6f4b684df12c1b949787","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\tif (proposalProvider != null) {\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\t// last COMPLETE node element (node with associated grammar element)\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\t\t\t\t// node at the CURRENT cursor position (node with or without grammar element)\n\t\t\t\tLeafNode currentLeafNode = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\t\t\t\t// get associated grammar element\n\t\t\t\tAbstractElement grammarElement = ParseTreeUtil.getGrammarElementFromNode(lastCompleteNode);\n\n\t\t\t\tString prefix = viewer.getTextWidget().getText(currentLeafNode.getOffset(), offset);\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tfor (Iterator<AbstractElement> iterator = calculatePossibleElementSet(lastCompleteNode, grammarElement)\n\t\t\t\t\t\t.iterator(); iterator.hasNext();) {\n\t\t\t\t\tAbstractElement nextElement = iterator.next();\n\n\t\t\t\t\tList<EObject> resolvedElementOrRuleList = resolveElement(nextElement);\n\n\t\t\t\t\tfor (Iterator<EObject> elementOrRuleIterator = resolvedElementOrRuleList.iterator(); elementOrRuleIterator\n\t\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\t\tEObject abstractElement = elementOrRuleIterator.next();\n\n\t\t\t\t\t\tif (abstractElement instanceof Keyword) {\n\t\t\t\t\t\t\tcompletionProposalList.addAll(proposalProvider.completeKeyword((Keyword) abstractElement,\n\t\t\t\t\t\t\t\t\tcurrentLeafNode, prefix, xtextDocument, offset));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof Assignment) {\n\n\t\t\t\t\t\t\tAssignment assignment = (Assignment) abstractElement;\n\n\t\t\t\t\t\t\tParserRule lexerRule = GrammarUtil.containingParserRule(assignment);\n\n\t\t\t\t\t\t\tMethod method = findMethod(proposalProvider.getClass(), \"complete\"\n\t\t\t\t\t\t\t\t\t+ firstLetterCapitalized(lexerRule.getName())\n\t\t\t\t\t\t\t\t\t+ firstLetterCapitalized(assignment.getFeature()), Assignment.class, EObject.class,\n\t\t\t\t\t\t\t\t\tString.class, IDocument.class, int.class);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCollection<? extends ICompletionProposal> assignmentProposalList = (Collection<? extends ICompletionProposal>) invokeMethod(method, proposalProvider, assignment, currentLeafNode, prefix, xtextDocument,\n\t\t\t\t\t\t\t\t\toffset);\n\n\t\t\t\t\t\t\tcompletionProposalList.addAll(assignmentProposalList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof LexerRule) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof RuleCall) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof CrossReference) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (abstractElement instanceof Action) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList);\n\t\t\t\t\treturn (ICompletionProposal[]) sortAndFilter.toArray(new ICompletionProposal[] {});\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":98367,"modified_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\tif (proposalProvider != null) {\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\t// last COMPLETE node element with associated grammar element\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\t\t\t\t// node at CURRENT cursor pos. with or without grammar element\n\t\t\t\tLeafNode currentLeafNode = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\t\t\t\t// get associated grammar element\n\t\t\t\tAbstractElement grammarElement = ParseTreeUtil.getGrammarElementFromNode(lastCompleteNode);\n\n\t\t\t\tString prefix = viewer.getTextWidget().getText(currentLeafNode.getOffset(), offset);\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tfor (Iterator<AbstractElement> iterator = calculatePossibleElementSet(lastCompleteNode, grammarElement)\n\t\t\t\t\t\t.iterator(); iterator.hasNext();) {\n\t\t\t\t\tAbstractElement nextElement = iterator.next();\n\n\t\t\t\t\tList<EObject> resolvedElementOrRuleList = resolveElement(nextElement, true);\n\n\t\t\t\t\tcollectCompletionProposalList(resolvedElementOrRuleList, completionProposalList, xtextDocument,\n\t\t\t\t\t\t\tcurrentLeafNode, prefix, offset);\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList);\n\t\t\t\t\treturn (ICompletionProposal[]) sortAndFilter.toArray(new ICompletionProposal[] {});\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"6e9b6e0326a355db3a5a6f4b684df12c1b949787","url":"https://github.com/eclipse/xtext"},{"original_method":"private final Object invokeMethod(Method method, Object target, Object... args) {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"huh?\");\n\t}","id":98368,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate final Collection<ICompletionProposal> invokeMethod(Method method, Object target, Object... args) {\n\t\ttry {\n\t\t\treturn (Collection<ICompletionProposal>) method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"huh?\");\n\t}","commit_id":"6e9b6e0326a355db3a5a6f4b684df12c1b949787","url":"https://github.com/eclipse/xtext"},{"original_method":"private final Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n\t\tAssert.isNotNull(clazz, \"Class must not be null\");\n\t\tAssert.isNotNull(name, \"Method name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (!Object.class.equals(searchType) && searchType != null) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() : searchType.getDeclaredMethods());\n\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\tMethod method = methods[i];\n\t\t\t\tif (name.equals(method.getName())\n\t\t\t\t\t\t&& (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}","id":98369,"modified_method":"private final Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n\t\tAssert.isNotNull(clazz, \"Class must not be null\");\n\t\tAssert.isNotNull(name, \"Method name must not be null\");\n\t\tMethod result = methodLookupMap.get(name);\n\t\tClass<?> searchType = clazz;\n\t\twhile (!Object.class.equals(searchType) && searchType != null && null == result) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() : searchType.getDeclaredMethods());\n\t\t\tfor (int i = 0; i < methods.length && null == result; i++) {\n\t\t\t\tMethod method = methods[i];\n\t\t\t\tif (name.equals(method.getName())\n\t\t\t\t\t\t&& (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {\n\t\t\t\t\tresult = method;\n\t\t\t\t\tmethodLookupMap.put(name, method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn result;\n\t}","commit_id":"6e9b6e0326a355db3a5a6f4b684df12c1b949787","url":"https://github.com/eclipse/xtext"},{"original_method":"protected final List<EObject> resolveElement(AbstractElement abstractElement) {\n\n\t\tList<EObject> elementList = new ArrayList<EObject>();\n\n\t\tif (abstractElement instanceof Alternatives) {\n\t\t\tfor (AbstractElement alternativeElement : ((Alternatives) abstractElement).getGroups()) {\n\t\t\t\telementList.addAll(resolveElement(alternativeElement));\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof Assignment) {\n\n\t\t\tAssignment assignment = (Assignment) abstractElement;\n\n\t\t\tif (assignment.getTerminal() instanceof RuleCall) {\n\n\t\t\t\tAbstractRule abstractRule = GrammarUtil.calledRule((RuleCall) assignment.getTerminal());\n\n\t\t\t\tif (abstractRule instanceof ParserRule) {\n\t\t\t\t\telementList.addAll(resolveElement(assignment.getTerminal()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\telementList.add(assignment);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementList.add(assignment);\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof RuleCall) {\n\t\t\tAbstractRule abstractRule = GrammarUtil.calledRule((RuleCall) abstractElement);\n\n\t\t\tif (null == abstractRule) {\n\t\t\t\telementList.add(abstractElement);\n\t\t\t}\n\t\t\telse if (abstractRule instanceof LexerRule) {\n\t\t\t\telementList.add(abstractRule);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resolveElement(((ParserRule) abstractRule).getAlternatives());\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof Group) {\n\t\t\tboolean includeNext = true;\n\t\t\tfor (Iterator<AbstractElement> iterator = ((Group) abstractElement).getAbstractTokens().iterator(); iterator\n\t\t\t\t\t.hasNext()\n\t\t\t\t\t&& includeNext;) {\n\t\t\t\tAbstractElement groupElement = iterator.next();\n\t\t\t\telementList.addAll(resolveElement(groupElement));\n\t\t\t\tincludeNext = GrammarUtil.isOptionalCardinality(groupElement);\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\telementList.add(abstractElement);\n\t\t}\n\t\treturn elementList;\n\t}","id":98370,"modified_method":"protected final List<EObject> resolveElement(AbstractElement abstractElement, boolean resolveRuleCall) {\n\n\t\tList<EObject> elementList = new ArrayList<EObject>();\n\n\t\tif (abstractElement instanceof Alternatives) {\n\t\t\tfor (AbstractElement alternativeElement : ((Alternatives) abstractElement).getGroups()) {\n\t\t\t\telementList.addAll(resolveElement(alternativeElement, resolveRuleCall));\n\t\t\t}\n\t\t}\n\t\telse if (abstractElement instanceof Group) {\n\t\t\tboolean includeNext = true;\n\t\t\tfor (Iterator<AbstractElement> iterator = ((Group) abstractElement).getAbstractTokens().iterator(); iterator\n\t\t\t\t\t.hasNext()\n\t\t\t\t\t&& includeNext;) {\n\t\t\t\tAbstractElement groupElement = iterator.next();\n\t\t\t\telementList.addAll(resolveElement(groupElement, resolveRuleCall));\n\t\t\t\tincludeNext = GrammarUtil.isOptionalCardinality(groupElement);\n\t\t\t}\n\n\t\t}\n\t\telse if (abstractElement instanceof Assignment) {\n\n\t\t\tAssignment assignment = (Assignment) abstractElement;\n\n\t\t\tif (assignment.getTerminal() instanceof RuleCall && resolveRuleCall) {\n\t\t\t\telementList.addAll(resolveElement(assignment.getTerminal(), resolveRuleCall));\n\t\t\t}\n\t\t\telse if (assignment.getTerminal() instanceof Alternatives) {\n\t\t\t\telementList.addAll(resolveElement(assignment.getTerminal(), resolveRuleCall));\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementList.add(assignment);\n\t\t\t}\n\n\t\t}\n\t\telse if (abstractElement instanceof RuleCall) {\n\n\t\t\tAbstractRule abstractRule = GrammarUtil.calledRule((RuleCall) abstractElement);\n\n\t\t\tif (abstractRule instanceof ParserRule) {\n\t\t\t\telementList.addAll(resolveElement(((ParserRule) abstractRule).getAlternatives(), resolveRuleCall));\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementList.add(abstractElement);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\telementList.add(abstractElement);\n\t\t}\n\t\treturn elementList;\n\t}","commit_id":"6e9b6e0326a355db3a5a6f4b684df12c1b949787","url":"https://github.com/eclipse/xtext"},{"original_method":"public static Map<String, AlignmentContext> splitContextBySampleName(ReadBackedPileup pileup, String assumedSingleSample) {\n        return splitContextBySampleName(new AlignmentContext(pileup.getLocation(), pileup));\n    }","id":98371,"modified_method":"public static Map<String, AlignmentContext> splitContextBySampleName(ReadBackedPileup pileup) {\n        return splitContextBySampleName(new AlignmentContext(pileup.getLocation(), pileup));\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        // get all of the unique sample names\n        // if we're supposed to assume a single sample, do so\n        Set<String> samples = new TreeSet<String>();\n        if ( UAC.ASSUME_SINGLE_SAMPLE != null )\n            samples.add(UAC.ASSUME_SINGLE_SAMPLE);\n        else\n            samples = SampleUtils.getSAMFileSamples(getToolkit().getSAMFileHeader());\n\n        UG_engine = new UnifiedGenotyperEngine(getToolkit(), UAC, logger, null, null, samples);\n\n        // initialize the header\n        Set<VCFHeaderLine> headerInfo = new HashSet<VCFHeaderLine>();\n        headerInfo.add(new VCFInfoHeaderLine(VCFConstants.DOWNSAMPLED_KEY, 0, VCFHeaderLineType.Flag, \"Were any of the samples downsampled?\"));\n        headerInfo.add(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_KEY, 1, VCFHeaderLineType.String, \"Genotype\"));\n        headerInfo.add(new VCFFormatHeaderLine(VCFConstants.DEPTH_KEY, 1, VCFHeaderLineType.Integer, \"Read Depth (only filtered reads used for calling)\"));\n        headerInfo.add(new VCFFormatHeaderLine(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, 3, VCFHeaderLineType.Float, \"Normalized, Phred-scaled likelihoods for AA,AB,BB genotypes where A=ref and B=alt; not applicable if site is not biallelic\"));\n\n        writer.writeHeader(new VCFHeader(headerInfo, samples)) ;\n    }","id":98372,"modified_method":"public void initialize() {\n        // get all of the unique sample names\n        Set<String> samples = SampleUtils.getSAMFileSamples(getToolkit().getSAMFileHeader());\n\n        UG_engine = new UnifiedGenotyperEngine(getToolkit(), UAC, logger, null, null, samples);\n\n        // initialize the header\n        Set<VCFHeaderLine> headerInfo = new HashSet<VCFHeaderLine>();\n        headerInfo.add(new VCFInfoHeaderLine(VCFConstants.DOWNSAMPLED_KEY, 0, VCFHeaderLineType.Flag, \"Were any of the samples downsampled?\"));\n        headerInfo.add(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_KEY, 1, VCFHeaderLineType.String, \"Genotype\"));\n        headerInfo.add(new VCFFormatHeaderLine(VCFConstants.DEPTH_KEY, 1, VCFHeaderLineType.Integer, \"Read Depth (only filtered reads used for calling)\"));\n        headerInfo.add(new VCFFormatHeaderLine(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, 3, VCFHeaderLineType.Float, \"Normalized, Phred-scaled likelihoods for AA,AB,BB genotypes where A=ref and B=alt; not applicable if site is not biallelic\"));\n\n        writer.writeHeader(new VCFHeader(headerInfo, samples)) ;\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public UnifiedArgumentCollection clone() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n\n        uac.GLmodel = GLmodel;\n        uac.AFmodel = AFmodel;\n        uac.heterozygosity = heterozygosity;\n        uac.PCR_error = PCR_error;\n        uac.GenotypingMode = GenotypingMode;\n        uac.OutputMode = OutputMode;\n        uac.COMPUTE_SLOD = COMPUTE_SLOD;\n        uac.ASSUME_SINGLE_SAMPLE = ASSUME_SINGLE_SAMPLE;\n        uac.STANDARD_CONFIDENCE_FOR_CALLING = STANDARD_CONFIDENCE_FOR_CALLING;\n        uac.STANDARD_CONFIDENCE_FOR_EMITTING = STANDARD_CONFIDENCE_FOR_EMITTING;\n        uac.MIN_BASE_QUALTY_SCORE = MIN_BASE_QUALTY_SCORE;\n        uac.MAX_DELETION_FRACTION = MAX_DELETION_FRACTION;\n        uac.MIN_INDEL_COUNT_FOR_GENOTYPING = MIN_INDEL_COUNT_FOR_GENOTYPING;\n        uac.INDEL_HETEROZYGOSITY = INDEL_HETEROZYGOSITY;\n        uac.INDEL_GAP_OPEN_PENALTY = INDEL_GAP_OPEN_PENALTY;\n        uac.INDEL_GAP_CONTINUATION_PENALTY = INDEL_GAP_CONTINUATION_PENALTY;\n        uac.OUTPUT_DEBUG_INDEL_INFO = OUTPUT_DEBUG_INDEL_INFO;\n        uac.INDEL_HAPLOTYPE_SIZE = INDEL_HAPLOTYPE_SIZE;\n        uac.alleles = alleles;\n\n        // todo- arguments to remove\n        uac.IGNORE_SNP_ALLELES = IGNORE_SNP_ALLELES;\n        uac.BANDED_INDEL_COMPUTATION = BANDED_INDEL_COMPUTATION;\n        return uac;\n    }","id":98373,"modified_method":"public UnifiedArgumentCollection clone() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n\n        uac.GLmodel = GLmodel;\n        uac.AFmodel = AFmodel;\n        uac.heterozygosity = heterozygosity;\n        uac.PCR_error = PCR_error;\n        uac.GenotypingMode = GenotypingMode;\n        uac.OutputMode = OutputMode;\n        uac.COMPUTE_SLOD = COMPUTE_SLOD;\n        uac.STANDARD_CONFIDENCE_FOR_CALLING = STANDARD_CONFIDENCE_FOR_CALLING;\n        uac.STANDARD_CONFIDENCE_FOR_EMITTING = STANDARD_CONFIDENCE_FOR_EMITTING;\n        uac.MIN_BASE_QUALTY_SCORE = MIN_BASE_QUALTY_SCORE;\n        uac.MAX_DELETION_FRACTION = MAX_DELETION_FRACTION;\n        uac.MIN_INDEL_COUNT_FOR_GENOTYPING = MIN_INDEL_COUNT_FOR_GENOTYPING;\n        uac.INDEL_HETEROZYGOSITY = INDEL_HETEROZYGOSITY;\n        uac.INDEL_GAP_OPEN_PENALTY = INDEL_GAP_OPEN_PENALTY;\n        uac.INDEL_GAP_CONTINUATION_PENALTY = INDEL_GAP_CONTINUATION_PENALTY;\n        uac.OUTPUT_DEBUG_INDEL_INFO = OUTPUT_DEBUG_INDEL_INFO;\n        uac.INDEL_HAPLOTYPE_SIZE = INDEL_HAPLOTYPE_SIZE;\n        uac.alleles = alleles;\n\n        // todo- arguments to remove\n        uac.IGNORE_SNP_ALLELES = IGNORE_SNP_ALLELES;\n        uac.BANDED_INDEL_COMPUTATION = BANDED_INDEL_COMPUTATION;\n        return uac;\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Initialize the samples, output, and genotype calculation model\n     *\n     **/\n    public void initialize() {\n        // get all of the unique sample names\n        // if we're supposed to assume a single sample, do so\n        Set<String> samples = new TreeSet<String>();\n        if ( UAC.ASSUME_SINGLE_SAMPLE != null )\n            samples.add(UAC.ASSUME_SINGLE_SAMPLE);\n        else\n            samples = SampleUtils.getSAMFileSamples(getToolkit().getSAMFileHeader());\n\n        // initialize the verbose writer\n        if ( verboseWriter != null )\n            verboseWriter.println(\"AFINFO\\tLOC\\tREF\\tALT\\tMAF\\tF\\tAFprior\\tAFposterior\\tNormalizedPosterior\");\n\n        annotationEngine = new VariantAnnotatorEngine(Arrays.asList(annotationClassesToUse), annotationsToUse, annotationsToExclude, this, getToolkit());\n        UG_engine = new UnifiedGenotyperEngine(getToolkit(), UAC, logger, verboseWriter, annotationEngine, samples);\n\n        // initialize the header\n        Set<VCFHeaderLine> headerInfo = getHeaderInfo();\n\n        // invoke initialize() method on each of the annotation classes, allowing them to add their own header lines\n        // and perform any necessary initialization/validation steps\n        annotationEngine.invokeAnnotationInitializationMethods(headerInfo);\n\n        writer.writeHeader(new VCFHeader(headerInfo, samples));\n    }","id":98374,"modified_method":"/**\n     * Initialize the samples, output, and genotype calculation model\n     *\n     **/\n    public void initialize() {\n        // get all of the unique sample names\n        Set<String> samples = SampleUtils.getSAMFileSamples(getToolkit().getSAMFileHeader());\n\n        // initialize the verbose writer\n        if ( verboseWriter != null )\n            verboseWriter.println(\"AFINFO\\tLOC\\tREF\\tALT\\tMAF\\tF\\tAFprior\\tAFposterior\\tNormalizedPosterior\");\n\n        annotationEngine = new VariantAnnotatorEngine(Arrays.asList(annotationClassesToUse), annotationsToUse, annotationsToExclude, this, getToolkit());\n        UG_engine = new UnifiedGenotyperEngine(getToolkit(), UAC, logger, verboseWriter, annotationEngine, samples);\n\n        // initialize the header\n        Set<VCFHeaderLine> headerInfo = getHeaderInfo();\n\n        // invoke initialize() method on each of the annotation classes, allowing them to add their own header lines\n        // and perform any necessary initialization/validation steps\n        annotationEngine.invokeAnnotationInitializationMethods(headerInfo);\n\n        writer.writeHeader(new VCFHeader(headerInfo, samples));\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantCallContext generateEmptyContext(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, AlignmentContext rawContext) {\n        VariantContext vc;\n        if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            VariantContext vcInput = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, ref, rawContext.getLocation(), false, logger, UAC.alleles);\n            if ( vcInput == null )\n                return null;\n            vc = new VariantContext(\"UG_call\", vcInput.getChr(), vcInput.getStart(), vcInput.getEnd(), vcInput.getAlleles(), InferredGeneticContext.NO_NEG_LOG_10PERROR, null, null, ref.getBase());\n\n        } else {\n            // deal with bad/non-standard reference bases\n            if ( !Allele.acceptableAlleleBases(new byte[]{ref.getBase()}) )\n                return null;\n\n            Set<Allele> alleles = new HashSet<Allele>();\n            alleles.add(Allele.create(ref.getBase(), true));\n            vc = new VariantContext(\"UG_call\", ref.getLocus().getContig(), ref.getLocus().getStart(), ref.getLocus().getStart(), alleles);\n        }\n        \n        if ( annotationEngine != null ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n\n            vc = annotationEngine.annotateContext(tracker, ref, stratifiedContexts, vc);\n        }\n\n        return new VariantCallContext(vc, false);\n    }","id":98375,"modified_method":"private VariantCallContext generateEmptyContext(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, AlignmentContext rawContext) {\n        VariantContext vc;\n        if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            VariantContext vcInput = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, ref, rawContext.getLocation(), false, logger, UAC.alleles);\n            if ( vcInput == null )\n                return null;\n            vc = new VariantContext(\"UG_call\", vcInput.getChr(), vcInput.getStart(), vcInput.getEnd(), vcInput.getAlleles(), InferredGeneticContext.NO_NEG_LOG_10PERROR, null, null, ref.getBase());\n\n        } else {\n            // deal with bad/non-standard reference bases\n            if ( !Allele.acceptableAlleleBases(new byte[]{ref.getBase()}) )\n                return null;\n\n            Set<Allele> alleles = new HashSet<Allele>();\n            alleles.add(Allele.create(ref.getBase(), true));\n            vc = new VariantContext(\"UG_call\", ref.getLocus().getContig(), ref.getLocus().getStart(), ref.getLocus().getStart(), alleles);\n        }\n        \n        if ( annotationEngine != null ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vc = annotationEngine.annotateContext(tracker, ref, stratifiedContexts, vc);\n        }\n\n        return new VariantCallContext(vc, false);\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            log10AlleleFrequencyPosteriors.set(new double[N+1]);\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n        }\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 )\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n\n        // 'zero' out the AFs (so that we don't have to worry if not all samples have reads at this position)\n        clearAFarray(log10AlleleFrequencyPosteriors.get());\n        afcm.get().getLog10PNonRef(vc.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n\n        // find the most likely frequency\n        int bestAFguess = MathUtils.maxElementIndex(log10AlleleFrequencyPosteriors.get());\n\n        // calculate p(f>0)\n        double[] normalizedPosteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get());\n        double sum = 0.0;\n        for (int i = 1; i <= N; i++)\n            sum += normalizedPosteriors[i];\n        double PofF = Math.min(sum, 1.0); // deal with precision errors\n\n        double phredScaledConfidence;\n        if ( bestAFguess != 0 || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(normalizedPosteriors[0]);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * log10AlleleFrequencyPosteriors.get()[0];\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PofF);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                sum = 0.0;\n                for (int i = 1; i <= N; i++) {\n                    if ( log10AlleleFrequencyPosteriors.get()[i] == AlleleFrequencyCalculationModel.VALUE_NOT_CALCULATED )\n                        break;\n                    sum += log10AlleleFrequencyPosteriors.get()[i];\n                }\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestAFguess) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), true, 1.0 - PofF);\n        }\n\n        // create the genotypes\n        Map<String, Genotype> genotypes = afcm.get().assignGenotypes(vc, log10AlleleFrequencyPosteriors.get(), bestAFguess);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null )\n            printVerboseData(refContext.getLocus().toString(), vc, PofF, phredScaledConfidence, normalizedPosteriors, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // if the site was downsampled, record that fact\n        if ( rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n\n        if ( UAC.COMPUTE_SLOD && bestAFguess != 0 ) {\n            //final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            VariantContext vcOverall = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(vcOverall.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double overallLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double overallLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            //if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(vcForward.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double forwardLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double forwardLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            //if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(vcReverse.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double reverseLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double reverseLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            //if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            //if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            attributes.put(\"SB\", strandScore);\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n\n        int endLoc = calculateEndPos(vc.getAlleles(), vc.getReference(), loc);\n\n        Set<Allele> myAlleles = new HashSet<Allele>(vc.getAlleles());\n        // strip out the alternate allele if it's a ref call\n        if ( bestAFguess == 0 && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.DISCOVERY ) {\n            myAlleles = new HashSet<Allele>(1);\n            myAlleles.add(vc.getReference());\n        }\n        VariantContext vcCall = new VariantContext(\"UG_call\", loc.getContig(), loc.getStart(), endLoc,\n                myAlleles, genotypes, phredScaledConfidence/10.0, passesCallThreshold(phredScaledConfidence) ? null : filter, attributes, refContext.getBase());\n\n        if ( annotationEngine != null ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n\n            vcCall = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall);\n        }\n\n        return new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PofF));\n    }","id":98376,"modified_method":"private VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            log10AlleleFrequencyPosteriors.set(new double[N+1]);\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n        }\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 )\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n\n        // 'zero' out the AFs (so that we don't have to worry if not all samples have reads at this position)\n        clearAFarray(log10AlleleFrequencyPosteriors.get());\n        afcm.get().getLog10PNonRef(vc.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n\n        // find the most likely frequency\n        int bestAFguess = MathUtils.maxElementIndex(log10AlleleFrequencyPosteriors.get());\n\n        // calculate p(f>0)\n        double[] normalizedPosteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get());\n        double sum = 0.0;\n        for (int i = 1; i <= N; i++)\n            sum += normalizedPosteriors[i];\n        double PofF = Math.min(sum, 1.0); // deal with precision errors\n\n        double phredScaledConfidence;\n        if ( bestAFguess != 0 || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(normalizedPosteriors[0]);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * log10AlleleFrequencyPosteriors.get()[0];\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PofF);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                sum = 0.0;\n                for (int i = 1; i <= N; i++) {\n                    if ( log10AlleleFrequencyPosteriors.get()[i] == AlleleFrequencyCalculationModel.VALUE_NOT_CALCULATED )\n                        break;\n                    sum += log10AlleleFrequencyPosteriors.get()[i];\n                }\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestAFguess) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), true, 1.0 - PofF);\n        }\n\n        // create the genotypes\n        Map<String, Genotype> genotypes = afcm.get().assignGenotypes(vc, log10AlleleFrequencyPosteriors.get(), bestAFguess);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null )\n            printVerboseData(refContext.getLocus().toString(), vc, PofF, phredScaledConfidence, normalizedPosteriors, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // if the site was downsampled, record that fact\n        if ( rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n\n        if ( UAC.COMPUTE_SLOD && bestAFguess != 0 ) {\n            //final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            VariantContext vcOverall = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(vcOverall.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double overallLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double overallLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            //if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(vcForward.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double forwardLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double forwardLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            //if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(vcReverse.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double reverseLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double reverseLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            //if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            //if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            attributes.put(\"SB\", strandScore);\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n\n        int endLoc = calculateEndPos(vc.getAlleles(), vc.getReference(), loc);\n\n        Set<Allele> myAlleles = new HashSet<Allele>(vc.getAlleles());\n        // strip out the alternate allele if it's a ref call\n        if ( bestAFguess == 0 && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.DISCOVERY ) {\n            myAlleles = new HashSet<Allele>(1);\n            myAlleles.add(vc.getReference());\n        }\n        VariantContext vcCall = new VariantContext(\"UG_call\", loc.getContig(), loc.getStart(), endLoc,\n                myAlleles, genotypes, phredScaledConfidence/10.0, passesCallThreshold(phredScaledConfidence) ? null : filter, attributes, refContext.getBase());\n\n        if ( annotationEngine != null ) {\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vcCall = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall);\n        }\n\n        return new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PofF));\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires({\"toolkit != null\", \"UAC != null\"})\n    public UnifiedGenotyperEngine(GenomeAnalysisEngine toolkit, UnifiedArgumentCollection UAC) {\n        this(toolkit, UAC, Logger.getLogger(UnifiedGenotyperEngine.class), null, null,\n                // get the number of samples\n                // if we're supposed to assume a single sample, do so\n                UAC.ASSUME_SINGLE_SAMPLE != null ?\n                        new TreeSet<String>(Arrays.asList(UAC.ASSUME_SINGLE_SAMPLE)) :\n                        SampleUtils.getSAMFileSamples(toolkit.getSAMFileHeader()));\n    }","id":98377,"modified_method":"@Requires({\"toolkit != null\", \"UAC != null\"})\n    public UnifiedGenotyperEngine(GenomeAnalysisEngine toolkit, UnifiedArgumentCollection UAC) {\n        this(toolkit, UAC, Logger.getLogger(UnifiedGenotyperEngine.class), null, null, SampleUtils.getSAMFileSamples(toolkit.getSAMFileHeader()));\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<String, AlignmentContext> getFilteredAndStratifiedContexts(UnifiedArgumentCollection UAC, ReferenceContext refContext, AlignmentContext rawContext, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        Map<String, AlignmentContext> stratifiedContexts = null;\n\n        if ( !BaseUtils.isRegularBase( refContext.getBase() ) )\n            return null;\n\n        if ( model == GenotypeLikelihoodsCalculationModel.Model.INDEL ) {\n\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                // regular pileup in this case\n                ReadBackedPileup pileup = rawContext.getBasePileup() .getMappingFilteredPileup(UAC.MIN_BASE_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.getNumberOfElements() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n\n            } else {\n\n                // todo - tmp will get rid of extended events so this wont be needed\n                if (!rawContext.hasExtendedEventPileup())\n                    return null;\n                ReadBackedExtendedEventPileup rawPileup = rawContext.getExtendedEventPileup();\n\n                // filter the context based on min mapping quality\n                ReadBackedExtendedEventPileup pileup = rawPileup.getMappingFilteredPileup(UAC.MIN_BASE_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.getNumberOfElements() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n            }\n        } else if ( model == GenotypeLikelihoodsCalculationModel.Model.SNP ) {\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(rawContext.getBasePileup(), UAC.ASSUME_SINGLE_SAMPLE);\n\n            if( !(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) ) {\n                int numDeletions = 0;\n                for( final PileupElement p : rawContext.getBasePileup() ) {\n                    if( p.isDeletion() ) { numDeletions++; }\n                }\n                if( ((double) numDeletions) / ((double) rawContext.getBasePileup().getNumberOfElements()) > UAC.MAX_DELETION_FRACTION ) {\n                    return null;\n                }\n            }\n        }\n\n        return stratifiedContexts;\n    }","id":98378,"modified_method":"private Map<String, AlignmentContext> getFilteredAndStratifiedContexts(UnifiedArgumentCollection UAC, ReferenceContext refContext, AlignmentContext rawContext, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        Map<String, AlignmentContext> stratifiedContexts = null;\n\n        if ( !BaseUtils.isRegularBase( refContext.getBase() ) )\n            return null;\n\n        if ( model == GenotypeLikelihoodsCalculationModel.Model.INDEL ) {\n\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                // regular pileup in this case\n                ReadBackedPileup pileup = rawContext.getBasePileup() .getMappingFilteredPileup(UAC.MIN_BASE_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.getNumberOfElements() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            } else {\n\n                // todo - tmp will get rid of extended events so this wont be needed\n                if (!rawContext.hasExtendedEventPileup())\n                    return null;\n                ReadBackedExtendedEventPileup rawPileup = rawContext.getExtendedEventPileup();\n\n                // filter the context based on min mapping quality\n                ReadBackedExtendedEventPileup pileup = rawPileup.getMappingFilteredPileup(UAC.MIN_BASE_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.getNumberOfElements() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n            }\n        } else if ( model == GenotypeLikelihoodsCalculationModel.Model.SNP ) {\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(rawContext.getBasePileup());\n\n            if( !(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) ) {\n                int numDeletions = 0;\n                for( final PileupElement p : rawContext.getBasePileup() ) {\n                    if( p.isDeletion() ) { numDeletions++; }\n                }\n                if( ((double) numDeletions) / ((double) rawContext.getBasePileup().getNumberOfElements()) > UAC.MAX_DELETION_FRACTION ) {\n                    return null;\n                }\n            }\n        }\n\n        return stratifiedContexts;\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For each site of interest, annotate based on the requested annotation types\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      the reference base\n     * @param context  the context for the given locus\n     * @return 1 if the locus was successfully processed, 0 if otherwise\n     */\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null )\n            return 0;\n\n        Collection<VariantContext> VCs = tracker.getValues(variantCollection.variants, context.getLocation());\n        if ( VCs.size() == 0 )\n            return 0;\n\n        Collection<VariantContext> annotatedVCs = VCs;\n\n        // if the reference base is not ambiguous, we can annotate\n        Map<String, AlignmentContext> stratifiedContexts;\n        if ( BaseUtils.simpleBaseToBaseIndex(ref.getBase()) != -1 ) {\n            if ( ! context.hasExtendedEventPileup() ) {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getBasePileup(), ASSUME_SINGLE_SAMPLE);\n            } else {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getExtendedEventPileup(), ASSUME_SINGLE_SAMPLE);\n            }\n            if ( stratifiedContexts != null ) {\n                annotatedVCs = new ArrayList<VariantContext>(VCs.size());\n                for ( VariantContext vc : VCs )\n                    annotatedVCs.add(engine.annotateContext(tracker, ref, stratifiedContexts, vc));\n            }\n        }\n\n        if ( ! indelsOnly ) {\n            for ( VariantContext annotatedVC : annotatedVCs )\n                vcfWriter.add(annotatedVC);\n        } else {\n            // check to see if the buffered context is different (in location) this context\n            if ( indelBufferContext != null && ! VariantContextUtils.getLocation(getToolkit().getGenomeLocParser(),indelBufferContext.iterator().next()).equals(VariantContextUtils.getLocation(getToolkit().getGenomeLocParser(),annotatedVCs.iterator().next())) ) {\n                for ( VariantContext annotatedVC : indelBufferContext )\n                    vcfWriter.add(annotatedVC);\n                indelBufferContext = annotatedVCs;\n            } else {\n                indelBufferContext = annotatedVCs;\n            }\n        }\n\n        return 1;\n    }","id":98379,"modified_method":"/**\n     * For each site of interest, annotate based on the requested annotation types\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      the reference base\n     * @param context  the context for the given locus\n     * @return 1 if the locus was successfully processed, 0 if otherwise\n     */\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null )\n            return 0;\n\n        Collection<VariantContext> VCs = tracker.getValues(variantCollection.variants, context.getLocation());\n        if ( VCs.size() == 0 )\n            return 0;\n\n        Collection<VariantContext> annotatedVCs = VCs;\n\n        // if the reference base is not ambiguous, we can annotate\n        Map<String, AlignmentContext> stratifiedContexts;\n        if ( BaseUtils.simpleBaseToBaseIndex(ref.getBase()) != -1 ) {\n            if ( ! context.hasExtendedEventPileup() ) {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getBasePileup());\n            } else {\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(context.getExtendedEventPileup());\n            }\n            if ( stratifiedContexts != null ) {\n                annotatedVCs = new ArrayList<VariantContext>(VCs.size());\n                for ( VariantContext vc : VCs )\n                    annotatedVCs.add(engine.annotateContext(tracker, ref, stratifiedContexts, vc));\n            }\n        }\n\n        if ( ! indelsOnly ) {\n            for ( VariantContext annotatedVC : annotatedVCs )\n                vcfWriter.add(annotatedVC);\n        } else {\n            // check to see if the buffered context is different (in location) this context\n            if ( indelBufferContext != null && ! VariantContextUtils.getLocation(getToolkit().getGenomeLocParser(),indelBufferContext.iterator().next()).equals(VariantContextUtils.getLocation(getToolkit().getGenomeLocParser(),annotatedVCs.iterator().next())) ) {\n                for ( VariantContext annotatedVC : indelBufferContext )\n                    vcfWriter.add(annotatedVC);\n                indelBufferContext = annotatedVCs;\n            } else {\n                indelBufferContext = annotatedVCs;\n            }\n        }\n\n        return 1;\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Prepare the output file and the list of available features.\n     */\n    public void initialize() {\n\n        if ( LIST )\n            listAnnotationsAndExit();\n\n        // get the list of all sample names from the variant VCF input rod, if applicable\n        List<String> rodName = Arrays.asList(variantCollection.variants.getName());\n        Set<String> samples = SampleUtils.getUniqueSamplesFromRods(getToolkit(), rodName);\n\n        // if there are no valid samples, warn the user\n        if ( samples.size() == 0 ) {\n            logger.warn(\"There are no samples input at all; use the --sampleName argument to specify one if desired.\");\n        }\n\n        if ( USE_ALL_ANNOTATIONS )\n            engine = new VariantAnnotatorEngine(annotationsToExclude, this, getToolkit());\n        else\n            engine = new VariantAnnotatorEngine(annotationGroupsToUse, annotationsToUse, annotationsToExclude, this, getToolkit());\n        engine.initializeExpressions(expressionsToUse);\n\n        // setup the header fields\n        // note that if any of the definitions conflict with our new ones, then we want to overwrite the old ones\n        Set<VCFHeaderLine> hInfo = new HashSet<VCFHeaderLine>();\n        hInfo.addAll(engine.getVCFAnnotationDescriptions());\n        for ( VCFHeaderLine line : VCFUtils.getHeaderFields(getToolkit(), Arrays.asList(variantCollection.variants.getName())) ) {\n            if ( isUniqueHeaderLine(line, hInfo) )\n                hInfo.add(line);\n        }\n        for ( String expression : expressionsToUse )\n            hInfo.add(new VCFInfoHeaderLine(expression, VCFHeaderLineCount.UNBOUNDED, VCFHeaderLineType.String, \"Value transferred from another external VCF resource\"));\n\n        engine.invokeAnnotationInitializationMethods(hInfo);\n\n        VCFHeader vcfHeader = new VCFHeader(hInfo, samples);\n        vcfWriter.writeHeader(vcfHeader);\n\n        if ( indelsOnly ) {\n            indelBufferContext = null;\n        }\n    }","id":98380,"modified_method":"/**\n     * Prepare the output file and the list of available features.\n     */\n    public void initialize() {\n\n        if ( LIST )\n            listAnnotationsAndExit();\n\n        // get the list of all sample names from the variant VCF input rod, if applicable\n        List<String> rodName = Arrays.asList(variantCollection.variants.getName());\n        Set<String> samples = SampleUtils.getUniqueSamplesFromRods(getToolkit(), rodName);\n\n        if ( USE_ALL_ANNOTATIONS )\n            engine = new VariantAnnotatorEngine(annotationsToExclude, this, getToolkit());\n        else\n            engine = new VariantAnnotatorEngine(annotationGroupsToUse, annotationsToUse, annotationsToExclude, this, getToolkit());\n        engine.initializeExpressions(expressionsToUse);\n\n        // setup the header fields\n        // note that if any of the definitions conflict with our new ones, then we want to overwrite the old ones\n        Set<VCFHeaderLine> hInfo = new HashSet<VCFHeaderLine>();\n        hInfo.addAll(engine.getVCFAnnotationDescriptions());\n        for ( VCFHeaderLine line : VCFUtils.getHeaderFields(getToolkit(), Arrays.asList(variantCollection.variants.getName())) ) {\n            if ( isUniqueHeaderLine(line, hInfo) )\n                hInfo.add(line);\n        }\n        for ( String expression : expressionsToUse )\n            hInfo.add(new VCFInfoHeaderLine(expression, VCFHeaderLineCount.UNBOUNDED, VCFHeaderLineType.String, \"Value transferred from another external VCF resource\"));\n\n        engine.invokeAnnotationInitializationMethods(hInfo);\n\n        VCFHeader vcfHeader = new VCFHeader(hInfo, samples);\n        vcfWriter.writeHeader(vcfHeader);\n\n        if ( indelsOnly ) {\n            indelBufferContext = null;\n        }\n    }","commit_id":"a12bc63e5c2b99e52baa9eebe85667a4d1abec3d","url":"https://github.com/broadgsa/gatk"},{"original_method":"private final void cleanLast0() throws IOException {\n\n        // check if index is inside of cache\n        if (this.buffercount > 0) {\n            // shrink buffer\n            this.buffercount--;\n            return;\n        }\n        // shrink file\n        this.raf.setLength(this.raf.length() - this.recordsize);\n    }","id":98381,"modified_method":"private final void cleanLast0() throws IOException {\n\n        // check if index is inside of cache\n        if (this.buffercount > 0) {\n            // shrink buffer\n            this.buffercount--;\n            return;\n        }\n        // shrink file\n        if (this.raf.length() > 0) // already 0 length, nothing to shrink (prevent seek io error)\n            this.raf.setLength(this.raf.length() - this.recordsize);\n    }","commit_id":"2b8cc5832c897e03b21d2debd4061e6aa7985f0a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * this is like\n     * <code>clean(this.size() - 1, b, start);<\/code>\n     *\n     * @see clean(long, byte[], int)\n     * @param b\n     * @param start\n     * @throws IOException\n     */\n    private final void cleanLast0(final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        // check if index is inside of buffer\n        if (this.buffercount > 0) {\n            // read entry from the buffer\n            System.arraycopy(this.buffer, (this.buffercount - 1) * this.recordsize, b, start, this.recordsize);\n            // shrink buffer\n            this.buffercount--;\n            return;\n        }\n        // read entry from the file\n        final long endpos = this.raf.length() - this.recordsize;\n        this.raf.seek(endpos);\n        this.raf.readFully(b, start, this.recordsize);\n\n        // write zero bytes to the cache and to the file\n        this.raf.seek(endpos);\n        this.raf.write(this.zero, 0, this.recordsize);\n\n        // shrink file\n        this.raf.setLength(endpos);\n    }","id":98382,"modified_method":"/**\n     * this is like\n     * <code>clean(this.size() - 1, b, start);<\/code>\n     *\n     * @see clean(long, byte[], int)\n     * @param b\n     * @param start\n     * @throws IOException\n     */\n    private final void cleanLast0(final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        // check if index is inside of buffer\n        if (this.buffercount > 0) {\n            // read entry from the buffer\n            System.arraycopy(this.buffer, (this.buffercount - 1) * this.recordsize, b, start, this.recordsize);\n            // shrink buffer\n            this.buffercount--;\n            return;\n        }\n        // read entry from the file\n        long endpos = this.raf.length() - this.recordsize;\n        if (endpos >= 0) { // prevent seek error for 0 size file\n            this.raf.seek(endpos);\n            this.raf.readFully(b, start, this.recordsize);\n        } else {\n            endpos = 0;\n            System.arraycopy(this.zero, 0, b, start, this.recordsize);\n        }\n        // write zero bytes to the cache and to the file\n        this.raf.seek(endpos);\n        this.raf.write(this.zero, 0, this.recordsize);\n\n        // shrink file\n        this.raf.setLength(endpos);\n    }","commit_id":"2b8cc5832c897e03b21d2debd4061e6aa7985f0a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n        byte[] address = ip_addr.getAddress();   \n        out.write(address);   \n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else\n            out.writeInt(0);\n    }","id":98383,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n        if(ip_addr != null) {\n            byte[] address=ip_addr.getAddress();\n            out.writeByte(address.length); // 1 byte\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeByte(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeBoolean(true);\n            out.writeShort(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else\n            out.writeBoolean(false);\n    }","commit_id":"ee2989a7bd7eb0e869089415a2a8a90e2811a7a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len=in.readShort();\n        if(len > 0) {\n            //read the four bytes\n            byte[] a = new byte[len];\n            //in theory readFully(byte[]) should be faster\n            //than read(byte[]) since latter reads\n            // 4 bytes one at a time\n            in.readFully(a);\n            //look up an instance in the cache\n            this.ip_addr=InetAddress.getByAddress(a);\n        }\n        //then read the port\n        port=in.readInt();\n\n        if(in.readBoolean() == false)\n            return;\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","id":98384,"modified_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len=in.readByte();\n        if(len > 0) {\n            byte[] a = new byte[len]; // 4 bytes (IPv4) or 16 bytes (IPv6)\n            in.readFully(a);\n            this.ip_addr=InetAddress.getByAddress(a);\n        }\n        port=in.readInt();\n\n        if(in.readBoolean() == false)\n            return;\n        len=in.readShort();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","commit_id":"ee2989a7bd7eb0e869089415a2a8a90e2811a7a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n        byte[] address;\n\n        if(ip_addr != null) {\n            address=ip_addr.getAddress();\n            out.writeShort(address.length); // 2 bytes\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeShort(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeBoolean(true); // 1 byte\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.writeBoolean(false);\n        }\n    }","id":98385,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n        if(ip_addr != null) {\n            byte[] address=ip_addr.getAddress();  // 4 bytes (IPv4) or 16 bytes (IPv6)\n            out.writeByte(address.length); // 1 byte\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeByte(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeBoolean(true); // 1 byte\n            out.writeShort(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.writeBoolean(false);\n        }\n    }","commit_id":"ee2989a7bd7eb0e869089415a2a8a90e2811a7a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n        if(size >= 0)\n            return size;\n        // length + 4 bytes for port + 1 for additional_data available\n        int tmp_size=Global.SHORT_SIZE + Global.INT_SIZE + Global.BYTE_SIZE;\n        if(ip_addr != null)\n            tmp_size+=ip_addr.getAddress().length; // 4 bytes for IPv4\n        if(additional_data != null)\n            tmp_size+=additional_data.length+Global.INT_SIZE;\n        size=tmp_size;\n        return tmp_size;\n    }","id":98386,"modified_method":"public int size() {\n        if(size >= 0)\n            return size;\n        // length (1 bytes) + 4 bytes for port + 1 for additional_data available\n        int tmp_size=Global.BYTE_SIZE+ Global.INT_SIZE + Global.BYTE_SIZE;\n        if(ip_addr != null)\n            tmp_size+=ip_addr.getAddress().length; // 4 bytes for IPv4\n        if(additional_data != null)\n            tmp_size+=additional_data.length+Global.SHORT_SIZE;\n        size=tmp_size;\n        return tmp_size;\n    }","commit_id":"ee2989a7bd7eb0e869089415a2a8a90e2811a7a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        int len=0;   \n        //read the four bytes\n        byte[] a = new byte[4];   \n        //in theory readFully(byte[]) should be faster   \n        //than read(byte[]) since latter reads   \n        // 4 bytes one at a time   \n        in.readFully(a);   \n        //then read the port\n        port = in.readInt();\n        //look up an instance in the cache\n        this.ip_addr=InetAddress.getByAddress(a);\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);        \n        }\n    }","id":98387,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        int len=in.readByte();\n        if(len > 0) {\n            //read the four bytes\n            byte[] a = new byte[len];\n            //in theory readFully(byte[]) should be faster\n            //than read(byte[]) since latter reads\n            // 4 bytes one at a time\n            in.readFully(a);\n            //look up an instance in the cache\n            this.ip_addr=InetAddress.getByAddress(a);\n        }\n        //then read the port\n        port=in.readInt();\n\n        if(in.readBoolean() == false)\n            return;\n        len=in.readShort();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","commit_id":"ee2989a7bd7eb0e869089415a2a8a90e2811a7a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n        if(size >= 0)\n            return size;\n        // length + 4 bytes for port + 1 for additional_data available\n        int tmp_size=Global.SHORT_SIZE + Global.INT_SIZE + Global.BYTE_SIZE;\n        if(ip_addr != null)\n            tmp_size+=ip_addr.getAddress().length; // 4 bytes for IPv4\n        if(additional_data != null)\n            tmp_size+=additional_data.length+Global.INT_SIZE;\n        size=tmp_size;\n        return tmp_size;\n    }","id":98388,"modified_method":"public int size() {\n        if(size >= 0)\n            return size;\n        // length (1 bytes) + 4 bytes for port + 1 for additional_data available\n        int tmp_size=Global.BYTE_SIZE+ Global.INT_SIZE + Global.BYTE_SIZE;\n        if(ip_addr != null)\n            tmp_size+=ip_addr.getAddress().length; // 4 bytes for IPv4\n        if(additional_data != null)\n            tmp_size+=additional_data.length+Global.SHORT_SIZE;\n        size=tmp_size;\n        return tmp_size;\n    }","commit_id":"ffdc66721d0785a2ae0e25aa2266f26312f34a6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n        byte[] address;\n\n        if(ip_addr != null) {\n            address=ip_addr.getAddress();\n            out.writeShort(address.length); // 2 bytes\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeShort(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeBoolean(true); // 1 byte\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.writeBoolean(false);\n        }\n    }","id":98389,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n        if(ip_addr != null) {\n            byte[] address=ip_addr.getAddress();  // 4 bytes (IPv4) or 16 bytes (IPv6)\n            out.writeByte(address.length); // 1 byte\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeByte(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeBoolean(true); // 1 byte\n            out.writeShort(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.writeBoolean(false);\n        }\n    }","commit_id":"ffdc66721d0785a2ae0e25aa2266f26312f34a6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len=in.readShort();\n        if(len > 0) {\n            //read the four bytes\n            byte[] a = new byte[len];\n            //in theory readFully(byte[]) should be faster\n            //than read(byte[]) since latter reads\n            // 4 bytes one at a time\n            in.readFully(a);\n            //look up an instance in the cache\n            this.ip_addr=InetAddress.getByAddress(a);\n        }\n        //then read the port\n        port=in.readInt();\n\n        if(in.readBoolean() == false)\n            return;\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","id":98390,"modified_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len=in.readByte();\n        if(len > 0) {\n            byte[] a = new byte[len]; // 4 bytes (IPv4) or 16 bytes (IPv6)\n            in.readFully(a);\n            this.ip_addr=InetAddress.getByAddress(a);\n        }\n        port=in.readInt();\n\n        if(in.readBoolean() == false)\n            return;\n        len=in.readShort();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","commit_id":"ffdc66721d0785a2ae0e25aa2266f26312f34a6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n        byte[] address = ip_addr.getAddress();   \n        out.write(address);   \n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else\n            out.writeInt(0);\n    }","id":98391,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n        if(ip_addr != null) {\n            byte[] address=ip_addr.getAddress();\n            out.writeByte(address.length); // 1 byte\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeByte(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.writeBoolean(true);\n            out.writeShort(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else\n            out.writeBoolean(false);\n    }","commit_id":"ffdc66721d0785a2ae0e25aa2266f26312f34a6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        int len=0;   \n        //read the four bytes\n        byte[] a = new byte[4];   \n        //in theory readFully(byte[]) should be faster   \n        //than read(byte[]) since latter reads   \n        // 4 bytes one at a time   \n        in.readFully(a);   \n        //then read the port\n        port = in.readInt();\n        //look up an instance in the cache\n        this.ip_addr=InetAddress.getByAddress(a);\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);        \n        }\n    }","id":98392,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        int len=in.readByte();\n        if(len > 0) {\n            //read the four bytes\n            byte[] a = new byte[len];\n            //in theory readFully(byte[]) should be faster\n            //than read(byte[]) since latter reads\n            // 4 bytes one at a time\n            in.readFully(a);\n            //look up an instance in the cache\n            this.ip_addr=InetAddress.getByAddress(a);\n        }\n        //then read the port\n        port=in.readInt();\n\n        if(in.readBoolean() == false)\n            return;\n        len=in.readShort();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","commit_id":"ffdc66721d0785a2ae0e25aa2266f26312f34a6c","url":"https://github.com/belaban/JGroups"},{"original_method":"private Package getPollingPackageForMonitor(OnmsLocationMonitor mon) {\n        OnmsMonitoringLocationDefinition def = m_locMonDao.findMonitoringLocationDefinition(mon.getDefinitionName());\n        String pollingPackageName = def.getPollingPackageName();\n        \n        return m_pollerConfig.getPackage(pollingPackageName);\n    }","id":98393,"modified_method":"private Package getPollingPackageForMonitor(OnmsLocationMonitor mon) {\n        OnmsMonitoringLocationDefinition def = m_locMonDao.findMonitoringLocationDefinition(mon.getDefinitionName());\n        String pollingPackageName = def.getPollingPackageName();\n        \n        Package pkg = m_pollerConfig.getPackage(pollingPackageName);\n        if (pkg == null) {\n            throw new IllegalStateException(\"Package \"+pollingPackageName+\" does not exist as defined for monitoring location \"+mon.getDefinitionName());\n        }\n        return pkg;\n    }","commit_id":"643c985141c53a832b545ff9f4ab2d2ea4d02de1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Package getPollingPackageForMonitor(OnmsLocationMonitor mon) {\n        OnmsMonitoringLocationDefinition def = m_locMonDao.findMonitoringLocationDefinition(mon.getDefinitionName());\n        String pollingPackageName = def.getPollingPackageName();\n        \n        return m_pollerConfig.getPackage(pollingPackageName);\n    }","id":98394,"modified_method":"private Package getPollingPackageForMonitor(OnmsLocationMonitor mon) {\n        OnmsMonitoringLocationDefinition def = m_locMonDao.findMonitoringLocationDefinition(mon.getDefinitionName());\n        String pollingPackageName = def.getPollingPackageName();\n        \n        Package pkg = m_pollerConfig.getPackage(pollingPackageName);\n        if (pkg == null) {\n            throw new IllegalStateException(\"Package \"+pollingPackageName+\" does not exist as defined for monitoring location \"+mon.getDefinitionName());\n        }\n        return pkg;\n    }","commit_id":"33cccb6f1e2bf9dbc22c3d96ceab777966e451d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  protected boolean checkPackageExists(PsiDirectory directory) {\n    return JavaDirectoryService.getInstance().getPackage(directory) != null;\n  }","id":98395,"modified_method":"@Override\n  protected boolean checkPackageExists(PsiDirectory directory) {\n    PsiPackage pkg = JavaDirectoryService.getInstance().getPackage(directory);\n    return pkg != null && JavaPsiFacade.getInstance(directory.getProject()).getNameHelper().isQualifiedName(pkg.getQualifiedName());\n  }","commit_id":"c8916739b171c6dcd4d9a6df58d470079ae6ba26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<HypericAlertStatus> fetchHypericAlerts(String hypericUrl, List<String> alertIds) throws HttpException, IOException, JAXBException, XMLStreamException {\n        StringBuffer alertIdString = new StringBuffer();\n        for (int i = 0; i < alertIds.size(); i++) {\n            if (i > 0) alertIdString.append(\" \");\n            alertIdString.append(alertIds.get(i));\n        }\n\n        HttpClient httpClient = new HttpClient();\n        HostConfiguration hostConfig = new HostConfiguration();\n\n        // TODO Change to a POST method if possible\n        GetMethod httpMethod = new GetMethod(hypericUrl);\n        // httpMethod.addParameter(\"alertIds\", alertIdString.toString());\n\n        httpClient.getParams().setParameter(HttpClientParams.SO_TIMEOUT, 3000);\n        httpClient.getParams().setParameter(HttpClientParams.USER_AGENT, \"OpenNMS Ackd.HypericAckProcessor\");\n        // Change these parameters to be configurable\n        // hostConfig.setHost(HYPERIC_IP_ADDRESS, HYPERIC_PORT);\n        // hostConfig.getParams().setParameter(HttpClientParams.VIRTUAL_HOST, \"localhost\");\n        // if(ParameterMap.getKeyedBoolean(map, \"http-1.0\", false))\n        // httpClient.getParams().setParameter(HttpClientParams.PROTOCOL_VERSION,HttpVersion.HTTP_1_0);\n\n        if (HYPERIC_USER != null && !\"\".equals(HYPERIC_USER) && HYPERIC_PASSWORD != null && !\"\".equals(HYPERIC_PASSWORD)) {\n            httpClient.getParams().setAuthenticationPreemptive(true);\n            httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(HYPERIC_USER, HYPERIC_PASSWORD));\n        }\n\n        List<HypericAlertStatus> retval = new ArrayList<HypericAlertStatus>();\n        try {\n            log().debug(\"httpClient request with the following parameters: \" + httpClient);\n            log().debug(\"hostConfig parameters: \" + hostConfig);\n            log().debug(\"getMethod parameters: \" + httpMethod);\n            httpClient.executeMethod(hostConfig, httpMethod);\n\n            //Integer statusCode = httpMethod.getStatusCode();\n            //String statusText = httpMethod.getStatusText();\n            InputStream responseText = httpMethod.getResponseBodyAsStream();\n\n            retval = parseHypericAlerts(new InputStreamReader(responseText));\n        } finally{\n            httpMethod.releaseConnection();\n        }\n        return retval;\n    }","id":98396,"modified_method":"public static List<HypericAlertStatus> fetchHypericAlerts(String hypericUrl, List<String> alertIds) throws HttpException, IOException, JAXBException, XMLStreamException {\n        StringBuffer alertIdString = new StringBuffer();\n        for (int i = 0; i < alertIds.size(); i++) {\n            if (i > 0) alertIdString.append(\" \");\n            alertIdString.append(alertIds.get(i));\n        }\n\n        HttpClient httpClient = new HttpClient();\n        HostConfiguration hostConfig = new HostConfiguration();\n        \n        URI uri = new URI(hypericUrl, true);\n\n        // TODO Add alertIds parameter\n        // TODO Change to a POST method if possible\n        GetMethod httpMethod = new GetMethod(uri.getURI());\n        // httpMethod.addParameter(\"alertIds\", alertIdString.toString());\n\n        httpClient.getParams().setParameter(HttpClientParams.SO_TIMEOUT, 3000);\n        httpClient.getParams().setParameter(HttpClientParams.USER_AGENT, \"OpenNMS Ackd.HypericAckProcessor\");\n        // hostConfig.getParams().setParameter(HttpClientParams.VIRTUAL_HOST, \"localhost\");\n\n        String userinfo = uri.getUserinfo();\n        if (userinfo != null && !\"\".equals(userinfo)) {\n            httpClient.getParams().setAuthenticationPreemptive(true);\n            int colonIndex = userinfo.indexOf(\":\");\n            if (colonIndex < 0) {\n                // If there is no colon separator, use the entire string as a username\n                httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(userinfo));\n            } else if (colonIndex == 0) {\n                throw new IllegalArgumentException(\"Illegal Hyperic HTTP credentials starting with a colon in the ackd configuration: \" + userinfo);\n            } else {\n                // If there is a colon separator, parse out the username and password\n                String username = userinfo.substring(0, colonIndex);\n                if (colonIndex < (userinfo.length() - 1)) {\n                    // Note that this can return an empty string \"\"\n                    String password = userinfo.substring(colonIndex + 1);\n                    httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password));\n                } else {\n                    httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username));\n                }\n            }\n        }\n\n        List<HypericAlertStatus> retval = new ArrayList<HypericAlertStatus>();\n        try {\n            log().debug(\"httpClient request with the following parameters: \" + httpClient);\n            log().debug(\"hostConfig parameters: \" + hostConfig);\n            log().debug(\"getMethod parameters: \" + httpMethod);\n            httpClient.executeMethod(hostConfig, httpMethod);\n\n            //Integer statusCode = httpMethod.getStatusCode();\n            //String statusText = httpMethod.getStatusText();\n            InputStream responseText = httpMethod.getResponseBodyAsStream();\n\n            retval = parseHypericAlerts(new InputStreamReader(responseText));\n        } finally{\n            httpMethod.releaseConnection();\n        }\n        return retval;\n    }","commit_id":"f7d805c27d51c8a682b889b6bd68ae8ed578ad1c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private AckdConfigurationDao createAckdConfigDao() {\n\n        class AckdConfigDao extends DefaultAckdConfigurationDao {\n\n            public AckdConfiguration getConfig() {\n                AckdConfiguration config = new AckdConfiguration();\n                config.setAckExpression(\"~(?i)^AcK$\");\n                config.setAlarmidMatchExpression(\"~(?i).*alarmid:([0-9]+).*\");\n                config.setAlarmSync(true);\n                config.setClearExpression(\"~(?i)^(Resolve|cleaR)$\");\n                config.setEscalateExpression(\"~(?i)^esc$\");\n                config.setNotifyidMatchExpression(\"~(?i).*RE:.*Notice #([0-9]+).*\");\n                config.setUnackExpression(\"~(?i)^unAck$\");\n\n                Readers readers = new Readers();\n                {\n                    Reader reader = new Reader();\n                    reader.setEnabled(false);\n                    reader.setReaderName(\"JavaMailReader\");\n\n                    Parameter hypericHosts = new Parameter();\n                    hypericHosts.setKey(\"readmail-config\");\n                    hypericHosts.setValue(\"localhost\");\n                    reader.addParameter(hypericHosts);\n\n                    org.opennms.netmgt.config.ackd.ReaderSchedule hypericSchedule = new org.opennms.netmgt.config.ackd.ReaderSchedule();\n                    hypericSchedule.setInterval(60);\n                    hypericSchedule.setUnit(\"s\");\n\n                    readers.addReader(reader);\n                }\n\n                {\n                    Reader reader = new Reader();\n                    reader.setEnabled(true);\n                    reader.setReaderName(HypericAckProcessor.READER_NAME_HYPERIC);\n\n                    Parameter hypericHosts = new Parameter();\n                    hypericHosts.setKey(HypericAckProcessor.PARAMETER_HYPERIC_HOSTS);\n                    hypericHosts.setValue(\"10001 http://127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\");\n                    reader.addParameter(hypericHosts);\n\n                    org.opennms.netmgt.config.ackd.ReaderSchedule hypericSchedule = new org.opennms.netmgt.config.ackd.ReaderSchedule();\n                    hypericSchedule.setInterval(8);\n                    hypericSchedule.setUnit(\"s\");\n                    reader.setReaderSchedule(hypericSchedule);\n\n                    readers.addReader(reader);\n                }\n\n                config.setReaders(readers);\n                return config;\n            }\n\n        }\n\n        return new AckdConfigDao();\n    }","id":98397,"modified_method":"private AckdConfigurationDao createAckdConfigDao() {\n\n        class AckdConfigDao extends DefaultAckdConfigurationDao {\n\n            public AckdConfiguration getConfig() {\n                AckdConfiguration config = new AckdConfiguration();\n                config.setAckExpression(\"~(?i)^AcK$\");\n                config.setAlarmidMatchExpression(\"~(?i).*alarmid:([0-9]+).*\");\n                config.setAlarmSync(true);\n                config.setClearExpression(\"~(?i)^(Resolve|cleaR)$\");\n                config.setEscalateExpression(\"~(?i)^esc$\");\n                config.setNotifyidMatchExpression(\"~(?i).*RE:.*Notice #([0-9]+).*\");\n                config.setUnackExpression(\"~(?i)^unAck$\");\n\n                Readers readers = new Readers();\n                {\n                    Reader reader = new Reader();\n                    reader.setEnabled(false);\n                    reader.setReaderName(\"JavaMailReader\");\n\n                    Parameter hypericHosts = new Parameter();\n                    hypericHosts.setKey(\"readmail-config\");\n                    hypericHosts.setValue(\"localhost\");\n                    reader.addParameter(hypericHosts);\n\n                    org.opennms.netmgt.config.ackd.ReaderSchedule hypericSchedule = new org.opennms.netmgt.config.ackd.ReaderSchedule();\n                    hypericSchedule.setInterval(60);\n                    hypericSchedule.setUnit(\"s\");\n\n                    readers.addReader(reader);\n                }\n\n                {\n                    Reader reader = new Reader();\n                    reader.setEnabled(true);\n                    reader.setReaderName(HypericAckProcessor.READER_NAME_HYPERIC);\n\n                    Parameter hypericHosts = new Parameter();\n                    hypericHosts.setKey(HypericAckProcessor.PARAMETER_HYPERIC_HOSTS);\n                    hypericHosts.setValue(\"10001 http://hqadmin:hqadmin@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\");\n                    reader.addParameter(hypericHosts);\n\n                    org.opennms.netmgt.config.ackd.ReaderSchedule hypericSchedule = new org.opennms.netmgt.config.ackd.ReaderSchedule();\n                    hypericSchedule.setInterval(8);\n                    hypericSchedule.setUnit(\"s\");\n                    reader.setReaderSchedule(hypericSchedule);\n\n                    readers.addReader(reader);\n                }\n\n                config.setReaders(readers);\n                return config;\n            }\n\n        }\n\n        return new AckdConfigDao();\n    }","commit_id":"f7d805c27d51c8a682b889b6bd68ae8ed578ad1c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitHttpServer(port=7081)\n    public void testFetchHypericAlerts() throws Exception {\n        // Test reading alerts over the HTTP server        \n        List<HypericAckProcessor.HypericAlertStatus> alerts = HypericAckProcessor.fetchHypericAlerts(\"http://127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\", Arrays.asList(new String[] { \"1\", \"2\", \"3\" }));\n        assertEquals(5, alerts.size());\n        for (HypericAckProcessor.HypericAlertStatus alert : alerts) {\n            System.out.println(alert.toString());\n        }\n    }","id":98398,"modified_method":"@Test\n    @JUnitHttpServer(port=7081,basicAuth=true)\n    public void testFetchHypericAlerts() throws Exception {\n        // Test reading alerts over the HTTP server\n        {\n            List<HypericAckProcessor.HypericAlertStatus> alerts = HypericAckProcessor.fetchHypericAlerts(\"http://hqadmin:hqadmin@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\", Arrays.asList(new String[] { \"1\", \"2\", \"3\" }));\n            assertEquals(5, alerts.size());\n            for (HypericAckProcessor.HypericAlertStatus alert : alerts) {\n                System.out.println(alert.toString());\n            }\n\n            alerts = HypericAckProcessor.fetchHypericAlerts(\"http://uhohcolons:this%3Apassword%3Ahas%3Acolons@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\", Arrays.asList(new String[] { \"1\", \"2\", \"3\" }));\n            assertEquals(5, alerts.size());\n        }\n\n        // Try with bad credentials to make sure we get a malformed response\n        {\n            boolean caughtAuthFailure = false;\n            try {\n                List<HypericAckProcessor.HypericAlertStatus> alerts = HypericAckProcessor.fetchHypericAlerts(\"http://:badcredentials@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\", Arrays.asList(new String[] { \"1\", \"2\", \"3\" }));\n            } catch (IllegalArgumentException e) {\n                // Expected state\n                caughtAuthFailure = true;\n            }\n            assertTrue(\"Did not catch expected authorization failure\", caughtAuthFailure);\n        }\n\n        // Try with bad credentials to make sure we get a malformed response\n        {\n            boolean caughtAuthFailure = false;\n            for (String url : new String[] {\n                    \"http://blankpass@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\",\n                    \"http://blankpass:@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\",\n                    \"http://hqadmin@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\",\n                    \"http://hqadmin:@127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\",\n                    \"http://127.0.0.1:7081/hqu/opennms/alertStatus/list.hqu\"\n            }) {\n                try {\n                    List<HypericAckProcessor.HypericAlertStatus> alerts = HypericAckProcessor.fetchHypericAlerts(url, Arrays.asList(new String[] { \"1\", \"2\", \"3\" }));\n                } catch (JAXBException e) {\n                    // Expected state\n                    caughtAuthFailure = true;\n                }\n                assertTrue(\"Did not catch expected authorization failure for URL: \" + url, caughtAuthFailure);\n            }\n        }\n    }","commit_id":"f7d805c27d51c8a682b889b6bd68ae8ed578ad1c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static HttpClient getHttpClient(final String login, final String password) {\n    final HttpClient client = new HttpClient();\n    // Configure proxySettings if it is required\n    final HttpConfigurable proxySettings = HttpConfigurable.getInstance();\n    if (proxySettings.USE_HTTP_PROXY){\n      client.getHostConfiguration().setProxy(proxySettings.PROXY_HOST, proxySettings.PROXY_PORT);\n      if (proxySettings.PROXY_AUTHENTICATION) {\n        client.getState().setProxyCredentials(AuthScope.ANY, new UsernamePasswordCredentials(proxySettings.PROXY_LOGIN,\n                                                                                             proxySettings.getPlainProxyPassword()));\n      }\n    }\n    client.getParams().setAuthenticationPreemptive(true);\n    client.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(login, password));\n    return client;\n  }","id":98399,"modified_method":"public static HttpClient getHttpClient(@Nullable final String login, @Nullable final String password) {\n    final HttpClient client = new HttpClient();\n    // Configure proxySettings if it is required\n    final HttpConfigurable proxySettings = HttpConfigurable.getInstance();\n    if (proxySettings.USE_HTTP_PROXY){\n      client.getHostConfiguration().setProxy(proxySettings.PROXY_HOST, proxySettings.PROXY_PORT);\n      if (proxySettings.PROXY_AUTHENTICATION) {\n        client.getState().setProxyCredentials(AuthScope.ANY, new UsernamePasswordCredentials(proxySettings.PROXY_LOGIN,\n                                                                                             proxySettings.getPlainProxyPassword()));\n      }\n    }\n    if (login != null && password != null) {\n      client.getParams().setAuthenticationPreemptive(true);\n      client.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(login, password));\n    }\n    return client;\n  }","commit_id":"02037e9ec8059ab8c751f5e7e49cd881b2fac6a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void connect() throws IOException {\n        if (!connected) {\n            String userinfo = url.getUserInfo();\n\n            // Create the HTTP client (this *should* be fairly lightweight)\n\n            // NOTE: This will also reset the client's state, including cookies and authorization stuff, as currently\n            // don't have the ability to keep this state for example in association with an XForms page.\n            final HttpClient httpClient = new HttpClient(connectionManager);\n\n            // Make authentification preemptive\n            httpClient.getParams().setAuthenticationPreemptive(true);\n\n            if (userinfo != null) {\n                // Set username and optional password specified on URL\n                int separatorPosition = userinfo.indexOf(\":\");\n                String username = separatorPosition == -1 ? userinfo : userinfo.substring(0, separatorPosition);\n                String password = separatorPosition == -1 ? \"\" : userinfo.substring(separatorPosition + 1);\n                // If the username/password contain special character, those character will be encoded, since we\n                // are getting this from a URL. Now do the decoding.\n                username = URLDecoder.decode(username, \"utf-8\");\n                password = URLDecoder.decode(password, \"utf-8\");\n                httpClient.getState().setCredentials(\n                    new AuthScope(url.getHost(), url.getPort()),\n                    new UsernamePasswordCredentials(username, password)\n                );\n            } else if (username != null) {\n                // Set username and password specified externally\n                httpClient.getState().setCredentials(\n                    new AuthScope(url.getHost(), url.getPort()),\n                    new UsernamePasswordCredentials(username, password == null ? \"\" : password)\n                );\n            }\n\n            // If method has not been set, use GET\n            if (method == null)\n                method = new GetMethod(url.toString());\n            // Create request entity with body\n            if (requestBody != null && method instanceof EntityEnclosingMethod) {\n                HandlerRequestEntity requestEntity = new HandlerRequestEntity(requestBody, getRequestProperty(\"content-type\"));\n                ((EntityEnclosingMethod) method).setRequestEntity(requestEntity);\n            }\n            // Set headers\n            for (Iterator keyIteratory = requestProperties.keySet().iterator(); keyIteratory.hasNext();) {\n                String key = (String) keyIteratory.next();\n                if (!\"authorization\".equalsIgnoreCase(key) || (userinfo == null && username == null))\n                    method.setRequestHeader(key, (String) requestProperties.get(key));\n            }\n            // Handle authentication challenge\n            method.setDoAuthentication(true);\n\n            // Make request\n            responseCode = httpClient.executeMethod(method);\n            connected = true;\n        }\n    }","id":98400,"modified_method":"public void connect() throws IOException {\n        if (!connected) {\n            String userinfo = url.getUserInfo();\n\n            // Create the HTTP client (this *should* be fairly lightweight)\n\n            // NOTE: This will also reset the client's state, including cookies and authorization stuff, as currently\n            // don't have the ability to keep this state for example in association with an XForms page.\n            final HttpClient httpClient = new HttpClient(connectionManager);\n\n            // Make authentification preemptive\n            if (userinfo != null || username != null)\n                httpClient.getParams().setAuthenticationPreemptive(true);\n\n            if (userinfo != null) {\n                // Set username and optional password specified on URL\n                int separatorPosition = userinfo.indexOf(\":\");\n                String username = separatorPosition == -1 ? userinfo : userinfo.substring(0, separatorPosition);\n                String password = separatorPosition == -1 ? \"\" : userinfo.substring(separatorPosition + 1);\n                // If the username/password contain special character, those character will be encoded, since we\n                // are getting this from a URL. Now do the decoding.\n                username = URLDecoder.decode(username, \"utf-8\");\n                password = URLDecoder.decode(password, \"utf-8\");\n                httpClient.getState().setCredentials(\n                    new AuthScope(url.getHost(), url.getPort()),\n                    new UsernamePasswordCredentials(username, password)\n                );\n            } else if (username != null) {\n                // Set username and password specified externally\n                httpClient.getState().setCredentials(\n                    new AuthScope(url.getHost(), url.getPort()),\n                    new UsernamePasswordCredentials(username, password == null ? \"\" : password)\n                );\n            }\n\n            // If method has not been set, use GET\n            if (method == null)\n                method = new GetMethod(url.toString());\n            // Create request entity with body\n            if (requestBody != null && method instanceof EntityEnclosingMethod) {\n                HandlerRequestEntity requestEntity = new HandlerRequestEntity(requestBody, getRequestProperty(\"content-type\"));\n                ((EntityEnclosingMethod) method).setRequestEntity(requestEntity);\n            }\n            // Set headers\n            for (Iterator keyIteratory = requestProperties.keySet().iterator(); keyIteratory.hasNext();) {\n                String key = (String) keyIteratory.next();\n                if (!\"authorization\".equalsIgnoreCase(key) || (userinfo == null && username == null))\n                    method.setRequestHeader(key, (String) requestProperties.get(key));\n            }\n            // Handle authentication challenge\n            method.setDoAuthentication(true);\n\n            // Make request\n            responseCode = httpClient.executeMethod(method);\n            connected = true;\n        }\n    }","commit_id":"0797b60d74f92e4585ff029716589490f0ab3e47","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"protected JCExpression makeInvocation() {\n        gen.at(node);\n        \n        JCExpression result = gen.expressionGen().transformPrimary(primary, new TermTransformer() {\n            @Override\n            public JCExpression transform(JCExpression primaryExpr, String selector) {\n                TransformedInvocationPrimary transformedPrimary = transformPrimary(primaryExpr, selector);\n                List<JCExpression> argExprs = transformArgumentList(transformedPrimary);\n                JCExpression resultExpr = transformInvocationOrInstantiation(transformedPrimary, argExprs);\n                return resultExpr;\n            }\n        });\n\n        return result;\n    }","id":98401,"modified_method":"protected JCExpression makeInvocation() {\n        gen.at(node);\n        \n        JCExpression result = gen.expressionGen().transformPrimary(primary, new TermTransformer() {\n            @Override\n            public JCExpression transform(JCExpression primaryExpr, String selector) {\n                TransformedInvocationPrimary transformedPrimary = transformPrimary(primaryExpr, selector);\n                transformArgumentList(transformedPrimary);\n                JCExpression resultExpr = transformInvocationOrInstantiation(transformedPrimary);\n                return resultExpr;\n            }\n        });\n\n        return result;\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected JCExpression transformInvocationOrInstantiation(TransformedInvocationPrimary transformedPrimary,\n            List<JCExpression> argExprs) {\n        JCExpression resultExpr;\n        if (primary instanceof Tree.BaseTypeExpression) {\n            resultExpr = transformBaseInstantiation(transformedPrimary,\n                    argExprs);\n        } else if (primary instanceof Tree.QualifiedTypeExpression) {\n            resultExpr = transformQualifiedInstantiation(transformedPrimary,\n                    argExprs);\n        } else {   \n            resultExpr = transformInvocation(transformedPrimary, argExprs);\n        }\n        \n        if(handleBoxing)\n            resultExpr = gen.expressionGen().applyErasureAndBoxing(resultExpr, returnType, \n                    !unboxed, boxingStrategy, returnType);\n        return resultExpr;\n    }","id":98402,"modified_method":"protected JCExpression transformInvocationOrInstantiation(TransformedInvocationPrimary transformedPrimary) {\n        JCExpression resultExpr;\n        if (primary instanceof Tree.BaseTypeExpression) {\n            resultExpr = transformBaseInstantiation(transformedPrimary);\n        } else if (primary instanceof Tree.QualifiedTypeExpression) {\n            resultExpr = transformQualifiedInstantiation(transformedPrimary);\n        } else {   \n            resultExpr = transformInvocation(transformedPrimary);\n        }\n        \n        if(handleBoxing)\n            resultExpr = gen.expressionGen().applyErasureAndBoxing(resultExpr, returnType, \n                    !unboxed, boxingStrategy, returnType);\n        return resultExpr;\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected InvocationBuilder(AbstractTransformer gen, \n            Tree.Primary primary, Declaration primaryDeclaration,\n            ProducedType returnType, Node node) {\n        this.gen = gen;\n        this.primary = primary;\n        this.primaryDeclaration = primaryDeclaration;\n        this.returnType = returnType;\n        this.node = node;\n        \n        if (primary instanceof Tree.StaticMemberOrTypeExpression){\n            this.primaryTypeArguments = transformTypeArguments(gen, ((Tree.StaticMemberOrTypeExpression)primary).getTypeArguments().getTypeModels());\n        } else {\n            this.primaryTypeArguments = transformTypeArguments(gen, null);\n        }\n        if (primary instanceof Tree.QualifiedMemberOrTypeExpression){\n            this.qmePrimary = ((Tree.QualifiedMemberOrTypeExpression) primary).getPrimary();\n            this.onValueType = Decl.isValueTypeDecl(qmePrimary);\n        } else {\n            this.qmePrimary = null;\n            this.onValueType = false;\n        }\n    }","id":98403,"modified_method":"protected InvocationBuilder(AbstractTransformer gen, \n            Tree.Primary primary, Declaration primaryDeclaration,\n            ProducedType returnType, Node node) {\n        this.gen = gen;\n        this.callBuilder = CallBuilder.instance(gen);\n        this.primary = primary;\n        this.primaryDeclaration = primaryDeclaration;\n        this.returnType = returnType;\n        this.node = node;\n        \n        if (primary instanceof Tree.StaticMemberOrTypeExpression){\n            this.primaryTypeArguments = transformTypeArguments(gen, ((Tree.StaticMemberOrTypeExpression)primary).getTypeArguments().getTypeModels());\n        } else {\n            this.primaryTypeArguments = transformTypeArguments(gen, null);\n        }\n        if (primary instanceof Tree.QualifiedMemberOrTypeExpression){\n            this.qmePrimary = ((Tree.QualifiedMemberOrTypeExpression) primary).getPrimary();\n            this.onValueType = Decl.isValueTypeDecl(qmePrimary);\n        } else {\n            this.qmePrimary = null;\n            this.onValueType = false;\n        }\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected List<JCExpression> transformArgumentList(TransformedInvocationPrimary transformedPrimary) {\n        gen.expressionGen().withinInvocation(false);\n        compute();\n        List<JCExpression> args = this.args.toList();\n        if (needsTypeInfoArgument()) {\n            JCExpression infoArg = makeTypeInfoArgument();\n            args = args.prepend(infoArg);\n        }\n        if (!(primary instanceof Tree.BaseTypeExpression)\n                && !(primary instanceof Tree.QualifiedTypeExpression)\n                && onValueType \n                && transformedPrimary != null) {\n            args = args.prepend(transformedPrimary.expr);   \n        }\n        List<JCExpression> argExprs = args;\n        gen.expressionGen().withinInvocation(true);\n        return argExprs;\n    }","id":98404,"modified_method":"protected void transformArgumentList(TransformedInvocationPrimary transformedPrimary) {\n        gen.expressionGen().withinInvocation(false);\n        compute();\n        \n        if (needsTypeInfoArgument()) {\n            JCExpression infoArg = makeTypeInfoArgument();\n            this.callBuilder.prependArgument(infoArg);\n        }\n        if (!(primary instanceof Tree.BaseTypeExpression)\n                && !(primary instanceof Tree.QualifiedTypeExpression)\n                && onValueType \n                && transformedPrimary != null) {\n            this.callBuilder.prependArgument(transformedPrimary.expr);   \n        }\n        gen.expressionGen().withinInvocation(true);\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression transformQualifiedInstantiation(\n            TransformedInvocationPrimary transformedPrimary,\n            List<JCExpression> argExprs) {\n        JCExpression resultExpr;\n        // When doing qualified invocation through an interface we need\n        // to get the companion.\n        Tree.QualifiedTypeExpression qte = (Tree.QualifiedTypeExpression)primary;\n        Declaration declaration = qte.getDeclaration();\n        resultExpr = transformedPrimary.expr;\n        if (declaration.getContainer() instanceof Interface\n                && !Strategy.generateInstantiator(declaration)\n                && !(qte.getPrimary() instanceof Tree.Outer)) {\n            Interface qualifyingInterface = (Interface)declaration.getContainer();\n            resultExpr = gen.make().Apply(null, \n                    gen.makeSelect(transformedPrimary.expr, gen.getCompanionAccessorName(qualifyingInterface)), \n                    List.<JCExpression>nil());\n            // But when the interface is local the accessor returns Object\n            // so we need to cast it to the type of the companion\n            if (Decl.isAncestorLocal(declaration)) {\n                resultExpr = gen.make().TypeCast(gen.makeJavaType(qualifyingInterface.getType(), JT_COMPANION), resultExpr);\n            }\n        }\n        if (Strategy.generateInstantiator(declaration)) {\n            resultExpr = gen.make().Apply(null, \n                    gen.naming.makeInstantiatorMethodName(resultExpr, (Class)declaration), \n                    argExprs);\n        } else {\n            ProducedType classType = (ProducedType)qte.getTarget();\n            // Note: here we're not fully qualifying the class name because the JLS says that if \"new\" is qualified the class name\n            // is qualified relative to it\n            JCExpression type = gen.makeJavaType(classType, AbstractTransformer.JT_CLASS_NEW | AbstractTransformer.JT_NON_QUALIFIED);\n            resultExpr = gen.make().NewClass(resultExpr, null, type, argExprs, null);\n        }\n        return resultExpr;\n    }","id":98405,"modified_method":"private JCExpression transformQualifiedInstantiation(\n            TransformedInvocationPrimary transformedPrimary) {\n        \n        Tree.QualifiedTypeExpression qte = (Tree.QualifiedTypeExpression)primary;\n        Declaration declaration = qte.getDeclaration();\n        if (!Strategy.generateInstantiator(declaration)) {\n            // When doing qualified invocation through an interface we need\n            // to get the companion.\n            JCExpression qualifier;\n            if (declaration.getContainer() instanceof Interface\n                    && !(qte.getPrimary() instanceof Tree.Outer)) {\n                Interface qualifyingInterface = (Interface)declaration.getContainer();\n                qualifier = gen.make().Apply(null, \n                        gen.makeSelect(transformedPrimary.expr, gen.getCompanionAccessorName(qualifyingInterface)), \n                        List.<JCExpression>nil());\n                // But when the interface is local the accessor returns Object\n                // so we need to cast it to the type of the companion\n                if (Decl.isAncestorLocal(declaration)) {\n                    qualifier = gen.make().TypeCast(gen.makeJavaType(qualifyingInterface.getType(), JT_COMPANION), qualifier);\n                }\n            } else {\n                qualifier = transformedPrimary.expr;\n            }\n            ProducedType classType = (ProducedType)qte.getTarget();\n            // Note: here we're not fully qualifying the class name because the JLS says that if \"new\" is qualified the class name\n            // is qualified relative to it\n            JCExpression type = gen.makeJavaType(classType, AbstractTransformer.JT_CLASS_NEW | AbstractTransformer.JT_NON_QUALIFIED);\n            //resultExpr = gen.make().NewClass(qualifier, null, type, argExprs, null);\n            callBuilder.instantiate(qualifier, type);\n        } else {\n            callBuilder.invoke(gen.naming.makeInstantiatorMethodName(transformedPrimary.expr, (Class)declaration));\n        }\n        return callBuilder.build();\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Appends an argument\n     * @param argExpr\n     */\n    protected final void appendArgument(JCExpression argExpr) {\n        this.args.append(argExpr);\n    }","id":98406,"modified_method":"/**\n     * Appends an argument\n     * @param argExpr\n     */\n    protected final void appendArgument(JCExpression argExpr) {\n        this.callBuilder.argument(argExpr);\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression transformBaseInstantiation(\n            TransformedInvocationPrimary transformedPrimary,\n            List<JCExpression> argExprs) {\n        JCExpression resultExpr;\n        Tree.BaseTypeExpression type = (Tree.BaseTypeExpression)primary;\n        Declaration declaration = type.getDeclaration();\n        if (Strategy.generateInstantiator(declaration)) {\n            resultExpr = gen.make().Apply(null, \n                    gen.naming.makeInstantiatorMethodName(transformedPrimary.expr, (Class)declaration), \n                    argExprs);\n            if (Decl.isAncestorLocal(primaryDeclaration)) {\n                // $new method declared to return Object, so needs typecast\n                resultExpr = gen.make().TypeCast(gen.makeJavaType(\n                        ((TypeDeclaration)declaration).getType()), resultExpr);\n            }\n        } else {\n            ProducedType classType = (ProducedType)type.getTarget();\n            resultExpr = gen.make().NewClass(null, null, gen.makeJavaType(classType, AbstractTransformer.JT_CLASS_NEW), argExprs, null);\n        }\n        return resultExpr;\n    }","id":98407,"modified_method":"private JCExpression transformBaseInstantiation(\n            TransformedInvocationPrimary transformedPrimary) {\n        JCExpression resultExpr;\n        Tree.BaseTypeExpression type = (Tree.BaseTypeExpression)primary;\n        Declaration declaration = type.getDeclaration();\n        if (Strategy.generateInstantiator(declaration)) {\n            callBuilder.invoke(gen.naming.makeInstantiatorMethodName(transformedPrimary.expr, (Class)declaration));\n            resultExpr = callBuilder.build();\n            if (Decl.isAncestorLocal(primaryDeclaration)) {\n                // $new method declared to return Object, so needs typecast\n                resultExpr = gen.make().TypeCast(gen.makeJavaType(\n                        ((TypeDeclaration)declaration).getType()), resultExpr);\n            }\n        } else {\n            ProducedType classType = (ProducedType)type.getTarget();\n            callBuilder.instantiate(gen.makeJavaType(classType, AbstractTransformer.JT_CLASS_NEW));\n            resultExpr = callBuilder.build();\n        }\n        return resultExpr;\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression transformInvocation(\n            TransformedInvocationPrimary transformedPrimary,\n            List<JCExpression> argExprs) {\n        JCExpression resultExpr;\n        if (onValueType) {\n            JCExpression primTypeExpr = gen.makeJavaType(qmePrimary.getTypeModel(), JT_NO_PRIMITIVES);\n            resultExpr = gen.make().Apply(primaryTypeArguments, \n                    gen.naming.makeQuotedQualIdent(primTypeExpr, transformedPrimary.selector), \n                    argExprs);\n        } else {\n            resultExpr = gen.make().Apply(primaryTypeArguments, \n                    gen.naming.makeQuotedQualIdent(transformedPrimary.expr, transformedPrimary.selector), \n                    argExprs);\n        }\n        return resultExpr;\n    }","id":98408,"modified_method":"private JCExpression transformInvocation(\n            TransformedInvocationPrimary transformedPrimary) {\n        callBuilder.typeArguments(primaryTypeArguments);\n        if (onValueType) {\n            JCExpression primTypeExpr = gen.makeJavaType(qmePrimary.getTypeModel(), JT_NO_PRIMITIVES);\n            callBuilder.invoke(gen.naming.makeQuotedQualIdent(primTypeExpr, transformedPrimary.selector));\n        } else {\n            callBuilder.invoke(gen.naming.makeQuotedQualIdent(transformedPrimary.expr, transformedPrimary.selector));\n        }\n        return callBuilder.build();\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    protected JCExpression makeInvocation() {\n        gen.at(node);\n        JCExpression result = gen.make().Apply(primaryTypeArguments, \n                gen.naming.makeQuotedQualIdent(callable, Naming.getCallableMethodName()), \n                transformArgumentList(null));\n        if(handleBoxing)\n            result = gen.expressionGen().applyErasureAndBoxing(result, returnType, \n                    !unboxed, boxingStrategy, returnType);\n        return result;\n    }","id":98409,"modified_method":"@Override\n    protected JCExpression makeInvocation() {\n        gen.at(node);\n        \n        this.callBuilder.typeArguments(primaryTypeArguments)\n            .invoke(gen.naming.makeQuotedQualIdent(callable, Naming.getCallableMethodName()));\n        \n        transformArgumentList(null);\n        JCExpression result = this.callBuilder.build();\n        if(handleBoxing)\n            result = gen.expressionGen().applyErasureAndBoxing(result, returnType, \n                    !unboxed, boxingStrategy, returnType);\n        return result;\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    protected JCExpression makeInvocation() {\n        gen.at(node);\n        JCExpression expr = null;\n        if (Strategy.generateInstantiator(primaryDeclaration)\n                && primaryDeclaration.getContainer() instanceof Interface) {\n            // If the subclass is inner to an interface then it will be \n            // generated inner to the companion and we need to qualify the \n            // super(), *unless* the subclass is nested within the same \n            // interface as it's superclass.\n            Scope outer = sub.getDeclarationModel().getContainer();\n            while (!(outer instanceof Package)) {\n                if (outer == primaryDeclaration.getContainer()) {\n                    expr = gen.naming.makeSuper();\n                    break;\n                }\n                outer = outer.getContainer();\n            }\n            if (expr == null) {\n                expr = gen.naming.makeQualifiedSuper(gen.naming.makeCompanionFieldName((Interface)primaryDeclaration.getContainer()));\n            }\n        } else {\n            expr = gen.naming.makeSuper();\n        }\n        JCExpression result = gen.make().Apply(List.<JCExpression> nil(), expr,\n                // We could create a TransformedPrimary(expr, \"super\") here if needed\n                transformArgumentList(null));\n        return result;\n    }","id":98410,"modified_method":"@Override\n    protected JCExpression makeInvocation() {\n        gen.at(node);\n        JCExpression expr = null;\n        if (Strategy.generateInstantiator(primaryDeclaration)\n                && primaryDeclaration.getContainer() instanceof Interface) {\n            // If the subclass is inner to an interface then it will be \n            // generated inner to the companion and we need to qualify the \n            // super(), *unless* the subclass is nested within the same \n            // interface as it's superclass.\n            Scope outer = sub.getDeclarationModel().getContainer();\n            while (!(outer instanceof Package)) {\n                if (outer == primaryDeclaration.getContainer()) {\n                    expr = gen.naming.makeSuper();\n                    break;\n                }\n                outer = outer.getContainer();\n            }\n            if (expr == null) {\n                expr = gen.naming.makeQualifiedSuper(gen.naming.makeCompanionFieldName((Interface)primaryDeclaration.getContainer()));\n            }\n        } else {\n            expr = gen.naming.makeSuper();\n        }\n        this.callBuilder.invoke(expr);\n        // We could create a TransformedPrimary(expr, \"super\") here if needed\n        transformArgumentList(null);\n        return callBuilder.build();\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    protected JCExpression transformInvocationOrInstantiation(\n            TransformedInvocationPrimary transformedPrimary,\n            List<JCExpression> argExprs) {\n        JCExpression resultExpr = super.transformInvocationOrInstantiation(transformedPrimary, argExprs);\n        // apply the default parameters\n        if (vars != null && !vars.isEmpty()) {\n            if (returnType == null || Decl.isUnboxedVoid(primaryDeclaration)) {\n                // void methods get wrapped like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1); null)\n                resultExpr = gen.make().LetExpr( \n                        vars.append(gen.make().Exec(resultExpr)).toList(), \n                        gen.makeNull());\n            } else {\n                // all other methods like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1))\n                resultExpr = gen.make().LetExpr( \n                        vars.toList(),\n                        resultExpr);\n            }\n        }\n        return resultExpr;\n    }","id":98411,"modified_method":"@Override\n    protected JCExpression transformInvocationOrInstantiation(\n            TransformedInvocationPrimary transformedPrimary) {\n        JCExpression resultExpr = super.transformInvocationOrInstantiation(transformedPrimary);\n        // apply the default parameters\n        if (vars != null && !vars.isEmpty()) {\n            if (returnType == null || Decl.isUnboxedVoid(primaryDeclaration)) {\n                // void methods get wrapped like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1); null)\n                resultExpr = gen.make().LetExpr( \n                        vars.append(gen.make().Exec(resultExpr)).toList(), \n                        gen.makeNull());\n            } else {\n                // all other methods like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1))\n                resultExpr = gen.make().LetExpr( \n                        vars.toList(),\n                        resultExpr);\n            }\n        }\n        return resultExpr;\n    }","commit_id":"c881a91d2dd3d9eaa80a1b098a93d2b085848b6c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n\tpublic void requestWasRemoved(ObjectContainer container, ClientContext context) {\n\t\t// if request is still running, send a PutFailed with code=cancelled\n\t\tif( !finished ) {\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tInsertException cancelled = new InsertException(InsertException.CANCELLED);\n\t\t\t\tputFailedMessage = new PutFailedMessage(cancelled, identifier, global);\n\t\t\t}\n\t\t\ttrySendFinalMessage(null, container);\n\t\t}\n\t\t// notify client that request was removed\n\t\tFCPMessage msg = new PersistentRequestRemovedMessage(getIdentifier(), global);\n\t\tclient.queueClientRequestMessage(msg, 0, container);\n\n\t\tfreeData(container);\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tcontainer.activate(ctx, 2);\n\t\t\tctx.removeFrom(container);\n\t\t\tPutFailedMessage pfm;\n\t\t\tFreenetURI uri;\n\t\t\tFreenetURI pubURI;\n\t\t\tFCPMessage progress;\n\t\t\tsynchronized(this) {\n\t\t\t\tpfm = putFailedMessage;\n\t\t\t\tputFailedMessage = null;\n\t\t\t\turi = generatedURI;\n\t\t\t\tgeneratedURI = null;\n\t\t\t\tpubURI = publicURI;\n\t\t\t\tprogress = progressMessage;\n\t\t\t\tprogressMessage = null;\n\t\t\t}\n\t\t\tif(pfm != null) {\n\t\t\t\tcontainer.activate(pfm, 5);\n\t\t\t\tpfm.removeFrom(container);\n\t\t\t}\n\t\t\tif(uri != null) {\n\t\t\t\tcontainer.activate(uri, 5);\n\t\t\t\turi.removeFrom(container);\n\t\t\t}\n\t\t\tif(progress != null) {\n\t\t\t\tcontainer.activate(progress, 1);\n\t\t\t\tprogress.removeFrom(container);\n\t\t\t}\n\t\t\tif(pubURI != null) {\n\t\t\t\tcontainer.activate(pubURI, 5);\n\t\t\t\tpubURI.removeFrom(container);\n\t\t\t}\n\t\t}\n\t\tsuper.requestWasRemoved(container, context);\n\t}","id":98412,"modified_method":"@Override\n\tpublic void requestWasRemoved(ObjectContainer container, ClientContext context) {\n\t\t// if request is still running, send a PutFailed with code=cancelled\n\t\tif( !finished ) {\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tInsertException cancelled = new InsertException(InsertException.CANCELLED);\n\t\t\t\tputFailedMessage = new PutFailedMessage(cancelled, identifier, global);\n\t\t\t}\n\t\t\ttrySendFinalMessage(null, container);\n\t\t}\n\t\t// notify client that request was removed\n\t\tFCPMessage msg = new PersistentRequestRemovedMessage(getIdentifier(), global);\n\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\torigHandler.outputHandler.queue(msg);\n\t\telse\n\t\tclient.queueClientRequestMessage(msg, 0, container);\n\n\t\tfreeData(container);\n\t\tif(persistenceType == PERSIST_FOREVER) {\n\t\t\tcontainer.activate(ctx, 2);\n\t\t\tctx.removeFrom(container);\n\t\t\tPutFailedMessage pfm;\n\t\t\tFreenetURI uri;\n\t\t\tFreenetURI pubURI;\n\t\t\tFCPMessage progress;\n\t\t\tsynchronized(this) {\n\t\t\t\tpfm = putFailedMessage;\n\t\t\t\tputFailedMessage = null;\n\t\t\t\turi = generatedURI;\n\t\t\t\tgeneratedURI = null;\n\t\t\t\tpubURI = publicURI;\n\t\t\t\tprogress = progressMessage;\n\t\t\t\tprogressMessage = null;\n\t\t\t}\n\t\t\tif(pfm != null) {\n\t\t\t\tcontainer.activate(pfm, 5);\n\t\t\t\tpfm.removeFrom(container);\n\t\t\t}\n\t\t\tif(uri != null) {\n\t\t\t\tcontainer.activate(uri, 5);\n\t\t\t\turi.removeFrom(container);\n\t\t\t}\n\t\t\tif(progress != null) {\n\t\t\t\tcontainer.activate(progress, 1);\n\t\t\t\tprogress.removeFrom(container);\n\t\t\t}\n\t\t\tif(pubURI != null) {\n\t\t\t\tcontainer.activate(pubURI, 5);\n\t\t\t\tpubURI.removeFrom(container);\n\t\t\t}\n\t\t}\n\t\tsuper.requestWasRemoved(container, context);\n\t}","commit_id":"08ec296b0d034ba167cc470aa6d3f9167e38f1b2","url":"https://github.com/freenet/fred"},{"original_method":"private void trySendAllDataMessage(AllDataMessage msg, FCPConnectionOutputHandler handler, ObjectContainer container) {\n\t\tif(persistenceType != ClientRequest.PERSIST_CONNECTION) {\n\t\t\tallDataPending = msg;\n\t\t\tif(persistenceType == ClientRequest.PERSIST_FOREVER)\n\t\t\t\tcontainer.store(this);\n\t\t} else {\n\t\t\tif(persistenceType == PERSIST_FOREVER)\n\t\t\t\tcontainer.activate(client, 1);\n\t\t\tclient.queueClientRequestMessage(msg, 0, container);\n\t\t}\n\t}","id":98413,"modified_method":"private void trySendAllDataMessage(AllDataMessage msg, FCPConnectionOutputHandler handler, ObjectContainer container) {\n\t\tif(persistenceType != ClientRequest.PERSIST_CONNECTION) {\n\t\t\tallDataPending = msg;\n\t\t\tif(persistenceType == ClientRequest.PERSIST_FOREVER) {\n\t\t\t\tcontainer.activate(client, 1);\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\t\t}\n\t\tif(persistenceType == PERSIST_CONNECTION && handler == null)\n\t\t\thandler = origHandler.outputHandler;\n\t\tif(handler != null)\n\t\t\thandler.queue(msg);\n\t\telse\n\t\t\tclient.queueClientRequestMessage(msg, 0, container);\n\t}","commit_id":"99cd9295070015097f0bdd8b3ce2073d5a4772da","url":"https://github.com/freenet/fred"},{"original_method":"private void trySendProgress(SimpleProgressMessage msg, FCPConnectionOutputHandler handler, ObjectContainer container) {\n\t\tif(persistenceType != ClientRequest.PERSIST_CONNECTION) {\n\t\t\tprogressPending = msg;\n\t\t\tif(persistenceType == ClientRequest.PERSIST_FOREVER)\n\t\t\t\tcontainer.store(this);\n\t\t}\n\t\tif(persistenceType == PERSIST_FOREVER)\n\t\t\tcontainer.activate(client, 1);\n\t\tclient.queueClientRequestMessage(msg, VERBOSITY_SPLITFILE_PROGRESS, container);\n\t\tif(persistenceType == PERSIST_FOREVER && !client.isGlobalQueue)\n\t\t\tcontainer.deactivate(client, 1);\n\t}","id":98414,"modified_method":"private void trySendProgress(SimpleProgressMessage msg, FCPConnectionOutputHandler handler, ObjectContainer container) {\n\t\tif(persistenceType != ClientRequest.PERSIST_CONNECTION) {\n\t\t\tprogressPending = msg;\n\t\t\tif(persistenceType == ClientRequest.PERSIST_FOREVER)\n\t\t\t\tcontainer.store(this);\n\t\t}\n\t\tif(persistenceType == PERSIST_FOREVER)\n\t\t\tcontainer.activate(client, 1);\n\t\tif(persistenceType == PERSIST_CONNECTION && handler == null)\n\t\t\thandler = origHandler.outputHandler;\n\t\tif(handler != null) {\n\t\t\thandler.queue(msg);\n\t\t} else\n\t\t\tclient.queueClientRequestMessage(msg, VERBOSITY_SPLITFILE_PROGRESS, container);\n\t\tif(persistenceType == PERSIST_FOREVER && !client.isGlobalQueue)\n\t\t\tcontainer.deactivate(client, 1);\n\t}","commit_id":"7382c7f0f9a1fa9c6b4a145184eac22f44cb88aa","url":"https://github.com/freenet/fred"},{"original_method":"public void notification(StoreEvent event) {\n            String typeString = \"\";\n            switch(event.getMessageType()) {\n                case StoreEvent.ALERT:\n                    typeString = \"ALERT: \";\n                    break;\n                case StoreEvent.NOTICE:\n                    typeString = \"NOTICE: \";\n                    break;\n            }\n\n            Debug.logVerbose(\"JavaMail \" + typeString + event.getMessage(), module);\n        }","id":98415,"modified_method":"public void notification(StoreEvent event) {\n            String typeString = \"\";\n            switch(event.getMessageType()) {\n                case StoreEvent.ALERT:\n                    typeString = \"ALERT: \";\n                    break;\n                case StoreEvent.NOTICE:\n                    typeString = \"NOTICE: \";\n                    break;\n            }\n\n            if (Debug.verboseOn()) Debug.logVerbose(\"JavaMail \" + typeString + event.getMessage(), module);\n        }","commit_id":"9dbd658a0a4f4c0df59bc383c065dbbee2a1c407","url":"https://github.com/apache/ofbiz"},{"original_method":"protected void checkMessages(Store store, Session session) throws MessagingException, GeneralException {\n            store.addStoreListener(new LoggingStoreListener());\n            store.connect();\n\n            // open the default folder\n            Folder folder = store.getDefaultFolder();\n            if (folder == null) {\n                throw new MessagingException(\"No default folder available\");\n            }\n\n            // open the inbox\n            folder = folder.getFolder(INBOX);\n            if (folder == null) {\n                throw new MessagingException(\"No INBOX folder available\");\n            }\n\n            // get the message count; stop if nothing to do\n            folder.open(Folder.READ_WRITE);\n            int totalMessages = folder.getMessageCount();\n            if (totalMessages == 0) {\n                folder.close(false);\n                store.close();\n                return;\n            }\n\n            // get all messages\n            Message[] messages = folder.getMessages();\n            FetchProfile profile = new FetchProfile();\n            profile.add(FetchProfile.Item.ENVELOPE);\n            profile.add(FetchProfile.Item.FLAGS);\n            profile.add(\"X-Mailer\");\n            folder.fetch(messages, profile);\n\n            // process each message\n            for (int i = 0; i < messages.length; i++) {\n                // process each un-read message\n                if (!messages[i].isSet(Flags.Flag.SEEN)) {\n                    this.processMessage(messages[i], session);\n                    Debug.logVerbose(\"Message from \" + UtilMisc.toListArray(messages[i].getFrom()) + \" with subject [\" + messages[i].getSubject() + \"]  has been processed.\" , module);\n                    messages[i].setFlag(Flags.Flag.SEEN, true);\n                    Debug.logVerbose(\"Message [\" + messages[i].getSubject() + \"] is marked seen\", module);\n                }\n                if (deleteMail) {\n                    Debug.logVerbose(\"Message [\" + messages[i].getSubject() + \"] is being deleted\", module);\n                    messages[i].setFlag(Flags.Flag.DELETED, true);\n                }\n            }\n\n            // expunge and close the folder\n            folder.close(true);\n            store.close();\n        }","id":98416,"modified_method":"protected void checkMessages(Store store, Session session) throws MessagingException, GeneralException {\n            store.addStoreListener(new LoggingStoreListener());\n            store.connect();\n\n            // open the default folder\n            Folder folder = store.getDefaultFolder();\n            if (folder == null) {\n                throw new MessagingException(\"No default folder available\");\n            }\n\n            // open the inbox\n            folder = folder.getFolder(INBOX);\n            if (folder == null) {\n                throw new MessagingException(\"No INBOX folder available\");\n            }\n\n            // get the message count; stop if nothing to do\n            folder.open(Folder.READ_WRITE);\n            int totalMessages = folder.getMessageCount();\n            if (totalMessages == 0) {\n                folder.close(false);\n                store.close();\n                return;\n            }\n\n            // get all messages\n            Message[] messages = folder.getMessages();\n            FetchProfile profile = new FetchProfile();\n            profile.add(FetchProfile.Item.ENVELOPE);\n            profile.add(FetchProfile.Item.FLAGS);\n            profile.add(\"X-Mailer\");\n            folder.fetch(messages, profile);\n\n            // process each message\n            for (int i = 0; i < messages.length; i++) {\n                // process each un-read message\n                if (!messages[i].isSet(Flags.Flag.SEEN)) {\n                    this.processMessage(messages[i], session);\n                    if (Debug.verboseOn()) Debug.logVerbose(\"Message from \" + UtilMisc.toListArray(messages[i].getFrom()) + \" with subject [\" + messages[i].getSubject() + \"]  has been processed.\" , module);\n                    messages[i].setFlag(Flags.Flag.SEEN, true);\n                    if (Debug.verboseOn()) Debug.logVerbose(\"Message [\" + messages[i].getSubject() + \"] is marked seen\", module);\n                }\n                if (deleteMail) {\n                \tif (Debug.verboseOn()) Debug.logVerbose(\"Message [\" + messages[i].getSubject() + \"] is being deleted\", module);\n                    messages[i].setFlag(Flags.Flag.DELETED, true);\n                }\n            }\n\n            // expunge and close the folder\n            folder.close(true);\n            store.close();\n        }","commit_id":"9dbd658a0a4f4c0df59bc383c065dbbee2a1c407","url":"https://github.com/apache/ofbiz"},{"original_method":"protected URLName updateUrlName(URLName urlName, Properties props) {\n        String protocol = urlName.getProtocol();\n        String userName = urlName.getUsername();\n        String password = urlName.getPassword();\n        String host = urlName.getHost();\n        String file = urlName.getFile();\n        int port = urlName.getPort();\n\n        // check the username\n        if (UtilValidate.isEmpty(userName)) {\n            userName = props.getProperty(\"mail.\" + protocol + \".user\");\n            if (UtilValidate.isEmpty(userName)) {\n                userName = props.getProperty(\"mail.user\");\n            }\n        }\n\n        // check the password; update with the non-standard property\n        if (UtilValidate.isEmpty(password)) {\n            password = props.getProperty(\"mail.\" + protocol + \".pass\");\n            if (UtilValidate.isEmpty(password)) {\n                password = props.getProperty(\"mail.pass\");\n            }\n        }\n\n        // check the host\n        if (UtilValidate.isEmpty(host)) {\n            host = props.getProperty(\"mail.\" + protocol + \".host\");\n            if (UtilValidate.isEmpty(host)) {\n                host = props.getProperty(\"mail.host\");\n            }\n        }\n\n        Debug.logVerbose(\"Update URL - \" + protocol + \"://\" + userName + \"@\" + host + \":\" + port + \"!\" + password + \";\" + file, module);\n        return new URLName(protocol, host, port, file, userName, password);\n    }","id":98417,"modified_method":"protected URLName updateUrlName(URLName urlName, Properties props) {\n        String protocol = urlName.getProtocol();\n        String userName = urlName.getUsername();\n        String password = urlName.getPassword();\n        String host = urlName.getHost();\n        String file = urlName.getFile();\n        int port = urlName.getPort();\n\n        // check the username\n        if (UtilValidate.isEmpty(userName)) {\n            userName = props.getProperty(\"mail.\" + protocol + \".user\");\n            if (UtilValidate.isEmpty(userName)) {\n                userName = props.getProperty(\"mail.user\");\n            }\n        }\n\n        // check the password; update with the non-standard property\n        if (UtilValidate.isEmpty(password)) {\n            password = props.getProperty(\"mail.\" + protocol + \".pass\");\n            if (UtilValidate.isEmpty(password)) {\n                password = props.getProperty(\"mail.pass\");\n            }\n        }\n\n        // check the host\n        if (UtilValidate.isEmpty(host)) {\n            host = props.getProperty(\"mail.\" + protocol + \".host\");\n            if (UtilValidate.isEmpty(host)) {\n                host = props.getProperty(\"mail.host\");\n            }\n        }\n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Update URL - \" + protocol + \"://\" + userName + \"@\" + host + \":\" + port + \"!\" + password + \";\" + file, module);\n        return new URLName(protocol, host, port, file, userName, password);\n    }","commit_id":"9dbd658a0a4f4c0df59bc383c065dbbee2a1c407","url":"https://github.com/apache/ofbiz"},{"original_method":"protected Store getStore(Session session) throws ContainerException {\n        // create the store object\n        Store store = null;\n        try {\n            store = session.getStore();\n        } catch (NoSuchProviderException e) {\n            throw new ContainerException(e);\n        }\n\n        // re-write the URLName including the password for this store\n        if (store != null && store.getURLName() != null) {\n            URLName urlName = this.updateUrlName(store.getURLName(), session.getProperties());\n            Debug.logVerbose(\"URLName - \" + urlName.toString(), module);\n            try {\n                store = session.getStore(urlName);\n            } catch (NoSuchProviderException e) {\n                throw new ContainerException(e);\n            }\n        }\n\n        // test the store\n        try {\n            store.connect();\n            store.close();\n        } catch (MessagingException e) {\n            Debug.logError(\"Unable to connect to mail store : \" + store.getURLName().toString(), module);\n            return null;\n        }\n\n        return store;\n    }","id":98418,"modified_method":"protected Store getStore(Session session) throws ContainerException {\n        // create the store object\n        Store store = null;\n        try {\n            store = session.getStore();\n        } catch (NoSuchProviderException e) {\n            throw new ContainerException(e);\n        }\n\n        // re-write the URLName including the password for this store\n        if (store != null && store.getURLName() != null) {\n            URLName urlName = this.updateUrlName(store.getURLName(), session.getProperties());\n            if (Debug.verboseOn()) Debug.logVerbose(\"URLName - \" + urlName.toString(), module);\n            try {\n                store = session.getStore(urlName);\n            } catch (NoSuchProviderException e) {\n                throw new ContainerException(e);\n            }\n        }\n\n        // test the store\n        try {\n            store.connect();\n            store.close();\n        } catch (MessagingException e) {\n            Debug.logError(\"Unable to connect to mail store : \" + store.getURLName().toString(), module);\n            return null;\n        }\n\n        return store;\n    }","commit_id":"9dbd658a0a4f4c0df59bc383c065dbbee2a1c407","url":"https://github.com/apache/ofbiz"},{"original_method":"@Nullable\n  private OptionManager getOptionManager() {\n    return (OptionManager)getMainStorage(this).getStorageData();\n  }","id":98419,"modified_method":"@NotNull\n  private DeprecatedModuleOptionManager getOptionManager() {\n    //noinspection ConstantConditions\n    return ModuleServiceManager.getService(this, DeprecatedModuleOptionManager.class);\n  }","commit_id":"f306b71889efe883b352420e9f30745ac84daf0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getOptionValue(@NotNull String key) {\n    OptionManager manager = getOptionManager();\n    return manager == null ? null : manager.getOptionValue(key);\n  }","id":98420,"modified_method":"@Override\n  public String getOptionValue(@NotNull String key) {\n    return getOptionManager().state.options.get(key);\n  }","commit_id":"f306b71889efe883b352420e9f30745ac84daf0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setOption(@NotNull String key, @NotNull String value) {\n    OptionManager manager = getOptionManager();\n    if (manager != null) {\n      manager.setOption(key, value);\n    }\n  }","id":98421,"modified_method":"@Override\n  public void setOption(@NotNull String key, @NotNull String value) {\n    getOptionManager().state.options.put(key, value);\n  }","commit_id":"f306b71889efe883b352420e9f30745ac84daf0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void clearOption(@NotNull String key) {\n    OptionManager manager = getOptionManager();\n    if (manager != null) {\n      manager.clearOption(key);\n    }\n  }","id":98422,"modified_method":"@Override\n  public void clearOption(@NotNull String key) {\n    getOptionManager().state.options.remove(key);\n  }","commit_id":"f306b71889efe883b352420e9f30745ac84daf0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<String> readStringTable() throws IOException{\r\n\t\tList<String> list = new ArrayList<String>();\r\n\t\twhile(true){\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn list;\r\n\t\t\tcase OsmandOdb.StringTable.S_FIELD_NUMBER :\r\n\t\t\t\tlist.add(codedIS.readString());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// TODO skip unknown fields\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":98423,"modified_method":"private List<String> readStringTable() throws IOException{\r\n\t\tList<String> list = new ArrayList<String>();\r\n\t\twhile(true){\r\n\t\t\tint t = codedIS.readTag();\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn list;\r\n\t\t\tcase OsmandOdb.StringTable.S_FIELD_NUMBER :\r\n\t\t\t\tlist.add(codedIS.readString());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tskipUnknownField(t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private MapRoot readMapLevel() throws IOException {\r\n\t\tMapRoot root = new MapRoot();\r\n\t\twhile(true){\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn root;\r\n\t\t\tcase OsmandOdb.MapRootLevel.BOTTOM_FIELD_NUMBER :\r\n\t\t\t\troot.bottom = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.LEFT_FIELD_NUMBER :\r\n\t\t\t\troot.left = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.RIGHT_FIELD_NUMBER :\r\n\t\t\t\troot.right = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.TOP_FIELD_NUMBER :\r\n\t\t\t\troot.top = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.MAXZOOM_FIELD_NUMBER :\r\n\t\t\t\troot.maxZoom = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.MINZOOM_FIELD_NUMBER :\r\n\t\t\t\troot.minZoom = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.ROOT_FIELD_NUMBER :\r\n\t\t\t\tMapTree r = new MapTree();\r\n\t\t\t\t// left, ... already initialized \r\n\t\t\t\tr.length = readInt();\r\n\t\t\t\tr.filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(r.length);\r\n\t\t\t\treadMapTreeBounds(r, root.left, root.right, root.top, root.bottom);\r\n\t\t\t\troot.trees.add(r);\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(r.filePointer + r.length);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// TODO skip unknown fields\r\n\t\t\t\treturn root;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}","id":98424,"modified_method":"private MapRoot readMapLevel() throws IOException {\r\n\t\tMapRoot root = new MapRoot();\r\n\t\twhile(true){\r\n\t\t\tint t = codedIS.readTag();\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn root;\r\n\t\t\tcase OsmandOdb.MapRootLevel.BOTTOM_FIELD_NUMBER :\r\n\t\t\t\troot.bottom = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.LEFT_FIELD_NUMBER :\r\n\t\t\t\troot.left = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.RIGHT_FIELD_NUMBER :\r\n\t\t\t\troot.right = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.TOP_FIELD_NUMBER :\r\n\t\t\t\troot.top = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.MAXZOOM_FIELD_NUMBER :\r\n\t\t\t\troot.maxZoom = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.MINZOOM_FIELD_NUMBER :\r\n\t\t\t\troot.minZoom = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapRootLevel.ROOT_FIELD_NUMBER :\r\n\t\t\t\tMapTree r = new MapTree();\r\n\t\t\t\t// left, ... already initialized \r\n\t\t\t\tr.length = readInt();\r\n\t\t\t\tr.filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(r.length);\r\n\t\t\t\treadMapTreeBounds(r, root.left, root.right, root.top, root.bottom);\r\n\t\t\t\troot.trees.add(r);\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(r.filePointer + r.length);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tskipUnknownField(t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void init() throws IOException {\r\n\t\twhile(true){\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.OsmAndStructure.VERSION_FIELD_NUMBER :\r\n\t\t\t\tversion = codedIS.readUInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.OsmAndStructure.MAPINDEX_FIELD_NUMBER:\r\n\t\t\t\tint length = readInt();\r\n\t\t\t\tint filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\r\n\t\t\t\treadMapIndex();\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(filePointer + length);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// TODO skip unknown fields\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":98425,"modified_method":"private void init() throws IOException {\r\n\t\twhile(true){\r\n\t\t\tint t = codedIS.readTag();\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.OsmAndStructure.VERSION_FIELD_NUMBER :\r\n\t\t\t\tversion = codedIS.readUInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.OsmAndStructure.MAPINDEX_FIELD_NUMBER:\r\n\t\t\t\tint length = readInt();\r\n\t\t\t\tint filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\r\n\t\t\t\treadMapIndex();\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(filePointer + length);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tskipUnknownField(t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void main(String[] args) throws IOException {\r\n\t\tRandomAccessFile raf = new RandomAccessFile(new File(\"e:\\\\Information\\\\OSM maps\\\\osmand\\\\Minsk.map.pbf\"), \"r\");\r\n\t\tBinaryMapIndexReader reader = new BinaryMapIndexReader(raf);\r\n\t\tSystem.out.println(reader.getVersion());\r\n\t\tint sleft = MapUtils.get31TileNumberX(27.578);\r\n\t\tint sright = MapUtils.get31TileNumberX(27.583);\r\n\t\tint stop = MapUtils.get31TileNumberY(53.916);\r\n\t\tint sbottom = MapUtils.get31TileNumberY(53.9138);\r\n\t\tSystem.out.println(\"SEARCH \" + sleft + \" \" + sright + \" \" + stop + \" \" + sbottom);\r\n\t\tfor(MapRoot b : reader.getMapIndexes()) {\r\n\t\t\tSystem.out.println(b.minZoom + \" \" + b.maxZoom + \" \" +b.trees.size() + \" \" \r\n\t\t\t\t\t+ b.left + \" \" + b.right + \" \" + b.top + \" \" + b.bottom);\r\n\t\t\tfor(BinaryMapDataObject obj : reader.searchMapIndex(b, sleft, sright, stop, sbottom, new ArrayList<BinaryMapDataObject>())){\r\n\t\t\t\tif(obj.getName() != null){\r\n\t\t\t\t\tSystem.out.println(\" \" + obj.getName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":98426,"modified_method":"public static void main(String[] args) throws IOException {\r\n\t\tRandomAccessFile raf = new RandomAccessFile(new File(\"e:\\\\Information\\\\OSM maps\\\\osmand\\\\Minsk.map.pbf\"), \"r\");\r\n\t\tBinaryMapIndexReader reader = new BinaryMapIndexReader(raf);\r\n\t\tSystem.out.println(\"VERSION \" + reader.getVersion());\r\n\t\tint sleft = MapUtils.get31TileNumberX(27.578);\r\n\t\tint sright = MapUtils.get31TileNumberX(27.583);\r\n\t\tint stop = MapUtils.get31TileNumberY(53.916);\r\n\t\tint sbottom = MapUtils.get31TileNumberY(53.9138);\r\n\t\tSystem.out.println(\"SEARCH \" + sleft + \" \" + sright + \" \" + stop + \" \" + sbottom);\r\n\r\n\t\tfor (BinaryMapDataObject obj : reader.searchMapIndex(buildSearchRequest(sleft, sright, stop, sbottom, 18))) {\r\n\t\t\tif (obj.getName() != null) {\r\n\t\t\t\tSystem.out.println(\" \" + obj.getName());\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void searchMapTreeBounds(MapTree tree, int pleft, int pright, int ptop, int pbottom,\r\n\t\t\tint sleft, int sright, int stop, int sbottom,\r\n\t\t\tList<BinaryMapDataObject> searchResults, String indent) throws IOException {\r\n\t\tint init = 0;\r\n\t\tList<BinaryMapDataObject> results = null;\r\n\t\twhile(true){\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\t\tif(init == 0xf){\r\n\t\t\t\tinit = 0;\r\n\t\t\t\t// coordinates are init\r\n\t\t\t\tif(tree.right < sleft || tree.left > sright || tree.top > sbottom || tree.bottom < stop){\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.MapTree.BOTTOM_FIELD_NUMBER :\r\n\t\t\t\ttree.bottom = codedIS.readSInt32() + pbottom;\r\n\t\t\t\tinit |= 1;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.LEFT_FIELD_NUMBER :\r\n\t\t\t\ttree.left = codedIS.readSInt32() + pleft;\r\n\t\t\t\tinit |= 2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.RIGHT_FIELD_NUMBER :\r\n\t\t\t\ttree.right = codedIS.readSInt32() + pright;\r\n\t\t\t\tinit |= 4;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.TOP_FIELD_NUMBER :\r\n\t\t\t\ttree.top = codedIS.readSInt32() + ptop;\r\n\t\t\t\tinit |= 8;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.LEAFS_FIELD_NUMBER :\r\n\t\t\t\tint length = codedIS.readRawVarint32();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\r\n\t\t\t\tBinaryMapDataObject mapObject = readMapDataObject(tree.left, tree.right, tree.top, tree.bottom, sleft, sright, stop, sbottom);\r\n\t\t\t\tif(mapObject != null){\r\n\t\t\t\t\tif(results == null){\r\n\t\t\t\t\t\tresults = new ArrayList<BinaryMapDataObject>();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults.add(mapObject);\r\n\t\t\t\t\tsearchResults.add(mapObject);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.SUBTREES_FIELD_NUMBER :\r\n\t\t\t\tMapTree r = new MapTree();\r\n\t\t\t\t// left, ... already initialized \r\n\t\t\t\tr.length = readInt();\r\n\t\t\t\tr.filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\toldLimit = codedIS.pushLimit(r.length);\r\n\t\t\t\tsearchMapTreeBounds(r, tree.left, tree.right, tree.top, tree.bottom, sleft, sright, stop, sbottom, searchResults, indent+\"  \");\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(r.filePointer + r.length);\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.BASEID_FIELD_NUMBER :\r\n\t\t\t\ttree.baseId = codedIS.readUInt64();\r\n\t\t\t\tif (results != null) {\r\n\t\t\t\t\tfor (BinaryMapDataObject rs : results) {\r\n\t\t\t\t\t\trs.id += tree.baseId;\r\n\t\t\t\t\t\tif (rs.restrictions != null) {\r\n\t\t\t\t\t\t\tfor (int i = 0; i < rs.restrictions.length; i++) {\r\n\t\t\t\t\t\t\t\trs.restrictions[i] += tree.baseId;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.STRINGTABLE_FIELD_NUMBER :\r\n\t\t\t\tlength = codedIS.readRawVarint32();\r\n\t\t\t\toldLimit = codedIS.pushLimit(length);\r\n\t\t\t\ttree.stringTable = readStringTable();\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\t\r\n\t\t\t\tif (results != null) {\r\n\t\t\t\t\tfor (BinaryMapDataObject rs : results) {\r\n\t\t\t\t\t\tif (rs.stringId != -1) {\r\n\t\t\t\t\t\t\trs.name = tree.stringTable.get(rs.stringId);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// TODO skip unknown fields\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":98427,"modified_method":"private void searchMapTreeBounds(MapTree tree, int pleft, int pright, int ptop, int pbottom,\r\n\t\t\tSearchRequest req) throws IOException {\r\n\t\tint init = 0;\r\n\t\tint lastIndexResult = -1;;\r\n\t\twhile(true){\r\n\t\t\tint t = codedIS.readTag();\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\r\n\t\t\tif(init == 0xf){\r\n\t\t\t\tinit = 0;\r\n\t\t\t\t// coordinates are init\r\n\t\t\t\tif(tree.right < req.left || tree.left > req.right || tree.top > req.bottom || tree.bottom < req.top){\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.MapTree.BOTTOM_FIELD_NUMBER :\r\n\t\t\t\ttree.bottom = codedIS.readSInt32() + pbottom;\r\n\t\t\t\tinit |= 1;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.LEFT_FIELD_NUMBER :\r\n\t\t\t\ttree.left = codedIS.readSInt32() + pleft;\r\n\t\t\t\tinit |= 2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.RIGHT_FIELD_NUMBER :\r\n\t\t\t\ttree.right = codedIS.readSInt32() + pright;\r\n\t\t\t\tinit |= 4;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.TOP_FIELD_NUMBER :\r\n\t\t\t\ttree.top = codedIS.readSInt32() + ptop;\r\n\t\t\t\tinit |= 8;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.LEAFS_FIELD_NUMBER :\r\n\t\t\t\tint length = codedIS.readRawVarint32();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\r\n\t\t\t\tif(lastIndexResult == -1){\r\n\t\t\t\t\tlastIndexResult = req.searchResults.size();\r\n\t\t\t\t}\r\n\t\t\t\tBinaryMapDataObject mapObject = readMapDataObject(tree.left, tree.right, tree.top, tree.bottom, req);\r\n\t\t\t\tif(mapObject != null){\r\n\t\t\t\t\treq.searchResults.add(mapObject);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.SUBTREES_FIELD_NUMBER :\r\n\t\t\t\tMapTree r = new MapTree();\r\n\t\t\t\t// left, ... already initialized \r\n\t\t\t\tr.length = readInt();\r\n\t\t\t\tr.filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\toldLimit = codedIS.pushLimit(r.length);\r\n\t\t\t\tsearchMapTreeBounds(r, tree.left, tree.right, tree.top, tree.bottom, req);\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(r.filePointer + r.length);\r\n\t\t\t\tif(lastIndexResult >= 0){\r\n\t\t\t\t\tthrow new IllegalStateException();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.BASEID_FIELD_NUMBER :\r\n\t\t\t\ttree.baseId = codedIS.readUInt64();\r\n\r\n\t\t\t\tif (lastIndexResult != -1) {\r\n\t\t\t\t\tfor (int i = lastIndexResult; i < req.searchResults.size(); i++) {\r\n\t\t\t\t\t\tBinaryMapDataObject rs = req.searchResults.get(i);\r\n\t\t\t\t\t\trs.id += tree.baseId;\r\n\t\t\t\t\t\tif (rs.restrictions != null) {\r\n\t\t\t\t\t\t\tfor (int j = 0; j < rs.restrictions.length; j++) {\r\n\t\t\t\t\t\t\t\trs.restrictions[j] += tree.baseId;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.STRINGTABLE_FIELD_NUMBER :\r\n\t\t\t\tlength = codedIS.readRawVarint32();\r\n\t\t\t\toldLimit = codedIS.pushLimit(length);\r\n\t\t\t\ttree.stringTable = readStringTable();\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\r\n\t\t\t\tif (lastIndexResult != -1) {\r\n\t\t\t\t\tfor (int i = lastIndexResult; i < req.searchResults.size(); i++) {\r\n\t\t\t\t\t\tBinaryMapDataObject rs = req.searchResults.get(i);\r\n\t\t\t\t\t\tif (rs.stringId != -1) {\r\n\t\t\t\t\t\t\trs.name = tree.stringTable.get(rs.stringId);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tskipUnknownField(t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void readMapTreeBounds(MapTree tree, int aleft, int aright, int atop, int abottom) throws IOException {\r\n\t\twhile(true){\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.MapTree.BOTTOM_FIELD_NUMBER :\r\n\t\t\t\ttree.bottom = codedIS.readSInt32() + abottom;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.LEFT_FIELD_NUMBER :\r\n\t\t\t\ttree.left = codedIS.readSInt32() + aleft;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.RIGHT_FIELD_NUMBER :\r\n\t\t\t\ttree.right = codedIS.readSInt32() + aright;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.TOP_FIELD_NUMBER :\r\n\t\t\t\ttree.top = codedIS.readSInt32() + atop;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// TODO skip unknown fields\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":98428,"modified_method":"private void readMapTreeBounds(MapTree tree, int aleft, int aright, int atop, int abottom) throws IOException {\r\n\t\tint init = 0;\r\n\t\twhile(true){\r\n\t\t\tif(init == 0xf){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint t = codedIS.readTag();\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.MapTree.BOTTOM_FIELD_NUMBER :\r\n\t\t\t\ttree.bottom = codedIS.readSInt32() + abottom;\r\n\t\t\t\tinit |= 1;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.LEFT_FIELD_NUMBER :\r\n\t\t\t\ttree.left = codedIS.readSInt32() + aleft;\r\n\t\t\t\tinit |= 2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.RIGHT_FIELD_NUMBER :\r\n\t\t\t\ttree.right = codedIS.readSInt32() + aright;\r\n\t\t\t\tinit |= 4;\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapTree.TOP_FIELD_NUMBER :\r\n\t\t\t\ttree.top = codedIS.readSInt32() + atop;\r\n\t\t\t\tinit |= 8;\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\tdefault:\r\n\t\t\t\tskipUnknownField(t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private BinaryMapDataObject readMapDataObject(int left, int right, int top, int bottom, int sleft, int sright, int stop, int sbottom) throws IOException {\r\n\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\tif(OsmandOdb.MapData.COORDINATES_FIELD_NUMBER != tag) {\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t}\r\n\t\tCACHE.clear();\r\n\t\tint size = codedIS.readRawVarint32();\r\n\t\tint old = codedIS.pushLimit(size);\r\n\t\tint px = left;\r\n\t\tint py = top;\r\n\t\tboolean contains = false;\r\n\t\twhile(codedIS.getBytesUntilLimit() > 0){\r\n\t\t\tint x = codedIS.readSInt32() + px;\r\n\t\t\tint y = codedIS.readSInt32() + py;\r\n\t\t\tCACHE.add(x);\r\n\t\t\tCACHE.add(y);\r\n\t\t\tpx = x;\r\n\t\t\tpy = y;\r\n\t\t\tif(!contains && sleft <= x && sright >= x && stop <= y && sbottom >= y){\r\n\t\t\t\tcontains = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcodedIS.popLimit(old);\r\n\t\tif(!contains){\r\n\t\t\tcodedIS.skipRawBytes(codedIS.getBytesUntilLimit());\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tBinaryMapDataObject dataObject = new BinaryMapDataObject();\r\n\t\tdataObject.coordinates = new int[CACHE.size()];\r\n\t\tfor(int i=0; i<CACHE.size(); i++){\r\n\t\t\tdataObject.coordinates[i] = CACHE.get(i);\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\ttag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn dataObject;\r\n\t\t\tcase OsmandOdb.MapData.TYPES_FIELD_NUMBER :\r\n\t\t\t\tint sizeL = codedIS.readRawVarint32();\r\n\t\t\t\tcodedIS.skipRawBytes(sizeL);\r\n\t\t\t\t// TODO read types\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.RESTRICTIONS_FIELD_NUMBER :\r\n\t\t\t\t// TODO read restrictions \r\n\t\t\t\tsizeL = codedIS.readRawVarint32();\r\n\t\t\t\tcodedIS.skipRawBytes(sizeL);\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.HIGHWAYMETA_FIELD_NUMBER :\r\n\t\t\t\tdataObject.highwayAttributes = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.ID_FIELD_NUMBER :\r\n\t\t\t\tdataObject.id = codedIS.readSInt64();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.STRINGID_FIELD_NUMBER :\r\n\t\t\t\tdataObject.stringId = codedIS.readUInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// TODO skip unknown fields\r\n\t\t\t\treturn dataObject;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}","id":98429,"modified_method":"private BinaryMapDataObject readMapDataObject(int left, int right, int top, int bottom, SearchRequest req) throws IOException {\r\n\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\tif(OsmandOdb.MapData.COORDINATES_FIELD_NUMBER != tag) {\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t}\r\n\t\treq.cacheCoordinates.clear();\r\n\t\tint size = codedIS.readRawVarint32();\r\n\t\tint old = codedIS.pushLimit(size);\r\n\t\tint px = left;\r\n\t\tint py = top;\r\n\t\tboolean contains = false;\r\n\t\twhile(codedIS.getBytesUntilLimit() > 0){\r\n\t\t\tint x = codedIS.readSInt32() + px;\r\n\t\t\tint y = codedIS.readSInt32() + py;\r\n\t\t\treq.cacheCoordinates.add(x);\r\n\t\t\treq.cacheCoordinates.add(y);\r\n\t\t\tpx = x;\r\n\t\t\tpy = y;\r\n\t\t\tif(!contains && req.left <= x && req.right >= x && req.top <= y && req.bottom >= y){\r\n\t\t\t\tcontains = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcodedIS.popLimit(old);\r\n\t\tif(!contains){\r\n\t\t\tcodedIS.skipRawBytes(codedIS.getBytesUntilLimit());\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tBinaryMapDataObject dataObject = new BinaryMapDataObject();\t\t\r\n\t\tdataObject.coordinates = req.cacheCoordinates.toArray();\r\n\t\t\r\n\t\twhile(true){\r\n\t\t\tint t = codedIS.readTag();\r\n\t\t\ttag = WireFormat.getTagFieldNumber(t);\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn dataObject;\r\n\t\t\tcase OsmandOdb.MapData.TYPES_FIELD_NUMBER :\r\n\t\t\t\tint sizeL = codedIS.readRawVarint32();\r\n\t\t\t\tcodedIS.skipRawBytes(sizeL);\r\n\t\t\t\t// TODO read types\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.RESTRICTIONS_FIELD_NUMBER :\r\n\t\t\t\t// TODO read restrictions \r\n\t\t\t\tsizeL = codedIS.readRawVarint32();\r\n\t\t\t\tcodedIS.skipRawBytes(sizeL);\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.HIGHWAYMETA_FIELD_NUMBER :\r\n\t\t\t\tdataObject.highwayAttributes = codedIS.readInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.ID_FIELD_NUMBER :\r\n\t\t\t\tdataObject.id = codedIS.readSInt64();\r\n\t\t\t\tbreak;\r\n\t\t\tcase OsmandOdb.MapData.STRINGID_FIELD_NUMBER :\r\n\t\t\t\tdataObject.stringId = codedIS.readUInt32();\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tskipUnknownField(t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void readMapIndex() throws IOException {\r\n\t\twhile(true){\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(codedIS.readTag());\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.OsmAndMapIndex.LEVELS_FIELD_NUMBER :\r\n\t\t\t\tint length = readInt();\r\n\t\t\t\tint filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\r\n\t\t\t\tMapRoot mapRoot = readMapLevel();\r\n\t\t\t\tmapIndexes.add(mapRoot);\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(filePointer + length);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// TODO skip unknown fields\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":98430,"modified_method":"private void readMapIndex() throws IOException {\r\n\t\twhile(true){\r\n\t\t\tint t = codedIS.readTag();\r\n\t\t\tint tag = WireFormat.getTagFieldNumber(t);\r\n\t\t\tswitch (tag) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn;\r\n\t\t\tcase OsmandOdb.OsmAndMapIndex.LEVELS_FIELD_NUMBER :\r\n\t\t\t\tint length = readInt();\r\n\t\t\t\tint filePointer = codedIS.getTotalBytesRead();\r\n\t\t\t\tint oldLimit = codedIS.pushLimit(length);\r\n\t\t\t\tMapRoot mapRoot = readMapLevel();\r\n\t\t\t\tmapIndexes.add(mapRoot);\r\n\t\t\t\tcodedIS.popLimit(oldLimit);\r\n\t\t\t\tcodedIS.seek(filePointer + length);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tskipUnknownField(t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void startWriteMapIndex() throws IOException{\r\n\t\tassert state.peek() == OSMAND_STRUCTURE_INIT;\r\n\t\tstate.push(MAP_INDEX_INIT);\r\n\t\tcodedOutStream.writeTag(OsmandOdb.OsmAndStructure.MAPINDEX_FIELD_NUMBER, WireFormat.FieldType.MESSAGE.getWireType());\r\n\t\tpreserveInt32Size();\r\n\t}","id":98431,"modified_method":"public void startWriteMapIndex() throws IOException{\r\n\t\tassert state.peek() == OSMAND_STRUCTURE_INIT;\r\n\t\tstate.push(MAP_INDEX_INIT);\r\n\t\tcodedOutStream.writeTag(OsmandOdb.OsmAndStructure.MAPINDEX_FIELD_NUMBER, WireFormat.WIRETYPE_FIXED32_LENGTH_DELIMITED);\r\n\t\tpreserveInt32Size();\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void startMapTreeElement(long baseId, int leftX, int rightX, int topY, int bottomY) throws IOException{\r\n\t\tassert state.peek() == MAP_ROOT_LEVEL_INIT || state.peek() == MAP_TREE;\r\n\t\tif(state.peek() == MAP_ROOT_LEVEL_INIT){\r\n\t\t\tcodedOutStream.writeTag(OsmandOdb.MapRootLevel.ROOT_FIELD_NUMBER, WireFormat.FieldType.MESSAGE.getWireType());\r\n\t\t} else {\r\n\t\t\tcodedOutStream.writeTag(OsmandOdb.MapTree.SUBTREES_FIELD_NUMBER, WireFormat.FieldType.MESSAGE.getWireType());\r\n\t\t}\r\n\t\tpreserveInt32Size();\r\n\t\tstate.push(MAP_TREE);\r\n\t\t\r\n\t\t\r\n\t\tBounds bounds = stackBounds.peek();\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.LEFT_FIELD_NUMBER, leftX - bounds.leftX);\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.RIGHT_FIELD_NUMBER, rightX - bounds.rightX);\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.TOP_FIELD_NUMBER, topY - bounds.topY);\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.BOTTOM_FIELD_NUMBER, bottomY - bounds.bottomY);\r\n\t\tstackBounds.push(new Bounds(leftX, rightX, topY, bottomY));\r\n\t\tstackBaseIds.push(baseId);\r\n\t\tstackStringTable.push(null);\r\n\t}","id":98432,"modified_method":"public void startMapTreeElement(long baseId, int leftX, int rightX, int topY, int bottomY) throws IOException{\r\n\t\tassert state.peek() == MAP_ROOT_LEVEL_INIT || state.peek() == MAP_TREE;\r\n\t\tif(state.peek() == MAP_ROOT_LEVEL_INIT){\r\n\t\t\tcodedOutStream.writeTag(OsmandOdb.MapRootLevel.ROOT_FIELD_NUMBER, WireFormat.WIRETYPE_FIXED32_LENGTH_DELIMITED);\r\n\t\t} else {\r\n\t\t\tcodedOutStream.writeTag(OsmandOdb.MapTree.SUBTREES_FIELD_NUMBER, WireFormat.WIRETYPE_FIXED32_LENGTH_DELIMITED);\r\n\t\t}\r\n\t\tpreserveInt32Size();\r\n\t\tstate.push(MAP_TREE);\r\n\t\t\r\n\t\t\r\n\t\tBounds bounds = stackBounds.peek();\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.LEFT_FIELD_NUMBER, leftX - bounds.leftX);\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.RIGHT_FIELD_NUMBER, rightX - bounds.rightX);\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.TOP_FIELD_NUMBER, topY - bounds.topY);\r\n\t\tcodedOutStream.writeSInt32(OsmandOdb.MapTree.BOTTOM_FIELD_NUMBER, bottomY - bounds.bottomY);\r\n\t\tstackBounds.push(new Bounds(leftX, rightX, topY, bottomY));\r\n\t\tstackBaseIds.push(baseId);\r\n\t\tstackStringTable.push(null);\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void startWriteMapLevelIndex(int minZoom, int maxZoom, int leftX, int rightX, int topY, int bottomY) throws IOException{\r\n\t\tassert state.peek() == MAP_INDEX_INIT;\r\n\t\tstate.push(MAP_ROOT_LEVEL_INIT);\r\n\t\t\r\n\t\tcodedOutStream.writeTag(OsmandOdb.OsmAndMapIndex.LEVELS_FIELD_NUMBER, WireFormat.FieldType.MESSAGE.getWireType());\r\n\t\tpreserveInt32Size();\r\n\t\t\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.MAXZOOM_FIELD_NUMBER, maxZoom);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.MINZOOM_FIELD_NUMBER, minZoom);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.LEFT_FIELD_NUMBER, leftX);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.RIGHT_FIELD_NUMBER, rightX);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.TOP_FIELD_NUMBER, topY);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.BOTTOM_FIELD_NUMBER, bottomY);\r\n\t\t\r\n\t\tstackBounds.push(new Bounds(leftX, rightX, topY, bottomY));\r\n\t}","id":98433,"modified_method":"public void startWriteMapLevelIndex(int minZoom, int maxZoom, int leftX, int rightX, int topY, int bottomY) throws IOException{\r\n\t\tassert state.peek() == MAP_INDEX_INIT;\r\n\t\tstate.push(MAP_ROOT_LEVEL_INIT);\r\n\t\t\r\n\t\tcodedOutStream.writeTag(OsmandOdb.OsmAndMapIndex.LEVELS_FIELD_NUMBER, WireFormat.WIRETYPE_FIXED32_LENGTH_DELIMITED);\r\n\t\tpreserveInt32Size();\r\n\t\t\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.MAXZOOM_FIELD_NUMBER, maxZoom);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.MINZOOM_FIELD_NUMBER, minZoom);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.LEFT_FIELD_NUMBER, leftX);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.RIGHT_FIELD_NUMBER, rightX);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.TOP_FIELD_NUMBER, topY);\r\n\t\tcodedOutStream.writeInt32(OsmandOdb.MapRootLevel.BOTTOM_FIELD_NUMBER, bottomY);\r\n\t\t\r\n\t\tstackBounds.push(new Bounds(leftX, rightX, topY, bottomY));\r\n\t}","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private CodedInputStreamRAF(final RandomAccessFile raf, int bufferSize) {\n\tBUFFER_SIZE = bufferSize;\n    buffer = new byte[BUFFER_SIZE];\n    bufferSize = 0;\n    bufferPos = 0;\n    totalBytesRetired = 0;\n    this.raf = raf;\n  }","id":98434,"modified_method":"private CodedInputStreamRAF(final RandomAccessFile raf, int bufferSize) {\n\tBUFFER_SIZE = bufferSize;\n    buffer = new byte[BUFFER_SIZE];\n    this.bufferSize = 0;\n    bufferPos = 0;\n    totalBytesRetired = 0;\n    this.raf = raf;\n  }","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void seek(long pointer) throws IOException{\n\t  if(pointer - totalBytesRetired >= 0  && pointer - totalBytesRetired < bufferSize){\n\t\t  skipRawBytes((int) (pointer - getTotalBytesRead()));\n\t  } else {\n\t\t  totalBytesRetired = (int) pointer;\n\t\t  raf.seek(pointer);\n\t\t  bufferPos = 0;\n\t\t  bufferSize = 0;\n\t  }\n  }","id":98435,"modified_method":"public void seek(long pointer) throws IOException{\n\t  if(pointer - totalBytesRetired >= 0  && pointer - totalBytesRetired < bufferSize){\n\t\t  skipRawBytes((int) (pointer - getTotalBytesRead()));\n\t  } else {\n\t\t  totalBytesRetired = (int) pointer;\n\t\t  bufferSizeAfterLimit = 0;\n\t\t  raf.seek(pointer);\n\t\t  bufferPos = 0;\n\t\t  bufferSize = 0;\n\t  }\n  }","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/** Given a tag value, determines the wire type (the lower 3 bits). */\n  static int getTagWireType(final int tag) {\n    return tag & TAG_TYPE_MASK;\n  }","id":98436,"modified_method":"/** Given a tag value, determines the wire type (the lower 3 bits). */\n  public static int getTagWireType(final int tag) {\n    return tag & TAG_TYPE_MASK;\n  }","commit_id":"979e5d85a9c0ea9dfd5e89ca0baefbf9b83559df","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Nullable\n  private FileContent doTake() {\n    FileContent result = null;\n\n    while (result == null) {\n      if (ourAllowParallelFileReading) {\n        result = myLoadedContentsQueue.poll();\n        if (result == null) {\n          VirtualFile virtualFileToLoad = myFilesToLoadQueue.poll();\n          if (virtualFileToLoad != null) {\n            FileContent content = new FileContent(virtualFileToLoad);\n            if (isValidFile(virtualFileToLoad)) {\n              try {\n                content.getBytes();\n              }\n              catch (Throwable t) {\n                if (t instanceof IOException || t instanceof InvalidVirtualFileAccessException) {\n                  LOG.info(t);\n                }\n                else {\n                  LOG.error(t);\n                }\n                content.setEmptyContent();\n              }\n            }\n            else {\n              content.setEmptyContent();\n            }\n            return content;\n          }\n\n          // take last content which is loaded by another thread\n          do {\n            try {\n              result = myLoadedContentsQueue.poll(10, TimeUnit.MILLISECONDS);\n              if (result != null) break;\n            }\n            catch (InterruptedException ex) {\n              throw new RuntimeException(ex);\n            }\n          }\n          while (!myContentLoadingThreadTerminated);\n        }\n      }\n      else {\n        try {\n          result = myLoadedContentsQueue.poll(300, TimeUnit.MILLISECONDS);\n        }\n        catch (InterruptedException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n      if (result == null && myContentLoadingThreadTerminated) {\n        return null;\n      }\n    }\n\n    if (result == TOMBSTONE) {\n      try {\n        myLoadedContentsQueue.put(result); // put it back to notify the others\n      }\n      catch (InterruptedException ignore) {\n        // should not happen\n      }\n      return null;\n    }\n\n    synchronized (myProceedWithLoadingLock) {\n      myLoadedBytesInQueue -= result.getLength();\n      if (myLoadedBytesInQueue < MAX_SIZE_OF_BYTES_IN_QUEUE) {\n        myProceedWithLoadingLock\n          .notifyAll(); // we actually ask only content loading thread to proceed, so there should not be much difference with plain notify\n      }\n    }\n\n    return result;\n  }","id":98437,"modified_method":"@Nullable\n  private FileContent doTake() {\n    FileContent result = null;\n\n    while (result == null) {\n      if (ourAllowParallelFileReading) {\n        result = myLoadedContentsQueue.poll();\n        if (result == null) {\n          VirtualFile virtualFileToLoad = myFilesToLoadQueue.poll();\n          if (virtualFileToLoad != null) {\n            FileContent content = new FileContent(virtualFileToLoad);\n            if (isValidFile(virtualFileToLoad)) {\n              try {\n                content.getBytes();\n                return content;\n              }\n              catch (IOException e) {\n                LOG.info(virtualFileToLoad + \": \" + e);\n              }\n              catch (InvalidVirtualFileAccessException e) {\n                LOG.info(virtualFileToLoad + \": \" + e);\n              }\n              catch (Throwable t) {\n                LOG.error(virtualFileToLoad + \": \" + t);\n              }\n            }\n            content.setEmptyContent();\n            return content;\n          }\n\n          // take last content which is loaded by another thread\n          do {\n            try {\n              result = myLoadedContentsQueue.poll(10, TimeUnit.MILLISECONDS);\n              if (result != null) break;\n            }\n            catch (InterruptedException ex) {\n              throw new RuntimeException(ex);\n            }\n          }\n          while (!myContentLoadingThreadTerminated);\n        }\n      }\n      else {\n        try {\n          result = myLoadedContentsQueue.poll(300, TimeUnit.MILLISECONDS);\n        }\n        catch (InterruptedException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n      if (result == null && myContentLoadingThreadTerminated) {\n        return null;\n      }\n    }\n\n    if (result == TOMBSTONE) {\n      try {\n        myLoadedContentsQueue.put(result); // put it back to notify the others\n      }\n      catch (InterruptedException ignore) {\n        // should not happen\n      }\n      return null;\n    }\n\n    synchronized (myProceedWithLoadingLock) {\n      myLoadedBytesInQueue -= result.getLength();\n      if (myLoadedBytesInQueue < MAX_SIZE_OF_BYTES_IN_QUEUE) {\n        myProceedWithLoadingLock\n          .notifyAll(); // we actually ask only content loading thread to proceed, so there should not be much difference with plain notify\n      }\n    }\n\n    return result;\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** @deprecated do not use (leaks file handles), to remove in IDEA 15 */\n  public abstract JarFile getJarFile(@NotNull VirtualFile entryVFile) throws IOException;","id":98438,"modified_method":"/** @deprecated to be removed in IDEA 15 */\n  @SuppressWarnings({\"UnusedDeclaration\", \"deprecation\"})\n  public abstract JarFile getJarFile(@NotNull VirtualFile entryVFile) throws IOException;","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JarFileSystemImpl(@NotNull MessageBus bus) {\n    boolean noCopy = SystemProperties.getBooleanProperty(\"idea.jars.nocopy\", !SystemInfo.isWindows);\n    myNoCopyJarPaths = noCopy ? null : new ConcurrentHashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n\n    // to prevent platform .jar files from copying\n    boolean runningFromDist = new File(PathManager.getLibPath(), \"openapi.jar\").exists();\n    myNoCopyJarDir = !runningFromDist ? null : new File(PathManager.getHomePath());\n\n    bus.connect().subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener.Adapter() {\n      @Override\n      public void after(@NotNull List<? extends VFileEvent> events) {\n        List<VirtualFile> rootsToRefresh = new ArrayList<VirtualFile>();\n\n        for (VFileEvent event : events) {\n          if (event.getFileSystem() instanceof LocalFileSystem) {\n            String path = event.getPath();\n\n            String[] jarPaths;\n            synchronized (LOCK) {\n              jarPaths = myJarPathsCache;\n              if (jarPaths == null) {\n                myJarPathsCache = jarPaths = ArrayUtil.toStringArray(myHandlers.keySet());\n              }\n            }\n\n            for (String jarPath : jarPaths) {\n              final String jarFile = jarPath.substring(0, jarPath.length() - JAR_SEPARATOR.length());\n              if (FileUtil.startsWith(jarFile, path)) {\n                VirtualFile jarRootToRefresh = markDirty(jarPath);\n                if (jarRootToRefresh != null) {\n                  rootsToRefresh.add(jarRootToRefresh);\n                }\n              }\n            }\n          }\n        }\n\n        if (!rootsToRefresh.isEmpty()) {\n          boolean async = !ApplicationManager.getApplication().isUnitTestMode();\n          RefreshQueue.getInstance().refresh(async, true, null, rootsToRefresh);\n        }\n      }\n    });\n  }","id":98439,"modified_method":"public JarFileSystemImpl(@NotNull MessageBus bus) {\n    boolean noCopy = SystemProperties.getBooleanProperty(\"idea.jars.nocopy\", !SystemInfo.isWindows);\n    myNoCopyJarPaths = noCopy ? null : new ConcurrentHashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n\n    // to prevent platform .jar files from copying\n    boolean runningFromDist = new File(PathManager.getLibPath(), \"openapi.jar\").exists();\n    myNoCopyJarDir = !runningFromDist ? null : new File(PathManager.getHomePath());\n\n    bus.connect().subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener.Adapter() {\n      @Override\n      public void after(@NotNull List<? extends VFileEvent> events) {\n        List<VirtualFile> rootsToRefresh = ContainerUtil.newSmartList();\n\n        for (VFileEvent event : events) {\n          if (event.getFileSystem() instanceof LocalFileSystem) {\n            String path = event.getPath();\n\n            String[] jarPaths;\n            synchronized (LOCK) {\n              jarPaths = myJarPathsCache;\n              if (jarPaths == null) {\n                myJarPathsCache = jarPaths = ArrayUtil.toStringArray(myHandlers.keySet());\n              }\n            }\n\n            for (String jarPath : jarPaths) {\n              final String jarFile = jarPath.substring(0, jarPath.length() - JAR_SEPARATOR.length());\n              if (FileUtil.startsWith(jarFile, path)) {\n                VirtualFile jarRootToRefresh = markDirty(jarPath);\n                if (jarRootToRefresh != null) {\n                  rootsToRefresh.add(jarRootToRefresh);\n                }\n              }\n            }\n          }\n        }\n\n        if (!rootsToRefresh.isEmpty()) {\n          List<String> pathsToReset = ContainerUtil.newArrayListWithCapacity(rootsToRefresh.size());\n          for (VirtualFile root : rootsToRefresh) {\n            String rootPath = root.getPath();\n            String jarPath = rootPath.substring(0, rootPath.length() - 2);\n            pathsToReset.add(FileUtil.toSystemDependentName(jarPath));\n          }\n          ZipFileCache.reset(pathsToReset);\n\n          boolean async = !ApplicationManager.getApplication().isUnitTestMode();\n          RefreshQueue.getInstance().refresh(async, true, null, rootsToRefresh);\n        }\n      }\n    });\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public byte[] contentsToByteArray(@NotNull VirtualFile file) throws IOException {\n    JarFile jar = getJar();\n    if (jar != null) {\n      JarFile.JarEntry entry = jar.getEntry(getRelativePath(file));\n      if (entry != null) {\n        InputStream stream = jar.getInputStream(entry);\n        if (stream != null) {\n          try {\n            return FileUtil.loadBytes(stream, (int)entry.getSize());\n          }\n          finally {\n            stream.close();\n          }\n        }\n      }\n    }\n    return ArrayUtil.EMPTY_BYTE_ARRAY;\n  }","id":98440,"modified_method":"@NotNull\n  public byte[] contentsToByteArray(@NotNull VirtualFile file) throws IOException {\n    ZipFile zip = getZipFile();\n    try {\n      ZipEntry entry = zip.getEntry(getRelativePath(file));\n      if (entry != null) {\n        InputStream stream = zip.getInputStream(entry);\n        if (stream != null) {\n          try {\n            return FileUtil.loadBytes(stream, (int)entry.getSize());\n          }\n          finally {\n            stream.close();\n          }\n        }\n      }\n    }\n    finally {\n      ZipFileCache.release(zip);\n    }\n    return ArrayUtil.EMPTY_BYTE_ARRAY;\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected Map<String, EntryInfo> getEntriesMap() {\n    Map<String, EntryInfo> map = SoftReference.dereference(myRelPathsToEntries);\n    if (map == null) {\n      synchronized (myLock) {\n        map = SoftReference.dereference(myRelPathsToEntries);\n\n        if (map == null) {\n          JarFile zip = getJar();\n          if (zip != null) {\n            LogUtil.debug(LOG, \"mapping %s\", myBasePath);\n\n            map = new THashMap<String, EntryInfo>();\n            map.put(\"\", new EntryInfo(null, \"\", true, DEFAULT_LENGTH, DEFAULT_TIMESTAMP));\n\n            Enumeration<? extends JarFile.JarEntry> entries = zip.entries();\n            while (entries.hasMoreElements()) {\n              JarFile.JarEntry entry = entries.nextElement();\n              if (entry == null) break;  // corrupted .jar\n              getOrCreate(entry, map, zip);\n            }\n\n            myRelPathsToEntries = new SoftReference<Map<String, EntryInfo>>(Collections.unmodifiableMap(map));\n          }\n          else {\n            map = Collections.emptyMap();\n          }\n        }\n      }\n    }\n    return map;\n  }","id":98441,"modified_method":"@NotNull\n  protected Map<String, EntryInfo> getEntriesMap() {\n    Map<String, EntryInfo> map = SoftReference.dereference(myRelPathsToEntries);\n    if (map == null) {\n      synchronized (myLock) {\n        map = SoftReference.dereference(myRelPathsToEntries);\n\n        if (map == null) {\n          if (myCorruptedJar) {\n            map = Collections.emptyMap();\n          }\n          else {\n            LogUtil.debug(LOG, \"mapping %s\", myBasePath);\n            map = new THashMap<String, EntryInfo>();\n            map.put(\"\", new EntryInfo(null, \"\", true, DEFAULT_LENGTH, DEFAULT_TIMESTAMP));\n\n            try {\n              ZipFile zip = getZipFile();\n              try {\n                Enumeration<? extends ZipEntry> entries = zip.entries();\n                while (entries.hasMoreElements()) {\n                  getOrCreate(entries.nextElement(), map, zip);\n                }\n              }\n              finally {\n                ZipFileCache.release(zip);\n              }\n            }\n            catch (IOException e) {\n              myCorruptedJar = true;\n              LOG.warn(e.getMessage() + \": \" + myBasePath, e);\n              map = Collections.emptyMap();\n            }\n          }\n\n          myRelPathsToEntries = new SoftReference<Map<String, EntryInfo>>(Collections.unmodifiableMap(map));\n        }\n      }\n    }\n    return map;\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public JarFile getJar() {\n    JarFile jar = myJarFile.get();\n    if (jar == null) {\n      synchronized (myLock) {\n        if (myCorruptedJar) {\n          return null;\n        }\n        jar = myJarFile.get();\n        if (jar == null) {\n          try {\n            jar = createJarFile();\n            myJarFile.set(jar);\n          }\n          catch (IOException e) {\n            myCorruptedJar = true;\n            LOG.warn(e.getMessage() + \": \" + myBasePath, e);\n            return null;\n          }\n        }\n      }\n    }\n    return jar;\n  }","id":98442,"modified_method":"/** @deprecated to be removed in IDEA 15 */\n  @SuppressWarnings(\"deprecation\")\n  public JarFile getJar() {\n    try {\n      File mirror = getMirrorFile(getOriginalFile());\n      return new MyJarFile(new ZipFile(mirror));\n    }\n    catch (IOException e) {\n      LOG.warn(e.getMessage() + \": \" + myBasePath, e);\n      return null;\n    }\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static EntryInfo getOrCreate(String entryName, Map<String, EntryInfo> map, JarFile zip) {\n    EntryInfo info = map.get(entryName);\n\n    if (info == null) {\n      JarFile.JarEntry entry = zip.getEntry(entryName + \"/\");\n      if (entry != null) {\n        return getOrCreate(entry, map, zip);\n      }\n\n      int idx = entryName.lastIndexOf('/');\n      String parentName = idx > 0 ? entryName.substring(0, idx) : \"\";\n      String shortName = idx > 0 ? entryName.substring(idx + 1) : entryName;\n\n      EntryInfo parentInfo = getOrCreate(parentName, map, zip);\n      info = new EntryInfo(parentInfo, shortName, true, DEFAULT_LENGTH, DEFAULT_TIMESTAMP);\n      map.put(entryName, info);\n    }\n\n    if (!info.isDirectory) {\n      //noinspection ConstantConditions\n      LOG.info(zip.getZipFile().getName() + \": \" + entryName + \" should be a directory\");\n      info = new EntryInfo(info.parent, info.shortName, true, info.length, info.timestamp);\n      map.put(entryName, info);\n    }\n\n    return info;\n  }","id":98443,"modified_method":"@NotNull\n  private static EntryInfo getOrCreate(String entryName, Map<String, EntryInfo> map, ZipFile zip) {\n    EntryInfo info = map.get(entryName);\n\n    if (info == null) {\n      ZipEntry entry = zip.getEntry(entryName + \"/\");\n      if (entry != null) {\n        return getOrCreate(entry, map, zip);\n      }\n\n      int idx = entryName.lastIndexOf('/');\n      String parentName = idx > 0 ? entryName.substring(0, idx) : \"\";\n      String shortName = idx > 0 ? entryName.substring(idx + 1) : entryName;\n\n      EntryInfo parentInfo = getOrCreate(parentName, map, zip);\n      info = new EntryInfo(parentInfo, shortName, true, DEFAULT_LENGTH, DEFAULT_TIMESTAMP);\n      map.put(entryName, info);\n    }\n\n    if (!info.isDirectory) {\n      LOG.info(zip.getName() + \": \" + entryName + \" should be a directory\");\n      info = new EntryInfo(info.parent, info.shortName, true, info.length, info.timestamp);\n      map.put(entryName, info);\n    }\n\n    return info;\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean exists(@NotNull VirtualFile file) {\n    if (file.getParent() == null) {\n      return myJarFile.get() != null || getOriginalFile().exists();\n    }\n\n    return getEntryInfo(file) != null;\n  }","id":98444,"modified_method":"public boolean exists(@NotNull VirtualFile file) {\n    if (file.getParent() == null) return getOriginalFile().exists();\n    EntryInfo info = getEntryInfo(file);\n    return info != null;\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static EntryInfo getOrCreate(JarFile.JarEntry entry, Map<String, EntryInfo> map, JarFile zip) {\n    boolean isDirectory = entry.isDirectory();\n    String entryName = entry.getName();\n    if (StringUtil.endsWithChar(entryName, '/')) {\n      entryName = entryName.substring(0, entryName.length() - 1);\n      isDirectory = true;\n    }\n\n    EntryInfo info = map.get(entryName);\n    if (info != null) return info;\n\n    int idx = entryName.lastIndexOf('/');\n    String parentName = idx > 0 ? entryName.substring(0, idx) : \"\";\n    String shortName = idx > 0 ? entryName.substring(idx + 1) : entryName;\n\n    EntryInfo parentInfo = getOrCreate(parentName, map, zip);\n\n    if (\".\".equals(shortName)) {\n      return parentInfo;\n    }\n\n    info = new EntryInfo(parentInfo, shortName, isDirectory, entry.getSize(), entry.getTime());\n    map.put(entryName, info);\n    return info;\n  }","id":98445,"modified_method":"@NotNull\n  private static EntryInfo getOrCreate(ZipEntry entry, Map<String, EntryInfo> map, ZipFile zip) {\n    boolean isDirectory = entry.isDirectory();\n    String entryName = entry.getName();\n    if (StringUtil.endsWithChar(entryName, '/')) {\n      entryName = entryName.substring(0, entryName.length() - 1);\n      isDirectory = true;\n    }\n\n    EntryInfo info = map.get(entryName);\n    if (info != null) return info;\n\n    int idx = entryName.lastIndexOf('/');\n    String parentName = idx > 0 ? entryName.substring(0, idx) : \"\";\n    String shortName = idx > 0 ? entryName.substring(idx + 1) : entryName;\n\n    EntryInfo parentInfo = getOrCreate(parentName, map, zip);\n\n    if (\".\".equals(shortName)) {\n      return parentInfo;\n    }\n\n    info = new EntryInfo(parentInfo, shortName, isDirectory, entry.getSize(), entry.getTime());\n    map.put(entryName, info);\n    return info;\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void releaseZipFile(final ZipFile zipFile) throws IOException {\n    if (myCanLockJar) {\n      myZipFileRef.release();\n    }\n    else if (zipFile != null) {\n      zipFile.close();\n    }\n  }","id":98446,"modified_method":"private void releaseZipFile(ZipFile zipFile) throws IOException {\n    if (myCanLockJar) {\n      ZipFileCache.release(zipFile);\n    }\n    else if (zipFile != null) {\n      zipFile.close();\n    }\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ZipFile acquireZipFile() throws IOException {\n    if (myCanLockJar) {\n      return myZipFileRef.acquire();\n    }\n    return doGetZipFile();\n  }","id":98447,"modified_method":"private ZipFile acquireZipFile() throws IOException {\n    String path = FileUtil.unquote(myURL.getFile());\n    //noinspection IOResourceOpenedButNotSafelyClosed\n    return myCanLockJar ? ZipFileCache.acquire(path) : new ZipFile(path);\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  Resource getResource(String name, boolean flag) {\n    JarMemoryLoader loader = com.intellij.reference.SoftReference.dereference(myMemoryLoader);\n    if (loader != null) {\n      Resource resource = loader.getResource(name);\n      if (resource != null) return resource;\n    }\n\n    ZipFile file = null;\n    try {\n      file = acquireZipFile();\n      if (file == null) return null;\n      ZipEntry entry = file.getEntry(name);\n      if (entry != null) {\n        return new MyResource(entry, new URL(getBaseURL(), name));\n      }\n    }\n    catch (Exception e) {\n      return null;\n    }\n    finally {\n      try {\n        releaseZipFile(file);\n      }\n      catch (IOException ignored) { }\n    }\n\n    return null;\n  }","id":98448,"modified_method":"@Override\n  @Nullable\n  Resource getResource(String name, boolean flag) {\n    JarMemoryLoader loader = com.intellij.reference.SoftReference.dereference(myMemoryLoader);\n    if (loader != null) {\n      Resource resource = loader.getResource(name);\n      if (resource != null) return resource;\n    }\n\n    try {\n      ZipFile file = acquireZipFile();\n      try {\n        ZipEntry entry = file.getEntry(name);\n        if (entry != null) {\n          return MemoryResource.load(getBaseURL(), file, entry);\n        }\n      }\n      finally {\n        releaseZipFile(file);\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n\n    return null;\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void buildCache(final ClasspathCache cache) throws IOException {\n    ZipFile zipFile = null;\n    try {\n      zipFile = acquireZipFile();\n      if (zipFile == null) return;\n\n      final Enumeration<? extends ZipEntry> entries = zipFile.entries();\n      while (entries.hasMoreElements()) {\n        ZipEntry zipEntry = entries.nextElement();\n        String name = zipEntry.getName();\n        cache.addResourceEntry(name, this);\n        cache.addNameEntry(name, this);\n      }\n    }\n    finally {\n      releaseZipFile(zipFile);\n    }\n  }","id":98449,"modified_method":"@Override\n  void buildCache(ClasspathCache cache) throws IOException {\n    ZipFile zipFile = acquireZipFile();\n    try {\n      Enumeration<? extends ZipEntry> entries = zipFile.entries();\n      while (entries.hasMoreElements()) {\n        ZipEntry zipEntry = entries.nextElement();\n        String name = zipEntry.getName();\n        cache.addResourceEntry(name, this);\n        cache.addNameEntry(name, this);\n      }\n    }\n    finally {\n      releaseZipFile(zipFile);\n    }\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void preloadClasses() {\n    ZipFile zipFile = null;\n    try {\n      zipFile = acquireZipFile();\n      if (zipFile == null) return;\n      try {\n        File file = new File(zipFile.getName());\n        myMemoryLoader = new SoftReference<JarMemoryLoader>(JarMemoryLoader.load(file, getBaseURL()));\n      }\n      catch (Exception e) {\n        LOG.error(e);\n      }\n    }\n    catch (Exception e) {\n      // it happens :) eg tools.jar under MacOS\n    }\n    finally {\n      try {\n        releaseZipFile(zipFile);\n      }\n      catch (IOException ignore) {\n\n      }\n    }\n  }","id":98450,"modified_method":"void preloadClasses() {\n    try {\n      ZipFile zipFile = acquireZipFile();\n      try {\n        JarMemoryLoader loader = JarMemoryLoader.load(zipFile, getBaseURL());\n        if (loader != null) {\n          myMemoryLoader = new SoftReference<JarMemoryLoader>(loader);\n        }\n      }\n      finally {\n        releaseZipFile(zipFile);\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static JarMemoryLoader load(File file, URL baseUrl) throws IOException {\n    FileInputStream inputStream = new FileInputStream(file);\n    try {\n      return load(inputStream, baseUrl);\n    }\n    finally {\n      inputStream.close();\n    }\n  }","id":98451,"modified_method":"@Nullable\n  public static JarMemoryLoader load(File file, URL baseUrl) throws IOException {\n    ZipFile zipFile = new ZipFile(file);\n    try {\n      return load(zipFile, baseUrl);\n    }\n    finally {\n      zipFile.close();\n    }\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** @deprecated use {@link JarUtil#getJarAttribute(File, Attributes.Name)} (to remove in IDEA 15) */\n  @SuppressWarnings(\"UnusedDeclaration\")\n  public static String detectJarVersion(@Nullable com.intellij.openapi.vfs.JarFile zipFile) {\n    if (zipFile == null) {\n      return null;\n    }\n    try {\n      final com.intellij.openapi.vfs.JarFile.JarEntry zipEntry = zipFile.getEntry(JarFile.MANIFEST_NAME);\n      if (zipEntry == null) {\n        return null;\n      }\n      final InputStream inputStream = zipFile.getInputStream(zipEntry);\n      final Manifest manifest = new Manifest(inputStream);\n      final Attributes attributes = manifest.getMainAttributes();\n      return attributes.getValue(Attributes.Name.IMPLEMENTATION_VERSION);\n    }\n    catch (IOException e) {\n      return null;\n    }\n  }","id":98452,"modified_method":"/** @deprecated use {@link JarUtil#getJarAttribute(File, Attributes.Name)} (to remove in IDEA 15) */\n  @SuppressWarnings({\"UnusedDeclaration\", \"deprecation\"})\n  public static String detectJarVersion(@Nullable com.intellij.openapi.vfs.JarFile zipFile) {\n    if (zipFile == null) {\n      return null;\n    }\n    try {\n      final com.intellij.openapi.vfs.JarFile.JarEntry zipEntry = zipFile.getEntry(JarFile.MANIFEST_NAME);\n      if (zipEntry == null) {\n        return null;\n      }\n      final InputStream inputStream = zipFile.getInputStream(zipEntry);\n      final Manifest manifest = new Manifest(inputStream);\n      final Attributes attributes = manifest.getMainAttributes();\n      return attributes.getValue(Attributes.Name.IMPLEMENTATION_VERSION);\n    }\n    catch (IOException e) {\n      return null;\n    }\n  }","commit_id":"0b888e543c0ae75362a5c2b5d48542d70222fca2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method) {\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tCFG cfg;\n\t\ttry {\n\t\t\tcfg = classContext.getCFG(method);\n\t\t} catch (CFGBuilderException e1) {\n\t\t\tAnalysisContext.logError(\"Coult not get CFG\", e1);\n\t\t\treturn;\n\t\t}\n\t\tTypeDataflow typeDataflow;\n\t\ttry {\n\t\t\ttypeDataflow = classContext.getTypeDataflow(method);\n\t\t} catch (CheckedAnalysisException e1) {\n\t\t\tAnalysisContext.logError(\"Coult not get Type dataflow\", e1);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (ins.getOpcode() == Constants.INVOKEVIRTUAL) {\n\t\t\t\tINVOKEVIRTUAL iv = (INVOKEVIRTUAL) ins;\n\n\t\t\t\tString methodName = iv.getMethodName(cpg);\n\t\t\t\tString methodSig = iv.getSignature(cpg);\n\t\t\t\tif (methodName.equals(\"wait\")\n\t\t\t\t        && (methodSig.equals(\"()V\") || methodSig.equals(\"(J)V\") || methodSig.equals(\"(JI)V\"))\n\t\t\t\t        || (methodName.equals(\"notify\") || methodName.equals(\"notifyAll\")) && methodSig.equals(\"()V\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\t\tif (!frame.isValid())\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tType type = frame.getInstance(ins, cpg);\n\t\t\t\t\t\tif (!(type instanceof ReferenceType)) {\n\t\t\t\t\t\t\t// Something is deeply wrong if a non-reference type\n\t\t\t\t\t\t\t// is used for a method invocation. But, that's\n\t\t\t\t\t\t\t// really a\n\t\t\t\t\t\t\t// verification problem.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tClassDescriptor classDescriptor = DescriptorFactory.createClassDescriptorFromSignature(type.getSignature());\n\t\t\t\t\t\tif (classDescriptor.equals(classContext.getClassDescriptor()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!classDescriptor.getClassName().startsWith(\"java/util/concurrent\"))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tXClass c = Lookup.getXClass(classDescriptor);\n\t\t\t\t\t\tXMethod m = c.findMethod(\"await\", \"()V\", false);\n\t\t\t\t\t\tif (m != null && m.isPublic() && c.isPublic())\n\t\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"TESTING\", NORMAL_PRIORITY).addClassAndMethod(\n\t\t\t\t\t\t\t        classContext.getJavaClass(), method)\n\t\t\t\t\t\t\t        .addString(\"Calling wait or notify on a util.concurrent object that supports await\")\n\t\t\t\t\t\t\t        .addCalledMethod(cpg, iv)\n\t\t\t\t\t\t\t        .addType(classDescriptor).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t        .addSourceLine(classContext, method, location));\n\n\t\t\t\t\t} catch (CheckedAnalysisException e) {\n\t\t\t\t\t\tAnalysisContext.logError(\"Coult not get Type dataflow\", e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (ins.getOpcode() != Constants.MONITORENTER)\n\t\t\t\tcontinue;\n\t\t\tType type;\n\t\t\ttry {\n\t\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\t\t\t\ttype = frame.getInstance(ins, cpg);\n\t\t\t} catch (CheckedAnalysisException e) {\n\t\t\t\tAnalysisContext.logError(\"Coult not get Type dataflow\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(type instanceof ReferenceType)) {\n\t\t\t\t// Something is deeply wrong if a non-reference type\n\t\t\t\t// is used for a monitorenter. But, that's really a\n\t\t\t\t// verification problem.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean isSubtype = false;\n\t\t\ttry {\n\t\t\t\tisSubtype = Hierarchy.isSubtype((ReferenceType) type, LOCK_TYPE);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t\tString sig = type.getSignature();\n\t\t\tboolean isUtilConcurrentSig = sig.startsWith(UTIL_CONCURRRENT_SIG_PREFIX);\n\n\t\t\tif (isSubtype) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"JLM_JSR166_LOCK_MONITORENTER\", isUtilConcurrentSig ? HIGH_PRIORITY\n\t\t\t\t        : NORMAL_PRIORITY).addClassAndMethod(classContext.getJavaClass(), method).addType(sig)\n\t\t\t\t        .addSourceForTopStackValue(classContext, method, location).addSourceLine(classContext, method, location));\n\t\t\t} else if (isUtilConcurrentSig) {\n\t\t\t\t\n\t\t\t\tint priority = \"Ljava/util/concurrent/CopyOnWriteArrayList;\".equals(sig) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\", priority)\n\t\t\t\t        .addClassAndMethod(classContext.getJavaClass(), method).addType(sig).addSourceForTopStackValue(\n\t\t\t\t                classContext, method, location).addSourceLine(classContext, method, location));\n\n\t\t\t}\n\t\t}\n\t}","id":98453,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method) {\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tCFG cfg;\n\t\ttry {\n\t\t\tcfg = classContext.getCFG(method);\n\t\t} catch (CFGBuilderException e1) {\n\t\t\tAnalysisContext.logError(\"Coult not get CFG\", e1);\n\t\t\treturn;\n\t\t}\n\t\tTypeDataflow typeDataflow;\n\t\ttry {\n\t\t\ttypeDataflow = classContext.getTypeDataflow(method);\n\t\t} catch (CheckedAnalysisException e1) {\n\t\t\tAnalysisContext.logError(\"Coult not get Type dataflow\", e1);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (ins.getOpcode() == Constants.INVOKEVIRTUAL) {\n\t\t\t\tINVOKEVIRTUAL iv = (INVOKEVIRTUAL) ins;\n\n\t\t\t\tString methodName = iv.getMethodName(cpg);\n\t\t\t\tString methodSig = iv.getSignature(cpg);\n\t\t\t\tif (methodName.equals(\"wait\")\n\t\t\t\t        && (methodSig.equals(\"()V\") || methodSig.equals(\"(J)V\") || methodSig.equals(\"(JI)V\"))\n\t\t\t\t        || (methodName.equals(\"notify\") || methodName.equals(\"notifyAll\")) && methodSig.equals(\"()V\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\t\tif (!frame.isValid())\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tType type = frame.getInstance(ins, cpg);\n\t\t\t\t\t\tif (!(type instanceof ReferenceType)) {\n\t\t\t\t\t\t\t// Something is deeply wrong if a non-reference type\n\t\t\t\t\t\t\t// is used for a method invocation. But, that's\n\t\t\t\t\t\t\t// really a\n\t\t\t\t\t\t\t// verification problem.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tClassDescriptor classDescriptor = DescriptorFactory.createClassDescriptorFromSignature(type.getSignature());\n\t\t\t\t\t\tif (classDescriptor.equals(classContext.getClassDescriptor()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!classDescriptor.getClassName().startsWith(\"java/util/concurrent\"))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tXClass c = Lookup.getXClass(classDescriptor);\n\t\t\t\t\t\tXMethod m;\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\t\tif (methodName.equals(\"wait\")) {\n\t\t\t\t\t\t\tm = c.findMethod(\"await\", \"()V\", false);\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\t} else if (methodName.equals(\"notify\")) {\n\t\t\t\t\t\t\t\tm = c.findMethod(\"signal\", \"()V\", false);\n\t\t\t\t\t\t\t\tif (m == null)\n\t\t\t\t\t\t\t\t\tm =  c.findMethod(\"countDown\", \"()V\", false);\n\t\t\t\t\t\t} else if (methodName.equals(\"notifyAll\")) {\n\t\t\t\t\t\t\t\tm = c.findMethod(\"signalAll\", \"()V\", false);\n\t\t\t\t\t\t\t\tif (m == null)\n\t\t\t\t\t\t\t\t\tm =  c.findMethod(\"countDown\", \"()V\", false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Unexpected methodName: \" + methodName);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (m != null && m.isPublic() && c.isPublic())\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT\", priority).addClassAndMethod(\n\t\t\t\t\t\t\t        classContext.getJavaClass(), method)\n\t\t\t\t\t\t\t        .addCalledMethod(cpg, iv)\n\t\t\t\t\t\t\t        .addMethod(m).describe(MethodAnnotation.METHOD_ALTERNATIVE_TARGET)\n\t\t\t\t\t\t\t        .addType(classDescriptor).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t        .addSourceLine(classContext, method, location));\n\n\t\t\t\t\t} catch (CheckedAnalysisException e) {\n\t\t\t\t\t\tAnalysisContext.logError(\"Coult not get Type dataflow\", e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (ins.getOpcode() != Constants.MONITORENTER)\n\t\t\t\tcontinue;\n\t\t\tType type;\n\t\t\ttry {\n\t\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\t\t\t\ttype = frame.getInstance(ins, cpg);\n\t\t\t} catch (CheckedAnalysisException e) {\n\t\t\t\tAnalysisContext.logError(\"Coult not get Type dataflow\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(type instanceof ReferenceType)) {\n\t\t\t\t// Something is deeply wrong if a non-reference type\n\t\t\t\t// is used for a monitorenter. But, that's really a\n\t\t\t\t// verification problem.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean isSubtype = false;\n\t\t\ttry {\n\t\t\t\tisSubtype = Hierarchy.isSubtype((ReferenceType) type, LOCK_TYPE);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t\tString sig = type.getSignature();\n\t\t\tboolean isUtilConcurrentSig = sig.startsWith(UTIL_CONCURRRENT_SIG_PREFIX);\n\n\t\t\tif (isSubtype) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"JLM_JSR166_LOCK_MONITORENTER\", isUtilConcurrentSig ? HIGH_PRIORITY\n\t\t\t\t        : NORMAL_PRIORITY).addClassAndMethod(classContext.getJavaClass(), method).addType(sig)\n\t\t\t\t        .addSourceForTopStackValue(classContext, method, location).addSourceLine(classContext, method, location));\n\t\t\t} else if (isUtilConcurrentSig) {\n\t\t\t\t\n\t\t\t\tint priority = \"Ljava/util/concurrent/CopyOnWriteArrayList;\".equals(sig) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\", priority)\n\t\t\t\t        .addClassAndMethod(classContext.getJavaClass(), method).addType(sig).addSourceForTopStackValue(\n\t\t\t\t                classContext, method, location).addSourceLine(classContext, method, location));\n\n\t\t\t}\n\t\t}\n\t}","commit_id":"2b640f0f6918c5574501bb03c3b1038c6a7df0f8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void sawOpcode(int seen) {\n        \n        if (isMethodCall()) {\n            MethodDescriptor called = getMethodDescriptorOperand();\n\n            if (previousMethodCall != null && !stack.isJumpTarget(getPC())) {\n                if (called.getName().equals(\"toString\")\n                        && called.getClassDescriptor().getClassName().equals(\"java/lang/Integer\")\n                        && (previousMethodCall.getName().equals(\"<init>\")\n                        && previousMethodCall.getSignature().equals(\"(I)V\") ||\n                         previousMethodCall.getName().equals(\"valueOf\")\n                        && previousMethodCall.getSignature().equals(\"(I)Ljava/lang/Integer;\"))\n                        \n                        \n                        ) {\n                    BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this) .addString(\"new Integer(myInt).toString() => to be replaced by Integer.toString(myInt)\");\n                    accumulator.accumulateBug(bug, this);\n\n                }  else   if (called.getName().equals(\"intValue\")\n                        && called.getClassDescriptor().getClassName().equals(\"java/lang/Integer\")\n                        && previousMethodCall.getName().equals(\"<init>\")\n                        && previousMethodCall.getSignature().equals(\"(Ljava/lang/String;)V\")) {\n                    BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addString(\"new Integer(myString).intValue() => to be replaced by Integer.parseString(myString)\");\n                    accumulator.accumulateBug(bug, this);\n                }\n            }\n            previousMethodCall = called;\n        } else\n            previousMethodCall = null;\n        \n\n        if (seen == LDC || seen == LDC_W || seen == LDC2_W) {\n            Constant c = getConstantRefOperand();\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT)) {\n                BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                        .addString(\"Did you mean MICROS_PER_DAY\").addInt(MICROS_PER_DAY_OVERFLOWED_AS_INT)\n                        .describe(IntAnnotation.INT_VALUE);\n                accumulator.accumulateBug(bug, this);\n            }\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == Integer.MIN_VALUE\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == Long.MIN_VALUE)) {\n                sawLoadOfMinValue = true;\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n                absoluteValueAccumulator.clearBugs();\n            }\n        }\n\n\n        if (seen == LCMP) {\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            checkForCompatibleLongComparison(left, right);\n            checkForCompatibleLongComparison(right, left);\n        }\n\n        if (stack.getStackDepth() >= 2)\n            switch (seen) {\n            case IF_ICMPEQ:\n            case IF_ICMPNE:\n            case IF_ICMPLE:\n            case IF_ICMPGE:\n            case IF_ICMPLT:\n            case IF_ICMPGT:\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item0.getConstant() instanceof Integer) {\n                    OpcodeStack.Item tmp = item0;\n                    item0 = item1;\n                    item1 = tmp;\n                }\n                Object constant1 = item1.getConstant();\n                XMethod returnValueOf = item0.getReturnValueOf();\n                if (constant1 instanceof Integer\n                        && returnValueOf != null\n                        && returnValueOf.getName().equals(\"getYear\")\n                        && (returnValueOf.getClassName().equals(\"java.util.Date\") || returnValueOf.getClassName().equals(\n                                \"java.sql.Date\"))) {\n                    int year = (Integer) constant1;\n                    if (year > 1900)\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                                        .addString(\"Comparison of getYear does understand that it returns year-1900\")\n                                        .addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addInt(year)\n                                        .describe(IntAnnotation.INT_VALUE), this);\n                }\n            }\n\n        // System.out.printf(\"%4d %10s: %s\\n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n        if (seen == IFLT && stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n            sawCheckForNonNegativeSignedByte = getPC();\n        }\n\n        if (pendingAbsoluteValueBug != null) {\n            if (opcodesSincePendingAbsoluteValueBug == 0) {\n                opcodesSincePendingAbsoluteValueBug++;\n            } else {\n                if (seen == IREM) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    Object constantValue = top.getConstant();\n                    if (constantValue instanceof Number && Util.isPowerOfTwo(((Number) constantValue).intValue())) {\n                        pendingAbsoluteValueBug.setPriority(Priorities.LOW_PRIORITY);\n                    }\n                }\n                if (false)\n                    try {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen] + \":\"\n                                + OPCODE_NAMES[getNextOpcode()]);\n                    } catch (Exception e) {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen]);\n\n                    }\n                absoluteValueAccumulator.accumulateBug(pendingAbsoluteValueBug, pendingAbsoluteValueBugSourceLine);\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n            }\n        }\n\n        if (seen == INVOKESTATIC\n                && getClassConstantOperand().equals(\"org/easymock/EasyMock\")\n                && (getNameConstantOperand().equals(\"replay\") || getNameConstantOperand().equals(\"verify\") || getNameConstantOperand()\n                        .startsWith(\"reset\")) && getSigConstantOperand().equals(\"([Ljava/lang/Object;)V\")\n                && getPrevOpcode(1) == ANEWARRAY && getPrevOpcode(2) == ICONST_0)\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD\", NORMAL_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        \n        if (seen == INVOKESTATIC && (getClassConstantOperand().equals(\"com/google/common/base/Preconditions\")\n             && getNameConstantOperand().equals(\"checkNotNull\")\n             || getClassConstantOperand().equals(\"com/google/common/base/Strings\")\n             && (getNameConstantOperand().equals(\"nullToEmpty\") ||\n                     getNameConstantOperand().equals(\"emptyToNull\") ||\n                     getNameConstantOperand().equals(\"isNullOrEmpty\")))\n             ) {\n            int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n\n            OpcodeStack.Item item = stack.getStackItem(args - 1);\n            Object o = item.getConstant();\n            if (o instanceof String) {\n\n                OpcodeStack.Item secondArgument = null;\n                String bugPattern = \"DMI_DOH\";\n                if (args > 1) {\n                    secondArgument = stack.getStackItem(args - 2);\n                    Object secondConstant = secondArgument.getConstant();\n                    if (!(secondConstant instanceof String)) {\n                        bugPattern = \"DMI_ARGUMENTS_WRONG_ORDER\";\n                    }\n                }\n\n                BugInstance bug = new BugInstance(this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this)\n                        .addString(\"Passing String constant as value that should be null checked\").describe(StringAnnotation.STRING_MESSAGE)\n                        .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);\n                if (secondArgument != null)\n                        bug.addValueSource(secondArgument, this);\n\n                accumulator.accumulateBug(bug, this);\n            }\n        }\n\n        if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"junit/framework/Assert\")\n                && getNameConstantOperand().equals(\"assertNotNull\")) {\n               int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n\n               OpcodeStack.Item item = stack.getStackItem(0);\n               Object o = item.getConstant();\n               if (o instanceof String) {\n\n                   OpcodeStack.Item secondArgument = null;\n                   String bugPattern = \"DMI_DOH\";\n                   if (args == 2) {\n                       secondArgument = stack.getStackItem(1);\n                       Object secondConstant = secondArgument.getConstant();\n                       if (!(secondConstant instanceof String)) {\n                           bugPattern = \"DMI_ARGUMENTS_WRONG_ORDER\";\n                       }\n                   }\n\n                   BugInstance bug = new BugInstance(this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(this)\n                           .addCalledMethod(this).addString(\"Passing String constant as value that should be null checked\").describe(StringAnnotation.STRING_MESSAGE)\n                           .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);\n                   if (secondArgument != null)\n                           bug.addValueSource(secondArgument, this);\n\n                   accumulator.accumulateBug(bug, this);\n               }\n           }\n        if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE)\n                && getSigConstantOperand().indexOf(\"Ljava/lang/Runnable;\") >= 0) {\n            SignatureParser parser = new SignatureParser(getSigConstantOperand());\n            int count = 0;\n            for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext(); count++) {\n                String parameter = i.next();\n                if (parameter.equals(\"Ljava/lang/Runnable;\")) {\n                    OpcodeStack.Item item = stack.getStackItem(parser.getNumParameters() - 1 - count);\n                    if (\"Ljava/lang/Thread;\".equals(item.getSignature())) {\n                        accumulator.accumulateBug(new BugInstance(this, \"DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED\",\n                                NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this), this);\n                    }\n\n                }\n            }\n\n        }\n\n        if (prevOpcode == I2L && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/Double\")\n                && getNameConstantOperand().equals(\"longBitsToDouble\")) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT\", HIGH_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && (freshRandomOnTos || freshRandomOneBelowTos)) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_RANDOM_USED_ONLY_ONCE\", HIGH_PRIORITY).addClassAndMethod(this)\n                    .addCalledMethod(this), this);\n\n        }\n\n        freshRandomOneBelowTos = freshRandomOnTos && isRegisterLoad();\n        freshRandomOnTos = seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && getNameConstantOperand().equals(\"<init>\");\n\n        if ((seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashMap\") && getNameConstantOperand().equals(\n                \"get\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Map\") && getNameConstantOperand()\n                        .equals(\"get\"))\n                || (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashSet\") && getNameConstantOperand()\n                        .equals(\"contains\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Set\") && getNameConstantOperand()\n                        .equals(\"contains\"))) {\n            OpcodeStack.Item top = stack.getStackItem(0);\n            if (top.getSignature().equals(\"Ljava/net/URL;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_COLLECTION_OF_URLS\", HIGH_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n        }\n\n        /**\n         * Since you can change the number of core threads for a scheduled\n         * thread pool executor, disabling this for now\n         */\n        if (false && seen == INVOKESPECIAL\n                && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"<init>\")) {\n\n            int arguments = getNumberArguments(getSigConstantOperand());\n            OpcodeStack.Item item = stack.getStackItem(arguments - 1);\n            Object value = item.getConstant();\n            if (value instanceof Integer && ((Integer) value).intValue() == 0)\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS\",\n                        HIGH_PRIORITY).addClassAndMethod(this), this);\n\n        }\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"setMaximumPoolSize\")) {\n            accumulator.accumulateBug(new BugInstance(this,\n                    \"DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR\", HIGH_PRIORITY)\n                    .addClassAndMethod(this), this);\n        }\n        if (isEqualsObject && !reportedBadCastInEquals) {\n            if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"isInstance\")\n                    && getClassConstantOperand().equals(\"java/lang/Class\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INSTANCEOF || seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"getClass\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INVOKESPECIAL && getNameConstantOperand().equals(\"equals\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item1.getRegisterNumber() + item0.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == CHECKCAST && !sawInstanceofCheck) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    if (getSizeOfSurroundingTryBlock(getPC()) == Integer.MAX_VALUE) {\n                        accumulator.accumulateBug(new BugInstance(this, \"BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS\",\n                                NORMAL_PRIORITY).addClassAndMethod(this), this);\n                    }\n\n                    reportedBadCastInEquals = true;\n                }\n            }\n        }\n        {\n            boolean foundVacuousComparison = false;\n            if (seen == IF_ICMPGT || seen == IF_ICMPLE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (seen == IF_ICMPLT || seen == IF_ICMPGE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (foundVacuousComparison) {\n                accumulator.accumulateBug(new BugInstance(this, \"INT_VACUOUS_COMPARISON\", getBranchOffset() < 0 ? HIGH_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), this);\n            }\n\n        }\n\n        if (!sawLoadOfMinValue && seen == INVOKESTATIC &&\n                ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"abs\")\n                ) {\n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            int special = item0.getSpecialKind();\n            if (special == OpcodeStack.Item.RANDOM_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_RANDOM_INT\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n            else if (special == OpcodeStack.Item.HASHCODE_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_HASHCODE\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n        }\n\n        try {\n            int stackLoc = stackEntryThatMustBeNonnegative(seen);\n            if (stackLoc >= 0) {\n                OpcodeStack.Item tos = stack.getStackItem(stackLoc);\n                switch (tos.getSpecialKind()) {\n                case OpcodeStack.Item.HASHCODE_INT_REMAINDER:\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_REM_OF_HASHCODE\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n\n                    break;\n                case OpcodeStack.Item.RANDOM_INT:\n                case OpcodeStack.Item.RANDOM_INT_REMAINDER:\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"RV_REM_OF_RANDOM_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n\n                    break;\n                }\n\n            }\n            if (seen == IREM) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                Object constant0 = item0.getConstant();\n                if (constant0 instanceof Integer && ((Integer) constant0).intValue() == 1) {\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_REM_BY_1\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n\n            if (stack.getStackDepth() >= 1 && (seen == LOOKUPSWITCH || seen == TABLESWITCH)) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n                    int[] switchLabels = getSwitchLabels();\n                    int[] switchOffsets = getSwitchOffsets();\n                    for (int i = 0; i < switchLabels.length; i++) {\n                        int v = switchLabels[i];\n                        if (v <= -129 || v >= 128) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", HIGH_PRIORITY)\n                                    .addClassAndMethod(this).addInt(v).describe(IntAnnotation.INT_VALUE),\n                                    SourceLineAnnotation.fromVisitedInstruction(this, getPC() + switchOffsets[i]));\n                        }\n\n                    }\n                }\n            }\n            // check for use of signed byte where is it assumed it can be out of\n            // the -128...127 range\n            if (stack.getStackDepth() >= 2) {\n                switch (seen) {\n                case IF_ICMPEQ:\n                case IF_ICMPNE:\n                case IF_ICMPLT:\n                case IF_ICMPLE:\n                case IF_ICMPGE:\n                case IF_ICMPGT:\n                    OpcodeStack.Item item0 = stack.getStackItem(0);\n                    OpcodeStack.Item item1 = stack.getStackItem(1);\n                    int seen2 = seen;\n                    if (item0.getConstant() != null) {\n                        OpcodeStack.Item tmp = item0;\n                        item0 = item1;\n                        item1 = tmp;\n                        switch (seen) {\n                        case IF_ICMPLT:\n                            seen2 = IF_ICMPGT;\n                            break;\n                        case IF_ICMPGE:\n                            seen2 = IF_ICMPLE;\n                            break;\n                        case IF_ICMPGT:\n                            seen2 = IF_ICMPLT;\n                            break;\n                        case IF_ICMPLE:\n                            seen2 = IF_ICMPGE;\n                            break;\n\n                        }\n                    }\n                    Object constant1 = item1.getConstant();\n                    if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 <= -129 || v1 >= 128 || v1 == 127 && !(seen2 == IF_ICMPEQ || seen2 == IF_ICMPNE\n\n                        )) {\n                            int priority = HIGH_PRIORITY;\n                            if (v1 == 127) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 127 > x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 127 >= x : always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 127 < x : never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 127 <= x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 == 128) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 128 > x; always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 128 >= x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 128 < x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 128 <= x; never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 <= -129) {\n                                priority = NORMAL_PRIORITY;\n                            }\n\n                            if (getPC() - sawCheckForNonNegativeSignedByte < 10)\n                                priority++;\n\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", priority)\n                                    .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n\n                        }\n                    } else if (item0.getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 < 0) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n                        }\n\n                    }\n\n                }\n            }\n\n            switch (seen) {\n            case IAND:\n            case LAND:\n            case IOR:\n            case LOR:\n            case IXOR:\n            case LXOR:\n                long badValue = (seen == IAND || seen == LAND) ? -1 : 0;\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                int prevOpcode = getPrevOpcode(1);\n                int prevPrevOpcode = getPrevOpcode(2);\n                if (rhs.hasConstantValue(badValue)\n                        && (prevOpcode == LDC || prevOpcode == ICONST_0 || prevOpcode == ICONST_M1 || prevOpcode == LCONST_0)\n                        && prevPrevOpcode != GOTO)\n                    reportVacuousBitOperation(seen, lhs);\n\n            }\n\n            if (checkForBitIorofSignedByte && seen != I2B) {\n                String pattern = (prevOpcode == LOR || prevOpcode == IOR) ? \"BIT_IOR_OF_SIGNED_BYTE\" : \"BIT_ADD_OF_SIGNED_BYTE\";\n                int priority = (prevOpcode == LOR || prevOpcode == LADD) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n                accumulator.accumulateBug(new BugInstance(this, pattern, priority).addClassAndMethod(this), this);\n\n                checkForBitIorofSignedByte = false;\n            } else if ((seen == IOR || seen == LOR || seen == IADD || seen == LADD) && stack.getStackDepth() >= 2) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n\n                int special0 = item0.getSpecialKind();\n                int special1 = item1.getSpecialKind();\n                if (special0 == OpcodeStack.Item.SIGNED_BYTE && special1 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item1.hasConstantValue(256) || special0 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item0.hasConstantValue(256) && special1 == OpcodeStack.Item.SIGNED_BYTE) {\n                    checkForBitIorofSignedByte = true;\n                } else {\n                    checkForBitIorofSignedByte = false;\n                }\n            } else {\n                checkForBitIorofSignedByte = false;\n            }\n\n            if (prevOpcodeWasReadLine && sinceBufferedInputStreamReady >= 100 && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/String\") && getSigConstantOperand().startsWith(\"()\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"NP_IMMEDIATE_DEREFERENCE_OF_READLINE\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/io/BufferedReader\")\n                    && getNameConstantOperand().equals(\"ready\") && getSigConstantOperand().equals(\"()Z\")) {\n                sinceBufferedInputStreamReady = 0;\n            } else {\n                sinceBufferedInputStreamReady++;\n            }\n\n            prevOpcodeWasReadLine = (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n                    && getNameConstantOperand().equals(\"readLine\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\");\n\n            // System.out.println(randomNextIntState + \" \" + OPCODE_NAMES[seen]\n            // + \" \" + getMethodName());\n            switch (randomNextIntState) {\n            case 0:\n                if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                        && getNameConstantOperand().equals(\"nextDouble\") || seen == INVOKESTATIC\n                        && ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"random\")) {\n                    randomNextIntState = 1;\n                }\n                break;\n            case 1:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_01_TO_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    randomNextIntState = 0;\n                } else if (seen == DMUL)\n                    randomNextIntState = 4;\n                else if (seen == LDC2_W && getConstantRefOperand() instanceof ConstantDouble\n                        && ((ConstantDouble) getConstantRefOperand()).getBytes() == Integer.MIN_VALUE)\n                    randomNextIntState = 0;\n                else\n                    randomNextIntState = 2;\n\n                break;\n            case 2:\n                if (seen == I2D) {\n                    randomNextIntState = 3;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 3:\n                if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 4:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"DM_NEXTINT_VIA_NEXTDOUBLE\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n                }\n                randomNextIntState = 0;\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            if (isPublicStaticVoidMain\n                    && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().startsWith(\"javax/swing/\")\n                    && (getNameConstantOperand().equals(\"show\") && getSigConstantOperand().equals(\"()V\")\n                            || getNameConstantOperand().equals(\"pack\") && getSigConstantOperand().equals(\"()V\") || getNameConstantOperand()\n                            .equals(\"setVisible\") && getSigConstantOperand().equals(\"(Z)V\"))) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"SW_SWING_METHODS_INVOKED_IN_SWING_THREAD\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            // if ((seen == INVOKEVIRTUAL)\n            // && getClassConstantOperand().equals(\"java/lang/String\")\n            // && getNameConstantOperand().equals(\"substring\")\n            // && getSigConstantOperand().equals(\"(I)Ljava/lang/String;\")\n            // && stack.getStackDepth() > 1) {\n            // OpcodeStack.Item item = stack.getStackItem(0);\n            // Object o = item.getConstant();\n            // if (o != null && o instanceof Integer) {\n            // int v = ((Integer) o).intValue();\n            // if (v == 0)\n            // accumulator.accumulateBug(new BugInstance(this,\n            // \"DMI_USELESS_SUBSTRING\", NORMAL_PRIORITY)\n            // .addClassAndMethod(this)\n            // .addSourceLine(this));\n            // }\n            // }\n\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"isAnnotationPresent\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Class;)Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                Object value = item.getConstant();\n                if (value instanceof String) {\n                    String annotationClassName = (String) value;\n                    boolean lacksClassfileRetention = AnalysisContext.currentAnalysisContext().getAnnotationRetentionDatabase()\n                            .lacksRuntimeRetention(annotationClassName.replace('/', '.'));\n                    if (lacksClassfileRetention) {\n                        ClassDescriptor annotationClass = DescriptorFactory.createClassDescriptor(annotationClassName);\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION\", HIGH_PRIORITY)\n                                        .addClassAndMethod(this).addCalledMethod(this).addClass(annotationClass)\n                                        .describe(ClassAnnotation.ANNOTATION_ROLE), this);\n                    }\n\n                }\n\n            }\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"next\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Object;\") && getMethodName().equals(\"hasNext\")\n                    && getMethodSig().equals(\"()Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_CALLING_NEXT_FROM_HASNEXT\", item.isInitialParameter()\n                        && item.getRegisterNumber() == 0 ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(Ljava/lang/String;)V\")\n                    && !Subtypes2.isJSP(getThisClass())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\") || seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/Runtime\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_RUN_FINALIZERS_ON_EXIT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"()V\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n\n            }\n\n            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"exit\") && !getMethodName().equals(\"processWindowEvent\")\n                    && !getMethodName().startsWith(\"windowClos\") && getMethodName().indexOf(\"exit\") == -1\n                    && getMethodName().indexOf(\"Exit\") == -1 && getMethodName().indexOf(\"crash\") == -1\n                    && getMethodName().indexOf(\"Crash\") == -1 && getMethodName().indexOf(\"die\") == -1\n                    && getMethodName().indexOf(\"Die\") == -1 && getMethodName().indexOf(\"main\") == -1) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_EXIT\", getMethod().isStatic() ? LOW_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), SourceLineAnnotation.fromVisitedInstruction(this));\n            }\n            if (((seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")) || (seen == INVOKEVIRTUAL && getClassConstantOperand()\n                    .equals(\"java/lang/Runtime\")))\n                    && getNameConstantOperand().equals(\"gc\")\n                    && getSigConstantOperand().equals(\"()V\")\n                    && !getDottedClassName().startsWith(\"java.lang\")\n                    && !getMethodName().startsWith(\"gc\") && !getMethodName().endsWith(\"gc\")) {\n                if (gcInvocationBugReport == null) {\n                    // System.out.println(\"Saw call to GC\");\n                    if (isPublicStaticVoidMain) {\n                        // System.out.println(\"Skipping GC complaint in main method\");\n                        return;\n                    }\n                    if (isTestMethod(getMethod())) {\n                        return;\n                    }\n                    // Just save this report in a field; it will be flushed\n                    // IFF there were no calls to System.currentTimeMillis();\n                    // in the method.\n                    gcInvocationBugReport = new BugInstance(this, \"DM_GC\", HIGH_PRIORITY).addClassAndMethod(this).addSourceLine(\n                            this);\n                    gcInvocationPC = getPC();\n                    // System.out.println(\"GC invocation at pc \" + PC);\n                }\n            }\n            if (!isSynthetic && (seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/Boolean\")\n                    && getNameConstantOperand().equals(\"<init>\") && !getClassName().equals(\"java/lang/Boolean\")) {\n                int majorVersion = getThisClass().getMajor();\n                if (majorVersion >= MAJOR_1_4) {\n                    accumulator.accumulateBug(new BugInstance(this, \"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n            if ((seen == INVOKESTATIC) && getClassConstantOperand().equals(\"java/lang/System\")\n                    && (getNameConstantOperand().equals(\"currentTimeMillis\") || getNameConstantOperand().equals(\"nanoTime\"))) {\n                sawCurrentTimeMillis = true;\n            }\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"toString\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator\n                        .accumulateBug(new BugInstance(this, \"DM_STRING_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && (getNameConstantOperand().equals(\"toUpperCase\") || getNameConstantOperand().equals(\"toLowerCase\"))\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_CONVERT_CASE\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                String cls = getClassConstantOperand();\n                String sig = getSigConstantOperand();\n                if ((cls.equals(\"java/lang/Integer\") && sig.equals(\"(I)V\"))\n                        || (cls.equals(\"java/lang/Float\") && sig.equals(\"(F)V\"))\n                        || (cls.equals(\"java/lang/Double\") && sig.equals(\"(D)V\"))\n                        || (cls.equals(\"java/lang/Long\") && sig.equals(\"(J)V\"))\n                        || (cls.equals(\"java/lang/Byte\") && sig.equals(\"(B)V\"))\n                        || (cls.equals(\"java/lang/Character\") && sig.equals(\"(C)V\"))\n                        || (cls.equals(\"java/lang/Short\") && sig.equals(\"(S)V\"))\n                        || (cls.equals(\"java/lang/Boolean\") && sig.equals(\"(Z)V\"))) {\n                    primitiveObjCtorSeen = cls;\n                } else {\n                    primitiveObjCtorSeen = null;\n                }\n            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"toString\")\n                    && getClassConstantOperand().equals(primitiveObjCtorSeen)\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                primitiveObjCtorSeen = null;\n            } else {\n                primitiveObjCtorSeen = null;\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                ctorSeen = true;\n            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/Object\")\n                    && getNameConstantOperand().equals(\"getClass\") && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_NEW_FOR_GETCLASS\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n                ctorSeen = false;\n            } else {\n                ctorSeen = false;\n            }\n\n            if (jdk15ChecksEnabled && (seen == INVOKEVIRTUAL) && isMonitorWait(getNameConstantOperand(), getSigConstantOperand())) {\n                checkMonitorWait();\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")\n                    && getClassConstantOperand().equals(\"java/lang/Thread\")) {\n                String sig = getSigConstantOperand();\n                if (sig.equals(\"()V\") || sig.equals(\"(Ljava/lang/String;)V\")\n                        || sig.equals(\"(Ljava/lang/ThreadGroup;Ljava/lang/String;)V\")) {\n                    OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);\n                    if (!getMethodName().equals(\"<init>\") || invokedOn.getRegisterNumber() != 0) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DM_USELESS_THREAD\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                    }\n                }\n            }\n\n            if (seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/math/BigDecimal\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(D)V\")) {\n                OpcodeStack.Item top = stack.getStackItem(0);\n                Object value = top.getConstant();\n                if (value instanceof Double) {\n                    double arg = ((Double) value).doubleValue();\n                    String dblString = Double.toString(arg);\n                    String bigDecimalString = new BigDecimal(arg).toString();\n                    boolean ok = dblString.equals(bigDecimalString) || dblString.equals(bigDecimalString + \".0\");\n\n                    if (!ok) {\n                        boolean scary = dblString.length() <= 8 && bigDecimalString.length() > 12\n                                && dblString.toUpperCase().indexOf(\"E\") == -1;\n                        bugReporter.reportBug(new BugInstance(this, \"DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE\",\n                                scary ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this).addCalledMethod(this)\n                                .addMethod(\"java.math.BigDecimal\", \"valueOf\", \"(D)Ljava/math/BigDecimal;\", true)\n                                .describe(MethodAnnotation.METHOD_ALTERNATIVE_TARGET).addString(dblString)\n                                .addString(bigDecimalString).addSourceLine(this));\n                    }\n                }\n\n            }\n\n        } finally {\n            prevOpcode = seen;\n        }\n    }","id":98454,"modified_method":"@Override\n    public void sawOpcode(int seen) {\n        \n        if (isMethodCall()) {\n            MethodDescriptor called = getMethodDescriptorOperand();\n\n            if (previousMethodCall != null && !stack.isJumpTarget(getPC())) {\n                if (called.getName().equals(\"toString\")\n                        && called.getClassDescriptor().getClassName().equals(\"java/lang/Integer\")\n                        && previousMethodCall.getName().equals(\"valueOf\")\n                        && previousMethodCall.getSignature().equals(\"(I)Ljava/lang/Integer;\")\n                        ) {\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Integer\", \"toString\", \"(I)Ljava/lang/String;\", true);\n                    BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.METHOD_PREFERRED);\n                    accumulator.accumulateBug(bug, this);\n\n                }  else   if (called.getName().equals(\"intValue\")\n                        && called.getClassDescriptor().getClassName().equals(\"java/lang/Integer\")\n                        && previousMethodCall.getName().equals(\"<init>\")\n                        && previousMethodCall.getSignature().equals(\"(Ljava/lang/String;)V\")) {\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Integer\", \"parseString\", \"(Ljava/lang/String;)I\", true);\n                    \n                    BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.METHOD_PREFERRED);\n                    accumulator.accumulateBug(bug, this);\n                }\n            }\n            previousMethodCall = called;\n        } else\n            previousMethodCall = null;\n        \n\n        if (seen == LDC || seen == LDC_W || seen == LDC2_W) {\n            Constant c = getConstantRefOperand();\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT)) {\n                BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                        .addString(\"Did you mean MICROS_PER_DAY\").addInt(MICROS_PER_DAY_OVERFLOWED_AS_INT)\n                        .describe(IntAnnotation.INT_VALUE);\n                accumulator.accumulateBug(bug, this);\n            }\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == Integer.MIN_VALUE\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == Long.MIN_VALUE)) {\n                sawLoadOfMinValue = true;\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n                absoluteValueAccumulator.clearBugs();\n            }\n        }\n\n\n        if (seen == LCMP) {\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            checkForCompatibleLongComparison(left, right);\n            checkForCompatibleLongComparison(right, left);\n        }\n\n        if (stack.getStackDepth() >= 2)\n            switch (seen) {\n            case IF_ICMPEQ:\n            case IF_ICMPNE:\n            case IF_ICMPLE:\n            case IF_ICMPGE:\n            case IF_ICMPLT:\n            case IF_ICMPGT:\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item0.getConstant() instanceof Integer) {\n                    OpcodeStack.Item tmp = item0;\n                    item0 = item1;\n                    item1 = tmp;\n                }\n                Object constant1 = item1.getConstant();\n                XMethod returnValueOf = item0.getReturnValueOf();\n                if (constant1 instanceof Integer\n                        && returnValueOf != null\n                        && returnValueOf.getName().equals(\"getYear\")\n                        && (returnValueOf.getClassName().equals(\"java.util.Date\") || returnValueOf.getClassName().equals(\n                                \"java.sql.Date\"))) {\n                    int year = (Integer) constant1;\n                    if (year > 1900)\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                                        .addString(\"Comparison of getYear does understand that it returns year-1900\")\n                                        .addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addInt(year)\n                                        .describe(IntAnnotation.INT_VALUE), this);\n                }\n            }\n\n        // System.out.printf(\"%4d %10s: %s\\n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n        if (seen == IFLT && stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n            sawCheckForNonNegativeSignedByte = getPC();\n        }\n\n        if (pendingAbsoluteValueBug != null) {\n            if (opcodesSincePendingAbsoluteValueBug == 0) {\n                opcodesSincePendingAbsoluteValueBug++;\n            } else {\n                if (seen == IREM) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    Object constantValue = top.getConstant();\n                    if (constantValue instanceof Number && Util.isPowerOfTwo(((Number) constantValue).intValue())) {\n                        pendingAbsoluteValueBug.setPriority(Priorities.LOW_PRIORITY);\n                    }\n                }\n                if (false)\n                    try {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen] + \":\"\n                                + OPCODE_NAMES[getNextOpcode()]);\n                    } catch (Exception e) {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen]);\n\n                    }\n                absoluteValueAccumulator.accumulateBug(pendingAbsoluteValueBug, pendingAbsoluteValueBugSourceLine);\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n            }\n        }\n\n        if (seen == INVOKESTATIC\n                && getClassConstantOperand().equals(\"org/easymock/EasyMock\")\n                && (getNameConstantOperand().equals(\"replay\") || getNameConstantOperand().equals(\"verify\") || getNameConstantOperand()\n                        .startsWith(\"reset\")) && getSigConstantOperand().equals(\"([Ljava/lang/Object;)V\")\n                && getPrevOpcode(1) == ANEWARRAY && getPrevOpcode(2) == ICONST_0)\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD\", NORMAL_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        \n        if (seen == INVOKESTATIC && (getClassConstantOperand().equals(\"com/google/common/base/Preconditions\")\n             && getNameConstantOperand().equals(\"checkNotNull\")\n             || getClassConstantOperand().equals(\"com/google/common/base/Strings\")\n             && (getNameConstantOperand().equals(\"nullToEmpty\") ||\n                     getNameConstantOperand().equals(\"emptyToNull\") ||\n                     getNameConstantOperand().equals(\"isNullOrEmpty\")))\n             ) {\n            int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n\n            OpcodeStack.Item item = stack.getStackItem(args - 1);\n            Object o = item.getConstant();\n            if (o instanceof String) {\n\n                OpcodeStack.Item secondArgument = null;\n                String bugPattern = \"DMI_DOH\";\n                if (args > 1) {\n                    secondArgument = stack.getStackItem(args - 2);\n                    Object secondConstant = secondArgument.getConstant();\n                    if (!(secondConstant instanceof String)) {\n                        bugPattern = \"DMI_ARGUMENTS_WRONG_ORDER\";\n                    }\n                }\n\n                BugInstance bug = new BugInstance(this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this)\n                        .addString(\"Passing String constant as value that should be null checked\").describe(StringAnnotation.STRING_MESSAGE)\n                        .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);\n                if (secondArgument != null)\n                        bug.addValueSource(secondArgument, this);\n\n                accumulator.accumulateBug(bug, this);\n            }\n        }\n\n        if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"junit/framework/Assert\")\n                && getNameConstantOperand().equals(\"assertNotNull\")) {\n               int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n\n               OpcodeStack.Item item = stack.getStackItem(0);\n               Object o = item.getConstant();\n               if (o instanceof String) {\n\n                   OpcodeStack.Item secondArgument = null;\n                   String bugPattern = \"DMI_DOH\";\n                   if (args == 2) {\n                       secondArgument = stack.getStackItem(1);\n                       Object secondConstant = secondArgument.getConstant();\n                       if (!(secondConstant instanceof String)) {\n                           bugPattern = \"DMI_ARGUMENTS_WRONG_ORDER\";\n                       }\n                   }\n\n                   BugInstance bug = new BugInstance(this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(this)\n                           .addCalledMethod(this).addString(\"Passing String constant as value that should be null checked\").describe(StringAnnotation.STRING_MESSAGE)\n                           .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);\n                   if (secondArgument != null)\n                           bug.addValueSource(secondArgument, this);\n\n                   accumulator.accumulateBug(bug, this);\n               }\n           }\n        if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE)\n                && getSigConstantOperand().indexOf(\"Ljava/lang/Runnable;\") >= 0) {\n            SignatureParser parser = new SignatureParser(getSigConstantOperand());\n            int count = 0;\n            for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext(); count++) {\n                String parameter = i.next();\n                if (parameter.equals(\"Ljava/lang/Runnable;\")) {\n                    OpcodeStack.Item item = stack.getStackItem(parser.getNumParameters() - 1 - count);\n                    if (\"Ljava/lang/Thread;\".equals(item.getSignature())) {\n                        accumulator.accumulateBug(new BugInstance(this, \"DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED\",\n                                NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this), this);\n                    }\n\n                }\n            }\n\n        }\n\n        if (prevOpcode == I2L && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/Double\")\n                && getNameConstantOperand().equals(\"longBitsToDouble\")) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT\", HIGH_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && (freshRandomOnTos || freshRandomOneBelowTos)) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_RANDOM_USED_ONLY_ONCE\", HIGH_PRIORITY).addClassAndMethod(this)\n                    .addCalledMethod(this), this);\n\n        }\n\n        freshRandomOneBelowTos = freshRandomOnTos && isRegisterLoad();\n        freshRandomOnTos = seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && getNameConstantOperand().equals(\"<init>\");\n\n        if ((seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashMap\") && getNameConstantOperand().equals(\n                \"get\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Map\") && getNameConstantOperand()\n                        .equals(\"get\"))\n                || (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashSet\") && getNameConstantOperand()\n                        .equals(\"contains\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Set\") && getNameConstantOperand()\n                        .equals(\"contains\"))) {\n            OpcodeStack.Item top = stack.getStackItem(0);\n            if (top.getSignature().equals(\"Ljava/net/URL;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_COLLECTION_OF_URLS\", HIGH_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n        }\n\n        /**\n         * Since you can change the number of core threads for a scheduled\n         * thread pool executor, disabling this for now\n         */\n        if (false && seen == INVOKESPECIAL\n                && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"<init>\")) {\n\n            int arguments = getNumberArguments(getSigConstantOperand());\n            OpcodeStack.Item item = stack.getStackItem(arguments - 1);\n            Object value = item.getConstant();\n            if (value instanceof Integer && ((Integer) value).intValue() == 0)\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS\",\n                        HIGH_PRIORITY).addClassAndMethod(this), this);\n\n        }\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"setMaximumPoolSize\")) {\n            accumulator.accumulateBug(new BugInstance(this,\n                    \"DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR\", HIGH_PRIORITY)\n                    .addClassAndMethod(this), this);\n        }\n        if (isEqualsObject && !reportedBadCastInEquals) {\n            if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"isInstance\")\n                    && getClassConstantOperand().equals(\"java/lang/Class\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INSTANCEOF || seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"getClass\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INVOKESPECIAL && getNameConstantOperand().equals(\"equals\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item1.getRegisterNumber() + item0.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == CHECKCAST && !sawInstanceofCheck) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    if (getSizeOfSurroundingTryBlock(getPC()) == Integer.MAX_VALUE) {\n                        accumulator.accumulateBug(new BugInstance(this, \"BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS\",\n                                NORMAL_PRIORITY).addClassAndMethod(this), this);\n                    }\n\n                    reportedBadCastInEquals = true;\n                }\n            }\n        }\n        {\n            boolean foundVacuousComparison = false;\n            if (seen == IF_ICMPGT || seen == IF_ICMPLE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (seen == IF_ICMPLT || seen == IF_ICMPGE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (foundVacuousComparison) {\n                accumulator.accumulateBug(new BugInstance(this, \"INT_VACUOUS_COMPARISON\", getBranchOffset() < 0 ? HIGH_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), this);\n            }\n\n        }\n\n        if (!sawLoadOfMinValue && seen == INVOKESTATIC &&\n                ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"abs\")\n                ) {\n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            int special = item0.getSpecialKind();\n            if (special == OpcodeStack.Item.RANDOM_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_RANDOM_INT\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n            else if (special == OpcodeStack.Item.HASHCODE_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_HASHCODE\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n        }\n\n        try {\n            int stackLoc = stackEntryThatMustBeNonnegative(seen);\n            if (stackLoc >= 0) {\n                OpcodeStack.Item tos = stack.getStackItem(stackLoc);\n                switch (tos.getSpecialKind()) {\n                case OpcodeStack.Item.HASHCODE_INT_REMAINDER:\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_REM_OF_HASHCODE\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n\n                    break;\n                case OpcodeStack.Item.RANDOM_INT:\n                case OpcodeStack.Item.RANDOM_INT_REMAINDER:\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"RV_REM_OF_RANDOM_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n\n                    break;\n                }\n\n            }\n            if (seen == IREM) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                Object constant0 = item0.getConstant();\n                if (constant0 instanceof Integer && ((Integer) constant0).intValue() == 1) {\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_REM_BY_1\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n\n            if (stack.getStackDepth() >= 1 && (seen == LOOKUPSWITCH || seen == TABLESWITCH)) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n                    int[] switchLabels = getSwitchLabels();\n                    int[] switchOffsets = getSwitchOffsets();\n                    for (int i = 0; i < switchLabels.length; i++) {\n                        int v = switchLabels[i];\n                        if (v <= -129 || v >= 128) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", HIGH_PRIORITY)\n                                    .addClassAndMethod(this).addInt(v).describe(IntAnnotation.INT_VALUE),\n                                    SourceLineAnnotation.fromVisitedInstruction(this, getPC() + switchOffsets[i]));\n                        }\n\n                    }\n                }\n            }\n            // check for use of signed byte where is it assumed it can be out of\n            // the -128...127 range\n            if (stack.getStackDepth() >= 2) {\n                switch (seen) {\n                case IF_ICMPEQ:\n                case IF_ICMPNE:\n                case IF_ICMPLT:\n                case IF_ICMPLE:\n                case IF_ICMPGE:\n                case IF_ICMPGT:\n                    OpcodeStack.Item item0 = stack.getStackItem(0);\n                    OpcodeStack.Item item1 = stack.getStackItem(1);\n                    int seen2 = seen;\n                    if (item0.getConstant() != null) {\n                        OpcodeStack.Item tmp = item0;\n                        item0 = item1;\n                        item1 = tmp;\n                        switch (seen) {\n                        case IF_ICMPLT:\n                            seen2 = IF_ICMPGT;\n                            break;\n                        case IF_ICMPGE:\n                            seen2 = IF_ICMPLE;\n                            break;\n                        case IF_ICMPGT:\n                            seen2 = IF_ICMPLT;\n                            break;\n                        case IF_ICMPLE:\n                            seen2 = IF_ICMPGE;\n                            break;\n\n                        }\n                    }\n                    Object constant1 = item1.getConstant();\n                    if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 <= -129 || v1 >= 128 || v1 == 127 && !(seen2 == IF_ICMPEQ || seen2 == IF_ICMPNE\n\n                        )) {\n                            int priority = HIGH_PRIORITY;\n                            if (v1 == 127) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 127 > x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 127 >= x : always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 127 < x : never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 127 <= x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 == 128) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 128 > x; always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 128 >= x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 128 < x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 128 <= x; never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 <= -129) {\n                                priority = NORMAL_PRIORITY;\n                            }\n\n                            if (getPC() - sawCheckForNonNegativeSignedByte < 10)\n                                priority++;\n\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", priority)\n                                    .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n\n                        }\n                    } else if (item0.getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 < 0) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n                        }\n\n                    }\n\n                }\n            }\n\n            switch (seen) {\n            case IAND:\n            case LAND:\n            case IOR:\n            case LOR:\n            case IXOR:\n            case LXOR:\n                long badValue = (seen == IAND || seen == LAND) ? -1 : 0;\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                int prevOpcode = getPrevOpcode(1);\n                int prevPrevOpcode = getPrevOpcode(2);\n                if (rhs.hasConstantValue(badValue)\n                        && (prevOpcode == LDC || prevOpcode == ICONST_0 || prevOpcode == ICONST_M1 || prevOpcode == LCONST_0)\n                        && prevPrevOpcode != GOTO)\n                    reportVacuousBitOperation(seen, lhs);\n\n            }\n\n            if (checkForBitIorofSignedByte && seen != I2B) {\n                String pattern = (prevOpcode == LOR || prevOpcode == IOR) ? \"BIT_IOR_OF_SIGNED_BYTE\" : \"BIT_ADD_OF_SIGNED_BYTE\";\n                int priority = (prevOpcode == LOR || prevOpcode == LADD) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n                accumulator.accumulateBug(new BugInstance(this, pattern, priority).addClassAndMethod(this), this);\n\n                checkForBitIorofSignedByte = false;\n            } else if ((seen == IOR || seen == LOR || seen == IADD || seen == LADD) && stack.getStackDepth() >= 2) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n\n                int special0 = item0.getSpecialKind();\n                int special1 = item1.getSpecialKind();\n                if (special0 == OpcodeStack.Item.SIGNED_BYTE && special1 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item1.hasConstantValue(256) || special0 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item0.hasConstantValue(256) && special1 == OpcodeStack.Item.SIGNED_BYTE) {\n                    checkForBitIorofSignedByte = true;\n                } else {\n                    checkForBitIorofSignedByte = false;\n                }\n            } else {\n                checkForBitIorofSignedByte = false;\n            }\n\n            if (prevOpcodeWasReadLine && sinceBufferedInputStreamReady >= 100 && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/String\") && getSigConstantOperand().startsWith(\"()\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"NP_IMMEDIATE_DEREFERENCE_OF_READLINE\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/io/BufferedReader\")\n                    && getNameConstantOperand().equals(\"ready\") && getSigConstantOperand().equals(\"()Z\")) {\n                sinceBufferedInputStreamReady = 0;\n            } else {\n                sinceBufferedInputStreamReady++;\n            }\n\n            prevOpcodeWasReadLine = (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n                    && getNameConstantOperand().equals(\"readLine\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\");\n\n            // System.out.println(randomNextIntState + \" \" + OPCODE_NAMES[seen]\n            // + \" \" + getMethodName());\n            switch (randomNextIntState) {\n            case 0:\n                if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                        && getNameConstantOperand().equals(\"nextDouble\") || seen == INVOKESTATIC\n                        && ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"random\")) {\n                    randomNextIntState = 1;\n                }\n                break;\n            case 1:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_01_TO_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    randomNextIntState = 0;\n                } else if (seen == DMUL)\n                    randomNextIntState = 4;\n                else if (seen == LDC2_W && getConstantRefOperand() instanceof ConstantDouble\n                        && ((ConstantDouble) getConstantRefOperand()).getBytes() == Integer.MIN_VALUE)\n                    randomNextIntState = 0;\n                else\n                    randomNextIntState = 2;\n\n                break;\n            case 2:\n                if (seen == I2D) {\n                    randomNextIntState = 3;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 3:\n                if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 4:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"DM_NEXTINT_VIA_NEXTDOUBLE\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n                }\n                randomNextIntState = 0;\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            if (isPublicStaticVoidMain\n                    && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().startsWith(\"javax/swing/\")\n                    && (getNameConstantOperand().equals(\"show\") && getSigConstantOperand().equals(\"()V\")\n                            || getNameConstantOperand().equals(\"pack\") && getSigConstantOperand().equals(\"()V\") || getNameConstantOperand()\n                            .equals(\"setVisible\") && getSigConstantOperand().equals(\"(Z)V\"))) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"SW_SWING_METHODS_INVOKED_IN_SWING_THREAD\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            // if ((seen == INVOKEVIRTUAL)\n            // && getClassConstantOperand().equals(\"java/lang/String\")\n            // && getNameConstantOperand().equals(\"substring\")\n            // && getSigConstantOperand().equals(\"(I)Ljava/lang/String;\")\n            // && stack.getStackDepth() > 1) {\n            // OpcodeStack.Item item = stack.getStackItem(0);\n            // Object o = item.getConstant();\n            // if (o != null && o instanceof Integer) {\n            // int v = ((Integer) o).intValue();\n            // if (v == 0)\n            // accumulator.accumulateBug(new BugInstance(this,\n            // \"DMI_USELESS_SUBSTRING\", NORMAL_PRIORITY)\n            // .addClassAndMethod(this)\n            // .addSourceLine(this));\n            // }\n            // }\n\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"isAnnotationPresent\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Class;)Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                Object value = item.getConstant();\n                if (value instanceof String) {\n                    String annotationClassName = (String) value;\n                    boolean lacksClassfileRetention = AnalysisContext.currentAnalysisContext().getAnnotationRetentionDatabase()\n                            .lacksRuntimeRetention(annotationClassName.replace('/', '.'));\n                    if (lacksClassfileRetention) {\n                        ClassDescriptor annotationClass = DescriptorFactory.createClassDescriptor(annotationClassName);\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION\", HIGH_PRIORITY)\n                                        .addClassAndMethod(this).addCalledMethod(this).addClass(annotationClass)\n                                        .describe(ClassAnnotation.ANNOTATION_ROLE), this);\n                    }\n\n                }\n\n            }\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"next\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Object;\") && getMethodName().equals(\"hasNext\")\n                    && getMethodSig().equals(\"()Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_CALLING_NEXT_FROM_HASNEXT\", item.isInitialParameter()\n                        && item.getRegisterNumber() == 0 ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(Ljava/lang/String;)V\")\n                    && !Subtypes2.isJSP(getThisClass())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\") || seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/Runtime\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_RUN_FINALIZERS_ON_EXIT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"()V\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n\n            }\n\n            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"exit\") && !getMethodName().equals(\"processWindowEvent\")\n                    && !getMethodName().startsWith(\"windowClos\") && getMethodName().indexOf(\"exit\") == -1\n                    && getMethodName().indexOf(\"Exit\") == -1 && getMethodName().indexOf(\"crash\") == -1\n                    && getMethodName().indexOf(\"Crash\") == -1 && getMethodName().indexOf(\"die\") == -1\n                    && getMethodName().indexOf(\"Die\") == -1 && getMethodName().indexOf(\"main\") == -1) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_EXIT\", getMethod().isStatic() ? LOW_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), SourceLineAnnotation.fromVisitedInstruction(this));\n            }\n            if (((seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")) || (seen == INVOKEVIRTUAL && getClassConstantOperand()\n                    .equals(\"java/lang/Runtime\")))\n                    && getNameConstantOperand().equals(\"gc\")\n                    && getSigConstantOperand().equals(\"()V\")\n                    && !getDottedClassName().startsWith(\"java.lang\")\n                    && !getMethodName().startsWith(\"gc\") && !getMethodName().endsWith(\"gc\")) {\n                if (gcInvocationBugReport == null) {\n                    // System.out.println(\"Saw call to GC\");\n                    if (isPublicStaticVoidMain) {\n                        // System.out.println(\"Skipping GC complaint in main method\");\n                        return;\n                    }\n                    if (isTestMethod(getMethod())) {\n                        return;\n                    }\n                    // Just save this report in a field; it will be flushed\n                    // IFF there were no calls to System.currentTimeMillis();\n                    // in the method.\n                    gcInvocationBugReport = new BugInstance(this, \"DM_GC\", HIGH_PRIORITY).addClassAndMethod(this).addSourceLine(\n                            this);\n                    gcInvocationPC = getPC();\n                    // System.out.println(\"GC invocation at pc \" + PC);\n                }\n            }\n            if (!isSynthetic && (seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/Boolean\")\n                    && getNameConstantOperand().equals(\"<init>\") && !getClassName().equals(\"java/lang/Boolean\")) {\n                int majorVersion = getThisClass().getMajor();\n                if (majorVersion >= MAJOR_1_4) {\n                    accumulator.accumulateBug(new BugInstance(this, \"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n            if ((seen == INVOKESTATIC) && getClassConstantOperand().equals(\"java/lang/System\")\n                    && (getNameConstantOperand().equals(\"currentTimeMillis\") || getNameConstantOperand().equals(\"nanoTime\"))) {\n                sawCurrentTimeMillis = true;\n            }\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"toString\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator\n                        .accumulateBug(new BugInstance(this, \"DM_STRING_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && (getNameConstantOperand().equals(\"toUpperCase\") || getNameConstantOperand().equals(\"toLowerCase\"))\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_CONVERT_CASE\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                String cls = getClassConstantOperand();\n                String sig = getSigConstantOperand();\n                String primitiveType = ClassName.getPrimitiveType(cls);\n                if (primitiveType != null && sig.charAt(1) == primitiveType.charAt(0)) {\n                    primitiveObjCtorSeen = cls;\n                } else {\n                    primitiveObjCtorSeen = null;\n                }\n            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"toString\")\n                    && getClassConstantOperand().equals(primitiveObjCtorSeen)\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n                BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this);\n                MethodAnnotation preferred = new MethodAnnotation(ClassName.toDottedClassName(primitiveObjCtorSeen),\n                        \"toString\", \"(\"+ClassName.getPrimitiveType(primitiveObjCtorSeen)+\")Ljava/lang/String;\", true);\n                bug.addMethod(preferred).describe(MethodAnnotation.METHOD_PREFERRED);\n                accumulator.accumulateBug(\n                        bug, this);\n\n                primitiveObjCtorSeen = null;\n            } else {\n                primitiveObjCtorSeen = null;\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                ctorSeen = true;\n            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/Object\")\n                    && getNameConstantOperand().equals(\"getClass\") && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_NEW_FOR_GETCLASS\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n                ctorSeen = false;\n            } else {\n                ctorSeen = false;\n            }\n\n            if (jdk15ChecksEnabled && (seen == INVOKEVIRTUAL) && isMonitorWait(getNameConstantOperand(), getSigConstantOperand())) {\n                checkMonitorWait();\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")\n                    && getClassConstantOperand().equals(\"java/lang/Thread\")) {\n                String sig = getSigConstantOperand();\n                if (sig.equals(\"()V\") || sig.equals(\"(Ljava/lang/String;)V\")\n                        || sig.equals(\"(Ljava/lang/ThreadGroup;Ljava/lang/String;)V\")) {\n                    OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);\n                    if (!getMethodName().equals(\"<init>\") || invokedOn.getRegisterNumber() != 0) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DM_USELESS_THREAD\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                    }\n                }\n            }\n\n            if (seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/math/BigDecimal\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(D)V\")) {\n                OpcodeStack.Item top = stack.getStackItem(0);\n                Object value = top.getConstant();\n                if (value instanceof Double) {\n                    double arg = ((Double) value).doubleValue();\n                    String dblString = Double.toString(arg);\n                    String bigDecimalString = new BigDecimal(arg).toString();\n                    boolean ok = dblString.equals(bigDecimalString) || dblString.equals(bigDecimalString + \".0\");\n\n                    if (!ok) {\n                        boolean scary = dblString.length() <= 8 && bigDecimalString.length() > 12\n                                && dblString.toUpperCase().indexOf(\"E\") == -1;\n                        bugReporter.reportBug(new BugInstance(this, \"DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE\",\n                                scary ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this).addCalledMethod(this)\n                                .addMethod(\"java.math.BigDecimal\", \"valueOf\", \"(D)Ljava/math/BigDecimal;\", true)\n                                .describe(MethodAnnotation.METHOD_ALTERNATIVE_TARGET).addString(dblString)\n                                .addString(bigDecimalString).addSourceLine(this));\n                    }\n                }\n\n            }\n\n        } finally {\n            prevOpcode = seen;\n        }\n    }","commit_id":"618a625550a3cece9988e9e15558a23208f777eb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void runTests() {\n        TestNG testNg = new TestNG();\n        testNg.setOutputDirectory(testReportDir.getAbsolutePath());\n        testNg.setDefaultSuiteName(options.getDefaultSuiteName());\n        testNg.setDefaultTestName(options.getDefaultTestName());\n        testNg.setParallel(options.getParallel());\n        testNg.setThreadCount(options.getThreadCount());\n        String configFailurePolicy = options.getConfigFailurePolicy();\n        try {\n            JavaReflectionUtil.method(TestNG.class, Object.class, \"setConfigFailurePolicy\", String.class).invoke(testNg, configFailurePolicy);\n        } catch (NoSuchMethodException e) {\n            if (!configFailurePolicy.equals(TestNGOptions.DEFAULT_CONFIG_FAILURE_POLICY)) {\n                // Should not reach this point as this is validated in the test framework implementation - just propagate the failure\n                throw e;\n            }\n        }\n        try {\n            JavaReflectionUtil.method(TestNG.class, Object.class, \"setAnnotations\").invoke(testNg, options.getAnnotations());\n        } catch (NoSuchMethodException e) {\n            /* do nothing; method has been removed in TestNG 6.3 */\n        }\n        if (options.getJavadocAnnotations()) {\n            testNg.setSourcePath(CollectionUtils.join(File.pathSeparator, options.getTestResources()));\n        }\n\n        testNg.setUseDefaultListeners(options.getUseDefaultListeners());\n        testNg.setVerbose(0);\n        testNg.setGroups(CollectionUtils.join(\",\", options.getIncludeGroups()));\n        testNg.setExcludedGroups(CollectionUtils.join(\",\", options.getExcludeGroups()));\n\n        //adding custom test listeners before Gradle's listeners.\n        //this way, custom listeners are more powerful and, for example, they can change test status.\n        for (String listenerClass : options.getListeners()) {\n            try {\n                testNg.addListener(applicationClassLoader.loadClass(listenerClass).newInstance());\n            } catch (Throwable e) {\n                throw new GradleException(String.format(\"Could not add a test listener with class '%s'.\", listenerClass), e);\n            }\n        }\n\n        if (!options.getIncludedTests().isEmpty()) {\n            testNg.addListener(new SelectedTestsFilter(options.getIncludedTests()));\n        }\n\n        if (!suiteFiles.isEmpty()) {\n            testNg.setTestSuites(GFileUtils.toPaths(suiteFiles));\n        } else {\n            testNg.setTestClasses(testClasses.toArray(new Class[testClasses.size()]));\n        }\n        testNg.addListener((Object) adaptListener(new TestNGTestResultProcessorAdapter(resultProcessor, idGenerator, timeProvider)));\n\n        try {\n            JavaReflectionUtil.method(TestNG.class, void.class, \"setPreserveOrder\", boolean.class).invoke(testNg, options.getPreserveOrder());\n        } catch (NoSuchMethodException e) {\n            if (options.getPreserveOrder()) {\n                throw new GradleException(\"Preserving the order of tests is not supported by this version of TestNG.\", e);\n            }\n        }\n        try {\n            JavaReflectionUtil.method(TestNG.class, void.class, \"setGroupByInstances\", boolean.class).invoke(testNg, options.getGroupByInstances());\n        } catch (NoSuchMethodException e) {\n            if (options.getGroupByInstances()) {\n                throw new GradleException(\"Grouping tests by instances is not supported by this version of TestNG.\", e);\n            }\n        }\n\n        testNg.run();\n    }","id":98455,"modified_method":"private void runTests() {\n        TestNG testNg = new TestNG();\n        testNg.setOutputDirectory(testReportDir.getAbsolutePath());\n        testNg.setDefaultSuiteName(options.getDefaultSuiteName());\n        testNg.setDefaultTestName(options.getDefaultTestName());\n        testNg.setParallel(options.getParallel());\n        testNg.setThreadCount(options.getThreadCount());\n        invokeVerifiedMethod(testNg, \"setConfigFailurePolicy\", String.class, options.getConfigFailurePolicy(), TestNGOptions.DEFAULT_CONFIG_FAILURE_POLICY);\n        invokeVerifiedMethod(testNg, \"setPreserveOrder\", boolean.class, options.getPreserveOrder(), false);\n        invokeVerifiedMethod(testNg, \"setGroupByInstances\", boolean.class, options.getGroupByInstances(), false);\n        try {\n            JavaReflectionUtil.method(TestNG.class, Object.class, \"setAnnotations\").invoke(testNg, options.getAnnotations());\n        } catch (NoSuchMethodException e) {\n            /* do nothing; method has been removed in TestNG 6.3 */\n        }\n        if (options.getJavadocAnnotations()) {\n            testNg.setSourcePath(CollectionUtils.join(File.pathSeparator, options.getTestResources()));\n        }\n\n        testNg.setUseDefaultListeners(options.getUseDefaultListeners());\n        testNg.setVerbose(0);\n        testNg.setGroups(CollectionUtils.join(\",\", options.getIncludeGroups()));\n        testNg.setExcludedGroups(CollectionUtils.join(\",\", options.getExcludeGroups()));\n\n        //adding custom test listeners before Gradle's listeners.\n        //this way, custom listeners are more powerful and, for example, they can change test status.\n        for (String listenerClass : options.getListeners()) {\n            try {\n                testNg.addListener(applicationClassLoader.loadClass(listenerClass).newInstance());\n            } catch (Throwable e) {\n                throw new GradleException(String.format(\"Could not add a test listener with class '%s'.\", listenerClass), e);\n            }\n        }\n\n        if (!options.getIncludedTests().isEmpty()) {\n            testNg.addListener(new SelectedTestsFilter(options.getIncludedTests()));\n        }\n\n        if (!suiteFiles.isEmpty()) {\n            testNg.setTestSuites(GFileUtils.toPaths(suiteFiles));\n        } else {\n            testNg.setTestClasses(testClasses.toArray(new Class[testClasses.size()]));\n        }\n        testNg.addListener((Object) adaptListener(new TestNGTestResultProcessorAdapter(resultProcessor, idGenerator, timeProvider)));\n        testNg.run();\n    }","commit_id":"2da56feded0f8030df79249f80b702bb39b44488","url":"https://github.com/gradle/gradle"},{"original_method":"public WorkerTestClassProcessorFactory getProcessorFactory() {\n        verifyConfigFailurePolicy();\n        options.setTestResources(testTask.getTestSrcDirs());\n        List<File> suiteFiles = options.getSuites(testTask.getTemporaryDir());\n        return new TestClassProcessorFactoryImpl(options.getOutputDirectory(), new TestNGSpec(options, filter), suiteFiles);\n    }","id":98456,"modified_method":"public WorkerTestClassProcessorFactory getProcessorFactory() {\n        verifyConfigFailurePolicy();\n        verifyPreserveOrder();\n        verifyGroupByInstances();\n        options.setTestResources(testTask.getTestSrcDirs());\n        List<File> suiteFiles = options.getSuites(testTask.getTemporaryDir());\n        return new TestClassProcessorFactoryImpl(options.getOutputDirectory(), new TestNGSpec(options, filter), suiteFiles);\n    }","commit_id":"2da56feded0f8030df79249f80b702bb39b44488","url":"https://github.com/gradle/gradle"},{"original_method":"private void verifyConfigFailurePolicy() {\n        if (!options.getConfigFailurePolicy().equals(TestNGOptions.DEFAULT_CONFIG_FAILURE_POLICY)) {\n            try {\n                Class<?> testNg = classLoaderFactory.create().loadClass(\"org.testng.TestNG\");\n                testNg.getMethod(\"setConfigFailurePolicy\", String.class);\n            } catch (ClassNotFoundException e) {\n                throw new GradleException(\"Could not load TestNG.\", e);\n            } catch (NoSuchMethodException e) {\n                throw new InvalidUserDataException(String.format(\"The version of TestNG used does not support setting config failure policy to '%s'.\", options.getConfigFailurePolicy()));\n            }\n        }\n    }","id":98457,"modified_method":"private void verifyConfigFailurePolicy() {\n        if (!options.getConfigFailurePolicy().equals(TestNGOptions.DEFAULT_CONFIG_FAILURE_POLICY)) {\n            verifyMethodExists(\"setConfigFailurePolicy\", String.class,\n                String.format(\"The version of TestNG used does not support setting config failure policy to '%s'.\", options.getConfigFailurePolicy()));\n        }\n    }","commit_id":"2da56feded0f8030df79249f80b702bb39b44488","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  public RangeMarkerTree<T>.RMNode addInterval(@NotNull T interval, int start, int end, boolean greedyToLeft, boolean greedyToRight, int layer) {\n    RangeMarkerImpl marker = (RangeMarkerImpl)interval;\n    marker.setValid(true);\n    RangeMarkerTree<T>.RMNode node = (RMNode)super.addInterval(interval, start, end, greedyToLeft, greedyToRight, layer);\n\n    if (DEBUG && node.intervals.size() > DUPLICATE_LIMIT) {\n      l.readLock().lock();\n      try {\n        System.gc();\n        System.gc();\n        System.gc();\n        final StringBuilder msg = new StringBuilder();\n        final AtomicInteger alive = new AtomicInteger();\n        node.processAliveKeys(new Processor<T>() {\n          @Override\n          public boolean process(T t) {\n            msg.append(t).append(\"\\n\");\n            alive.incrementAndGet();\n            return true;\n          }\n        });\n        if (alive.get() > DUPLICATE_LIMIT) {\n          msg.insert(0, \"Too many range markers (\" + alive +\") registered at (\"+start+\",\"+end+\") in \"+this+\":\\n\");\n          LOG.error(msg);\n        }\n      }\n      finally {\n        l.readLock().unlock();\n      }\n    }\n    return node;\n  }","id":98458,"modified_method":"@Override\n  public RangeMarkerTree<T>.RMNode addInterval(@NotNull T interval, int start, int end, boolean greedyToLeft, boolean greedyToRight, int layer) {\n    RangeMarkerImpl marker = (RangeMarkerImpl)interval;\n    marker.setValid(true);\n    RangeMarkerTree<T>.RMNode node = (RMNode)super.addInterval(interval, start, end, greedyToLeft, greedyToRight, layer);\n\n    if (DEBUG && node.intervals.size() > DUPLICATE_LIMIT) {\n      l.readLock().lock();\n      try {\n        String msg = errMsg(node);\n        if (msg != null) {\n          System.gc();\n          System.gc();\n          System.gc();\n          msg = errMsg(node);\n          if (msg != null) {\n            LOG.error(msg);\n          }\n        }\n      }\n      finally {\n        l.readLock().unlock();\n      }\n    }\n    return node;\n  }","commit_id":"84faf6234f1f95730906eccc99c2ae66577d0c50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void runActivity(final Project project) {\n    Runnable task = new Runnable() {\n      @SuppressWarnings(\"unchecked\")\n      @Override\n      public void run() {\n        for (ExternalSystemManager<?, ?, ?, ?, ?> manager : ExternalSystemApiUtil.getAllManagers()) {\n          if (manager instanceof StartupActivity) {\n            ((StartupActivity)manager).runActivity(project);\n          }\n        }\n        if (project.getUserData(ExternalSystemDataKeys.NEWLY_IMPORTED_PROJECT) != Boolean.TRUE) {\n          for (ExternalSystemManager manager : ExternalSystemManager.EP_NAME.getExtensions()) {\n            ExternalSystemUtil.refreshProjects(project, manager.getSystemId(), false);\n          }\n        }\n        ExternalSystemAutoImporter.letTheMagicBegin(project);\n        ExternalToolWindowManager.handle(project);\n        ExternalSystemVcsRegistrar.handle(project);\n      }\n    };\n\n    if (project.isInitialized()) {\n      task.run();\n    }\n    else {\n      StartupManager.getInstance(project).registerPostStartupActivity(task);\n    } \n  }","id":98459,"modified_method":"@Override\n  public void runActivity(final Project project) {\n    Runnable task = new Runnable() {\n      @SuppressWarnings(\"unchecked\")\n      @Override\n      public void run() {\n        for (ExternalSystemManager<?, ?, ?, ?, ?> manager : ExternalSystemApiUtil.getAllManagers()) {\n          if (manager instanceof StartupActivity) {\n            ((StartupActivity)manager).runActivity(project);\n          }\n        }\n        if (project.getUserData(ExternalSystemDataKeys.NEWLY_IMPORTED_PROJECT) != Boolean.TRUE) {\n          for (ExternalSystemManager manager : ExternalSystemManager.EP_NAME.getExtensions()) {\n            ExternalSystemUtil.refreshProjects(project, manager.getSystemId(), false);\n          }\n        }\n        ExternalSystemAutoImporter.letTheMagicBegin(project);\n        ExternalToolWindowManager.handle(project);\n      }\n    };\n\n    if (project.isInitialized()) {\n      task.run();\n    }\n    else {\n      StartupManager.getInstance(project).registerPostStartupActivity(task);\n    } \n  }","commit_id":"b6bf5cc45bf29834aa13014b7e9265e820cc8c49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public GitRootDetectInfo detect() {\n    return detect(myProject.getBaseDir());\n  }","id":98460,"modified_method":"public GitRootDetectInfo detect() {\n    VirtualFile projectDir = myProject.getBaseDir();\n\n    if (projectDir == null) {\n      return new GitRootDetectInfo(Collections.<VirtualFile>emptyList(), false, false);\n    }\n\n    final Set<VirtualFile> roots = scanForRootsInsideDir(projectDir);\n    roots.addAll(scanForRootsInContentRoots());\n\n    if (roots.contains(projectDir)) {\n      return new GitRootDetectInfo(roots, true, false);\n    }\n\n    VirtualFile rootAbove = scanForSingleRootAboveDir(projectDir);\n    if (rootAbove != null) {\n      roots.add(rootAbove);\n      return new GitRootDetectInfo(roots, true, true);\n    }\n    return new GitRootDetectInfo(roots, false, false);\n  }","commit_id":"b6bf5cc45bf29834aa13014b7e9265e820cc8c49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public VirtualFile getVcsRootFor(final VirtualFile file) {\n    VcsDirectoryMapping mapping = getMappingFor(file);\n    if (mapping == null) {\n      return null;\n    }\n    final String directory = mapping.getDirectory();\n    if (directory.length() == 0) {\n      final VirtualFile contentRoot = ProjectRootManager.getInstance(myProject).getFileIndex().getContentRootForFile(file);\n      if (contentRoot != null) {\n        return contentRoot;\n      }\n      return myProject.getBaseDir();\n    }\n    return LocalFileSystem.getInstance().findFileByPath(directory);\n  }","id":98461,"modified_method":"@Nullable\n  public VirtualFile getVcsRootFor(final VirtualFile file) {\n    VcsDirectoryMapping mapping = getMappingFor(file);\n    if (mapping == null) {\n      return null;\n    }\n    final String directory = mapping.getDirectory();\n    if (directory.length() == 0) {\n      final VirtualFile baseDir = myProject.getBaseDir();\n      if (baseDir != null && VfsUtil.isAncestor(baseDir, file, false)) {\n        return baseDir;\n      }\n      final VirtualFile contentRoot = ProjectRootManager.getInstance(myProject).getFileIndex().getContentRootForFile(file);\n      if (contentRoot != null) {\n        return contentRoot;\n      }\n      return null;\n    }\n    return LocalFileSystem.getInstance().findFileByPath(directory);\n  }","commit_id":"a0bfe3fc8863b5f80e222318752938fdce9056b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isInDirectoryBasedRoot(final VirtualFile file) {\n    if (file == null) return false;\n    final StorageScheme storageScheme = ((ProjectEx) myProject).getStateStore().getStorageScheme();\n    if (StorageScheme.DIRECTORY_BASED.equals(storageScheme)) {\n      final VirtualFile ideaDir = myProject.getBaseDir().findChild(Project.DIRECTORY_STORE_FOLDER);\n      return (ideaDir != null && ideaDir.isValid() && ideaDir.isDirectory() && VfsUtil.isAncestor(ideaDir, file, false));\n    }\n    return false;\n  }","id":98462,"modified_method":"private boolean isInDirectoryBasedRoot(final VirtualFile file) {\n    if (file == null) return false;\n    final StorageScheme storageScheme = ((ProjectEx) myProject).getStateStore().getStorageScheme();\n    if (StorageScheme.DIRECTORY_BASED.equals(storageScheme)) {\n      final VirtualFile baseDir = myProject.getBaseDir();\n      if (baseDir == null) return false;\n      final VirtualFile ideaDir = baseDir.findChild(Project.DIRECTORY_STORE_FOLDER);\n      return (ideaDir != null && ideaDir.isValid() && ideaDir.isDirectory() && VfsUtil.isAncestor(ideaDir, file, false));\n    }\n    return false;\n  }","commit_id":"e1247ba8336e2a5e481c9ad31b626ed1f4b01d01","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Content getOrCreateConsoleContent(final ContentManager contentManager) {\n    final String displayName = VcsBundle.message(\"vcs.console.toolwindow.display.name\");\n    Content content = contentManager.findContent(displayName);\n    if (content == null) {\n      final EditorFactory editorFactory = EditorFactory.getInstance();\n      final Editor editor = editorFactory.createViewer(editorFactory.createDocument(\"\"));\n      EditorSettings editorSettings = editor.getSettings();\n      editorSettings.setLineMarkerAreaShown(false);\n      editorSettings.setIndentGuidesShown(false);\n      editorSettings.setLineNumbersShown(false);\n      editorSettings.setFoldingOutlineShown(false);\n\n      myEditorAdapter = new EditorAdapter(editor, myProject);\n      final JPanel panel = new JPanel(new BorderLayout());\n      panel.add(editor.getComponent(), BorderLayout.CENTER);\n\n      content = ContentFactory.SERVICE.getInstance().createContent(panel, displayName, true);\n      contentManager.addContent(content);\n\n      for (Pair<String, TextAttributes> pair : myPendingOutput) {\n        myEditorAdapter.appendString(pair.first, pair.second);\n      }\n      myPendingOutput.clear();\n    }\n    return content;\n  }","id":98463,"modified_method":"private Content getOrCreateConsoleContent(final ContentManager contentManager) {\n    final String displayName = VcsBundle.message(\"vcs.console.toolwindow.display.name\");\n    Content content = contentManager.findContent(displayName);\n    if (content == null) {\n      final EditorFactory editorFactory = EditorFactory.getInstance();\n      final Editor editor = editorFactory.createViewer(editorFactory.createDocument(\"\"), myProject);\n      EditorSettings editorSettings = editor.getSettings();\n      editorSettings.setLineMarkerAreaShown(false);\n      editorSettings.setIndentGuidesShown(false);\n      editorSettings.setLineNumbersShown(false);\n      editorSettings.setFoldingOutlineShown(false);\n\n      myEditorAdapter = new EditorAdapter(editor, myProject);\n      final JPanel panel = new JPanel(new BorderLayout());\n      panel.add(editor.getComponent(), BorderLayout.CENTER);\n\n      content = ContentFactory.SERVICE.getInstance().createContent(panel, displayName, true);\n      contentManager.addContent(content);\n\n      for (Pair<String, TextAttributes> pair : myPendingOutput) {\n        myEditorAdapter.appendString(pair.first, pair.second);\n      }\n      myPendingOutput.clear();\n    }\n    return content;\n  }","commit_id":"e1247ba8336e2a5e481c9ad31b626ed1f4b01d01","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public AbstractVcs findVersioningVcs(VirtualFile file) {\n    for (AbstractVcs vcs : getAllVcss()) {\n      if (vcs.isVersionedDirectory(file)) {\n        return vcs;\n      }\n    }\n    return null;\n  }","id":98464,"modified_method":"/**\n   * Used to guess VCS for automatic mapping through a look into a working copy\n   */\n  @Nullable\n  public AbstractVcs findVersioningVcs(VirtualFile file) {\n    final VcsDescriptor[] vcsDescriptors = getAllVcss();\n    VcsDescriptor probableVcs = null;\n    for (VcsDescriptor vcsDescriptor : vcsDescriptors) {\n      if (vcsDescriptor.probablyUnderVcs(file)) {\n        if (probableVcs != null) {\n          return null;\n        }\n        probableVcs = vcsDescriptor;\n      }\n    }\n    return probableVcs == null ? null : findVcsByName(probableVcs.getName());\n  }","commit_id":"e1247ba8336e2a5e481c9ad31b626ed1f4b01d01","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void dispose() {\n    // todo dispose lock is bad here..\n    synchronized (myDisposeLock) {\n      if (myIsDisposed) return;\n\n      if (myEditorAdapter != null) {\n        final Editor editor = myEditorAdapter.getEditor();\n        if (!editor.isDisposed()) {\n          EditorFactory.getInstance().releaseEditor(editor);\n        }\n      }\n      myMappings.disposeMe();\n      try {\n        myContentManager = null;\n\n        ToolWindowManager toolWindowManager = ToolWindowManager.getInstance(myProject);\n        if (toolWindowManager != null && toolWindowManager.getToolWindow(ToolWindowId.VCS) != null) {\n          toolWindowManager.unregisterToolWindow(ToolWindowId.VCS);\n        }\n      }\n      finally {\n        myIsDisposed = true;\n      }\n    }\n  }","id":98465,"modified_method":"private void dispose() {\n    // todo dispose lock is bad here..\n    synchronized (myDisposeLock) {\n      if (myIsDisposed) return;\n\n      myMappings.disposeMe();\n      try {\n        myContentManager = null;\n\n        ToolWindowManager toolWindowManager = ToolWindowManager.getInstance(myProject);\n        if (toolWindowManager != null && toolWindowManager.getToolWindow(ToolWindowId.VCS) != null) {\n          toolWindowManager.unregisterToolWindow(ToolWindowId.VCS);\n        }\n      }\n      finally {\n        myIsDisposed = true;\n      }\n    }\n  }","commit_id":"e1247ba8336e2a5e481c9ad31b626ed1f4b01d01","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AbstractVcs[] getAllVcss() {\n    return AllVcses.getInstance(myProject).getAll();\n  }","id":98466,"modified_method":"public VcsDescriptor[] getAllVcss() {\n    return AllVcses.getInstance(myProject).getAll();\n  }","commit_id":"e1247ba8336e2a5e481c9ad31b626ed1f4b01d01","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void initComponent() {\n    myOptionsAndConfirmations.init(new Convertor<String, VcsShowConfirmationOption.Value>() {\n      public VcsShowConfirmationOption.Value convert(String o) {\n        return mySerialization.getInitOptionValue(o);\n      }\n    });\n  }","id":98467,"modified_method":"public void initComponent() {\n    myOptionsAndConfirmations.init(new Convertor<String, Value>() {\n      public VcsShowConfirmationOption.Value convert(String o) {\n        return mySerialization.getInitOptionValue(o);\n      }\n    });\n  }","commit_id":"e1247ba8336e2a5e481c9ad31b626ed1f4b01d01","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProjectLevelVcsManagerImpl(Project project) {\n    myProject = project;\n    mySerialization = new ProjectLevelVcsManagerSerialization();\n    myOptionsAndConfirmations = new OptionsAndConfirmations();\n\n    myDefaultVcsRootPolicy = DefaultVcsRootPolicy.getInstance(project);\n\n    myBackgroundableActionHandlerMap = new HashMap<VcsBackgroundableActions, BackgroundableActionEnabledHandler>();\n    myInitialization = new VcsInitialization(myProject);\n    myMappings = new NewMappings(myProject, myEventDispatcher, this);\n    myMappingsToRoots = new MappingsToRoots(myMappings, myProject);\n  }","id":98468,"modified_method":"public ProjectLevelVcsManagerImpl(Project project, final FileStatusManager manager) {\n    myProject = project;\n    mySerialization = new ProjectLevelVcsManagerSerialization();\n    myOptionsAndConfirmations = new OptionsAndConfirmations();\n\n    myDefaultVcsRootPolicy = DefaultVcsRootPolicy.getInstance(project);\n\n    myBackgroundableActionHandlerMap = new HashMap<VcsBackgroundableActions, BackgroundableActionEnabledHandler>();\n    myInitialization = new VcsInitialization(myProject);\n    myMappings = new NewMappings(myProject, myEventDispatcher, this, manager);\n    myMappingsToRoots = new MappingsToRoots(myMappings, myProject);\n\n    ProjectManager.getInstance().addProjectManagerListener(myProject, new ProjectManagerAdapter() {\n      @Override\n      public void projectClosing(Project project) {\n        onProjectClosing();\n      }\n    });\n  }","commit_id":"e1247ba8336e2a5e481c9ad31b626ed1f4b01d01","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean isInDirectoryBasedRoot(final VirtualFile file) {\n    if (file == null) return false;\n    final StorageScheme storageScheme = ((ProjectEx) myProject).getStateStore().getStorageScheme();\n    if (StorageScheme.DIRECTORY_BASED.equals(storageScheme)) {\n      final VirtualFile ideaDir = myProject.getBaseDir().findChild(Project.DIRECTORY_STORE_FOLDER);\n      return (ideaDir != null && ideaDir.isValid() && ideaDir.isDirectory() && VfsUtil.isAncestor(ideaDir, file, false));\n    }\n    return false;\n  }","id":98469,"modified_method":"private boolean isInDirectoryBasedRoot(final VirtualFile file) {\n    if (file == null) return false;\n    final StorageScheme storageScheme = ((ProjectEx) myProject).getStateStore().getStorageScheme();\n    if (StorageScheme.DIRECTORY_BASED.equals(storageScheme)) {\n      final VirtualFile baseDir = myProject.getBaseDir();\n      if (baseDir == null) return false;\n      final VirtualFile ideaDir = baseDir.findChild(Project.DIRECTORY_STORE_FOLDER);\n      return (ideaDir != null && ideaDir.isValid() && ideaDir.isDirectory() && VfsUtil.isAncestor(ideaDir, file, false));\n    }\n    return false;\n  }","commit_id":"bf1db01a3217708b2b2e368493f17f808081c601","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected MinimalFileSet getRuntimeFiles() {\n        return emptyLibraryOutputs();\n    }","id":98470,"modified_method":"public FileCollection getRuntimeFiles() {\n        return emptyLibraryOutputs();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected MinimalFileSet getLinkFiles() {\n        return emptyLibraryOutputs();\n    }","id":98471,"modified_method":"public FileCollection getLinkFiles() {\n        return emptyLibraryOutputs();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"protected MinimalFileSet getHeaderDirs() {\n        return new MinimalFileSet() {\n            public String getDisplayName() {\n                return String.format(\"Headers for %s\", getName());\n            }\n\n            public Set<File> getFiles() {\n                Set<File> headerDirs = new LinkedHashSet<File>();\n                for (HeaderExportingSourceSet sourceSet : getSource().withType(HeaderExportingSourceSet.class)) {\n                    headerDirs.addAll(sourceSet.getExportedHeaders().getSrcDirs());\n                }\n                return headerDirs;\n            }\n        };\n    }","id":98472,"modified_method":"public FileCollection getHeaderDirs() {\n        return new AbstractFileCollection() {\n            public String getDisplayName() {\n                return String.format(\"Headers for %s\", getName());\n            }\n\n            public Set<File> getFiles() {\n                Set<File> headerDirs = new LinkedHashSet<File>();\n                for (HeaderExportingSourceSet sourceSet : getSource().withType(HeaderExportingSourceSet.class)) {\n                    headerDirs.addAll(sourceSet.getExportedHeaders().getSrcDirs());\n                }\n                return headerDirs;\n            }\n        };\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"protected MinimalFileSet emptyLibraryOutputs() {\n        return new EmptyLibraryOutputs();\n    }","id":98473,"modified_method":"protected FileCollection emptyLibraryOutputs() {\n        return new EmptyLibraryOutputs();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"private LibraryNativeDependencySet resolve(Set<? extends LibraryBinary> candidates) {\n            for (LibraryBinary candidate : candidates) {\n                if (flavor != null && !flavor.getName().equals(candidate.getFlavor().getName())) {\n                    continue;\n                }\n                if (platform != null && !platform.getName().equals(candidate.getTargetPlatform().getName())) {\n                    continue;\n                }\n                if (buildType != null && !buildType.getName().equals(candidate.getBuildType().getName())) {\n                    continue;\n                }\n\n                return ((LibraryBinaryInternal) candidate).resolve();\n            }\n\n            String typeName = GUtil.elvis(requirement.getLinkage(), \"shared\");\n            throw new InvalidUserDataException(String.format(\"No %s library binary available for library '%s' with [flavor: '%s', platform: '%s']\",\n                    typeName, requirement.getLibraryName(), flavor.getName(), platform.getName()));\n        }","id":98474,"modified_method":"private LibraryNativeDependencySet resolve(Set<? extends LibraryBinary> candidates) {\n            for (LibraryBinary candidate : candidates) {\n                if (flavor != null && !flavor.getName().equals(candidate.getFlavor().getName())) {\n                    continue;\n                }\n                if (platform != null && !platform.getName().equals(candidate.getTargetPlatform().getName())) {\n                    continue;\n                }\n                if (buildType != null && !buildType.getName().equals(candidate.getBuildType().getName())) {\n                    continue;\n                }\n\n                return new DefaultLibraryNativeDependencySet((LibraryBinaryInternal) candidate);\n            }\n\n            String typeName = GUtil.elvis(requirement.getLinkage(), \"shared\");\n            throw new InvalidUserDataException(String.format(\"No %s library binary available for library '%s' with [flavor: '%s', platform: '%s']\",\n                    typeName, requirement.getLibraryName(), flavor.getName(), platform.getName()));\n        }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected MinimalFileSet getRuntimeFiles() {\n        return new SharedLibraryRuntimeOutputs();\n    }","id":98475,"modified_method":"public FileCollection getRuntimeFiles() {\n        return new SharedLibraryRuntimeOutputs();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected MinimalFileSet getLinkFiles() {\n        return new SharedLibraryLinkOutputs();\n    }","id":98476,"modified_method":"public FileCollection getLinkFiles() {\n        return new SharedLibraryLinkOutputs();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected MinimalFileSet getRuntimeFiles() {\n        return emptyLibraryOutputs();\n    }","id":98477,"modified_method":"public FileCollection getRuntimeFiles() {\n        return emptyLibraryOutputs();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected MinimalFileSet getLinkFiles() {\n        return new StaticLibraryLinkOutputs();\n    }","id":98478,"modified_method":"public FileCollection getLinkFiles() {\n        return new StaticLibraryLinkOutputs();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected Collection<File> getLinkFiles() {\n        return Collections.emptySet();\n    }","id":98479,"modified_method":"@Override\n    public FileCollection getLinkFiles() {\n        return new SimpleFileCollection();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected Collection<File> getRuntimeFiles() {\n        return Collections.emptySet();\n    }","id":98480,"modified_method":"@Override\n    public FileCollection getRuntimeFiles() {\n        return new SimpleFileCollection();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected Collection<File> getRuntimeFiles() {\n        return Collections.singleton(getOutputFile());\n    }","id":98481,"modified_method":"public FileCollection getRuntimeFiles() {\n        return new SimpleFileCollection(getOutputFile());\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected Collection<File> getLinkFiles() {\n        return Collections.singleton(getOutputFile());\n    }","id":98482,"modified_method":"public FileCollection getLinkFiles() {\n        return new SimpleFileCollection(getOutputFile());\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected Collection<File> getRuntimeFiles() {\n        return Collections.emptySet();\n    }","id":98483,"modified_method":"public FileCollection getRuntimeFiles() {\n        return new SimpleFileCollection();\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected Collection<File> getLinkFiles() {\n        return Collections.singleton(getOutputFile());\n    }","id":98484,"modified_method":"public FileCollection getLinkFiles() {\n        return new SimpleFileCollection(getOutputFile());\n    }","commit_id":"d8c929970514285e122181ca64a7143220d88503","url":"https://github.com/gradle/gradle"},{"original_method":"@Test public void testW2V_SG_HSM() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"smalldata/text/text8\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 5;\n      parms._wordModel = Word2Vec.WordModel.SkipGram;\n      parms._normModel = Word2Vec.NormModel.HSM;\n      parms._vecSize = 100;\n      parms._windowSize = 5;\n      parms._sentSampleRate = 0.001f;\n      parms._initLearningRate = 0.025f;\n      parms._epochs = 10;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      printResults(w2vm.findSynonyms(\"dog\",5));\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","id":98485,"modified_method":"@Ignore\n  @Test public void testW2V_SG_HSM() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"bigdata/laptop/text8.gz\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 20;\n      parms._wordModel = Word2Vec.WordModel.SkipGram;\n      parms._normModel = Word2Vec.NormModel.HSM;\n      parms._vecSize = 100;\n      parms._windowSize = 4;\n      parms._sentSampleRate = 0.001f;\n      parms._initLearningRate = 0.05f;\n      parms._epochs = 10;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      HashMap hm = w2vm.findSynonyms(\"dog\",10);\n      printResults(hm);\n      Assert.assertTrue(hm.containsKey(\"dogs\"));\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","commit_id":"3272e413a0af438406aba74bb3fa4e3d10a4f515","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test public void testWordCount() {\n    Key wca = null;\n    Frame fr = null;\n    try {\n      long start = System.currentTimeMillis();\n      fr = parse_test_file(\"smalldata/text/text8\");\n      System.out.println(\"Done Parse: \"+(float)(System.currentTimeMillis()-start)/1000+\"s\");\n\n      start = System.currentTimeMillis();\n      wca = (new WordCountTask(3)).doAll(fr)._wordCountKey;\n      System.out.println(\"Done counting: \"+(float)(System.currentTimeMillis()-start)/1000+\"s\");\n      Assert.assertEquals(100038l, ((Frame)wca.get()).numRows());\n    } finally {\n      if( fr  != null ) fr.remove();\n      if( wca != null ) wca.remove();\n    }\n  }","id":98486,"modified_method":"@Test public void testWordCount() {\n    Key wca = null;\n    Frame fr = null;\n    try {\n      long start = System.currentTimeMillis();\n      fr = parse_test_file(\"bigdata/laptop/text8.gz\");\n      System.out.println(\"Done Parse: \"+(float)(System.currentTimeMillis()-start)/1000+\"s\");\n\n      start = System.currentTimeMillis();\n      wca = (new WordCountTask(3)).doAll(fr)._wordCountKey;\n      System.out.println(\"Done counting: \"+(float)(System.currentTimeMillis()-start)/1000+\"s\");\n      Assert.assertEquals(100038l, ((Frame)wca.get()).numRows());\n    } finally {\n      if( fr  != null ) fr.remove();\n      if( wca != null ) wca.remove();\n    }\n  }","commit_id":"3272e413a0af438406aba74bb3fa4e3d10a4f515","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test public void testW2V_SG_NS() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"smalldata/text/text8\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 5;\n      parms._wordModel = Word2Vec.WordModel.SkipGram;\n      parms._normModel = Word2Vec.NormModel.NegSampling;\n      parms._negSampleCnt = 5;\n      parms._vecSize = 100;\n      parms._windowSize = 5;\n      parms._sentSampleRate = 0.001f;\n      parms._initLearningRate = 0.025f;\n      parms._epochs = 10;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      printResults(w2vm.findSynonyms(\"dog\",5));\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","id":98487,"modified_method":"@Ignore\n  @Test public void testW2V_SG_NS() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"bigdata/laptop/text8.gz\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 20;\n      parms._wordModel = Word2Vec.WordModel.SkipGram;\n      parms._normModel = Word2Vec.NormModel.NegSampling;\n      parms._negSampleCnt = 5;\n      parms._vecSize = 100;\n      parms._windowSize = 4;\n      parms._sentSampleRate = 0.001f;\n      parms._initLearningRate = 0.025f;\n      parms._epochs = 15;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      HashMap hm = w2vm.findSynonyms(\"dog\",10);\n      printResults(hm);\n      Assert.assertTrue(hm.containsKey(\"dogs\"));\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","commit_id":"3272e413a0af438406aba74bb3fa4e3d10a4f515","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void printResults(HashMap<String, Float> hm) {\n    TreeMap<Float, String> reversedMap = new TreeMap<Float, String>();\n    for (Map.Entry entry : hm.entrySet())\n      reversedMap.put((Float) entry.getValue(), (String) entry.getKey());\n\n    //then you just access the reversedMap however you like...\n    for (Map.Entry entry : reversedMap.descendingMap().entrySet())\n      System.out.println(entry.getKey() + \", \" + entry.getValue());\n  }","id":98488,"modified_method":"private void printResults(HashMap<String, Float> hm) {\n    TreeMap<Float, String> reversedMap = new TreeMap<Float, String>();\n    for (Map.Entry entry : hm.entrySet())\n      reversedMap.put((Float) entry.getValue(), (String) entry.getKey());\n\n    for (Map.Entry entry : reversedMap.descendingMap().entrySet())\n      Log.info(entry.getKey() + \", \" + entry.getValue());\n  }","commit_id":"3272e413a0af438406aba74bb3fa4e3d10a4f515","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@BeforeClass() public static void setup() { stall_till_cloudsize(1); }","id":98489,"modified_method":"@BeforeClass() public static void setup() { stall_till_cloudsize(5); }","commit_id":"3272e413a0af438406aba74bb3fa4e3d10a4f515","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test public void testW2V_CBOW_HSM() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"smalldata/text/text8\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 5;\n      parms._wordModel = Word2Vec.WordModel.CBOW;\n      parms._normModel = Word2Vec.NormModel.HSM;\n      parms._vecSize = 100;\n      parms._windowSize = 5;\n      parms._sentSampleRate = 0.001f;\n      parms._initLearningRate = 0.05f;\n      parms._epochs = 10;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      printResults(w2vm.findSynonyms(\"dog\",5));\n\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","id":98490,"modified_method":"@Ignore\n  @Test public void testW2V_CBOW_HSM() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"bigdata/laptop/text8.gz\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 20;\n      parms._wordModel = Word2Vec.WordModel.CBOW;\n      parms._normModel = Word2Vec.NormModel.HSM;\n      parms._vecSize = 100;\n      parms._windowSize = 4;\n      parms._sentSampleRate = 0.01f;\n      parms._initLearningRate = 0.05f;\n      parms._epochs = 25;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      HashMap hm = w2vm.findSynonyms(\"dog\",10);\n      printResults(hm);\n      Assert.assertTrue(hm.containsKey(\"dogs\"));\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","commit_id":"3272e413a0af438406aba74bb3fa4e3d10a4f515","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test public void testW2V_CBOW_NS() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"smalldata/text/text8\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 5;\n      parms._wordModel = Word2Vec.WordModel.CBOW;\n      parms._normModel = Word2Vec.NormModel.NegSampling;\n      parms._negSampleCnt = 5;\n      parms._vecSize = 100;\n      parms._windowSize = 5;\n      parms._sentSampleRate = 0.001f;\n      parms._initLearningRate = 0.05f;\n      parms._epochs = 10;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      printResults(w2vm.findSynonyms(\"dog\",5));\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","id":98491,"modified_method":"@Ignore\n  @Test public void testW2V_CBOW_NS() {\n    Word2Vec job = null;\n    Word2VecModel w2vm = null;\n    Frame fr = null;\n    try {\n      fr = parse_test_file(\"bigdata/laptop/text8.gz\");\n\n      Word2VecModel.Word2VecParameters parms = new Word2VecModel.Word2VecParameters();\n      parms._train = fr._key;\n      parms._minWordFreq = 20;\n      parms._wordModel = Word2Vec.WordModel.CBOW;\n      parms._normModel = Word2Vec.NormModel.NegSampling;\n      parms._negSampleCnt = 15;\n      parms._vecSize = 100;\n      parms._windowSize = 4;\n      parms._sentSampleRate = 0.01f;\n      parms._initLearningRate = 0.05f;\n      parms._epochs = 15;\n      job = new Word2Vec(parms);\n      job.train();\n      w2vm = job.get();\n      HashMap hm = w2vm.findSynonyms(\"dog\",10);\n      printResults(hm);\n      Assert.assertTrue(hm.containsKey(\"dogs\"));\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( job != null) job.remove();\n      if( w2vm != null) w2vm.delete();\n    }\n  }","commit_id":"3272e413a0af438406aba74bb3fa4e3d10a4f515","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void execute()\n    {\n        ArtifactRepository localRepo = createLocalArtifactRepository();\n        MavenProjectBuilder builder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n\n        Pom pom = buildPom( builder, localRepo );\n\n        if ( pom == null )\n        {\n            throw new BuildException( \"A POM element is required to deploy to the repository\" );\n        }\n\n        if ( remoteRepository == null )\n        {\n            if ( pom.getDistributionManagement() == null || pom.getDistributionManagement().getRepository() == null )\n            {\n                throw new BuildException( \"A distributionManagement element is required in your POM to deploy\" );\n            }\n\n            remoteRepository = createAntRemoteRepositoryBase( pom.getDistributionManagement().getRepository() );\n        }\n\n        if ( remoteSnapshotRepository == null )\n        {\n            if ( pom.getDistributionManagement().getSnapshotRepository() != null )\n            {\n                remoteSnapshotRepository = createAntRemoteRepositoryBase(\n                    pom.getDistributionManagement().getSnapshotRepository() );\n            }\n        }\n\n        // Deploy the POM\n        Artifact artifact = createArtifact( pom );\n\n        ArtifactRepository deploymentRepository = createRemoteArtifactRepository( remoteRepository );\n\n        if ( remoteSnapshotRepository != null && artifact.isSnapshot() )\n        {\n            deploymentRepository = createRemoteArtifactRepository( remoteSnapshotRepository );\n        }\n\n        boolean isPomArtifact = \"pom\".equals( pom.getPackaging() );\n        if ( !isPomArtifact )\n        {\n            ArtifactMetadata metadata = new ProjectArtifactMetadata( artifact, pom.getFile() );\n            artifact.addMetadata( metadata );\n        }\n\n        log( \"Deploying to \" + deploymentRepository.getUrl() );\n        ArtifactDeployer deployer = (ArtifactDeployer) lookup( ArtifactDeployer.ROLE );\n        try\n        {\n            if ( !isPomArtifact )\n            {\n                deployer.deploy( file, artifact, deploymentRepository, localRepo );\n            }\n            else\n            {\n                deployer.deploy( pom.getFile(), artifact, deploymentRepository, localRepo );\n            }\n        }\n        catch ( ArtifactDeploymentException e )\n        {\n            // TODO: deployment exception that does not give a trace\n            throw new BuildException( \"Error deploying artifact\", e );\n        }\n    }","id":98492,"modified_method":"public void execute()\n    {\n        ArtifactRepository localRepo = createLocalArtifactRepository();\n        MavenProjectBuilder builder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n\n        Pom pom = buildPom( builder, localRepo );\n\n        if ( pom == null )\n        {\n            throw new BuildException( \"A POM element is required to deploy to the repository\" );\n        }\n\n        Artifact artifact = createArtifact( pom );\n\n        DistributionManagement distributionManagement = pom.getDistributionManagement();\n\n        if ( remoteSnapshotRepository == null && remoteRepository == null )\n        {\n            if ( distributionManagement != null )\n            {\n                if ( distributionManagement.getSnapshotRepository() != null )\n                {\n                    remoteSnapshotRepository = createAntRemoteRepositoryBase(\n                        distributionManagement.getSnapshotRepository() );\n                }\n                if ( distributionManagement.getRepository() != null )\n                {\n                    remoteRepository = createAntRemoteRepositoryBase( distributionManagement.getRepository() );\n                }\n            }\n        }\n\n        if ( remoteSnapshotRepository == null )\n        {\n            remoteSnapshotRepository = remoteRepository;\n        }\n\n        ArtifactRepository deploymentRepository = null;\n        if ( artifact.isSnapshot() && remoteSnapshotRepository != null )\n        {\n            deploymentRepository = createRemoteArtifactRepository( remoteSnapshotRepository );\n        }\n        else if ( remoteRepository != null )\n        {\n            deploymentRepository = createRemoteArtifactRepository( remoteRepository );\n        }\n        else\n        {\n            throw new BuildException(\n                \"A distributionManagement element or remoteRepository element is required to deploy\" );\n        }\n\n        // Deploy the POM\n        boolean isPomArtifact = \"pom\".equals( pom.getPackaging() );\n        if ( !isPomArtifact )\n        {\n            ArtifactMetadata metadata = new ProjectArtifactMetadata( artifact, pom.getFile() );\n            artifact.addMetadata( metadata );\n        }\n\n        log( \"Deploying to \" + deploymentRepository.getUrl() );\n        ArtifactDeployer deployer = (ArtifactDeployer) lookup( ArtifactDeployer.ROLE );\n        try\n        {\n            if ( !isPomArtifact )\n            {\n                deployer.deploy( file, artifact, deploymentRepository, localRepo );\n            }\n            else\n            {\n                deployer.deploy( pom.getFile(), artifact, deploymentRepository, localRepo );\n            }\n        }\n        catch ( ArtifactDeploymentException e )\n        {\n            // TODO: deployment exception that does not give a trace\n            throw new BuildException( \"Error deploying artifact\", e );\n        }\n    }","commit_id":"8a6aae6db4f048400b3fe3f78f1869150cdd6dd9","url":"https://github.com/apache/maven"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        ArtifactRepository deploymentRepository =\n            RepositoryUtils.mavenRepositoryToWagonRepository( project.getDistributionManagement().getRepository() );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 project.getType() );\n\n        artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n    }","id":98493,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        \n        //@todo this will be duplicated in case of every mojo which implements deploy goal\n        // this should be pushed into the ArtifactDeployer component\n        DistributionManagement distributionManagement = project.getDistributionManagement();\n        \n        if ( distributionManagement == null )\n        {\n            String msg = \"Deployment failed: distributionManagement element\" + \n                            \" was not specified in the pom\";\n            throw new Exception( msg );\n        }\n        \n        Repository repository = distributionManagement.getRepository();\n        \n        if ( repository == null )\n        {\n            String msg = \"Deployment failed: repository element\" + \n                            \" was not specified in the pom inside\" + \n                            \" distributionManagement element\";\n            throw new Exception( msg );\n         }\n        \n        \n        ArtifactRepository deploymentRepository =\n            RepositoryUtils.mavenRepositoryToWagonRepository( repository );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 project.getType() );\n\n        artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n    }","commit_id":"3b0e7649d80d8e51e77778d2dc2b9355d3682478","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        ArtifactRepository deploymentRepository =\n            RepositoryUtils.mavenRepositoryToWagonRepository( project.getDistributionManagement().getRepository() );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 project.getType() );\n\n        artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n    }","id":98494,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        \n        //@todo this will be duplicated in case of every mojo which implements deploy goal\n        // this should be pushed into the ArtifactDeployer component\n        DistributionManagement distributionManagement = project.getDistributionManagement();\n        \n        if ( distributionManagement == null )\n        {\n            String msg = \"Deployment failed: distributionManagement element\" + \n                            \" was not specified in the pom\";\n            throw new Exception( msg );\n        }\n        \n        Repository repository = distributionManagement.getRepository();\n        \n        if ( repository == null )\n        {\n            String msg = \"Deployment failed: repository element\" + \n                            \" was not specified in the pom inside\" + \n                            \" distributionManagement element\";\n            throw new Exception( msg );\n         }\n        \n        \n        ArtifactRepository deploymentRepository =\n            RepositoryUtils.mavenRepositoryToWagonRepository( repository );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 project.getType() );\n\n        artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n    }","commit_id":"095ac2b60a4578c9732805e5db1cc31f800d548c","url":"https://github.com/apache/maven"},{"original_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    PyFunction problemFunction = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PyFunction.class);\n    if (problemFunction == null) return;\n    PyFunction superInit = mySuper.findMethodByName(PyNames.INIT, false);\n    StringBuilder superCall = new StringBuilder();\n    PyClass klass = problemFunction.getContainingClass();\n    boolean addComma = true;\n    if (klass != null && klass.isNewStyleClass()) {\n      addComma = false;\n      if (LanguageLevel.forElement(klass).isPy3K())\n        superCall.append(\"super().__init__(\");\n      else\n        superCall.append(\"super(\"+klass.getName()+\", self).__init__(\");\n    }\n    else {\n      superCall.append(mySuperName);\n      superCall.append(\".__init__(self\");\n    }\n    StringBuilder newFunction = new StringBuilder(\"def __init__(self\");\n\n    PyParameter[] parameters = problemFunction.getParameterList().getParameters();\n    List<String> problemParams = new ArrayList<String>();\n    List<String> functionParams = new ArrayList<String>();\n    String starName = null;\n    String doubleStarName = null;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      functionParams.add(p.getName());\n      if (p.getText().startsWith(\"**\")) {\n        doubleStarName = p.getText();\n        continue;\n      }\n      if (p.getText().startsWith(\"*\")) {\n        starName = p.getText();\n        continue;\n      }\n      if (p.getDefaultValue() != null) {\n        problemParams.add(p.getText());\n        continue;\n      }\n      newFunction.append(\",\").append(p.getText());\n    }\n\n    parameters = superInit.getParameterList().getParameters();\n    boolean addDouble = false;\n    boolean addStar = false;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      if (p.getDefaultValue() != null) continue;\n      String param;\n      param = p.getText();\n      if (param.startsWith(\"**\")) {\n        addDouble = true;\n        if (doubleStarName == null)\n          doubleStarName = p.getText();\n        continue;\n      }\n      if (param.startsWith(\"*\")) {\n        addStar = true;\n        if (starName == null)\n          starName = p.getText();\n        continue;\n      }\n      if (addComma)\n        superCall.append(\",\");\n      superCall.append(param);\n      if (!functionParams.contains(param))\n        newFunction.append(\",\").append(param);\n      addComma = true;\n    }\n    for(String p : problemParams)\n      newFunction.append(\",\").append(p);\n    if (addStar) {\n      newFunction.append(\",\").append(starName);\n      if (addComma) superCall.append(\",\");\n      superCall.append(starName);\n      addComma = true;\n    }\n    if (addDouble) {\n      if (addComma) superCall.append(\",\");\n      superCall.append(doubleStarName);\n      newFunction.append(\",\").append(doubleStarName);\n    }\n\n    superCall.append(\")\");\n    newFunction.append(\"):\\n\\t\").append(superCall).append(\"\\n\\t\").append(problemFunction.getStatementList().getText());\n\n    problemFunction.replace(\n      PyElementGenerator.getInstance(project).createFromText(LanguageLevel.forElement(problemFunction), PyFunction.class,\n                                                             newFunction.toString()));\n  }","id":98495,"modified_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    PyFunction problemFunction = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PyFunction.class);\n    if (problemFunction == null) return;\n    PyFunction superInit = mySuper.findMethodByName(PyNames.INIT, false);\n    StringBuilder superCall = new StringBuilder();\n    PyClass klass = problemFunction.getContainingClass();\n    boolean addComma = true;\n    if (klass != null && klass.isNewStyleClass()) {\n      addComma = false;\n      if (LanguageLevel.forElement(klass).isPy3K())\n        superCall.append(\"super().__init__(\");\n      else\n        superCall.append(\"super(\"+klass.getName()+\", self).__init__(\");\n    }\n    else {\n      superCall.append(mySuperName);\n      superCall.append(\".__init__(self\");\n    }\n    StringBuilder newFunction = new StringBuilder(\"def __init__(self\");\n\n    PyParameter[] parameters = problemFunction.getParameterList().getParameters();\n    List<String> problemParams = new ArrayList<String>();\n    List<String> functionParams = new ArrayList<String>();\n    String starName = null;\n    String doubleStarName = null;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      functionParams.add(p.getName());\n      if (p.getText().startsWith(\"**\")) {\n        doubleStarName = p.getText();\n        continue;\n      }\n      if (p.getText().startsWith(\"*\")) {\n        starName = p.getText();\n        continue;\n      }\n      if (p.getDefaultValue() != null) {\n        problemParams.add(p.getText());\n        continue;\n      }\n      newFunction.append(\",\").append(p.getText());\n    }\n\n    PyParameterList paramList = superInit.getParameterList();\n    if (paramList == null) return;\n    parameters = paramList.getParameters();\n    boolean addDouble = false;\n    boolean addStar = false;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      if (p.getDefaultValue() != null) continue;\n      String param;\n      param = p.getText();\n      if (param.startsWith(\"**\")) {\n        addDouble = true;\n        if (doubleStarName == null)\n          doubleStarName = p.getText();\n        continue;\n      }\n      if (param.startsWith(\"*\")) {\n        addStar = true;\n        if (starName == null)\n          starName = p.getText();\n        continue;\n      }\n      if (addComma)\n        superCall.append(\",\");\n      superCall.append(param);\n      if (!functionParams.contains(param))\n        newFunction.append(\",\").append(param);\n      addComma = true;\n    }\n    for(String p : problemParams)\n      newFunction.append(\",\").append(p);\n    if (addStar) {\n      newFunction.append(\",\").append(starName);\n      if (addComma) superCall.append(\",\");\n      superCall.append(starName);\n      addComma = true;\n    }\n    if (addDouble) {\n      if (addComma) superCall.append(\",\");\n      superCall.append(doubleStarName);\n      newFunction.append(\",\").append(doubleStarName);\n    }\n\n    superCall.append(\")\");\n    newFunction.append(\"):\\n\\t\").append(superCall).append(\"\\n\\t\").append(problemFunction.getStatementList().getText());\n\n    problemFunction.replace(\n      PyElementGenerator.getInstance(project).createFromText(LanguageLevel.forElement(problemFunction), PyFunction.class,\n                                                             newFunction.toString()));\n  }","commit_id":"1f638756dbcdb55e5bb8219d9d043f7dd703140b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiElement resolveParameter(PyFunction owner) {\n    return owner.getParameterList().findParameterByName(getCanonicalText());\n  }","id":98496,"modified_method":"@Nullable\n  private PsiElement resolveParameter(PyFunction owner) {\n    final PyParameterList parameterList = owner.getParameterList();\n    final PyNamedParameter resolved = parameterList.findParameterByName(getCanonicalText());\n    if (resolved != null) {\n      return resolved;\n    }\n    for (PyParameter parameter : parameterList.getParameters()) {\n      if (parameter instanceof PyNamedParameter) {\n        final PyNamedParameter namedParameter = (PyNamedParameter)parameter;\n        if (namedParameter.isKeywordContainer() || namedParameter.isPositionalContainer()) {\n          return namedParameter;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"f3218869a593a6907e72df9acbff2ad3dc9f59d3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeDefaultNonSecurityClasses() {\r\n    listener.onMessage(\"\\nNon merge mode (-merge=false): removing all default non security classes\");\r\n\r\n    OSchema schema = database.getMetadata().getSchema();\r\n    Collection<OClass> classes = schema.getClasses();\r\n\r\n    final Map<String, OClass> classesToDrop = new HashMap<String, OClass>();\r\n    for (OClass dbClass : classes) {\r\n      String className = dbClass.getName();\r\n      if (!className.equalsIgnoreCase(ORole.CLASS_NAME) && !className.equalsIgnoreCase(OUser.CLASS_NAME)\r\n          && !className.equalsIgnoreCase(OIdentity.CLASS_NAME)) {\r\n        classesToDrop.put(className, dbClass);\r\n      }\r\n    }\r\n\r\n    int removedClasses = 0;\r\n    while (!classesToDrop.isEmpty()) {\r\n      final AbstractList<String> classesReadyToDrop = new ArrayList<String>();\r\n      for (String className : classesToDrop.keySet()) {\r\n        boolean isSuperClass = false;\r\n        for (OClass dbClass : classesToDrop.values()) {\r\n          OClass parentClass = dbClass.getSuperClass();\r\n          if (parentClass != null) {\r\n            if (className.equalsIgnoreCase(parentClass.getName())) {\r\n              isSuperClass = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (!isSuperClass) {\r\n          classesReadyToDrop.add(className);\r\n        }\r\n      }\r\n      for (String className : classesReadyToDrop) {\r\n        schema.dropClass(className);\r\n        classesToDrop.remove(className);\r\n        removedClasses++;\r\n        listener.onMessage(\"\\n- Class \" + className + \" was removed.\");\r\n      }\r\n    }\r\n\r\n    schema.save();\r\n    schema.reload();\r\n\r\n    listener.onMessage(\"\\nRemoved \" + removedClasses + \" classes.\");\r\n  }","id":98497,"modified_method":"private void removeDefaultNonSecurityClasses() {\r\n    listener.onMessage(\"\\nNon merge mode (-merge=false): removing all default non security classes\");\r\n\r\n    OSchema schema = database.getMetadata().getSchema();\r\n    Collection<OClass> classes = schema.getClasses();\r\n    OClass orole = schema.getClass(ORole.CLASS_NAME);\r\n    OClass ouser = schema.getClass(OUser.CLASS_NAME);\r\n    OClass oidentity = schema.getClass(OIdentity.CLASS_NAME);\r\n    final Map<String, OClass> classesToDrop = new HashMap<String, OClass>();\r\n    for (OClass dbClass : classes) {\r\n      String className = dbClass.getName();\r\n\r\n      if (!dbClass.isSuperClassOf(orole) && !dbClass.isSuperClassOf(ouser) && !dbClass.isSuperClassOf(oidentity)) {\r\n        classesToDrop.put(className, dbClass);\r\n      }\r\n    }\r\n\r\n    int removedClasses = 0;\r\n    while (!classesToDrop.isEmpty()) {\r\n      final AbstractList<String> classesReadyToDrop = new ArrayList<String>();\r\n      for (String className : classesToDrop.keySet()) {\r\n        boolean isSuperClass = false;\r\n        for (OClass dbClass : classesToDrop.values()) {\r\n          List<OClass> parentClasses = dbClass.getSuperClasses();\r\n          if (parentClasses != null) {\r\n            for(OClass parentClass:parentClasses) {\r\n              if (className.equalsIgnoreCase(parentClass.getName())) {\r\n                isSuperClass = true;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (!isSuperClass) {\r\n          classesReadyToDrop.add(className);\r\n        }\r\n      }\r\n      for (String className : classesReadyToDrop) {\r\n        schema.dropClass(className);\r\n        classesToDrop.remove(className);\r\n        removedClasses++;\r\n        listener.onMessage(\"\\n- Class \" + className + \" was removed.\");\r\n      }\r\n    }\r\n\r\n    schema.save();\r\n    schema.reload();\r\n\r\n    listener.onMessage(\"\\nRemoved \" + removedClasses + \" classes.\");\r\n  }","commit_id":"5bcf5fa98fe870a76dd7f2eee90a46d20b97812a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@NotNull\n  private static ProblemDescriptor[] convertToProblemDescriptors(@NotNull final List<Annotation> annotations,\n                                                                 @NotNull final InspectionManager manager,\n                                                                 @NotNull final PsiFile file) {\n    if (annotations.isEmpty()) {\n      return ProblemDescriptor.EMPTY_ARRAY;\n    }\n\n    final List<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>();\n    for (final Annotation annotation : annotations) {\n      if (annotation.getSeverity() == HighlightSeverity.INFORMATION ||\n          annotation.getStartOffset() == annotation.getEndOffset()) {\n        continue;\n      }\n\n      final PsiElement startElement = file.findElementAt(annotation.getStartOffset());\n      final PsiElement endElement = file.findElementAt(annotation.getEndOffset() - 1);\n      if (startElement == null || endElement == null) {\n        continue;\n      }\n\n      problems.add(manager.createProblemDescriptor(startElement, endElement, annotation.getMessage(),\n                                                   ProblemHighlightType.GENERIC_ERROR_OR_WARNING, false));\n    }\n    return problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","id":98498,"modified_method":"@NotNull\n  private static ProblemDescriptor[] convertToProblemDescriptors(@NotNull final List<Annotation> annotations,\n                                                                 @NotNull final InspectionManager manager,\n                                                                 @NotNull final PsiFile file) {\n    if (annotations.isEmpty()) {\n      return ProblemDescriptor.EMPTY_ARRAY;\n    }\n\n    final List<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>();\n    for (final Annotation annotation : annotations) {\n      if (annotation.getSeverity() == HighlightSeverity.INFORMATION ||\n          annotation.getStartOffset() == annotation.getEndOffset()) {\n        continue;\n      }\n\n      final PsiElement startElement = file.findElementAt(annotation.getStartOffset());\n      final PsiElement endElement = file.findElementAt(annotation.getEndOffset() - 1);\n      if (startElement == null || endElement == null) {\n        continue;\n      }\n\n      LocalQuickFix[] quickFixes = toLocalQuickFixes(annotation.getQuickFixes(), file);\n      ProblemDescriptor descriptor = manager.createProblemDescriptor(startElement,\n                                                                     endElement,\n                                                                     annotation.getMessage(),\n                                                                     ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                     false,\n                                                                     quickFixes);\n      problems.add(descriptor);\n    }\n    return problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","commit_id":"769a5993175e7825ace03303600962c1314b0d88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public ProblemDescriptor[] checkMethod(PsiMethod psiMethod, InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiMethod.isDeprecated() || psiMethod.getContainingClass().isDeprecated())) {\n      return null;\n    }\n    PsiDocComment docComment = psiMethod.getDocComment();\n    if (docComment == null) {\n      if (isJavaDocRequired(psiMethod)) {\n        PsiMethod[] superMethods = psiMethod.findSuperMethods();\n        if (superMethods.length > 0) return null;\n        if (EjbRolesUtil.getEjbRole(psiMethod) instanceof EjbImplMethodRole) return null;\n        return superMethods.length == 0\n               ? new ProblemDescriptor[]{createDescriptor(psiMethod.getNameIdentifier(), JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT)}\n               : null;\n      }\n      else {\n        return null;\n      }\n    }\n\n    final PsiElement[] descriptionElements = docComment.getDescriptionElements();\n    for (PsiElement descriptionElement : descriptionElements) {\n      if (descriptionElement instanceof PsiInlineDocTag) {\n        if (\"inheritDoc\".equals(((PsiInlineDocTag)descriptionElement).getName())) return null;\n      }\n    }\n\n    if (docComment.findTagByName(\"inheritDoc\") != null) return null;\n\n    PsiDocTag[] tags = docComment.getTags();\n\n    boolean isReturnRequired = false;\n    boolean isReturnAbsent = true;\n    if (!psiMethod.isConstructor() && PsiType.VOID != psiMethod.getReturnType() && isTagRequired(psiMethod, \"return\")) {\n      isReturnRequired = true;\n      for (PsiDocTag tag : tags) {\n        if (\"return\".equals(tag.getName())) {\n          isReturnAbsent = false;\n          break;\n        }\n      }\n    }\n\n    ArrayList<PsiParameter> absentParameters = null;\n    if (isTagRequired(psiMethod, \"param\")) {\n      PsiParameter[] params = psiMethod.getParameterList().getParameters();\n      for (PsiParameter param : params) {\n        boolean found = false;\n        for (PsiDocTag tag : tags) {\n          if (\"param\".equals(tag.getName())) {\n            PsiDocTagValue value = tag.getValueElement();\n            if (value instanceof PsiDocParamRef) {\n              PsiDocParamRef paramRef = (PsiDocParamRef)value;\n              if (paramRef.getReference().isReferenceTo(param)) {\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (!found) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiParameter>(2);\n          absentParameters.add(param);\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> problems = null;\n\n    if (isReturnRequired && isReturnAbsent) {\n      problems = new ArrayList<ProblemDescriptor>(2);\n      problems.add(createDescriptor(psiMethod.getNameIdentifier(), InspectionsBundle.message(\"inspection.javadoc.problem.descriptor2\", \"<code>@return<\/code>\")));\n    }\n\n    if (absentParameters != null) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      for (PsiParameter psiParameter : absentParameters) {\n        problems.add(createDescriptor(psiMethod.getNameIdentifier(),\n                                      InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor3\", \"<code>@param<\/code>\",\n                                                                \"<code>\" + psiParameter.getName() + \"<\/code>\")));\n      }\n    }\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName()) && tag.getDataElements().length < 2) {\n        if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        if (valueElement != null) {\n          problems.add(createDescriptor(psiMethod.getNameIdentifier(),\n                                        InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor2\", \"<code>@param \" + valueElement.getText() + \"<\/code>\")));\n        }\n      }\n    }\n\n    if (isTagRequired(psiMethod, \"@throws\") && psiMethod.getThrowsList().getReferencedTypes().length > 0) {\n      boolean found = false;\n      for (PsiDocTag tag : tags) {\n        if (\"throws\".equals(tag.getName()) || \"exception\".equals(tag.getName())) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n        problems.add(createDescriptor(psiMethod.getNameIdentifier(), InspectionsBundle.message(\"inspection.javadoc.problem.descriptor2\", \"<code>@throws<\/code>\")));\n      }\n    }\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiMethod, tags);\n    if (tagProblems != null) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      problems.addAll(tagProblems);\n    }\n\n    problems = checkForPeriodInDoc(docComment, docComment, problems);\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {\n          PsiDocTagValue value = tag.getValueElement();\n          if (value instanceof PsiDocParamRef) {\n            PsiDocParamRef paramRef = (PsiDocParamRef)value;\n            PsiParameter[] params = psiMethod.getParameterList().getParameters();\n            for (PsiParameter param : params) {\n              if (paramRef.getReference().isReferenceTo(param)) {\n                if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n                problems.add(createDescriptor(psiMethod.getNameIdentifier(),\n                                              InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor\", \"<code>@param<\/code>\", \"<code>\" + param.getName() + \"<\/code>\")));\n              }\n            }\n          }\n        }\n      }\n      else\n        if (\"return\".equals(tag.getName())) {\n          if (extractTagDescription(tag).length() == 0) {\n            if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n            problems.add(manager.createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor1\", \"<code>@return<\/code>\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true));\n          }\n        }\n    }\n\n    problems = checkDuplicateTags(tags, problems);\n\n    return problems == null\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","id":98499,"modified_method":"@Nullable\n  public ProblemDescriptor[] checkMethod(PsiMethod psiMethod, InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiMethod.isDeprecated() || psiMethod.getContainingClass().isDeprecated())) {\n      return null;\n    }\n    PsiDocComment docComment = psiMethod.getDocComment();\n    if (docComment == null) {\n      if (isJavaDocRequired(psiMethod)) {\n        PsiMethod[] superMethods = psiMethod.findSuperMethods();\n        if (superMethods.length > 0) return null;\n        if (EjbRolesUtil.getEjbRole(psiMethod) instanceof EjbImplMethodRole) return null;\n        return superMethods.length == 0\n               ? new ProblemDescriptor[]{createDescriptor(psiMethod.getNameIdentifier(), JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT)}\n               : null;\n      }\n      else {\n        return null;\n      }\n    }\n\n    final PsiElement[] descriptionElements = docComment.getDescriptionElements();\n    for (PsiElement descriptionElement : descriptionElements) {\n      if (descriptionElement instanceof PsiInlineDocTag) {\n        if (\"inheritDoc\".equals(((PsiInlineDocTag)descriptionElement).getName())) return null;\n      }\n    }\n\n    if (docComment.findTagByName(\"inheritDoc\") != null) return null;\n\n    PsiDocTag[] tags = docComment.getTags();\n\n    boolean isReturnRequired = false;\n    boolean isReturnAbsent = true;\n    if (!psiMethod.isConstructor() && PsiType.VOID != psiMethod.getReturnType() && isTagRequired(psiMethod, \"return\")) {\n      isReturnRequired = true;\n      for (PsiDocTag tag : tags) {\n        if (\"return\".equals(tag.getName())) {\n          isReturnAbsent = false;\n          break;\n        }\n      }\n    }\n\n    ArrayList<PsiParameter> absentParameters = null;\n    if (isTagRequired(psiMethod, \"param\")) {\n      PsiParameter[] params = psiMethod.getParameterList().getParameters();\n      for (PsiParameter param : params) {\n        boolean found = false;\n        for (PsiDocTag tag : tags) {\n          if (\"param\".equals(tag.getName())) {\n            PsiDocTagValue value = tag.getValueElement();\n            if (value instanceof PsiDocParamRef) {\n              PsiDocParamRef paramRef = (PsiDocParamRef)value;\n              if (paramRef.getReference().isReferenceTo(param)) {\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (!found) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiParameter>(2);\n          absentParameters.add(param);\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> problems = null;\n\n    if (isReturnRequired && isReturnAbsent) {\n      problems = new ArrayList<ProblemDescriptor>(2);\n\n      ProblemDescriptor descriptor = createMissingTagDescriptor(psiMethod.getNameIdentifier(), \"return\");\n      problems.add(descriptor);\n    }\n\n    if (absentParameters != null) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      for (PsiParameter psiParameter : absentParameters) {\n        ProblemDescriptor descriptor = createMissingParamTagDescriptor(psiMethod.getNameIdentifier(), psiParameter.getName());\n        problems.add(descriptor);\n      }\n    }\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName()) && tag.getDataElements().length < 2) {\n        if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        if (valueElement != null) {\n          problems.add(createDescriptor(psiMethod.getNameIdentifier(),\n                                        InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@param \" + valueElement.getText() + \"<\/code>\")));\n        }\n      }\n    }\n\n    if (isTagRequired(psiMethod, \"@throws\") && psiMethod.getThrowsList().getReferencedTypes().length > 0) {\n      boolean found = false;\n      for (PsiDocTag tag : tags) {\n        if (\"throws\".equals(tag.getName()) || \"exception\".equals(tag.getName())) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n        ProblemDescriptor descriptor = createMissingThrowsTagDescriptor(psiMethod);\n        problems.add(descriptor);\n      }\n    }\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiMethod, tags);\n    if (tagProblems != null) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      problems.addAll(tagProblems);\n    }\n\n    problems = checkForPeriodInDoc(docComment, docComment, problems);\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {\n          PsiDocTagValue value = tag.getValueElement();\n          if (value instanceof PsiDocParamRef) {\n            PsiDocParamRef paramRef = (PsiDocParamRef)value;\n            PsiParameter[] params = psiMethod.getParameterList().getParameters();\n            for (PsiParameter param : params) {\n              if (paramRef.getReference().isReferenceTo(param)) {\n                if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n                problems.add(createDescriptor(psiMethod.getNameIdentifier(),\n                                              InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor\", \"<code>@param<\/code>\", \"<code>\" + param.getName() + \"<\/code>\")));\n              }\n            }\n          }\n        }\n      }\n      else\n        if (\"return\".equals(tag.getName())) {\n          if (extractTagDescription(tag).length() == 0) {\n            if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n            String message = InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@return<\/code>\");\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(tag, message, null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true);\n            problems.add(descriptor);\n          }\n        }\n    }\n\n    problems = checkDuplicateTags(tags, problems);\n\n    return problems == null\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","commit_id":"1dc89fa3631a4cb86290b032a2abc75658606d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ProblemDescriptor createDescriptor(@NotNull PsiElement element, String template, LocalQuickFix fix) {\n    return InspectionManager.getInstance(element.getProject()).createProblemDescriptor(element, template, new LocalQuickFix []{fix}, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n  }","id":98500,"modified_method":"private static ProblemDescriptor createDescriptor(@NotNull PsiElement element, String template, @NotNull LocalQuickFix fix) {\n    return InspectionManager.getInstance(element.getProject()).createProblemDescriptor(element, template, fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n  }","commit_id":"1dc89fa3631a4cb86290b032a2abc75658606d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ArrayList<ProblemDescriptor> getTagValuesProblems(PsiDocCommentOwner context, PsiDocTag[] tags) {\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    nextTag:\n    for (PsiDocTag tag : tags) {\n      final JavadocManager manager = tag.getManager().getJavadocManager();\n      String tagName = tag.getName();\n      JavadocTagInfo tagInfo = manager.getTagInfo(tagName);\n\n      if (tagInfo == null || !tagInfo.isValidInContext(context)) {\n        final StringTokenizer tokenizer = new StringTokenizer(myAdditionalJavadocTags, \", \");\n        while (tokenizer.hasMoreTokens()) {\n          if (tagName.equals(tokenizer.nextToken())) continue nextTag;\n        }\n\n        if (tagInfo == null){\n          problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.descriptor10\", \"<code>\" + tagName + \"<\/code>\"), new AddUnknownTagToCustoms(tag)));\n        } else {\n          problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.descriptor11\", \"<code>\" + tagName + \"<\/code>\"), new AddUnknownTagToCustoms(tag)));\n        }\n\n      }\n\n      PsiDocTagValue value = tag.getValueElement();\n      final JavadocTagInfo info = manager.getTagInfo(tagName);\n      if (info != null && !info.isValidInContext(context)) continue;\n      String message = info == null ? null : info.checkTagValue(value);\n\n      final PsiReference reference = value != null ? value.getReference() : null;\n      if (message == null && reference != null) {\n        PsiElement element = reference.resolve();\n        if (element == null) {\n          final int textOffset = value.getTextOffset();\n\n          if (textOffset == value.getTextRange().getEndOffset()) {\n            problems.add(InspectionManager.getInstance(tag.getProject()).createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor9\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true));\n          }\n        }\n      }\n\n      if (message != null) {\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        if (valueElement == null){\n          problems.add(InspectionManager.getInstance(tag.getProject()).createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor1\", \"<code>\" + tag.getName() + \"<\/code>\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true));\n        } else {\n          problems.add(createDescriptor(valueElement, message));\n        }\n      }\n    }\n\n    return problems.isEmpty() ? null : problems;\n  }","id":98501,"modified_method":"private ArrayList<ProblemDescriptor> getTagValuesProblems(PsiDocCommentOwner context, PsiDocTag[] tags) {\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    nextTag:\n    for (PsiDocTag tag : tags) {\n      final JavadocManager manager = tag.getManager().getJavadocManager();\n      String tagName = tag.getName();\n      JavadocTagInfo tagInfo = manager.getTagInfo(tagName);\n\n      if (tagInfo == null || !tagInfo.isValidInContext(context)) {\n        final StringTokenizer tokenizer = new StringTokenizer(myAdditionalJavadocTags, \", \");\n        while (tokenizer.hasMoreTokens()) {\n          if (tagName.equals(tokenizer.nextToken())) continue nextTag;\n        }\n\n        if (tagInfo == null){\n          problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.wrong.tag\", \"<code>\" + tagName + \"<\/code>\"), new AddUnknownTagToCustoms(tag)));\n        } else {\n          problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.disallowed.tag\", \"<code>\" + tagName + \"<\/code>\"), new AddUnknownTagToCustoms(tag)));\n        }\n\n      }\n\n      PsiDocTagValue value = tag.getValueElement();\n      final JavadocTagInfo info = manager.getTagInfo(tagName);\n      if (info != null && !info.isValidInContext(context)) continue;\n      String message = info == null ? null : info.checkTagValue(value);\n\n      final PsiReference reference = value != null ? value.getReference() : null;\n      if (message == null && reference != null) {\n        PsiElement element = reference.resolve();\n        if (element == null) {\n          final int textOffset = value.getTextOffset();\n\n          if (textOffset == value.getTextRange().getEndOffset()) {\n            problems.add(InspectionManager.getInstance(tag.getProject()).createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.problem.name.expected\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true));\n          }\n        }\n      }\n\n      if (message != null) {\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        if (valueElement == null){\n          problems.add(InspectionManager.getInstance(tag.getProject()).createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>\" + tag.getName() + \"<\/code>\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true));\n        } else {\n          problems.add(createDescriptor(valueElement, message));\n        }\n      }\n    }\n\n    return problems.isEmpty() ? null : problems;\n  }","commit_id":"1dc89fa3631a4cb86290b032a2abc75658606d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public ProblemDescriptor[] checkClass(PsiClass psiClass, InspectionManager manager, boolean isOnTheFly) {\n    if (psiClass instanceof PsiAnonymousClass) return null;\n    if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {\n      return null;\n    }\n    PsiDocComment docComment = psiClass.getDocComment();\n    final PsiIdentifier nameIdentifier = psiClass.getNameIdentifier();\n    final PsiElement elementToHighlight = nameIdentifier != null ? nameIdentifier : psiClass;\n    if (docComment == null) {\n      return isJavaDocRequired(psiClass)\n             ? new ProblemDescriptor[]{createDescriptor(elementToHighlight, JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT)}\n             : null;\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n\n    boolean isAuthorRequired = isTagRequired(psiClass, \"author\");\n    boolean isVersionRequired = isTagRequired(psiClass, \"version\");\n    boolean isSinceRequired = isTagRequired(psiClass, \"since\");\n\n    boolean isAuthorAbsent = true;\n    boolean isVersionAbsent = true;\n    boolean isSinceAbsent = true;\n\n    if (isAuthorRequired || isVersionRequired) {\n      for (int i = 0; i < tags.length && (isAuthorAbsent || isVersionAbsent || isSinceAbsent); i++) {\n        PsiDocTag tag = tags[i];\n        if (\"author\".equals(tag.getName())) isAuthorAbsent = false;\n        if (\"version\".equals(tag.getName())) isVersionAbsent = false;\n        if (\"since\".equals(tag.getName())) isSinceAbsent = false;\n      }\n    }\n\n    ArrayList<ProblemDescriptor> problems = null;\n\n\n    if (isAuthorRequired && isAuthorAbsent) {\n      problems = new ArrayList<ProblemDescriptor>(2);\n      problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor2\", \"<code>@author<\/code>\")));\n    }\n\n    if (isVersionRequired && isVersionAbsent) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor2\", \"<code>@version<\/code>\")));\n    }\n\n    if (isSinceRequired && isSinceAbsent) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor2\", \"<code>@since<\/code>\")));\n    }\n\n    problems = checkForPeriodInDoc(docComment, docComment, problems);\n\n    for (PsiDocTag tag : tags) {\n      if (\"author\".equals(tag.getName())) {\n        if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {\n          if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n          problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor5\")));\n        }\n      }\n      else\n        if (\"version\".equals(tag.getName())) {\n          if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {\n            if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n            problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor6\")));\n          }\n        }\n        else\n          if (\"since\".equals(tag.getName())) {\n            if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {\n              if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n              problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor7\")));\n            }\n          }\n    }\n\n    problems = checkDuplicateTags(tags, problems);\n\n    return problems == null\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","id":98502,"modified_method":"@Nullable\n  public ProblemDescriptor[] checkClass(PsiClass psiClass, InspectionManager manager, boolean isOnTheFly) {\n    if (psiClass instanceof PsiAnonymousClass) return null;\n    if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {\n      return null;\n    }\n    PsiDocComment docComment = psiClass.getDocComment();\n    final PsiIdentifier nameIdentifier = psiClass.getNameIdentifier();\n    final PsiElement elementToHighlight = nameIdentifier != null ? nameIdentifier : psiClass;\n    if (docComment == null) {\n      return isJavaDocRequired(psiClass)\n             ? new ProblemDescriptor[]{createDescriptor(elementToHighlight, JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT)}\n             : null;\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n    @NonNls String[] tagsToCheck = {\"author\", \"version\", \"since\"};\n    @NonNls String[] absentDescriptionKeys = {\n      \"inspection.javadoc.problem.missing.author.description\",\n      \"inspection.javadoc.problem.missing.version.description\",\n      \"inspection.javadoc.problem.missing.since.description\"};\n\n    boolean[] isTagRequired = new boolean[tagsToCheck.length];\n    boolean[] isTagPresent = new boolean[tagsToCheck.length];\n\n    boolean someTagsAreRequired = false;\n    for (int i = 0; i < tagsToCheck.length; i++) {\n      final String tag = tagsToCheck[i];\n      someTagsAreRequired |= isTagRequired[i] = isTagRequired(psiClass, tag);\n    }\n\n    if (someTagsAreRequired) {\n      for (PsiDocTag tag : tags) {\n        String tagName = tag.getName();\n        for (int i = 0; i < tagsToCheck.length; i++) {\n          final String tagToCheck = tagsToCheck[i];\n          if (tagToCheck.equals(tagName)) {\n            isTagPresent[i] = true;\n          }\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> problems = null;\n\n    for (int i = 0; i < tagsToCheck.length; i++) {\n      final String tagToCheck = tagsToCheck[i];\n      if (isTagRequired[i] && !isTagPresent[i]) {\n        problems = new ArrayList<ProblemDescriptor>(2);\n        ProblemDescriptor descriptor = createMissingTagDescriptor(elementToHighlight, tagToCheck);\n        problems.add(descriptor);\n      }\n    }\n    problems = checkForPeriodInDoc(docComment, docComment, problems);\n\n    for (PsiDocTag tag : tags) {\n      for (int i = 0; i < tagsToCheck.length; i++) {\n        final String tagToCheck = tagsToCheck[i];\n        if (tagToCheck.equals(tag.getName()) && JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {\n          if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n          problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(absentDescriptionKeys[i])));\n        }\n      }\n    }\n\n    problems = checkDuplicateTags(tags, problems);\n\n    return problems == null\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","commit_id":"1dc89fa3631a4cb86290b032a2abc75658606d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OptionsPanel() {\n      super(new GridBagLayout());\n      GridBagConstraints gc = new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0,0,0,0),0,0 );\n      gc.weighty = 0;\n      add(createAdditionalJavadocTagsPanel(), gc);\n      JTabbedPane tabs = new JTabbedPane(JTabbedPane.BOTTOM);\n      @NonNls String[] tags = new String[]{\"@author\", \"@version\", \"@since\"};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PACKAGE_LOCAL},\n                                                                                                    tags,\n                                                                                                    TOP_LEVEL_CLASS_OPTIONS));\n      tags = new String[]{\"@return\", \"@param\", InspectionsBundle.message(\"inspection.javadoc.throws.or.exception.option\")};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title1\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PROTECTED, JavaDocLocalInspection.PACKAGE_LOCAL, JavaDocLocalInspection.PRIVATE},\n                                                                                                     tags,\n                                                                                                     METHOD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title2\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PROTECTED, JavaDocLocalInspection.PACKAGE_LOCAL, JavaDocLocalInspection.PRIVATE},\n                                                                                                     null,\n                                                                                                     FIELD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title3\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PROTECTED, JavaDocLocalInspection.PACKAGE_LOCAL, JavaDocLocalInspection.PRIVATE},\n                                                                                                     null,\n                                                                                                     INNER_CLASS_OPTIONS));\n      add(tabs, gc);\n\n      final JCheckBox checkBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.deprecated\"),\n                                               IGNORE_DEPRECATED);\n      checkBox.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          IGNORE_DEPRECATED = checkBox.isSelected();\n        }\n      });\n      gc.gridwidth = 1;\n      add(checkBox, gc);\n      final JCheckBox periodCheckBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.period\"),\n                                                     IGNORE_JAVADOC_PERIOD);\n      checkBox.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          IGNORE_JAVADOC_PERIOD = periodCheckBox.isSelected();\n        }\n      });\n      add(periodCheckBox, gc);\n    }","id":98503,"modified_method":"public OptionsPanel() {\n      super(new GridBagLayout());\n      GridBagConstraints gc = new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0,0,0,0),0,0 );\n      gc.weighty = 0;\n      add(createAdditionalJavadocTagsPanel(), gc);\n      JTabbedPane tabs = new JTabbedPane(JTabbedPane.BOTTOM);\n      @NonNls String[] tags = new String[]{\"@author\", \"@version\", \"@since\"};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PACKAGE_LOCAL},\n                                                                                                    tags,\n                                                                                                    TOP_LEVEL_CLASS_OPTIONS));\n      tags = new String[]{\"@return\", \"@param\", InspectionsBundle.message(\"inspection.javadoc.throws.or.exception.option\")};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.method\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PROTECTED, JavaDocLocalInspection.PACKAGE_LOCAL, JavaDocLocalInspection.PRIVATE},\n                                                                                                           tags,\n                                                                                                           METHOD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.field\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PROTECTED, JavaDocLocalInspection.PACKAGE_LOCAL, JavaDocLocalInspection.PRIVATE},\n                                                                                                          null,\n                                                                                                          FIELD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.inner.class\"), createOptionsPanel(new String[]{JavaDocLocalInspection.NONE, JavaDocLocalInspection.PUBLIC, JavaDocLocalInspection.PROTECTED, JavaDocLocalInspection.PACKAGE_LOCAL, JavaDocLocalInspection.PRIVATE},\n                                                                                                                null,\n                                                                                                                INNER_CLASS_OPTIONS));\n      add(tabs, gc);\n\n      final JCheckBox checkBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.deprecated\"),\n                                               IGNORE_DEPRECATED);\n      checkBox.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          IGNORE_DEPRECATED = checkBox.isSelected();\n        }\n      });\n      gc.gridwidth = 1;\n      add(checkBox, gc);\n      final JCheckBox periodCheckBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.period\"),\n                                                     IGNORE_JAVADOC_PERIOD);\n      checkBox.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          IGNORE_JAVADOC_PERIOD = periodCheckBox.isSelected();\n        }\n      });\n      add(periodCheckBox, gc);\n    }","commit_id":"1dc89fa3631a4cb86290b032a2abc75658606d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitRefInDocTag(final PsiDocTag tag,\n                                  final JavadocManager manager,\n                                  final PsiElement context,\n                                  ArrayList<ProblemDescriptor> problems) {\n    String tagName = tag.getName();\n    PsiDocTagValue value = tag.getValueElement();\n    if (value == null) return;\n    final JavadocTagInfo info = manager.getTagInfo(tagName);\n    if (info != null && !info.isValidInContext(context)) return;\n    String message = info == null || !info.isInline() ? null : info.checkTagValue(value);\n    if (message != null){\n      problems.add(createDescriptor(value, message));\n    }\n    final PsiReference reference = value.getReference();\n    if (reference != null) {\n      PsiElement element = reference.resolve();\n      if (element == null) {\n        final int textOffset = value.getTextOffset();\n\n        if (textOffset != value.getTextRange().getEndOffset()) {\n          if (problems == null) problems = new ArrayList<ProblemDescriptor>();\n          final PsiDocTagValue valueElement = tag.getValueElement();\n          if (valueElement != null) {\n            problems.add(createDescriptor(valueElement, InspectionsBundle.message(\"inspection.javadoc.problem.descriptor8\",\n                                                                                  \"<code>\" +\n                                                                                  new String(value.getContainingFile().textToCharArray(),\n                                                                                             textOffset,\n                                                                                             value.getTextRange().getEndOffset() - textOffset) +\n                                                                                   \"<\/code>\")));\n          }\n        }\n      }\n    }\n  }","id":98504,"modified_method":"public void visitRefInDocTag(final PsiDocTag tag,\n                                  final JavadocManager manager,\n                                  final PsiElement context,\n                                  ArrayList<ProblemDescriptor> problems) {\n    String tagName = tag.getName();\n    PsiDocTagValue value = tag.getValueElement();\n    if (value == null) return;\n    final JavadocTagInfo info = manager.getTagInfo(tagName);\n    if (info != null && !info.isValidInContext(context)) return;\n    String message = info == null || !info.isInline() ? null : info.checkTagValue(value);\n    if (message != null){\n      problems.add(createDescriptor(value, message));\n    }\n    final PsiReference reference = value.getReference();\n    if (reference != null) {\n      PsiElement element = reference.resolve();\n      if (element == null) {\n        final int textOffset = value.getTextOffset();\n\n        if (textOffset != value.getTextRange().getEndOffset()) {\n          if (problems == null) problems = new ArrayList<ProblemDescriptor>();\n          final PsiDocTagValue valueElement = tag.getValueElement();\n          if (valueElement != null) {\n            @NonNls String params = \"<code>\" + new String(value.getContainingFile().textToCharArray(), textOffset, value.getTextRange().getEndOffset() - textOffset) + \"<\/code>\";\n            problems.add(createDescriptor(valueElement, InspectionsBundle.message(\"inspection.javadoc.problem.cannot.resolve\", params)));\n          }\n        }\n      }\n    }\n  }","commit_id":"1dc89fa3631a4cb86290b032a2abc75658606d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiElementVisitor getVisitor(final PsiJavaCodeReferenceElement[] references,\n                                       final String[] refMessage,\n                                       final PsiElement context,\n                                       final ArrayList<ProblemDescriptor> problems) {\n    return new PsiElementVisitor() {\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        visitElement(expression);\n      }\n\n      public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n        super.visitReferenceElement(reference);\n        PsiElement resolved = reference.resolve();\n        if (resolved == null) {\n          refMessage[0] = InspectionsBundle.message(\"inspection.javadoc.problem.descriptor8\", \"<code>\" + reference.getText() + \"<\/code>\");\n          references[0] = reference;\n        }\n      }\n\n      public void visitDocTag(PsiDocTag tag) {\n        super.visitDocTag(tag);\n        final JavadocManager javadocManager = tag.getManager().getJavadocManager();\n        final JavadocTagInfo info = javadocManager.getTagInfo(tag.getName());\n        if (info == null || !info.isInline()) {\n          visitRefInDocTag(tag, javadocManager, context, problems);\n        }\n      }\n\n      public void visitInlineDocTag(PsiInlineDocTag tag) {\n        super.visitInlineDocTag(tag);\n        final JavadocManager javadocManager = tag.getManager().getJavadocManager();\n        visitRefInDocTag(tag, javadocManager, context, problems);\n      }\n\n      public void visitElement(PsiElement element) {\n        PsiElement[] children = element.getChildren();\n        for (PsiElement child : children) {\n          //do not visit method javadoc twice\n          if (!(child instanceof PsiDocCommentOwner)) {\n            child.accept(this);\n          }\n        }\n      }\n\n      public void visitDocComment(PsiDocComment comment) {\n        super.visitDocComment(comment);\n        /*final PsiElement[] descriptionElements = comment.getDescriptionElements();\n        for (PsiElement element : descriptionElements) {\n          element.accept(this);\n        }*/\n      }\n    };\n  }","id":98505,"modified_method":"private PsiElementVisitor getVisitor(final PsiJavaCodeReferenceElement[] references,\n                                       final String[] refMessage,\n                                       final PsiElement context,\n                                       final ArrayList<ProblemDescriptor> problems) {\n    return new PsiElementVisitor() {\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        visitElement(expression);\n      }\n\n      public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n        super.visitReferenceElement(reference);\n        PsiElement resolved = reference.resolve();\n        if (resolved == null) {\n          refMessage[0] = InspectionsBundle.message(\"inspection.javadoc.problem.cannot.resolve\", \"<code>\" + reference.getText() + \"<\/code>\");\n          references[0] = reference;\n        }\n      }\n\n      public void visitDocTag(PsiDocTag tag) {\n        super.visitDocTag(tag);\n        final JavadocManager javadocManager = tag.getManager().getJavadocManager();\n        final JavadocTagInfo info = javadocManager.getTagInfo(tag.getName());\n        if (info == null || !info.isInline()) {\n          visitRefInDocTag(tag, javadocManager, context, problems);\n        }\n      }\n\n      public void visitInlineDocTag(PsiInlineDocTag tag) {\n        super.visitInlineDocTag(tag);\n        final JavadocManager javadocManager = tag.getManager().getJavadocManager();\n        visitRefInDocTag(tag, javadocManager, context, problems);\n      }\n\n      public void visitElement(PsiElement element) {\n        PsiElement[] children = element.getChildren();\n        for (PsiElement child : children) {\n          //do not visit method javadoc twice\n          if (!(child instanceof PsiDocCommentOwner)) {\n            child.accept(this);\n          }\n        }\n      }\n\n      public void visitDocComment(PsiDocComment comment) {\n        super.visitDocComment(comment);\n        /*final PsiElement[] descriptionElements = comment.getDescriptionElements();\n        for (PsiElement element : descriptionElements) {\n          element.accept(this);\n        }*/\n      }\n    };\n  }","commit_id":"1dc89fa3631a4cb86290b032a2abc75658606d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private CommonProblemDescriptor[] checkElement(RefClass refEntity, InspectionManager manager, final Project project) {\n    final PsiElement psiElement = refEntity.getElement();\n    final Map<PsiElement, Collection<String>> suppressedScopes = new THashMap<PsiElement, Collection<String>>();\n    psiElement.accept(new PsiRecursiveElementVisitor() {\n      public void visitModifierList(PsiModifierList list) {\n        super.visitModifierList(list);\n        final PsiElement parent = list.getParent();\n        if (parent instanceof PsiModifierListOwner && !(parent instanceof PsiClass)) {\n          checkElement(parent);\n        }\n      }\n\n      public void visitComment(PsiComment comment) {\n        checkElement(comment);\n      }\n\n      public void visitClass(PsiClass aClass) {\n        if (aClass == psiElement) {\n          super.visitClass(aClass);\n          checkElement(aClass);\n        }\n      }\n\n\n      private void checkElement(final PsiElement owner) {\n        String idsString = InspectionManagerEx.getSuppressedInspectionIdsIn(owner);\n        if (idsString != null && idsString.length() != 0) {\n          List<String> ids = StringUtil.split(idsString, \",\");\n          Collection<String> suppressed = suppressedScopes.get(owner);\n          if (suppressed == null) {\n            suppressed = ids;\n          }\n          else {\n            for (String id : ids) {\n              if (!suppressed.contains(id)) {\n                suppressed.add(id);\n              }\n            }\n          }\n          suppressedScopes.put(owner, suppressed);\n        }\n      }\n    });\n\n    if (suppressedScopes.values().isEmpty()) return null;\n    // have to visit all file from scratch since inspections can be written in any perversive way including checkFile() overriding\n    final ModifiableModel model = InspectionProjectProfileManager.getInstance(manager.getProject()).getInspectionProfile(psiElement).getModifiableModel();\n    InspectionProfileWrapper profile = new InspectionProfileWrapper((InspectionProfile)model);\n    profile.init(manager.getProject());\n    Collection<InspectionTool> suppressedTools = new THashSet<InspectionTool>();\n\n    InspectionTool[] tools = profile.getInspectionTools();\n    for (Collection<String> ids : suppressedScopes.values()) {\n      for (String id : ids) {\n        String shortName = id.trim();\n        for (InspectionTool tool : tools) {\n          if (tool.getShortName().equals(shortName)) {\n            suppressedTools.add(tool);\n          }\n        }\n      }\n    }\n\n    GlobalInspectionContextImpl globalContext = ((InspectionManagerEx)InspectionManager.getInstance(project)).createNewGlobalContext(false);\n    final RefManagerImpl refManager = ((RefManagerImpl)globalContext.getRefManager());\n    refManager.inspectionReadActionStarted();\n    final List<ProblemDescriptor> result;\n    try {\n      result = new ArrayList<ProblemDescriptor>();\n      for (InspectionTool tool : suppressedTools) {\n        String toolId = tool.getShortName();\n        tool.initialize(globalContext);\n        Collection<CommonProblemDescriptor> descriptors;\n        if (tool instanceof LocalInspectionToolWrapper) {\n          LocalInspectionToolWrapper local = (LocalInspectionToolWrapper)tool;\n          if (local.getTool() instanceof UnfairLocalInspectionTool) continue; //cant't work with passes other than LocalInspectionPass\n          local.processFile(psiElement.getContainingFile(), false, manager);\n          descriptors = local.getProblemDescriptors();\n        }\n        else if (tool instanceof GlobalInspectionToolWrapper) {\n          GlobalInspectionToolWrapper global = (GlobalInspectionToolWrapper)tool;\n          global.processFile(new AnalysisScope(psiElement.getContainingFile()), manager, globalContext);\n          descriptors = global.getProblemDescriptors();\n        }\n        else {\n          continue;\n        }\n        for (PsiElement suppressedScope : suppressedScopes.keySet()) {\n          Collection<String> suppressedIds = suppressedScopes.get(suppressedScope);\n          if (!suppressedIds.contains(toolId)) continue;\n          boolean hasErrorInsideSuppressedScope = false;\n          for (CommonProblemDescriptor descriptor : descriptors) {\n            if (!(descriptor instanceof ProblemDescriptor)) continue;\n            PsiElement element = ((ProblemDescriptor)descriptor).getPsiElement();\n            if (element == null) continue;\n            PsiElement annotation = InspectionManagerEx.getElementToolSuppressedIn(element, toolId);\n            if (annotation != null && PsiTreeUtil.isAncestor(suppressedScope, annotation, false)) {\n              hasErrorInsideSuppressedScope = true;\n              break;\n            }\n          }\n          if (!hasErrorInsideSuppressedScope) {\n            PsiElement element = suppressedScope instanceof PsiComment\n                                 ? PsiTreeUtil.skipSiblingsForward(suppressedScope, PsiWhiteSpace.class)\n                                 : suppressedScope.getFirstChild();\n            PsiElement annotation = InspectionManagerEx.getElementToolSuppressedIn(element, toolId);\n            if (annotation != null && annotation.isValid()) {\n              String description = InspectionsBundle.message(\"inspection.redundant.suppression.description\");\n              if (myQuickFixes == null) myQuickFixes = new BidirectionalMap<String, QuickFix>();\n              QuickFix fix = myQuickFixes.get(toolId);\n              if (fix == null) {\n                fix = new RemoveSuppressWarningAction(toolId);\n                myQuickFixes.put(toolId, fix);\n              }\n              ProblemDescriptor descriptor = manager.createProblemDescriptor(annotation, description, (LocalQuickFix)fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n              result.add(descriptor);\n            }\n          }\n        }\n      }\n    }\n    finally {\n      refManager.inspectionReadActionFinished();\n    }\n    return result.toArray(new ProblemDescriptor[result.size()]);\n  }","id":98506,"modified_method":"@Nullable\n  private CommonProblemDescriptor[] checkElement(RefClass refEntity, InspectionManager manager, final Project project) {\n    final PsiElement psiElement = refEntity.getElement();\n    final Map<PsiElement, Collection<String>> suppressedScopes = new THashMap<PsiElement, Collection<String>>();\n    psiElement.accept(new PsiRecursiveElementVisitor() {\n      public void visitModifierList(PsiModifierList list) {\n        super.visitModifierList(list);\n        final PsiElement parent = list.getParent();\n        if (parent instanceof PsiModifierListOwner && !(parent instanceof PsiClass)) {\n          checkElement(parent);\n        }\n      }\n\n      public void visitComment(PsiComment comment) {\n        checkElement(comment);\n      }\n\n      public void visitClass(PsiClass aClass) {\n        if (aClass == psiElement) {\n          super.visitClass(aClass);\n          checkElement(aClass);\n        }\n      }\n\n\n      private void checkElement(final PsiElement owner) {\n        String idsString = InspectionManagerEx.getSuppressedInspectionIdsIn(owner);\n        if (idsString != null && idsString.length() != 0) {\n          List<String> ids = StringUtil.split(idsString, \",\");\n          Collection<String> suppressed = suppressedScopes.get(owner);\n          if (suppressed == null) {\n            suppressed = ids;\n          }\n          else {\n            for (String id : ids) {\n              if (!suppressed.contains(id)) {\n                suppressed.add(id);\n              }\n            }\n          }\n          suppressedScopes.put(owner, suppressed);\n        }\n      }\n    });\n\n    if (suppressedScopes.values().isEmpty()) return null;\n    // have to visit all file from scratch since inspections can be written in any perversive way including checkFile() overriding\n    final ModifiableModel model = InspectionProjectProfileManager.getInstance(manager.getProject()).getInspectionProfile(psiElement).getModifiableModel();\n    InspectionProfileWrapper profile = new InspectionProfileWrapper((InspectionProfile)model);\n    profile.init(manager.getProject());\n    Collection<InspectionTool> suppressedTools = new THashSet<InspectionTool>();\n\n    InspectionTool[] tools = profile.getInspectionTools();\n    for (Collection<String> ids : suppressedScopes.values()) {\n      for (String id : ids) {\n        String shortName = id.trim();\n        for (InspectionTool tool : tools) {\n          if (tool.getShortName().equals(shortName)) {\n            suppressedTools.add(tool);\n          }\n        }\n      }\n    }\n\n    GlobalInspectionContextImpl globalContext = ((InspectionManagerEx)InspectionManager.getInstance(project)).createNewGlobalContext(false);\n    final RefManagerImpl refManager = ((RefManagerImpl)globalContext.getRefManager());\n    refManager.inspectionReadActionStarted();\n    final List<ProblemDescriptor> result;\n    try {\n      result = new ArrayList<ProblemDescriptor>();\n      for (InspectionTool tool : suppressedTools) {\n        String toolId = tool.getShortName();\n        tool.initialize(globalContext);\n        Collection<CommonProblemDescriptor> descriptors;\n        if (tool instanceof LocalInspectionToolWrapper) {\n          LocalInspectionToolWrapper local = (LocalInspectionToolWrapper)tool;\n          if (local.getTool() instanceof UnfairLocalInspectionTool) continue; //cant't work with passes other than LocalInspectionPass\n          local.processFile(psiElement.getContainingFile(), false, manager);\n          descriptors = local.getProblemDescriptors();\n        }\n        else if (tool instanceof GlobalInspectionToolWrapper) {\n          GlobalInspectionToolWrapper global = (GlobalInspectionToolWrapper)tool;\n          global.processFile(new AnalysisScope(psiElement.getContainingFile()), manager, globalContext);\n          descriptors = global.getProblemDescriptors();\n        }\n        else {\n          continue;\n        }\n        for (PsiElement suppressedScope : suppressedScopes.keySet()) {\n          Collection<String> suppressedIds = suppressedScopes.get(suppressedScope);\n          if (!suppressedIds.contains(toolId)) continue;\n          boolean hasErrorInsideSuppressedScope = false;\n          for (CommonProblemDescriptor descriptor : descriptors) {\n            if (!(descriptor instanceof ProblemDescriptor)) continue;\n            PsiElement element = ((ProblemDescriptor)descriptor).getPsiElement();\n            if (element == null) continue;\n            PsiElement annotation = InspectionManagerEx.getElementToolSuppressedIn(element, toolId);\n            if (annotation != null && PsiTreeUtil.isAncestor(suppressedScope, annotation, false)) {\n              hasErrorInsideSuppressedScope = true;\n              break;\n            }\n          }\n          if (!hasErrorInsideSuppressedScope) {\n            PsiMember psiMember;\n            if (suppressedScope instanceof PsiMember) {\n              psiMember = (PsiMember)suppressedScope;\n            } else {\n              psiMember = PsiTreeUtil.getParentOfType(suppressedScope, PsiDocCommentOwner.class);\n            }\n            if (psiMember != null && psiMember.isValid()) {\n              String description = InspectionsBundle.message(\"inspection.redundant.suppression.description\");\n              if (myQuickFixes == null) myQuickFixes = new BidirectionalMap<String, QuickFix>();\n              QuickFix fix = myQuickFixes.get(toolId);\n              if (fix == null) {\n                fix = new RemoveSuppressWarningAction(toolId);\n                myQuickFixes.put(toolId, fix);\n              }\n              PsiElement identifier = null;\n              if (psiMember instanceof PsiMethod) {\n                identifier = ((PsiMethod)psiMember).getNameIdentifier();\n              } else if (psiMember instanceof PsiField) {\n                identifier = ((PsiField)psiMember).getNameIdentifier();\n              } else if (psiMember instanceof PsiClass) {\n                identifier = ((PsiClass)psiMember).getNameIdentifier();\n              }\n              if (identifier == null) {\n                identifier = psiMember;\n              }\n              result.add(manager.createProblemDescriptor(identifier, description, (LocalQuickFix)fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n            }\n          }\n        }\n      }\n    }\n    finally {\n      refManager.inspectionReadActionFinished();\n    }\n    return result.toArray(new ProblemDescriptor[result.size()]);\n  }","commit_id":"692d438e4452937425c8daf6bd2e484ebf72487b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Get the next job id from context and create a trigger to fire the next\n   * job.\n   * @param context\n   * @throws JobExecutionException\n   */\n  @Override\n  public void execute(JobExecutionContext context) throws JobExecutionException {\n    JobKey jobKey = context.getJobDetail().getKey();\n    LOG.debug(\"Executing linear job: \" + jobKey);\n\n    if (!executionScheduleManager.continueOnMisfire(context)) {\n      throw new JobExecutionException(\"Canceled execution based on misfire\"\n        + \" toleration threshold, job: \" + jobKey\n        + \", scheduleTime = \" + context.getScheduledFireTime());\n    }\n\n    // Perform work and exit if failure reported\n    try {\n      doWork(context.getMergedJobDataMap().getWrappedMap());\n    } catch (AmbariException e) {\n      LOG.error(\"Exception caught on job execution. Exiting linear chain...\", e);\n      throw new JobExecutionException(e);\n    }\n\n    LOG.debug(\"Finished linear job: \" + jobKey);\n\n    JobDataMap jobDataMap = context.getMergedJobDataMap();\n\n    String nextJobName = jobDataMap.getString(NEXT_EXECUTION_JOB_NAME_KEY);\n    String nextJobGroup = jobDataMap.getString(NEXT_EXECUTION_JOB_GROUP_KEY);\n\n    if (nextJobName == null || nextJobName.isEmpty()) {\n      LOG.debug(\"End of linear job chain. Returning with success.\");\n      return;\n    }\n\n    int separationSeconds = jobDataMap.getIntValue(NEXT_EXECUTION_SEPARATION_SECONDS);\n\n    // Create trigger for next job execution\n    Trigger trigger = newTrigger()\n      .forJob(nextJobName, nextJobGroup)\n      .withIdentity(\"TriggerForJob-\" + nextJobName, LINEAR_EXECUTION_TRIGGER_GROUP)\n      .withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow())\n      .startAt(futureDate(separationSeconds, DateBuilder.IntervalUnit.SECOND))\n      .build();\n\n    executionScheduleManager.scheduleJob(trigger);\n  }","id":98507,"modified_method":"/**\n   * Get the next job id from context and create a trigger to fire the next\n   * job.\n   * @param context\n   * @throws JobExecutionException\n   */\n  @Override\n  public void execute(JobExecutionContext context) throws JobExecutionException {\n    JobKey jobKey = context.getJobDetail().getKey();\n    LOG.debug(\"Executing linear job: \" + jobKey);\n\n    if (!executionScheduleManager.continueOnMisfire(context)) {\n      throw new JobExecutionException(\"Canceled execution based on misfire\"\n        + \" toleration threshold, job: \" + jobKey\n        + \", scheduleTime = \" + context.getScheduledFireTime());\n    }\n\n    Map<String, Object> properties = context.getMergedJobDataMap()\n      .getWrappedMap();\n\n    // Perform work and exit if failure reported\n    try {\n      doWork(properties);\n    } catch (AmbariException e) {\n      LOG.error(\"Exception caught on job execution. Exiting linear chain...\", e);\n      throw new JobExecutionException(e);\n    }\n\n    LOG.debug(\"Finished linear job: \" + jobKey);\n\n    JobDataMap jobDataMap = context.getMergedJobDataMap();\n\n    String nextJobName = jobDataMap.getString(NEXT_EXECUTION_JOB_NAME_KEY);\n    String nextJobGroup = jobDataMap.getString(NEXT_EXECUTION_JOB_GROUP_KEY);\n\n    // If no more jobs left, update status and return\n    if (nextJobName == null || nextJobName.isEmpty()) {\n      LOG.debug(\"End of linear job chain. Returning with success.\");\n      try {\n        finalizeExecution(properties);\n      } catch (AmbariException e) {\n        LOG.warn(\"Unable to finalize execution for job: \" + jobKey);\n      }\n      return;\n    }\n\n    int separationSeconds = jobDataMap.getIntValue(NEXT_EXECUTION_SEPARATION_SECONDS);\n\n    // Create trigger for next job execution\n    Trigger trigger = newTrigger()\n      .forJob(nextJobName, nextJobGroup)\n      .withIdentity(\"TriggerForJob-\" + nextJobName, LINEAR_EXECUTION_TRIGGER_GROUP)\n      .withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow())\n      .startAt(futureDate(separationSeconds, DateBuilder.IntervalUnit.SECOND))\n      .build();\n\n    executionScheduleManager.scheduleJob(trigger);\n  }","commit_id":"a158073c7db49cee635bdcda2a6330ead3fba62b","url":"https://github.com/apache/ambari"},{"original_method":"private BatchRequestResponse convertToBatchRequestResponse(ClientResponse clientResponse) {\n    BatchRequestResponse batchRequestResponse = new BatchRequestResponse();\n    int retCode = clientResponse.getStatus();\n\n    batchRequestResponse.setReturnCode(retCode);\n\n    String responseString = clientResponse.getEntity(String.class);\n    LOG.debug(\"Processing API response: status={}, body={}\", retCode, responseString);\n    Map httpResponseMap;\n    try {\n      httpResponseMap = gson.fromJson(responseString, Map.class);\n      LOG.debug(\"Processing responce as JSON\");\n    } catch (JsonSyntaxException e) {\n      LOG.debug(\"Response is not valid JSON object. Recording as is\");\n      httpResponseMap = new HashMap();\n      httpResponseMap.put(\"message\", responseString);\n    }\n\n\n    if (retCode < 300) {\n      if (httpResponseMap == null) {\n        //Empty response on successful scenario\n        batchRequestResponse.setStatus(HostRoleStatus.COMPLETED.toString());\n        return batchRequestResponse;\n      }\n\n      Map requestMap = null;\n      Object requestMapObject = httpResponseMap.get(\"Requests\");\n      if (requestMapObject instanceof Map) {\n        requestMap = (Map) requestMapObject;\n      }\n\n      if (requestMap != null) {\n        batchRequestResponse.setRequestId((\n          (Double) requestMap.get(REQUESTS_ID_KEY)).longValue());\n        //TODO fix different names for field\n        String status = null;\n        if (requestMap.get(REQUESTS_STATUS_KEY) != null) {\n          status = requestMap.get(REQUESTS_STATUS_KEY).toString();\n        }\n        if (requestMap.get(\"status\") != null) {\n          status = requestMap.get(\"status\").toString();\n        }\n\n        if (requestMap.get(REQUESTS_ABORTED_TASKS_KEY) != null) {\n          batchRequestResponse.setAbortedTaskCount(Integer.parseInt\n            (requestMap.get(REQUESTS_ABORTED_TASKS_KEY).toString()));\n        }\n        if (requestMap.get(REQUESTS_FAILED_TASKS_KEY) != null) {\n          batchRequestResponse.setFailedTaskCount(Integer.parseInt\n            (requestMap.get(REQUESTS_FAILED_TASKS_KEY).toString()));\n        }\n        if (requestMap.get(REQUESTS_TIMEDOUT_TASKS_KEY) != null) {\n          batchRequestResponse.setTimedOutTaskCount(Integer.parseInt\n            (requestMap.get(REQUESTS_TIMEDOUT_TASKS_KEY).toString()));\n        }\n        if (requestMap.get(REQUESTS_TOTAL_TASKS_KEY) != null) {\n          batchRequestResponse.setTotalTaskCount(Integer.parseInt\n            (requestMap.get(REQUESTS_TOTAL_TASKS_KEY).toString()));\n        }\n        batchRequestResponse.setStatus(status);\n      }\n\n    } else {\n      //unsuccessful response\n      batchRequestResponse.setReturnMessage((String) httpResponseMap.get(\"message\"));\n      batchRequestResponse.setStatus(HostRoleStatus.FAILED.toString());\n    }\n\n    return batchRequestResponse;\n  }","id":98508,"modified_method":"private BatchRequestResponse convertToBatchRequestResponse(ClientResponse clientResponse) {\n    BatchRequestResponse batchRequestResponse = new BatchRequestResponse();\n    int retCode = clientResponse.getStatus();\n\n    batchRequestResponse.setReturnCode(retCode);\n\n    String responseString = clientResponse.getEntity(String.class);\n    LOG.debug(\"Processing API response: status={}, body={}\", retCode, responseString);\n    Map httpResponseMap;\n    try {\n      httpResponseMap = gson.fromJson(responseString, Map.class);\n      LOG.debug(\"Processing responce as JSON\");\n    } catch (JsonSyntaxException e) {\n      LOG.debug(\"Response is not valid JSON object. Recording as is\");\n      httpResponseMap = new HashMap();\n      httpResponseMap.put(\"message\", responseString);\n    }\n\n\n    if (retCode < 300) {\n      if (httpResponseMap == null) {\n        //Empty response on successful scenario\n        batchRequestResponse.setStatus(HostRoleStatus.COMPLETED.toString());\n        return batchRequestResponse;\n      }\n\n      Map requestMap = null;\n      Object requestMapObject = httpResponseMap.get(\"Requests\");\n      if (requestMapObject instanceof Map) {\n        requestMap = (Map) requestMapObject;\n      }\n\n      if (requestMap != null) {\n        batchRequestResponse.setRequestId((\n          (Double) requestMap.get(REQUESTS_ID_KEY)).longValue());\n        //TODO fix different names for field\n        String status = null;\n        if (requestMap.get(REQUESTS_STATUS_KEY) != null) {\n          status = requestMap.get(REQUESTS_STATUS_KEY).toString();\n        }\n        if (requestMap.get(\"status\") != null) {\n          status = requestMap.get(\"status\").toString();\n        }\n\n        if (requestMap.get(REQUESTS_ABORTED_TASKS_KEY) != null) {\n          batchRequestResponse.setAbortedTaskCount(\n            ((Double) requestMap.get(REQUESTS_ABORTED_TASKS_KEY)).intValue());\n        }\n        if (requestMap.get(REQUESTS_FAILED_TASKS_KEY) != null) {\n          batchRequestResponse.setFailedTaskCount(\n            ((Double) requestMap.get(REQUESTS_FAILED_TASKS_KEY)).intValue());\n        }\n        if (requestMap.get(REQUESTS_TIMEDOUT_TASKS_KEY) != null) {\n          batchRequestResponse.setTimedOutTaskCount(\n            ((Double) requestMap.get(REQUESTS_TIMEDOUT_TASKS_KEY)).intValue());\n        }\n        if (requestMap.get(REQUESTS_TOTAL_TASKS_KEY) != null) {\n          batchRequestResponse.setTotalTaskCount(\n            ((Double) requestMap.get(REQUESTS_TOTAL_TASKS_KEY)).intValue());\n        }\n        batchRequestResponse.setStatus(status);\n      }\n\n    } else {\n      //unsuccessful response\n      batchRequestResponse.setReturnMessage((String) httpResponseMap.get(\"message\"));\n      batchRequestResponse.setStatus(HostRoleStatus.FAILED.toString());\n    }\n\n    return batchRequestResponse;\n  }","commit_id":"a158073c7db49cee635bdcda2a6330ead3fba62b","url":"https://github.com/apache/ambari"},{"original_method":"@Transactional\n  private RequestExecution createRequestSchedule() throws Exception {\n    Batch batches = new Batch();\n    Schedule schedule = new Schedule();\n\n    BatchSettings batchSettings = new BatchSettings();\n    batchSettings.setTaskFailureToleranceLimit(10);\n    batches.setBatchSettings(batchSettings);\n\n    List<BatchRequest> batchRequests = new ArrayList<BatchRequest>();\n    BatchRequest batchRequest1 = new BatchRequest();\n    batchRequest1.setOrderId(10L);\n    batchRequest1.setType(BatchRequest.Type.DELETE);\n    batchRequest1.setUri(\"testUri1\");\n\n    BatchRequest batchRequest2 = new BatchRequest();\n    batchRequest2.setOrderId(12L);\n    batchRequest2.setType(BatchRequest.Type.POST);\n    batchRequest2.setUri(\"testUri2\");\n    batchRequest2.setBody(\"testBody\");\n\n    batchRequests.add(batchRequest1);\n    batchRequests.add(batchRequest2);\n\n    batches.getBatchRequests().addAll(batchRequests);\n\n    schedule.setMinutes(\"10\");\n    schedule.setEndTime(\"2014-01-01 00:00:00\");\n\n    RequestExecution requestExecution = requestExecutionFactory.createNew\n      (cluster, batches, schedule);\n    requestExecution.setDescription(\"Test Schedule\");\n\n    requestExecution.persist();\n\n    return requestExecution;\n  }","id":98509,"modified_method":"@Transactional\n  private RequestExecution createRequestSchedule() throws Exception {\n    Batch batches = new Batch();\n    Schedule schedule = new Schedule();\n\n    BatchSettings batchSettings = new BatchSettings();\n    batchSettings.setTaskFailureToleranceLimit(10);\n    batches.setBatchSettings(batchSettings);\n\n    List<BatchRequest> batchRequests = new ArrayList<BatchRequest>();\n    BatchRequest batchRequest1 = new BatchRequest();\n    batchRequest1.setOrderId(10L);\n    batchRequest1.setType(BatchRequest.Type.DELETE);\n    batchRequest1.setUri(\"testUri1\");\n\n    BatchRequest batchRequest2 = new BatchRequest();\n    batchRequest2.setOrderId(12L);\n    batchRequest2.setType(BatchRequest.Type.POST);\n    batchRequest2.setUri(\"testUri2\");\n    batchRequest2.setBody(\"testBody\");\n\n    batchRequests.add(batchRequest1);\n    batchRequests.add(batchRequest2);\n\n    batches.getBatchRequests().addAll(batchRequests);\n\n    schedule.setMinutes(\"10\");\n    schedule.setEndTime(\"2014-01-01 00:00:00\");\n\n    RequestExecution requestExecution = requestExecutionFactory.createNew\n      (cluster, batches, schedule);\n\n    requestExecution.setStatus(RequestExecution.Status.SCHEDULED);\n    requestExecution.setDescription(\"Test Schedule\");\n\n    requestExecution.persist();\n\n    return requestExecution;\n  }","commit_id":"a158073c7db49cee635bdcda2a6330ead3fba62b","url":"https://github.com/apache/ambari"},{"original_method":"/**\n\t * Get the node from tree by given path\n\t * @param path\n\t * @param root\n\t * @return the node from tree by given path\n\t */\n\tprivate Object getNodeByPath(List path, Object root)\n\t{\n\t\tObject node = root;\n\t\tfor(int i=path.size()-2; i >= 0; i--){\n\t\t\tnode = _model.getChild(node, Integer.parseInt(path.get(i).toString()));\n\t\t}\n\t\treturn node;\n\t}","id":98510,"modified_method":"/**\n\t * Get the node from tree by given path\n\t * @param path\n\t * @param root\n\t * @return the node from tree by given path\n\t */\n\tprivate Object getNodeByPath(List path, Object root)\n\t{\n\t\tObject node = root;\n\t\tint pathSize = path.size()-1;\n\t\tif(_rootVisible)\n\t\t\tpathSize--;\n\t\tfor(int i=pathSize; i >= 0; i--){\n\t\t\tnode = _model.getChild(node, ((Integer)(path.get(i))).intValue());\n\t\t}\n\t\treturn node;\n\t}","commit_id":"a9a23eca1ed23b00c52a4c61d805b2dd9dc24e02","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderTree() throws Exception{\n\t\t_treechildren = null;\n\t\tTreechildren children = new Treechildren();\n\t\tTreeitem ti = new Treeitem();\n\t\tti.setParent(children);\n\t\tchildren.setParent(this);\n\t\tthis.renderItem(ti);\n\t}","id":98511,"modified_method":"private void renderTree() throws Exception{\n\t\tif(_rootVisible)\n\t\t\trenderRoot();\n\t\telse\n\t\t\trenderInvisibleRoot();\n\t}","commit_id":"a9a23eca1ed23b00c52a4c61d805b2dd9dc24e02","url":"https://github.com/zkoss/zk"},{"original_method":"private void _addParamElement(\n\t\tElement methodElement, JavaParameter javaParameter,\n\t\tDocletTag[] paramDocletTags) {\n\n\t\tString name = javaParameter.getName();\n\n\t\tString value = null;\n\n\t\tfor (DocletTag paramDocletTag : paramDocletTags) {\n\t\t\tString curValue = paramDocletTag.getValue();\n\n\t\t\tif (!curValue.startsWith(name)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = curValue;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tElement paramElement = methodElement.addElement(\"param\");\n\n\t\tDocUtil.add(paramElement, \"name\", name);\n\t\tDocUtil.add(paramElement, \"type\", _getTypeValue(javaParameter));\n\n\t\tif (value != null) {\n\t\t\tvalue = value.substring(name.length());\n\n\t\t\tDocUtil.add(paramElement, \"required\", true);\n\t\t}\n\n\t\tvalue = _trimMultilineText(value);\n\n\t\tElement commentElement = paramElement.addElement(\"comment\");\n\n\t\tcommentElement.addCDATA(value);\n\t}","id":98512,"modified_method":"private void _addParamElement(\n\t\tElement methodElement, JavaParameter javaParameter,\n\t\tDocletTag[] paramDocletTags) {\n\n\t\tString name = javaParameter.getName();\n\n\t\tString value = null;\n\n\t\tfor (DocletTag paramDocletTag : paramDocletTags) {\n\t\t\tString curValue = paramDocletTag.getValue();\n\n\t\t\tif (curValue.equals(name) || curValue.startsWith(name + \" \")) {\n\t\t\t\tvalue = curValue;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tElement paramElement = methodElement.addElement(\"param\");\n\n\t\tDocUtil.add(paramElement, \"name\", name);\n\t\tDocUtil.add(paramElement, \"type\", _getTypeValue(javaParameter));\n\n\t\tif (value != null) {\n\t\t\tvalue = value.substring(name.length());\n\n\t\t\tDocUtil.add(paramElement, \"required\", true);\n\t\t}\n\n\t\tvalue = _trimMultilineText(value);\n\n\t\tElement commentElement = paramElement.addElement(\"comment\");\n\n\t\tcommentElement.addCDATA(value);\n\t}","commit_id":"6ee0dbad02f49527d13d30049744486419c1168f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isOverridden(String name)\n    {\n        // find a match\n        boolean overrideMatch = false;\n        for (String override : overrides)\n        {\n            if (name.startsWith(override))\n            {\n                overrideMatch = true;\n                break;\n            }\n        }\n        return overrideMatch;\n    }","id":98513,"modified_method":"protected boolean isOverridden(String name)\n    {\n        // find a match\n        boolean overrideMatch = false;\n        for (String override : overrides)\n        {\n            if (name.equals(override) || name.startsWith(override + \".\"))\n            {\n                overrideMatch = true;\n                break;\n            }\n        }\n        return overrideMatch;\n    }","commit_id":"2a626e726c755a5bd0ef168cdaeeff3808623782","url":"https://github.com/mulesoft/mule"},{"original_method":"protected boolean isBlocked(String name)\n    {\n        boolean blockedMatch = false;\n        for (String b : blocked)\n        {\n            if (name.startsWith(b))\n            {\n                blockedMatch = true;\n                break;\n            }\n        }\n        return blockedMatch;\n    }","id":98514,"modified_method":"protected boolean isBlocked(String name)\n    {\n        boolean blockedMatch = false;\n        for (String b : blocked)\n        {\n            if (name.equals(b) || name.startsWith(b + \".\"))\n            {\n                blockedMatch = true;\n                break;\n            }\n        }\n        return blockedMatch;\n    }","commit_id":"2a626e726c755a5bd0ef168cdaeeff3808623782","url":"https://github.com/mulesoft/mule"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1205921334476(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    final SNode contextClassifier;\n    {\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          SNode contextPart = SNodeOperations.getAncestorWhereConceptInList(_context.getParentNode(), new String[]{\"jetbrains.mps.baseLanguage.classifiers.structure.IClassifier\",\"jetbrains.mps.baseLanguage.classifiers.structure.IClassifierPart\"}, true, false);\n          if (SNodeOperations.isInstanceOf(contextPart, \"jetbrains.mps.baseLanguage.classifiers.structure.IClassifier\")) {\n            return contextPart;\n          } else\n          {\n            return IClassifierPart_Behavior.call_getMainClassifier_1213877255428(contextPart);\n          }\n        }\n\n      };\n      contextClassifier = (SNode)calc.calculate();\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.DotExpression\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            return IClassifier_Behavior.call_getMembers_1213877528020(contextClassifier, _context.getParentNode());\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(final SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.DotExpression\", null);\n              SLinkOperations.setNewChild(result, \"operand\", \"jetbrains.mps.baseLanguage.classifiers.structure.ThisClassifierExpresson\");\n              SLinkOperations.setTarget(result, \"operation\", IMember_Behavior.call_createOperation_1213877353000((item)), true);\n              return result;\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","id":98515,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1205921334476(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    final SNode contextClassifier;\n    {\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          SNode contextPart = SNodeOperations.getAncestorWhereConceptInList(_context.getParentNode(), new String[]{\"jetbrains.mps.baseLanguage.classifiers.structure.IClassifier\", \"jetbrains.mps.baseLanguage.classifiers.structure.IClassifierPart\"}, true, false);\n          if (SNodeOperations.isInstanceOf(contextPart, \"jetbrains.mps.baseLanguage.classifiers.structure.IClassifier\")) {\n            return contextPart;\n          } else {\n            return IClassifierPart_Behavior.call_getMainClassifier_1213877255428(contextPart);\n          }\n        }\n\n      };\n      contextClassifier = (SNode) calc.calculate();\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.DotExpression\", operationContext.getScope());\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode) BaseAdapter.fromAdapter(outputConcept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            return IClassifier_Behavior.call_getMembers_1213877528020(contextClassifier, _context.getParentNode());\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable<SNode>) calc.calculate();\n        assert queryResult != null;\n        for (final SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(outputConcept, item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.DotExpression\", null);\n              SLinkOperations.setNewChild(result, \"operand\", \"jetbrains.mps.baseLanguage.classifiers.structure.ThisClassifierExpresson\");\n              SLinkOperations.setTarget(result, \"operation\", IMember_Behavior.call_createOperation_1213877353000((item)), true);\n              return result;\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","commit_id":"176c0b92080e1c274753d606264a3b3d1d493561","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      final SNode operandType = TypeChecker.getInstance().getRuntimeSupport().typeOf(IOperation_Behavior.call_getOperand_1213877410070(nodeToCheck), \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921836720\", true);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(operandType, new Runnable() {\n\n        public void run() {\n          {\n            IMatchingPattern pattern_ = HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.classifiers.structure.BaseClassifierType\");\n            SNode coercedNode_ = TypeChecker.getInstance().getRuntimeSupport().coerce(TypeChecker.getInstance().getEquationManager().getRepresentator(operandType), pattern_);\n            if (coercedNode_ != null) {\n              if (!(ListSequence.fromList(BaseClassifierType_Behavior.call_getMembers_1213877402148(coercedNode_, nodeToCheck)).contains(SLinkOperations.getTarget(nodeToCheck, \"member\", false)))) {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Declaration is out of scope\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921883388\", intentionProvider);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921833059\");\n    }\n  }","id":98516,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      final SNode operandType = TypeChecker.getInstance().getRuntimeSupport().typeOf(IOperation_Behavior.call_getOperand_1213877410070(nodeToCheck), \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921836720\", true);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(operandType, new Runnable() {\n\n        public void run() {\n          {\n            IMatchingPattern pattern_ = HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.classifiers.structure.BaseClassifierType\");\n            SNode coercedNode_ = TypeChecker.getInstance().getRuntimeSupport().coerce(TypeChecker.getInstance().getEquationManager().getRepresentator(operandType), pattern_);\n            if (coercedNode_ != null) {\n              if (!(ListSequence.fromList(BaseClassifierType_Behavior.call_getMembers_1213877402148(coercedNode_, nodeToCheck)).contains(SLinkOperations.getTarget(nodeToCheck, \"member\", false)))) {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Declaration is out of scope\", \"jetbrains.mps.baseLanguage.classifiers.helgins@16_0\", \"1217434393591\", intentionProvider);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205921833059\");\n    }\n  }","commit_id":"176c0b92080e1c274753d606264a3b3d1d493561","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1214001479715\", true), SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"type\", true), nodeToCheck, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1214001485999\");\n  }","id":98517,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1214001479715\", true), SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"type\", true), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1214001485999\", intentionProvider);\n    }\n  }","commit_id":"176c0b92080e1c274753d606264a3b3d1d493561","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769685435\", true), SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"returnType\", true), nodeToCheck, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769679712\");\n    {\n      SNode parameter;\n      SNode argument;\n      Iterator<SNode> parameter_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true).iterator();\n      Iterator<SNode> argument_iterator = SLinkOperations.getTargets(nodeToCheck, \"actualArgument\", true).iterator();\n      while (true) {\n        if (!(parameter_iterator.hasNext())) {\n          break;\n        }\n        if (!(argument_iterator.hasNext())) {\n          break;\n        }\n        parameter = parameter_iterator.next();\n        argument = argument_iterator.next();\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(argument, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854575356\", true), SLinkOperations.getTarget(parameter, \"type\", true), argument, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854571586\", false, 0);\n      }\n    }\n    if (ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true)).count() != SLinkOperations.getCount(nodeToCheck, \"actualArgument\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Number of parameters doesn't match\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854659855\", intentionProvider);\n      }\n    }\n  }","id":98518,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769685435\", true), SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"returnType\", true), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205769679712\", intentionProvider);\n    }\n    {\n      SNode parameter;\n      SNode argument;\n      Iterator<SNode> parameter_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true).iterator();\n      Iterator<SNode> argument_iterator = SLinkOperations.getTargets(nodeToCheck, \"actualArgument\", true).iterator();\n      while (true) {\n        if (!(parameter_iterator.hasNext())) {\n          break;\n        }\n        if (!(argument_iterator.hasNext())) {\n          break;\n        }\n        parameter = parameter_iterator.next();\n        argument = argument_iterator.next();\n        {\n          SNode _nodeToCheck_1029348928467 = nodeToCheck;\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(argument, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854575356\", true), SLinkOperations.getTarget(parameter, \"type\", true), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205854571586\", false, 0, intentionProvider);\n        }\n      }\n    }\n    if (ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true)).count() != SLinkOperations.getCount(nodeToCheck, \"actualArgument\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(nodeToCheck, \"Number of parameters doesn't match\", \"jetbrains.mps.baseLanguage.classifiers.helgins@16_0\", \"1217434393437\", intentionProvider);\n      }\n    }\n  }","commit_id":"176c0b92080e1c274753d606264a3b3d1d493561","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    SNode classifier = ThisClassifierExpresson_Behavior.call_getClassifier_1213877512819(nodeToCheck);\n    if (classifier != null) {\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753197519\", true), IClassifier_Behavior.call_createType_1213877527970(classifier), nodeToCheck, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753196184\");\n    } else\n    {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(nodeToCheck, \"this classifier expression isn't applicable in this place\", \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753211126\", intentionProvider);\n      }\n    }\n  }","id":98519,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    SNode classifier = ThisClassifierExpresson_Behavior.call_getClassifier_1213877512819(nodeToCheck);\n    if (classifier != null) {\n      {\n        SNode _nodeToCheck_1029348928467 = nodeToCheck;\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753197519\", true), IClassifier_Behavior.call_createType_1213877527970(classifier), _nodeToCheck_1029348928467, null, \"jetbrains.mps.baseLanguage.classifiers.helgins\", \"1205753196184\", intentionProvider);\n      }\n    } else {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().reportTypeError(nodeToCheck, \"this classifier expression isn't applicable in this place\", \"jetbrains.mps.baseLanguage.classifiers.helgins@16_0\", \"1217434393351\", intentionProvider);\n      }\n    }\n  }","commit_id":"176c0b92080e1c274753d606264a3b3d1d493561","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.ide.uiLanguage.helgins\", \"1203610791158\", true), new QuotationClass_().createNode(), nodeToCheck, null, \"jetbrains.mps.ide.uiLanguage.helgins\", \"1203610794130\");\n  }","id":98520,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"jetbrains.mps.ide.uiLanguage.helgins\", \"1203610791158\", true), new QuotationClass_0().createNode(), _nodeToCheck_1029348928467, null, \"jetbrains.mps.ide.uiLanguage.helgins\", \"1203610794130\", intentionProvider);\n    }\n  }","commit_id":"46d44d5972a04fc77b1d7639613886e5c2eae488","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\r\n    meta = (MetaInjectMeta) smi;\r\n    data = (MetaInjectData) sdi;\r\n\r\n    // Read the data from all input steps and keep it in memory...\r\n    //\r\n    data.rowMap = new HashMap<String, List<RowMetaAndData>>();\r\n    for (String prevStepName : getTransMeta().getPrevStepNames(getStepMeta())) {\r\n      List<RowMetaAndData> list = new ArrayList<RowMetaAndData>();\r\n      RowSet rowSet = findInputRowSet(prevStepName);\r\n      Object[] row = getRowFrom(rowSet);\r\n      while (row!=null) {\r\n        RowMetaAndData rd = new RowMetaAndData();\r\n        rd.setRowMeta(rowSet.getRowMeta());\r\n        rd.setData(row);\r\n        list.add(rd);\r\n        \r\n        row = getRowFrom(rowSet);\r\n      }\r\n      if (!list.isEmpty()) {\r\n        data.rowMap.put(prevStepName, list);\r\n      }\r\n    }\r\n    \r\n    for (String targetStep : data.stepInjectionMap.keySet()) {\r\n      \r\n      System.out.println(\"Handing step '\"+targetStep+\"' injection!\");\r\n      \r\n      // This is the injection interface:\r\n      //\r\n      StepMetaInjectionInterface injectionInterface = data.stepInjectionMap.get(targetStep);\r\n      \r\n      // This is the injection description:\r\n      //\r\n      List<StepInjectionMetaEntry> metadataEntries = injectionInterface.getStepInjectionMetadataEntries();\r\n      \r\n      // Create a new list of metadata injection entries...\r\n      //\r\n      List<StepInjectionMetaEntry> inject = new ArrayList<StepInjectionMetaEntry>();\r\n      \r\n      // Collect all the metadata for this target step...\r\n      //\r\n      Map<TargetStepAttribute, SourceStepField> targetMap = meta.getTargetSourceMapping();\r\n      for (TargetStepAttribute target : targetMap.keySet()) {\r\n        SourceStepField source = targetMap.get(target);\r\n\r\n        if (target.getStepname().equalsIgnoreCase(targetStep)) {\r\n          // This is the step to collect data for...\r\n          // We also know which step to read the data from. (source)\r\n          // \r\n          List<RowMetaAndData> rows = data.rowMap.get(source.getStepname());\r\n          if (rows!=null && rows.size()>0) {\r\n            // Which metadata key is this referencing?  Find the attribute key in the metadata entries...\r\n            //\r\n            StepInjectionMetaEntry entry = findMetaEntry(metadataEntries, target.getAttributeKey());\r\n            if (entry!=null) {\r\n              if (!target.isDetail()) {\r\n                setEntryValue(entry, rows.get(0), source);\r\n                inject.add(entry);\r\n              } else {\r\n                // We are going to pass this entry N times for N target mappings\r\n                // As such, we have to see if it's already in the injection list...\r\n                // \r\n                StepInjectionMetaEntry metaEntries = findMetaEntry(inject, entry.getKey());\r\n                if (metaEntries==null) {\r\n                  \r\n                  StepInjectionMetaEntry rootEntry = findDetailRootEntry(metadataEntries, entry);\r\n                  \r\n                  // Inject an empty copy\r\n                  //\r\n                  metaEntries = rootEntry.clone();\r\n                  metaEntries.setDetails(new ArrayList<StepInjectionMetaEntry>());\r\n                  inject.add(metaEntries);\r\n                  \r\n                  // We also need to pre-populate the whole grid: X rows by Y attributes\r\n                  //\r\n                  StepInjectionMetaEntry metaEntry = rootEntry.getDetails().get(0);\r\n    \r\n                  for (int i=0;i<rows.size();i++) {\r\n                    StepInjectionMetaEntry metaCopy = metaEntry.clone();\r\n                    metaEntries.getDetails().add(metaCopy);\r\n                    metaCopy.setDetails(new ArrayList<StepInjectionMetaEntry>());\r\n                    \r\n                    for (StepInjectionMetaEntry me : metaEntry.getDetails()) {\r\n                      StepInjectionMetaEntry meCopy = me.clone();\r\n                      metaCopy.getDetails().add(meCopy);\r\n                    }\r\n                  }\r\n                  \r\n                  // From now on we can simply refer to the correct X,Y coordinate.\r\n                } else {\r\n                  StepInjectionMetaEntry rootEntry = findDetailRootEntry(inject, metaEntries);\r\n                  metaEntries = rootEntry;\r\n                }\r\n                \r\n                for (int i=0;i<rows.size();i++) {\r\n                  RowMetaAndData row = rows.get(i);\r\n                  try {\r\n                    List<StepInjectionMetaEntry> rowEntries = metaEntries.getDetails().get(i).getDetails();\r\n                    \r\n                    for (StepInjectionMetaEntry rowEntry : rowEntries) {\r\n                      // We have to look up the sources for these targets again in the target-2-source mapping\r\n                      // That is because we only want handle this as few times as possible...\r\n                      //\r\n                      SourceStepField detailSource = findDetailSource(targetMap, targetStep, rowEntry.getKey());\r\n                      if (detailSource!=null) {\r\n                        setEntryValue(rowEntry, row, detailSource);\r\n                      } else {\r\n                        System.out.println(\"No detail source found for key: \"+rowEntry.getKey()+\" and target step: \"+targetStep);\r\n                      }\r\n                    }\r\n                  } catch(Exception e) {\r\n                    e.printStackTrace();\r\n                  }\r\n                }\r\n                \r\n                System.out.println(\"injected entry: \"+entry);\r\n              }\r\n              // End of TopLevel/Detail if block\r\n            } else {\r\n              System.out.println(\"entry not found: \"+target.getAttributeKey());\r\n            }\r\n          } else {\r\n            System.out.println(\"No rows found for source step: \"+source.getStepname());\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Inject the metadata into the step!\r\n      //\r\n      injectionInterface.injectStepMetadataEntries(inject);\r\n    }\r\n    \r\n    System.out.println(data.transMeta.getXML());\r\n    \r\n    // Now we can execute this modified transformation metadata.\r\n    //\r\n    final Trans injectTrans = new Trans(data.transMeta, this);\r\n    getTrans().addTransStoppedListener(new TransStoppedListener() {\r\n      public void transStopped(Trans parentTrans) {\r\n        injectTrans.stopAll();\r\n      }\r\n    });\r\n    injectTrans.execute(null);\r\n    \r\n    while (!injectTrans.isFinished() && !injectTrans.isStopped()) {\r\n      copyResult(injectTrans);\r\n      \r\n      // Wait a little bit.\r\n      try { Thread.sleep(500); } catch (Exception e) { }\r\n    }\r\n    copyResult(injectTrans);\r\n    \r\n    setOutputDone();\r\n\r\n    return false;\r\n  }","id":98521,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\r\n    meta = (MetaInjectMeta) smi;\r\n    data = (MetaInjectData) sdi;\r\n\r\n    // Read the data from all input steps and keep it in memory...\r\n    //\r\n    data.rowMap = new HashMap<String, List<RowMetaAndData>>();\r\n    for (String prevStepName : getTransMeta().getPrevStepNames(getStepMeta())) {\r\n      List<RowMetaAndData> list = new ArrayList<RowMetaAndData>();\r\n      RowSet rowSet = findInputRowSet(prevStepName);\r\n      Object[] row = getRowFrom(rowSet);\r\n      while (row!=null) {\r\n        RowMetaAndData rd = new RowMetaAndData();\r\n        rd.setRowMeta(rowSet.getRowMeta());\r\n        rd.setData(row);\r\n        list.add(rd);\r\n        \r\n        row = getRowFrom(rowSet);\r\n      }\r\n      if (!list.isEmpty()) {\r\n        data.rowMap.put(prevStepName, list);\r\n      }\r\n    }\r\n    \r\n    for (String targetStep : data.stepInjectionMap.keySet()) {\r\n      \r\n      if (log.isDetailed()) logDetailed(\"Handing step '\"+targetStep+\"' injection!\");\r\n      \r\n      // This is the injection interface:\r\n      //\r\n      StepMetaInjectionInterface injectionInterface = data.stepInjectionMap.get(targetStep);\r\n      \r\n      // This is the injection description:\r\n      //\r\n      List<StepInjectionMetaEntry> metadataEntries = injectionInterface.getStepInjectionMetadataEntries();\r\n      \r\n      // Create a new list of metadata injection entries...\r\n      //\r\n      List<StepInjectionMetaEntry> inject = new ArrayList<StepInjectionMetaEntry>();\r\n      \r\n      // Collect all the metadata for this target step...\r\n      //\r\n      Map<TargetStepAttribute, SourceStepField> targetMap = meta.getTargetSourceMapping();\r\n      for (TargetStepAttribute target : targetMap.keySet()) {\r\n        SourceStepField source = targetMap.get(target);\r\n\r\n        if (target.getStepname().equalsIgnoreCase(targetStep)) {\r\n          // This is the step to collect data for...\r\n          // We also know which step to read the data from. (source)\r\n          // \r\n          List<RowMetaAndData> rows = data.rowMap.get(source.getStepname());\r\n          if (rows!=null && rows.size()>0) {\r\n            // Which metadata key is this referencing?  Find the attribute key in the metadata entries...\r\n            //\r\n            StepInjectionMetaEntry entry = findMetaEntry(metadataEntries, target.getAttributeKey());\r\n            if (entry!=null) {\r\n              if (!target.isDetail()) {\r\n                setEntryValue(entry, rows.get(0), source);\r\n                inject.add(entry);\r\n              } else {\r\n                // We are going to pass this entry N times for N target mappings\r\n                // As such, we have to see if it's already in the injection list...\r\n                // \r\n                StepInjectionMetaEntry metaEntries = findMetaEntry(inject, entry.getKey());\r\n                if (metaEntries==null) {\r\n                  \r\n                  StepInjectionMetaEntry rootEntry = findDetailRootEntry(metadataEntries, entry);\r\n                  \r\n                  // Inject an empty copy\r\n                  //\r\n                  metaEntries = rootEntry.clone();\r\n                  metaEntries.setDetails(new ArrayList<StepInjectionMetaEntry>());\r\n                  inject.add(metaEntries);\r\n                  \r\n                  // We also need to pre-populate the whole grid: X rows by Y attributes\r\n                  //\r\n                  StepInjectionMetaEntry metaEntry = rootEntry.getDetails().get(0);\r\n    \r\n                  for (int i=0;i<rows.size();i++) {\r\n                    StepInjectionMetaEntry metaCopy = metaEntry.clone();\r\n                    metaEntries.getDetails().add(metaCopy);\r\n                    metaCopy.setDetails(new ArrayList<StepInjectionMetaEntry>());\r\n                    \r\n                    for (StepInjectionMetaEntry me : metaEntry.getDetails()) {\r\n                      StepInjectionMetaEntry meCopy = me.clone();\r\n                      metaCopy.getDetails().add(meCopy);\r\n                    }\r\n                  }\r\n                  \r\n                  // From now on we can simply refer to the correct X,Y coordinate.\r\n                } else {\r\n                  StepInjectionMetaEntry rootEntry = findDetailRootEntry(inject, metaEntries);\r\n                  metaEntries = rootEntry;\r\n                }\r\n                \r\n                for (int i=0;i<rows.size();i++) {\r\n                  RowMetaAndData row = rows.get(i);\r\n                  try {\r\n                    List<StepInjectionMetaEntry> rowEntries = metaEntries.getDetails().get(i).getDetails();\r\n                    \r\n                    for (StepInjectionMetaEntry rowEntry : rowEntries) {\r\n                      // We have to look up the sources for these targets again in the target-2-source mapping\r\n                      // That is because we only want handle this as few times as possible...\r\n                      //\r\n                      SourceStepField detailSource = findDetailSource(targetMap, targetStep, rowEntry.getKey());\r\n                      if (detailSource!=null) {\r\n                        setEntryValue(rowEntry, row, detailSource);\r\n                      } else {\r\n                        if (log.isDetailed()) logDetailed(\"No detail source found for key: \"+rowEntry.getKey()+\" and target step: \"+targetStep);\r\n                      }\r\n                    }\r\n                  } catch(Exception e) {\r\n                    throw new KettleException(\"Unexpected error occurred while injecting metadata\", e);\r\n                  }\r\n                }\r\n                \r\n                if (log.isDetailed()) logDetailed(\"injected entry: \"+entry);\r\n              }\r\n              // End of TopLevel/Detail if block\r\n            } else {\r\n              if (log.isDetailed()) logDetailed(\"entry not found: \"+target.getAttributeKey());\r\n            }\r\n          } else {\r\n            if (log.isDetailed()) logDetailed(\"No rows found for source step: \"+source.getStepname());\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Inject the metadata into the step!\r\n      //\r\n      injectionInterface.injectStepMetadataEntries(inject);\r\n    }\r\n    \r\n    if (log.isDetailed()) logDetailed(\"XML of transformation after injection: \"+data.transMeta.getXML());\r\n    \r\n    // Now we can execute this modified transformation metadata.\r\n    //\r\n    final Trans injectTrans = new Trans(data.transMeta, this);\r\n    getTrans().addTransStoppedListener(new TransStoppedListener() {\r\n      public void transStopped(Trans parentTrans) {\r\n        injectTrans.stopAll();\r\n      }\r\n    });\r\n    injectTrans.prepareExecution(null);\r\n    \r\n    if (!Const.isEmpty(meta.getSourceStepName())) {\r\n      StepInterface stepInterface = injectTrans.getStepInterface(meta.getSourceStepName(), 0);\r\n      if (stepInterface==null) {\r\n        throw new KettleException(\"Unable to find step '\"+meta.getSourceStepName()+\"' to read from.\");\r\n      }\r\n      stepInterface.addRowListener(new RowAdapter() {\r\n        @Override\r\n        public void rowWrittenEvent(RowMetaInterface rowMeta, Object[] row) throws KettleStepException {\r\n          // Just pass along the data as output of this step...\r\n          //\r\n          MetaInject.this.putRow(rowMeta, row);\r\n        }\r\n      });\r\n    }\r\n    \r\n    injectTrans.startThreads();\r\n    while (!injectTrans.isFinished() && !injectTrans.isStopped()) {\r\n      copyResult(injectTrans);\r\n      \r\n      // Wait a little bit.\r\n      try { Thread.sleep(500); } catch (Exception e) { }\r\n    }\r\n    copyResult(injectTrans);\r\n    \r\n    setOutputDone();\r\n\r\n    return false;\r\n  }","commit_id":"64af8020a5828a09d49c8a6d70796332850bb7b2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n   * Copy information from the meta-data input to the dialog fields.\r\n   */\r\n  public void getData() {\r\n    wStepname.selectAll();\r\n\r\n    specificationMethod = metaInjectMeta.getSpecificationMethod();\r\n    switch (specificationMethod) {\r\n    case FILENAME:\r\n      wFilename.setText(Const.NVL(metaInjectMeta.getFileName(), \"\"));\r\n      break;\r\n    case REPOSITORY_BY_NAME:\r\n      wDirectory.setText(Const.NVL(metaInjectMeta.getDirectoryPath(), \"\"));\r\n      wTransname.setText(Const.NVL(metaInjectMeta.getTransName(), \"\"));\r\n      break;\r\n    case REPOSITORY_BY_REFERENCE:\r\n      referenceObjectId = metaInjectMeta.getTransObjectId();\r\n      wByReference.setText(\"\");\r\n      try {\r\n        RepositoryObject transInf = repository.getObjectInformation(metaInjectMeta.getTransObjectId(), RepositoryObjectType.TRANSFORMATION);\r\n        if (transInf != null) {\r\n          getByReferenceData(transInf);\r\n        }\r\n      } catch (KettleException e) {\r\n        new ErrorDialog(shell, BaseMessages.getString(PKG, \"MetaInjectDialog.Exception.UnableToReferenceObjectId.Title\"), BaseMessages.getString(PKG, \"MetaInjectDialog.Exception.UnableToReferenceObjectId.Message\"), e);\r\n      }\r\n      break;\r\n    }\r\n    setRadioButtons();\r\n\r\n    refreshTree();\r\n  }","id":98522,"modified_method":"/**\r\n   * Copy information from the meta-data input to the dialog fields.\r\n   */\r\n  public void getData() {\r\n    wStepname.selectAll();\r\n\r\n    specificationMethod = metaInjectMeta.getSpecificationMethod();\r\n    switch (specificationMethod) {\r\n    case FILENAME:\r\n      wFilename.setText(Const.NVL(metaInjectMeta.getFileName(), \"\"));\r\n      break;\r\n    case REPOSITORY_BY_NAME:\r\n      wDirectory.setText(Const.NVL(metaInjectMeta.getDirectoryPath(), \"\"));\r\n      wTransname.setText(Const.NVL(metaInjectMeta.getTransName(), \"\"));\r\n      break;\r\n    case REPOSITORY_BY_REFERENCE:\r\n      referenceObjectId = metaInjectMeta.getTransObjectId();\r\n      wByReference.setText(\"\");\r\n      try {\r\n        RepositoryObject transInf = repository.getObjectInformation(metaInjectMeta.getTransObjectId(), RepositoryObjectType.TRANSFORMATION);\r\n        if (transInf != null) {\r\n          getByReferenceData(transInf);\r\n        }\r\n      } catch (KettleException e) {\r\n        new ErrorDialog(shell, BaseMessages.getString(PKG, \"MetaInjectDialog.Exception.UnableToReferenceObjectId.Title\"), BaseMessages.getString(PKG, \"MetaInjectDialog.Exception.UnableToReferenceObjectId.Message\"), e);\r\n      }\r\n      break;\r\n    }\r\n    \r\n    wSourceStep.setText(Const.NVL(metaInjectMeta.getSourceStepName(), \"\"));\r\n    \r\n    setRadioButtons();\r\n    \r\n    refreshTree();\r\n  }","commit_id":"64af8020a5828a09d49c8a6d70796332850bb7b2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open() {\r\n    Shell parent = getParent();\r\n    Display display = parent.getDisplay();\r\n\r\n    shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\r\n    props.setLook(shell);\r\n    setShellImage(shell, metaInjectMeta);\r\n\r\n    lsMod = new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        metaInjectMeta.setChanged();\r\n      }\r\n    };\r\n    changed = metaInjectMeta.hasChanged();\r\n\r\n    FormLayout formLayout = new FormLayout();\r\n    formLayout.marginWidth = Const.FORM_MARGIN;\r\n    formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n    shell.setLayout(formLayout);\r\n    shell.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Shell.Title\")); //$NON-NLS-1$\r\n\r\n    middle = props.getMiddlePct();\r\n    margin = Const.MARGIN;\r\n\r\n    // Stepname line\n    wlStepname = new Label(shell, SWT.RIGHT);\r\n    wlStepname.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Stepname.Label\")); //$NON-NLS-1$\r\n    props.setLook(wlStepname);\r\n    fdlStepname = new FormData();\r\n    fdlStepname.left = new FormAttachment(0, 0);\r\n    fdlStepname.right = new FormAttachment(middle, -margin);\r\n    fdlStepname.top = new FormAttachment(0, margin);\r\n    wlStepname.setLayoutData(fdlStepname);\r\n    wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    wStepname.setText(stepname);\r\n    props.setLook(wStepname);\r\n    wStepname.addModifyListener(lsMod);\r\n    fdStepname = new FormData();\r\n    fdStepname.left = new FormAttachment(middle, 0);\r\n    fdStepname.top = new FormAttachment(0, margin);\r\n    fdStepname.right = new FormAttachment(100, 0);\r\n    wStepname.setLayoutData(fdStepname);\r\n\r\n    // Show a group with 2 main options: a transformation in the repository\n    // or on file\n    //\n\r\n    // //////////////////////////////////////////////////\n    // The key creation box\n    // //////////////////////////////////////////////////\n    //\n    gTransGroup = new Group(shell, SWT.SHADOW_ETCHED_IN);\r\n    gTransGroup.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.TransGroup.Label\")); //$NON-NLS-1$;\r\n    gTransGroup.setBackground(shell.getBackground()); // the default looks\n    // ugly\n    FormLayout transGroupLayout = new FormLayout();\r\n    transGroupLayout.marginLeft = margin * 2;\r\n    transGroupLayout.marginTop = margin * 2;\r\n    transGroupLayout.marginRight = margin * 2;\r\n    transGroupLayout.marginBottom = margin * 2;\r\n    gTransGroup.setLayout(transGroupLayout);\r\n\r\n    // Radio button: The mapping is in a file\n    // \n    radioFilename = new Button(gTransGroup, SWT.RADIO);\r\n    props.setLook(radioFilename);\r\n    radioFilename.setSelection(false);\r\n    radioFilename.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioFile.Label\")); //$NON-NLS-1$\r\n    radioFilename.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioFile.Tooltip\", Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\r\n    FormData fdFileRadio = new FormData();\r\n    fdFileRadio.left = new FormAttachment(0, 0);\r\n    fdFileRadio.right = new FormAttachment(100, 0);\r\n    fdFileRadio.top = new FormAttachment(0, 0);\r\n    radioFilename.setLayoutData(fdFileRadio);\r\n    radioFilename.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.FILENAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wbbFilename = new Button(gTransGroup, SWT.PUSH | SWT.CENTER); // Browse\n    props.setLook(wbbFilename);\r\n    wbbFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n    wbbFilename.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.BrowseForFileOrDirAndAdd\"));\r\n    FormData fdbFilename = new FormData();\r\n    fdbFilename.right = new FormAttachment(100, 0);\r\n    fdbFilename.top = new FormAttachment(radioFilename, margin);\r\n    wbbFilename.setLayoutData(fdbFilename);\r\n    wbbFilename.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        selectFileTrans();\r\n      }\r\n    });\r\n\r\n    wFilename = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    props.setLook(wFilename);\r\n    wFilename.addModifyListener(lsMod);\r\n    FormData fdFilename = new FormData();\r\n    fdFilename.left = new FormAttachment(0, 25);\r\n    fdFilename.right = new FormAttachment(wbbFilename, -margin);\r\n    fdFilename.top = new FormAttachment(wbbFilename, 0, SWT.CENTER);\r\n    wFilename.setLayoutData(fdFilename);\r\n    wFilename.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.FILENAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    // Radio button: The mapping is in the repository\n    // \n    radioByName = new Button(gTransGroup, SWT.RADIO);\r\n    props.setLook(radioByName);\r\n    radioByName.setSelection(false);\r\n    radioByName.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRep.Label\")); //$NON-NLS-1$\r\n    radioByName.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRep.Tooltip\", Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\r\n    FormData fdRepRadio = new FormData();\r\n    fdRepRadio.left = new FormAttachment(0, 0);\r\n    fdRepRadio.right = new FormAttachment(100, 0);\r\n    fdRepRadio.top = new FormAttachment(wbbFilename, 2 * margin);\r\n    radioByName.setLayoutData(fdRepRadio);\r\n    radioByName.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_NAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n    wbTrans = new Button(gTransGroup, SWT.PUSH | SWT.CENTER); // Browse\n    props.setLook(wbTrans);\r\n    wbTrans.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Select.Button\"));\r\n    wbTrans.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.BrowseForFileOrDirAndAdd\"));\r\n    FormData fdbTrans = new FormData();\r\n    fdbTrans.right = new FormAttachment(100, 0);\r\n    fdbTrans.top = new FormAttachment(radioByName, 2 * margin);\r\n    wbTrans.setLayoutData(fdbTrans);\r\n    wbTrans.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        selectRepositoryTrans();\r\n      }\r\n    });\r\n\r\n    wDirectory = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    props.setLook(wDirectory);\r\n    wDirectory.addModifyListener(lsMod);\r\n    FormData fdTransDir = new FormData();\r\n    fdTransDir.left = new FormAttachment(middle + (100 - middle) / 2, 0);\r\n    fdTransDir.right = new FormAttachment(wbTrans, -margin);\r\n    fdTransDir.top = new FormAttachment(wbTrans, 0, SWT.CENTER);\r\n    wDirectory.setLayoutData(fdTransDir);\r\n    wDirectory.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_NAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wTransname = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    props.setLook(wTransname);\r\n    wTransname.addModifyListener(lsMod);\r\n    FormData fdTransName = new FormData();\r\n    fdTransName.left = new FormAttachment(0, 25);\r\n    fdTransName.right = new FormAttachment(wDirectory, -margin);\r\n    fdTransName.top = new FormAttachment(wbTrans, 0, SWT.CENTER);\r\n    wTransname.setLayoutData(fdTransName);\r\n    wTransname.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_NAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    // Radio button: The mapping is in the repository\r\n    // \r\n    radioByReference = new Button(gTransGroup, SWT.RADIO);\r\n    props.setLook(radioByReference);\r\n    radioByReference.setSelection(false);\r\n    radioByReference.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRepByReference.Label\")); //$NON-NLS-1$\r\n    radioByReference.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRepByReference.Tooltip\", Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\r\n    FormData fdRadioByReference = new FormData();\r\n    fdRadioByReference.left = new FormAttachment(0, 0);\r\n    fdRadioByReference.right = new FormAttachment(100, 0);\r\n    fdRadioByReference.top = new FormAttachment(wTransname, 2 * margin);\r\n    radioByReference.setLayoutData(fdRadioByReference);\r\n    radioByReference.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_REFERENCE;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wbByReference = new Button(gTransGroup, SWT.PUSH | SWT.CENTER);\r\n    props.setLook(wbByReference);\r\n    wbByReference.setImage(GUIResource.getInstance().getImageTransGraph());\r\n    wbByReference.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.SelectTrans.Tooltip\"));\r\n    FormData fdbByReference = new FormData();\r\n    fdbByReference.top = new FormAttachment(radioByReference, margin);\r\n    fdbByReference.right = new FormAttachment(100, 0);\r\n    wbByReference.setLayoutData(fdbByReference);\r\n    wbByReference.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        selectTransformationByReference();\r\n      }\r\n    });\r\n\r\n    wByReference = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.READ_ONLY);\r\n    props.setLook(wByReference);\r\n    wByReference.addModifyListener(lsMod);\r\n    FormData fdByReference = new FormData();\r\n    fdByReference.top = new FormAttachment(radioByReference, margin);\r\n    fdByReference.left = new FormAttachment(0, 25);\r\n    fdByReference.right = new FormAttachment(wbByReference, -margin);\r\n    wByReference.setLayoutData(fdByReference);\r\n    wByReference.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_REFERENCE;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wEditTrans = new Button(gTransGroup, SWT.PUSH | SWT.CENTER); // Browse\n    props.setLook(wEditTrans);\r\n    wEditTrans.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Edit.Button\"));\r\n    wEditTrans.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.BrowseForFileOrDirAndAdd\"));\r\n    FormData fdEditTrans = new FormData();\r\n    fdEditTrans.left = new FormAttachment(0, 0);\r\n    fdEditTrans.right = new FormAttachment(100, 0);\r\n    fdEditTrans.top = new FormAttachment(wByReference, 3 * margin);\r\n    wEditTrans.setLayoutData(fdEditTrans);\r\n    wEditTrans.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        editTrans();\r\n      }\r\n    });\r\n\r\n    FormData fdTransGroup = new FormData();\r\n    fdTransGroup.left = new FormAttachment(0, 0);\r\n    fdTransGroup.top = new FormAttachment(wStepname, 2 * margin);\r\n    fdTransGroup.right = new FormAttachment(100, 0);\r\n    // fdTransGroup.bottom = new FormAttachment(wStepname, 350);\n    gTransGroup.setLayoutData(fdTransGroup);\r\n\r\n    // Some buttons\r\n    wOK = new Button(shell, SWT.PUSH);\r\n    wOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\r\n    wCancel = new Button(shell, SWT.PUSH);\r\n    wCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\r\n    setButtonPositions(new Button[] { wOK, wCancel }, margin, null);\r\n    \r\n    // Now the tree with the field selection etc.\r\n    //\r\n    addTree();\r\n    \r\n\r\n    // Add listeners\n    lsCancel = new Listener() {\r\n      public void handleEvent(Event e) {\r\n        cancel();\r\n      }\r\n    };\r\n    lsOK = new Listener() {\r\n      public void handleEvent(Event e) {\r\n        ok();\r\n      }\r\n    };\r\n\r\n    wCancel.addListener(SWT.Selection, lsCancel);\r\n    wOK.addListener(SWT.Selection, lsOK);\r\n\r\n    lsDef = new SelectionAdapter() {\r\n      public void widgetDefaultSelected(SelectionEvent e) {\r\n        ok();\r\n      }\r\n    };\r\n\r\n    wStepname.addSelectionListener(lsDef);\r\n    wFilename.addSelectionListener(lsDef);\r\n    wTransname.addSelectionListener(lsDef);\r\n\r\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener(new ShellAdapter() {\r\n      public void shellClosed(ShellEvent e) {\r\n        cancel();\r\n      }\r\n    });\r\n\r\n    // Set the shell size, based upon previous time...\n    setSize();\r\n\r\n    getData();\r\n    metaInjectMeta.setChanged(changed);\r\n\r\n    shell.open();\r\n    while (!shell.isDisposed()) {\r\n      if (!display.readAndDispatch())\r\n        display.sleep();\r\n    }\r\n    return stepname;\r\n  }","id":98523,"modified_method":"public String open() {\r\n    Shell parent = getParent();\r\n    Display display = parent.getDisplay();\r\n\r\n    shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\r\n    props.setLook(shell);\r\n    setShellImage(shell, metaInjectMeta);\r\n\r\n    lsMod = new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        metaInjectMeta.setChanged();\r\n      }\r\n    };\r\n    changed = metaInjectMeta.hasChanged();\r\n\r\n    FormLayout formLayout = new FormLayout();\r\n    formLayout.marginWidth = Const.FORM_MARGIN;\r\n    formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n    shell.setLayout(formLayout);\r\n    shell.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Shell.Title\")); //$NON-NLS-1$\r\n\r\n    middle = props.getMiddlePct();\r\n    margin = Const.MARGIN;\r\n\r\n    // Stepname line\n    wlStepname = new Label(shell, SWT.RIGHT);\r\n    wlStepname.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Stepname.Label\")); //$NON-NLS-1$\r\n    props.setLook(wlStepname);\r\n    fdlStepname = new FormData();\r\n    fdlStepname.left = new FormAttachment(0, 0);\r\n    fdlStepname.right = new FormAttachment(middle, -margin);\r\n    fdlStepname.top = new FormAttachment(0, margin);\r\n    wlStepname.setLayoutData(fdlStepname);\r\n    wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    wStepname.setText(stepname);\r\n    props.setLook(wStepname);\r\n    wStepname.addModifyListener(lsMod);\r\n    fdStepname = new FormData();\r\n    fdStepname.left = new FormAttachment(middle, 0);\r\n    fdStepname.top = new FormAttachment(0, margin);\r\n    fdStepname.right = new FormAttachment(100, 0);\r\n    wStepname.setLayoutData(fdStepname);\r\n\r\n    // Show a group with 2 main options: a transformation in the repository\n    // or on file\n    //\n\r\n    // //////////////////////////////////////////////////\n    // The key creation box\n    // //////////////////////////////////////////////////\n    //\n    gTransGroup = new Group(shell, SWT.SHADOW_ETCHED_IN);\r\n    gTransGroup.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.TransGroup.Label\")); //$NON-NLS-1$;\r\n    gTransGroup.setBackground(shell.getBackground()); // the default looks\n    // ugly\n    FormLayout transGroupLayout = new FormLayout();\r\n    transGroupLayout.marginLeft = margin * 2;\r\n    transGroupLayout.marginTop = margin * 2;\r\n    transGroupLayout.marginRight = margin * 2;\r\n    transGroupLayout.marginBottom = margin * 2;\r\n    gTransGroup.setLayout(transGroupLayout);\r\n\r\n    // Radio button: The mapping is in a file\n    // \n    radioFilename = new Button(gTransGroup, SWT.RADIO);\r\n    props.setLook(radioFilename);\r\n    radioFilename.setSelection(false);\r\n    radioFilename.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioFile.Label\")); //$NON-NLS-1$\r\n    radioFilename.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioFile.Tooltip\", Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\r\n    FormData fdFileRadio = new FormData();\r\n    fdFileRadio.left = new FormAttachment(0, 0);\r\n    fdFileRadio.right = new FormAttachment(100, 0);\r\n    fdFileRadio.top = new FormAttachment(0, 0);\r\n    radioFilename.setLayoutData(fdFileRadio);\r\n    radioFilename.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.FILENAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wbbFilename = new Button(gTransGroup, SWT.PUSH | SWT.CENTER); // Browse\n    props.setLook(wbbFilename);\r\n    wbbFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n    wbbFilename.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.BrowseForFileOrDirAndAdd\"));\r\n    FormData fdbFilename = new FormData();\r\n    fdbFilename.right = new FormAttachment(100, 0);\r\n    fdbFilename.top = new FormAttachment(radioFilename, margin);\r\n    wbbFilename.setLayoutData(fdbFilename);\r\n    wbbFilename.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        selectFileTrans();\r\n      }\r\n    });\r\n\r\n    wFilename = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    props.setLook(wFilename);\r\n    wFilename.addModifyListener(lsMod);\r\n    FormData fdFilename = new FormData();\r\n    fdFilename.left = new FormAttachment(0, 25);\r\n    fdFilename.right = new FormAttachment(wbbFilename, -margin);\r\n    fdFilename.top = new FormAttachment(wbbFilename, 0, SWT.CENTER);\r\n    wFilename.setLayoutData(fdFilename);\r\n    wFilename.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.FILENAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    // Radio button: The mapping is in the repository\n    // \n    radioByName = new Button(gTransGroup, SWT.RADIO);\r\n    props.setLook(radioByName);\r\n    radioByName.setSelection(false);\r\n    radioByName.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRep.Label\")); //$NON-NLS-1$\r\n    radioByName.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRep.Tooltip\", Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\r\n    FormData fdRepRadio = new FormData();\r\n    fdRepRadio.left = new FormAttachment(0, 0);\r\n    fdRepRadio.right = new FormAttachment(100, 0);\r\n    fdRepRadio.top = new FormAttachment(wbbFilename, 2 * margin);\r\n    radioByName.setLayoutData(fdRepRadio);\r\n    radioByName.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_NAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n    wbTrans = new Button(gTransGroup, SWT.PUSH | SWT.CENTER); // Browse\n    props.setLook(wbTrans);\r\n    wbTrans.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Select.Button\"));\r\n    wbTrans.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.BrowseForFileOrDirAndAdd\"));\r\n    FormData fdbTrans = new FormData();\r\n    fdbTrans.right = new FormAttachment(100, 0);\r\n    fdbTrans.top = new FormAttachment(radioByName, 2 * margin);\r\n    wbTrans.setLayoutData(fdbTrans);\r\n    wbTrans.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        selectRepositoryTrans();\r\n      }\r\n    });\r\n\r\n    wDirectory = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    props.setLook(wDirectory);\r\n    wDirectory.addModifyListener(lsMod);\r\n    FormData fdTransDir = new FormData();\r\n    fdTransDir.left = new FormAttachment(middle + (100 - middle) / 2, 0);\r\n    fdTransDir.right = new FormAttachment(wbTrans, -margin);\r\n    fdTransDir.top = new FormAttachment(wbTrans, 0, SWT.CENTER);\r\n    wDirectory.setLayoutData(fdTransDir);\r\n    wDirectory.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_NAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wTransname = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    props.setLook(wTransname);\r\n    wTransname.addModifyListener(lsMod);\r\n    FormData fdTransName = new FormData();\r\n    fdTransName.left = new FormAttachment(0, 25);\r\n    fdTransName.right = new FormAttachment(wDirectory, -margin);\r\n    fdTransName.top = new FormAttachment(wbTrans, 0, SWT.CENTER);\r\n    wTransname.setLayoutData(fdTransName);\r\n    wTransname.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_NAME;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    // Radio button: The mapping is in the repository\r\n    // \r\n    radioByReference = new Button(gTransGroup, SWT.RADIO);\r\n    props.setLook(radioByReference);\r\n    radioByReference.setSelection(false);\r\n    radioByReference.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRepByReference.Label\")); //$NON-NLS-1$\r\n    radioByReference.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.RadioRepByReference.Tooltip\", Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\r\n    FormData fdRadioByReference = new FormData();\r\n    fdRadioByReference.left = new FormAttachment(0, 0);\r\n    fdRadioByReference.right = new FormAttachment(100, 0);\r\n    fdRadioByReference.top = new FormAttachment(wTransname, 2 * margin);\r\n    radioByReference.setLayoutData(fdRadioByReference);\r\n    radioByReference.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_REFERENCE;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wbByReference = new Button(gTransGroup, SWT.PUSH | SWT.CENTER);\r\n    props.setLook(wbByReference);\r\n    wbByReference.setImage(GUIResource.getInstance().getImageTransGraph());\r\n    wbByReference.setToolTipText(BaseMessages.getString(PKG, \"MetaInjectDialog.SelectTrans.Tooltip\"));\r\n    FormData fdbByReference = new FormData();\r\n    fdbByReference.top = new FormAttachment(radioByReference, margin);\r\n    fdbByReference.right = new FormAttachment(100, 0);\r\n    wbByReference.setLayoutData(fdbByReference);\r\n    wbByReference.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        selectTransformationByReference();\r\n      }\r\n    });\r\n\r\n    wByReference = new TextVar(transMeta, gTransGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.READ_ONLY);\r\n    props.setLook(wByReference);\r\n    wByReference.addModifyListener(lsMod);\r\n    FormData fdByReference = new FormData();\r\n    fdByReference.top = new FormAttachment(radioByReference, margin);\r\n    fdByReference.left = new FormAttachment(0, 25);\r\n    fdByReference.right = new FormAttachment(wbByReference, -margin);\r\n    wByReference.setLayoutData(fdByReference);\r\n    wByReference.addModifyListener(new ModifyListener() {\r\n      public void modifyText(ModifyEvent e) {\r\n        specificationMethod = ObjectLocationSpecificationMethod.REPOSITORY_BY_REFERENCE;\r\n        setRadioButtons();\r\n      }\r\n    });\r\n\r\n    wEditTrans = new Button(gTransGroup, SWT.PUSH | SWT.CENTER); // Browse\n    props.setLook(wEditTrans);\r\n    wEditTrans.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.Edit.Button\"));\r\n    wEditTrans.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.BrowseForFileOrDirAndAdd\"));\r\n    FormData fdEditTrans = new FormData();\r\n    fdEditTrans.left = new FormAttachment(0, 0);\r\n    fdEditTrans.right = new FormAttachment(100, 0);\r\n    fdEditTrans.top = new FormAttachment(wByReference, 3 * margin);\r\n    wEditTrans.setLayoutData(fdEditTrans);\r\n    wEditTrans.addSelectionListener(new SelectionAdapter() {\r\n      public void widgetSelected(SelectionEvent e) {\r\n        editTrans();\r\n      }\r\n    });\r\n\r\n    FormData fdTransGroup = new FormData();\r\n    fdTransGroup.left = new FormAttachment(0, 0);\r\n    fdTransGroup.top = new FormAttachment(wStepname, 2 * margin);\r\n    fdTransGroup.right = new FormAttachment(100, 0);\r\n    // fdTransGroup.bottom = new FormAttachment(wStepname, 350);\n    gTransGroup.setLayoutData(fdTransGroup);\r\n    \r\n    Label wlSourceStep = new Label(shell, SWT.LEFT);\r\n    wlSourceStep.setText(BaseMessages.getString(PKG, \"MetaInjectDialog.SourceStep.Label\")); //$NON-NLS-1$\r\n    props.setLook(wlSourceStep);\r\n    FormData fdlSourceStep = new FormData();\r\n    fdlSourceStep.left = new FormAttachment(0, 0);\r\n    fdlSourceStep.top = new FormAttachment(gTransGroup, 2*margin);\r\n    wlSourceStep.setLayoutData(fdlSourceStep);\r\n    wSourceStep = new CCombo(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n    wSourceStep.setText(stepname);\r\n    props.setLook(wSourceStep);\r\n    wSourceStep.addModifyListener(lsMod);\r\n    FormData fdSourceStep = new FormData();\r\n    fdSourceStep.left = new FormAttachment(wlSourceStep, 2*margin);\r\n    fdSourceStep.top = new FormAttachment(gTransGroup, margin);\r\n    fdSourceStep.right = new FormAttachment(100, 0);\r\n    wSourceStep.setLayoutData(fdSourceStep);\r\n\r\n    // Some buttons\r\n    wOK = new Button(shell, SWT.PUSH);\r\n    wOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\r\n    wCancel = new Button(shell, SWT.PUSH);\r\n    wCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\r\n    setButtonPositions(new Button[] { wOK, wCancel }, margin, null);\r\n    \r\n    // Now the tree with the field selection etc.\r\n    //\r\n    addTree();\r\n    \r\n\r\n    // Add listeners\n    lsCancel = new Listener() {\r\n      public void handleEvent(Event e) {\r\n        cancel();\r\n      }\r\n    };\r\n    lsOK = new Listener() {\r\n      public void handleEvent(Event e) {\r\n        ok();\r\n      }\r\n    };\r\n\r\n    wCancel.addListener(SWT.Selection, lsCancel);\r\n    wOK.addListener(SWT.Selection, lsOK);\r\n\r\n    lsDef = new SelectionAdapter() {\r\n      public void widgetDefaultSelected(SelectionEvent e) {\r\n        ok();\r\n      }\r\n    };\r\n\r\n    wStepname.addSelectionListener(lsDef);\r\n    wFilename.addSelectionListener(lsDef);\r\n    wTransname.addSelectionListener(lsDef);\r\n\r\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener(new ShellAdapter() {\r\n      public void shellClosed(ShellEvent e) {\r\n        cancel();\r\n      }\r\n    });\r\n\r\n    // Set the shell size, based upon previous time...\n    setSize();\r\n\r\n    getData();\r\n    metaInjectMeta.setChanged(changed);\r\n\r\n    shell.open();\r\n    while (!shell.isDisposed()) {\r\n      if (!display.readAndDispatch())\r\n        display.sleep();\r\n    }\r\n    return stepname;\r\n  }","commit_id":"64af8020a5828a09d49c8a6d70796332850bb7b2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok() {\r\n    if (Const.isEmpty(wStepname.getText()))\r\n      return;\r\n\r\n    stepname = wStepname.getText(); // return value\n\r\n    try {\r\n      loadTransformation();\r\n    } catch (KettleException e) {\r\n      new ErrorDialog(shell, BaseMessages.getString(PKG, \"MetaInjectDialog.ErrorLoadingSpecifiedTransformation.Title\"), \r\n          BaseMessages.getString(PKG, \"MetaInjectDialog.ErrorLoadingSpecifiedTransformation.Message\"), e);\r\n    }\r\n\r\n    metaInjectMeta.setSpecificationMethod(specificationMethod);\r\n    switch (specificationMethod) {\r\n    case FILENAME:\r\n      metaInjectMeta.setFileName(wFilename.getText());\r\n      metaInjectMeta.setDirectoryPath(null);\r\n      metaInjectMeta.setTransName(null);\r\n      metaInjectMeta.setTransObjectId(null);\r\n      break;\r\n    case REPOSITORY_BY_NAME:\r\n      metaInjectMeta.setDirectoryPath(wDirectory.getText());\r\n      metaInjectMeta.setTransName(wTransname.getText());\r\n      metaInjectMeta.setFileName(null);\r\n      metaInjectMeta.setTransObjectId(null);\r\n      break;\r\n    case REPOSITORY_BY_REFERENCE:\r\n      metaInjectMeta.setFileName(null);\r\n      metaInjectMeta.setDirectoryPath(null);\r\n      metaInjectMeta.setTransName(null);\r\n      metaInjectMeta.setTransObjectId(referenceObjectId);\r\n      break;\r\n    }\r\n    \r\n    metaInjectMeta.setTargetSourceMapping(targetSourceMapping);\r\n    metaInjectMeta.setChanged(true);\r\n\r\n    dispose();\r\n  }","id":98524,"modified_method":"private void ok() {\r\n    if (Const.isEmpty(wStepname.getText()))\r\n      return;\r\n\r\n    stepname = wStepname.getText(); // return value\n\r\n    try {\r\n      loadTransformation();\r\n    } catch (KettleException e) {\r\n      new ErrorDialog(shell, BaseMessages.getString(PKG, \"MetaInjectDialog.ErrorLoadingSpecifiedTransformation.Title\"), \r\n          BaseMessages.getString(PKG, \"MetaInjectDialog.ErrorLoadingSpecifiedTransformation.Message\"), e);\r\n    }\r\n\r\n    metaInjectMeta.setSpecificationMethod(specificationMethod);\r\n    switch (specificationMethod) {\r\n    case FILENAME:\r\n      metaInjectMeta.setFileName(wFilename.getText());\r\n      metaInjectMeta.setDirectoryPath(null);\r\n      metaInjectMeta.setTransName(null);\r\n      metaInjectMeta.setTransObjectId(null);\r\n      break;\r\n    case REPOSITORY_BY_NAME:\r\n      metaInjectMeta.setDirectoryPath(wDirectory.getText());\r\n      metaInjectMeta.setTransName(wTransname.getText());\r\n      metaInjectMeta.setFileName(null);\r\n      metaInjectMeta.setTransObjectId(null);\r\n      break;\r\n    case REPOSITORY_BY_REFERENCE:\r\n      metaInjectMeta.setFileName(null);\r\n      metaInjectMeta.setDirectoryPath(null);\r\n      metaInjectMeta.setTransName(null);\r\n      metaInjectMeta.setTransObjectId(referenceObjectId);\r\n      break;\r\n    }\r\n    \r\n    metaInjectMeta.setSourceStepName(wSourceStep.getText());\r\n    \r\n    metaInjectMeta.setTargetSourceMapping(targetSourceMapping);\r\n    metaInjectMeta.setChanged(true);\r\n\r\n    dispose();\r\n  }","commit_id":"64af8020a5828a09d49c8a6d70796332850bb7b2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addTree() {\r\n    \r\n    wTree = new Tree(shell, SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);\r\n    FormData fdTree = new FormData();\r\n    fdTree.left = new FormAttachment(0,0);\r\n    fdTree.right = new FormAttachment(100,0);\r\n    fdTree.top = new FormAttachment(gTransGroup, 2*margin);\r\n    fdTree.bottom = new FormAttachment(wOK, -2*margin);\r\n    wTree.setLayoutData(fdTree);\r\n    \r\n    ColumnInfo[] colinf = new ColumnInfo[] { \r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.TargetStep\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.TargetDescription\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.SourceStep\"), ColumnInfo.COLUMN_TYPE_CCOMBO, false, true), //$NON-NLS-1$\r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.SourceField\"), ColumnInfo.COLUMN_TYPE_CCOMBO, false, true), //$NON-NLS-1$\r\n    };\r\n    \r\n    wTree.setHeaderVisible(true);\r\n    for (int i=0;i<colinf.length;i++) {\r\n        ColumnInfo columnInfo = colinf[i];\r\n        TreeColumn treeColumn = new TreeColumn(wTree, columnInfo.getAllignement());\r\n        treeColumn.setText(columnInfo.getName());\r\n        treeColumn.setWidth(200);\r\n    }\r\n    \r\n    wTree.addListener(SWT.MouseDown, new Listener() {\r\n      public void handleEvent(Event event) {\r\n        try {\r\n          Point point = new Point(event.x, event.y);\r\n          TreeItem item = wTree.getItem(point);\r\n          if (item != null) {\r\n            TargetStepAttribute target = treeItemTargetMap.get(item);\r\n            if (target!=null) {\r\n              SourceStepField source = targetSourceMapping.get(target);\r\n              \r\n              String[] prevStepNames = transMeta.getPrevStepNames(stepMeta);\r\n              Arrays.sort(prevStepNames);\r\n              EnterSelectionDialog selectStep = new EnterSelectionDialog(shell, prevStepNames, \"Select source step\", \"Select the source step\");\r\n              if (source!=null && !Const.isEmpty(source.getStepname())) {\r\n                int index = Const.indexOfString(source.getStepname(), prevStepNames);\r\n                if (index>=0) {\r\n                  selectStep.setSelectedNrs(new int[] {index,});\r\n                }\r\n              }\r\n              String prevStep = selectStep.open();\r\n              if (prevStep!=null) {\r\n                // OK, now we list the fields from that step...\r\n                //\r\n                RowMetaInterface fields = transMeta.getStepFields(prevStep);\r\n                String[] fieldNames = fields.getFieldNames();\r\n                Arrays.sort(fieldNames);\r\n                EnterSelectionDialog selectField = new EnterSelectionDialog(shell, fieldNames, \"Select field\", \"Select the source field\");\r\n                if (source!=null && !Const.isEmpty(source.getField())) {\r\n                  int index = Const.indexOfString(source.getField(), fieldNames);\r\n                  if (index>=0) {\r\n                    selectField.setSelectedNrs(new int[] {index,});\r\n                  }\r\n                }\r\n                String fieldName = selectField.open();\r\n                if (fieldName!=null) {\r\n                  // Store the selection, update the UI...\r\n                  //\r\n                  item.setText(2, prevStep);\r\n                  item.setText(3, fieldName);\r\n                  source = new SourceStepField(prevStep, fieldName);\r\n                  targetSourceMapping.put(target, source);\r\n                }\r\n              } else {\r\n                item.setText(2, \"\");\r\n                item.setText(3, \"\");\r\n                targetSourceMapping.remove(target);\r\n              }\r\n            } \r\n          }\r\n        } catch(Exception e) {\r\n          new ErrorDialog(shell, \"Oops\", \"Unexpected Error\", e);\r\n        }\r\n      }\r\n    }\r\n    );\r\n  }","id":98525,"modified_method":"private void addTree() {\r\n    \r\n    wTree = new Tree(shell, SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);\r\n    FormData fdTree = new FormData();\r\n    fdTree.left = new FormAttachment(0,0);\r\n    fdTree.right = new FormAttachment(100,0);\r\n    fdTree.top = new FormAttachment(wSourceStep, 2*margin);\r\n    fdTree.bottom = new FormAttachment(wOK, -2*margin);\r\n    wTree.setLayoutData(fdTree);\r\n    \r\n    ColumnInfo[] colinf = new ColumnInfo[] { \r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.TargetStep\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.TargetDescription\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.SourceStep\"), ColumnInfo.COLUMN_TYPE_CCOMBO, false, true), //$NON-NLS-1$\r\n        new ColumnInfo(BaseMessages.getString(PKG, \"MetaInjectDialog.Column.SourceField\"), ColumnInfo.COLUMN_TYPE_CCOMBO, false, true), //$NON-NLS-1$\r\n    };\r\n    \r\n    wTree.setHeaderVisible(true);\r\n    for (int i=0;i<colinf.length;i++) {\r\n        ColumnInfo columnInfo = colinf[i];\r\n        TreeColumn treeColumn = new TreeColumn(wTree, columnInfo.getAllignement());\r\n        treeColumn.setText(columnInfo.getName());\r\n        treeColumn.setWidth(200);\r\n    }\r\n    \r\n    wTree.addListener(SWT.MouseDown, new Listener() {\r\n      public void handleEvent(Event event) {\r\n        try {\r\n          Point point = new Point(event.x, event.y);\r\n          TreeItem item = wTree.getItem(point);\r\n          if (item != null) {\r\n            TargetStepAttribute target = treeItemTargetMap.get(item);\r\n            if (target!=null) {\r\n              SourceStepField source = targetSourceMapping.get(target);\r\n              \r\n              String[] prevStepNames = transMeta.getPrevStepNames(stepMeta);\r\n              Arrays.sort(prevStepNames);\r\n              EnterSelectionDialog selectStep = new EnterSelectionDialog(shell, prevStepNames, \"Select source step\", \"Select the source step\");\r\n              if (source!=null && !Const.isEmpty(source.getStepname())) {\r\n                int index = Const.indexOfString(source.getStepname(), prevStepNames);\r\n                if (index>=0) {\r\n                  selectStep.setSelectedNrs(new int[] {index,});\r\n                }\r\n              }\r\n              String prevStep = selectStep.open();\r\n              if (prevStep!=null) {\r\n                // OK, now we list the fields from that step...\r\n                //\r\n                RowMetaInterface fields = transMeta.getStepFields(prevStep);\r\n                String[] fieldNames = fields.getFieldNames();\r\n                Arrays.sort(fieldNames);\r\n                EnterSelectionDialog selectField = new EnterSelectionDialog(shell, fieldNames, \"Select field\", \"Select the source field\");\r\n                if (source!=null && !Const.isEmpty(source.getField())) {\r\n                  int index = Const.indexOfString(source.getField(), fieldNames);\r\n                  if (index>=0) {\r\n                    selectField.setSelectedNrs(new int[] {index,});\r\n                  }\r\n                }\r\n                String fieldName = selectField.open();\r\n                if (fieldName!=null) {\r\n                  // Store the selection, update the UI...\r\n                  //\r\n                  item.setText(2, prevStep);\r\n                  item.setText(3, fieldName);\r\n                  source = new SourceStepField(prevStep, fieldName);\r\n                  targetSourceMapping.put(target, source);\r\n                }\r\n              } else {\r\n                item.setText(2, \"\");\r\n                item.setText(3, \"\");\r\n                targetSourceMapping.remove(target);\r\n              }\r\n            } \r\n          }\r\n        } catch(Exception e) {\r\n          new ErrorDialog(shell, \"Oops\", \"Unexpected Error\", e);\r\n        }\r\n      }\r\n    }\r\n    );\r\n  }","commit_id":"64af8020a5828a09d49c8a6d70796332850bb7b2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void refreshTree() {\r\n    try {\r\n      loadTransformation();\r\n      \r\n      treeItemTargetMap = new HashMap<TreeItem, TargetStepAttribute>();\r\n      \r\n      wTree.removeAll();\r\n      \r\n      TreeItem transItem = new TreeItem(wTree, SWT.NONE);\r\n      transItem.setExpanded(true);\r\n      transItem.setText(injectTransMeta.getName());\r\n      List<StepMeta> injectSteps = new ArrayList<StepMeta>();\r\n      for (StepMeta stepMeta : injectTransMeta.getUsedSteps()) {\r\n        if (stepMeta.getStepMetaInterface().getStepMetaInjectionInterface()!=null) {\r\n          injectSteps.add(stepMeta);\r\n        }\r\n      }\r\n      Collections.sort(injectSteps);\r\n      \r\n      for (StepMeta stepMeta : injectSteps) {\r\n        TreeItem stepItem = new TreeItem(transItem, SWT.NONE);\r\n        stepItem.setText(stepMeta.getName());\r\n        stepItem.setExpanded(true);\r\n        \r\n        // For each step, add the keys\r\n        // \r\n        StepMetaInjectionInterface injection = stepMeta.getStepMetaInterface().getStepMetaInjectionInterface();\r\n        List<StepInjectionMetaEntry> entries = injection.getStepInjectionMetadataEntries();\r\n        for (final StepInjectionMetaEntry entry : entries) {\r\n          if (entry.getValueType()!=ValueMetaInterface.TYPE_NONE) {\r\n            TreeItem entryItem = new TreeItem(stepItem, SWT.NONE);\r\n            entryItem.setText(entry.getKey());\r\n            entryItem.setText(1, entry.getDescription());\r\n            TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), entry.getKey(), false);\r\n            treeItemTargetMap.put(entryItem, target);\r\n            \r\n            SourceStepField source = targetSourceMapping.get(target);\r\n            if (source!=null) {\r\n              entryItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n              entryItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n            }\r\n          } else {\r\n            // Fields...\r\n            //\r\n            TreeItem listsItem = new TreeItem(stepItem, SWT.NONE);\r\n            listsItem.setText(entry.getKey());\r\n            listsItem.setText(1, entry.getDescription());\r\n            \r\n            // Field...\r\n            //\r\n            StepInjectionMetaEntry listEntry = entry.getDetails().get(0);\r\n            TreeItem listItem = new TreeItem(listsItem, SWT.NONE);\r\n            listItem.setText(listEntry.getKey());\r\n            listItem.setText(1, listEntry.getDescription());\r\n            \r\n            for (StepInjectionMetaEntry me : listEntry.getDetails()) {\r\n              TreeItem treeItem = new TreeItem(listItem, SWT.NONE);\r\n              treeItem.setText(me.getKey());\r\n              treeItem.setText(1, me.getDescription());\r\n\r\n              TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), me.getKey(), true);\r\n              treeItemTargetMap.put(treeItem, target);\r\n              \r\n              SourceStepField source = targetSourceMapping.get(target);\r\n              if (source!=null) {\r\n                treeItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n                treeItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n              }              \r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n    } catch (Throwable t) {\r\n    }\r\n    \r\n    for (TreeItem item : wTree.getItems()) {\r\n      expandItemAndChildren(item);\r\n    }\r\n  }","id":98526,"modified_method":"private void refreshTree() {\r\n    try {\r\n      loadTransformation();\r\n      \r\n      treeItemTargetMap = new HashMap<TreeItem, TargetStepAttribute>();\r\n      \r\n      wTree.removeAll();\r\n      \r\n      TreeItem transItem = new TreeItem(wTree, SWT.NONE);\r\n      transItem.setExpanded(true);\r\n      transItem.setText(injectTransMeta.getName());\r\n      List<StepMeta> injectSteps = new ArrayList<StepMeta>();\r\n      for (StepMeta stepMeta : injectTransMeta.getUsedSteps()) {\r\n        if (stepMeta.getStepMetaInterface().getStepMetaInjectionInterface()!=null) {\r\n          injectSteps.add(stepMeta);\r\n        }\r\n      }\r\n      Collections.sort(injectSteps);\r\n      \r\n      for (StepMeta stepMeta : injectSteps) {\r\n        TreeItem stepItem = new TreeItem(transItem, SWT.NONE);\r\n        stepItem.setText(stepMeta.getName());\r\n        stepItem.setExpanded(true);\r\n        \r\n        // For each step, add the keys\r\n        // \r\n        StepMetaInjectionInterface injection = stepMeta.getStepMetaInterface().getStepMetaInjectionInterface();\r\n        List<StepInjectionMetaEntry> entries = injection.getStepInjectionMetadataEntries();\r\n        for (final StepInjectionMetaEntry entry : entries) {\r\n          if (entry.getValueType()!=ValueMetaInterface.TYPE_NONE) {\r\n            TreeItem entryItem = new TreeItem(stepItem, SWT.NONE);\r\n            entryItem.setText(entry.getKey());\r\n            entryItem.setText(1, entry.getDescription());\r\n            TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), entry.getKey(), false);\r\n            treeItemTargetMap.put(entryItem, target);\r\n            \r\n            SourceStepField source = targetSourceMapping.get(target);\r\n            if (source!=null) {\r\n              entryItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n              entryItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n            }\r\n          } else {\r\n            // Fields...\r\n            //\r\n            TreeItem listsItem = new TreeItem(stepItem, SWT.NONE);\r\n            listsItem.setText(entry.getKey());\r\n            listsItem.setText(1, entry.getDescription());\r\n            \r\n            // Field...\r\n            //\r\n            StepInjectionMetaEntry listEntry = entry.getDetails().get(0);\r\n            TreeItem listItem = new TreeItem(listsItem, SWT.NONE);\r\n            listItem.setText(listEntry.getKey());\r\n            listItem.setText(1, listEntry.getDescription());\r\n            \r\n            for (StepInjectionMetaEntry me : listEntry.getDetails()) {\r\n              TreeItem treeItem = new TreeItem(listItem, SWT.NONE);\r\n              treeItem.setText(me.getKey());\r\n              treeItem.setText(1, me.getDescription());\r\n\r\n              TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), me.getKey(), true);\r\n              treeItemTargetMap.put(treeItem, target);\r\n              \r\n              SourceStepField source = targetSourceMapping.get(target);\r\n              if (source!=null) {\r\n                treeItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n                treeItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n              }              \r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n    } catch (Throwable t) {\r\n    }\r\n    \r\n    for (TreeItem item : wTree.getItems()) {\r\n      expandItemAndChildren(item);\r\n    }\r\n    \r\n    // Also set the source step combo values\r\n    //\r\n    String[] sourceSteps = injectTransMeta.getStepNames();\r\n    Arrays.sort(sourceSteps);\r\n    wSourceStep.setItems(sourceSteps);\r\n  }","commit_id":"64af8020a5828a09d49c8a6d70796332850bb7b2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n   protected void onBind()\n   {\n      keyShortcutPresenter.bind();\n      documentListPresenter.bind();\n      translationPresenter.bind();\n      searchResultsPresenter.bind();\n      notificationPresenter.bind();\n      layoutSelectorPresenter.bind();\n      \n      layoutSelectorPresenter.setLayoutListener(translationPresenter);\n      notificationPresenter.setErrorLabelListener(this);\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            display.setReadOnlyVisible(event.isReadOnly());\n         }\n      }));\n\n      setErrorNotificationLabel(notificationPresenter.getMessageCount());\n\n      registerHandler(eventBus.addHandler(NotificationEvent.getType(), new NotificationEventHandler()\n      {\n         @Override\n         public void onNotification(NotificationEvent event)\n         {\n            // See NotificationPresenter for Severity.Error message\n            if (event.getSeverity() != Severity.Error)\n            {\n               display.setNotificationMessage(event.getMessage(), event.getSeverity());\n               display.getDismissVisibility().setVisible(true);\n               Log.info(\"Notification:\" + event.getMessage());\n            }\n            else\n            {\n               setErrorNotificationLabel(notificationPresenter.getMessageCount());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentStatsUpdatedEvent.getType(), new DocumentStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onDocumentStatsUpdated(DocumentStatsUpdatedEvent event)\n         {\n            if (selectedDocument != null && event.getDocId().equals(selectedDocument.getId()))\n            {\n               selectedDocumentStats.set(event.getNewStats());\n               if (currentView.equals(MainView.Editor))\n               {\n                  refreshStatsDisplay();\n               }\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(ProjectStatsUpdatedEvent.getType(), new ProjectStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onProjectStatsRetrieved(ProjectStatsUpdatedEvent event)\n         {\n            projectStats.set(event.getProjectStats());\n            if (currentView.equals(MainView.Documents))\n            {\n               refreshStatsDisplay();\n            }\n         }\n      }));\n\n      registerHandler(display.getDismiss().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            display.setNotificationMessage(\"\", NotificationEvent.Severity.Info);\n            display.getDismissVisibility().setVisible(false);\n         }\n      }));\n\n      display.getDismissVisibility().setVisible(false);\n\n      registerHandler(display.getDocumentsLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n\n            if (token.getView().equals(MainView.Documents))\n            {\n               if (selectedDocument == null)\n               {\n                  return; // abort if no doc to edit\n               }\n               token.setView(MainView.Editor);\n            }\n            else\n            {\n               token.setView(MainView.Documents);\n            }\n            history.newItem(token.toTokenString());\n         }\n      }));\n\n      registerHandler(history.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            processHistoryEvent(event);\n         }\n      }));\n      \n      registerHandler(display.getErrorNotificationBtn().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            notificationPresenter.showErrorNotification();\n         }\n      }));\n\n      display.getLeaveWorkspaceMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            // use when opening workspace in new window\n            // Application.closeWindow();\n\n            // use when opening workspace in same window\n            Application.exitWorkspace();\n            Application.redirectToZanataProjectHome(workspaceContext.getWorkspaceId());\n         }\n      });\n\n      display.getHelpMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            com.google.gwt.user.client.Window.open(messages.hrefHelpLink(), messages.hrefHelpLink(), null);\n         }\n      });\n\n      display.getSignOutMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            Application.redirectToLogout();\n         }\n      });\n\n      display.getLayoutMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            layoutSelectorPresenter.show();            \n         }\n      });\n      \n      display.getSearchAndReplaceLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n            if (!token.getView().equals(MainView.Search))\n            {\n               token.setView(MainView.Search);\n               history.newItem(token.toTokenString());\n            }\n         }\n      });\n\n      registerHandler(eventBus.addHandler(PresenterRevealedEvent.getType(), new PresenterRevealedHandler()\n      {\n\n         @Override\n         public void onPresenterRevealed(PresenterRevealedEvent event)\n         {\n            // TODO disabled until tests are updated\n//            if (event.getPresenter() == searchResultsPresenter)\n//            {\n//               display.setDocumentLabel(\"\", messages.projectWideSearchAndReplace());\n//               currentDisplayStats = projectStats;\n//            }\n         }\n      }));\n\n      display.setUserLabel(identity.getPerson().getName());\n      String workspaceTitle = windowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY);\n      display.setWorkspaceNameLabel(workspaceContext.getWorkspaceName(), workspaceTitle);\n      window.setTitle(messages.windowTitle(workspaceContext.getWorkspaceName(), workspaceContext.getLocaleName()));\n\n      display.setReadOnlyVisible(workspaceContext.isReadOnly());\n\n      // this may be redundant with the following history event line\n      showView(MainView.Documents);\n\n      history.fireCurrentHistoryState();\n   }","id":98527,"modified_method":"@Override\n   protected void onBind()\n   {\n      keyShortcutPresenter.bind();\n      documentListPresenter.bind();\n      translationPresenter.bind();\n      searchResultsPresenter.bind();\n      notificationPresenter.bind();\n      layoutSelectorPresenter.bind();\n      \n      layoutSelectorPresenter.setLayoutListener(translationPresenter);\n      notificationPresenter.setErrorLabelListener(this);\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            display.setReadOnlyVisible(event.isReadOnly());\n         }\n      }));\n\n      setErrorNotificationLabel(notificationPresenter.getMessageCount());\n\n      registerHandler(eventBus.addHandler(NotificationEvent.getType(), new NotificationEventHandler()\n      {\n         @Override\n         public void onNotification(NotificationEvent event)\n         {\n            // See NotificationPresenter for Severity.Error message\n            if (event.getSeverity() != Severity.Error)\n            {\n               display.setNotificationMessage(event.getMessage(), event.getSeverity());\n               display.getDismissVisibility().setVisible(true);\n               Log.info(\"Notification:\" + event.getMessage());\n            }\n            else\n            {\n               setErrorNotificationLabel(notificationPresenter.getMessageCount());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentStatsUpdatedEvent.getType(), new DocumentStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onDocumentStatsUpdated(DocumentStatsUpdatedEvent event)\n         {\n            if (selectedDocument != null && event.getDocId().equals(selectedDocument.getId()))\n            {\n               selectedDocumentStats.set(event.getNewStats());\n               if (currentView.equals(MainView.Editor))\n               {\n                  refreshStatsDisplay();\n               }\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(ProjectStatsUpdatedEvent.getType(), new ProjectStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onProjectStatsRetrieved(ProjectStatsUpdatedEvent event)\n         {\n            projectStats.set(event.getProjectStats());\n            if (currentView.equals(MainView.Documents))\n            {\n               refreshStatsDisplay();\n            }\n         }\n      }));\n\n      registerHandler(display.getDismiss().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            display.setNotificationMessage(\"\", NotificationEvent.Severity.Info);\n            display.getDismissVisibility().setVisible(false);\n         }\n      }));\n\n      display.getDismissVisibility().setVisible(false);\n\n      registerHandler(display.getDocumentsLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n\n            if (token.getView().equals(MainView.Documents))\n            {\n               if (selectedDocument == null)\n               {\n                  return; // abort if no doc to edit\n               }\n               token.setView(MainView.Editor);\n            }\n            else\n            {\n               token.setView(MainView.Documents);\n            }\n            history.newItem(token.toTokenString());\n         }\n      }));\n\n      registerHandler(history.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            processHistoryEvent(event);\n         }\n      }));\n      \n      registerHandler(display.getErrorNotificationBtn().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            notificationPresenter.showErrorNotification();\n         }\n      }));\n\n      display.getSearchAndReplaceLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n            if (!token.getView().equals(MainView.Search))\n            {\n               token.setView(MainView.Search);\n               history.newItem(token.toTokenString());\n            }\n         }\n      });\n\n      registerHandler(eventBus.addHandler(PresenterRevealedEvent.getType(), new PresenterRevealedHandler()\n      {\n\n         @Override\n         public void onPresenterRevealed(PresenterRevealedEvent event)\n         {\n            // TODO disabled until tests are updated\n//            if (event.getPresenter() == searchResultsPresenter)\n//            {\n//               display.setDocumentLabel(\"\", messages.projectWideSearchAndReplace());\n//               currentDisplayStats = projectStats;\n//            }\n         }\n      }));\n\n\n      Command helpMenuCommand = new Command()\n      {\n         @Override\n         public void execute()\n         {\n            com.google.gwt.user.client.Window.open(messages.hrefHelpLink(), messages.hrefHelpLink(), null);\n         }\n      };\n\n      Command signOutMenuCommand = new Command()\n      {\n         @Override\n         public void execute()\n         {\n            Application.redirectToLogout();\n         }\n      };\n\n      Command leaveWorkspaceMenuCommand = new Command()\n      {\n         @Override\n         public void execute()\n         {\n            Application.exitWorkspace();\n            Application.redirectToZanataProjectHome(workspaceContext.getWorkspaceId());\n         }\n      };\n\n      Command layoutMenuMenuCommand = new Command()\n      {\n         @Override\n         public void execute()\n         {\n            layoutSelectorPresenter.show();\n         }\n      };\n\n\n      display.initMenuList(identity.getPerson().getName(), helpMenuCommand, leaveWorkspaceMenuCommand, signOutMenuCommand, layoutMenuMenuCommand);\n      String workspaceTitle = windowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY);\n      display.setWorkspaceNameLabel(workspaceContext.getWorkspaceName(), workspaceTitle);\n      window.setTitle(messages.windowTitle(workspaceContext.getWorkspaceName(), workspaceContext.getLocaleName()));\n\n      display.setReadOnlyVisible(workspaceContext.isReadOnly());\n\n      // this may be redundant with the following history event line\n      showView(MainView.Documents);\n\n      history.fireCurrentHistoryState();\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void expectPresenterSetupActions()\n   {\n      mockWindow.setTitle(TEST_WINDOW_TITLE);\n      expectLastCall().once();\n      mockDisplay.setUserLabel(TEST_PERSON_NAME);\n      expectLastCall().anyTimes();\n      mockDisplay.setWorkspaceNameLabel(TEST_WORKSPACE_NAME, TEST_WORKSPACE_TITLE);\n      expectLastCall().anyTimes();\n      mockDisplay.setReadOnlyVisible(false);\n      expectLastCall().once();\n      // initially empty project stats\n      mockDisplay.setStats(eq(emptyProjectStats));\n      expectLastCall().once();\n\n      mockDisplay.setDocumentLabel(\"\", NO_DOCUMENTS_STRING);\n      expectLastCall().once();\n\n      mockDisplay.showInMainView(MainView.Documents);\n      expectLastCall().once(); //starts on document list view\n\n      // due to this display beginning as concealed\n      mockSearchResultsPresenter.concealDisplay();\n      expectLastCall().once();\n\n      mockDismissVisibility.setVisible(false); // starts invisible\n      expectLastCall().once();\n\n      mockLeaveWorkspaceMenuItem.setCommand(and(capture(capturedLeaveWorkspaceLinkCommand), isA(Command.class)));\n      expectLastCall().once();\n\n      mockHelpMenuItem.setCommand(and(capture(capturedHelpLinkCommand), isA(Command.class)));\n      expectLastCall().once();\n\n      mockSignoutMenuItem.setCommand(and(capture(capturedSignoutLinkCommand), isA(Command.class)));\n      expectLastCall().once();\n\n      mockDisplay.setErrorNotificationText(0);\n      expectLastCall().once();\n   }","id":98528,"modified_method":"private void expectPresenterSetupActions()\n   {\n      mockWindow.setTitle(TEST_WINDOW_TITLE);\n      expectLastCall().once();\n\n      mockDisplay.initMenuList(TEST_PERSON_NAME, isA(Command.class), isA(Command.class), isA(Command.class), isA(Command.class));\n      expectLastCall().anyTimes();\n\n      mockDisplay.setWorkspaceNameLabel(TEST_WORKSPACE_NAME, TEST_WORKSPACE_TITLE);\n      expectLastCall().anyTimes();\n      mockDisplay.setReadOnlyVisible(false);\n      expectLastCall().once();\n      // initially empty project stats\n      mockDisplay.setStats(eq(emptyProjectStats));\n      expectLastCall().once();\n\n      mockDisplay.setDocumentLabel(\"\", NO_DOCUMENTS_STRING);\n      expectLastCall().once();\n\n      mockDisplay.showInMainView(MainView.Documents);\n      expectLastCall().once(); //starts on document list view\n\n      // due to this display beginning as concealed\n      mockSearchResultsPresenter.concealDisplay();\n      expectLastCall().once();\n\n      mockDismissVisibility.setVisible(false); // starts invisible\n      expectLastCall().once();\n\n      mockDisplay.setErrorNotificationText(0);\n      expectLastCall().once();\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void resetAllMocks()\n   {\n      reset(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      reset(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      reset(mockMessages, mockPerson, mockSearchResultsPresenter);\n      reset(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      reset(mockDismiss, mockDismissVisibility, mockNotificationPresenter);\n\n      reset(mockHelpMenuItem, mockLeaveWorkspaceMenuItem, mockSignoutMenuItem, mockSearchLink);\n   }","id":98529,"modified_method":"private void resetAllMocks()\n   {\n      reset(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      reset(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      reset(mockMessages, mockPerson, mockSearchResultsPresenter);\n      reset(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      reset(mockDismiss, mockDismissVisibility, mockNotificationPresenter);\n      reset(mockSearchLink);\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void setupMockGetterReturnValues()\n   {\n      expect(mockDisplay.getSignOutMenuItem()).andReturn(mockSignoutMenuItem).anyTimes();\n      expect(mockDisplay.getHelpMenuItem()).andReturn(mockHelpMenuItem).anyTimes();\n      expect(mockDisplay.getLeaveWorkspaceMenuItem()).andReturn(mockLeaveWorkspaceMenuItem).anyTimes();\n      expect(mockDisplay.getDocumentsLink()).andReturn(mockDocumentsLink).anyTimes();\n      expect(mockDisplay.getErrorNotificationBtn()).andReturn(mockErrorNotificationBtn).anyTimes();\n\n      expect(mockDisplay.getSearchAndReplaceLink()).andReturn(mockSearchLink).anyTimes();\n      expect(mockDisplay.getDismiss()).andReturn(mockDismiss).anyTimes();\n      expect(mockDisplay.getDismissVisibility()).andReturn(mockDismissVisibility).anyTimes();\n\n      expect(mockIdentity.getPerson()).andReturn(mockPerson).anyTimes();\n      expect(mockPerson.getName()).andReturn(TEST_PERSON_NAME).anyTimes();\n\n      expect(mockWindowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY)).andReturn(TEST_WORKSPACE_TITLE).anyTimes();\n\n      expect(mockMessages.windowTitle(TEST_WORKSPACE_NAME, TEST_LOCALE_NAME)).andReturn(TEST_WINDOW_TITLE).anyTimes();\n      expect(mockMessages.noDocumentSelected()).andReturn(NO_DOCUMENTS_STRING).anyTimes();\n      expect(mockMessages.projectWideSearchAndReplace()).andReturn(SEARCH_PAGE_LABEL).anyTimes();\n\n      expect(mockWorkspaceContext.getWorkspaceName()).andReturn(TEST_WORKSPACE_NAME).anyTimes();\n      expect(mockWorkspaceContext.getLocaleName()).andReturn(TEST_LOCALE_NAME).anyTimes();\n      expect(mockWorkspaceContext.isReadOnly()).andReturn(false).anyTimes();\n\n      expect(mockDocumentListPresenter.getDocumentInfo(testDocId)).andReturn(testDocInfo).anyTimes();\n   }","id":98530,"modified_method":"private void setupMockGetterReturnValues()\n   {\n      expect(mockDisplay.getDocumentsLink()).andReturn(mockDocumentsLink).anyTimes();\n      expect(mockDisplay.getErrorNotificationBtn()).andReturn(mockErrorNotificationBtn).anyTimes();\n\n      expect(mockDisplay.getSearchAndReplaceLink()).andReturn(mockSearchLink).anyTimes();\n      expect(mockDisplay.getDismiss()).andReturn(mockDismiss).anyTimes();\n      expect(mockDisplay.getDismissVisibility()).andReturn(mockDismissVisibility).anyTimes();\n\n      expect(mockIdentity.getPerson()).andReturn(mockPerson).anyTimes();\n      expect(mockPerson.getName()).andReturn(TEST_PERSON_NAME).anyTimes();\n\n      expect(mockWindowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY)).andReturn(TEST_WORKSPACE_TITLE).anyTimes();\n\n      expect(mockMessages.windowTitle(TEST_WORKSPACE_NAME, TEST_LOCALE_NAME)).andReturn(TEST_WINDOW_TITLE).anyTimes();\n      expect(mockMessages.noDocumentSelected()).andReturn(NO_DOCUMENTS_STRING).anyTimes();\n      expect(mockMessages.projectWideSearchAndReplace()).andReturn(SEARCH_PAGE_LABEL).anyTimes();\n\n      expect(mockWorkspaceContext.getWorkspaceName()).andReturn(TEST_WORKSPACE_NAME).anyTimes();\n      expect(mockWorkspaceContext.getLocaleName()).andReturn(TEST_LOCALE_NAME).anyTimes();\n      expect(mockWorkspaceContext.isReadOnly()).andReturn(false).anyTimes();\n\n      expect(mockDocumentListPresenter.getDocumentInfo(testDocId)).andReturn(testDocInfo).anyTimes();\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void verifyAllMocks()\n   {\n      verify(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      verify(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      verify(mockMessages, mockPerson, mockSearchResultsPresenter);\n      verify(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      verify(mockDismiss, mockDismissVisibility, mockNotificationPresenter);\n\n      verify(mockHelpMenuItem, mockLeaveWorkspaceMenuItem, mockSignoutMenuItem, mockSearchLink);\n   }","id":98531,"modified_method":"private void verifyAllMocks()\n   {\n      verify(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      verify(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      verify(mockMessages, mockPerson, mockSearchResultsPresenter);\n      verify(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      verify(mockDismiss, mockDismissVisibility, mockNotificationPresenter);\n      verify(mockSearchLink);\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeClass\n   public void createMocks()\n   {\n      mockDismiss = createMock(HasClickHandlers.class);\n      mockDismissVisibility = createMock(HasVisibility.class);\n      mockDisplay = createMock(AppPresenter.Display.class);\n      mockDocumentListPresenter = createMock(DocumentListPresenter.class);\n      mockDocumentsLink = createMock(HasClickHandlers.class);\n      mockErrorNotificationBtn = createMock(HasClickHandlers.class);\n      mockSearchLink = createMock(HasClickHandlers.class);\n      mockEventBus = createMock(EventBus.class);\n      mockHistory = createMock(History.class);\n      mockIdentity = createMock(Identity.class);\n      mockKeyShortcutPresenter = createMock(KeyShortcutPresenter.class);\n      mockLeaveWorkspaceMenuItem = createMock(HasCommand.class);\n      mockMessages = createMock(WebTransMessages.class);\n      mockPerson = createMock(Person.class);\n      mockSearchResultsPresenter = createMock(SearchResultsPresenter.class);\n      mockSignoutMenuItem = createMock(HasCommand.class);\n      mockTranslationPresenter = createMock(TranslationPresenter.class);\n      mockWindow = createMock(Window.class);\n      mockWindowLocation = createMock(Window.Location.class);\n      mockWorkspaceContext = createMock(WorkspaceContext.class);\n      mockNotificationPresenter = createMock(NotificationPresenter.class);\n      mockHelpMenuItem = createMock(HasCommand.class);\n\n      capturedSearchLinkClickHandler = new Capture<ClickHandler>();\n      capturedDismissLinkClickHandler = new Capture<ClickHandler>();\n      capturedDocumentLinkClickHandler = new Capture<ClickHandler>();\n      capturedErrorNotificationBtnHandler = new Capture<ClickHandler>();\n      capturedDocumentSelectionEvent = new Capture<DocumentSelectionEvent>();\n      capturedDocumentStatsUpdatedEventHandler = new Capture<DocumentStatsUpdatedEventHandler>();\n      capturedHistoryTokenString = new Capture<String>();\n      capturedHistoryValueChangeHandler = new Capture<ValueChangeHandler<String>>();\n      capturedNotificationEventHandler = new Capture<NotificationEventHandler>();\n      capturedProjectStatsUpdatedEventHandler = new Capture<ProjectStatsUpdatedEventHandler>();\n      capturedWorkspaceContextUpdatedEventHandler = new Capture<WorkspaceContextUpdateEventHandler>();\n      capturedPresenterRevealedHandler = new Capture<PresenterRevealedHandler>();\n\n      capturedSignoutLinkCommand = new Capture<Command>();\n      capturedLeaveWorkspaceLinkCommand = new Capture<Command>();\n      capturedHelpLinkCommand = new Capture<Command>();\n\n\n   }","id":98532,"modified_method":"@BeforeClass\n   public void createMocks()\n   {\n      mockDismiss = createMock(HasClickHandlers.class);\n      mockDismissVisibility = createMock(HasVisibility.class);\n      mockDisplay = createMock(AppPresenter.Display.class);\n      mockDocumentListPresenter = createMock(DocumentListPresenter.class);\n      mockDocumentsLink = createMock(HasClickHandlers.class);\n      mockErrorNotificationBtn = createMock(HasClickHandlers.class);\n      mockSearchLink = createMock(HasClickHandlers.class);\n      mockEventBus = createMock(EventBus.class);\n      mockHistory = createMock(History.class);\n      mockIdentity = createMock(Identity.class);\n      mockKeyShortcutPresenter = createMock(KeyShortcutPresenter.class);\n      mockMessages = createMock(WebTransMessages.class);\n      mockPerson = createMock(Person.class);\n      mockSearchResultsPresenter = createMock(SearchResultsPresenter.class);\n      mockTranslationPresenter = createMock(TranslationPresenter.class);\n      mockWindow = createMock(Window.class);\n      mockWindowLocation = createMock(Window.Location.class);\n      mockWorkspaceContext = createMock(WorkspaceContext.class);\n      mockNotificationPresenter = createMock(NotificationPresenter.class);\n      mockLayoutSelectorPresenter = createMock(LayoutSelectorPresenter.class);\n      capturedSearchLinkClickHandler = new Capture<ClickHandler>();\n      capturedDismissLinkClickHandler = new Capture<ClickHandler>();\n      capturedDocumentLinkClickHandler = new Capture<ClickHandler>();\n      capturedErrorNotificationBtnHandler = new Capture<ClickHandler>();\n      capturedDocumentSelectionEvent = new Capture<DocumentSelectionEvent>();\n      capturedDocumentStatsUpdatedEventHandler = new Capture<DocumentStatsUpdatedEventHandler>();\n      capturedHistoryTokenString = new Capture<String>();\n      capturedHistoryValueChangeHandler = new Capture<ValueChangeHandler<String>>();\n      capturedNotificationEventHandler = new Capture<NotificationEventHandler>();\n      capturedProjectStatsUpdatedEventHandler = new Capture<ProjectStatsUpdatedEventHandler>();\n      capturedWorkspaceContextUpdatedEventHandler = new Capture<WorkspaceContextUpdateEventHandler>();\n      capturedPresenterRevealedHandler = new Capture<PresenterRevealedHandler>();\n\n      capturedSignoutLinkCommand = new Capture<Command>();\n      capturedLeaveWorkspaceLinkCommand = new Capture<Command>();\n      capturedHelpLinkCommand = new Capture<Command>();\n      capturedLayoutLinkCommand = new Capture<Command>();\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n   void beforeMethod()\n   {\n      resetAllMocks();\n      resetAllCaptures();\n\n      emptyProjectStats = new TranslationStats();\n      buildTestDocumentInfo();\n\n      setupDefaultMockExpectations();\n\n      appPresenter = new AppPresenter(mockDisplay, mockEventBus,\n            mockKeyShortcutPresenter, mockTranslationPresenter,\n            mockDocumentListPresenter, mockSearchResultsPresenter,\n            mockNotificationPresenter, mockIdentity, mockWorkspaceContext,\n            mockMessages, mockHistory, mockWindow, mockWindowLocation);\n\n      mockNotificationPresenter.setErrorLabelListener(appPresenter);\n      expectLastCall().once();\n   }","id":98533,"modified_method":"@BeforeMethod\n   void beforeMethod()\n   {\n      resetAllMocks();\n      resetAllCaptures();\n\n      emptyProjectStats = new TranslationStats();\n      buildTestDocumentInfo();\n\n      setupDefaultMockExpectations();\n\n      appPresenter = new AppPresenter(mockDisplay, mockEventBus,\n            mockKeyShortcutPresenter, mockTranslationPresenter,\n            mockDocumentListPresenter, mockSearchResultsPresenter,\n            mockNotificationPresenter, mockLayoutSelectorPresenter, \n            mockIdentity, mockWorkspaceContext, mockMessages, \n            mockHistory, mockWindow, mockWindowLocation);\n\n      mockNotificationPresenter.setErrorLabelListener(appPresenter);\n      expectLastCall().once();\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void replayAllMocks()\n   {\n      replay(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      replay(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      replay(mockMessages, mockPerson, mockSearchResultsPresenter);\n      replay(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      replay(mockDismiss, mockDismissVisibility, mockNotificationPresenter);\n\n      replay(mockHelpMenuItem, mockLeaveWorkspaceMenuItem, mockSignoutMenuItem, mockSearchLink);\n   }","id":98534,"modified_method":"private void replayAllMocks()\n   {\n      replay(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      replay(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      replay(mockMessages, mockPerson, mockSearchResultsPresenter);\n      replay(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      replay(mockDismiss, mockDismissVisibility, mockNotificationPresenter);\n      replay(mockSearchLink);\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void resetAllCaptures()\n   {\n      capturedDismissLinkClickHandler.reset();\n      capturedDocumentLinkClickHandler.reset();\n      capturedDocumentSelectionEvent.reset();\n      capturedDocumentStatsUpdatedEventHandler.reset();\n      capturedHistoryTokenString.reset();\n      capturedHistoryValueChangeHandler.reset();\n      capturedLeaveWorkspaceLinkCommand.reset();\n      capturedHelpLinkCommand.reset();\n      capturedNotificationEventHandler.reset();\n      capturedProjectStatsUpdatedEventHandler.reset();\n      capturedSearchLinkClickHandler.reset();\n      capturedSignoutLinkCommand.reset();\n      capturedWorkspaceContextUpdatedEventHandler.reset();\n      capturedPresenterRevealedHandler.reset();\n      capturedErrorNotificationBtnHandler.reset();\n   }","id":98535,"modified_method":"private void resetAllCaptures()\n   {\n      capturedDismissLinkClickHandler.reset();\n      capturedDocumentLinkClickHandler.reset();\n      capturedDocumentSelectionEvent.reset();\n      capturedDocumentStatsUpdatedEventHandler.reset();\n      capturedHistoryTokenString.reset();\n      capturedHistoryValueChangeHandler.reset();\n      capturedLeaveWorkspaceLinkCommand.reset();\n      capturedHelpLinkCommand.reset();\n      capturedLayoutLinkCommand.reset();\n      capturedNotificationEventHandler.reset();\n      capturedProjectStatsUpdatedEventHandler.reset();\n      capturedSearchLinkClickHandler.reset();\n      capturedSignoutLinkCommand.reset();\n      capturedWorkspaceContextUpdatedEventHandler.reset();\n      capturedPresenterRevealedHandler.reset();\n      capturedErrorNotificationBtnHandler.reset();\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n\n      initWidget(uiBinder.createAndBindUi(this));\n\n      menuBar = new MenuBar(true);\n      helpMenuItem = new MenuCommandItem(messages.help(), emptyCommand);\n      leaveWorkspaceMenuItem = new MenuCommandItem(messages.leaveWorkspace(), emptyCommand);\n      signOutMenuItem = new MenuCommandItem(messages.signOut(), emptyCommand);\n      layoutMenuItem = new MenuCommandItem(messages.layout(), emptyCommand);\n\n      searchAndReplace.setText(messages.searchAndReplace());\n      \n      \n      menuBar.addItem(helpMenuItem);\n      menuBar.addSeparator();\n      menuBar.addItem(layoutMenuItem);\n      menuBar.addSeparator();\n      menuBar.addItem(leaveWorkspaceMenuItem);\n      menuBar.addItem(signOutMenuItem);\n      \n      userAvatarUrl = identity.getPerson().getAvatarUrl();\n\n      this.documentListView = documentListView.asWidget();\n      this.container.add(this.documentListView);\n\n      this.translationView = translationView.asWidget();\n      this.container.add(this.translationView);\n\n      this.searchResultsView = searchResultsView.asWidget();\n      this.container.add(this.searchResultsView);\n\n      errorNotificationBtn.setTitle(messages.errorNotification());\n\n      Window.enableScrolling(false);\n   }","id":98536,"modified_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n\n      initWidget(uiBinder.createAndBindUi(this));\n\n      searchAndReplace.setText(messages.searchAndReplace());\n      userAvatarUrl = identity.getPerson().getAvatarUrl();\n\n      this.documentListView = documentListView.asWidget();\n      this.container.add(this.documentListView);\n\n      this.translationView = translationView.asWidget();\n      this.container.add(this.translationView);\n\n      this.searchResultsView = searchResultsView.asWidget();\n      this.container.add(this.searchResultsView);\n\n      errorNotificationBtn.setTitle(messages.errorNotification());\n\n      Window.enableScrolling(false);\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public TranslationView(Resources resources, WebTransMessages messages, TranslationEditorPresenter.Display translationEditorView, OptionsPanelPresenter.Display sidePanelView, TransMemoryPresenter.Display transMemoryView, WorkspaceUsersPresenter.Display workspaceUsersView, GlossaryPresenter.Display glossaryView)\n   {\n\n      StyleInjector.inject(resources.style().getText(), true);\n      sidePanelOuterContainer = new LayoutPanel();\n      southPanelContainer = new LayoutPanel();\n\n\n      userPanel = new LayoutPanel();\n      tmGlossaryPanel = new SplitLayoutPanel(3);\n      \n      optionsToggleButton = new ToggleButton(messages.hideEditorOptionsLabel(), messages.showEditorOptionsLabel());\n      optionsToggleButton.setTitle(messages.hideEditorOptions());\n      optionsToggleButton.setDown(true);\n\n      southPanelToggleButton = new ToggleButton(messages.restoreLabel(), messages.minimiseLabel());\n      southPanelToggleButton.setDown(true);\n\n      initWidget(uiBinder.createAndBindUi(this));\n      mainSplitPanel.setWidgetMinSize(sidePanelOuterContainer, (int) panelWidth);\n      mainSplitPanel.setWidgetMinSize(southPanelContainer, (int) southHeight);\n\n      southPanelTab.add(tmGlossaryPanel, messages.tmGlossaryHeading());\n      southPanelTab.add(userPanel, messages.nUsersOnline(0));\n\n      setEditorView(translationEditorView.asWidget());\n\n      setSidePanel(sidePanelView.asWidget());\n\n      setGlossaryView(glossaryView.asWidget());\n      setTranslationMemoryView(transMemoryView.asWidget());\n\n      setWorkspaceUsersView(workspaceUsersView.asWidget());\n   }","id":98537,"modified_method":"@Inject\n   public TranslationView(Resources resources, WebTransMessages messages, TranslationEditorPresenter.Display translationEditorView, OptionsPanelPresenter.Display sidePanelView, TransMemoryPresenter.Display transMemoryView, WorkspaceUsersPresenter.Display workspaceUsersView, GlossaryPresenter.Display glossaryView)\n   {\n\n      StyleInjector.inject(resources.style().getText(), true);\n      sidePanelOuterContainer = new LayoutPanel();\n      southPanelContainer = new LayoutPanel();\n\n\n      userPanel = new LayoutPanel();\n      tmGlossaryPanel = new SplitLayoutPanel(3);\n      \n      optionsToggleButton = new ToggleButton(messages.hideEditorOptionsLabel(), messages.showEditorOptionsLabel());\n      optionsToggleButton.setTitle(messages.hideEditorOptions());\n      optionsToggleButton.setDown(true);\n\n      southPanelToggleButton = new ToggleButton(messages.restoreLabel(), messages.minimiseLabel());\n      southPanelToggleButton.setDown(true);\n\n      initWidget(uiBinder.createAndBindUi(this));\n      mainSplitPanel.setWidgetMinSize(sidePanelOuterContainer, (int) OPTION_PANEL_WIDTH);\n      mainSplitPanel.setWidgetMinSize(southPanelContainer, (int) SOUTH_PANEL_HEIGHT);\n\n      southPanelTab.add(tmGlossaryPanel, messages.tmGlossaryHeading());\n      southPanelTab.add(userPanel, messages.nUsersOnline(0));\n\n      setEditorView(translationEditorView.asWidget());\n\n      setSidePanel(sidePanelView.asWidget());\n\n      setGlossaryView(glossaryView.asWidget());\n      setTranslationMemoryView(transMemoryView.asWidget());\n\n      setWorkspaceUsersView(workspaceUsersView.asWidget());\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void setSidePanelVisible(boolean visible)\n   {\n      mainSplitPanel.forceLayout();\n      Widget splitter = SplitLayoutPanelHelper.getAssociatedSplitter(mainSplitPanel, sidePanelOuterContainer);\n      if (visible)\n      {\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, sidePanelOuterContainer, panelWidth);\n      }\n      else\n      {\n         panelWidth = mainSplitPanel.getWidgetContainerElement(sidePanelOuterContainer).getOffsetWidth();\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, sidePanelOuterContainer, 0);\n      }\n      splitter.setVisible(visible);\n      mainSplitPanel.animate(200);\n   }","id":98538,"modified_method":"@Override\n   public void setSidePanelVisible(boolean visible)\n   {\n      mainSplitPanel.forceLayout();\n      Widget splitter = SplitLayoutPanelHelper.getAssociatedSplitter(mainSplitPanel, sidePanelOuterContainer);\n      if (visible)\n      {\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, sidePanelOuterContainer, OPTION_PANEL_WIDTH);\n      }\n      else\n      {\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, sidePanelOuterContainer, 0);\n      }\n      splitter.setVisible(visible);\n      mainSplitPanel.animate(ANIMATE_DURATION);\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void setSouthPanelVisible(boolean visible)\n   {\n      double splitPosition = visible ? 26 : 0;\n\n      mainSplitPanel.forceLayout();\n      // TODO retain southHeight? Workaround is to collapse first\n      SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, southPanelContainer, splitPosition);\n      SplitLayoutPanelHelper.getAssociatedSplitter(mainSplitPanel, southPanelContainer).setVisible(visible);\n      mainSplitPanel.animate(200);\n   }","id":98539,"modified_method":"@Override\n   public void setSouthPanelVisible(boolean visible)\n   {\n      double splitPosition = visible ? MIN_SOUTH_PANEL_HEIGHT : 0;\n\n      mainSplitPanel.forceLayout();\n      // TODO retain southHeight? Workaround is to collapse first\n      SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, southPanelContainer, splitPosition);\n      SplitLayoutPanelHelper.getAssociatedSplitter(mainSplitPanel, southPanelContainer).setVisible(visible);\n      mainSplitPanel.animate(ANIMATE_DURATION);\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void setGlossaryView(Widget glossaryView)\n   {\n      tmGlossaryPanel.remove(glossaryView);\n      tmGlossaryPanel.addEast(glossaryView, glossaryPanelWidth);\n   }","id":98540,"modified_method":"private void setGlossaryView(Widget glossaryView)\n   {\n      tmGlossaryPanel.remove(glossaryView);\n      tmGlossaryPanel.addEast(glossaryView, GLOSSARY_PANEL_WIDTH);\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void setSouthPanelExpanded(boolean expanded)\n   {\n      mainSplitPanel.forceLayout();\n      Widget splitter = SplitLayoutPanelHelper.getAssociatedSplitter(mainSplitPanel, southPanelContainer);\n      if (expanded)\n      {\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, southPanelContainer, southHeight);\n      }\n      else\n      {\n         southHeight = mainSplitPanel.getWidgetContainerElement(southPanelContainer).getOffsetHeight();\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, southPanelContainer, 26);\n      }\n      splitter.setVisible(expanded);\n      mainSplitPanel.animate(200);\n\n   }","id":98541,"modified_method":"@Override\n   public void setSouthPanelExpanded(boolean expanded)\n   {\n      mainSplitPanel.forceLayout();\n      Widget splitter = SplitLayoutPanelHelper.getAssociatedSplitter(mainSplitPanel, southPanelContainer);\n      if (expanded)\n      {\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, southPanelContainer, SOUTH_PANEL_HEIGHT);\n      }\n      else\n      {\n         SplitLayoutPanelHelper.setSplitPosition(mainSplitPanel, southPanelContainer, MIN_SOUTH_PANEL_HEIGHT);\n      }\n      splitter.setVisible(expanded);\n      mainSplitPanel.animate(ANIMATE_DURATION);\n\n   }","commit_id":"44704a0d02f7d3d4f5147340245ecc5b6096e802","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void replayAllMocks()\n   {\n      replay(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      replay(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      replay(mockMessages, mockPerson, mockSearchResultsPresenter);\n      replay(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      replay(mockNotificationPresenter);\n\n      replay(mockHelpMenuItem, mockLeaveWorkspaceMenuItem, mockSignoutMenuItem, mockSearchLink);\n   }","id":98542,"modified_method":"private void replayAllMocks()\n   {\n      replay(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      replay(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      replay(mockMessages, mockPerson, mockSearchResultsPresenter);\n      replay(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      replay(mockNotificationPresenter, mockLayoutPresenter);\n      replay(mockSearchLink);\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeClass\n   public void createMocks()\n   {\n      mockDisplay = createMock(AppPresenter.Display.class);\n      mockDocumentListPresenter = createMock(DocumentListPresenter.class);\n      mockDocumentsLink = createMock(HasClickHandlers.class);\n      mockErrorNotificationBtn = createMock(HasClickHandlers.class);\n      mockSearchLink = createMock(HasClickHandlers.class);\n      mockEventBus = createMock(EventBus.class);\n      mockHistory = createMock(History.class);\n      mockIdentity = createMock(Identity.class);\n      mockKeyShortcutPresenter = createMock(KeyShortcutPresenter.class);\n      mockLeaveWorkspaceMenuItem = createMock(HasCommand.class);\n      mockMessages = createMock(WebTransMessages.class);\n      mockPerson = createMock(Person.class);\n      mockSearchResultsPresenter = createMock(SearchResultsPresenter.class);\n      mockSignoutMenuItem = createMock(HasCommand.class);\n      mockTranslationPresenter = createMock(TranslationPresenter.class);\n      mockWindow = createMock(Window.class);\n      mockWindowLocation = createMock(Window.Location.class);\n      mockWorkspaceContext = createMock(WorkspaceContext.class);\n      mockNotificationPresenter = createMock(NotificationPresenter.class);\n      mockHelpMenuItem = createMock(HasCommand.class);\n\n      capturedSearchLinkClickHandler = new Capture<ClickHandler>();\n      capturedDocumentLinkClickHandler = new Capture<ClickHandler>();\n      capturedErrorNotificationBtnHandler = new Capture<ClickHandler>();\n      capturedDocumentSelectionEvent = new Capture<DocumentSelectionEvent>();\n      capturedDocumentStatsUpdatedEventHandler = new Capture<DocumentStatsUpdatedEventHandler>();\n      capturedHistoryTokenString = new Capture<String>();\n      capturedHistoryValueChangeHandler = new Capture<ValueChangeHandler<String>>();\n      capturedKeyShortcuts = new Capture<KeyShortcut>();\n      capturedProjectStatsUpdatedEventHandler = new Capture<ProjectStatsUpdatedEventHandler>();\n      capturedWorkspaceContextUpdatedEventHandler = new Capture<WorkspaceContextUpdateEventHandler>();\n      capturedPresenterRevealedHandler = new Capture<PresenterRevealedHandler>();\n\n      capturedSignoutLinkCommand = new Capture<Command>();\n      capturedLeaveWorkspaceLinkCommand = new Capture<Command>();\n      capturedHelpLinkCommand = new Capture<Command>();\n\n   }","id":98543,"modified_method":"@BeforeClass\n   public void createMocks()\n   {\n      mockDisplay = createMock(AppPresenter.Display.class);\n      mockDocumentListPresenter = createMock(DocumentListPresenter.class);\n      mockDocumentsLink = createMock(HasClickHandlers.class);\n      mockErrorNotificationBtn = createMock(HasClickHandlers.class);\n      mockSearchLink = createMock(HasClickHandlers.class);\n      mockEventBus = createMock(EventBus.class);\n      mockHistory = createMock(History.class);\n      mockIdentity = createMock(Identity.class);\n      mockKeyShortcutPresenter = createMock(KeyShortcutPresenter.class);\n      mockMessages = createMock(WebTransMessages.class);\n      mockPerson = createMock(Person.class);\n      mockSearchResultsPresenter = createMock(SearchResultsPresenter.class);\n      mockTranslationPresenter = createMock(TranslationPresenter.class);\n      mockWindow = createMock(Window.class);\n      mockWindowLocation = createMock(Window.Location.class);\n      mockWorkspaceContext = createMock(WorkspaceContext.class);\n      mockNotificationPresenter = createMock(NotificationPresenter.class);\n      mockLayoutPresenter = createMock(LayoutSelectorPresenter.class);\n\n      capturedSearchLinkClickHandler = new Capture<ClickHandler>();\n      capturedDocumentLinkClickHandler = new Capture<ClickHandler>();\n      capturedErrorNotificationBtnHandler = new Capture<ClickHandler>();\n      capturedDocumentSelectionEvent = new Capture<DocumentSelectionEvent>();\n      capturedDocumentStatsUpdatedEventHandler = new Capture<DocumentStatsUpdatedEventHandler>();\n      capturedHistoryTokenString = new Capture<String>();\n      capturedHistoryValueChangeHandler = new Capture<ValueChangeHandler<String>>();\n      capturedKeyShortcuts = new Capture<KeyShortcut>();\n      capturedProjectStatsUpdatedEventHandler = new Capture<ProjectStatsUpdatedEventHandler>();\n      capturedWorkspaceContextUpdatedEventHandler = new Capture<WorkspaceContextUpdateEventHandler>();\n      capturedPresenterRevealedHandler = new Capture<PresenterRevealedHandler>();\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void verifyAllMocks()\n   {\n      verify(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      verify(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      verify(mockMessages, mockPerson, mockSearchResultsPresenter);\n      verify(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      verify(mockNotificationPresenter);\n\n      verify(mockHelpMenuItem, mockLeaveWorkspaceMenuItem, mockSignoutMenuItem, mockSearchLink);\n   }","id":98544,"modified_method":"private void verifyAllMocks()\n   {\n      verify(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      verify(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      verify(mockMessages, mockPerson, mockSearchResultsPresenter);\n      verify(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      verify(mockNotificationPresenter, mockLayoutPresenter);\n      verify(mockSearchLink);\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void setupMockGetterReturnValues()\n   {\n      expect(mockDisplay.getSignOutMenuItem()).andReturn(mockSignoutMenuItem).anyTimes();\n      expect(mockDisplay.getHelpMenuItem()).andReturn(mockHelpMenuItem).anyTimes();\n      expect(mockDisplay.getLeaveWorkspaceMenuItem()).andReturn(mockLeaveWorkspaceMenuItem).anyTimes();\n      expect(mockDisplay.getDocumentsLink()).andReturn(mockDocumentsLink).anyTimes();\n      expect(mockDisplay.getNotificationBtn()).andReturn(mockErrorNotificationBtn).anyTimes();\n\n      expect(mockDisplay.getSearchAndReplaceLink()).andReturn(mockSearchLink).anyTimes();\n\n      expect(mockIdentity.getPerson()).andReturn(mockPerson).anyTimes();\n      expect(mockPerson.getName()).andReturn(TEST_PERSON_NAME).anyTimes();\n\n      expect(mockWindowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY)).andReturn(TEST_WORKSPACE_TITLE).anyTimes();\n\n      expect(mockMessages.windowTitle(TEST_WORKSPACE_NAME, TEST_LOCALE_NAME)).andReturn(TEST_WINDOW_TITLE).anyTimes();\n      expect(mockMessages.noDocumentSelected()).andReturn(NO_DOCUMENTS_STRING).anyTimes();\n      expect(mockMessages.projectWideSearchAndReplace()).andReturn(SEARCH_PAGE_LABEL).anyTimes();\n      expect(mockMessages.showDocumentListKeyShortcut()).andReturn(DOCUMENT_LIST_KEY_SHORTCUT_DESCRIPTION).anyTimes();\n      expect(mockMessages.showEditorKeyShortcut()).andReturn(SHOW_EDITOR_KEY_SHORTCUT_DESCRIPTION).anyTimes();\n      expect(mockMessages.showProjectWideSearch()).andReturn(SHOW_PROJECT_WIDE_SEARCH_KEY_SHORTCUT_DESCRIPTION).anyTimes();\n\n      expect(mockWorkspaceContext.getWorkspaceName()).andReturn(TEST_WORKSPACE_NAME).anyTimes();\n      expect(mockWorkspaceContext.getLocaleName()).andReturn(TEST_LOCALE_NAME).anyTimes();\n      expect(mockWorkspaceContext.isReadOnly()).andReturn(false).anyTimes();\n\n      expect(mockDocumentListPresenter.getDocumentInfo(testDocId)).andReturn(testDocInfo).anyTimes();\n   }","id":98545,"modified_method":"private void setupMockGetterReturnValues()\n   {\n      expect(mockDisplay.getDocumentsLink()).andReturn(mockDocumentsLink).anyTimes();\n      expect(mockDisplay.getNotificationBtn()).andReturn(mockErrorNotificationBtn).anyTimes();\n\n      expect(mockDisplay.getSearchAndReplaceLink()).andReturn(mockSearchLink).anyTimes();\n\n      expect(mockIdentity.getPerson()).andReturn(mockPerson).anyTimes();\n      expect(mockPerson.getName()).andReturn(TEST_PERSON_NAME).anyTimes();\n\n      expect(mockWindowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY)).andReturn(TEST_WORKSPACE_TITLE).anyTimes();\n\n      expect(mockMessages.windowTitle(TEST_WORKSPACE_NAME, TEST_LOCALE_NAME)).andReturn(TEST_WINDOW_TITLE).anyTimes();\n      expect(mockMessages.noDocumentSelected()).andReturn(NO_DOCUMENTS_STRING).anyTimes();\n      expect(mockMessages.projectWideSearchAndReplace()).andReturn(SEARCH_PAGE_LABEL).anyTimes();\n      expect(mockMessages.showDocumentListKeyShortcut()).andReturn(DOCUMENT_LIST_KEY_SHORTCUT_DESCRIPTION).anyTimes();\n      expect(mockMessages.showEditorKeyShortcut()).andReturn(SHOW_EDITOR_KEY_SHORTCUT_DESCRIPTION).anyTimes();\n      expect(mockMessages.showProjectWideSearch()).andReturn(SHOW_PROJECT_WIDE_SEARCH_KEY_SHORTCUT_DESCRIPTION).anyTimes();\n\n      expect(mockWorkspaceContext.getWorkspaceName()).andReturn(TEST_WORKSPACE_NAME).anyTimes();\n      expect(mockWorkspaceContext.getLocaleName()).andReturn(TEST_LOCALE_NAME).anyTimes();\n      expect(mockWorkspaceContext.isReadOnly()).andReturn(false).anyTimes();\n\n      expect(mockDocumentListPresenter.getDocumentInfo(testDocId)).andReturn(testDocInfo).anyTimes();\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n   void beforeMethod()\n   {\n      resetAllMocks();\n      resetAllCaptures();\n\n      emptyProjectStats = new TranslationStats();\n      buildTestDocumentInfo();\n\n      setupDefaultMockExpectations();\n\n      appPresenter = new AppPresenter(mockDisplay, mockEventBus, mockKeyShortcutPresenter, mockTranslationPresenter, mockDocumentListPresenter, mockSearchResultsPresenter, mockNotificationPresenter, mockIdentity, mockWorkspaceContext, mockMessages, mockHistory, mockWindow, mockWindowLocation);\n\n      mockNotificationPresenter.setNotificationListener(appPresenter);\n      expectLastCall().once();\n   }","id":98546,"modified_method":"@BeforeMethod\n   void beforeMethod()\n   {\n      resetAllMocks();\n      resetAllCaptures();\n\n      emptyProjectStats = new TranslationStats();\n      buildTestDocumentInfo();\n\n      setupDefaultMockExpectations();\n\n      appPresenter = new AppPresenter(mockDisplay, mockEventBus, mockKeyShortcutPresenter, mockTranslationPresenter, mockDocumentListPresenter, mockSearchResultsPresenter, mockNotificationPresenter, mockLayoutPresenter, mockIdentity, mockWorkspaceContext, mockMessages, mockHistory, mockWindow, mockWindowLocation);\n\n      mockNotificationPresenter.setNotificationListener(appPresenter);\n      expectLastCall().once();\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void resetAllMocks()\n   {\n      reset(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      reset(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      reset(mockMessages, mockPerson, mockSearchResultsPresenter);\n      reset(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      reset(mockNotificationPresenter);\n\n      reset(mockHelpMenuItem, mockLeaveWorkspaceMenuItem, mockSignoutMenuItem, mockSearchLink);\n   }","id":98547,"modified_method":"private void resetAllMocks()\n   {\n      reset(mockDisplay, mockDocumentListPresenter, mockDocumentsLink, mockErrorNotificationBtn);\n      reset(mockEventBus, mockHistory, mockIdentity, mockKeyShortcutPresenter);\n      reset(mockMessages, mockPerson, mockSearchResultsPresenter);\n      reset(mockTranslationPresenter, mockWindow, mockWindowLocation, mockWorkspaceContext);\n      reset(mockNotificationPresenter, mockLayoutPresenter);\n      reset(mockSearchLink);\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void resetAllCaptures()\n   {\n      capturedDocumentLinkClickHandler.reset();\n      capturedDocumentSelectionEvent.reset();\n      capturedDocumentStatsUpdatedEventHandler.reset();\n      capturedHistoryTokenString.reset();\n      capturedHistoryValueChangeHandler.reset();\n      capturedLeaveWorkspaceLinkCommand.reset();\n      capturedHelpLinkCommand.reset();\n      capturedKeyShortcuts.reset();\n      capturedProjectStatsUpdatedEventHandler.reset();\n      capturedSearchLinkClickHandler.reset();\n      capturedSignoutLinkCommand.reset();\n      capturedWorkspaceContextUpdatedEventHandler.reset();\n      capturedPresenterRevealedHandler.reset();\n      capturedErrorNotificationBtnHandler.reset();\n   }","id":98548,"modified_method":"private void resetAllCaptures()\n   {\n      capturedDocumentLinkClickHandler.reset();\n      capturedDocumentSelectionEvent.reset();\n      capturedDocumentStatsUpdatedEventHandler.reset();\n      capturedHistoryTokenString.reset();\n      capturedHistoryValueChangeHandler.reset();\n      capturedKeyShortcuts.reset();\n      capturedProjectStatsUpdatedEventHandler.reset();\n      capturedSearchLinkClickHandler.reset();\n      capturedWorkspaceContextUpdatedEventHandler.reset();\n      capturedPresenterRevealedHandler.reset();\n      capturedErrorNotificationBtnHandler.reset();\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Set up expectations to bind child presenters\n    */\n   private void expectSubPresenterBindings()\n   {\n      mockKeyShortcutPresenter.bind();\n      expectLastCall().once();\n      mockDocumentListPresenter.bind();\n      expectLastCall().once();\n      mockSearchResultsPresenter.bind();\n      expectLastCall().once();\n      mockTranslationPresenter.bind();\n      expectLastCall().once();\n      mockNotificationPresenter.bind();\n      expectLastCall().once();\n\n   }","id":98549,"modified_method":"/**\n    * Set up expectations to bind child presenters\n    */\n   private void expectSubPresenterBindings()\n   {\n      mockKeyShortcutPresenter.bind();\n      expectLastCall().once();\n      mockDocumentListPresenter.bind();\n      expectLastCall().once();\n      mockSearchResultsPresenter.bind();\n      expectLastCall().once();\n      mockTranslationPresenter.bind();\n      expectLastCall().once();\n      mockNotificationPresenter.bind();\n      expectLastCall().once();\n      mockLayoutPresenter.bind();\n      expectLastCall().once();\n      mockLayoutPresenter.setLayoutListener(mockTranslationPresenter);\n      expectLastCall().once();\n\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void expectPresenterSetupActions()\n   {\n      mockWindow.setTitle(TEST_WINDOW_TITLE);\n      expectLastCall().once();\n      mockDisplay.setUserLabel(TEST_PERSON_NAME);\n      expectLastCall().anyTimes();\n      mockDisplay.setWorkspaceNameLabel(TEST_WORKSPACE_NAME, TEST_WORKSPACE_TITLE);\n      expectLastCall().anyTimes();\n      mockDisplay.setReadOnlyVisible(false);\n      expectLastCall().once();\n      // initially empty project stats\n      mockDisplay.setStats(eq(emptyProjectStats));\n      expectLastCall().once();\n\n      mockDisplay.setDocumentLabel(\"\", NO_DOCUMENTS_STRING);\n      expectLastCall().once();\n\n      mockDisplay.showInMainView(MainView.Documents);\n      expectLastCall().once(); // starts on document list view\n\n      mockTranslationPresenter.concealDisplay();\n      expectLastCall().once();\n\n      // due to this display beginning as concealed\n      mockSearchResultsPresenter.concealDisplay();\n      expectLastCall().once();\n\n      mockLeaveWorkspaceMenuItem.setCommand(and(capture(capturedLeaveWorkspaceLinkCommand), isA(Command.class)));\n      expectLastCall().once();\n\n      mockHelpMenuItem.setCommand(and(capture(capturedHelpLinkCommand), isA(Command.class)));\n      expectLastCall().once();\n\n      mockSignoutMenuItem.setCommand(and(capture(capturedSignoutLinkCommand), isA(Command.class)));\n      expectLastCall().once();\n\n      expect(mockKeyShortcutPresenter.registerKeyShortcut(and(capture(capturedKeyShortcuts), isA(KeyShortcut.class)))).andReturn(null).anyTimes();\n   }","id":98550,"modified_method":"private void expectPresenterSetupActions()\n   {\n      mockWindow.setTitle(TEST_WINDOW_TITLE);\n      expectLastCall().once();\n      mockDisplay.setWorkspaceNameLabel(TEST_WORKSPACE_NAME, TEST_WORKSPACE_TITLE);\n      expectLastCall().anyTimes();\n      mockDisplay.setReadOnlyVisible(false);\n      expectLastCall().once();\n      // initially empty project stats\n      mockDisplay.setStats(eq(emptyProjectStats));\n      expectLastCall().once();\n\n      mockDisplay.setDocumentLabel(\"\", NO_DOCUMENTS_STRING);\n      expectLastCall().once();\n\n      mockDisplay.showInMainView(MainView.Documents);\n      expectLastCall().once(); // starts on document list view\n\n      mockTranslationPresenter.concealDisplay();\n      expectLastCall().once();\n\n      // due to this display beginning as concealed\n      mockSearchResultsPresenter.concealDisplay();\n      expectLastCall().once();\n      \n      mockDisplay.initMenuList(isA(String.class), isA(Command.class), isA(Command.class), isA(Command.class), isA(Command.class));\n      expectLastCall().once();\n      \n      mockDisplay.setLayoutMenuVisible(false);\n      expectLastCall().anyTimes();\n      \n      mockDisplay.setLayoutMenuVisible(true);\n      expectLastCall().anyTimes();\n\n      expect(mockKeyShortcutPresenter.registerKeyShortcut(and(capture(capturedKeyShortcuts), isA(KeyShortcut.class)))).andReturn(null).anyTimes();\n   }","commit_id":"8a1a36a46d06aba77b68b74f5a110529797f2c9b","url":"https://github.com/zanata/zanata-server"},{"original_method":"public synchronized long nextId()\n    {\n        // if we dont have anymore grabbed ids from master, grab a bunch \n        try\n        {\n            Long nextId = nextLocalIdOrNull();\n            if ( nextId == null )\n            {\n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId.intValue();\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","id":98551,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","commit_id":"1bd49d1dd63f78d5e5b7a0b135fdfbdd5ddb09c4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Long storeLocally( IdAllocation allocation )\n    {\n        this.highestIdInUse = allocation.getHighestIdInUse();\n        this.defragCount = allocation.getDefragCount();\n        for ( long id : allocation.getIds() )\n        {\n            idQueue.add( id );\n        }\n        updateLocalIdGenerator();\n        return idQueue.poll();\n    }","id":98552,"modified_method":"private long storeLocally( IdAllocation allocation )\n    {\n        this.highestIdInUse = allocation.getHighestIdInUse();\n        this.defragCount = allocation.getDefragCount();\n        this.idQueue = new LongArrayIterator( allocation.getIds() );\n        updateLocalIdGenerator();\n        return idQueue.next();\n    }","commit_id":"1bd49d1dd63f78d5e5b7a0b135fdfbdd5ddb09c4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Long nextLocalIdOrNull()\n    {\n        return this.idQueue.poll();\n    }","id":98553,"modified_method":"private long nextLocalId()\n    {\n        return this.idQueue.next();\n    }","commit_id":"1bd49d1dd63f78d5e5b7a0b135fdfbdd5ddb09c4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        // if we dont have anymore grabbed ids from master, grab a bunch \n        try\n        {\n            Long nextId = nextLocalIdOrNull();\n            if ( nextId == null )\n            {\n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId.intValue();\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","id":98554,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","commit_id":"1cca8edd063094956912ae5a2c235eabf5a2b664","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Long nextLocalIdOrNull()\n    {\n        return this.idQueue.poll();\n    }","id":98555,"modified_method":"private long nextLocalId()\n    {\n        return this.idQueue.next();\n    }","commit_id":"1cca8edd063094956912ae5a2c235eabf5a2b664","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Long storeLocally( IdAllocation allocation )\n    {\n        this.highestIdInUse = allocation.getHighestIdInUse();\n        this.defragCount = allocation.getDefragCount();\n        for ( long id : allocation.getIds() )\n        {\n            idQueue.add( id );\n        }\n        updateLocalIdGenerator();\n        return idQueue.poll();\n    }","id":98556,"modified_method":"private long storeLocally( IdAllocation allocation )\n    {\n        this.highestIdInUse = allocation.getHighestIdInUse();\n        this.defragCount = allocation.getDefragCount();\n        this.idQueue = new LongArrayIterator( allocation.getIds() );\n        updateLocalIdGenerator();\n        return idQueue.next();\n    }","commit_id":"1cca8edd063094956912ae5a2c235eabf5a2b664","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Long storeLocally( IdAllocation allocation )\n    {\n        this.highestIdInUse = allocation.getHighestIdInUse();\n        this.defragCount = allocation.getDefragCount();\n        for ( long id : allocation.getIds() )\n        {\n            idQueue.add( id );\n        }\n        updateLocalIdGenerator();\n        return idQueue.poll();\n    }","id":98557,"modified_method":"private long storeLocally( IdAllocation allocation )\n    {\n        this.highestIdInUse = allocation.getHighestIdInUse();\n        this.defragCount = allocation.getDefragCount();\n        this.idQueue = new LongArrayIterator( allocation.getIds() );\n        updateLocalIdGenerator();\n        return idQueue.next();\n    }","commit_id":"d4a79550811b8b1d4dbfc2fb3e3e7dec82ef56e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Long nextLocalIdOrNull()\n    {\n        return this.idQueue.poll();\n    }","id":98558,"modified_method":"private long nextLocalId()\n    {\n        return this.idQueue.next();\n    }","commit_id":"d4a79550811b8b1d4dbfc2fb3e3e7dec82ef56e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        // if we dont have anymore grabbed ids from master, grab a bunch \n        try\n        {\n            Long nextId = nextLocalIdOrNull();\n            if ( nextId == null )\n            {\n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId.intValue();\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","id":98559,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","commit_id":"d4a79550811b8b1d4dbfc2fb3e3e7dec82ef56e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    List<SNode> baseMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.BaseMethod_Finder\", node, GlobalScope.getInstance(), new EmptyProgressIndicator());\n    ListSequence.fromList(baseMethods).addElement(node);\n    for(SNode method : baseMethods) {\n      ListOperations.addElement(_results, method);\n    }\n  }","id":98560,"modified_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    List<SNode> baseMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.BaseMethod_Finder\", node, GlobalScope.getInstance(), new EmptyProgressIndicator());\n    ListSequence.fromList(baseMethods).addElement(node);\n    for(SNode method : Sequence.fromIterable(baseMethods)) {\n      ListOperations.addElement(_results, method);\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> baseMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.BaseMethod_Finder\", node, GlobalScope.getInstance(), indicator);\n    for(SNode method : baseMethods) {\n      for(SNode usage : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.MethodUsages_Finder\", method, scope, indicator)) {\n        ListOperations.addElement(_results, usage);\n      }\n    }\n  }","id":98561,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> baseMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.BaseMethod_Finder\", node, GlobalScope.getInstance(), indicator);\n    for(SNode method : Sequence.fromIterable(baseMethods)) {\n      for(SNode usage : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.MethodUsages_Finder\", method, scope, indicator))) {\n        ListOperations.addElement(_results, usage);\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> allAncestors = new ArrayList<SNode>();\n    SNode method = node;\n    boolean isStatic = SNodeOperations.isInstanceOf(method, \"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\");\n    SNode classNode = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    SNode interfaceNode = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Interface\", false, false);\n    if (classNode != null) {\n      ListSequence.fromList(allAncestors).addElement(classNode);\n      ListSequence.fromList(allAncestors).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ClassAncestors_Finder\", classNode, scope, indicator)));\n      ListSequence.fromList(allAncestors).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ImplementedInterfaces_Finder\", classNode, scope, indicator)));\n    } else if (interfaceNode != null) {\n      ListSequence.fromList(allAncestors).addElement(interfaceNode);\n      ListSequence.fromList(allAncestors).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.InterfaceAncestors_Finder\", interfaceNode, scope, indicator)));\n    }\n    Set<SNode> results = new HashSet<SNode>();\n    for(SNode ancestor : allAncestors) {\n      List<SNode> classMethods = null;\n      if (isStatic) {\n        if (SNodeOperations.isInstanceOf(ancestor, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n          classMethods = SLinkOperations.getTargets(((SNode)ancestor), \"staticMethod\", true);\n        }\n      } else\n      {\n        if (SNodeOperations.isInstanceOf(ancestor, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n          classMethods = SLinkOperations.getTargets(((SNode)ancestor), \"method\", true);\n        } else\n        {\n          classMethods = SLinkOperations.getTargets(((SNode)ancestor), \"method\", true);\n        }\n      }\n      for(SNode classMethod : classMethods) {\n        if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(classMethod, method)) {\n          results.add(classMethod);\n        }\n      }\n    }\n    for(SNode result : results) {\n      ListOperations.addElement(_results, result);\n    }\n  }","id":98562,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> allAncestors = new ArrayList<SNode>();\n    SNode method = node;\n    boolean isStatic = SNodeOperations.isInstanceOf(method, \"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\");\n    SNode classNode = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    SNode interfaceNode = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Interface\", false, false);\n    if (classNode != null) {\n      ListSequence.fromList(allAncestors).addElement(classNode);\n      ListSequence.fromList(allAncestors).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ClassAncestors_Finder\", classNode, scope, indicator)));\n      ListSequence.fromList(allAncestors).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ImplementedInterfaces_Finder\", classNode, scope, indicator)));\n    } else if (interfaceNode != null) {\n      ListSequence.fromList(allAncestors).addElement(interfaceNode);\n      ListSequence.fromList(allAncestors).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.InterfaceAncestors_Finder\", interfaceNode, scope, indicator)));\n    }\n    Set<SNode> results = new HashSet<SNode>();\n    for(SNode ancestor : Sequence.fromIterable(allAncestors)) {\n      List<SNode> classMethods = null;\n      if (isStatic) {\n        if (SNodeOperations.isInstanceOf(ancestor, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n          classMethods = SLinkOperations.getTargets(((SNode)ancestor), \"staticMethod\", true);\n        }\n      } else\n      {\n        if (SNodeOperations.isInstanceOf(ancestor, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n          classMethods = SLinkOperations.getTargets(((SNode)ancestor), \"method\", true);\n        } else\n        {\n          classMethods = SLinkOperations.getTargets(((SNode)ancestor), \"method\", true);\n        }\n      }\n      for(SNode classMethod : Sequence.fromIterable(classMethods)) {\n        if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(classMethod, method)) {\n          results.add(classMethod);\n        }\n      }\n    }\n    for(SNode result : Sequence.fromIterable(results)) {\n      ListOperations.addElement(_results, result);\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    // search for straight usages & search for SUPER calls\n    // BUG IN BASE LANGUAGE -- AT THE TIME THIS THING DOES NOT FIND SUPER() CALLS\n    for(SNode nodeUsage : FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", node, scope, indicator)) {\n      ListOperations.addElement(_results, nodeUsage);\n    }\n    // WORKAROUND - FIND SUPER() CALLS\n    for(SNode subclassResult : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.StraightDerivedClasses_Finder\", SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), scope, indicator)) {\n      for(SNode constructorNode : SLinkOperations.getTargets(subclassResult, \"constructor\", true)) {\n        for(SNode invocation : ListSequence.fromList(SNodeOperations.getDescendants(constructorNode, null, false)).where(new IWhereFilter <SNode>() {\n\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation\");\n          }\n\n        })) {\n          boolean thisConstructor = true;\n          SNode invocationNode = (SNode)invocation;\n          if (ListSequence.fromList(SLinkOperations.getTargets(invocationNode, \"actualArgument\", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count()) {\n            for(int i = 0 ; i < ListSequence.fromList(SLinkOperations.getTargets(invocationNode, \"actualArgument\", true)).count() ; i = i + 1) {\n              SNode actualArgument = ListSequence.fromList(SLinkOperations.getTargets(invocationNode, \"actualArgument\", true)).getElement(i);\n              SNode formalArgument = ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).getElement(i);\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(actualArgument), SLinkOperations.getTarget(formalArgument, \"type\", true)))) {\n                thisConstructor = false;\n              }\n            }\n            if (thisConstructor) {\n              ListOperations.addElement(_results, invocationNode);\n            }\n          }\n        }\n      }\n    }\n    // search for enum constants creation\n    SNode enumNode = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.EnumClass\", false, false);\n    if (enumNode != null) {\n      for(SNode enumConstant : SLinkOperations.getTargets(enumNode, \"enumConstant\", true)) {\n        boolean thisConstructor = true;\n        if (ListSequence.fromList(SLinkOperations.getTargets(enumConstant, \"actualArgument\", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count()) {\n          for(int i = 0 ; i < ListSequence.fromList(SLinkOperations.getTargets(enumConstant, \"actualArgument\", true)).count() ; i = i + 1) {\n            SNode actualArgument = ListSequence.fromList(SLinkOperations.getTargets(enumConstant, \"actualArgument\", true)).getElement(i);\n            SNode formalArgument = ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).getElement(i);\n            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(actualArgument), SLinkOperations.getTarget(formalArgument, \"type\", true)))) {\n              thisConstructor = false;\n            }\n          }\n          if (thisConstructor) {\n            ListOperations.addElement(_results, enumConstant);\n          }\n        }\n      }\n    }\n  }","id":98563,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    // search for straight usages & search for SUPER calls\n    // BUG IN BASE LANGUAGE -- AT THE TIME THIS THING DOES NOT FIND SUPER() CALLS\n    for(SNode nodeUsage : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", node, scope, indicator))) {\n      ListOperations.addElement(_results, nodeUsage);\n    }\n    // WORKAROUND - FIND SUPER() CALLS\n    for(SNode subclassResult : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.StraightDerivedClasses_Finder\", SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), scope, indicator))) {\n      for(SNode constructorNode : Sequence.fromIterable(SLinkOperations.getTargets(subclassResult, \"constructor\", true))) {\n        for(SNode invocation : Sequence.fromIterable(ListSequence.fromList(SNodeOperations.getDescendants(constructorNode, null, false)).where(new IWhereFilter <SNode>() {\n\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation\");\n          }\n\n        }))) {\n          boolean thisConstructor = true;\n          SNode invocationNode = (SNode)invocation;\n          if (ListSequence.fromList(SLinkOperations.getTargets(invocationNode, \"actualArgument\", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count()) {\n            for(int i = 0 ; i < ListSequence.fromList(SLinkOperations.getTargets(invocationNode, \"actualArgument\", true)).count() ; i = i + 1) {\n              SNode actualArgument = ListSequence.fromList(SLinkOperations.getTargets(invocationNode, \"actualArgument\", true)).getElement(i);\n              SNode formalArgument = ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).getElement(i);\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(actualArgument), SLinkOperations.getTarget(formalArgument, \"type\", true)))) {\n                thisConstructor = false;\n              }\n            }\n            if (thisConstructor) {\n              ListOperations.addElement(_results, invocationNode);\n            }\n          }\n        }\n      }\n    }\n    // search for enum constants creation\n    SNode enumNode = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.EnumClass\", false, false);\n    if (enumNode != null) {\n      for(SNode enumConstant : Sequence.fromIterable(SLinkOperations.getTargets(enumNode, \"enumConstant\", true))) {\n        boolean thisConstructor = true;\n        if (ListSequence.fromList(SLinkOperations.getTargets(enumConstant, \"actualArgument\", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count()) {\n          for(int i = 0 ; i < ListSequence.fromList(SLinkOperations.getTargets(enumConstant, \"actualArgument\", true)).count() ; i = i + 1) {\n            SNode actualArgument = ListSequence.fromList(SLinkOperations.getTargets(enumConstant, \"actualArgument\", true)).getElement(i);\n            SNode formalArgument = ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).getElement(i);\n            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(actualArgument), SLinkOperations.getTarget(formalArgument, \"type\", true)))) {\n              thisConstructor = false;\n            }\n          }\n          if (thisConstructor) {\n            ListOperations.addElement(_results, enumConstant);\n          }\n        }\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> fieldDeclarations = new ArrayList<SNode>();\n    ListSequence.fromList(fieldDeclarations).addElement(node);\n    if (SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false) != null) {\n      ListSequence.fromList(fieldDeclarations).addSequence(ListSequence.fromList((List<SNode>)FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingFields_Finder\", node, scope, indicator)));\n    }\n    // \n    for(SNode fieldDeclaration : fieldDeclarations) {\n      for(SNode fieldUsage : FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", fieldDeclaration, scope, indicator)) {\n        ListOperations.addElement(_results, fieldUsage);\n      }\n    }\n  }","id":98564,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> fieldDeclarations = new ArrayList<SNode>();\n    ListSequence.fromList(fieldDeclarations).addElement(node);\n    if (SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false) != null) {\n      ListSequence.fromList(fieldDeclarations).addSequence(ListSequence.fromList((List<SNode>)FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingFields_Finder\", node, scope, indicator)));\n    }\n    // \n    for(SNode fieldDeclaration : Sequence.fromIterable(fieldDeclarations)) {\n      for(SNode fieldUsage : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", fieldDeclaration, scope, indicator))) {\n        ListOperations.addElement(_results, fieldUsage);\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    ListOperations.addElement(_results, node);\n    if (SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false) != null) {\n      for(SNode fieldNode : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingFields_Finder\", node, scope, new EmptyProgressIndicator())) {\n        ListOperations.addElement(_results, fieldNode);\n      }\n    }\n  }","id":98565,"modified_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    ListOperations.addElement(_results, node);\n    if (SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false) != null) {\n      for(SNode fieldNode : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingFields_Finder\", node, scope, new EmptyProgressIndicator()))) {\n        ListOperations.addElement(_results, fieldNode);\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> result = new ArrayList<SNode>();\n    List<SNode> classNodes = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ClassAncestors_Finder\", node, scope, indicator);\n    ListSequence.fromList(classNodes).addElement(node);\n    for(SNode classNode : classNodes) {\n      for(SNode implementedInterface : SLinkOperations.getTargets((SNode)classNode, \"implementedInterface\", true)) {\n        SNode interfaceNode = (SNode)SLinkOperations.getTarget(implementedInterface, \"classifier\", false);\n        ListSequence.fromList(result).addElement(interfaceNode);\n        ListSequence.fromList(result).addSequence(ListSequence.fromList((List<SNode>)FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.InterfaceAncestors_Finder\", interfaceNode, scope, indicator)));\n      }\n    }\n    for(SNode interfaceNode : result) {\n      ListOperations.addElement(_results, interfaceNode);\n    }\n  }","id":98566,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> result = new ArrayList<SNode>();\n    List<SNode> classNodes = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ClassAncestors_Finder\", node, scope, indicator);\n    ListSequence.fromList(classNodes).addElement(node);\n    for(SNode classNode : Sequence.fromIterable(classNodes)) {\n      for(SNode implementedInterface : Sequence.fromIterable(SLinkOperations.getTargets((SNode)classNode, \"implementedInterface\", true))) {\n        SNode interfaceNode = (SNode)SLinkOperations.getTarget(implementedInterface, \"classifier\", false);\n        ListSequence.fromList(result).addElement(interfaceNode);\n        ListSequence.fromList(result).addSequence(ListSequence.fromList((List<SNode>)FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.InterfaceAncestors_Finder\", interfaceNode, scope, indicator)));\n      }\n    }\n    for(SNode interfaceNode : Sequence.fromIterable(result)) {\n      ListOperations.addElement(_results, interfaceNode);\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> derivedInterfaces = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedInterfaces_Finder\", node, scope, indicator);\n    ListSequence.fromList(derivedInterfaces).addElement(node);\n    // \n    List<SNode> derivedInterfacesUsages = new ArrayList<SNode>();\n    for(SNode derivedInterface : derivedInterfaces) {\n      ListSequence.fromList(derivedInterfacesUsages).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", derivedInterface, scope, indicator)));\n    }\n    // \n    for(SNode interfaceNode : derivedInterfacesUsages) {\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(interfaceNode), \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n        if (SNodeOperations.hasRole(interfaceNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"implementedInterface\")) {\n          ListOperations.addElement(_results, SNodeOperations.getParent(interfaceNode));\n          for(SNode classNode : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", SNodeOperations.getParent(interfaceNode), scope, indicator)) {\n            ListOperations.addElement(_results, classNode);\n          }\n        }\n      }\n    }\n  }","id":98567,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> derivedInterfaces = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedInterfaces_Finder\", node, scope, indicator);\n    ListSequence.fromList(derivedInterfaces).addElement(node);\n    // \n    List<SNode> derivedInterfacesUsages = new ArrayList<SNode>();\n    for(SNode derivedInterface : derivedInterfaces) {\n      ListSequence.fromList(derivedInterfacesUsages).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", derivedInterface, scope, indicator)));\n    }\n    // \n    for(SNode interfaceNode : derivedInterfacesUsages) {\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(interfaceNode), \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n        if (SNodeOperations.hasRole(interfaceNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"implementedInterface\")) {\n          ListOperations.addElement(_results, SNodeOperations.getParent(interfaceNode));\n          for(SNode classNode : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", SNodeOperations.getParent(interfaceNode), scope, indicator))) {\n            ListOperations.addElement(_results, classNode);\n          }\n        }\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    ListOperations.addElement(_results, node);\n    for(SNode derivedInterface : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedInterfaces_Finder\", node, scope, new EmptyProgressIndicator())) {\n      ListOperations.addElement(_results, derivedInterface);\n    }\n  }","id":98568,"modified_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    ListOperations.addElement(_results, node);\n    for(SNode derivedInterface : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedInterfaces_Finder\", node, scope, new EmptyProgressIndicator()))) {\n      ListOperations.addElement(_results, derivedInterface);\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"extendedInterface\", true)).isEmpty()) {\n      return;\n    }\n    SNode current = node;\n    for(SNode ancestor : SLinkOperations.getTargets(current, \"extendedInterface\", true)) {\n      SNode ancestorNode = (SNode)SLinkOperations.getTarget(ancestor, \"classifier\", false);\n      ListOperations.addElement(_results, ancestorNode);\n      for(SNode ancestorAncestor : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.InterfaceAncestors_Finder\", ancestorNode, scope, indicator)) {\n        ListOperations.addElement(_results, ancestorAncestor);\n      }\n    }\n  }","id":98569,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"extendedInterface\", true)).isEmpty()) {\n      return;\n    }\n    SNode current = node;\n    for(SNode ancestor : Sequence.fromIterable(SLinkOperations.getTargets(current, \"extendedInterface\", true))) {\n      SNode ancestorNode = (SNode)SLinkOperations.getTarget(ancestor, \"classifier\", false);\n      ListOperations.addElement(_results, ancestorNode);\n      for(SNode ancestorAncestor : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.InterfaceAncestors_Finder\", ancestorNode, scope, indicator))) {\n        ListOperations.addElement(_results, ancestorAncestor);\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> implementorsAndAncestorsList = new ArrayList<SNode>();\n    for(SNode implementor : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ImplementingClasses_Finder\", SNodeOperations.getParent(node), scope, indicator)) {\n      ListSequence.fromList(implementorsAndAncestorsList).addElement(implementor);\n      ListSequence.fromList(implementorsAndAncestorsList).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", implementor, scope, indicator)));\n    }\n    // \n    Set<SNode> implementorsAndAncestorsNodes = new HashSet<SNode>();\n    for(SNode implementorOrAncestor : implementorsAndAncestorsList) {\n      implementorsAndAncestorsNodes.add(implementorOrAncestor);\n    }\n    // \n    for(SNode classNode : implementorsAndAncestorsNodes) {\n      for(SNode sMethod : SLinkOperations.getTargets(classNode, \"method\", true)) {\n        if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(sMethod, node)) {\n          ListOperations.addElement(_results, sMethod);\n        }\n      }\n    }\n  }","id":98570,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    List<SNode> implementorsAndAncestorsList = new ArrayList<SNode>();\n    for(SNode implementor : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.ImplementingClasses_Finder\", SNodeOperations.getParent(node), scope, indicator))) {\n      ListSequence.fromList(implementorsAndAncestorsList).addElement(implementor);\n      ListSequence.fromList(implementorsAndAncestorsList).addSequence(ListSequence.fromList(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", implementor, scope, indicator)));\n    }\n    // \n    Set<SNode> implementorsAndAncestorsNodes = new HashSet<SNode>();\n    for(SNode implementorOrAncestor : Sequence.fromIterable(implementorsAndAncestorsList)) {\n      implementorsAndAncestorsNodes.add(implementorOrAncestor);\n    }\n    // \n    for(SNode classNode : Sequence.fromIterable(implementorsAndAncestorsNodes)) {\n      for(SNode sMethod : Sequence.fromIterable(SLinkOperations.getTargets(classNode, \"method\", true))) {\n        if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(sMethod, node)) {\n          ListOperations.addElement(_results, sMethod);\n        }\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    for(SNode classNode : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", SNodeOperations.getParent(node), scope, indicator)) {\n      Iterable<SNode> fieldsOfSameKind;\n      if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\")) {\n        fieldsOfSameKind = SLinkOperations.getTargets(classNode, \"field\", true);\n      } else\n      {\n        fieldsOfSameKind = SLinkOperations.getTargets(classNode, \"staticField\", true);\n      }\n      for(SNode field : fieldsOfSameKind) {\n        if (SPropertyOperations.getString(field, \"name\").equals(SPropertyOperations.getString(node, \"name\")) && Type_Behavior.call_getErasureSignature_1213877337313(SLinkOperations.getTarget(field, \"type\", true)).equals(Type_Behavior.call_getErasureSignature_1213877337313(SLinkOperations.getTarget(node, \"type\", true)))) {\n          ListOperations.addElement(_results, field);\n        }\n      }\n    }\n  }","id":98571,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    for(SNode classNode : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", SNodeOperations.getParent(node), scope, indicator))) {\n      Iterable<SNode> fieldsOfSameKind;\n      if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\")) {\n        fieldsOfSameKind = SLinkOperations.getTargets(classNode, \"field\", true);\n      } else\n      {\n        fieldsOfSameKind = SLinkOperations.getTargets(classNode, \"staticField\", true);\n      }\n      for(SNode field : Sequence.fromIterable(fieldsOfSameKind)) {\n        if (SPropertyOperations.getString(field, \"name\").equals(SPropertyOperations.getString(node, \"name\")) && Type_Behavior.call_getErasureSignature_1213877337313(SLinkOperations.getTarget(field, \"type\", true)).equals(Type_Behavior.call_getErasureSignature_1213877337313(SLinkOperations.getTarget(node, \"type\", true)))) {\n          ListOperations.addElement(_results, field);\n        }\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    for(SNode classNode : FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", SNodeOperations.getParent(node), scope, indicator)) {\n      Iterable<SNode> methodsOfSameKind;\n      if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")) {\n        methodsOfSameKind = SLinkOperations.getTargets(classNode, \"method\", true);\n      } else\n      {\n        methodsOfSameKind = SLinkOperations.getTargets(classNode, \"staticMethod\", true);\n      }\n      for(SNode sMethod : methodsOfSameKind) {\n        if (SPropertyOperations.getString(sMethod, \"name\").equals(SPropertyOperations.getString(node, \"name\")) && SLinkOperations.getCount(sMethod, \"parameter\") == SLinkOperations.getCount(node, \"parameter\")) {\n          if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(sMethod, node)) {\n            ListOperations.addElement(_results, sMethod);\n          }\n        }\n      }\n    }\n  }","id":98572,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    for(SNode classNode : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder\", SNodeOperations.getParent(node), scope, indicator))) {\n      Iterable<SNode> methodsOfSameKind;\n      if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")) {\n        methodsOfSameKind = SLinkOperations.getTargets(classNode, \"method\", true);\n      } else\n      {\n        methodsOfSameKind = SLinkOperations.getTargets(classNode, \"staticMethod\", true);\n      }\n      for(SNode sMethod : Sequence.fromIterable(methodsOfSameKind)) {\n        if (SPropertyOperations.getString(sMethod, \"name\").equals(SPropertyOperations.getString(node, \"name\")) && SLinkOperations.getCount(sMethod, \"parameter\") == SLinkOperations.getCount(node, \"parameter\")) {\n          if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(sMethod, node)) {\n            ListOperations.addElement(_results, sMethod);\n          }\n        }\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    SNode nodeParentMethod = SNodeOperations.getAncestorWhereConceptInList(node, new String[]{\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\",\"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\"}, false, false);\n    // \n    List<SNode> overridingMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingMethods_Finder\", nodeParentMethod, scope, new EmptyProgressIndicator());\n    ListSequence.fromList(overridingMethods).addElement(nodeParentMethod);\n    // \n    for(SNode methodNode : overridingMethods) {\n      ListOperations.addElement(_results, ListSequence.fromList(SLinkOperations.getTargets(methodNode, \"parameter\", true)).getElement(SNodeOperations.getIndexInParent(node)));\n    }\n  }","id":98573,"modified_method":"public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {\n    SNode nodeParentMethod = SNodeOperations.getAncestorWhereConceptInList(node, new String[]{\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\",\"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\"}, false, false);\n    // \n    List<SNode> overridingMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingMethods_Finder\", nodeParentMethod, scope, new EmptyProgressIndicator());\n    ListSequence.fromList(overridingMethods).addElement(nodeParentMethod);\n    // \n    for(SNode methodNode : Sequence.fromIterable(overridingMethods)) {\n      ListOperations.addElement(_results, ListSequence.fromList(SLinkOperations.getTargets(methodNode, \"parameter\", true)).getElement(SNodeOperations.getIndexInParent(node)));\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    SNode nodeParentMethod = SNodeOperations.getAncestorWhereConceptInList(node, new String[]{\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\",\"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\"}, false, false);\n    // \n    List<SNode> overridingMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingMethods_Finder\", nodeParentMethod, scope, indicator);\n    ListSequence.fromList(overridingMethods).addElement(nodeParentMethod);\n    // \n    for(SNode methodNode : overridingMethods) {\n      SNode parameterNode = ListSequence.fromList(SLinkOperations.getTargets(methodNode, \"parameter\", true)).getElement(SNodeOperations.getIndexInParent(node));\n      for(SNode parameterUsage : FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", parameterNode, scope, indicator)) {\n        ListOperations.addElement(_results, parameterUsage);\n      }\n    }\n  }","id":98574,"modified_method":"protected void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator) {\n    SNode nodeParentMethod = SNodeOperations.getAncestorWhereConceptInList(node, new String[]{\"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\",\"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\"}, false, false);\n    // \n    List<SNode> overridingMethods = FindUtils.executeFinder(\"jetbrains.mps.baseLanguage.findUsages.OverridingMethods_Finder\", nodeParentMethod, scope, indicator);\n    ListSequence.fromList(overridingMethods).addElement(nodeParentMethod);\n    // \n    for(SNode methodNode : Sequence.fromIterable(overridingMethods)) {\n      SNode parameterNode = ListSequence.fromList(SLinkOperations.getTargets(methodNode, \"parameter\", true)).getElement(SNodeOperations.getIndexInParent(node));\n      for(SNode parameterUsage : Sequence.fromIterable(FindUtils.executeFinder(\"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\", parameterNode, scope, indicator))) {\n        ListOperations.addElement(_results, parameterUsage);\n      }\n    }\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"))) {\n      return null;\n    }\n    SNode opClassifier = DotExpression_Behavior.call_getClassifier_1213877410697(_context.getEnclosingNode());\n    if (opClassifier == null) {\n      return null;\n    }\n    List<SNode> resultProperties = ListSequence.<SNode>fromArray();\n    List<SNode> classifiers = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(opClassifier))).getClassifierNodes();\n    for(SNode classifier : classifiers) {\n      if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n        SNode classConcept = classifier;\n        List<SNode> properties = SLinkOperations.getTargets(classConcept, \"property\", true);\n        for(SNode property : properties) {\n          if (VisibilityUtil.isVisible(_context.getEnclosingNode(), property)) {\n            ListSequence.fromList(resultProperties).addElement(property);\n          }\n        }\n      }\n    }\n    return new SimpleSearchScope(resultProperties);\n  }","id":98575,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"))) {\n      return null;\n    }\n    SNode opClassifier = DotExpression_Behavior.call_getClassifier_1213877410697(_context.getEnclosingNode());\n    if (opClassifier == null) {\n      return null;\n    }\n    List<SNode> resultProperties = ListSequence.<SNode>fromArray();\n    List<SNode> classifiers = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(opClassifier))).getClassifierNodes();\n    for(SNode classifier : Sequence.fromIterable(classifiers)) {\n      if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n        SNode classConcept = classifier;\n        List<SNode> properties = SLinkOperations.getTargets(classConcept, \"property\", true);\n        for(SNode property : Sequence.fromIterable(properties)) {\n          if (VisibilityUtil.isVisible(_context.getEnclosingNode(), property)) {\n            ListSequence.fromList(resultProperties).addElement(property);\n          }\n        }\n      }\n    }\n    return new SimpleSearchScope(resultProperties);\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode createClassType_forClosure_enclosingClass(SNode inputClosure, ITemplateGenerator generator) {\n    SNode enclosingClass = SNodeOperations.getAncestor(inputClosure, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    if (enclosingClass == null) {\n      // closure is not in class\n      enclosingClass = getJavaLangObject();\n    }\n    SModel outputModel = generator.getOutputModel();\n    SNode outputClassType = SModelOperations.createNewNode(outputModel, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n    SLinkOperations.setTarget(outputClassType, \"classifier\", enclosingClass, false);\n    for(SNode typeVar : SLinkOperations.getTargets(enclosingClass, \"typeVariableDeclaration\", true)) {\n      SNode typeVarRef = SLinkOperations.addNewChild(outputClassType, \"parameter\", \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\");\n      SLinkOperations.setTarget(typeVarRef, \"typeVariableDeclaration\", typeVar, false);\n    }\n    return outputClassType;\n  }","id":98576,"modified_method":"public static SNode createClassType_forClosure_enclosingClass(SNode inputClosure, ITemplateGenerator generator) {\n    SNode enclosingClass = SNodeOperations.getAncestor(inputClosure, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    if (enclosingClass == null) {\n      // closure is not in class\n      enclosingClass = getJavaLangObject();\n    }\n    SModel outputModel = generator.getOutputModel();\n    SNode outputClassType = SModelOperations.createNewNode(outputModel, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n    SLinkOperations.setTarget(outputClassType, \"classifier\", enclosingClass, false);\n    for(SNode typeVar : Sequence.fromIterable(SLinkOperations.getTargets(enclosingClass, \"typeVariableDeclaration\", true))) {\n      SNode typeVarRef = SLinkOperations.addNewChild(outputClassType, \"parameter\", \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\");\n      SLinkOperations.setTarget(typeVarRef, \"typeVariableDeclaration\", typeVar, false);\n    }\n    return outputClassType;\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // type-variables declared in enclosing classifier\n    List<SNode> declarations = new ArrayList<SNode>();\n    for(SNode genericDeclaration : SNodeOperations.getAncestors(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.GenericDeclaration\", true)) {\n      ListSequence.fromList(declarations).addSequence(ListSequence.fromList(SLinkOperations.getTargets(genericDeclaration, \"typeVariableDeclaration\", true)));\n    }\n    return new SimpleSearchScope(declarations);\n  }","id":98577,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // type-variables declared in enclosing classifier\n    List<SNode> declarations = new ArrayList<SNode>();\n    for(SNode genericDeclaration : Sequence.fromIterable(SNodeOperations.getAncestors(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.GenericDeclaration\", true))) {\n      ListSequence.fromList(declarations).addSequence(ListSequence.fromList(SLinkOperations.getTargets(genericDeclaration, \"typeVariableDeclaration\", true)));\n    }\n    return new SimpleSearchScope(declarations);\n  }","commit_id":"9539d90672145ee48815fc8f0e74b8525af47b1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Show the dialog and get user's answer, whether he wants to force delete the branch.\n   *\n   * @param commits          the list of commits, which are not merged from the branch being deleted to the current branch,\n   *                         grouped by repository.\n   * @param branchToDelete   the name of the branch which user chose to delete.\n   * @param mergedToBranches the list of branches which the branch is merged to (returned by {@code git branch --merged <branchToDelete>} command.\n   * @param currentBranch\n   * @return true if user decided to delete the branch.\n   */\n  public static boolean showAndGetAnswer(@NotNull Project project,\n                                         @NotNull Map<GitRepository, List<GitCommit>> commits,\n                                         @NotNull String branchToDelete,\n                                         @NotNull List<String> mergedToBranches, \n                                         @Nullable String currentBranch) {\n    GitBranchIsNotFullyMergedDialog dialog = new GitBranchIsNotFullyMergedDialog(project, commits, branchToDelete, currentBranch, mergedToBranches);\n    dialog.show();\n    return dialog.isOK();\n  }","id":98578,"modified_method":"/**\n   * Show the dialog and get user's answer, whether he wants to force delete the branch.\n   *\n   * @param commits          the list of commits, which are not merged from the branch being deleted to the current branch,\n   *                         grouped by repository.\n   * @param branchToDelete   the name of the branch which user chose to delete.\n   * @param mergedToBranches the list of branches which the branch is merged to (returned by {@code git branch --merged <branchToDelete>} command.\n   * @param currentBranch\n   * @return true if user decided to delete the branch.\n   */\n  public static boolean showAndGetAnswer(@NotNull Project project,\n                                         @NotNull Map<GitRepository, List<GitCommit>> commits,\n                                         @NotNull String branchToDelete,\n                                         @NotNull List<String> mergedToBranches, \n                                         @Nullable String currentBranch) {\n    GitBranchIsNotFullyMergedDialog dialog = new GitBranchIsNotFullyMergedDialog(project, commits, branchToDelete, currentBranch, mergedToBranches);\n    DialogManager.getInstance(project).showDialog(dialog);\n    return dialog.isOK();\n  }","commit_id":"0bcc0f9af71280c3838f6fa77abef891ca3931f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showUnmergedFilesNotification() {\n    String title = UNMERGED_FILES_ERROR_TITLE;\n    String description = \"You have to <a href='resolve'>resolve<\/a> all merge conflicts before checkout.<br/>\" +\n                         \"After resolving conflicts you also probably would want to commit your files to the current branch.\";\n    GitVcs.IMPORTANT_ERROR_NOTIFICATION.createNotification(title, description, NotificationType.ERROR, new NotificationListener() {\n      @Override public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n        if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED && event.getDescription().equals(\"resolve\")) {\n          GitConflictResolver.Params params = new GitConflictResolver.Params().\n                setMergeDescription(\"The following files have unresolved conflicts. You need to resolve them before checking out.\").\n                setErrorNotificationTitle(\"Unresolved files remain.\");\n          new GitConflictResolver(myProject, GitUtil.getRoots(getRepositories()), params).merge();\n        }\n      }\n    }).notify(myProject);\n  }","id":98579,"modified_method":"private void showUnmergedFilesNotification() {\n    String title = UNMERGED_FILES_ERROR_TITLE;\n    String description = UNMERGED_FILES_ERROR_NOTIFICATION_DESCRIPTION;\n    NotificationManager.getInstance(myProject).notify(GitVcs.IMPORTANT_ERROR_NOTIFICATION, title, description, NotificationType.ERROR, new NotificationListener() {\n      @Override public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n        if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED && event.getDescription().equals(\"resolve\")) {\n          GitConflictResolver.Params params = new GitConflictResolver.Params().\n                setMergeDescription(\"The following files have unresolved conflicts. You need to resolve them before checking out.\").\n                setErrorNotificationTitle(\"Unresolved files remain.\");\n          new GitConflictResolver(myProject, GitUtil.getRoots(getRepositories()), params).merge();\n        }\n      }\n    });\n  }","commit_id":"0bcc0f9af71280c3838f6fa77abef891ca3931f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void notifyError(@NotNull String title, @NotNull String message) {\n    GitVcs.IMPORTANT_ERROR_NOTIFICATION.createNotification(title, message, NotificationType.ERROR, null).notify(myProject);\n  }","id":98580,"modified_method":"protected void notifyError(@NotNull String title, @NotNull String message) {\n    NotificationManager.getInstance(myProject).notify(GitVcs.IMPORTANT_ERROR_NOTIFICATION, title, message, NotificationType.ERROR);\n  }","commit_id":"0bcc0f9af71280c3838f6fa77abef891ca3931f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void showFatalErrorDialogWithRollback(@NotNull final String title, @NotNull final String message) {\n    final AtomicBoolean ok = new AtomicBoolean();\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        String description = message + getRollbackProposal();\n        ok.set(Messages.OK ==\n               Messages.showYesNoDialog(myProject, description, title, \"Rollback\", \"Don't rollback\", Messages.getErrorIcon()));\n      }\n    });\n    if (ok.get()) {\n      rollback();\n    }\n  }","id":98581,"modified_method":"protected void showFatalErrorDialogWithRollback(@NotNull final String title, @NotNull final String message) {\n    final AtomicBoolean ok = new AtomicBoolean();\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        String description = message + getRollbackProposal();\n        ok.set(Messages.OK ==\n               MessageManager.showYesNoDialog(myProject, description, title, \"Rollback\", \"Don't rollback\", Messages.getErrorIcon()));\n      }\n    });\n    if (ok.get()) {\n      rollback();\n    }\n  }","commit_id":"0bcc0f9af71280c3838f6fa77abef891ca3931f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showUnmergedFilesDialogWithRollback() {\n    final AtomicBoolean ok = new AtomicBoolean();\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override public void run() {\n        String description = \"You have to resolve all merge conflicts before checkout.<br/>\" + getRollbackProposal();\n        // suppressing: this message looks ugly if capitalized by words\n        //noinspection DialogTitleCapitalization\n        ok.set(Messages.OK == Messages.showYesNoDialog(myProject, description, UNMERGED_FILES_ERROR_TITLE, \"Rollback\", \"Don't rollback\", Messages.getErrorIcon()));\n      }\n    });\n    if (ok.get()) {\n      rollback();\n    }\n  }","id":98582,"modified_method":"private void showUnmergedFilesDialogWithRollback() {\n    final AtomicBoolean ok = new AtomicBoolean();\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override public void run() {\n        String description = \"You have to resolve all merge conflicts before checkout.<br/>\" + getRollbackProposal();\n        // suppressing: this message looks ugly if capitalized by words\n        //noinspection DialogTitleCapitalization\n        ok.set(Messages.OK == MessageManager.showYesNoDialog(myProject, description, UNMERGED_FILES_ERROR_TITLE, \"Rollback\", \"Don't rollback\", Messages.getErrorIcon()));\n      }\n    });\n    if (ok.get()) {\n      rollback();\n    }\n  }","commit_id":"0bcc0f9af71280c3838f6fa77abef891ca3931f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void notifySuccess() {\n    GitVcs.NOTIFICATION_GROUP_ID.createNotification(getSuccessMessage(), NotificationType.INFORMATION).notify(myProject);\n  }","id":98583,"modified_method":"protected void notifySuccess() {\n    NotificationManager.getInstance(myProject).notify(GitVcs.NOTIFICATION_GROUP_ID, \"\", getSuccessMessage(), NotificationType.INFORMATION);\n  }","commit_id":"0bcc0f9af71280c3838f6fa77abef891ca3931f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@BeforeMethod\n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myChangeListManager = ChangeListManagerImpl.getInstanceImpl(myProject);\n    mySettings = GitVcsSettings.getInstance(myProject);\n    myCodeStyleSeparator = CodeStyleFacade.getInstance(myProject).getLineSeparator();\n    myDialogManager = registerDialogManager();\n\n    unixFile = createFileInCommand(\"unix_file.txt\", \"Unix File\\n\");\n    winFile = createFileInCommand(\"win_file.txt\", \"Windows File\\r\\n\");\n    macFile = createFileInCommand(\"mac_file.txt\", \"Mac File\\r\");\n    myRepo.addCommit();\n  }","id":98584,"modified_method":"@BeforeMethod\n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myChangeListManager = ChangeListManagerImpl.getInstanceImpl(myProject);\n    mySettings = GitVcsSettings.getInstance(myProject);\n    myCodeStyleSeparator = CodeStyleFacade.getInstance(myProject).getLineSeparator();\n    myDialogManager = GitTestUtil.registerDialogManager(myProject);\n\n    unixFile = createFileInCommand(\"unix_file.txt\", \"Unix File\\n\");\n    winFile = createFileInCommand(\"win_file.txt\", \"Windows File\\r\\n\");\n    macFile = createFileInCommand(\"mac_file.txt\", \"Mac File\\r\");\n    myRepo.addCommit();\n  }","commit_id":"0bcc0f9af71280c3838f6fa77abef891ca3931f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tprotected void readLine(String line, DeckCardLists deckList) {\n\t\tif (line.length() == 0 || line.startsWith(\"//\")) return;\n\t\tboolean sideboard = false;\n\t\tif (line.startsWith(\"SB:\")) {\n\t\t\tline = line.substring(3).trim();\n\t\t\tsideboard = true;\n\t\t}\n\t\tint delim = line.indexOf(' ');\n\t\tString lineNum = line.substring(0, delim).trim();\n\t\tString lineName = line.substring(delim).trim();\n\t\ttry {\n\t\t\tint num = Integer.parseInt(lineNum);\n\t\t\tString cardName = Sets.findCard(lineName).getClass().getCanonicalName();\n\t\t\tif (cardName == null)\n\t\t\t\tsbMessage.append(\"Could not find card: '\").append(lineName).append(\"' at line \").append(lineCount).append(\"\\n\");\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\t\tif (!sideboard)\n\t\t\t\t\t\tdeckList.getCards().add(cardName);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeckList.getSideboard().add(cardName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException nfe) {\n\t\t\tsbMessage.append(\"Invalid number: \").append(lineNum).append(\" at line \").append(lineCount).append(\"\\n\");\n\t\t}\n\t}","id":98585,"modified_method":"@Override\n\tprotected void readLine(String line, DeckCardLists deckList) {\n\t\tif (line.length() == 0 || line.startsWith(\"//\")) return;\n\t\tboolean sideboard = false;\n\t\tif (line.startsWith(\"SB:\")) {\n\t\t\tline = line.substring(3).trim();\n\t\t\tsideboard = true;\n\t\t}\n\t\tint delim = line.indexOf(' ');\n\t\tString lineNum = line.substring(0, delim).trim();\n\t\tString lineName = line.substring(delim).trim();\n\t\ttry {\n\t\t\tint num = Integer.parseInt(lineNum);\n\t\t\tCard card = Sets.findCard(lineName);\n\t\t\tif (card == null)\n\t\t\t\tsbMessage.append(\"Could not find card: '\").append(lineName).append(\"' at line \").append(lineCount).append(\"\\n\");\n\t\t\telse {\n\t\t\t\tString cardName = card.getClass().getCanonicalName();\n\t\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\t\tif (!sideboard)\n\t\t\t\t\t\tdeckList.getCards().add(cardName);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeckList.getSideboard().add(cardName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException nfe) {\n\t\t\tsbMessage.append(\"Invalid number: \").append(lineNum).append(\" at line \").append(lineCount).append(\"\\n\");\n\t\t}\n\t}","commit_id":"da316cc345c9487683151cc9938b7ad09dae5d60","url":"https://github.com/magefree/mage"},{"original_method":"private void btnImportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImportActionPerformed\n\t\tString lastFolder = MageFrame.getPreferences().get(\"lastImportFolder\", \"\");\n\t\tif (!lastFolder.isEmpty())\n\t\t\tfcImportDeck.setCurrentDirectory(new File(lastFolder));\n\t\tint ret = fcImportDeck.showOpenDialog(this);\n\t\tif (ret == JFileChooser.APPROVE_OPTION) {\n\t\t\tFile file = fcImportDeck.getSelectedFile();\n\t\t\ttry {\n\t\t\t\tsetCursor(new Cursor(Cursor.WAIT_CURSOR));\n\t\t\t\tDeckImporter importer = getDeckImporter(file.getPath());\n\t\t\t\tif (importer != null) {\n\t\t\t\t\tdeck = Deck.load(importer.importDeck(file.getPath()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tJOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Unknown deck format\", \"Error importing deck\", JOptionPane.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLogger.getLogger(DeckEditorPanel.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsetCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n\t\t\t}\n\t\t\trefreshDeck();\n\t\t\ttry {\n\t\t\t\tMageFrame.getPreferences().put(\"lastImportFolder\", file.getCanonicalPath());\n\t\t\t} catch (IOException ex) {\t}\n\t\t}\n\t\tfcImportDeck.setSelectedFile(null);\n\t}","id":98586,"modified_method":"private void btnImportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImportActionPerformed\n\t\tString lastFolder = MageFrame.getPreferences().get(\"lastImportFolder\", \"\");\n\t\tif (!lastFolder.isEmpty())\n\t\t\tfcImportDeck.setCurrentDirectory(new File(lastFolder));\n\t\tint ret = fcImportDeck.showOpenDialog(this);\n\t\tif (ret == JFileChooser.APPROVE_OPTION) {\n\t\t\tFile file = fcImportDeck.getSelectedFile();\n\t\t\ttry {\n\t\t\t\tsetCursor(new Cursor(Cursor.WAIT_CURSOR));\n\t\t\t\tDeckImporter importer = getDeckImporter(file.getPath());\n\t\t\t\tif (importer != null) {\n\t\t\t\t\tdeck = Deck.load(importer.importDeck(file.getPath()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tJOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Unknown deck format\", \"Error importing deck\", JOptionPane.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLogger.getLogger(DeckEditorPanel.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsetCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n\t\t\t}\n\t\t\trefreshDeck();\n\t\t\ttry {\n\t\t\t\tif (file != null)\n\t\t\t\t\tMageFrame.getPreferences().put(\"lastImportFolder\", file.getCanonicalPath());\n\t\t\t} catch (IOException ex) {\t}\n\t\t}\n\t\tfcImportDeck.setSelectedFile(null);\n\t}","commit_id":"da316cc345c9487683151cc9938b7ad09dae5d60","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic DeckCardLists importDeck(String file) {\n\t\tFile f = new File(file);\n\t\tDeckCardLists deckList = new DeckCardLists();\n\t\tlineCount = 0;\n\t\tsbMessage.setLength(0);\n\t\ttry {\n\t\t\tScanner scanner = new Scanner(f);\n\t\t\ttry {\n\t\t\t\twhile (scanner.hasNextLine()) {\n\t\t\t\t\tString line = scanner.nextLine().trim();\n\t\t\t\t\tlineCount++;\n\t\t\t\t\treadLine(line, deckList);\n\t\t\t\t}\n\t\t\t\tif (sbMessage.length() > 0) {\n\t\t\t\t\tJOptionPane.showMessageDialog(MageFrame.getDesktop(), sbMessage.toString(), \"Error importing deck\", JOptionPane.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tscanner.close();\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlogger.log(Level.SEVERE, null, ex);\n\t\t}\n\t\treturn deckList;\n\t}","id":98587,"modified_method":"@Override\n\tpublic DeckCardLists importDeck(String file) {\n\t\tFile f = new File(file);\n\t\tDeckCardLists deckList = new DeckCardLists();\n\t\tlineCount = 0;\n\t\tsbMessage.setLength(0);\n\t\ttry {\n\t\t\tScanner scanner = new Scanner(f);\n\t\t\ttry {\n\t\t\t\twhile (scanner.hasNextLine()) {\n\t\t\t\t\tString line = scanner.nextLine().trim();\n\t\t\t\t\tlineCount++;\n\t\t\t\t\treadLine(line, deckList);\n\t\t\t\t}\n\t\t\t\tif (sbMessage.length() > 0) {\n\t\t\t\t\tJOptionPane.showMessageDialog(MageFrame.getDesktop(), sbMessage.toString(), \"Error importing deck\", JOptionPane.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tJOptionPane.showMessageDialog(MageFrame.getDesktop(), ex.getMessage(), \"Error importing deck\", JOptionPane.ERROR_MESSAGE);\n\t\t\t\tlogger.log(Level.SEVERE, null, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tscanner.close();\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlogger.log(Level.SEVERE, null, ex);\n\t\t}\n\t\treturn deckList;\n\t}","commit_id":"da316cc345c9487683151cc9938b7ad09dae5d60","url":"https://github.com/magefree/mage"},{"original_method":"public Card findCard(String name, boolean random) {\r\n\t\tList<Card> foundCards = new ArrayList<Card>();\r\n\t\tfor (Card card : cards) {\r\n\t\t\tif (name.equals(card.getName())) {\r\n\t\t\t\tfoundCards.add(card);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (foundCards.size() > 0) {\r\n\t\t\tCard newCard = foundCards.get(rnd.nextInt(foundCards.size())).copy();\r\n\t\t\tnewCard.assignNewId();\r\n\t\t\treturn newCard;\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":98588,"modified_method":"public Card findCard(String name, boolean random) {\r\n\t\tList<Card> foundCards = new ArrayList<Card>();\r\n\t\tfor (Card card : cards) {\r\n\t\t\tif (name.equalsIgnoreCase(card.getName())) {\r\n\t\t\t\tfoundCards.add(card);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (foundCards.size() > 0) {\r\n\t\t\tCard newCard = foundCards.get(rnd.nextInt(foundCards.size())).copy();\r\n\t\t\tnewCard.assignNewId();\r\n\t\t\treturn newCard;\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"da316cc345c9487683151cc9938b7ad09dae5d60","url":"https://github.com/magefree/mage"},{"original_method":"public Card findCard(String name) {\r\n\t\tfor (Card card : cards) {\r\n\t\t\tif (name.equals(card.getName())) {\r\n\t\t\t\tCard newCard = card.copy();\r\n\t\t\t\tnewCard.assignNewId();\r\n\t\t\t\treturn newCard;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":98589,"modified_method":"public Card findCard(String name) {\r\n\t\tfor (Card card : cards) {\r\n\t\t\tif (name.equalsIgnoreCase(card.getName())) {\r\n\t\t\t\tCard newCard = card.copy();\r\n\t\t\t\tnewCard.assignNewId();\r\n\t\t\t\treturn newCard;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"da316cc345c9487683151cc9938b7ad09dae5d60","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tprotected void readLine(String line, DeckCardLists deckList) {\n\t\tif (line.length() == 0 || line.startsWith(\"//\")) return;\n\t\tboolean sideboard = false;\n\t\tif (line.startsWith(\"SB:\")) {\n\t\t\tline = line.substring(3).trim();\n\t\t\tsideboard = true;\n\t\t}\n\t\tint delim = line.indexOf(' ');\n\t\tString lineNum = line.substring(0, delim).trim();\n\t\tint setStart = line.indexOf('[') + 1;\n\t\tint setEnd = line.indexOf(']');\n\t\tString setCode = line.substring(setStart, setEnd).trim();\n\t\tString lineName = line.substring(setEnd + 1).trim();\n\t\ttry {\n\t\t\tint num = Integer.parseInt(lineNum);\n\t\t\tExpansionSet set = Sets.findSet(setCode);\n\t\t\tString cardName;\n\t\t\tif (set != null) {\n\t\t\t\tcardName = set.findCard(lineName).getClass().getCanonicalName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcardName = Sets.findCard(lineName).getClass().getCanonicalName();\n\t\t\t}\n\t\t\tif (cardName == null)\n\t\t\t\tsbMessage.append(\"Could not find card: '\").append(lineName).append(\"' at line \").append(lineCount).append(\"\\n\");\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\t\tif (!sideboard)\n\t\t\t\t\t\tdeckList.getCards().add(cardName);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeckList.getSideboard().add(cardName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException nfe) {\n\t\t\tsbMessage.append(\"Invalid number: \").append(lineNum).append(\" at line \").append(lineCount).append(\"\\n\");\n\t\t}\n\t}","id":98590,"modified_method":"@Override\n\tprotected void readLine(String line, DeckCardLists deckList) {\n\t\tif (line.length() == 0 || line.startsWith(\"//\")) return;\n\t\tboolean sideboard = false;\n\t\tif (line.startsWith(\"SB:\")) {\n\t\t\tline = line.substring(3).trim();\n\t\t\tsideboard = true;\n\t\t}\n\t\tint delim = line.indexOf(' ');\n\t\tString lineNum = line.substring(0, delim).trim();\n\t\tString setCode = \"\";\n\t\tif (line.indexOf('[') != -1 ) {\n\t\t\tint setStart = line.indexOf('[') + 1;\n\t\t\tint setEnd = line.indexOf(']');\n\t\t\tsetCode = line.substring(setStart, setEnd).trim();\n\t\t\tdelim = setEnd;\n\t\t}\n\t\tString lineName = line.substring(delim + 1).trim();\n\t\ttry {\n\t\t\tint num = Integer.parseInt(lineNum);\n\t\t\tExpansionSet set = null;\n\t\t\tif (setCode.length() > 0)\n\t\t\t\tset = Sets.findSet(setCode);\n\t\t\tCard card;\n\t\t\tif (set != null) {\n\t\t\t\tcard = set.findCard(lineName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcard = Sets.findCard(lineName);\n\t\t\t}\n\t\t\tif (card == null)\n\t\t\t\tsbMessage.append(\"Could not find card: '\").append(lineName).append(\"' at line \").append(lineCount).append(\"\\n\");\n\t\t\telse {\n\t\t\t\tString cardName = card.getClass().getCanonicalName();\n\t\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\t\tif (!sideboard)\n\t\t\t\t\t\tdeckList.getCards().add(cardName);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeckList.getSideboard().add(cardName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException nfe) {\n\t\t\tsbMessage.append(\"Invalid number: \").append(lineNum).append(\" at line \").append(lineCount).append(\"\\n\");\n\t\t}\n\t}","commit_id":"da316cc345c9487683151cc9938b7ad09dae5d60","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tprotected void readLine(String line, DeckCardLists deckList) {\n\t\tif (line.length() == 0 || line.startsWith(\"//\")) return;\n\t\tif (line.startsWith(\"Sideboard\")) {\n\t\t\tsideboard = true;\n\t\t\treturn;\n\t\t}\n\t\tint delim = line.indexOf(' ');\n\t\tString lineNum = line.substring(0, delim).trim();\n\t\tString lineName = line.substring(delim).trim();\n\t\ttry {\n\t\t\tint num = Integer.parseInt(lineNum);\n\t\t\tString cardName = Sets.findCard(lineName).getClass().getCanonicalName();\n\t\t\tif (cardName == null)\n\t\t\t\tsbMessage.append(\"Could not find card: '\").append(lineName).append(\"' at line \").append(lineCount).append(\"\\n\");\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\t\tif (!sideboard)\n\t\t\t\t\t\tdeckList.getCards().add(cardName);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeckList.getSideboard().add(cardName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException nfe) {\n\t\t\tsbMessage.append(\"Invalid number: \").append(lineNum).append(\" at line \").append(lineCount).append(\"\\n\");\n\t\t}\n\t}","id":98591,"modified_method":"@Override\n\tprotected void readLine(String line, DeckCardLists deckList) {\n\t\tif (line.length() == 0 || line.startsWith(\"//\")) return;\n\t\tif (line.startsWith(\"Sideboard\")) {\n\t\t\tsideboard = true;\n\t\t\treturn;\n\t\t}\n\t\tint delim = line.indexOf(' ');\n\t\tString lineNum = line.substring(0, delim).trim();\n\t\tString lineName = line.substring(delim).trim();\n\t\ttry {\n\t\t\tint num = Integer.parseInt(lineNum);\n\t\t\tCard card = Sets.findCard(lineName);\n\t\t\tif (card == null)\n\t\t\t\tsbMessage.append(\"Could not find card: '\").append(lineName).append(\"' at line \").append(lineCount).append(\"\\n\");\n\t\t\telse {\n\t\t\t\tString cardName = card.getClass().getCanonicalName();\n\t\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\t\tif (!sideboard)\n\t\t\t\t\t\tdeckList.getCards().add(cardName);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeckList.getSideboard().add(cardName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException nfe) {\n\t\t\tsbMessage.append(\"Invalid number: \").append(lineNum).append(\" at line \").append(lineCount).append(\"\\n\");\n\t\t}\n\t}","commit_id":"da316cc345c9487683151cc9938b7ad09dae5d60","url":"https://github.com/magefree/mage"},{"original_method":"@Nullable\n  private <Connection> RunContentDescriptor startSession(@NotNull Project project,\n                                                         @Nullable RunContentDescriptor contentToReuse,\n                                                         @NotNull ExecutionEnvironment env,\n                                                         @NotNull Executor executor,\n                                                         @NotNull JstdRunConfiguration runConfiguration) throws ExecutionException {\n    JstdDebugBrowserInfo<Connection> debugBrowserInfo = JstdDebugBrowserInfo.build(runConfiguration.getRunSettings());\n    if (debugBrowserInfo == null) {\n      throw new ExecutionException(\"Can not find a browser that supports debugging.\");\n    }\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    final JSDebugEngine<Connection> debugEngine = debugBrowserInfo.getDebugEngine();\n    if (!debugEngine.prepareDebugger(project)) return null;\n\n    final String url;\n    final Connection connection;\n    if (debugEngine instanceof ChromeDebuggerEngine) {\n      ChromeConnectionManager chromeConnectionManager = ChromeConnectionManager.getInstance();\n      ExistentTabProviderFactory tabProviderFactory = ExistentTabProviderFactory.getInstance();\n      //noinspection unchecked\n      connection = (Connection) chromeConnectionManager.createConnection(tabProviderFactory);\n      url = \"http://localhost:\" + JstdToolWindowPanel.serverPort + debugBrowserInfo.getCapturedBrowserUrl();\n    }\n    else {\n      connection = debugEngine.openConnection();\n      url = null;\n    }\n\n    JstdTestRunnerCommandLineState runState = runConfiguration.getState(env, null, true);\n    final ExecutionResult executionResult = runState.execute(executor, this);\n    debugBrowserInfo.fixIfChrome(executionResult.getProcessHandler());\n\n    File configFile = new File(runConfiguration.getRunSettings().getConfigFile());\n    List<RemoteJavaScriptDebugConfiguration.RemoteUrlMappingBean> mapping = extractMappings(configFile);\n\n    final DebuggableFileFinder fileFinder = new RemoteDebuggingFileFinder(project, mapping);\n\n    XDebuggerManager xDebuggerManager = XDebuggerManager.getInstance(project);\n    XDebugSession xDebugSession = xDebuggerManager.startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n      @NotNull\n      public XDebugProcess start(@NotNull final XDebugSession session) {\n        JSDebugProcess debugProcess = debugEngine.createDebugProcess(session, fileFinder, connection, url, executionResult);\n        return debugProcess;\n      }\n    });\n    PrintWriter writer = new PrintWriter(executionResult.getProcessHandler().getProcessInput());\n    writer.println(TestRunner.DEBUG_SESSION_STARTED + \"\\n\");\n    writer.flush();\n\n    return xDebugSession.getRunContentDescriptor();\n  }","id":98592,"modified_method":"@Nullable\n  private <Connection> RunContentDescriptor startSession(@NotNull Project project,\n                                                         @Nullable RunContentDescriptor contentToReuse,\n                                                         @NotNull ExecutionEnvironment env,\n                                                         @NotNull Executor executor,\n                                                         @NotNull JstdRunConfiguration runConfiguration) throws ExecutionException {\n    JstdDebugBrowserInfo<Connection> debugBrowserInfo = JstdDebugBrowserInfo.build(runConfiguration.getRunSettings());\n    if (debugBrowserInfo == null) {\n      throw new ExecutionException(\"Can not find a browser that supports debugging.\");\n    }\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    final JSDebugEngine<Connection> debugEngine = debugBrowserInfo.getDebugEngine();\n    if (!debugEngine.prepareDebugger(project)) return null;\n\n    final String url;\n    final Connection connection;\n    if (debugEngine instanceof ChromeDebuggerEngine) {\n      ChromeConnectionManager chromeConnectionManager = ChromeConnectionManager.getInstance();\n      ExistentTabProviderFactory tabProviderFactory = ExistentTabProviderFactory.getInstance();\n      //noinspection unchecked\n      connection = (Connection) chromeConnectionManager.createConnection(tabProviderFactory);\n      url = \"http://localhost:\" + JstdToolWindowPanel.serverPort + debugBrowserInfo.getCapturedBrowserUrl();\n    }\n    else {\n      connection = debugEngine.openConnection();\n      url = null;\n    }\n\n    JstdTestRunnerCommandLineState runState = runConfiguration.getState(env, null, true);\n    final ExecutionResult executionResult = runState.execute(executor, this);\n    debugBrowserInfo.fixIfChrome(executionResult.getProcessHandler());\n\n    File configFile = new File(runConfiguration.getRunSettings().getConfigFile());\n    final DebuggableFileFinder fileFinder = JstdDebuggableFileFinderProvider.createFileFinder(project, configFile);\n\n    XDebuggerManager xDebuggerManager = XDebuggerManager.getInstance(project);\n    XDebugSession xDebugSession = xDebuggerManager.startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n      @NotNull\n      public XDebugProcess start(@NotNull final XDebugSession session) {\n        JSDebugProcess debugProcess = debugEngine.createDebugProcess(session, fileFinder, connection, url, executionResult);\n        return debugProcess;\n      }\n    });\n    PrintWriter writer = new PrintWriter(executionResult.getProcessHandler().getProcessInput());\n    writer.println(TestRunner.DEBUG_SESSION_STARTED + \"\\n\");\n    writer.flush();\n\n    return xDebugSession.getRunContentDescriptor();\n  }","commit_id":"22db13be65e1cf36b78ed2d34df114f4664a0f39","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void refactorIt(PsiElement newElement) {\n      VirtualFile newFile = toVirtualFile(newElement);\n      if (newFile != null) {\n        String newPath = newFile.getPath();\n        JstdRunSettings.Builder settingsBuilder = new JstdRunSettings.Builder(myConfiguration.getRunSettings());\n        if (myIsConfigFile) {\n          settingsBuilder.setConfigFile(newPath);\n        }\n        if (myIsJsTestFile) {\n          settingsBuilder.setJSFilePath(newPath);\n        }\n        if (myIsAllInDirectory) {\n          settingsBuilder.setDirectory(newPath);\n        }\n        updateRunSettings(settingsBuilder.build());\n      }\n    }","id":98593,"modified_method":"private void refactorIt(PsiElement newElement) {\n      VirtualFile newFile = toVirtualFile(newElement);\n      if (newFile != null) {\n        String newPath = FileUtil.toSystemDependentName(newFile.getPath());\n        JstdRunSettings.Builder settingsBuilder = new JstdRunSettings.Builder(myConfiguration.getRunSettings());\n        if (myIsConfigFile) {\n          settingsBuilder.setConfigFile(newPath);\n        }\n        if (myIsJsTestFile) {\n          settingsBuilder.setJSFilePath(newPath);\n        }\n        if (myIsAllInDirectory) {\n          settingsBuilder.setDirectory(newPath);\n        }\n        updateRunSettings(settingsBuilder.build());\n      }\n    }","commit_id":"22db13be65e1cf36b78ed2d34df114f4664a0f39","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public static RefactoringElementListener getRefactoringElementListener(@NotNull JstdRunConfiguration configuration,\n                                                                         @Nullable PsiElement element) {\n    if (element == null) {\n      return null;\n    }\n    VirtualFile fileAtElement = toVirtualFile(element);\n    if (fileAtElement == null) {\n      return null;\n    }\n    JstdRunSettings settings = configuration.getRunSettings();\n    String path = fileAtElement.getPath();\n    if (settings.getTestType() == TestType.ALL_CONFIGS_IN_DIRECTORY) {\n      if (settings.getDirectory().equals(path)) {\n        return new FilePathRefactoringElementListener(configuration, false, false, true);\n      }\n    } else {\n      if (settings.getJsFilePath().equals(path)) {\n        return new FilePathRefactoringElementListener(configuration, false, true, false);\n      }\n      if (settings.getConfigFile().equals(path)) {\n        return new FilePathRefactoringElementListener(configuration, true, false, false);\n      }\n    }\n    return null;\n  }","id":98594,"modified_method":"@Nullable\n  public static RefactoringElementListener getRefactoringElementListener(@NotNull JstdRunConfiguration configuration,\n                                                                         @Nullable PsiElement element) {\n    if (element == null) {\n      return null;\n    }\n    VirtualFile fileAtElement = toVirtualFile(element);\n    if (fileAtElement == null) {\n      return null;\n    }\n    JstdRunSettings settings = configuration.getRunSettings();\n    String path = fileAtElement.getPath();\n    if (settings.getTestType() == TestType.ALL_CONFIGS_IN_DIRECTORY) {\n      String allInDirectory = FileUtil.toSystemIndependentName(settings.getDirectory());\n      if (allInDirectory.equals(path)) {\n        return new FilePathRefactoringElementListener(configuration, false, false, true);\n      }\n    } else {\n      String jsFilePath = FileUtil.toSystemIndependentName(settings.getJsFilePath());\n      if (jsFilePath.equals(path)) {\n        return new FilePathRefactoringElementListener(configuration, false, true, false);\n      }\n      String configFilePath = FileUtil.toSystemIndependentName(settings.getConfigFile());\n      if (configFilePath.equals(path)) {\n        return new FilePathRefactoringElementListener(configuration, true, false, false);\n      }\n    }\n    return null;\n  }","commit_id":"22db13be65e1cf36b78ed2d34df114f4664a0f39","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Constructor.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  public BaseXHTTP(final String... args) throws Exception {\n    parseArguments(args);\n\n    // create jetty instance and set default context to HTTP path\n    final MainProp mprop = context.mprop;\n    final String webapp = mprop.get(MainProp.WEBPATH);\n    final WebAppContext wac = new WebAppContext(webapp, \"/\");\n    jetty = (Server) new XmlConfiguration(initJetty(webapp).inputStream()).configure();\n    jetty.setHandler(wac);\n\n    // retrieve jetty port\n    for(final Connector c : jetty.getConnectors()) {\n      if(c instanceof SelectChannelConnector) {\n        if(httpPort == 0) httpPort = c.getPort();\n        else c.setPort(httpPort);\n      }\n    }\n\n    // stop server\n    if(stopped) {\n      stop();\n      Util.outln(HTTP + ' ' + SRV_STOPPED_PORT_X, httpPort);\n      // temporary console windows: keep the message visible for a while\n      Performance.sleep(1000);\n      return;\n    }\n\n    // start web server in a new process\n    if(service) {\n      start(httpPort, args);\n      Util.outln(HTTP + ' ' + SRV_STARTED_PORT_X, httpPort);\n      // temporary console windows: keep the message visible for a while\n      Performance.sleep(1000);\n      return;\n    }\n\n    // request password on command line if only the user was specified\n    if(!AProp.getSystem(MainProp.USER).isEmpty()) {\n      while(AProp.getSystem(MainProp.PASSWORD).isEmpty()) {\n        Util.out(PASSWORD + COLS);\n        AProp.setSystem(MainProp.PASSWORD, Util.password());\n      }\n    }\n\n    // start web server\n    jetty.start();\n    Util.outln(HTTP + ' ' + SRV_STARTED_PORT_X, httpPort);\n\n    // initialize web.xml settings, assign system properties and run database server\n    // if not done so already. this must be called after starting jetty\n    HTTPContext.init(wac.getServletContext());\n\n    // start daemon for stopping web server\n    final int stop = mprop.num(MainProp.STOPPORT);\n    if(stop >= 0) new StopServer(mprop.get(MainProp.SERVERHOST), stop).start();\n\n    // show info when HTTP server is aborted\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        Util.outln(HTTP + ' ' + SRV_STOPPED_PORT_X, httpPort);\n        final Log l = context.log;\n        if(l != null) l.writeServer(OK, HTTP + ' ' + SRV_STOPPED_PORT_X, httpPort);\n        context.close();\n      }\n    });\n\n    // log server start at very end (logging flag could have been updated by web.xml)\n    context.log.writeServer(OK, HTTP + ' ' + SRV_STARTED_PORT_X, httpPort);\n  }","id":98595,"modified_method":"/**\n   * Constructor.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  public BaseXHTTP(final String... args) throws Exception {\n    parseArguments(args);\n\n    // create jetty instance and set default context to HTTP path\n    final MainProp mprop = context.mprop;\n    final String webapp = mprop.get(MainProp.WEBPATH);\n    final WebAppContext wac = new WebAppContext(webapp, \"/\");\n    jetty = (Server) new XmlConfiguration(initJetty(webapp).inputStream()).configure();\n    jetty.setHandler(wac);\n\n    // set the first http port (can also be https) to the port provided by command line\n    if (httpPort != 0) {\n      for(final Connector c : jetty.getConnectors()) {\n        if(c instanceof SelectChannelConnector) {\n          c.setPort(httpPort);\n          break;\n        }\n      }\n    }\n\n    // stop server\n    if(stopped) {\n      stop();\n      for(final Connector c : jetty.getConnectors())\n        Util.outln(HTTP + ' ' + SRV_STOPPED_PORT_X, c.getPort());\n      // temporary console windows: keep the message visible for a while\n      Performance.sleep(1000);\n      return;\n    }\n\n    // start web server in a new process\n    if(service) {\n      Connector connector = jetty.getConnectors()[0];\n      start(connector.getPort(),\n          connector instanceof SslSelectChannelConnector ? true : false, args);\n\n      for(final Connector c : jetty.getConnectors())\n        Util.outln(HTTP + ' ' + SRV_STARTED_PORT_X, c.getPort());\n      // temporary console windows: keep the message visible for a while\n      Performance.sleep(1000);\n      return;\n    }\n\n    // request password on command line if only the user was specified\n    if(!AProp.getSystem(MainProp.USER).isEmpty()) {\n      while(AProp.getSystem(MainProp.PASSWORD).isEmpty()) {\n        Util.out(PASSWORD + COLS);\n        AProp.setSystem(MainProp.PASSWORD, Util.password());\n      }\n    }\n\n    // start web server\n    jetty.start();\n    for(final Connector c : jetty.getConnectors())\n      Util.outln(HTTP + ' ' + SRV_STARTED_PORT_X, c.getPort());\n\n    // initialize web.xml settings, assign system properties and run database server\n    // if not done so already. this must be called after starting jetty\n    HTTPContext.init(wac.getServletContext());\n\n    // start daemon for stopping web server\n    final int stop = mprop.num(MainProp.STOPPORT);\n    if(stop >= 0) new StopServer(mprop.get(MainProp.SERVERHOST), stop).start();\n\n    // show info when HTTP server is aborted\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        for(final Connector c : jetty.getConnectors())\n          Util.outln(HTTP + ' ' + SRV_STOPPED_PORT_X, c.getPort());\n        final Log l = context.log;\n        if(l != null) {\n          for(final Connector c : jetty.getConnectors())\n            l.writeServer(OK, HTTP + ' ' + SRV_STOPPED_PORT_X, c.getPort());\n        }\n        context.close();\n      }\n    });\n\n    // log server start at very end (logging flag could have been updated by web.xml)\n    for(final Connector c : jetty.getConnectors())\n      context.log.writeServer(OK, HTTP + ' ' + SRV_STARTED_PORT_X, c.getPort());\n  }","commit_id":"d4ed99f58132e83eac57c23a8826ae5dc6ba676e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks if a server is running.\n   * @param host host\n   * @param port server port\n   * @return boolean success\n   */\n  private static boolean ping(final String host, final int port) {\n    try {\n      // create connection\n      final URL url = new URL(\"http://\" + host + ':' + port);\n      url.openConnection().getInputStream();\n      return true;\n    } catch(final IOException ex) {\n      // if page is not found, server is running\n      return ex instanceof FileNotFoundException;\n    }\n  }","id":98596,"modified_method":"/**\n   * Checks if a server is running.\n   * @param host host\n   * @param port server port\n   * @param ssl encryption via HTTPS\n   * @return boolean success\n   */\n  private static boolean ping(final String host, final int port, final boolean ssl) {\n    try {\n      // create connection\n      final URL url = new URL((ssl ? \"https://\" : \"http://\") + host + ':' + port);\n      url.openConnection().getInputStream();\n      return true;\n    } catch(final IOException ex) {\n      // if page is not found, server is running\n      // if SSL handshake failed server is running, otherwise SSLException\n      return ex instanceof FileNotFoundException || ex instanceof SSLHandshakeException;\n    }\n  }","commit_id":"d4ed99f58132e83eac57c23a8826ae5dc6ba676e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Starts the HTTP server in a separate process.\n   * @param port server port\n   * @param args command-line arguments\n   * @throws BaseXException database exception\n   */\n  private static void start(final int port, final String... args) throws BaseXException {\n    Util.start(BaseXHTTP.class, args);\n    // try to connect to the new server instance\n    for(int c = 1; c < 10; ++c) {\n      if(ping(LOCALHOST, port)) return;\n      Performance.sleep(c * 100);\n    }\n    throw new BaseXException(CONNECTION_ERROR);\n  }","id":98597,"modified_method":"/**\n   * Starts the HTTP server in a separate process.\n   * @param port server port\n   * @param ssl encryption via HTTPS\n   * @param args command-line arguments\n   * @throws BaseXException database exception\n   */\n  private static void start(final int port, final boolean ssl, final String... args) throws BaseXException {\n    Util.start(BaseXHTTP.class, args);\n    // try to connect to the new server instance\n    for(int c = 1; c < 10; ++c) {\n      if(ping(LOCALHOST, port, ssl)) return;\n      Performance.sleep(c * 100);\n    }\n    throw new BaseXException(CONNECTION_ERROR);\n  }","commit_id":"d4ed99f58132e83eac57c23a8826ae5dc6ba676e","url":"https://github.com/BaseXdb/basex"},{"original_method":"public static void methodCall(SNode methodCall, final SNodeTextGen textGen) {\n    BaseLanguageTextGen.methodTypeArguments(methodCall, textGen);\n    textGen.append(textGen.getReferentPresentation(SNodeOperations.getReference(methodCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\")), false));\n    BaseLanguageTextGen.arguments(methodCall, textGen);\n  }","id":98598,"modified_method":"public static void methodCall(SNode methodCall, final SNodeTextGen textGen) {\n    BaseLanguageTextGen.methodTypeArguments(methodCall, textGen);\n    BaseLanguageTextGen.referenceToShortName(SNodeOperations.getReference(methodCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\")), textGen);\n    BaseLanguageTextGen.arguments(methodCall, textGen);\n  }","commit_id":"6bc055c463697d76871be17e3d964825cfde98ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, \"jetbrains.mps.baseLanguage.structure.SwitchCase\"))) {\n      this.append(this.getReferentPresentation(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, \"enumConstantDeclaration\")), false));\n    } else {\n      BaseLanguageTextGen.blClassifierRef(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, \"enumClass\")), this);\n      this.append(\".\");\n      this.append(this.getReferentPresentation(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, \"enumConstantDeclaration\")), false));\n    }\n  }","id":98599,"modified_method":"public void doGenerateText(SNode node) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, \"jetbrains.mps.baseLanguage.structure.SwitchCase\"))) {\n      BaseLanguageTextGen.referenceToShortName(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, \"enumConstantDeclaration\")), this);\n    } else {\n      BaseLanguageTextGen.blClassifierRef(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, \"enumClass\")), this);\n      this.append(\".\");\n      BaseLanguageTextGen.referenceToShortName(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, \"enumConstantDeclaration\")), this);\n    }\n  }","commit_id":"6bc055c463697d76871be17e3d964825cfde98ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, \"fieldDeclaration\")), false));\n  }","id":98600,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.referenceToShortName(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, \"fieldDeclaration\")), this);\n  }","commit_id":"6bc055c463697d76871be17e3d964825cfde98ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * @deprecated move to BaseLanguageTextGen (where it belongs), drop unused parameter\n   */\n  @ToRemove(version = 0)\n  @Deprecated\n  public String getReferentPresentation(SReference reference, boolean uniq) {\n    if (reference == null) {\n      foundError(\"null reference\");\n      return \"<err:null reference>\";\n    }\n\n    String shortName;\n    String packageName = null;\n    if (reference instanceof DynamicReference) {\n      shortName = ((DynamicReference) reference).getResolveInfo();\n      if (shortName.startsWith(\"[\")) {\n        // todo: hack, remove with [] removing\n        packageName = shortName.substring(1, shortName.lastIndexOf(\"]\")).trim();\n        shortName = shortName.substring(shortName.lastIndexOf(\"]\") + 1).trim();\n      } else {\n        final SModelReference modelReference = reference.getTargetSModelReference();\n        if (modelReference != null) {\n          packageName = SModelStereotype.withoutStereotype(modelReference.getModelName());\n        } else {\n          int lastDot = shortName.lastIndexOf('.');\n          if (lastDot >= 0) {\n            packageName = shortName.substring(0, lastDot);\n            shortName = shortName.substring(lastDot + 1);\n            if (shortName.indexOf('$') >= 0) {\n              shortName = shortName.replace('$', '.');\n            }\n          }\n        }\n      }\n    } else {\n      SNode targetNode = reference.getTargetNode();\n      if (targetNode == null) {\n        foundError(String.format(\"Unknown target for role %s\", reference.getRole()));\n        return \"???\";\n      }\n      shortName = jetbrains.mps.util.SNodeOperations.getResolveInfo(targetNode);\n      packageName = SModelStereotype.withoutStereotype(targetNode.getModel().getReference().getModelName());\n    }\n    if (uniq) {\n      // todo: uniq, wtf?\n//      old code: return (isNeedLongName(shortName, packageName) ? packageName + '.' + shortName : shortName);\n      return shortName;\n    } else {\n      return shortName;\n    }\n  }","id":98601,"modified_method":"/**\n   * @deprecated moved to BaseLanguageTextGen (where it belongs). Left for compatibility with existing generated\n   * textgen classes (those using $ref{} part, despite its vague contract)\n   */\n  @ToRemove(version = 3.3)\n  @Deprecated\n  public String getReferentPresentation(SReference reference, boolean uniq) {\n    if (reference == null) {\n      foundError(\"null reference\");\n      return \"<err:null reference>\";\n    }\n\n    String shortName;\n    String packageName = null;\n    if (reference instanceof DynamicReference) {\n      shortName = ((DynamicReference) reference).getResolveInfo();\n      if (shortName.startsWith(\"[\")) {\n        // todo: hack, remove with [] removing\n        packageName = shortName.substring(1, shortName.lastIndexOf(\"]\")).trim();\n        shortName = shortName.substring(shortName.lastIndexOf(\"]\") + 1).trim();\n      } else {\n        final SModelReference modelReference = reference.getTargetSModelReference();\n        if (modelReference != null) {\n          packageName = SModelStereotype.withoutStereotype(modelReference.getModelName());\n        } else {\n          int lastDot = shortName.lastIndexOf('.');\n          if (lastDot >= 0) {\n            packageName = shortName.substring(0, lastDot);\n            shortName = shortName.substring(lastDot + 1);\n            if (shortName.indexOf('$') >= 0) {\n              shortName = shortName.replace('$', '.');\n            }\n          }\n        }\n      }\n    } else {\n      SNode targetNode = reference.getTargetNode();\n      if (targetNode == null) {\n        foundError(String.format(\"Unknown target for role %s\", reference.getRole()));\n        return \"???\";\n      }\n      shortName = jetbrains.mps.util.SNodeOperations.getResolveInfo(targetNode);\n      packageName = SModelStereotype.withoutStereotype(targetNode.getModel().getReference().getModelName());\n    }\n    if (uniq) {\n      // todo: uniq, wtf?\n//      old code: return (isNeedLongName(shortName, packageName) ? packageName + '.' + shortName : shortName);\n      return shortName;\n    } else {\n      return shortName;\n    }\n  }","commit_id":"6bc055c463697d76871be17e3d964825cfde98ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public String getReferentPresentation(SReference reference) {\n    // todo: this method not working now\n    return getReferentPresentation(reference, true);\n  }","id":98602,"modified_method":"/**\n   * @deprecated has been deprecated for 2,5 years. Shall drop, finally?\n   */\n  @Deprecated\n  @ToRemove(version = 3.3)\n  public String getReferentPresentation(SReference reference) {\n    // todo: this method not working now\n    return getReferentPresentation(reference, true);\n  }","commit_id":"6bc055c463697d76871be17e3d964825cfde98ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.blClassifierRef(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, \"classifier\")), this);\n    this.append(\".\");\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\")), false));\n  }","id":98603,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.blClassifierRef(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, \"classifier\")), this);\n    this.append(\".\");\n    BaseLanguageTextGen.referenceToShortName(SNodeOperations.getReference(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\")), this);\n  }","commit_id":"6bc055c463697d76871be17e3d964825cfde98ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x102467229d8L, 0x1024673a581L, \"typeVariableDeclaration\")), false));\n  }","id":98604,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.referenceToShortName(SNodeOperations.getReference(node, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x102467229d8L, 0x1024673a581L, \"typeVariableDeclaration\")), this);\n  }","commit_id":"6bc055c463697d76871be17e3d964825cfde98ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Handle(\"rank\")\n    public void getRank(ProcedureRequest request, ProcedureResponder responder)\n      throws IOException, InterruptedException {\n\n      // Get the url from the query parameters.\n      byte[] url = request.getArgument(\"url\").getBytes(UTF8);\n      // Get the rank from the ranks dataset.\n      Double rank = ranks.read(url);\n\n      LOG.trace(\"Key: {}, Data: {}\", Arrays.toString(url), rank);\n\n      // Send response in JSON format.\n      responder.sendJson(String.valueOf(rank));\n    }","id":98605,"modified_method":"@Handle(\"rank\")\n    public void getRank(ProcedureRequest request, ProcedureResponder responder)\n      throws IOException, InterruptedException {\n\n      // Get the url from the query parameters.\n      String urlParam = \"\";\n      for (String key : request.getArguments().keySet()) {\n        if (key.equalsIgnoreCase(\"url\")) {\n          urlParam = request.getArgument(key);\n        }\n      }\n      if (urlParam.isEmpty()) {\n        responder.error(ProcedureResponse.Code.CLIENT_ERROR, \"URL must be given as argument\");\n      }\n      byte[] url = urlParam.getBytes(UTF8);\n\n      // Get the rank from the ranks dataset.\n      Double rank = ranks.read(url);\n      if (rank == null) {\n        responder.error(ProcedureResponse.Code.NOT_FOUND, \"No rank found for \" + urlParam);\n        return;\n      }\n\n      LOG.trace(\"Key: {}, Data: {}\", Arrays.toString(url), rank);\n\n      // Send response in JSON format.\n      responder.sendJson(String.valueOf(rank));\n    }","commit_id":"758f80ad0b763c81bb71541092a7a596423c2a58","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void run(SparkContext sc) {\n    LOG.info(\"Processing backlinkURLs data\");\n    JavaPairRDD<byte[], String> backlinkURLs = sc.readFromDataset(\"backlinkURLs\", byte[].class, String.class);\n    int iterationCount = getIterationCount(sc);\n\n    LOG.info(\"Grouping data by key\");\n    // Grouping backlinks by unique URL in key\n    JavaPairRDD<String, Iterable<String>> links =\n      backlinkURLs.values().mapToPair(new PairFunction<String, String, String>() {\n      @Override\n      public Tuple2<String, String> call(String s) {\n        String[] parts = SPACES.split(s);\n        return new Tuple2<String, String>(parts[0], parts[1]);\n      }\n    }).distinct().groupByKey().cache();\n\n    // Initialize default rank for each key URL\n    JavaPairRDD<String, Double> ranks = links.mapValues(new Function<Iterable<String>, Double>() {\n      @Override\n      public Double call(Iterable<String> rs) {\n        return 1.0;\n      }\n    });\n    // Calculates and updates URL ranks continuously using PageRank algorithm.\n    for (int current = 0; current < iterationCount; current++) {\n      LOG.debug(\"Processing data with PageRank algorithm. Iteration {}/{}\", current, (iterationCount - 1));\n      // Calculates URL contributions to the rank of other URLs.\n      JavaPairRDD<String, Double> contribs = links.join(ranks).values()\n        .flatMapToPair(new PairFlatMapFunction<Tuple2<Iterable<String>, Double>, String, Double>() {\n          @Override\n          public Iterable<Tuple2<String, Double>> call(Tuple2<Iterable<String>, Double> s) {\n            LOG.debug(\"Processing {} with rank {}\", s._1(), s._2());\n            int urlCount = Iterables.size(s._1());\n            List<Tuple2<String, Double>> results = new ArrayList<Tuple2<String, Double>>();\n            for (String n : s._1()) {\n              results.add(new Tuple2<String, Double>(n, s._2() / urlCount));\n            }\n            return results;\n          }\n        });\n      // Re-calculates URL ranks based on backlink contributions.\n      ranks = contribs.reduceByKey(new Sum()).mapValues(new Function<Double, Double>() {\n        @Override\n        public Double call(Double sum) {\n          return 0.15 + sum * 0.85;\n        }\n      });\n    }\n\n    LOG.info(\"Writing ranks data\");\n\n\n    JavaPairRDD<byte[], Double> ranksRaw = ranks.mapToPair(new PairFunction<Tuple2<String, Double>, byte[], Double>() {\n      @Override\n      public Tuple2<byte[], Double> call(Tuple2<String, Double> tuple) throws Exception {\n        LOG.debug(\"URL {} has rank {}\", Arrays.toString(tuple._1().getBytes(UTF8)), tuple._2());\n        return new Tuple2<byte[], Double>(tuple._1().getBytes(UTF8), tuple._2());\n      }\n    });\n\n    // Store calculated results in output Dataset.\n    // All calculated results are stored in one row.\n    // Each result, the calculated URL rank based on backlink contributions, is an entry of the row.\n    // The value of the entry is the URL rank.\n    sc.writeToDataset(ranksRaw, \"ranks\", byte[].class, Double.class);\n\n    LOG.info(\"Done!\");\n  }","id":98606,"modified_method":"@Override\n  public void run(SparkContext sc) {\n    LOG.info(\"Processing backlinkURLs data\");\n    JavaPairRDD<byte[], String> backlinkURLs = sc.readFromDataset(\"backlinkURLs\", byte[].class, String.class);\n    int iterationCount = getIterationCount(sc);\n\n    LOG.info(\"Grouping data by key\");\n    // Grouping backlinks by unique URL in key\n    JavaPairRDD<String, Iterable<String>> links =\n      backlinkURLs.values().mapToPair(new PairFunction<String, String, String>() {\n      @Override\n      public Tuple2<String, String> call(String s) {\n        String[] parts = SPACES.split(s);\n        return new Tuple2<String, String>(parts[0], parts[1]);\n      }\n    }).distinct().groupByKey().cache();\n\n    // Initialize default rank for each key URL\n    JavaPairRDD<String, Double> ranks = links.mapValues(new Function<Iterable<String>, Double>() {\n      @Override\n      public Double call(Iterable<String> rs) {\n        return 1.0;\n      }\n    });\n    // Calculates and updates URL ranks continuously using PageRank algorithm.\n    for (int current = 0; current < iterationCount; current++) {\n      LOG.debug(\"Processing data with PageRank algorithm. Iteration {}/{}\", current + 1, (iterationCount));\n      // Calculates URL contributions to the rank of other URLs.\n      JavaPairRDD<String, Double> contribs = links.join(ranks).values()\n        .flatMapToPair(new PairFlatMapFunction<Tuple2<Iterable<String>, Double>, String, Double>() {\n          @Override\n          public Iterable<Tuple2<String, Double>> call(Tuple2<Iterable<String>, Double> s) {\n            LOG.debug(\"Processing {} with rank {}\", s._1(), s._2());\n            int urlCount = Iterables.size(s._1());\n            List<Tuple2<String, Double>> results = new ArrayList<Tuple2<String, Double>>();\n            for (String n : s._1()) {\n              results.add(new Tuple2<String, Double>(n, s._2() / urlCount));\n            }\n            return results;\n          }\n        });\n      // Re-calculates URL ranks based on backlink contributions.\n      ranks = contribs.reduceByKey(new Sum()).mapValues(new Function<Double, Double>() {\n        @Override\n        public Double call(Double sum) {\n          return 0.15 + sum * 0.85;\n        }\n      });\n    }\n\n    LOG.info(\"Writing ranks data\");\n\n    JavaPairRDD<byte[], Double> ranksRaw = ranks.mapToPair(new PairFunction<Tuple2<String, Double>, byte[], Double>() {\n      @Override\n      public Tuple2<byte[], Double> call(Tuple2<String, Double> tuple) throws Exception {\n        LOG.debug(\"URL {} has rank {}\", Arrays.toString(tuple._1().getBytes(UTF8)), tuple._2());\n        return new Tuple2<byte[], Double>(tuple._1().getBytes(UTF8), tuple._2());\n      }\n    });\n\n    // Store calculated results in output Dataset.\n    // All calculated results are stored in one row.\n    // Each result, the calculated URL rank based on backlink contributions, is an entry of the row.\n    // The value of the entry is the URL rank.\n    sc.writeToDataset(ranksRaw, \"ranks\", byte[].class, Double.class);\n\n    LOG.info(\"Done!\");\n  }","commit_id":"758f80ad0b763c81bb71541092a7a596423c2a58","url":"https://github.com/caskdata/cdap"},{"original_method":"@Handle(\"rank\")\n    public void getRank(ProcedureRequest request, ProcedureResponder responder)\n      throws IOException, InterruptedException {\n\n      // Get the url from the query parameters.\n      byte[] url = request.getArgument(\"url\").getBytes(UTF8);\n      // Get the rank from the ranks dataset.\n      Double rank = ranks.read(url);\n\n      LOG.trace(\"Key: {}, Data: {}\", Arrays.toString(url), rank);\n\n      // Send response in JSON format.\n      responder.sendJson(String.valueOf(rank));\n    }","id":98607,"modified_method":"@Handle(\"rank\")\n    public void getRank(ProcedureRequest request, ProcedureResponder responder)\n      throws IOException, InterruptedException {\n\n      // Get the url from the query parameters.\n      String urlParam = \"\";\n      for (String key : request.getArguments().keySet()) {\n        if (key.equalsIgnoreCase(\"url\")) {\n          urlParam = request.getArgument(key);\n        }\n      }\n      if (urlParam.isEmpty()) {\n        responder.error(ProcedureResponse.Code.CLIENT_ERROR, \"URL must be given as argument\");\n      }\n      byte[] url = urlParam.getBytes(UTF8);\n\n      // Get the rank from the ranks dataset.\n      Double rank = ranks.read(url);\n      if (rank == null) {\n        responder.error(ProcedureResponse.Code.NOT_FOUND, \"No rank found for \" + urlParam);\n        return;\n      }\n\n      LOG.trace(\"Key: {}, Data: {}\", Arrays.toString(url), rank);\n\n      // Send response in JSON format.\n      responder.sendJson(String.valueOf(rank));\n    }","commit_id":"d9e1b476324cc7d14a41a44bdaf488749a3b7d01","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void run(SparkContext sc) {\n    LOG.info(\"Processing backlinkURLs data\");\n    JavaPairRDD<byte[], String> backlinkURLs = sc.readFromDataset(\"backlinkURLs\", byte[].class, String.class);\n    int iterationCount = getIterationCount(sc);\n\n    LOG.info(\"Grouping data by key\");\n    // Grouping backlinks by unique URL in key\n    JavaPairRDD<String, Iterable<String>> links =\n      backlinkURLs.values().mapToPair(new PairFunction<String, String, String>() {\n      @Override\n      public Tuple2<String, String> call(String s) {\n        String[] parts = SPACES.split(s);\n        return new Tuple2<String, String>(parts[0], parts[1]);\n      }\n    }).distinct().groupByKey().cache();\n\n    // Initialize default rank for each key URL\n    JavaPairRDD<String, Double> ranks = links.mapValues(new Function<Iterable<String>, Double>() {\n      @Override\n      public Double call(Iterable<String> rs) {\n        return 1.0;\n      }\n    });\n    // Calculates and updates URL ranks continuously using PageRank algorithm.\n    for (int current = 0; current < iterationCount; current++) {\n      LOG.debug(\"Processing data with PageRank algorithm. Iteration {}/{}\", current, (iterationCount - 1));\n      // Calculates URL contributions to the rank of other URLs.\n      JavaPairRDD<String, Double> contribs = links.join(ranks).values()\n        .flatMapToPair(new PairFlatMapFunction<Tuple2<Iterable<String>, Double>, String, Double>() {\n          @Override\n          public Iterable<Tuple2<String, Double>> call(Tuple2<Iterable<String>, Double> s) {\n            LOG.debug(\"Processing {} with rank {}\", s._1(), s._2());\n            int urlCount = Iterables.size(s._1());\n            List<Tuple2<String, Double>> results = new ArrayList<Tuple2<String, Double>>();\n            for (String n : s._1()) {\n              results.add(new Tuple2<String, Double>(n, s._2() / urlCount));\n            }\n            return results;\n          }\n        });\n      // Re-calculates URL ranks based on backlink contributions.\n      ranks = contribs.reduceByKey(new Sum()).mapValues(new Function<Double, Double>() {\n        @Override\n        public Double call(Double sum) {\n          return 0.15 + sum * 0.85;\n        }\n      });\n    }\n\n    LOG.info(\"Writing ranks data\");\n\n\n    JavaPairRDD<byte[], Double> ranksRaw = ranks.mapToPair(new PairFunction<Tuple2<String, Double>, byte[], Double>() {\n      @Override\n      public Tuple2<byte[], Double> call(Tuple2<String, Double> tuple) throws Exception {\n        LOG.debug(\"URL {} has rank {}\", Arrays.toString(tuple._1().getBytes(UTF8)), tuple._2());\n        return new Tuple2<byte[], Double>(tuple._1().getBytes(UTF8), tuple._2());\n      }\n    });\n\n    // Store calculated results in output Dataset.\n    // All calculated results are stored in one row.\n    // Each result, the calculated URL rank based on backlink contributions, is an entry of the row.\n    // The value of the entry is the URL rank.\n    sc.writeToDataset(ranksRaw, \"ranks\", byte[].class, Double.class);\n\n    LOG.info(\"Done!\");\n  }","id":98608,"modified_method":"@Override\n  public void run(SparkContext sc) {\n    LOG.info(\"Processing backlinkURLs data\");\n    JavaPairRDD<byte[], String> backlinkURLs = sc.readFromDataset(\"backlinkURLs\", byte[].class, String.class);\n    int iterationCount = getIterationCount(sc);\n\n    LOG.info(\"Grouping data by key\");\n    // Grouping backlinks by unique URL in key\n    JavaPairRDD<String, Iterable<String>> links =\n      backlinkURLs.values().mapToPair(new PairFunction<String, String, String>() {\n      @Override\n      public Tuple2<String, String> call(String s) {\n        String[] parts = SPACES.split(s);\n        return new Tuple2<String, String>(parts[0], parts[1]);\n      }\n    }).distinct().groupByKey().cache();\n\n    // Initialize default rank for each key URL\n    JavaPairRDD<String, Double> ranks = links.mapValues(new Function<Iterable<String>, Double>() {\n      @Override\n      public Double call(Iterable<String> rs) {\n        return 1.0;\n      }\n    });\n    // Calculates and updates URL ranks continuously using PageRank algorithm.\n    for (int current = 0; current < iterationCount; current++) {\n      LOG.debug(\"Processing data with PageRank algorithm. Iteration {}/{}\", current + 1, (iterationCount));\n      // Calculates URL contributions to the rank of other URLs.\n      JavaPairRDD<String, Double> contribs = links.join(ranks).values()\n        .flatMapToPair(new PairFlatMapFunction<Tuple2<Iterable<String>, Double>, String, Double>() {\n          @Override\n          public Iterable<Tuple2<String, Double>> call(Tuple2<Iterable<String>, Double> s) {\n            LOG.debug(\"Processing {} with rank {}\", s._1(), s._2());\n            int urlCount = Iterables.size(s._1());\n            List<Tuple2<String, Double>> results = new ArrayList<Tuple2<String, Double>>();\n            for (String n : s._1()) {\n              results.add(new Tuple2<String, Double>(n, s._2() / urlCount));\n            }\n            return results;\n          }\n        });\n      // Re-calculates URL ranks based on backlink contributions.\n      ranks = contribs.reduceByKey(new Sum()).mapValues(new Function<Double, Double>() {\n        @Override\n        public Double call(Double sum) {\n          return 0.15 + sum * 0.85;\n        }\n      });\n    }\n\n    LOG.info(\"Writing ranks data\");\n\n    JavaPairRDD<byte[], Double> ranksRaw = ranks.mapToPair(new PairFunction<Tuple2<String, Double>, byte[], Double>() {\n      @Override\n      public Tuple2<byte[], Double> call(Tuple2<String, Double> tuple) throws Exception {\n        LOG.debug(\"URL {} has rank {}\", Arrays.toString(tuple._1().getBytes(UTF8)), tuple._2());\n        return new Tuple2<byte[], Double>(tuple._1().getBytes(UTF8), tuple._2());\n      }\n    });\n\n    // Store calculated results in output Dataset.\n    // All calculated results are stored in one row.\n    // Each result, the calculated URL rank based on backlink contributions, is an entry of the row.\n    // The value of the entry is the URL rank.\n    sc.writeToDataset(ranksRaw, \"ranks\", byte[].class, Double.class);\n\n    LOG.info(\"Done!\");\n  }","commit_id":"d9e1b476324cc7d14a41a44bdaf488749a3b7d01","url":"https://github.com/caskdata/cdap"},{"original_method":"private String toString(String action, String arg, Service serv) {\n\t\tsynchronized(toStringLock) {\n\t\t\tif ((!action.equals(_lastAction)) ||\n\t\t\t    (!serv.equals(_lastService)) ||\n\t\t\t    _lastArgumentList == null) {\n\t\t\t\tAction getIP = serv.getAction(action);\n\t\t\t\tif(getIP == null || !getIP.postControlAction()) {\n\t\t\t\t\t_lastAction = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t_lastAction = action;\n\t\t\t\t_lastService = serv;\n\t\t\t\t_lastArgumentList = getIP.getOutputArgumentList();\n\t\t\t}\n\t\t\tString rv = _lastArgumentList.getArgument(arg).getValue();\n\t\t\treturn DataHelper.escapeHTML(rv);\n\t\t}\n\t}","id":98609,"modified_method":"private String toString(String action, String arg, Service serv) {\n\t\tsynchronized(toStringLock) {\n\t\t\tif ((!action.equals(_lastAction)) ||\n\t\t\t    (!serv.equals(_lastService)) ||\n\t\t\t    _lastArgumentList == null) {\n\t\t\t\tAction getIP = serv.getAction(action);\n\t\t\t\tif(getIP == null || !getIP.postControlAction()) {\n\t\t\t\t\t_lastAction = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t_lastAction = action;\n\t\t\t\t_lastService = serv;\n\t\t\t\t_lastArgumentList = getIP.getOutputArgumentList();\n\t\t\t}\n\t\t\tArgument a = _lastArgumentList.getArgument(arg);\n\t\t\tif (a == null)\n\t\t\t\treturn \"\";\n\t\t\tString rv = a.getValue();\n\t\t\treturn DataHelper.escapeHTML(rv);\n\t\t}\n\t}","commit_id":"2e3f5d0de9269523e86853ea3a6b0774bc4964ff","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * @return the reported downstream bit rate in bits per second. -1 if it's not available. Blocking.\n\t */\n\tprivate int getDownstreamMaxBitRate() {\n\t\tService service;\n\t\tsynchronized(lock) {\n\t\t\tif(!isNATPresent() || thinksWeAreDoubleNatted)\n\t\t\t\treturn -1;\n\t\t\tservice = _service;\n\t\t}\n\n\t\tAction getIP = service.getAction(\"GetLinkLayerMaxBitRates\");\n\t\tif(getIP == null || !getIP.postControlAction())\n\t\t\treturn -1;\n\n\t\ttry {\n\t\t    return Integer.parseInt(getIP.getOutputArgumentList().getArgument(\"NewDownstreamMaxBitRate\").getValue());\n\t\t} catch (NumberFormatException nfe) {\n\t\t    return -1;\n\t\t}\n\t}","id":98610,"modified_method":"/**\n\t * @return the reported downstream bit rate in bits per second. -1 if it's not available. Blocking.\n\t */\n\tprivate int getDownstreamMaxBitRate() {\n\t\tService service;\n\t\tsynchronized(lock) {\n\t\t\tif(!isNATPresent() || thinksWeAreDoubleNatted)\n\t\t\t\treturn -1;\n\t\t\tservice = _service;\n\t\t}\n\n\t\tAction getIP = service.getAction(\"GetLinkLayerMaxBitRates\");\n\t\tif(getIP == null || !getIP.postControlAction())\n\t\t\treturn -1;\n\n\t\tArgument a = getIP.getOutputArgumentList().getArgument(\"NewDownstreamMaxBitRate\");\n\t\tif (a == null)\n\t\t\treturn -1;\n\t\ttry {\n\t\t    return Integer.parseInt(a.getValue());\n\t\t} catch (NumberFormatException nfe) {\n\t\t    return -1;\n\t\t}\n\t}","commit_id":"0d5cf46625afee8678f3b78d26fa8d5840a5dd90","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * @return the reported upstream bit rate in bits per second. -1 if it's not available. Blocking.\n\t */\n\tprivate int getUpstreamMaxBitRate() {\n\t\tService service;\n\t\tsynchronized(lock) {\n\t\t\tif(!isNATPresent() || thinksWeAreDoubleNatted)\n\t\t\t\treturn -1;\n\t\t\tservice = _service;\n\t\t}\n\n\t\tAction getIP = service.getAction(\"GetLinkLayerMaxBitRates\");\n\t\tif(getIP == null || !getIP.postControlAction())\n\t\t\treturn -1;\n\n\t\ttry {\n\t\t    return Integer.parseInt(getIP.getOutputArgumentList().getArgument(\"NewUpstreamMaxBitRate\").getValue());\n\t\t} catch (NumberFormatException nfe) {\n\t\t    return -1;\n\t\t}\n\t}","id":98611,"modified_method":"/**\n\t * @return the reported upstream bit rate in bits per second. -1 if it's not available. Blocking.\n\t */\n\tprivate int getUpstreamMaxBitRate() {\n\t\tService service;\n\t\tsynchronized(lock) {\n\t\t\tif(!isNATPresent() || thinksWeAreDoubleNatted)\n\t\t\t\treturn -1;\n\t\t\tservice = _service;\n\t\t}\n\n\t\tAction getIP = service.getAction(\"GetLinkLayerMaxBitRates\");\n\t\tif(getIP == null || !getIP.postControlAction())\n\t\t\treturn -1;\n\n\t\tArgument a = getIP.getOutputArgumentList().getArgument(\"NewUpstreamMaxBitRate\");\n\t\tif (a == null)\n\t\t\treturn -1;\n\t\ttry {\n\t\t    return Integer.parseInt(a.getValue());\n\t\t} catch (NumberFormatException nfe) {\n\t\t    return -1;\n\t\t}\n\t}","commit_id":"0d5cf46625afee8678f3b78d26fa8d5840a5dd90","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * @return the external address the NAT thinks we have.  Blocking.\n\t * null if we can't find it.\n\t */\n\tprivate String getNATAddress() {\n\t\tService service;\n\t\tsynchronized(lock) {\n\t\t\tif(!isNATPresent())\n\t\t\t\treturn null;\n\t\t\tservice = _service;\n\t\t}\n\n\t\tAction getIP = service.getAction(\"GetExternalIPAddress\");\n\t\tif(getIP == null || !getIP.postControlAction())\n\t\t\treturn null;\n\n\t\tString rv = (getIP.getOutputArgumentList().getArgument(\"NewExternalIPAddress\")).getValue();\n\t\t// I2P some devices return 0.0.0.0 when not connected\n\t\tif (\"0.0.0.0\".equals(rv) || rv == null || rv.length() <= 0)\n\t\t\treturn null;\n\t\treturn rv;\n\t}","id":98612,"modified_method":"/**\n\t * @return the external address the NAT thinks we have.  Blocking.\n\t * null if we can't find it.\n\t */\n\tprivate String getNATAddress() {\n\t\tService service;\n\t\tsynchronized(lock) {\n\t\t\tif(!isNATPresent())\n\t\t\t\treturn null;\n\t\t\tservice = _service;\n\t\t}\n\n\t\tAction getIP = service.getAction(\"GetExternalIPAddress\");\n\t\tif(getIP == null || !getIP.postControlAction())\n\t\t\treturn null;\n\n\t\tArgument a = getIP.getOutputArgumentList().getArgument(\"NewExternalIPAddress\");\n\t\tif (a == null)\n\t\t\treturn null;\n\t\tString rv = a.getValue();\n\t\t// I2P some devices return 0.0.0.0 when not connected\n\t\tif (\"0.0.0.0\".equals(rv) || rv == null || rv.length() <= 0)\n\t\t\treturn null;\n\t\treturn rv;\n\t}","commit_id":"0d5cf46625afee8678f3b78d26fa8d5840a5dd90","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Activate\n\tprotected void activate(BundleContext bundleContext) {\n\t\t_bundleContext = bundleContext;\n\n\t\tDestinationConfiguration pushNotificationDestinationConfiguration =\n\t\t\tnew DestinationConfiguration(\n\t\t\t\tDestinationConfiguration.DESTINATION_TYPE_SERIAL,\n\t\t\t\tDestinationNames.PUSH_NOTIFICATION);\n\n\t\tregisterDestination(pushNotificationDestinationConfiguration);\n\n\t\tDestinationConfiguration\n\t\t\tpushNotificationResponseDestinationConfiguration =\n\t\t\t\tnew DestinationConfiguration(\n\t\t\t\t\tDestinationConfiguration.DESTINATION_TYPE_SERIAL,\n\t\t\t\t\tDestinationNames.PUSH_NOTIFICATION_RESPONSE);\n\n\t\tregisterDestination(pushNotificationResponseDestinationConfiguration);\n\t}","id":98613,"modified_method":"@Activate\n\tprotected void activate(BundleContext bundleContext) {\n\t\t_bundleContext = bundleContext;\n\n\t\tDestinationConfiguration pushNotificationDestinationConfiguration =\n\t\t\tnew DestinationConfiguration(\n\t\t\t\tDestinationConfiguration.DESTINATION_TYPE_SERIAL,\n\t\t\t\tDestinationNames.PUSH_NOTIFICATION);\n\n\t\tDestination pushNotificationDestination = registerDestination(\n\t\t\tpushNotificationDestinationConfiguration);\n\n\t\tMessageListener pushNotificationsMessageListener =\n\t\t\tnew PushNotificationsMessageListener(\n\t\t\t\t_pushNotificationsDeviceLocalService);\n\n\t\tpushNotificationDestination.register(pushNotificationsMessageListener);\n\n\t\tDestinationConfiguration\n\t\t\tpushNotificationResponseDestinationConfiguration =\n\t\t\t\tnew DestinationConfiguration(\n\t\t\t\t\tDestinationConfiguration.DESTINATION_TYPE_SERIAL,\n\t\t\t\t\tDestinationNames.PUSH_NOTIFICATION_RESPONSE);\n\n\t\tDestination pushNotificationResponseDestination = registerDestination(\n\t\t\tpushNotificationResponseDestinationConfiguration);\n\n\t\tMessageListener pushNotificationsResponseMessageListener =\n\t\t\tnew PushNotificationsResponseMessageListener(_jsonFactory);\n\n\t\tpushNotificationResponseDestination.register(\n\t\t\tpushNotificationsResponseMessageListener);\n\t}","commit_id":"9d51f9d58ce0c8bee8049d918a2a31898cb53e2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public int print(Graphics g, PageFormat pageFormat, int pageIndex) throws PrinterException {\n    if (myProgress.isCanceled()) {\n      return Printable.NO_SUCH_PAGE;\n    }\n    while (myFileIndex < myFilesList.size()) {\n      if (myTextPainter == null) {\n        Pair<PsiFile, Editor> pair = myFilesList.get(myFileIndex);\n        myTextPainter = PrintManager.initTextPainter(pair.first, pair.second);\n      }\n      if (myTextPainter != null) {\n        ((TextPainter)myTextPainter).setProgress(myProgress);\n\n        int ret = 0;\n        try {\n          ret = myTextPainter.print(g, pageFormat, pageIndex - myStartPageIndex);\n        }\n        catch (ProcessCanceledException ignored) { }\n\n        if (myProgress.isCanceled()) {\n          return Printable.NO_SUCH_PAGE;\n        }\n        if (ret == Printable.PAGE_EXISTS) {\n          return Printable.PAGE_EXISTS;\n        }\n        myTextPainter = null;\n        myStartPageIndex = pageIndex;\n      }\n      myFileIndex++;\n    }\n    return Printable.NO_SUCH_PAGE;\n  }","id":98614,"modified_method":"@Override\n  public int print(Graphics g, PageFormat pageFormat, int pageIndex) throws PrinterException {\n    if (myProgress.isCanceled()) {\n      return Printable.NO_SUCH_PAGE;\n    }\n    while (myFileIndex < myFilesList.size()) {\n      if (myTextPainter == null) {\n        Pair<PsiFile, Editor> pair = myFilesList.get(myFileIndex);\n        myTextPainter = PrintManager.initTextPainter(pair.first, pair.second);\n      }\n      if (myTextPainter != null) {\n        myTextPainter.setProgress(myProgress);\n\n        int ret = 0;\n        try {\n          ret = myTextPainter.print(g, pageFormat, pageIndex - myStartPageIndex);\n        }\n        catch (ProcessCanceledException ignored) { }\n\n        if (myProgress.isCanceled()) {\n          return Printable.NO_SUCH_PAGE;\n        }\n        if (ret == Printable.PAGE_EXISTS) {\n          return Printable.PAGE_EXISTS;\n        }\n        myTextPainter.dispose();\n        myTextPainter = null;\n        myStartPageIndex = pageIndex;\n      }\n      myFileIndex++;\n    }\n    return Printable.NO_SUCH_PAGE;\n  }","commit_id":"d774199cdf711c078f306a15a2b112f0356efb81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void executePrint(DataContext dataContext) {\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return;\n\n    PsiDirectory[] psiDirectory = new PsiDirectory[1];\n    PsiElement psiElement = CommonDataKeys.PSI_ELEMENT.getData(dataContext);\n    if (psiElement instanceof PsiDirectory) {\n      psiDirectory[0] = (PsiDirectory)psiElement;\n    }\n\n    PsiFile psiFile = CommonDataKeys.PSI_FILE.getData(dataContext);\n    String[] shortFileName = new String[1];\n    String[] directoryName = new String[1];\n    if (psiFile != null || psiDirectory[0] != null) {\n      if (psiFile != null) {\n        shortFileName[0] = psiFile.getName();\n        if (psiDirectory[0] == null) {\n          psiDirectory[0] = psiFile.getContainingDirectory();\n        }\n      }\n      if (psiDirectory[0] != null) {\n        directoryName[0] = psiDirectory[0].getVirtualFile().getPresentableUrl();\n      }\n    }\n\n    Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n    String text = null;\n    if (editor != null) {\n      if (editor.getSelectionModel().hasSelection()) {\n        text = CodeEditorBundle.message(\"print.selected.text.radio\");\n      }\n      else {\n        text = psiFile == null ? \"Console text\" : null;\n      }\n    }\n\n    PrintDialog printDialog = new PrintDialog(shortFileName[0], directoryName[0], text, project);\n    printDialog.reset();\n    printDialog.show();\n    if (!printDialog.isOK()) {\n      return;\n    }\n    printDialog.apply();\n\n    final PageFormat pageFormat = createPageFormat();\n    final BasePainter painter;\n\n    PrintSettings printSettings = PrintSettings.getInstance();\n    if (printSettings.getPrintScope() != PrintSettings.PRINT_DIRECTORY) {\n      if (psiFile == null && editor == null) return;\n      TextPainter textPainter = psiFile != null ? initTextPainter(psiFile, editor) : initTextPainter((DocumentEx)editor.getDocument(), project);\n      if (textPainter == null) return;\n\n      if (printSettings.getPrintScope() == PrintSettings.PRINT_SELECTED_TEXT &&\n          editor != null &&\n          editor.getSelectionModel().hasSelection()) {\n        int firstLine = editor.getDocument().getLineNumber(editor.getSelectionModel().getSelectionStart());\n        textPainter.setSegment(editor.getSelectionModel().getSelectionStart(), editor.getSelectionModel().getSelectionEnd(), firstLine + 1);\n      }\n      painter = textPainter;\n    }\n    else {\n      List<Pair<PsiFile, Editor>> filesList = ContainerUtil.newArrayList();\n      boolean isRecursive = printSettings.isIncludeSubdirectories();\n      addToPsiFileList(psiDirectory[0], filesList, isRecursive);\n      painter = new MultiFilePainter(filesList);\n    }\n\n    Pageable document = new Pageable() {\n      @Override\n      public int getNumberOfPages() {\n        return Pageable.UNKNOWN_NUMBER_OF_PAGES;\n      }\n\n      @Override\n      public PageFormat getPageFormat(int pageIndex) throws IndexOutOfBoundsException {\n        return pageFormat;\n      }\n\n      @Override\n      public Printable getPrintable(int pageIndex) throws IndexOutOfBoundsException {\n        return painter;\n      }\n    };\n\n    final PrinterJob printerJob = PrinterJob.getPrinterJob();\n    try {\n      printerJob.setPageable(document);\n      printerJob.setPrintable(painter, pageFormat);\n      if (!printerJob.printDialog()) {\n        return;\n      }\n    }\n    catch (Exception e) {\n      LOG.warn(e);\n    }\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    ProgressManager.getInstance()\n      .run(new Task.Backgroundable(project, CodeEditorBundle.message(\"print.progress\"), true, PerformInBackgroundOption.ALWAYS_BACKGROUND) {\n        @Override\n        public void run(@NotNull ProgressIndicator indicator) {\n          try {\n            painter.setProgress(indicator);\n            printerJob.print();\n          }\n          catch (ProcessCanceledException e) {\n            LOG.info(\"Cancelled\");\n            printerJob.cancel();\n          }\n          catch (PrinterException e) {\n            Notifications.Bus.notify(new Notification(\"Print\", CommonBundle.getErrorTitle(), e.getMessage(), NotificationType.ERROR));\n            LOG.warn(e);\n          }\n          catch (Exception e) {\n            LOG.error(e);\n          }\n        }\n      });\n  }","id":98615,"modified_method":"public static void executePrint(DataContext dataContext) {\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return;\n\n    PsiDirectory[] psiDirectory = new PsiDirectory[1];\n    PsiElement psiElement = CommonDataKeys.PSI_ELEMENT.getData(dataContext);\n    if (psiElement instanceof PsiDirectory) {\n      psiDirectory[0] = (PsiDirectory)psiElement;\n    }\n\n    PsiFile psiFile = CommonDataKeys.PSI_FILE.getData(dataContext);\n    String[] shortFileName = new String[1];\n    String[] directoryName = new String[1];\n    if (psiFile != null || psiDirectory[0] != null) {\n      if (psiFile != null) {\n        shortFileName[0] = psiFile.getName();\n        if (psiDirectory[0] == null) {\n          psiDirectory[0] = psiFile.getContainingDirectory();\n        }\n      }\n      if (psiDirectory[0] != null) {\n        directoryName[0] = psiDirectory[0].getVirtualFile().getPresentableUrl();\n      }\n    }\n\n    Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n    String text = null;\n    if (editor != null) {\n      if (editor.getSelectionModel().hasSelection()) {\n        text = CodeEditorBundle.message(\"print.selected.text.radio\");\n      }\n      else {\n        text = psiFile == null ? \"Console text\" : null;\n      }\n    }\n\n    PrintDialog printDialog = new PrintDialog(shortFileName[0], directoryName[0], text, project);\n    printDialog.reset();\n    printDialog.show();\n    if (!printDialog.isOK()) {\n      return;\n    }\n    printDialog.apply();\n\n    final PageFormat pageFormat = createPageFormat();\n    final BasePainter painter;\n\n    PrintSettings printSettings = PrintSettings.getInstance();\n    if (printSettings.getPrintScope() != PrintSettings.PRINT_DIRECTORY) {\n      if (psiFile == null && editor == null) return;\n      TextPainter textPainter = psiFile != null ? initTextPainter(psiFile, editor) : initTextPainter((DocumentEx)editor.getDocument(), project);\n      if (textPainter == null) return;\n\n      if (printSettings.getPrintScope() == PrintSettings.PRINT_SELECTED_TEXT &&\n          editor != null &&\n          editor.getSelectionModel().hasSelection()) {\n        textPainter.setSegment(editor.getSelectionModel().getSelectionStart(), editor.getSelectionModel().getSelectionEnd());\n      }\n      painter = textPainter;\n    }\n    else {\n      List<Pair<PsiFile, Editor>> filesList = ContainerUtil.newArrayList();\n      boolean isRecursive = printSettings.isIncludeSubdirectories();\n      addToPsiFileList(psiDirectory[0], filesList, isRecursive);\n      painter = new MultiFilePainter(filesList);\n    }\n\n    Pageable document = new Pageable() {\n      @Override\n      public int getNumberOfPages() {\n        return Pageable.UNKNOWN_NUMBER_OF_PAGES;\n      }\n\n      @Override\n      public PageFormat getPageFormat(int pageIndex) throws IndexOutOfBoundsException {\n        return pageFormat;\n      }\n\n      @Override\n      public Printable getPrintable(int pageIndex) throws IndexOutOfBoundsException {\n        return painter;\n      }\n    };\n\n    final PrinterJob printerJob = PrinterJob.getPrinterJob();\n    try {\n      printerJob.setPageable(document);\n      printerJob.setPrintable(painter, pageFormat);\n      if (!printerJob.printDialog()) {\n        return;\n      }\n    }\n    catch (Exception e) {\n      LOG.warn(e);\n    }\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    ProgressManager.getInstance()\n      .run(new Task.Backgroundable(project, CodeEditorBundle.message(\"print.progress\"), true, PerformInBackgroundOption.ALWAYS_BACKGROUND) {\n        @Override\n        public void run(@NotNull ProgressIndicator indicator) {\n          try {\n            painter.setProgress(indicator);\n            printerJob.print();\n          }\n          catch (ProcessCanceledException e) {\n            LOG.info(\"Cancelled\");\n            printerJob.cancel();\n          }\n          catch (PrinterException e) {\n            Notifications.Bus.notify(new Notification(\"Print\", CommonBundle.getErrorTitle(), e.getMessage(), NotificationType.ERROR));\n            LOG.warn(e);\n          }\n          catch (Exception e) {\n            LOG.error(e);\n          }\n          finally {\n            painter.dispose();\n          }\n        }\n      });\n  }","commit_id":"d774199cdf711c078f306a15a2b112f0356efb81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TextPainter(DocumentEx editorDocument,\n                     EditorHighlighter highlighter,\n                     String fileName,\n                     Project project,\n                     FileType fileType,\n                     List<LineMarkerInfo> separators) {\n    myCodeStyleSettings = CodeStyleSettingsManager.getSettings(project);\n    myDocument = editorDocument;\n    myPrintSettings = PrintSettings.getInstance();\n    String fontName = myPrintSettings.FONT_NAME;\n    int fontSize = myPrintSettings.FONT_SIZE;\n    myPlainFont = new Font(fontName, Font.PLAIN, fontSize);\n    myBoldFont = new Font(fontName, Font.BOLD, fontSize);\n    myItalicFont = new Font(fontName, Font.ITALIC, fontSize);\n    myBoldItalicFont = new Font(fontName, Font.BOLD | Font.ITALIC, fontSize);\n    myHighlighter = highlighter;\n    myHeaderFont = new Font(myPrintSettings.FOOTER_HEADER_FONT_NAME, Font.PLAIN, myPrintSettings.FOOTER_HEADER_FONT_SIZE);\n    myFileName = fileName;\n    mySegmentEnd = myDocument.getTextLength();\n    myFileType = fileType;\n    myMethodSeparators = separators != null ? separators.toArray(new LineMarkerInfo[separators.size()]) : new LineMarkerInfo[0];\n    myCurrentMethodSeparator = 0;\n  }","id":98616,"modified_method":"public TextPainter(@NotNull DocumentEx editorDocument,\n                     EditorHighlighter highlighter,\n                     String fileName,\n                     Project project,\n                     FileType fileType,\n                     List<LineMarkerInfo> separators) {\n    myCodeStyleSettings = CodeStyleSettingsManager.getSettings(project);\n    myDocument = editorDocument;\n    myPrintSettings = PrintSettings.getInstance();\n    String fontName = myPrintSettings.FONT_NAME;\n    int fontSize = myPrintSettings.FONT_SIZE;\n    myPlainFont = new Font(fontName, Font.PLAIN, fontSize);\n    myBoldFont = new Font(fontName, Font.BOLD, fontSize);\n    myItalicFont = new Font(fontName, Font.ITALIC, fontSize);\n    myBoldItalicFont = new Font(fontName, Font.BOLD | Font.ITALIC, fontSize);\n    myHighlighter = highlighter;\n    myHeaderFont = new Font(myPrintSettings.FOOTER_HEADER_FONT_NAME, Font.PLAIN, myPrintSettings.FOOTER_HEADER_FONT_SIZE);\n    myFileName = fileName;\n    myRangeToPrint = editorDocument.createRangeMarker(0, myDocument.getTextLength());\n    myFileType = fileType;\n    myMethodSeparators = separators != null ? separators.toArray(new LineMarkerInfo[separators.size()]) : new LineMarkerInfo[0];\n    myCurrentMethodSeparator = 0;\n  }","commit_id":"d774199cdf711c078f306a15a2b112f0356efb81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int print(final Graphics g, final PageFormat pageFormat, final int pageIndex) throws PrinterException {\n    if (myOffset >= mySegmentEnd || myProgress.isCanceled()) {\n      return Printable.NO_SUCH_PAGE;\n    }\n    isPrintingPass = !isPrintingPass;\n    if (!isPrintingPass) {\n      return Printable.PAGE_EXISTS;\n    }\n\n    myProgress.setText(CodeEditorBundle.message(\"print.file.page.progress\", myFileName, (pageIndex + 1)));\n\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        myPageIndex = pageIndex;\n        Graphics2D g2D = (Graphics2D) g;\n        Rectangle2D.Double clip = new Rectangle2D.Double(pageFormat.getImageableX(), pageFormat.getImageableY(),\n                                                         pageFormat.getImageableWidth(),\n                                                         pageFormat.getImageableHeight());\n\n        double headerHeight = drawHeader(g2D, clip);\n        clip.y += headerHeight;\n        clip.height -= headerHeight;\n        double footerHeight = drawFooter(g2D, clip);\n        clip.height -= footerHeight;\n\n        Rectangle2D.Double border = (Rectangle2D.Double) clip.clone();\n        clip.x += getCharWidth(g2D) / 2;\n        clip.width -= getCharWidth(g2D);\n        if (myPrintSettings.PRINT_LINE_NUMBERS) {\n          double numbersStripWidth = calcNumbersStripWidth(g2D, clip) + getCharWidth(g2D) / 2;\n          clip.x += numbersStripWidth;\n          clip.width -= numbersStripWidth;\n        }\n        clip.x += getCharWidth(g2D) / 2;\n        clip.width -= getCharWidth(g2D);\n        drawText(g2D, clip);\n        drawBorder(g2D, border);\n      }\n    });\n\n    return Printable.PAGE_EXISTS;\n  }","id":98617,"modified_method":"@Override\n  public int print(final Graphics g, final PageFormat pageFormat, final int pageIndex) throws PrinterException {\n    return ApplicationManager.getApplication().runReadAction(new Computable<Integer>() {\n      @Override\n      public Integer compute() {\n        if (myProgress.isCanceled() || myRangeToPrint == null || !myRangeToPrint.isValid()) {\n          return NO_SUCH_PAGE;\n        }\n        int startOffset = myRangeToPrint.getStartOffset();\n        myOffset = startOffset;\n        mySegmentEnd = myRangeToPrint.getEndOffset();\n        myLineNumber = myDocument.getLineNumber(myOffset) + 1;\n\n        if (myOffset >= mySegmentEnd) {\n          return NO_SUCH_PAGE;\n        }\n        isPrintingPass = !isPrintingPass;\n        if (!isPrintingPass) {\n          return PAGE_EXISTS;\n        }\n\n        myProgress.setText(CodeEditorBundle.message(\"print.file.page.progress\", myFileName, (pageIndex + 1)));\n        myPageIndex = pageIndex;\n        Graphics2D g2D = (Graphics2D) g;\n        Rectangle2D.Double clip = new Rectangle2D.Double(pageFormat.getImageableX(), pageFormat.getImageableY(),\n                                                         pageFormat.getImageableWidth(),\n                                                         pageFormat.getImageableHeight());\n\n        draw(g2D, clip);\n\n        myRangeToPrint.dispose();\n        // stop printing if there was no progress (to avoid an infinite loop) or if the whole range was processed\n        myRangeToPrint = myOffset > startOffset && myOffset < mySegmentEnd ? myDocument.createRangeMarker(myOffset, mySegmentEnd) : null;\n        return PAGE_EXISTS;\n      }\n    });\n  }","commit_id":"d774199cdf711c078f306a15a2b112f0356efb81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setSegment(int segmentStart, int segmentEnd, int firstLineNumber) {\n    myOffset = segmentStart;\n    mySegmentEnd = segmentEnd;\n    myLineNumber = firstLineNumber;\n  }","id":98618,"modified_method":"public void setSegment(int segmentStart, int segmentEnd) {\n    if (myRangeToPrint != null) {\n      myRangeToPrint.dispose();\n    }\n    myRangeToPrint = myDocument.createRangeMarker(segmentStart, segmentEnd);\n  }","commit_id":"d774199cdf711c078f306a15a2b112f0356efb81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** read access required */\n  private void findMPSClasses(String qname, Consumer<SNode> consumer, GlobalSearchScope scope) {\n    final FileBasedIndexImpl fileBasedIndex = (FileBasedIndexImpl) FileBasedIndex.getInstance();\n    List<Collection<SNodeDescriptor>> values = fileBasedIndex.getValues(MPSFQNameJavaClassIndex.ID, qname, scope);\n    collectNodes(consumer, values);\n  }","id":98619,"modified_method":"/** read access required */\n  private void findMPSClasses(String qname, Consumer<SNode> consumer, GlobalSearchScope scope) {\n    final FileBasedIndex fileBasedIndex = FileBasedIndex.getInstance();\n    List<Collection<SNodeDescriptor>> values = fileBasedIndex.getValues(MPSFQNameJavaClassIndex.ID, qname, scope);\n    collectNodes(consumer, values);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"/** read access required */\n  private void findMPSClasses(PsiPackage psiPackage, Consumer<SNode> consumer, GlobalSearchScope scope) {\n    final FileBasedIndexImpl fileBasedIndex = (FileBasedIndexImpl) FileBasedIndex.getInstance();\n    String key = psiPackage.getQualifiedName();\n    List<Collection<SNodeDescriptor>> values = fileBasedIndex.getValues(MPSJavaPackageIndex.ID, key, scope);\n    collectNodes(consumer, values);\n  }","id":98620,"modified_method":"/** read access required */\n  private void findMPSClasses(PsiPackage psiPackage, Consumer<SNode> consumer, GlobalSearchScope scope) {\n    final FileBasedIndex fileBasedIndex = FileBasedIndex.getInstance();\n    String key = psiPackage.getQualifiedName();\n    List<Collection<SNodeDescriptor>> values = fileBasedIndex.getValues(MPSJavaPackageIndex.ID, key, scope);\n    collectNodes(consumer, values);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void getAllFieldNames(@NotNull HashSet<String> set) {\n    // TODO implement\n  }","id":98621,"modified_method":"@Override\n  public void getAllFieldNames(@NotNull HashSet<String> set) {\n    FileBasedIndex.getInstance().processAllKeys(MPSJavaFieldIndex.ID, new CommonProcessors.CollectProcessor<String>(set), myProject);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public PsiField[] getFieldsByName(@NotNull @NonNls String name, @NotNull GlobalSearchScope scope) {\n    // TODO implement\n    return new PsiField[0];\n  }","id":98622,"modified_method":"@NotNull\n  @Override\n  public PsiField[] getFieldsByName(@NotNull @NonNls final String name, @NotNull final GlobalSearchScope scope) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    return ModelAccess.instance().runReadAction(new Computable<PsiField[]>() {\n      @Override\n      public PsiField[] compute() {\n        CollectConsumer<SNode> consumer = new CollectConsumer<SNode>(new ArrayList<SNode>());\n        findMPSFields(name, consumer, scope);\n        return toPsiFields(consumer.getResult());\n      }\n    });\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public PsiField[] getFieldsByNameIfNotMoreThan(@NonNls @NotNull String name, @NotNull GlobalSearchScope scope,\n                                                 int maxCount) {\n    // TODO implement\n    return new PsiField[0];\n  }","id":98623,"modified_method":"@NotNull\n  @Override\n  public PsiField[] getFieldsByNameIfNotMoreThan(@NonNls @NotNull final String name, @NotNull final GlobalSearchScope scope, final int maxCount) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    return ModelAccess.instance().runReadAction(new Computable<PsiField[]>() {\n      @Override\n      public PsiField[] compute() {\n        final CollectConsumer<SNode> consumer = new CollectConsumer<SNode>(new ArrayList<SNode>());\n        processMPSFields(name, new Processor<SNode>() {\n          int count = 0;\n\n          @Override\n          public boolean process(SNode node) {\n            if (count++ >= maxCount) return false;\n            consumer.consume(node);\n            return true;\n          }\n        }, scope);\n        return toPsiFields(consumer.getResult());\n      }\n    });\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public PsiClass[] getClassesByName(@NotNull @NonNls final String name, final @NotNull GlobalSearchScope scope) {\n\n    Project project = scope.getProject();\n    final ArrayList<PsiClass> result = new ArrayList<PsiClass>();\n\n    for (Module module : ModuleManager.getInstance(project).getModules()) {\n      if (!scope.isSearchInModuleContent(module)) continue;\n      MPSFacet facet = FacetManager.getInstance(module).getFacetByType(MPSFacetType.ID);\n      if (facet == null) continue;\n\n      final Solution facetSolution = facet.getSolution();\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n\n          for (SModel model : SModelRepository.getInstance().getModelDescriptors(facetSolution)) {\n            for (SNode root : model.getRootNodes()) {\n              for (SNode claz : SNodeOperations.getAncestors(root, \"jetbrains.mps.baseLanguage.structure.Classifier\", true)) {\n                PsiElement psiElem = MPSPsiProvider.getInstance(scope.getProject()).getPsi(claz);\n                // not our real project MPS node, probably stub\n                if (!(psiElem instanceof MPSPsiNode)) continue; // should skip all model\n                assert psiElem instanceof PsiClass;\n\n                PsiClass psiClas = (PsiClass) psiElem;\n                if (name.equals(psiClas.getName())) {\n                  result.add(psiClas);\n                }\n              }\n            }\n          }\n        }\n      });\n    }\n\n    if (result.isEmpty()) {\n      return PsiClass.EMPTY_ARRAY;\n    } else {\n      return ArrayUtil.toObjectArray(result, PsiClass.class);\n    }\n  }","id":98624,"modified_method":"@NotNull\n  @Override\n  public PsiClass[] getClassesByName(@NotNull @NonNls final String name, final @NotNull GlobalSearchScope scope) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    return ModelAccess.instance().runReadAction(new Computable<PsiClass[]>() {\n      @Override\n      public PsiClass[] compute() {\n        CollectConsumer<SNode> consumer = new CollectConsumer<SNode>(new ArrayList<SNode>());\n        findMPSClasses(name, consumer, scope);\n        return toPsiClasses(consumer.getResult());\n      }\n    });\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void getAllClassNames(@NotNull HashSet<String> dest) {\n    // TODO implement\n  }","id":98625,"modified_method":"@Override\n  public void getAllClassNames(@NotNull HashSet<String> dest) {\n    FileBasedIndex.getInstance().processAllKeys(MPSShortNameJavaClassIndex.ID, new CommonProcessors.CollectProcessor<String>(dest), myProject);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public PsiMethod[] getMethodsByName(@NonNls @NotNull String name, @NotNull GlobalSearchScope scope) {\n    // TODO implement\n    return new PsiMethod[0];\n  }","id":98626,"modified_method":"@NotNull\n  @Override\n  public PsiMethod[] getMethodsByName(@NonNls @NotNull final String name, @NotNull final GlobalSearchScope scope) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    return ModelAccess.instance().runReadAction(new Computable<PsiMethod[]>() {\n      @Override\n      public PsiMethod[] compute() {\n        CollectConsumer<SNode> consumer = new CollectConsumer<SNode>(new ArrayList<SNode>());\n        findMPSMethods(name, consumer, scope);\n        return toPsiMethods(consumer.getResult());\n      }\n    });\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean processMethodsWithName(@NonNls @NotNull String name, @NotNull GlobalSearchScope\n    scope, @NotNull Processor<PsiMethod> processor) {\n    // TODO implement\n    return false;\n  }","id":98627,"modified_method":"@Override\n  public boolean processMethodsWithName(@NonNls @NotNull final String name, @NotNull final GlobalSearchScope scope, @NotNull final Processor<PsiMethod> processor) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    final MPSPsiProvider psiProvider = MPSPsiProvider.getInstance(myProject);\n    return ModelAccess.instance().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return processMPSMethods(name, new Processor<SNode>() {\n          @Override\n          public boolean process(SNode node) {\n            PsiElement psi = psiProvider.getPsi(node);\n            if (psi instanceof PsiMethod) {\n              if (!processor.process((PsiMethod) psi)) return false;\n            }\n            return true;\n          }\n        }, scope);\n      }\n    });\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public PsiMethod[] getMethodsByNameIfNotMoreThan(@NonNls @NotNull String name, @NotNull GlobalSearchScope scope,\n                                                   int maxCount) {\n    // TODO implement\n    return new PsiMethod[0];\n  }","id":98628,"modified_method":"@NotNull\n  @Override\n  public PsiMethod[] getMethodsByNameIfNotMoreThan(@NonNls @NotNull final String name, @NotNull final GlobalSearchScope scope, final int maxCount) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    return ModelAccess.instance().runReadAction(new Computable<PsiMethod[]>() {\n      @Override\n      public PsiMethod[] compute() {\n        final CollectConsumer<SNode> consumer = new CollectConsumer<SNode>(new ArrayList<SNode>());\n        processMPSMethods(name, new Processor<SNode>() {\n          int count = 0;\n          @Override\n          public boolean process(SNode node) {\n            if (count++ >= maxCount) return false;\n            consumer.consume(node);\n            return true;\n          }\n        }, scope);\n        return toPsiMethods(consumer.getResult());\n      }\n    });\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public String[] getAllMethodNames() {\n    // TODO implement\n    return new String[0];\n  }","id":98629,"modified_method":"@NotNull\n  @Override\n  public String[] getAllMethodNames() {\n    Collection<String> allNames = FileBasedIndex.getInstance().getAllKeys(MPSJavaMethodIndex.ID, myProject);\n    return allNames.toArray(new String[allNames.size()]);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public String[] getAllClassNames() {\n    // TODO implement\n    return new String[0];\n  }","id":98630,"modified_method":"@NotNull\n  @Override\n  public String[] getAllClassNames() {\n    Collection<String> allNames = FileBasedIndex.getInstance().getAllKeys(MPSShortNameJavaClassIndex.ID, myProject);\n    return allNames.toArray(new String[allNames.size()]);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void getAllMethodNames(@NotNull HashSet<String> set) {\n    // TODO implement\n  }","id":98631,"modified_method":"@Override\n  public void getAllMethodNames(@NotNull HashSet<String> set) {\n    FileBasedIndex.getInstance().processAllKeys(MPSJavaMethodIndex.ID, new CommonProcessors.CollectProcessor<String>(set), myProject);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public String[] getAllFieldNames() {\n    // TODO implement\n    return new String[0];\n  }","id":98632,"modified_method":"@NotNull\n  @Override\n  public String[] getAllFieldNames() {\n    Collection<String> allNames = FileBasedIndex.getInstance().getAllKeys(MPSJavaFieldIndex.ID, myProject);\n    return allNames.toArray(new String[allNames.size()]);\n  }","commit_id":"f4439e10aec8488fe397927a414676c0f457cf48","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getEditorTabTitle(Project project, VirtualFile file) {\n    if (!(file instanceof MPSNodeVirtualFile)) return null;\n    final SNode node = MPSEditorUtil.getCurrentEditedNode(project, (MPSNodeVirtualFile) file);\n    if (node != null) {\n      final StringBuilder sb = new StringBuilder();\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          sb.append(node.getPresentation());\n        }\n      });\n      return sb.toString();\n    }\n    return null;\n  }","id":98633,"modified_method":"public String getEditorTabTitle(final Project project, final VirtualFile file) {\n    if (!(file instanceof MPSNodeVirtualFile)) return null;\n    return ModelAccess.instance().runReadAction(new Computable<String>() {\n      public String compute() {\n        SNode node = MPSEditorUtil.getCurrentEditedNode(project, (MPSNodeVirtualFile) file);\n        if (node == null) return \"<no_name>\";\n        return node.getPresentation();\n      }\n    });\n  }","commit_id":"2125476c915bc4f7e26f7c2bd78fddb83500bcb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/journal/select_document_library\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_file_entry\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_folder\")) {\n\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setParameter(\"groupId\", String.valueOf(groupId));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"document-home\"),\n\t\t\t\tportletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\t}\n\n\t\tList<DLFolder> ancestorFolders = folder.getAncestors();\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (DLFolder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, folder.getName(), portletURL.toString());\n\t}","id":98634,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/journal/select_document_library\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_file_entry\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_folder\")) {\n\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setParameter(\"groupId\", String.valueOf(groupId));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"document-home\"),\n\t\t\t\tportletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\t}\n\n\t\tList<DLFolder> ancestorFolders = folder.getAncestors();\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (DLFolder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tif(Validator.isNotNull(folder.getFolderId())){\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, folder.getName(), portletURL.toString());\n\t\t}\n\t}","commit_id":"51e467e01577724f8c71290f3cd4d2f0adacc343","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFileShortcut fileShortcut, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tDLFolder folder = fileShortcut.getFolder();\n\n\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/view_file_shortcut\");\n\t\tportletURL.setParameter(\n\t\t\t\"fileShortcutId\", String.valueOf(fileShortcut.getFileShortcutId()));\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, fileShortcut.getToTitle(), portletURL.toString());\n\t}","id":98635,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFileShortcut fileShortcut, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tDLFolder folder = fileShortcut.getFolder();\n\n\t\tif(Validator.isNotNull(folder.getFolderId())) {\n\t\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\t\t}\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/view_file_shortcut\");\n\t\tportletURL.setParameter(\n\t\t\t\"fileShortcutId\", String.valueOf(fileShortcut.getFileShortcutId()));\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, fileShortcut.getToTitle(), portletURL.toString());\n\t}","commit_id":"51e467e01577724f8c71290f3cd4d2f0adacc343","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tlong folderId, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder folder = DLFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\t\t}\n\t}","id":98636,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tlong folderId, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder folder = DLFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\tif(Validator.isNotNull(folder.getFolderId())) {\n\t\t\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\t\t\t}\n\t\t}\n\t}","commit_id":"51e467e01577724f8c71290f3cd4d2f0adacc343","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFileEntry fileEntry, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tDLFolder folder = fileEntry.getFolder();\n\n\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/view_file_entry\");\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(fileEntry.getFolderId()));\n\t\tportletURL.setParameter(\"name\", fileEntry.getName());\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, fileEntry.getTitle(), portletURL.toString());\n\t}","id":98637,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tDLFileEntry fileEntry, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tDLFolder folder = fileEntry.getFolder();\n\n\t\tif(Validator.isNotNull(folder.getFolderId())) {\n\t\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\t\t}\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/view_file_entry\");\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(fileEntry.getFolderId()));\n\t\tportletURL.setParameter(\"name\", fileEntry.getName());\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, fileEntry.getTitle(), portletURL.toString());\n\t}","commit_id":"51e467e01577724f8c71290f3cd4d2f0adacc343","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean updateBaseClass(BaseClass baseClass)\r\n    {\r\n        boolean needsUpdate = super.updateBaseClass(baseClass);\r\n\r\n        needsUpdate |= baseClass.addTextField(FIELD_appname, FIELDPN_appname, 30);\r\n        needsUpdate |= baseClass.addTextAreaField(FIELD_description, FIELDPN_description, 40, 5);\r\n        needsUpdate |= baseClass.addTextField(FIELD_appversion, FIELDPN_appversion, 30);\r\n        \r\n        StaticListClass slc;\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_dependencies, FIELDPN_dependencies, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_dependencies);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_applications, FIELDPN_applications, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_applications);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_documents, FIELDPN_documents, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_documents);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_docstoinclude, FIELDPN_docstoinclude, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_docstoinclude);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_docstolink, FIELDPN_docstolink, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_docstolink);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_translationdocs, FIELDPN_translationdocs, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_translationdocs);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        return needsUpdate;\r\n    }","id":98638,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * @see com.xpn.xwiki.plugin.applicationmanager.core.doc.objects.classes.AbstractSuperClass#updateBaseClass(com.xpn.xwiki.objects.classes.BaseClass)\r\n     */\r\n    protected boolean updateBaseClass(BaseClass baseClass)\r\n    {\r\n        boolean needsUpdate = super.updateBaseClass(baseClass);\r\n\r\n        needsUpdate |= baseClass.addTextField(FIELD_appname, FIELDPN_appname, 30);\r\n        needsUpdate |= baseClass.addTextAreaField(FIELD_description, FIELDPN_description, 40, 5);\r\n        needsUpdate |= baseClass.addTextField(FIELD_appversion, FIELDPN_appversion, 30);\r\n\r\n        StaticListClass slc;\r\n        \r\n        if (baseClass.addStaticListField(FIELD_dependencies, FIELDPN_dependencies, 80, true, \"\",\r\n            \"input\")) {\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_dependencies);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_applications, FIELDPN_applications, 80, true, \"\",\r\n            \"input\")) {\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_applications);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_documents, FIELDPN_documents, 80, true, \"\",\r\n            \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_documents);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_docstoinclude, FIELDPN_docstoinclude, 80, true,\r\n            \"\", \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_docstoinclude);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_docstolink, FIELDPN_docstolink, 80, true, \"\",\r\n            \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_docstolink);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_translationdocs, FIELDPN_translationdocs, 80,\r\n            true, \"\", \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_translationdocs);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        return needsUpdate;\r\n    }","commit_id":"17261dff6e97febe88339c775e9bc7eabe0265aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected boolean updateBaseClass(BaseClass baseClass)\r\n    {\r\n        boolean needsUpdate = super.updateBaseClass(baseClass);\r\n\r\n        needsUpdate |= baseClass.addTextField(FIELD_appname, FIELDPN_appname, 30);\r\n        needsUpdate |= baseClass.addTextAreaField(FIELD_description, FIELDPN_description, 40, 5);\r\n        needsUpdate |= baseClass.addTextField(FIELD_appversion, FIELDPN_appversion, 30);\r\n        \r\n        StaticListClass slc;\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_dependencies, FIELDPN_dependencies, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_dependencies);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_applications, FIELDPN_applications, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_applications);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_documents, FIELDPN_documents, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_documents);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_docstoinclude, FIELDPN_docstoinclude, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_docstoinclude);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_docstolink, FIELDPN_docstolink, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_docstolink);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        needsUpdate |= baseClass.addStaticListField(FIELD_translationdocs, FIELDPN_translationdocs, 80, true, \"\", \"input\");\r\n\r\n        // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n        // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n        // starts depending on that version where it's applied.\r\n        slc = (StaticListClass)baseClass.getField(FIELD_translationdocs);\r\n        slc.setSeparators(\"|\");\r\n        slc.setSeparator(\"|\");\r\n\r\n        return needsUpdate;\r\n    }","id":98639,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * @see com.xpn.xwiki.plugin.applicationmanager.core.doc.objects.classes.AbstractSuperClass#updateBaseClass(com.xpn.xwiki.objects.classes.BaseClass)\r\n     */\r\n    protected boolean updateBaseClass(BaseClass baseClass)\r\n    {\r\n        boolean needsUpdate = super.updateBaseClass(baseClass);\r\n\r\n        needsUpdate |= baseClass.addTextField(FIELD_appname, FIELDPN_appname, 30);\r\n        needsUpdate |= baseClass.addTextAreaField(FIELD_description, FIELDPN_description, 40, 5);\r\n        needsUpdate |= baseClass.addTextField(FIELD_appversion, FIELDPN_appversion, 30);\r\n\r\n        StaticListClass slc;\r\n        \r\n        if (baseClass.addStaticListField(FIELD_dependencies, FIELDPN_dependencies, 80, true, \"\",\r\n            \"input\")) {\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_dependencies);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_applications, FIELDPN_applications, 80, true, \"\",\r\n            \"input\")) {\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_applications);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_documents, FIELDPN_documents, 80, true, \"\",\r\n            \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_documents);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_docstoinclude, FIELDPN_docstoinclude, 80, true,\r\n            \"\", \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_docstoinclude);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_docstolink, FIELDPN_docstolink, 80, true, \"\",\r\n            \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_docstolink);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        if (baseClass.addStaticListField(FIELD_translationdocs, FIELDPN_translationdocs, 80,\r\n            true, \"\", \"input\")) {\r\n\r\n            // TODO : move into BaseClass.addStaticListField with \"separators' parameter when/if\r\n            // http://jira.xwiki.org/jira/browse/XWIKI-1683 is applied in XWiki Core and when this\r\n            // starts depending on that version where it's applied.\r\n            slc = (StaticListClass) baseClass.getField(FIELD_translationdocs);\r\n            slc.setSeparators(\"|\");\r\n            slc.setSeparator(\"|\");\r\n\r\n            needsUpdate = true;\r\n        }\r\n\r\n        return needsUpdate;\r\n    }","commit_id":"9402180016658797c258177f8ec80279338912cf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    StringBuilder stringBuilder = new StringBuilder();\n    for (PyExpression expression : ((PyListLiteralExpression) myStatement.getAssignedValue()).getElements()) {\n      stringBuilder.append(expression.getText()).append(\", \");\n    }\n    for (PyExpressionStatement statement: myStatements) {\n      for (PyExpression expr : ((PyCallExpression)statement.getExpression()).getArguments())\n        stringBuilder.append(expr.getText()).append(\", \");\n      statement.delete();\n    }\n    myStatement.getAssignedValue().replace(\n      elementGenerator.createExpressionFromText(\"[\" + stringBuilder.substring(0, stringBuilder.length() - 2) + \"]\"));\n  }","id":98640,"modified_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    StringBuilder stringBuilder = new StringBuilder();\n    final PyExpression assignedValue = myStatement.getAssignedValue();\n    if (assignedValue == null) return;\n\n    for (PyExpression expression : ((PyListLiteralExpression)assignedValue).getElements()) {\n      stringBuilder.append(expression.getText()).append(\", \");\n    }\n    for (PyExpressionStatement statement: myStatements) {\n      for (PyExpression expr : ((PyCallExpression)statement.getExpression()).getArguments())\n        stringBuilder.append(expr.getText()).append(\", \");\n      statement.delete();\n    }\n    assignedValue.replace(\n      elementGenerator.createExpressionFromText(\"[\" + stringBuilder.substring(0, stringBuilder.length() - 2) + \"]\"));\n  }","commit_id":"dff34d695cedcf9d61485203a23b21efe69743dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyAssignmentStatement(PyAssignmentStatement node) {\n      if (node.getAssignedValue() instanceof PyListLiteralExpression) {\n        if (node.getTargets().length != 1) {\n          return;\n        }\n        final PyExpression target = node.getTargets()[0];\n        String name = target.getName();\n        if (name == null) {\n          return;\n        }\n        PyExpression statement = null;\n        PyStatement expressionStatement = PsiTreeUtil.getNextSiblingOfType(node, PyStatement.class);\n        if (!(expressionStatement instanceof PyExpressionStatement))\n          return;\n        statement = ((PyExpressionStatement)expressionStatement).getExpression();\n        ListCreationQuickFix quickFix = null;\n        boolean availableFix = false;\nloop:\n        while (statement instanceof PyCallExpression) {\n          PyCallExpression callExpression = (PyCallExpression)statement;\n          PyExpression callee = callExpression.getCallee();\n          if (callee instanceof PyQualifiedExpression) {\n            PyExpression qualifier = ((PyQualifiedExpression)callee).getQualifier();\n            String funcName = ((PyQualifiedExpression)callee).getReferencedName();\n            if (qualifier != null && qualifier.getText().equals(name) && \"append\".equals(funcName)) {\n              PyArgumentList argList = callExpression.getArgumentList();\n              if (argList != null) {\n                for (PyExpression argument : argList.getArguments()) {\n                  if (argument.getText().equals(name))\n                    break loop;\n                  if (!availableFix) {\n                    quickFix = new ListCreationQuickFix(node);\n                    availableFix = true;\n                  }\n                }\n                if(availableFix)\n                  quickFix.addStatement((PyExpressionStatement)expressionStatement);\n              }\n            }\n          }\n          if (quickFix == null) {\n            return;\n          }\n          expressionStatement = PsiTreeUtil.getNextSiblingOfType(expressionStatement, PyStatement.class);\n          if (expressionStatement instanceof PyExpressionStatement)\n            statement = ((PyExpressionStatement)expressionStatement).getExpression();\n          else\n            statement = null;\n        }\n        \n        if (availableFix) {\n          registerProblem(node, \"This list creation could be rewritten as a list literal\", quickFix);\n        }\n      }\n    }","id":98641,"modified_method":"@Override\n    public void visitPyAssignmentStatement(PyAssignmentStatement node) {\n      if (!(node.getAssignedValue() instanceof PyListLiteralExpression))return;\n      final PyExpression[] targets = node.getTargets();\n      if (targets.length != 1) return;\n      final PyExpression target = targets[0];\n      final String name = target.getName();\n      if (name == null) return;\n\n      PyStatement expressionStatement = PsiTreeUtil.getNextSiblingOfType(node, PyStatement.class);\n      if (!(expressionStatement instanceof PyExpressionStatement))\n        return;\n\n      ListCreationQuickFix quickFix = null;\n\n      final String message = \"This list creation could be rewritten as a list literal\";\n      while (expressionStatement instanceof PyExpressionStatement) {\n        final PyExpression statement = ((PyExpressionStatement)expressionStatement).getExpression();\n        if (!(statement instanceof PyCallExpression)) break;\n\n        final PyCallExpression callExpression = (PyCallExpression)statement;\n        final PyExpression callee = callExpression.getCallee();\n        if (callee instanceof PyQualifiedExpression) {\n          final PyExpression qualifier = ((PyQualifiedExpression)callee).getQualifier();\n          final String funcName = ((PyQualifiedExpression)callee).getReferencedName();\n          if (qualifier != null && name.equals(qualifier.getText()) && \"append\".equals(funcName)) {\n            final PyArgumentList argList = callExpression.getArgumentList();\n            if (argList != null) {\n              for (PyExpression argument : argList.getArguments()) {\n                if (argument.getText().equals(name)) {\n                  if (quickFix != null)\n                    registerProblem(node, message, quickFix);\n                  return;\n                }\n              }\n              if (quickFix == null) {\n                quickFix = new ListCreationQuickFix(node);\n              }\n              quickFix.addStatement((PyExpressionStatement)expressionStatement);\n            }\n          }\n        }\n        if (quickFix == null) {\n          return;\n        }\n        expressionStatement = PsiTreeUtil.getNextSiblingOfType(expressionStatement, PyStatement.class);\n      }\n\n      if (quickFix != null) {\n        registerProblem(node, message, quickFix);\n      }\n    }","commit_id":"dff34d695cedcf9d61485203a23b21efe69743dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyStringLiteralExpression createStringLiteralAlreadyEscaped(String str) {\n    final PsiFile dummyFile = createDummyFile(LanguageLevel.getDefault(), \"a=(\" + str + \")\");\n    final PyAssignmentStatement expressionStatement = (PyAssignmentStatement)dummyFile.getFirstChild();\n    return (PyStringLiteralExpression)((PyParenthesizedExpression)expressionStatement.getAssignedValue()).getContainedExpression();\n  }","id":98642,"modified_method":"public PyStringLiteralExpression createStringLiteralAlreadyEscaped(String str) {\n    final PsiFile dummyFile = createDummyFile(LanguageLevel.getDefault(), \"a=(\" + str + \")\");\n    final PyAssignmentStatement expressionStatement = (PyAssignmentStatement)dummyFile.getFirstChild();\n    final PyExpression assignedValue = expressionStatement.getAssignedValue();\n    if (assignedValue != null) {\n      return (PyStringLiteralExpression)((PyParenthesizedExpression)assignedValue).getContainedExpression();\n    }\n    return createStringLiteralFromString(str);\n  }","commit_id":"948693c8f5fac5bb8f215612335e93358fc4f13f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyType getType() {\n    if (getParent() instanceof PyAssignmentStatement) {\n      final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)getParent();\n      return assignmentStatement.getAssignedValue().getType();\n    }\n    return null;\n  }","id":98643,"modified_method":"public PyType getType() {\n    if (getParent() instanceof PyAssignmentStatement) {\n      final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)getParent();\n      final PyExpression assignedValue = assignmentStatement.getAssignedValue();\n      if (assignedValue != null) {\n        if (assignedValue instanceof PyReferenceExpression) {\n          final PsiElement resolveResult = ((PyReferenceExpression)assignedValue).resolve();\n          if (resolveResult == this) {\n            return null;  // fix SOE on \"a = a\"\n          }\n          return PyReferenceExpressionImpl.getTypeFromTarget(resolveResult);          \n        }\n        return assignedValue.getType();\n      }\n    }\n    return null;\n  }","commit_id":"c30926675597d1a19f6d949ffcdfefd6269e3fc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized StructureDescriptor getStructureDescriptor(String fqName) {\n    checkConceptIsLoaded(fqName, LanguageAspect.STRUCTURE);\n    return structureDescriptors.get(fqName);\n  }","id":98644,"modified_method":"public StructureDescriptor getStructureDescriptor(String fqName) {\n    return checkConceptIsLoaded(fqName, LanguageAspect.STRUCTURE);\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private synchronized void checkConceptIsLoaded(final String fqName, LanguageAspect languageAspect) {\n    Pair<String, LanguageAspect> currentConceptAndLanguageAspect = new Pair<String, LanguageAspect>(fqName, languageAspect);\n\n    if (conceptsInLoading.contains(currentConceptAndLanguageAspect)) {\n      return;\n    }\n\n    switch (languageAspect) {\n      case STRUCTURE:\n        if (structureDescriptors.containsKey(fqName)) {\n          return;\n        }\n        break;\n      case BEHAVIOR:\n        if (behaviorDescriptors.containsKey(fqName)) {\n          return;\n        }\n        break;\n      case CONSTRAINTS:\n        if (constraintsDescriptors.containsKey(fqName)) {\n          return;\n        }\n        break;\n    }\n\n    conceptsInLoading.add(currentConceptAndLanguageAspect);\n\n    languageToConcepts.putValue(NameUtil.namespaceFromConceptFQName(fqName), fqName);\n\n//    ModelAccess.instance().runReadAction(new Runnable() {\n//      @Override\n//      public void run() {\n    LanguageRuntime languageRuntime = LanguageRegistry.getInstance().getLanguage(NameUtil.namespaceFromConceptFQName(fqName));\n\n    if (languageRuntime != null) {\n      switch (languageAspect) {\n        case STRUCTURE:\n          structureDescriptors.put(fqName, getDescriptor(languageRuntime.getStructureAspect(), fqName, LanguageRuntimeInterpreted.STRUCTURE_PROVIDER));\n          break;\n        case BEHAVIOR:\n          behaviorDescriptors.put(fqName, getDescriptor(languageRuntime.getBehaviorAspect(), fqName, LanguageRuntimeInterpreted.BEHAVIOR_PROVIDER));\n          break;\n        case CONSTRAINTS:\n          constraintsDescriptors.put(fqName, getDescriptor(languageRuntime.getConstraintsAspect(), fqName, LanguageRuntimeInterpreted.CONSTRAINTS_PROVIDER));\n          break;\n      }\n    } else {\n      // todo: MPS-12650, no way to get NPE\n      switch (languageAspect) {\n        case STRUCTURE:\n          structureDescriptors.put(fqName, LanguageRuntimeInterpreted.STRUCTURE_PROVIDER.getDescriptor(fqName));\n          break;\n        case BEHAVIOR:\n          behaviorDescriptors.put(fqName, LanguageRuntimeInterpreted.BEHAVIOR_PROVIDER.getDescriptor(fqName));\n          break;\n        case CONSTRAINTS:\n          constraintsDescriptors.put(fqName, LanguageRuntimeInterpreted.CONSTRAINTS_PROVIDER.getDescriptor(fqName));\n          break;\n      }\n    }\n//      }\n//    });\n\n    conceptsInLoading.remove(currentConceptAndLanguageAspect);\n  }","id":98645,"modified_method":"private <T> T checkConceptIsLoaded(final String fqName, LanguageAspect languageAspect) {\n    Pair<String, LanguageAspect> currentConceptAndLanguageAspect = new Pair<String, LanguageAspect>(fqName, languageAspect);\n\n    if (conceptsInLoading.contains(currentConceptAndLanguageAspect)) {\n      // todo: ?\n      return null;\n    }\n\n    T descriptor = null;\n    switch (languageAspect) {\n      case STRUCTURE:\n        descriptor = (T) structureDescriptors.get(fqName);\n        if (descriptor != null) {\n          return descriptor;\n        }\n        break;\n      case BEHAVIOR:\n        descriptor = (T) behaviorDescriptors.get(fqName);\n        if (descriptor != null) {\n          return descriptor;\n        }\n        break;\n      case CONSTRAINTS:\n        descriptor = (T) constraintsDescriptors.get(fqName);\n        if (descriptor != null) {\n          return descriptor;\n        }\n        break;\n    }\n\n    synchronized (lock) {\n      conceptsInLoading.add(currentConceptAndLanguageAspect);\n\n      languageToConcepts.putValue(NameUtil.namespaceFromConceptFQName(fqName), fqName);\n\n      try {\n        LanguageRuntime languageRuntime = LanguageRegistry.getInstance().getLanguage(NameUtil.namespaceFromConceptFQName(fqName));\n\n        if (languageRuntime != null) {\n          descriptor = (T) getRuntimeProvider(languageRuntime, languageAspect).getDescriptor(fqName);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Error while descriptor creating from language aspect for concept \" + fqName, e);\n      }\n\n      if (descriptor == null) {\n        descriptor = (T) getDefaultProvider(languageAspect).getDescriptor(fqName);\n      }\n\n      if (descriptor == null) {\n        LOG.error(\"Null descriptor after all\", new RuntimeException());\n      } else {\n        switch (languageAspect) {\n          case STRUCTURE:\n            structureDescriptors.put(fqName, (StructureDescriptor) descriptor);\n            break;\n          case BEHAVIOR:\n            behaviorDescriptors.put(fqName, (BehaviorDescriptor) descriptor);\n            break;\n          case CONSTRAINTS:\n            constraintsDescriptors.put(fqName, (ConstraintsDescriptor) descriptor);\n            break;\n        }\n      }\n\n      conceptsInLoading.remove(currentConceptAndLanguageAspect);\n\n      return descriptor;\n    }\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized void languagesLoaded(Iterable<LanguageRuntime> languages) {\n    ModelAccess.assertLegalWrite();\n\n    // lazy...\n  }","id":98646,"modified_method":"public void languagesLoaded(Iterable<LanguageRuntime> languages) {\n    ModelAccess.assertLegalWrite();\n\n    // lazy...\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public synchronized ConceptDescriptor getConceptDescriptorForInstanceNode(@Nullable SNode node) {\n    return new NullableBehaviorConceptDescriptor(getBehaviorDescriptorForInstanceNode(node));\n  }","id":98647,"modified_method":"@Deprecated\n  public ConceptDescriptor getConceptDescriptorForInstanceNode(@Nullable SNode node) {\n    return new NullableBehaviorConceptDescriptor(getBehaviorDescriptorForInstanceNode(node));\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized void languagesUnloaded(Iterable<LanguageRuntime> languages, boolean unloadAll) {\n    // todo\n    structureDescriptors.clear();\n    behaviorDescriptors.clear();\n    constraintsDescriptors.clear();\n  }","id":98648,"modified_method":"public void languagesUnloaded(Iterable<LanguageRuntime> languages, boolean unloadAll) {\n    // todo\n    structureDescriptors.clear();\n    behaviorDescriptors.clear();\n    constraintsDescriptors.clear();\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized BehaviorDescriptor getBehaviorDescriptorForInstanceNode(@Nullable SNode node) {\n    if (node == null) {\n      // todo: more clearly logic\n      return LanguageRuntimeInterpreted.BEHAVIOR_PROVIDER.getDescriptor(null);\n    } else {\n      return getBehaviorDescriptor(node.getConceptFqName());\n    }\n  }","id":98649,"modified_method":"public BehaviorDescriptor getBehaviorDescriptorForInstanceNode(@Nullable SNode node) {\n    if (node == null) {\n      // todo: more clearly logic\n      return LanguageRuntimeInterpreted.BEHAVIOR_PROVIDER.getDescriptor(null);\n    } else {\n      return getBehaviorDescriptor(node.getConceptFqName());\n    }\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized BehaviorDescriptor getBehaviorDescriptor(String fqName) {\n    checkConceptIsLoaded(fqName, LanguageAspect.BEHAVIOR);\n    return behaviorDescriptors.get(fqName);\n  }","id":98650,"modified_method":"public BehaviorDescriptor getBehaviorDescriptor(String fqName) {\n    return checkConceptIsLoaded(fqName, LanguageAspect.BEHAVIOR);\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized ConstraintsDescriptor getConstraintsDescriptor(String fqName) {\n    checkConceptIsLoaded(fqName, LanguageAspect.CONSTRAINTS);\n    return constraintsDescriptors.get(fqName);\n  }","id":98651,"modified_method":"public ConstraintsDescriptor getConstraintsDescriptor(String fqName) {\n    return checkConceptIsLoaded(fqName, LanguageAspect.CONSTRAINTS);\n  }","commit_id":"be2585669e8ede1e47f213fe63aada0e5741229c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\r\n    public boolean apply(ObjectSourcePlayer<MageObject> input, Game game) {\r\n        StackObject source = game.getStack().getStackObject(input.getSourceId());\r\n        if (source != null) {\r\n            for (Target target : source.getStackAbility().getTargets()) {\r\n                if (target.getTargetTag() > 0 // target is included in the target group to check\r\n                        && target.getTargetTag() != targetTag // it's not the target of this predicate\r\n                        && target.getTargets().contains(input.getObject().getId())) { // if the uuid already is used for another target in the group it's no allowed here\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","id":98652,"modified_method":"@Override\r\n    public boolean apply(ObjectSourcePlayer<MageItem> input, Game game) {\r\n        StackObject source = game.getStack().getStackObject(input.getSourceId());\r\n        if (source != null) {\r\n            for (Target target : source.getStackAbility().getTargets()) {\r\n                if (target.getTargetTag() > 0 // target is included in the target group to check\r\n                        && target.getTargetTag() != targetTag // it's not the target of this predicate\r\n                        && target.getTargets().contains(input.getObject().getId())) { // if the uuid already is used for another target in the group it's not allowed here\r\n                        return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n\n        boolean applied = false;\n        boolean twoDamageDone = false;\n        int damage = 2;\n\n        for ( UUID target : targetPointer.getTargets(game, source) ) {\n            Permanent permanent = game.getPermanent(target);\n\n            if ( twoDamageDone ) {\n                damage = 1;\n            }\n\n            if (permanent != null) {\n                applied |= (permanent.damage( damage, source.getSourceId(), game, false, true ) > 0);\n            }\n            Player player = game.getPlayer(target);\n            if (player != null) {\n                applied |= (player.damage( damage, source.getSourceId(), game, false, true ) > 0);\n            }\n\n            twoDamageDone = true;\n        }\n        return applied;\n    }","id":98653,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n\n        boolean applied = false;\n        boolean twoDamageDone = false;\n        int damage = 2;\n\n        for ( Target target : source.getTargets() ) {\n            Permanent permanent = game.getPermanent(target.getFirstTarget());\n\n            if ( twoDamageDone ) {\n                damage = 1;\n            }\n\n            if (permanent != null) {\n                applied |= (permanent.damage( damage, source.getSourceId(), game, false, true ) > 0);\n            }\n            Player player = game.getPlayer(target.getFirstTarget());\n            if (player != null) {\n                applied |= (player.damage( damage, source.getSourceId(), game, false, true ) > 0);\n            }\n\n            twoDamageDone = true;\n        }\n        return applied;\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"public ArcTrail (UUID ownerId) {\n        super(ownerId, 81, \"Arc Trail\", Rarity.UNCOMMON, new CardType[] { CardType.SORCERY }, \"{1}{R}\");\n        this.expansionSetCode = \"SOM\";\n\n\n        Target target = new TargetCreatureOrPlayer(2);\n        this.getSpellAbility().addTarget(target);\n        this.getSpellAbility().addEffect(ArcTrailEffect.getInstance());\n    }","id":98654,"modified_method":"public ArcTrail (UUID ownerId) {\n        super(ownerId, 81, \"Arc Trail\", Rarity.UNCOMMON, new CardType[] { CardType.SORCERY }, \"{1}{R}\");\n        this.expansionSetCode = \"SOM\";\n\n        // Arc Trail deals 2 damage to target creature or player and 1 damage to another target creature or player\n        FilterCreatureOrPlayer filter1 = new FilterCreatureOrPlayer(\"creature or player to deal 2 damage\");\n        TargetCreatureOrPlayer target1 = new TargetCreatureOrPlayer(1, 1, filter1);\n        target1.setTargetTag(1);\n        this.getSpellAbility().addTarget(target1);\n        \n        FilterCreatureOrPlayer filter2 = new FilterCreatureOrPlayer(\"another creature or player to deal 1 damage\");\n        AnotherTargetPredicate predicate = new AnotherTargetPredicate(2);\n        filter2.getCreatureFilter().add(predicate);\n        filter2.getPlayerFilter().add(predicate);\n        TargetCreatureOrPlayer target2 = new TargetCreatureOrPlayer(1, 1, filter2);\n        target2.setTargetTag(2);\n        this.getSpellAbility().addTarget(target2);\n        \n        this.getSpellAbility().addEffect(ArcTrailEffect.getInstance());\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        boolean applied = false;\n        int damage = 1;\n        for (UUID targetId : targetPointer.getTargets(game, source)) {\n            Permanent permanent = game.getPermanent(targetId);\n            if (permanent != null) {\n                applied |= (permanent.damage(damage, source.getSourceId(), game, false, true) > 0);\n            }\n            Player player = game.getPlayer(targetId);\n            if (player != null) {\n                applied |= (player.damage(damage, source.getSourceId(), game, false, true) > 0);\n            }\n            damage++;\n        }\n        return applied;\n    }","id":98655,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        boolean applied = false;\n        int damage = 1;\n        for (Target target : source.getTargets()) {\n            Permanent permanent = game.getPermanent(target.getFirstTarget());\n            if (permanent != null) {\n                applied |= (permanent.damage(damage, source.getSourceId(), game, false, true) > 0);\n            }\n            Player player = game.getPlayer(target.getFirstTarget());\n            if (player != null) {\n                applied |= (player.damage(damage, source.getSourceId(), game, false, true) > 0);\n            }\n            damage++;\n        }\n        return applied;\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"public ConeOfFlame(UUID ownerId) {\n        super(ownerId, 75, \"Cone of Flame\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{3}{R}{R}\");\n        this.expansionSetCode = \"DDG\";\n\n\n        // Cone of Flame deals 1 damage to target creature or player, 2 damage to another target creature or player, and 3 damage to a third target creature or player.\n        this.getSpellAbility().addEffect(new ConeOfFlameEffect());\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer(3));\n    }","id":98656,"modified_method":"public ConeOfFlame(UUID ownerId) {\n        super(ownerId, 75, \"Cone of Flame\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{3}{R}{R}\");\n        this.expansionSetCode = \"DDG\";\n\n\n        // Cone of Flame deals 1 damage to target creature or player, 2 damage to another target creature or player, and 3 damage to a third target creature or player.\n        FilterCreatureOrPlayer filter1 = new FilterCreatureOrPlayer(\"creature or player to deal 1 damage\");\n        TargetCreatureOrPlayer target1 = new TargetCreatureOrPlayer(1, 1, filter1);\n        target1.setTargetTag(1);\n        this.getSpellAbility().addTarget(target1);\n        \n        FilterCreatureOrPlayer filter2 = new FilterCreatureOrPlayer(\"another creature or player to deal 2 damage\");\n        AnotherTargetPredicate predicate2 = new AnotherTargetPredicate(2);\n        filter2.getCreatureFilter().add(predicate2);\n        filter2.getPlayerFilter().add(predicate2);\n        TargetCreatureOrPlayer target2 = new TargetCreatureOrPlayer(1, 1, filter2);\n        target2.setTargetTag(2);\n        this.getSpellAbility().addTarget(target2);\n        \n        FilterCreatureOrPlayer filter3 = new FilterCreatureOrPlayer(\"another creature or player to deal 3 damage\");\n        AnotherTargetPredicate predicate3 = new AnotherTargetPredicate(3);\n        filter3.getCreatureFilter().add(predicate3);\n        filter3.getPlayerFilter().add(predicate3);\n        TargetCreatureOrPlayer target3 = new TargetCreatureOrPlayer(1, 1, filter3);\n        target3.setTargetTag(3);\n        this.getSpellAbility().addTarget(target3);\n        \n        this.getSpellAbility().addEffect(new ConeOfFlameEffect());\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"public TargetCreatureOrPlayer(int numTargets) {\n        this(numTargets, numTargets);\n    }","id":98657,"modified_method":"public TargetCreatureOrPlayer(int numTargets) {\n        this(numTargets, numTargets, new FilterCreatureOrPlayer());\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Checks if there are enough {@link Permanent} or {@link Player} that can be chosen.  Should only be used\n     * for Ability targets since this checks for protection, shroud etc.\n     *\n     * @param sourceId - the target event source\n     * @param sourceControllerId - controller of the target event source\n     * @param game\n     * @return - true if enough valid {@link Permanent} or {@link Player} exist\n     */\n    @Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        int count = 0;\n        MageObject targetSource = game.getObject(sourceId);\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && player.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(player, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (permanent.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(permanent, sourceId, sourceControllerId, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":98658,"modified_method":"/**\n     * Checks if there are enough {@link Permanent} or {@link Player} that can be chosen.  Should only be used\n     * for Ability targets since this checks for protection, shroud etc.\n     *\n     * @param sourceId - the target event source\n     * @param sourceControllerId - controller of the target event source\n     * @param game\n     * @return - true if enough valid {@link Permanent} or {@link Player} exist\n     */\n    @Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        int count = 0;\n        MageObject targetSource = game.getObject(sourceId);\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && player.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(player, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(filter.getCreatureFilter(), sourceControllerId, game)) {\n            if (permanent.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(permanent, sourceId, sourceControllerId, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        MageObject targetSource = game.getObject(sourceId);\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && player.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(player, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (permanent.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(permanent, sourceId, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","id":98659,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        MageObject targetSource = game.getObject(sourceId);\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null\n                    && player.canBeTargetedBy(targetSource, sourceControllerId, game)\n                    && filter.getPlayerFilter().match(player, sourceId, sourceControllerId, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(filter.getCreatureFilter(), sourceControllerId, game)) {\n            if (permanent.canBeTargetedBy(targetSource, sourceControllerId, game)\n                    && filter.getCreatureFilter().match(permanent, sourceId, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Checks if there are enough {@link Permanent} or {@link Player} that can be selected.  Should not be used\n     * for Ability targets since this does not check for protection, shroud etc.\n     *\n     * @param sourceControllerId - controller of the select event\n     * @param game\n     * @return - true if enough valid {@link Permanent} or {@link Player} exist\n     */\n    @Override\n    public boolean canChoose(UUID sourceControllerId, Game game) {\n        int count = 0;\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && filter.match(player, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (filter.match(permanent, null, sourceControllerId, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":98660,"modified_method":"/**\n     * Checks if there are enough {@link Permanent} or {@link Player} that can be selected.  Should not be used\n     * for Ability targets since this does not check for protection, shroud etc.\n     *\n     * @param sourceControllerId - controller of the select event\n     * @param game\n     * @return - true if enough valid {@link Permanent} or {@link Player} exist\n     */\n    @Override\n    public boolean canChoose(UUID sourceControllerId, Game game) {\n        int count = 0;\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && filter.match(player, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(filter.getCreatureFilter(), sourceControllerId, game)) {\n            if (filter.match(permanent, null, sourceControllerId, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && filter.match(player, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (filter.match(permanent, null, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","id":98661,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && filter.getPlayerFilter().match(player, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(filter.getCreatureFilter(), sourceControllerId, game)) {\n            if (filter.getCreatureFilter().match(permanent, null, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"public TargetCreatureOrPlayer() {\n        this(1, 1);\n    }","id":98662,"modified_method":"public TargetCreatureOrPlayer() {\n        this(1, 1, new FilterCreatureOrPlayer());\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"public TargetCreatureOrPlayer(int minNumTargets, int maxNumTargets) {\n        this.minNumberOfTargets = minNumTargets;\n        this.maxNumberOfTargets = maxNumTargets;\n        this.zone = Zone.ALL;\n        this.filter = new FilterCreatureOrPlayer();\n        this.targetName = filter.getMessage();\n    }","id":98663,"modified_method":"public TargetCreatureOrPlayer(int numTargets, int maxNumTargets) {\n        this(numTargets, maxNumTargets, new FilterCreatureOrPlayer());\n    }","commit_id":"5155f9024ee9da45a52e1a46dddaa96da9a41d1f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent ownCreature = game.getPermanent(source.getFirstTarget());\n        if (ownCreature != null) {\n            int damage = ownCreature.getPower().getValue();\n            Permanent targetCreature = game.getPermanent(source.getTargets().get(1).getFirstTarget());\n            if (targetCreature != null) {\n                targetCreature.damage(damage, ownCreature.getId(), game, false, true);\n                return true;\n            }\n        }\n        return false;\n    }","id":98664,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent ownCreature = game.getPermanentOrLKIBattlefield(source.getFirstTarget());\n        if (ownCreature != null) {\n            int damage = ownCreature.getPower().getValue();\n            Permanent targetCreature = game.getPermanent(getTargetPointer().getFirst(game, source));\n            if (targetCreature != null) {\n                targetCreature.damage(damage, ownCreature.getId(), game, false, true);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"f72ec06ecdeda383ba8fddabb823aa1cb7204109","url":"https://github.com/magefree/mage"},{"original_method":"public Deadshot(UUID ownerId) {\n        super(ownerId, 129, \"Deadshot\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{3}{R}\");\n        this.expansionSetCode = \"TPR\";\n\n        // Tap target creature.\n        this.getSpellAbility().addEffect(new TapTargetEffect());\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n        \n        // It deals damage equal to its power to another target creature.\n        this.getSpellAbility().addEffect(new DeadshotDamageEffect());\n        this.getSpellAbility().addTarget(new DeadshotTargetCreaturePermanent(filter));\n    }","id":98665,"modified_method":"public Deadshot(UUID ownerId) {\n        super(ownerId, 129, \"Deadshot\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{3}{R}\");\n        this.expansionSetCode = \"TPR\";\n\n        // Tap target creature.\n        this.getSpellAbility().addEffect(new TapTargetEffect());\n        TargetCreaturePermanent target = new TargetCreaturePermanent();\n        target.setTargetTag(1);\n        this.getSpellAbility().addTarget(target);\n\n        // It deals damage equal to its power to another target creature.\n        this.getSpellAbility().addEffect(new DeadshotDamageEffect());\n        target = new TargetCreaturePermanent(filter);\n        target.setTargetTag(2);\n        this.getSpellAbility().addTarget(target);\n    }","commit_id":"f72ec06ecdeda383ba8fddabb823aa1cb7204109","url":"https://github.com/magefree/mage"},{"original_method":"public DeadshotDamageEffect(final DeadshotDamageEffect effect) {\n        super(effect);\n    }","id":98666,"modified_method":"public DeadshotDamageEffect(final DeadshotDamageEffect effect) {\n        super(effect);\n        this.setTargetPointer(new SecondTargetPointer());\n    }","commit_id":"f72ec06ecdeda383ba8fddabb823aa1cb7204109","url":"https://github.com/magefree/mage"},{"original_method":"public DroolingGroodion(UUID ownerId) {\r\n        super(ownerId, 65, \"Drooling Groodion\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{3}{B}{B}{G}\");\r\n        this.expansionSetCode = \"DDM\";\r\n        this.subtype.add(\"Beast\");\r\n\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // {2}{B}{G}, Sacrifice a creature: Target creature gets +2/+2 until end of turn. Another target creature gets -2/-2 until end of turn.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DroolingGroodionEffect(), new ManaCostsImpl(\"{2}{B}{G}\"));\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, new FilterControlledCreaturePermanent(), true)));\r\n        ability.addTarget(new TargetCreaturePermanent(new FilterCreaturePermanent(\"creature (first target)\")));\r\n        ability.addTarget(new TargetOtherCreaturePermanent(new FilterCreaturePermanent(\"creature (second target)\")));\r\n        this.addAbility(ability);\r\n    }","id":98667,"modified_method":"public DroolingGroodion(UUID ownerId) {\r\n        super(ownerId, 65, \"Drooling Groodion\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{3}{B}{B}{G}\");\r\n        this.expansionSetCode = \"DDM\";\r\n        this.subtype.add(\"Beast\");\r\n\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // {2}{B}{G}, Sacrifice a creature: Target creature gets +2/+2 until end of turn. Another target creature gets -2/-2 until end of turn.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DroolingGroodionEffect(), new ManaCostsImpl(\"{2}{B}{G}\"));\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, new FilterControlledCreaturePermanent(), true)));\r\n\r\n        TargetCreaturePermanent target = new TargetCreaturePermanent(new FilterCreaturePermanent(\"creature (first target)\"));\r\n        target.setTargetTag(1);\r\n        ability.addTarget(target);\r\n\r\n        FilterCreaturePermanent filter = new FilterCreaturePermanent(\"another target creature (second target\");\r\n        filter.add(new AnotherTargetPredicate(2));\r\n        target = new TargetCreaturePermanent(filter);\r\n        target.setTargetTag(2);\r\n        ability.addTarget(target);\r\n\r\n        this.addAbility(ability);\r\n    }","commit_id":"f72ec06ecdeda383ba8fddabb823aa1cb7204109","url":"https://github.com/magefree/mage"},{"original_method":"public KorChant(UUID ownerId) {\r\n        super(ownerId, 9, \"Kor Chant\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{W}\");\r\n        this.expansionSetCode = \"EXO\";\r\n\r\n        // All damage that would be dealt this turn to target creature you control by a source of your choice is dealt to another target creature instead.\r\n        this.getSpellAbility().addEffect(new KorChantEffect());\r\n        this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());\r\n        this.getSpellAbility().addTarget(new KorChantSecondTarget());\r\n    }","id":98668,"modified_method":"public KorChant(UUID ownerId) {\r\n        super(ownerId, 9, \"Kor Chant\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{W}\");\r\n        this.expansionSetCode = \"EXO\";\r\n\r\n        // All damage that would be dealt this turn to target creature you control by a source of your choice is dealt to another target creature instead.\r\n        this.getSpellAbility().addEffect(new KorChantEffect());\r\n        TargetControlledCreaturePermanent target = new TargetControlledCreaturePermanent();\r\n        target.setTargetTag(1);\r\n        this.getSpellAbility().addTarget(target);\r\n\r\n        FilterCreaturePermanent filter = new FilterCreaturePermanent(\"another target creature\");\r\n        filter.add(new AnotherTargetPredicate(2));\r\n        TargetCreaturePermanent target2 = new TargetCreaturePermanent(filter);\r\n        target2.setTargetTag(2);\r\n        this.getSpellAbility().addTarget(target2);\r\n    }","commit_id":"f72ec06ecdeda383ba8fddabb823aa1cb7204109","url":"https://github.com/magefree/mage"},{"original_method":"public SerpentineSpike(UUID ownerId) {\r\n        super(ownerId, 133, \"Serpentine Spike\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{5}{R}{R}\");\r\n        this.expansionSetCode = \"BFZ\";\r\n\r\n        // Devoid\r\n        Ability ability = new DevoidAbility(this.color);\r\n        ability.setRuleAtTheTop(true);\r\n        this.addAbility(ability);\r\n        // Serpentine Spike deals 2 damage to target creature, 3 damage to another target creature, and 4 damage to a third target creature. If a creature dealt damage this way would die this turn, exile it instead.\r\n        this.getSpellAbility().addEffect(new SerpentineSpikeEffect());\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(new FilterCreaturePermanent(\"creature (2 damage)\")));\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(new FilterCreaturePermanent(\"creature (3 damage)\")));\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(new FilterCreaturePermanent(\"creature (4 damage)\")));\r\n        Effect effect = new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn);\r\n        effect.setText(\"If a creature dealt damage this way would die this turn, exile it instead\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addWatcher(new DamagedByWatcher());\r\n    }","id":98669,"modified_method":"public SerpentineSpike(UUID ownerId) {\r\n        super(ownerId, 133, \"Serpentine Spike\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{5}{R}{R}\");\r\n        this.expansionSetCode = \"BFZ\";\r\n\r\n        // Devoid\r\n        Ability ability = new DevoidAbility(this.color);\r\n        ability.setRuleAtTheTop(true);\r\n        this.addAbility(ability);\r\n        // Serpentine Spike deals 2 damage to target creature, 3 damage to another target creature, and 4 damage to a third target creature. If a creature dealt damage this way would die this turn, exile it instead.\r\n        this.getSpellAbility().addEffect(new SerpentineSpikeEffect());\r\n\r\n        TargetCreaturePermanent target = new TargetCreaturePermanent(new FilterCreaturePermanent(\"creature (2 damage)\"));\r\n        target.setTargetTag(1);\r\n        this.getSpellAbility().addTarget(target);\r\n\r\n        FilterCreaturePermanent filter = new FilterCreaturePermanent(\"another target creature (3 damage)\");\r\n        filter.add(new AnotherTargetPredicate(2));\r\n        target = new TargetCreaturePermanent(filter);\r\n        target.setTargetTag(2);\r\n        this.getSpellAbility().addTarget(target);\r\n\r\n        filter = new FilterCreaturePermanent(\"another target creature (4 damage)\");\r\n        filter.add(new AnotherTargetPredicate(3));\r\n        target = new TargetCreaturePermanent(filter);\r\n        target.setTargetTag(3);\r\n        this.getSpellAbility().addTarget(target);\r\n\r\n        Effect effect = new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn);\r\n        effect.setText(\"If a creature dealt damage this way would die this turn, exile it instead\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addWatcher(new DamagedByWatcher());\r\n    }","commit_id":"f72ec06ecdeda383ba8fddabb823aa1cb7204109","url":"https://github.com/magefree/mage"},{"original_method":"public TargetImpl(final TargetImpl target) {\n        this.targetName = target.targetName;\n        this.zone = target.zone;\n        this.maxNumberOfTargets = target.maxNumberOfTargets;\n        this.minNumberOfTargets = target.minNumberOfTargets;\n        this.required = target.required;\n        this.requiredExplicitlySet = target.requiredExplicitlySet;\n        this.chosen = target.chosen;\n        this.targets.putAll(target.targets);\n        this.zoneChangeCounters.putAll(target.zoneChangeCounters);\n        this.atRandom = target.atRandom;\n        this.notTarget = target.notTarget;\n        this.targetController = target.targetController;\n        this.abilityController = target.abilityController;\n    }","id":98670,"modified_method":"public TargetImpl(final TargetImpl target) {\n        this.targetName = target.targetName;\n        this.zone = target.zone;\n        this.maxNumberOfTargets = target.maxNumberOfTargets;\n        this.minNumberOfTargets = target.minNumberOfTargets;\n        this.required = target.required;\n        this.requiredExplicitlySet = target.requiredExplicitlySet;\n        this.chosen = target.chosen;\n        this.targets.putAll(target.targets);\n        this.zoneChangeCounters.putAll(target.zoneChangeCounters);\n        this.atRandom = target.atRandom;\n        this.notTarget = target.notTarget;\n        this.targetController = target.targetController;\n        this.abilityController = target.abilityController;\n        this.targetTag = target.targetTag;\n    }","commit_id":"f72ec06ecdeda383ba8fddabb823aa1cb7204109","url":"https://github.com/magefree/mage"},{"original_method":"public Legerdemain(UUID ownerId) {\n        super(ownerId, 72, \"Legerdemain\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{2}{U}{U}\");\n        this.expansionSetCode = \"TMP\";\n\n        // Exchange control of target artifact or creature and another target permanent that shares one of those types with it.\n        this.getSpellAbility().addEffect(new ExchangeControlTargetEffect(Duration.EndOfGame, \"Exchange control of target artifact or creature and another target permanent that shares one of those types with it\", false, true));\n        this.getSpellAbility().addTarget(new TargetPermanent(filter));\n        this.getSpellAbility().addTarget(new LegerdemainSecondTarget());\n    }","id":98671,"modified_method":"public Legerdemain(UUID ownerId) {\n        super(ownerId, 72, \"Legerdemain\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{2}{U}{U}\");\n        this.expansionSetCode = \"TMP\";\n\n        // Exchange control of target artifact or creature and another target permanent that shares one of those types with it.\n        this.getSpellAbility().addEffect(new ExchangeControlTargetEffect(Duration.EndOfGame, \"Exchange control of target artifact or creature and another target permanent that shares one of those types with it\", false, true));\n        TargetPermanent firstTarget = new TargetPermanent(firstFilter);\n        firstTarget.setTargetTag(1);\n        TargetPermanent secondTarget = new TargetPermanent(secondFilter);\n        secondTarget.setTargetTag(2);\n        this.getSpellAbility().addTarget(firstTarget);\n        this.getSpellAbility().addTarget(secondTarget);\n    }","commit_id":"2173069c09dccbec74e2a0e73c3202a6a7ad87b9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        Map<String, String> map = Collections.singletonMap(PermissionConstants.PARAM_PERMISSIONS_JR2, PermissionConstants.VALUE_PERMISSIONS_JR2);\n        ConfigurationParameters acConfig = ConfigurationParameters.of(map);\n\n        return ConfigurationParameters.of(ImmutableMap.of(AuthorizationConfiguration.NAME, acConfig));\n    }","id":98672,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters acConfig = ConfigurationParameters.of(\n                PermissionConstants.PARAM_PERMISSIONS_JR2, PermissionConstants.VALUE_PERMISSIONS_JR2);\n\n        return ConfigurationParameters.of(AuthorizationConfiguration.NAME, acConfig);\n    }","commit_id":"cf323167d88691d0d19affa1ca991685752c28e5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@BeforeClass\r\n\tpublic static void setUpBeforeClass() throws Exception {\r\n\t\ttry {\r\n\t\t\tname = ContentName.fromURI(new String[]{baseName, subName2, document2});\r\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\r\n\t\t\t\r\n\t\t\t// generate key pair\r\n\t\t\tKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\r\n\t\t\tkpg.initialize(512); // go for fast\r\n\t\t\tpair = kpg.generateKeyPair();\r\n\t\t\tMinimalCertificateGenerator mg = new MinimalCertificateGenerator(\r\n\t\t\t\t\tendDN, pair.getPublic(), \r\n\t\t\t\t\tnew X500Principal(rootDN), \r\n\t\t\t\t\tMinimalCertificateGenerator.MSEC_IN_YEAR, false);\r\n\t\t\tcert = mg.sign(null, pair.getPrivate());\r\n\t\t\tpubID = new PublisherID(pair.getPublic(), false);\r\n\t\t} catch (Exception ex) {\r\n\t\t\tXMLEncodableTester.handleException(ex);\r\n\t\t\tSystem.out.println(\"Unable To Initialize Test!!!\");\r\n\t\t}\t\r\n\t}","id":98673,"modified_method":"@BeforeClass\r\n\tpublic static void setUpBeforeClass() throws Exception {\r\n\t\ttry {\r\n\t\t\tname = ContentName.fromURI(new String[]{baseName, subName2, document2});\r\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\r\n\t\t\t\r\n\t\t\t// generate key pair\r\n\t\t\tKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\r\n\t\t\tkpg.initialize(512); // go for fast\r\n\t\t\tpair = kpg.generateKeyPair();\r\n\t\t\tMinimalCertificateGenerator mg = new MinimalCertificateGenerator(\r\n\t\t\t\t\tendDN, pair.getPublic(), \r\n\t\t\t\t\tnew X500Principal(rootDN), \r\n\t\t\t\t\tMinimalCertificateGenerator.MSEC_IN_YEAR, false, false);\r\n\t\t\tcert = mg.sign(null, pair.getPrivate());\r\n\t\t\tpubID = new PublisherID(pair.getPublic(), false);\r\n\t\t} catch (Exception ex) {\r\n\t\t\tXMLEncodableTester.handleException(ex);\r\n\t\t\tSystem.out.println(\"Unable To Initialize Test!!!\");\r\n\t\t}\t\r\n\t}","commit_id":"4cb6901dc9088d21c7e56d8cccd87d2a7deda555","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Certificate issued under an existing CA.\n\t * @param subjectDN the distinguished name of the subject.\n\t * @param subjectPublicKey the public key of the subject.\n\t * @param issuerCertificate the certificate of the issuer.\n\t * @param duration the validity duration of the certificate.\n\t * @param isCA \n\t * @throws CertificateEncodingException\n\t * @throws IOException\n\t */\n\tpublic MinimalCertificateGenerator(String subjectDN, PublicKey subjectPublicKey,  \n\t\t\t\t\t\t\t\t\t   X509Certificate issuerCertificate, long duration, boolean isCA) throws CertificateEncodingException, IOException {\n\n\t\tthis(subjectDN, subjectPublicKey, issuerCertificate.getSubjectX500Principal(), duration, isCA);\n\t\t// Pull the existing subject identifier out of the issuer cert. \n\t\tbyte [] subjectKeyID = issuerCertificate.getExtensionValue(X509Extensions.SubjectKeyIdentifier.toString());\n\t\tif (null == subjectKeyID) {\n\t\t\tsubjectKeyID = CryptoUtil.generateKeyID(subjectPublicKey);\n\t\t} else {\n\t\t\t// content of extension is wrapped in a DEROctetString\n\t\t\tDEROctetString content = (DEROctetString)CryptoUtil.decode(subjectKeyID);\n\t\t\tsubjectKeyID = content.getOctets();\n\t\t}\n\t\tAuthorityKeyIdentifier aki = \n\t\t\tnew AuthorityKeyIdentifier(subjectKeyID);\n\t\t_generator.addExtension(X509Extensions.AuthorityKeyIdentifier, false, aki);\n\t}","id":98674,"modified_method":"/**\n\t * Certificate issued under an existing CA.\n\t * @param subjectDN the distinguished name of the subject.\n\t * @param subjectPublicKey the public key of the subject.\n\t * @param issuerCertificate the certificate of the issuer.\n\t * @param duration the validity duration of the certificate.\n\t * @param isCA \n\t * @param allUsage if isCA is true, add \"regular\" KeyUsage flags, for dual-use cert\n\t * @throws CertificateEncodingException\n\t * @throws IOException\n\t */\n\tpublic MinimalCertificateGenerator(String subjectDN, PublicKey subjectPublicKey,  \n\t\t\t\t\t\t\t\t\t   X509Certificate issuerCertificate, long duration, boolean isCA, boolean allUsage) throws CertificateEncodingException, IOException {\n\n\t\tthis(subjectDN, subjectPublicKey, issuerCertificate.getSubjectX500Principal(), duration, isCA, allUsage);\n\t\t// Pull the existing subject identifier out of the issuer cert. \n\t\tbyte [] subjectKeyID = issuerCertificate.getExtensionValue(X509Extensions.SubjectKeyIdentifier.toString());\n\t\tif (null == subjectKeyID) {\n\t\t\tsubjectKeyID = CryptoUtil.generateKeyID(subjectPublicKey);\n\t\t} else {\n\t\t\t// content of extension is wrapped in a DEROctetString\n\t\t\tDEROctetString content = (DEROctetString)CryptoUtil.decode(subjectKeyID);\n\t\t\tsubjectKeyID = content.getOctets();\n\t\t}\n\t\tAuthorityKeyIdentifier aki = \n\t\t\tnew AuthorityKeyIdentifier(subjectKeyID);\n\t\t_generator.addExtension(X509Extensions.AuthorityKeyIdentifier, false, aki);\n\t}","commit_id":"4cb6901dc9088d21c7e56d8cccd87d2a7deda555","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Generates an X509 certificate for a specified user key pair, \n\t * subject distinguished name and duration.\n\t * @param userKeyPair the user key pair.\n\t * @param subjectDN the distinguished name of the user.\n\t * @param duration the duration of validity of the certificate.\n\t * @return the X509 certificate.\n\t * @throws CertificateEncodingException\n\t * @throws InvalidKeyException\n\t * @throws IllegalStateException\n\t * @throws NoSuchAlgorithmException\n\t * @throws SignatureException\n\t */\n\tpublic static X509Certificate GenerateUserCertificate(KeyPair userKeyPair, String subjectDN, long duration) throws CertificateEncodingException, InvalidKeyException, IllegalStateException, NoSuchAlgorithmException, SignatureException {\n\t\tMinimalCertificateGenerator mg = new MinimalCertificateGenerator(subjectDN, userKeyPair.getPublic(), duration, false);\n\t\tmg.setClientAuthenticationUsage();\n\t\treturn mg.sign(null, userKeyPair.getPrivate());\n\t}","id":98675,"modified_method":"/**\n\t * Helper method\n\t */\n\tpublic static X509Certificate GenerateUserCertificate(KeyPair userKeyPair, String subjectDN, long duration) throws CertificateEncodingException, InvalidKeyException, IllegalStateException, NoSuchAlgorithmException, SignatureException {\n\t\treturn GenerateUserCertificate(userKeyPair.getPublic(), subjectDN, duration, userKeyPair.getPrivate());\n\t}","commit_id":"4cb6901dc9088d21c7e56d8cccd87d2a7deda555","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Basic common path.\n\t * @param subjectDN the distinguished name of the subject.\n\t * @param subjectPublicKey the public key of the subject.\n\t * @param issuerDN the distinguished name of the issuer.\n\t * @param duration the validity duration of the certificate.\n\t * @param isCA\n\t */\n\tpublic MinimalCertificateGenerator(String subjectDN, PublicKey subjectPublicKey, \n\t\t\t\t\t\t\t\t\t   X500Principal issuerDN, long duration, boolean isCA) {\n\t\t\n\t\t_generator.setSubjectDN(new X509Name(subjectDN));\n\t\t_generator.setIssuerDN(issuerDN);\n\t\t_generator.setSerialNumber(new BigInteger(64, cachedRandom));\n\t\t_generator.setPublicKey(subjectPublicKey);\n\t\t\n\t\tDate startTime = new Date();\n\t\tDate stopTime = new Date(startTime.getTime() + duration);\n\t\t_generator.setNotBefore(startTime);\n\t\t_generator.setNotAfter(stopTime);\n\n\t\t// CA key usage\n\t\tfinal KeyUsage caKeyUsage = new KeyUsage(KeyUsage.digitalSignature | KeyUsage.nonRepudiation | KeyUsage.keyCertSign | KeyUsage.cRLSign);\n\t\t// Non-CA key usage\n\t\tfinal KeyUsage nonCAKeyUsage = new KeyUsage(KeyUsage.digitalSignature | KeyUsage.nonRepudiation | KeyUsage.keyEncipherment | KeyUsage.dataEncipherment | KeyUsage.keyAgreement);\n\t\tif (isCA) {\n\t\t\t_generator.addExtension(X509Extensions.KeyUsage, false, caKeyUsage);\n\t\t} else {\n\t\t\t_generator.addExtension(X509Extensions.KeyUsage, false, nonCAKeyUsage);\t\t\t\n\t\t}\n\t\t\n\t\tBasicConstraints bc = new BasicConstraints(isCA);\n\t\t_generator.addExtension(X509Extensions.BasicConstraints, true, bc);\n\n\t    SubjectKeyIdentifier ski = new SubjectKeyIdentifier(CryptoUtil.generateKeyID(subjectPublicKey));\n\t    _generator.addExtension(X509Extensions.SubjectKeyIdentifier, false, ski);\n\t}","id":98676,"modified_method":"/**\n\t * Basic common path.\n\t * @param subjectDN the distinguished name of the subject.\n\t * @param subjectPublicKey the public key of the subject.\n\t * @param issuerDN the distinguished name of the issuer.\n\t * @param duration the validity duration of the certificate.\n\t * @param isCA\n\t * @param allUsage if isCA is true, add \"regular\" KeyUsage flags, for dual-use cert\n\t */\n\tpublic MinimalCertificateGenerator(String subjectDN, PublicKey subjectPublicKey, \n\t\t\t\t\t\t\t\t\t   X500Principal issuerDN, long duration, boolean isCA, boolean allUsage) {\n\t\t\n\t\t_generator.setSubjectDN(new X509Name(subjectDN));\n\t\t_generator.setIssuerDN(issuerDN);\n\t\t_generator.setSerialNumber(new BigInteger(64, cachedRandom));\n\t\t_generator.setPublicKey(subjectPublicKey);\n\t\t\n\t\tDate startTime = new Date();\n\t\tDate stopTime = new Date(startTime.getTime() + duration);\n\t\t_generator.setNotBefore(startTime);\n\t\t_generator.setNotAfter(stopTime);\n\n\t\t// CA key usage\n\t\tfinal int caKeyUsage = KeyUsage.digitalSignature | KeyUsage.nonRepudiation | KeyUsage.keyCertSign | KeyUsage.cRLSign;\n\t\t// Non-CA key usage\n\t\tfinal int nonCAKeyUsage = KeyUsage.digitalSignature | KeyUsage.nonRepudiation | KeyUsage.keyEncipherment | KeyUsage.dataEncipherment | KeyUsage.keyAgreement;\n\t\t\n\t\tint ourUsage;\n\t\tif (isCA) {\n\t\t\tif (!allUsage) {\n\t\t\t\tourUsage = caKeyUsage;\n\t\t\t} else {\n\t\t\t\tourUsage = caKeyUsage | nonCAKeyUsage;\n\t\t\t}\n\t\t} else {\n\t\t\tourUsage = nonCAKeyUsage;\n\t\t}\n\t\t_generator.addExtension(X509Extensions.KeyUsage, false, new KeyUsage(ourUsage));\t\t\t\n\t\t\n\t\tBasicConstraints bc = new BasicConstraints(isCA);\n\t\t_generator.addExtension(X509Extensions.BasicConstraints, true, bc);\n\n\t    SubjectKeyIdentifier ski = new SubjectKeyIdentifier(CryptoUtil.generateKeyID(subjectPublicKey));\n\t    _generator.addExtension(X509Extensions.SubjectKeyIdentifier, false, ski);\n\t}","commit_id":"4cb6901dc9088d21c7e56d8cccd87d2a7deda555","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Generates an X509 certificate for a specified user key pair,\n\t * subject distinguished name, email address and duration.\n\t * @param userKeyPair the user key pair.\n\t * @param subjectDN the distinguished name of the subject.\n\t * @param emailAddress the email address.\n\t * @param duration the validity duration of the certificate.\n\t * @return the X509 certificate.\n\t * @throws CertificateEncodingException\n\t * @throws InvalidKeyException\n\t * @throws IllegalStateException\n\t * @throws NoSuchAlgorithmException\n\t * @throws SignatureException\n\t */\n\tpublic static X509Certificate GenerateUserCertificate(KeyPair userKeyPair, String subjectDN, String emailAddress, long duration) throws CertificateEncodingException, InvalidKeyException, IllegalStateException, NoSuchAlgorithmException, SignatureException {\n\t\tMinimalCertificateGenerator mg = new MinimalCertificateGenerator(subjectDN, userKeyPair.getPublic(), duration, false);\n\t\tmg.setClientAuthenticationUsage();\n\t\tmg.setSecureEmailUsage(emailAddress);\n\t\treturn mg.sign(null, userKeyPair.getPrivate());\n\t}","id":98677,"modified_method":"/**\n\t * Helper method\n\t */\n\tpublic static X509Certificate GenerateUserCertificate(KeyPair userKeyPair, String subjectDN, String emailAddress, long duration) throws CertificateEncodingException, InvalidKeyException, IllegalStateException, NoSuchAlgorithmException, SignatureException {\n\t\treturn GenerateUserCertificate(userKeyPair.getPublic(), subjectDN, emailAddress, duration, userKeyPair.getPrivate());\n\t}","commit_id":"4cb6901dc9088d21c7e56d8cccd87d2a7deda555","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Self-signed certificate (which may or may not be a CA).\n\t * @param subjectDN the distinguished name of the subject.\n\t * @param subjectPublicKey the public key of the subject.\n\t * @param duration the validity duration of the certificate.\n\t * @param isCA\n\t */\n\tpublic MinimalCertificateGenerator(String subjectDN, PublicKey subjectPublicKey,  \n\t\t\t\t\t\t\t\t\t   long duration, boolean isCA) {\n\n\t\tthis(subjectDN, subjectPublicKey, new X500Principal(subjectDN), duration, isCA);\n\t\t// This needs to match what we are using for a subject key identifier.\n\t\tAuthorityKeyIdentifier aki = \n\t\t\tnew AuthorityKeyIdentifier(CryptoUtil.generateKeyID(subjectPublicKey));\n\t\t_generator.addExtension(X509Extensions.AuthorityKeyIdentifier, false, aki);\n\t}","id":98678,"modified_method":"/**\n\t * Self-signed certificate (which may or may not be a CA).\n\t * @param subjectDN the distinguished name of the subject.\n\t * @param subjectPublicKey the public key of the subject.\n\t * @param duration the validity duration of the certificate.\n\t * @param isCA add basic constraints\n\t * @param allUsage if isCA is true, add \"regular\" KeyUsage flags, for dual-use cert\n\t */\n\tpublic MinimalCertificateGenerator(String subjectDN, PublicKey subjectPublicKey,  \n\t\t\t\t\t\t\t\t\t   long duration, boolean isCA, boolean allUsage) {\n\n\t\tthis(subjectDN, subjectPublicKey, new X500Principal(subjectDN), duration, isCA, allUsage);\n\t\t// This needs to match what we are using for a subject key identifier.\n\t\tAuthorityKeyIdentifier aki = \n\t\t\tnew AuthorityKeyIdentifier(CryptoUtil.generateKeyID(subjectPublicKey));\n\t\t_generator.addExtension(X509Extensions.AuthorityKeyIdentifier, false, aki);\n\t}","commit_id":"4cb6901dc9088d21c7e56d8cccd87d2a7deda555","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@BeforeClass\r\n\tpublic static void setUpBeforeClass() throws Exception {\r\n\t\ttry {\r\n\t\t\tname = ContentName.fromURI(new String[]{baseName, subName2, document2});\r\n\t\t\tkeyname = ContentName.fromURI(new String[]{baseName, subName2, keydoc});\r\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\r\n\t\t\t\r\n\t\t\t// generate key pair\r\n\t\t\tKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\r\n\t\t\tkpg.initialize(512); // go for fast\r\n\t\t\tpair = kpg.generateKeyPair();\r\n\t\t\t\r\n\t\t\tMinimalCertificateGenerator mg = new MinimalCertificateGenerator(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tendDN, pair.getPublic(), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew X500Principal(rootDN), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMinimalCertificateGenerator.MSEC_IN_YEAR, false);\r\n\t\t\tcert = mg.sign(null, pair.getPrivate());\r\n\t\t\tnameLoc = new KeyLocator(keyname);\r\n\t\t\tkeyLoc = new KeyLocator(pair.getPublic());\r\n\t\t\tcertLoc = new KeyLocator(cert);\r\n\t\t\t\r\n\t\t\tArrays.fill(signature, (byte)1);\r\n\t\t\tArrays.fill(publisherid, (byte)3);\r\n\t\t\t\r\n\t\t\tpubkey = new PublisherPublicKeyDigest(publisherid);\r\n\t\t} catch (Exception ex) {\r\n\t\t\tXMLEncodableTester.handleException(ex);\r\n\t\t\tSystem.out.println(\"Unable To Initialize Test!!!\");\r\n\t\t}\t\r\n\t}","id":98679,"modified_method":"@BeforeClass\r\n\tpublic static void setUpBeforeClass() throws Exception {\r\n\t\ttry {\r\n\t\t\tname = ContentName.fromURI(new String[]{baseName, subName2, document2});\r\n\t\t\tkeyname = ContentName.fromURI(new String[]{baseName, subName2, keydoc});\r\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\r\n\t\t\t\r\n\t\t\t// generate key pair\r\n\t\t\tKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\r\n\t\t\tkpg.initialize(512); // go for fast\r\n\t\t\tpair = kpg.generateKeyPair();\r\n\t\t\t\r\n\t\t\tMinimalCertificateGenerator mg = new MinimalCertificateGenerator(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tendDN, pair.getPublic(), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew X500Principal(rootDN), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMinimalCertificateGenerator.MSEC_IN_YEAR, false, false);\r\n\t\t\tcert = mg.sign(null, pair.getPrivate());\r\n\t\t\tnameLoc = new KeyLocator(keyname);\r\n\t\t\tkeyLoc = new KeyLocator(pair.getPublic());\r\n\t\t\tcertLoc = new KeyLocator(cert);\r\n\t\t\t\r\n\t\t\tArrays.fill(signature, (byte)1);\r\n\t\t\tArrays.fill(publisherid, (byte)3);\r\n\t\t\t\r\n\t\t\tpubkey = new PublisherPublicKeyDigest(publisherid);\r\n\t\t} catch (Exception ex) {\r\n\t\t\tXMLEncodableTester.handleException(ex);\r\n\t\t\tSystem.out.println(\"Unable To Initialize Test!!!\");\r\n\t\t}\t\r\n\t}","commit_id":"4cb6901dc9088d21c7e56d8cccd87d2a7deda555","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n   * Create a self-signed X.509 Certificate.\n   * From http://bfo.com/blog/2011/03/08/odds_and_ends_creating_a_new_x_509_certificate.html.\n   *\n   * @param dn the X.509 Distinguished Name, eg \"CN=Test, L=London, C=GB\"\n   * @param pair the KeyPair\n   * @param days how many days from now the Certificate is valid for\n   * @param algorithm the signing algorithm, eg \"SHA1withRSA\"\n   * @return the self-signed certificate\n   * @throws IOException thrown if an IO error ocurred.\n   * @throws GeneralSecurityException thrown if an Security error ocurred.\n   */\n  public static X509Certificate generateCertificate(String dn, KeyPair pair,\n      int days, String algorithm)\n      throws GeneralSecurityException, IOException {\n    PrivateKey privkey = pair.getPrivate();\n    X509CertInfo info = new X509CertInfo();\n    Date from = new Date();\n    Date to = new Date(from.getTime() + days * 86400000l);\n    CertificateValidity interval = new CertificateValidity(from, to);\n    BigInteger sn = new BigInteger(64, new SecureRandom());\n    X500Name owner = new X500Name(dn);\n\n    info.set(X509CertInfo.VALIDITY, interval);\n    info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(sn));\n    info.set(X509CertInfo.SUBJECT, new CertificateSubjectName(owner));\n    info.set(X509CertInfo.ISSUER, new CertificateIssuerName(owner));\n    info.set(X509CertInfo.KEY, new CertificateX509Key(pair.getPublic()));\n    info\n        .set(X509CertInfo.VERSION, new CertificateVersion(CertificateVersion.V3));\n    AlgorithmId algo = new AlgorithmId(AlgorithmId.md5WithRSAEncryption_oid);\n    info.set(X509CertInfo.ALGORITHM_ID, new CertificateAlgorithmId(algo));\n\n    // Sign the cert to identify the algorithm that's used.\n    X509CertImpl cert = new X509CertImpl(info);\n    cert.sign(privkey, algorithm);\n\n    // Update the algorith, and resign.\n    algo = (AlgorithmId) cert.get(X509CertImpl.SIG_ALG);\n    info\n        .set(CertificateAlgorithmId.NAME + \".\" + CertificateAlgorithmId.ALGORITHM,\n            algo);\n    cert = new X509CertImpl(info);\n    cert.sign(privkey, algorithm);\n    return cert;\n  }","id":98680,"modified_method":"@SuppressWarnings(\"deprecation\")\n  /**\n   * Create a self-signed X.509 Certificate.\n   *\n   * @param dn the X.509 Distinguished Name, eg \"CN=Test, L=London, C=GB\"\n   * @param pair the KeyPair\n   * @param days how many days from now the Certificate is valid for\n   * @param algorithm the signing algorithm, eg \"SHA1withRSA\"\n   * @return the self-signed certificate\n   */\n  public static X509Certificate generateCertificate(String dn, KeyPair pair, int days, String algorithm)\n      throws CertificateEncodingException,\n             InvalidKeyException,\n             IllegalStateException,\n             NoSuchProviderException, NoSuchAlgorithmException, SignatureException{\n\n    Date from = new Date();\n    Date to = new Date(from.getTime() + days * 86400000l);\n    BigInteger sn = new BigInteger(64, new SecureRandom());\n    KeyPair keyPair = pair;\n    X509V1CertificateGenerator certGen = new X509V1CertificateGenerator();\n    X500Principal  dnName = new X500Principal(dn);\n\n    certGen.setSerialNumber(sn);\n    certGen.setIssuerDN(dnName);\n    certGen.setNotBefore(from);\n    certGen.setNotAfter(to);\n    certGen.setSubjectDN(dnName);\n    certGen.setPublicKey(keyPair.getPublic());\n    certGen.setSignatureAlgorithm(algorithm);\n\n    X509Certificate cert = certGen.generate(pair.getPrivate());\n    return cert;\n  }","commit_id":"1eed1020234b8b5e5444bbc88299bc6689e6b015","url":"https://github.com/apache/hadoop"},{"original_method":"public static String getClasspathDir(Class klass) throws Exception {\n    String file = klass.getName();\n    file = file.replace('.', '/') + \".class\";\n    URL url = Thread.currentThread().getContextClassLoader().getResource(file);\n    String baseDir = url.toURI().getPath();\n    baseDir = baseDir.substring(0, baseDir.length() - file.length() - 1);\n    return baseDir;\n  }","id":98681,"modified_method":"public static String getClasspathDir(Class<?> klass) throws Exception {\n    String file = klass.getName();\n    file = file.replace('.', '/') + \".class\";\n    URL url = Thread.currentThread().getContextClassLoader().getResource(file);\n    String baseDir = url.toURI().getPath();\n    baseDir = baseDir.substring(0, baseDir.length() - file.length() - 1);\n    return baseDir;\n  }","commit_id":"2da1bf10b8d83b51228f76a0603394a4a5ae03cb","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Create a self-signed X.509 Certificate.\n   * From http://bfo.com/blog/2011/03/08/odds_and_ends_creating_a_new_x_509_certificate.html.\n   *\n   * @param dn the X.509 Distinguished Name, eg \"CN=Test, L=London, C=GB\"\n   * @param pair the KeyPair\n   * @param days how many days from now the Certificate is valid for\n   * @param algorithm the signing algorithm, eg \"SHA1withRSA\"\n   * @return the self-signed certificate\n   * @throws IOException thrown if an IO error ocurred.\n   * @throws GeneralSecurityException thrown if an Security error ocurred.\n   */\n  public static X509Certificate generateCertificate(String dn, KeyPair pair,\n                                                    int days, String algorithm)\n    throws GeneralSecurityException, IOException {\n    PrivateKey privkey = pair.getPrivate();\n    X509CertInfo info = new X509CertInfo();\n    Date from = new Date();\n    Date to = new Date(from.getTime() + days * 86400000l);\n    CertificateValidity interval = new CertificateValidity(from, to);\n    BigInteger sn = new BigInteger(64, new SecureRandom());\n    X500Name owner = new X500Name(dn);\n\n    info.set(X509CertInfo.VALIDITY, interval);\n    info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(sn));\n    info.set(X509CertInfo.SUBJECT, new CertificateSubjectName(owner));\n    info.set(X509CertInfo.ISSUER, new CertificateIssuerName(owner));\n    info.set(X509CertInfo.KEY, new CertificateX509Key(pair.getPublic()));\n    info\n      .set(X509CertInfo.VERSION, new CertificateVersion(CertificateVersion.V3));\n    AlgorithmId algo = new AlgorithmId(AlgorithmId.md5WithRSAEncryption_oid);\n    info.set(X509CertInfo.ALGORITHM_ID, new CertificateAlgorithmId(algo));\n\n    // Sign the cert to identify the algorithm that's used.\n    X509CertImpl cert = new X509CertImpl(info);\n    cert.sign(privkey, algorithm);\n\n    // Update the algorith, and resign.\n    algo = (AlgorithmId) cert.get(X509CertImpl.SIG_ALG);\n    info\n      .set(CertificateAlgorithmId.NAME + \".\" + CertificateAlgorithmId.ALGORITHM,\n           algo);\n    cert = new X509CertImpl(info);\n    cert.sign(privkey, algorithm);\n    return cert;\n  }","id":98682,"modified_method":"/**\n   * Create a self-signed X.509 Certificate.\n   *\n   * @param dn the X.509 Distinguished Name, eg \"CN=Test, L=London, C=GB\"\n   * @param pair the KeyPair\n   * @param days how many days from now the Certificate is valid for\n   * @param algorithm the signing algorithm, eg \"SHA1withRSA\"\n   * @return the self-signed certificate\n   */\n  public static X509Certificate generateCertificate(String dn, KeyPair pair, int days, String algorithm) \n      throws CertificateEncodingException, InvalidKeyException, IllegalStateException, \n      NoSuchProviderException, NoSuchAlgorithmException, SignatureException {\n    Date from = new Date();\n    Date to = new Date(from.getTime() + days * 86400000l);\n    BigInteger sn = new BigInteger(64, new SecureRandom());\n    KeyPair keyPair = pair;\n    X509V1CertificateGenerator certGen = new X509V1CertificateGenerator();\n    X500Principal  dnName = new X500Principal(dn);\n\n    certGen.setSerialNumber(sn);\n    certGen.setIssuerDN(dnName);\n    certGen.setNotBefore(from);\n    certGen.setNotAfter(to);\n    certGen.setSubjectDN(dnName);\n    certGen.setPublicKey(keyPair.getPublic());\n    certGen.setSignatureAlgorithm(algorithm);\n    X509Certificate cert = certGen.generate(pair.getPrivate());\n    return cert;\n  }","commit_id":"2da1bf10b8d83b51228f76a0603394a4a5ae03cb","url":"https://github.com/apache/hbase"},{"original_method":"double op( double l, double r ) { return MathUtils.equalsWithinOneSmallUlp(l,r)?1:0; }","id":98683,"modified_method":"double op( double l, double r ) { return (Double.isNaN(l) && Double.isNaN(r) || MathUtils.equalsWithinOneSmallUlp(l,r))?1:0; }","commit_id":"4fc88caa8d86679c4ed584d6a2c32ec931f03cdd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? (r==null?0:1) : (l.equals(r) ? 0 : 1); }","id":98684,"modified_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? ((r==null)||(r.equals(\"\"))?0:1) : (l.equals(r) ? 0 : 1); }","commit_id":"4fc88caa8d86679c4ed584d6a2c32ec931f03cdd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? (r==null?1:0) : (l.equals(r) ? 1 : 0); }","id":98685,"modified_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? (r==null||(r.equals(\"\"))?1:0) : (l.equals(r) ? 1 : 0); }","commit_id":"4fc88caa8d86679c4ed584d6a2c32ec931f03cdd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"double op( double l, double r ) { return MathUtils.equalsWithinOneSmallUlp(l,r)?0:1; }","id":98686,"modified_method":"double op( double l, double r ) { return (Double.isNaN(l) && Double.isNaN(r) || MathUtils.equalsWithinOneSmallUlp(l,r))?0:1; }","commit_id":"4fc88caa8d86679c4ed584d6a2c32ec931f03cdd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override ValFrame frame_op_scalar( Frame fr, final double d ) {\n    return new ValFrame(new MRTask() {\n        @Override public void map( Chunk[] chks, NewChunk[] cress ) {\n          for( int c=0; c<chks.length; c++ ) {\n            Chunk chk = chks[c];\n            NewChunk cres = cress[c];\n            if( !chk.vec().isNumeric() ) cres.addZeros(chk._len);\n            else \n              for( int i=0; i<chk._len; i++ )\n                cres.addNum(op(chk.atd(i),d));\n          }\n        }\n      }.doAll(fr.numCols(), Vec.T_NUM, fr).outputFrame());\n  }","id":98687,"modified_method":"@Override ValFrame frame_op_scalar( Frame fr, final double d ) {\n    return new ValFrame(new MRTask() {\n        @Override public void map( Chunk[] chks, NewChunk[] cress ) {\n          for( int c=0; c<chks.length; c++ ) {\n            Chunk chk = chks[c];\n            NewChunk cres = cress[c];\n            BufferedString bStr = new BufferedString();\n            if( chk.vec().isString() )\n              for( int i=0; i<chk._len; i++ )\n                cres.addNum(str_op(chk.atStr(bStr,i), Double.isNaN(d)?null:new BufferedString(String.valueOf(d))));\n            else if( !chk.vec().isNumeric() ) cres.addZeros(chk._len);\n            else\n              for( int i=0; i<chk._len; i++ )\n                cres.addNum(op(chk.atd(i),d));\n          }\n        }\n      }.doAll(fr.numCols(), Vec.T_NUM, fr).outputFrame());\n  }","commit_id":"4fc88caa8d86679c4ed584d6a2c32ec931f03cdd","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override ValFrame frame_op_scalar( Frame fr, final double d ) {\n    return new ValFrame(new MRTask() {\n        @Override public void map( Chunk[] chks, NewChunk[] cress ) {\n          for( int c=0; c<chks.length; c++ ) {\n            Chunk chk = chks[c];\n            NewChunk cres = cress[c];\n            if( !chk.vec().isNumeric() ) cres.addZeros(chk._len);\n            else \n              for( int i=0; i<chk._len; i++ )\n                cres.addNum(op(chk.atd(i),d));\n          }\n        }\n      }.doAll(fr.numCols(), Vec.T_NUM, fr).outputFrame());\n  }","id":98688,"modified_method":"@Override ValFrame frame_op_scalar( Frame fr, final double d ) {\n    return new ValFrame(new MRTask() {\n        @Override public void map( Chunk[] chks, NewChunk[] cress ) {\n          for( int c=0; c<chks.length; c++ ) {\n            Chunk chk = chks[c];\n            NewChunk cres = cress[c];\n            BufferedString bStr = new BufferedString();\n            if( chk.vec().isString() )\n              for( int i=0; i<chk._len; i++ )\n                cres.addNum(str_op(chk.atStr(bStr,i), Double.isNaN(d)?null:new BufferedString(String.valueOf(d))));\n            else if( !chk.vec().isNumeric() ) cres.addZeros(chk._len);\n            else\n              for( int i=0; i<chk._len; i++ )\n                cres.addNum(op(chk.atd(i),d));\n          }\n        }\n      }.doAll(fr.numCols(), Vec.T_NUM, fr).outputFrame());\n  }","commit_id":"a581459e7d75f1c6a27481c3f3ea92a13f33d3ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"double op( double l, double r ) { return MathUtils.equalsWithinOneSmallUlp(l,r)?1:0; }","id":98689,"modified_method":"double op( double l, double r ) { return (Double.isNaN(l) && Double.isNaN(r) || MathUtils.equalsWithinOneSmallUlp(l,r))?1:0; }","commit_id":"a581459e7d75f1c6a27481c3f3ea92a13f33d3ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? (r==null?1:0) : (l.equals(r) ? 1 : 0); }","id":98690,"modified_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? (r==null||(r.equals(\"\"))?1:0) : (l.equals(r) ? 1 : 0); }","commit_id":"a581459e7d75f1c6a27481c3f3ea92a13f33d3ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? (r==null?0:1) : (l.equals(r) ? 0 : 1); }","id":98691,"modified_method":"double str_op( BufferedString l, BufferedString r ) { return l==null ? ((r==null)||(r.equals(\"\"))?0:1) : (l.equals(r) ? 0 : 1); }","commit_id":"a581459e7d75f1c6a27481c3f3ea92a13f33d3ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"double op( double l, double r ) { return MathUtils.equalsWithinOneSmallUlp(l,r)?0:1; }","id":98692,"modified_method":"double op( double l, double r ) { return (Double.isNaN(l) && Double.isNaN(r) || MathUtils.equalsWithinOneSmallUlp(l,r))?0:1; }","commit_id":"a581459e7d75f1c6a27481c3f3ea92a13f33d3ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n\t * @since 2.8\n\t */\n\tprotected XtendBatchCompiler getConfiguredBatchCompiler() {\n\t\tXtendBatchCompiler xtend2BatchCompiler = xtendBatchCompilerProvider.get();\n\t\txtend2BatchCompiler.setComplianceLevel(complianceLevel);\n\t\treturn xtend2BatchCompiler;\n\t}","id":98693,"modified_method":"/**\n\t * @since 2.8\n\t */\n\tprotected XtendBatchCompiler getConfiguredBatchCompiler() {\n\t\tXtendBatchCompiler xtend2BatchCompiler = xtendBatchCompilerProvider.get();\n\t\txtend2BatchCompiler.setComplianceLevel(complianceLevel);\n\t\txtend2BatchCompiler.setBasePath(project.getBasedir().getAbsolutePath());\n\t\treturn xtend2BatchCompiler;\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"@Deprecated\n\tprotected XtendBatchCompiler createXtendBatchCompiler() {\n\t\tInjector injector = new XtendMavenStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\tXtendBatchCompiler instance = injector.getInstance(XtendBatchCompiler.class);\n\t\tinstance.setComplianceLevel(complianceLevel);\n\t\treturn instance;\n\t}","id":98694,"modified_method":"@Deprecated\n\tprotected XtendBatchCompiler createXtendBatchCompiler() {\n\t\tInjector injector = new XtendMavenStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\tXtendBatchCompiler instance = injector.getInstance(XtendBatchCompiler.class);\n\t\tinstance.setComplianceLevel(complianceLevel);\n\t\tinstance.setBasePath(project.getBasedir().getAbsolutePath());\n\t\treturn instance;\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean preCompileStubs(File tmpSourceDirectory, File classDirectory) {\n\t\tList<String> commandLine = Lists.newArrayList();\n\t\t// todo args\n\t\tif (isVerbose()) {\n\t\t\tcommandLine.add(\"-verbose\");\n\t\t}\n\t\tif (!isEmpty(bootClassPath)) {\n\t\t\tcommandLine.add(\"-bootclasspath \\\"\" + concat(File.pathSeparator, getBootClassPathEntries()) + \"\\\"\");\n\t\t}\n\t\tif (!isEmpty(classPath)) {\n\t\t\tcommandLine.add(\"-cp \\\"\" + concat(File.pathSeparator, getClassPathEntries()) + \"\\\"\");\n\t\t}\n\t\tcommandLine.add(\"-d \\\"\" + classDirectory.toString() + \"\\\"\");\n\t\tcommandLine.add(\"-\" + getComplianceLevel());\n\t\tcommandLine.add(\"-proceedOnError\");\n\t\tList<String> sourceDirectories = newArrayList(getSourcePathDirectories());\n\t\tsourceDirectories.add(tmpSourceDirectory.toString());\n\t\tcommandLine.add(concat(\" \", transform(sourceDirectories, new Function<String, String>() {\n\t\t\t@Override\n\t\t\tpublic String apply(String path) {\n\t\t\t\treturn \"\\\"\" + path + \"\\\"\";\n\t\t\t}\n\t\t})));\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"invoke batch compiler with '\" + concat(\" \", commandLine) + \"'\");\n\t\t}\n\t\treturn BatchCompiler.compile(concat(\" \", commandLine), new PrintWriter(getOutputWriter()), new PrintWriter(\n\t\t\t\tgetErrorWriter()), null);\n\t}","id":98695,"modified_method":"protected boolean preCompileStubs(File tmpSourceDirectory, File classDirectory) {\n\t\treturn preCompile(tmpSourceDirectory, singletonList(tmpSourceDirectory.toString()), getClassPathEntries());\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean compile() {\n\t\ttry {\n\t\t\tif (workspaceConfigProvider.getWorkspaceConfig() == null) {\n\t\t\t\tif (!configureWorkspace()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tResourceSet resourceSet = resourceSetProvider.get();\n\t\t\tFile classDirectory = createTempDir(\"classes\");\n\t\t\ttry {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, true);\n\t\t\t\t// install a type provider without index lookup for the first phase\n\t\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, true);\n\t\t\t\tloadXtendFiles(resourceSet);\n\t\t\t\tFile sourceDirectory = createStubs(resourceSet);\n\t\t\t\tif (!preCompileStubs(sourceDirectory, classDirectory)) {\n\t\t\t\t\tlog.debug(\"Compilation of stubs and existing Java code had errors. This is expected and usually is not a probblem.\");\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, false);\n\t\t\t}\n\t\t\t// install a fresh type provider for the second phase, so we clear all previously cached classes and misses.\n\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, false);\n\t\t\tEcoreUtil.resolveAll(resourceSet);\n\t\t\tList<Issue> issues = validate(resourceSet);\n\t\t\tIterable<Issue> errors = Iterables.filter(issues, SeverityFilter.ERROR);\n\t\t\tIterable<Issue> warnings = Iterables.filter(issues, SeverityFilter.WARNING);\n\t\t\treportIssues(Iterables.concat(errors, warnings));\n\t\t\tif (!Iterables.isEmpty(errors)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgenerateJavaFiles(resourceSet);\n\t\t} finally {\n\t\t\tif (isDeleteTempDirectory()) {\n\t\t\t\tdeleteTmpFolders();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":98696,"modified_method":"public boolean compile() {\n\t\ttry {\n\t\t\tif (workspaceConfigProvider.getWorkspaceConfig() == null) {\n\t\t\t\tif (!configureWorkspace()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tResourceSet resourceSet = resourceSetProvider.get();\n\t\t\tFile classDirectory = createTempDir(\"classes\");\n\t\t\ttry {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, true);\n\t\t\t\t// install a type provider without index lookup for the first phase\n\t\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, true);\n\t\t\t\tloadXtendFiles(resourceSet);\n\t\t\t\tFile sourceDirectory = createStubs(resourceSet);\n\t\t\t\tif (!preCompileStubs(sourceDirectory, classDirectory)) {\n\t\t\t\t\tlog.warn(\"Compilation of stubs had errors.\");\n\t\t\t\t}\n\t\t\t\tif (!preCompileJava(sourceDirectory, classDirectory)) {\n\t\t\t\t\tlog.debug(\"Compilation of Java code against stubs had errors. This is expected and usually is not a probblem.\");\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, false);\n\t\t\t}\n\t\t\t// install a fresh type provider for the second phase, so we clear all previously cached classes and misses.\n\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, false);\n\t\t\tEcoreUtil.resolveAll(resourceSet);\n\t\t\tList<Issue> issues = validate(resourceSet);\n\t\t\tIterable<Issue> errors = Iterables.filter(issues, SeverityFilter.ERROR);\n\t\t\tIterable<Issue> warnings = Iterables.filter(issues, SeverityFilter.WARNING);\n\t\t\treportIssues(Iterables.concat(errors, warnings));\n\t\t\tif (!Iterables.isEmpty(errors)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgenerateJavaFiles(resourceSet);\n\t\t} finally {\n\t\t\tif (isDeleteTempDirectory()) {\n\t\t\t\tdeleteTmpFolders();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ResourceSet loadXtendFiles(final ResourceSet resourceSet) {\n\t\tencodingProvider.setDefaultEncoding(getFileEncoding());\n\t\tfinal NameBasedFilter nameBasedFilter = new NameBasedFilter();\n\t\tnameBasedFilter.setExtension(fileExtensionProvider.getPrimaryFileExtension());\n\t\tPathTraverser pathTraverser = new PathTraverser();\n\t\tList<String> sourcePathDirectories = getSourcePathDirectories();\n\t\tMultimap<String, URI> pathes = pathTraverser.resolvePathes(sourcePathDirectories, new Predicate<URI>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply(URI input) {\n\t\t\t\tboolean matches = nameBasedFilter.matches(input);\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t});\n\t\tfor (String src : pathes.keySet()) {\n\t\t\tURI baseDir = URI.createFileURI(src + \"/\");\n\t\t\tString identifier = Joiner.on(\"_\").join(baseDir.segments());\n\t\t\tURI platformResourceURI = URI.createPlatformResourceURI(identifier + \"/\", true);\n\t\t\tresourceSet.getURIConverter().getURIMap().put(platformResourceURI, baseDir);\n\t\t\tfor (URI uri : pathes.get(src)) {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"load xtend file '\" + uri + \"'\");\n\t\t\t\t}\n\t\t\t\tURI uriToUse = uri.replacePrefix(baseDir, platformResourceURI);\n\t\t\t\tresourceSet.getResource(uriToUse, true);\n\t\t\t}\n\t\t}\n\t\treturn resourceSet;\n\t}","id":98697,"modified_method":"protected ResourceSet loadXtendFiles(final ResourceSet resourceSet) {\n\t\tencodingProvider.setDefaultEncoding(getFileEncoding());\n\t\tfinal NameBasedFilter nameBasedFilter = new NameBasedFilter();\n\t\tnameBasedFilter.setExtension(fileExtensionProvider.getPrimaryFileExtension());\n\t\tPathTraverser pathTraverser = new PathTraverser();\n\t\tList<String> sourcePathDirectories = getSourcePathDirectories();\n\t\tMultimap<String, URI> pathes = pathTraverser.resolvePathes(sourcePathDirectories, new Predicate<URI>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply(URI input) {\n\t\t\t\tboolean matches = nameBasedFilter.matches(input);\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t});\n\t\tfor (String src : pathes.keySet()) {\n\t\t\tURI srcURI = URI.createFileURI(src + \"/\");\n\t\t\tURI relativeSrcURI = null;\n\t\t\tif(baseURI != null) {\n\t\t\t\trelativeSrcURI = srcURI.deresolve(baseURI);\n\t\t\t} else {\n\t\t\t\trelativeSrcURI = srcURI;\n\t\t\t}\n\t\t\tURI platformResourceURI = null;\n\t\t\tif(relativeSrcURI.isRelative()) {\n\t\t\t\tplatformResourceURI = URI.createPlatformResourceURI(relativeSrcURI.toString(), true);\n\t\t\t} else {\n\t\t\t\tString identifier = Joiner.on(\"_\").join(relativeSrcURI.segments());\n\t\t\t\tplatformResourceURI = URI.createPlatformResourceURI(identifier + \"/\", true);\n\t\t\t}\n\t\t\tresourceSet.getURIConverter().getURIMap().put(platformResourceURI, srcURI);\n\t\t\tfor (URI uri : pathes.get(src)) {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"load xtend file '\" + uri + \"'\");\n\t\t\t\t}\n\t\t\t\tURI uriToUse = uri.replacePrefix(srcURI, platformResourceURI);\n\t\t\t\tresourceSet.getResource(uriToUse, true);\n\t\t\t}\n\t\t}\n\t\treturn resourceSet;\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void simpleSMAP() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/simple_smap\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information for both Java and Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:16, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.java:18, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:13, XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void _join;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA2.java:7, XtendA.xtend:11\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(xpt.toString(), debugInfo);\n\t}","id":98698,"modified_method":"@Test\n\tpublic void simpleSMAP() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/simple_smap\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information for both Java and Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:16, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void this$0;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.java:18, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:13, XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void _join;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA2.java:7, XtendA.xtend:11\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(debugInfo, xpt.toString(), debugInfo);\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void simpleXtendAsPrimary() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(xpt.toString(), debugInfo);\n\t}","id":98699,"modified_method":"@Test\n\tpublic void simpleXtendAsPrimary() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void this$0;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(debugInfo, xpt.toString(), debugInfo);\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void simpleXtendAsPrimaryWithSyntheticVars() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary_with_synthetic_vars\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(xpt.toString(), debugInfo);\n\t}","id":98700,"modified_method":"@Test\n\tpublic void simpleXtendAsPrimaryWithSyntheticVars() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary_with_synthetic_vars\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void this$0;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(debugInfo, xpt.toString(), debugInfo);\n\t}","commit_id":"ce28802c6ae5a8e19cb70e182bbe1f5d30deda3d","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @since 2.8\n\t */\n\tprotected XtendBatchCompiler getConfiguredBatchCompiler() {\n\t\tXtendBatchCompiler xtend2BatchCompiler = xtendBatchCompilerProvider.get();\n\t\txtend2BatchCompiler.setComplianceLevel(complianceLevel);\n\t\treturn xtend2BatchCompiler;\n\t}","id":98701,"modified_method":"/**\n\t * @since 2.8\n\t */\n\tprotected XtendBatchCompiler getConfiguredBatchCompiler() {\n\t\tXtendBatchCompiler xtend2BatchCompiler = xtendBatchCompilerProvider.get();\n\t\txtend2BatchCompiler.setComplianceLevel(complianceLevel);\n\t\txtend2BatchCompiler.setBasePath(project.getBasedir().getAbsolutePath());\n\t\treturn xtend2BatchCompiler;\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"@Deprecated\n\tprotected XtendBatchCompiler createXtendBatchCompiler() {\n\t\tInjector injector = new XtendMavenStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\tXtendBatchCompiler instance = injector.getInstance(XtendBatchCompiler.class);\n\t\tinstance.setComplianceLevel(complianceLevel);\n\t\treturn instance;\n\t}","id":98702,"modified_method":"@Deprecated\n\tprotected XtendBatchCompiler createXtendBatchCompiler() {\n\t\tInjector injector = new XtendMavenStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\tXtendBatchCompiler instance = injector.getInstance(XtendBatchCompiler.class);\n\t\tinstance.setComplianceLevel(complianceLevel);\n\t\tinstance.setBasePath(project.getBasedir().getAbsolutePath());\n\t\treturn instance;\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ResourceSet loadXtendFiles(final ResourceSet resourceSet) {\n\t\tencodingProvider.setDefaultEncoding(getFileEncoding());\n\t\tfinal NameBasedFilter nameBasedFilter = new NameBasedFilter();\n\t\tnameBasedFilter.setExtension(fileExtensionProvider.getPrimaryFileExtension());\n\t\tPathTraverser pathTraverser = new PathTraverser();\n\t\tList<String> sourcePathDirectories = getSourcePathDirectories();\n\t\tMultimap<String, URI> pathes = pathTraverser.resolvePathes(sourcePathDirectories, new Predicate<URI>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply(URI input) {\n\t\t\t\tboolean matches = nameBasedFilter.matches(input);\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t});\n\t\tfor (String src : pathes.keySet()) {\n\t\t\tURI baseDir = URI.createFileURI(src + \"/\");\n\t\t\tString identifier = Joiner.on(\"_\").join(baseDir.segments());\n\t\t\tURI platformResourceURI = URI.createPlatformResourceURI(identifier + \"/\", true);\n\t\t\tresourceSet.getURIConverter().getURIMap().put(platformResourceURI, baseDir);\n\t\t\tfor (URI uri : pathes.get(src)) {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"load xtend file '\" + uri + \"'\");\n\t\t\t\t}\n\t\t\t\tURI uriToUse = uri.replacePrefix(baseDir, platformResourceURI);\n\t\t\t\tresourceSet.getResource(uriToUse, true);\n\t\t\t}\n\t\t}\n\t\treturn resourceSet;\n\t}","id":98703,"modified_method":"protected ResourceSet loadXtendFiles(final ResourceSet resourceSet) {\n\t\tencodingProvider.setDefaultEncoding(getFileEncoding());\n\t\tfinal NameBasedFilter nameBasedFilter = new NameBasedFilter();\n\t\tnameBasedFilter.setExtension(fileExtensionProvider.getPrimaryFileExtension());\n\t\tPathTraverser pathTraverser = new PathTraverser();\n\t\tList<String> sourcePathDirectories = getSourcePathDirectories();\n\t\tMultimap<String, URI> pathes = pathTraverser.resolvePathes(sourcePathDirectories, new Predicate<URI>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply(URI input) {\n\t\t\t\tboolean matches = nameBasedFilter.matches(input);\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t});\n\t\tfor (String src : pathes.keySet()) {\n\t\t\tURI srcURI = URI.createFileURI(src + \"/\");\n\t\t\tURI relativeSrcURI = null;\n\t\t\tif(baseURI != null) {\n\t\t\t\trelativeSrcURI = srcURI.deresolve(baseURI);\n\t\t\t} else {\n\t\t\t\trelativeSrcURI = srcURI;\n\t\t\t}\n\t\t\tURI platformResourceURI = null;\n\t\t\tif(relativeSrcURI.isRelative()) {\n\t\t\t\tplatformResourceURI = URI.createPlatformResourceURI(relativeSrcURI.toString(), true);\n\t\t\t} else {\n\t\t\t\tString identifier = Joiner.on(\"_\").join(relativeSrcURI.segments());\n\t\t\t\tplatformResourceURI = URI.createPlatformResourceURI(identifier + \"/\", true);\n\t\t\t}\n\t\t\tresourceSet.getURIConverter().getURIMap().put(platformResourceURI, srcURI);\n\t\t\tfor (URI uri : pathes.get(src)) {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"load xtend file '\" + uri + \"'\");\n\t\t\t\t}\n\t\t\t\tURI uriToUse = uri.replacePrefix(srcURI, platformResourceURI);\n\t\t\t\tresourceSet.getResource(uriToUse, true);\n\t\t\t}\n\t\t}\n\t\treturn resourceSet;\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean compile() {\n\t\ttry {\n\t\t\tif (workspaceConfigProvider.getWorkspaceConfig() == null) {\n\t\t\t\tif (!configureWorkspace()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tResourceSet resourceSet = resourceSetProvider.get();\n\t\t\tFile classDirectory = createTempDir(\"classes\");\n\t\t\ttry {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, true);\n\t\t\t\t// install a type provider without index lookup for the first phase\n\t\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, true);\n\t\t\t\tloadXtendFiles(resourceSet);\n\t\t\t\tFile sourceDirectory = createStubs(resourceSet);\n\t\t\t\tif (!preCompileStubs(sourceDirectory, classDirectory)) {\n\t\t\t\t\tlog.debug(\"Compilation of stubs and existing Java code had errors. This is expected and usually is not a probblem.\");\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, false);\n\t\t\t}\n\t\t\t// install a fresh type provider for the second phase, so we clear all previously cached classes and misses.\n\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, false);\n\t\t\tEcoreUtil.resolveAll(resourceSet);\n\t\t\tList<Issue> issues = validate(resourceSet);\n\t\t\tIterable<Issue> errors = Iterables.filter(issues, SeverityFilter.ERROR);\n\t\t\tIterable<Issue> warnings = Iterables.filter(issues, SeverityFilter.WARNING);\n\t\t\treportIssues(Iterables.concat(errors, warnings));\n\t\t\tif (!Iterables.isEmpty(errors)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgenerateJavaFiles(resourceSet);\n\t\t} finally {\n\t\t\tif (isDeleteTempDirectory()) {\n\t\t\t\tdeleteTmpFolders();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":98704,"modified_method":"public boolean compile() {\n\t\ttry {\n\t\t\tif (workspaceConfigProvider.getWorkspaceConfig() == null) {\n\t\t\t\tif (!configureWorkspace()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tResourceSet resourceSet = resourceSetProvider.get();\n\t\t\tFile classDirectory = createTempDir(\"classes\");\n\t\t\ttry {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, true);\n\t\t\t\t// install a type provider without index lookup for the first phase\n\t\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, true);\n\t\t\t\tloadXtendFiles(resourceSet);\n\t\t\t\tFile sourceDirectory = createStubs(resourceSet);\n\t\t\t\tif (!preCompileStubs(sourceDirectory, classDirectory)) {\n\t\t\t\t\tlog.warn(\"Compilation of stubs had errors.\");\n\t\t\t\t}\n\t\t\t\tif (!preCompileJava(sourceDirectory, classDirectory)) {\n\t\t\t\t\tlog.debug(\"Compilation of Java code against stubs had errors. This is expected and usually is not a probblem.\");\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcompilerPhases.setIndexing(resourceSet, false);\n\t\t\t}\n\t\t\t// install a fresh type provider for the second phase, so we clear all previously cached classes and misses.\n\t\t\tinstallJvmTypeProvider(resourceSet, classDirectory, false);\n\t\t\tEcoreUtil.resolveAll(resourceSet);\n\t\t\tList<Issue> issues = validate(resourceSet);\n\t\t\tIterable<Issue> errors = Iterables.filter(issues, SeverityFilter.ERROR);\n\t\t\tIterable<Issue> warnings = Iterables.filter(issues, SeverityFilter.WARNING);\n\t\t\treportIssues(Iterables.concat(errors, warnings));\n\t\t\tif (!Iterables.isEmpty(errors)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgenerateJavaFiles(resourceSet);\n\t\t} finally {\n\t\t\tif (isDeleteTempDirectory()) {\n\t\t\t\tdeleteTmpFolders();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean preCompileStubs(File tmpSourceDirectory, File classDirectory) {\n\t\tList<String> commandLine = Lists.newArrayList();\n\t\t// todo args\n\t\tif (isVerbose()) {\n\t\t\tcommandLine.add(\"-verbose\");\n\t\t}\n\t\tif (!isEmpty(bootClassPath)) {\n\t\t\tcommandLine.add(\"-bootclasspath \\\"\" + concat(File.pathSeparator, getBootClassPathEntries()) + \"\\\"\");\n\t\t}\n\t\tif (!isEmpty(classPath)) {\n\t\t\tcommandLine.add(\"-cp \\\"\" + concat(File.pathSeparator, getClassPathEntries()) + \"\\\"\");\n\t\t}\n\t\tcommandLine.add(\"-d \\\"\" + classDirectory.toString() + \"\\\"\");\n\t\tcommandLine.add(\"-\" + getComplianceLevel());\n\t\tcommandLine.add(\"-proceedOnError\");\n\t\tList<String> sourceDirectories = newArrayList(getSourcePathDirectories());\n\t\tsourceDirectories.add(tmpSourceDirectory.toString());\n\t\tcommandLine.add(concat(\" \", transform(sourceDirectories, new Function<String, String>() {\n\t\t\t@Override\n\t\t\tpublic String apply(String path) {\n\t\t\t\treturn \"\\\"\" + path + \"\\\"\";\n\t\t\t}\n\t\t})));\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"invoke batch compiler with '\" + concat(\" \", commandLine) + \"'\");\n\t\t}\n\t\treturn BatchCompiler.compile(concat(\" \", commandLine), new PrintWriter(getOutputWriter()), new PrintWriter(\n\t\t\t\tgetErrorWriter()), null);\n\t}","id":98705,"modified_method":"/**\n\t * @since 2.8\n\t */\n\tprotected boolean preCompileStubs(File tmpSourceDirectory, File classDirectory) {\n\t\treturn preCompile(tmpSourceDirectory, singletonList(tmpSourceDirectory.toString()), getClassPathEntries());\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void simpleXtendAsPrimaryWithSyntheticVars() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary_with_synthetic_vars\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(xpt.toString(), debugInfo);\n\t}","id":98706,"modified_method":"@Test\n\tpublic void simpleXtendAsPrimaryWithSyntheticVars() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary_with_synthetic_vars\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void this$0;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(debugInfo, xpt.toString(), debugInfo);\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void simpleSMAP() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/simple_smap\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information for both Java and Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:16, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.java:18, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:13, XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void _join;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA2.java:7, XtendA.xtend:11\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(xpt.toString(), debugInfo);\n\t}","id":98707,"modified_method":"@Test\n\tpublic void simpleSMAP() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/simple_smap\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information for both Java and Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:16, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void this$0;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.java:18, XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.java:13, XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void _newArrayList;\\n\");\n\t\txpt.append(\"      void _function;\\n\");\n\t\txpt.append(\"      void _map;\\n\");\n\t\txpt.append(\"      void _join;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA2.java:7, XtendA.xtend:11\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(debugInfo, xpt.toString(), debugInfo);\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void simpleXtendAsPrimary() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(xpt.toString(), debugInfo);\n\t}","id":98708,"modified_method":"@Test\n\tpublic void simpleXtendAsPrimary() throws Exception {\n\t\tVerifier verifier = verifyErrorFreeLog(ROOT + \"/xtend_as_primary\");\n\t\tString xtendGenDir = verifier.getBasedir() + \"/target/classes/test\";\n\t\tString debugInfo = new ClassFileDebugInfoExtractor().getDebugInfo(xtendGenDir);\n\n\t\t// please note that here we have source information only for Xtend\n\t\tStringBuilder xpt = new StringBuilder();\n\t\txpt.append(\"// test {\\n\");\n\t\txpt.append(\"  package test; // XtendA$1.class\\n\");\n\t\txpt.append(\"  class XtendA$1 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void this$0;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"    void apply() { // XtendA.xtend:6\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void it;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA.class\\n\");\n\t\txpt.append(\"  class XtendA {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:4\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"      void myvar;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"  \\n\");\n\t\txpt.append(\"  package test; // XtendA2.class\\n\");\n\t\txpt.append(\"  class XtendA2 {\\n\");\n\t\txpt.append(\"    void <init>() { // XtendA.xtend:12\\n\");\n\t\txpt.append(\"      void this;\\n\");\n\t\txpt.append(\"    }\\n\");\n\t\txpt.append(\"    \\n\");\n\t\txpt.append(\"  }\\n\");\n\t\txpt.append(\"}\");\n\t\tAssert.assertEquals(debugInfo, xpt.toString(), debugInfo);\n\t}","commit_id":"8b5cdbf5ab6fcec2a08f0ad3072f2c0a30e843c0","url":"https://github.com/eclipse/xtext"},{"original_method":"public static boolean isUserReviewerOfLanguage(HLocale lang) {\n        HAccount authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount != null) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.getPerson(), lang, null, true, null);\n        }\n\n        return false; // No authenticated user\n    }","id":98709,"modified_method":"public static boolean isUserReviewerOfLanguage(HLocale lang) {\n        Optional<HAccount> authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount.isPresent()) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.get().getPerson(), lang, null, true, null);\n        } else {\n            return false;\n        }\n\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static final HAccount getAuthenticatedAccount() {\n        return ServiceLocator.instance().getInstance(\n                JpaIdentityStore.AUTHENTICATED_USER, ScopeType.SESSION,\n                HAccount.class);\n    }","id":98710,"modified_method":"private static final Optional<HAccount> getAuthenticatedAccount() {\n        return Optional.fromNullable(ServiceLocator.instance().getInstance(\n                JpaIdentityStore.AUTHENTICATED_USER, ScopeType.SESSION,\n                HAccount.class));\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"@GrantsPermission(actions = \"import-translation\")\n    public static boolean canImportTranslation(\n            HProjectIteration projectIteration) {\n        HPerson authenticatedPerson = getAuthenticatedAccount().getPerson();\n        return authenticatedPerson.isMaintainer(projectIteration.getProject());\n    }","id":98711,"modified_method":"@GrantsPermission(actions = \"import-translation\")\n    public static boolean canImportTranslation(\n            HProjectIteration projectIteration) {\n        Optional<HAccount> account = getAuthenticatedAccount();\n        return account.isPresent() && account.get().getPerson().isMaintainer(projectIteration.getProject());\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static boolean isLanguageTeamMember(HLocale lang) {\n        HAccount authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount != null) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.getPerson(), lang, null, null, null);\n        }\n\n        return false; // No authenticated user\n    }","id":98712,"modified_method":"public static boolean isLanguageTeamMember(HLocale lang) {\n        Optional<HAccount> authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount.isPresent()) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.get().getPerson(), lang, null, null, null);\n        } else {\n            return false;\n        }\n\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"/** Admins and Project maintainers can perform copy-trans */\n    @GrantsPermission(actions = \"copy-trans\")\n    public static boolean canRunCopyTrans(HProjectIteration iteration) {\n        return getAuthenticatedAccount().getPerson().isMaintainer(\n                iteration.getProject());\n    }","id":98713,"modified_method":"/** Admins and Project maintainers can perform copy-trans */\n    @GrantsPermission(actions = \"copy-trans\")\n    public static boolean canRunCopyTrans(HProjectIteration iteration) {\n        Optional<HAccount> account = getAuthenticatedAccount();\n        return account.isPresent() && account.get().getPerson().isMaintainer(iteration.getProject());\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"/***************************************************************************\n     * Version Group rules\n     **************************************************************************/\n    @GrantsPermission(actions = \"update\")\n    public static boolean canUpdateVersionGroup(HIterationGroup group) {\n        return getAuthenticatedAccount().getPerson().isMaintainer(group);\n    }","id":98714,"modified_method":"/***************************************************************************\n     * Version Group rules\n     **************************************************************************/\n    @GrantsPermission(actions = \"update\")\n    public static boolean canUpdateVersionGroup(HIterationGroup group) {\n        Optional<HAccount> account = getAuthenticatedAccount();\n        return account.isPresent() && account.get().getPerson().isMaintainer(group);\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static boolean isUserTranslatorOfLanguage(HLocale lang) {\n        HAccount authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount != null) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.getPerson(), lang, true, null, null);\n        }\n\n        return false; // No authenticated user\n    }","id":98715,"modified_method":"public static boolean isUserTranslatorOfLanguage(HLocale lang) {\n        Optional<HAccount> authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount.isPresent()) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.get().getPerson(), lang, true, null, null);\n        }\n\n        return false; // No authenticated user\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"@GrantsPermission(actions = \"manage-language-team\")\n    public static boolean isUserCoordinatorOfLanguage(HLocale lang) {\n        HAccount authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount != null) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.getPerson(), lang, null, null, true);\n        }\n\n        return false; // No authenticated user\n    }","id":98716,"modified_method":"@GrantsPermission(actions = \"manage-language-team\")\n    public static boolean isUserCoordinatorOfLanguage(HLocale lang) {\n        Optional<HAccount> authenticatedAccount = getAuthenticatedAccount();\n        PersonDAO personDAO =\n                ServiceLocator.instance().getInstance(PersonDAO.class);\n\n        if (authenticatedAccount.isPresent()) {\n            return personDAO.isUserInLanguageTeamWithRoles(\n                    authenticatedAccount.get().getPerson(), lang, null, null, true);\n        } else {\n            return false;\n        }\n\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static boolean isUserAllowedAccess(HProject project) {\n        if (project.isRestrictedByRoles()) {\n            ZanataIdentity identity = getIdentity();\n\n            if (identity != null) {\n                for (HAccountRole role : project.getAllowedRoles()) {\n                    if (identity.hasRole(role.getName())) {\n                        return true;\n                    }\n                }\n            }\n\n            // no access\n            return false;\n        } else {\n            return true;\n        }\n    }","id":98717,"modified_method":"public static boolean isUserAllowedAccess(HProject project) {\n        if (project.isRestrictedByRoles()) {\n            ZanataIdentity identity = getIdentity();\n\n            for (HAccountRole role : project.getAllowedRoles()) {\n                if (identity.hasRole(role.getName())) {\n                    return true;\n                }\n            }\n\n            // no access\n            return false;\n        } else {\n            return true;\n        }\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static boolean isProjectMaintainer(HProject project) {\n        return getAuthenticatedAccount().getPerson().isMaintainer(project);\n    }","id":98718,"modified_method":"public static boolean isProjectMaintainer(HProject project) {\n        Optional<HAccount> account = getAuthenticatedAccount();\n        return account.isPresent() && account.get().getPerson().isMaintainer(project);\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"@GrantsPermission(actions = \"review-comment\")\n    public static boolean canMaintainerCommentOnReview(HLocale locale,\n            HProject project) {\n        return getAuthenticatedAccount().getPerson().isMaintainer(project);\n    }","id":98719,"modified_method":"@GrantsPermission(actions = \"review-comment\")\n    public static boolean canMaintainerCommentOnReview(HLocale locale,\n            HProject project) {\n        Optional<HAccount> account = getAuthenticatedAccount();\n        return account.isPresent() && account.get().getPerson().isMaintainer(project);\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"@GrantsPermission(actions = { \"add-translation\", \"modify-translation\",\n            \"review-translation\", \"translation-review\" })\n    public static boolean canAddOrReviewTranslation(\n            HProject project, HLocale locale) {\n        HAccount authenticatedAccount = getAuthenticatedAccount();\n        return authenticatedAccount != null && isProjectMaintainer(project);\n    }","id":98720,"modified_method":"@GrantsPermission(actions = { \"add-translation\", \"modify-translation\",\n            \"review-translation\", \"translation-review\" })\n    public static boolean canAddOrReviewTranslation(\n            HProject project, HLocale locale) {\n        Optional<HAccount> authenticatedAccount = getAuthenticatedAccount();\n        return authenticatedAccount.isPresent() && isProjectMaintainer(project);\n    }","commit_id":"08f93c993b72c00ef6660f3e6c0a775a42c76252","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void finalize() {\n\t\tzoomLockCheckBox = null;\n\t\tzoomSelButton = null;\n\t\tzoomMapButton = null;\n\t\tfadeSlider = null;\n\t\tfadeLabel = null;\n\t}","id":98721,"modified_method":"public void finalize() {\n\t\tzoomLockCheckBox = null;\n\t\tzoomSelButton = null;\n\t\tzoomMapButton = null;\n\t\tfadeSlider = null;\n\t\tfadeLabel = null;\n\t\tzoomPanel = null;\n\t\tfadePanel = null;\n\t    widgetStack = null;\n\t}","commit_id":"41880ae809c57e873f5b7fb7aa0e474b0daa71ed","url":"https://github.com/VUE/VUE"},{"original_method":"public PrototypePanel(DockWindow dw) {\n\t\tGridBagConstraints\tconstraints = new GridBagConstraints();\n\t\tJPanel\t\t\t\tzoomPanel = new JPanel(),\n\t\t\t\t\t\t\tlinePanel = null,\n\t\t\t\t\t\t\tfadePanel = new JPanel();\n\t\tInsets\t\t\t\thalfGutterInsets = new Insets(HALF_GUTTER, HALF_GUTTER, HALF_GUTTER, HALF_GUTTER);\n\n\t\tsetLayout(new GridBagLayout());\n\t\tzoomPanel.setLayout(new GridBagLayout());\n\t\tfadePanel.setLayout(new GridBagLayout());\n\n\t\tconstraints.fill = GridBagConstraints.HORIZONTAL;\n\t\tconstraints.weightx = 0.0;\n\t\tconstraints.weighty = 0.0;\n\t\tconstraints.gridx = 0;\n\t\tconstraints.gridy = 0;\n\t\tconstraints.gridheight = 1;\n\t\tconstraints.gridwidth = 1;\n\t\tconstraints.insets = halfGutterInsets;\n\t\t\n\t\tzoomSelButton = new JButton();\n\t\tzoomSelButton.setAction(tufts.vue.Actions.ZoomToSelection);\n\t\tzoomPanel.add(zoomSelButton, constraints);\n\n\t\tzoomMapButton = new JButton();\n\t\tzoomMapButton.setAction(tufts.vue.Actions.ZoomFit);\n\t\tconstraints.gridy = 1;\n\t\tzoomPanel.add(zoomMapButton, constraints);\n\n\t\tzoomLockCheckBox = new JCheckBox(\"Lock On\");\n\t\tzoomLockCheckBox.addChangeListener(this);\n\t\tconstraints.gridx = 1;\n\t\tconstraints.gridy = 0;\n\t\tconstraints.gridheight = 2;\n\t\tzoomPanel.add(zoomLockCheckBox, constraints);\n\n\t\tfadeLabel = new JLabel(\"Opacity\");\n\n\t\tconstraints.gridx = 0;\n\t\tconstraints.gridheight = 1;\n\t\tfadePanel.add(fadeLabel, constraints);\n\n\t\tfadeSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, 0);\n\n\t\tJLabel\t\tlabel100 = new JLabel(\"100%\");\n\t\tJLabel\t\tlabel0 = new JLabel(\"0%\");\n\t\tHashtable\tlabelTable = new Hashtable();\n\n\t\tlabelTable.put(new Integer( 0 ), label100);\n\t\tlabelTable.put(new Integer( 100 ), label0);\n\n\t\tfadeSlider.setLabelTable(labelTable);\n\t\tfadeSlider.setPaintLabels(true);\n\t\tfadeSlider.setPaintTicks(false);\n\t\tfadeSlider.setPreferredSize(new Dimension(130,35));\n\t\tfadeSlider.addChangeListener(this);\n\n\t\tconstraints.gridx = 1;\n\t\tfadePanel.add(fadeSlider, constraints);\n\n\t\tconstraints.fill = GridBagConstraints.BOTH;\n\t\tconstraints.weightx = 1.0;\n\t\tconstraints.weighty = 1.0;\n\t\tconstraints.insets = new Insets(HALF_GUTTER, HALF_GUTTER, 0, HALF_GUTTER);\n\t\tadd(zoomPanel, constraints);\n\n\t\tlinePanel = new JPanel() {\n\t\t\tpublic static final long\t\tserialVersionUID = 1;\n\t\t\tprotected void paintComponent(java.awt.Graphics g) {\n\t\t\t\tif (isOpaque()) {\n\t\t\t\t\tg.setColor(getBackground());\n\t\t\t\t\tg.fillRect(0, 0, getWidth(), getHeight());\n\t\t\t\t}\n\n\t\t\t\tg.setColor(java.awt.Color.DARK_GRAY);\n\t\t\t\tg.drawLine(HALF_GUTTER, getHeight() / 2, getWidth() - HALF_GUTTER - 1, getHeight() / 2);\n\t\t\t}\n\t\t};\n\n\t\tconstraints.gridy = 1;\n\t\tconstraints.insets = new Insets(0, HALF_GUTTER, 0, HALF_GUTTER);\n\t\tadd(linePanel, constraints);\n\n\t\tconstraints.gridy = 2;\n\t\tconstraints.insets = new Insets(0, HALF_GUTTER, HALF_GUTTER, HALF_GUTTER);\n\t\tadd(fadePanel, constraints);\n\n\t\tdw.setContent(this);\n\n\t\tvalidate();\n\n\t\tif (DEBUG) {\n\t\t\tzoomLockCheckBox.setBackground(Color.BLUE);\n\t\t\tzoomLockCheckBox.setOpaque(true);\n\t\t\tzoomSelButton.setBackground(Color.BLUE);\n\t\t\tzoomSelButton.setOpaque(true);\n\t\t\tzoomMapButton.setBackground(Color.BLUE);\n\t\t\tzoomMapButton.setOpaque(true);\n\t\t\tfadeLabel.setBackground(Color.BLUE);\n\t\t\tfadeLabel.setOpaque(true);\n\t\t\tfadeSlider.setBackground(Color.BLUE);\n\t\t\tfadeSlider.setOpaque(true);\n\t\t\tzoomPanel.setBackground(Color.ORANGE);\n\t\t\tzoomPanel.setOpaque(true);\n\t\t\tlinePanel.setBackground(Color.ORANGE);\n\t\t\tlinePanel.setOpaque(true);\n\t\t\tfadePanel.setBackground(Color.ORANGE);\n\t\t\tfadePanel.setOpaque(true);\n\t\t}\n\n\t\tsetVisible(true);\n\t}","id":98722,"modified_method":"public PrototypePanel(DockWindow dw) {\n\t\tGridBagConstraints\tconstraints = new GridBagConstraints();\n\t\tInsets\t\t\t\thalfGutterInsets = new Insets(HALF_GUTTER, HALF_GUTTER, HALF_GUTTER, HALF_GUTTER);\n\n\t\tsetLayout(new GridBagLayout());\n\n\t\tconstraints.fill = GridBagConstraints.HORIZONTAL;\n\t\tconstraints.weightx = 0.0;\n\t\tconstraints.weighty = 0.0;\n\t\tconstraints.gridx = 0;\n\t\tconstraints.gridy = 0;\n\t\tconstraints.gridheight = 1;\n\t\tconstraints.gridwidth = 1;\n\t\tconstraints.insets = halfGutterInsets;\n\t\t\n\t\tzoomPanel = new JPanel();\n\t\tzoomPanel.setLayout(new GridBagLayout());\n\n\t\tzoomSelButton = new JButton();\n\t\tzoomSelButton.setAction(tufts.vue.Actions.ZoomToSelection);\n\t\tzoomPanel.add(zoomSelButton, constraints);\n\n\t\tzoomMapButton = new JButton();\n\t\tzoomMapButton.setAction(tufts.vue.Actions.ZoomFit);\n\t\tconstraints.gridy = 1;\n\t\tzoomPanel.add(zoomMapButton, constraints);\n\n\t\tzoomLockCheckBox = new JCheckBox(\"Lock On\");\n\t\tzoomLockCheckBox.addChangeListener(this);\n\t\tconstraints.gridx = 1;\n\t\tconstraints.gridy = 0;\n\t\tconstraints.gridheight = 2;\n\t\tzoomPanel.add(zoomLockCheckBox, constraints);\n\n\t\tfadePanel = new JPanel();\n\t\tfadePanel.setLayout(new GridBagLayout());\n\n\t\tfadeLabel = new JLabel(\"Opacity\");\n\n\t\tconstraints.gridx = 0;\n\t\tconstraints.gridheight = 1;\n\t\tfadePanel.add(fadeLabel, constraints);\n\n\t\tfadeSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, 0);\n\n\t\tJLabel\t\tlabel100 = new JLabel(\"100%\");\n\t\tJLabel\t\tlabel0 = new JLabel(\"0%\");\n\t\tHashtable\tlabelTable = new Hashtable();\n\n\t\tlabelTable.put(new Integer( 0 ), label100);\n\t\tlabelTable.put(new Integer( 100 ), label0);\n\n\t\tfadeSlider.setLabelTable(labelTable);\n\t\tfadeSlider.setPaintLabels(true);\n\t\tfadeSlider.setPaintTicks(false);\n\t\tfadeSlider.setPreferredSize(new Dimension(130,35));\n\t\tfadeSlider.addChangeListener(this);\n\n\t\tconstraints.gridx = 1;\n\t\tfadePanel.add(fadeSlider, constraints);\n\n\t\twidgetStack = new WidgetStack(\"Interaction Tools\");\n\t\twidgetStack.addPane(\"Opacity and Extended Selection\", fadePanel);\n\t\twidgetStack.addPane(\"Zoom\", zoomPanel);\n\t\tdw.setContent(widgetStack);\n\n\t\tvalidate();\n\n\t\tif (DEBUG) {\n\t\t\tzoomLockCheckBox.setBackground(Color.BLUE);\n\t\t\tzoomLockCheckBox.setOpaque(true);\n\t\t\tzoomSelButton.setBackground(Color.BLUE);\n\t\t\tzoomSelButton.setOpaque(true);\n\t\t\tzoomMapButton.setBackground(Color.BLUE);\n\t\t\tzoomMapButton.setOpaque(true);\n\t\t\tfadeLabel.setBackground(Color.BLUE);\n\t\t\tfadeLabel.setOpaque(true);\n\t\t\tfadeSlider.setBackground(Color.BLUE);\n\t\t\tfadeSlider.setOpaque(true);\n\t\t\tzoomPanel.setBackground(Color.ORANGE);\n\t\t\tzoomPanel.setOpaque(true);\n\t\t\tfadePanel.setBackground(Color.ORANGE);\n\t\t\tfadePanel.setOpaque(true);\n\t\t}\n\n\t\tsetVisible(true);\n\t}","commit_id":"41880ae809c57e873f5b7fb7aa0e474b0daa71ed","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"add-site-roles-to-user-groups\");\n\t}","id":98723,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(\n\t\t\tresourceBundle, \"add-site-roles-to-user-groups\");\n\t}","commit_id":"1486eda524e342a3b3cce3fd238e74d2f1fd2205","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"add-site-roles-to-users\");\n\t}","id":98724,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"add-site-roles-to-users\");\n\t}","commit_id":"1486eda524e342a3b3cce3fd238e74d2f1fd2205","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"view-membership-requests\");\n\t}","id":98725,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"view-membership-requests\");\n\t}","commit_id":"1486eda524e342a3b3cce3fd238e74d2f1fd2205","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"configuration-templates\");\n\t}","id":98726,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"configuration-templates\");\n\t}","commit_id":"57c2b600dae7fbee8a278f364517dfc71bc3e513","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"add-to-facebook\");\n\t}","id":98727,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"add-to-facebook\");\n\t}","commit_id":"d58496cd5e62417664491cd7259e89450f641a63","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"add-to-netvibes\");\n\t}","id":98728,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"add-to-netvibes\");\n\t}","commit_id":"d58496cd5e62417664491cd7259e89450f641a63","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"add-to-any-website\");\n\t}","id":98729,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"add-to-any-website\");\n\t}","commit_id":"d58496cd5e62417664491cd7259e89450f641a63","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"look-and-feel-configuration\");\n\t}","id":98730,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"look-and-feel-configuration\");\n\t}","commit_id":"89c7c866f2e5f0b873c311e47ea537e61272c36a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"delete-expired-temporary-files\");\n\t}","id":98731,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(\n\t\t\tresourceBundle, \"delete-expired-temporary-files\");\n\t}","commit_id":"5600e1f73752451556ebf76a72536ebb328129de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"document-types\");\n\t}","id":98732,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"document-types\");\n\t}","commit_id":"5600e1f73752451556ebf76a72536ebb328129de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"metadata-sets\");\n\t}","id":98733,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"metadata-sets\");\n\t}","commit_id":"5600e1f73752451556ebf76a72536ebb328129de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"open-in-ms-office\");\n\t}","id":98734,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"open-in-ms-office\");\n\t}","commit_id":"5600e1f73752451556ebf76a72536ebb328129de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"add-to-igoogle\");\n\t}","id":98735,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(\n\t\t\tresourceBundle, \"add-to-an-open-social-platform\");\n\t}","commit_id":"8fab32e8261c54d3f1d8ca9e58f8127ee3a381ed","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\ttry {\n\t\t\tPortlet portlet = (Portlet)portletRequest.getAttribute(\n\t\t\t\tWebKeys.RENDER_PORTLET);\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)portletRequest.getAttribute(\n\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\treturn \"http://fusion.google.com/add?source=atgs&moduleurl=\" +\n\t\t\t\tPortalUtil.getGoogleGadgetURL(portlet, themeDisplay);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(pe, pe);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","id":98736,"modified_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)portletRequest.getAttribute(\n\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tLiferayPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\tportletRequest,\n\t\t\t\tPortletConfigurationSharingPortletKeys.\n\t\t\t\t\tPORTLET_CONFIGURATION_SHARING,\n\t\t\t\tthemeDisplay.getPlid(), PortletRequest.RENDER_PHASE);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"openSocialURL\", getWidgetURL(portletRequest));\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","commit_id":"8fab32e8261c54d3f1d8ca9e58f8127ee3a381ed","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"export-templates\");\n\t}","id":98737,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"export-templates\");\n\t}","commit_id":"48d45c660624ff9595e8ffd7812c00557a4968d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"publish-templates\");\n\t}","id":98738,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"publish-templates\");\n\t}","commit_id":"48d45c660624ff9595e8ffd7812c00557a4968d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"staging-configuration\");\n\t}","id":98739,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"staging-configuration\");\n\t}","commit_id":"48d45c660624ff9595e8ffd7812c00557a4968d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"export-all-settings\");\n\t}","id":98740,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"export-all-settings\");\n\t}","commit_id":"fa1bb07e20daf3ea014438bc05dd86e230bbe996","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"copy-applications\");\n\t}","id":98741,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"copy-applications\");\n\t}","commit_id":"23de05e477945c279ef01d6e31f81659b512f7e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"embedded-portlets\");\n\t}","id":98742,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"embedded-portlets\");\n\t}","commit_id":"23de05e477945c279ef01d6e31f81659b512f7e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"install-from-url\");\n\t}","id":98743,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"install-from-url\");\n\t}","commit_id":"4c0505c2e8ba4336488e92c6cecfd71054770caa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)),\n\t\t\t\"assign-organization-roles\");\n\t}","id":98744,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"assign-organization-roles\");\n\t}","commit_id":"f2e8f50b78ffc3d8655c66a452e1fa94ec54f2b5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"export-users\");\n\t}","id":98745,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"export-users\");\n\t}","commit_id":"f2e8f50b78ffc3d8655c66a452e1fa94ec54f2b5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"manage-site\");\n\t}","id":98746,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"manage-site\");\n\t}","commit_id":"f2e8f50b78ffc3d8655c66a452e1fa94ec54f2b5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), \"edit-web-content\");\n\t}","id":98747,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tResourceBundle resourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", getLocale(portletRequest), getClass());\n\n\t\treturn LanguageUtil.get(resourceBundle, \"edit-web-content\");\n\t}","commit_id":"cf791852597479b7b205c3d756925c5832326767","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public Dimension getPreferredSize() {\n    return myAnchor == null || myAnchor == this ? super.getPreferredSize() : myAnchor.getPreferredSize();\n  }","id":98748,"modified_method":"@Override\n  public Dimension getPreferredSize() {\n    if (myAnchor != null && myAnchor != this) return myAnchor.getPreferredSize();\n    if (myEditorPane != null) return getLayout().preferredLayoutSize(this);\n    return super.getPreferredSize();\n  }","commit_id":"d6b8765dc657eea604a3bb6e4a4571c8ba728dcc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Dimension getMinimumSize() {\n    return myAnchor == null || myAnchor == this ? super.getMinimumSize() : myAnchor.getMinimumSize();\n  }","id":98749,"modified_method":"@Override\n  public Dimension getMinimumSize() {\n    if (myAnchor != null && myAnchor != this) return myAnchor.getMinimumSize();\n    if (myEditorPane != null) return getLayout().minimumLayoutSize(this);\n    return super.getMinimumSize();\n  }","commit_id":"d6b8765dc657eea604a3bb6e4a4571c8ba728dcc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testGridBagLayout() throws Exception {\n    JPanel panel = (JPanel) getInstrumentedRootComponent(\"TestGridBag.form\", \"BindingTest.class\");\n    assertTrue(panel.getLayout() instanceof GridBagLayout);\n    GridBagLayout gridBag = (GridBagLayout) panel.getLayout();\n    JButton btn = (JButton) panel.getComponent(0);\n    GridBagConstraints gbc = gridBag.getConstraints(btn);\n    assertNotNull(gbc);\n    assertEquals(2, gbc.gridheight);\n    assertEquals(2, gbc.gridwidth);\n    assertEquals(1.0, gbc.weightx, 0.01);\n    assertEquals(new Insets(1, 2, 3, 4), gbc.insets);\n  }","id":98750,"modified_method":"public void testGridBagLayout() throws Exception {\n    JPanel panel = (JPanel) getInstrumentedRootComponent(\"TestGridBag.form\", \"BindingTest.class\");\n    assertTrue(panel.getLayout() instanceof GridBagLayout);\n    GridBagLayout gridBag = (GridBagLayout) panel.getLayout();\n    JButton btn = (JButton) panel.getComponent(0);\n    GridBagConstraints gbc = gridBag.getConstraints(btn);\n    assertNotNull(gbc);\n    assertEquals(2, gbc.gridheight);\n    assertEquals(2, gbc.gridwidth);\n    assertEquals(1.0, gbc.weightx, 0.01);\n    assertEquals(new Insets(1, 2, 3, 4), gbc.insets);\n    assertEquals(new Dimension(21, 24), btn.getMinimumSize());\n    assertEquals(new Dimension(23, 24), btn.getPreferredSize());\n    assertEquals(new Dimension(25, 26), btn.getMaximumSize());\n  }","commit_id":"45b6f4fbf598d415d18c73ff5f90035fc97594a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Result convert(final JComponent component, final GridConstraints constraints) {\n    final Result result = new Result(component);\n    result.constraints.gridx = constraints.getColumn();\n    result.constraints.gridy = constraints.getRow();\n    result.constraints.gridwidth = constraints.getColSpan();\n    result.constraints.gridheight = constraints.getRowSpan();\n    result.constraints.weightx = getWeight(constraints, true);\n    result.constraints.weighty = getWeight(constraints, false);\n    result.constraints.insets = myInsets;\n    switch(constraints.getFill()) {\n      case GridConstraints.FILL_HORIZONTAL: result.constraints.fill = GridBagConstraints.HORIZONTAL; break;\n      case GridConstraints.FILL_VERTICAL: result.constraints.fill = GridBagConstraints.VERTICAL; break;\n      case GridConstraints.FILL_BOTH: result.constraints.fill = GridBagConstraints.BOTH; break;\n    }\n\n    Dimension minSize = new Dimension(component == null ? constraints.myMinimumSize : component.getMinimumSize());\n    if ((constraints.getHSizePolicy() & GridConstraints.SIZEPOLICY_CAN_SHRINK) == 0) {\n      minSize.width = constraints.myPreferredSize.width >= 0 || component == null\n                      ? constraints.myPreferredSize.width\n                      : component.getPreferredSize().width;\n    }\n    if ((constraints.getVSizePolicy() & GridConstraints.SIZEPOLICY_CAN_SHRINK) == 0) {\n      minSize.height = constraints.myPreferredSize.height >= 0 || component == null\n                       ? constraints.myPreferredSize.height\n                       : component.getPreferredSize().height;\n    }\n\n    if (minSize.width != -1 || minSize.height != -1) {\n      result.minimumSize = minSize;\n    }\n\n    return result;\n  }","id":98751,"modified_method":"private Result convert(final JComponent component, final GridConstraints constraints) {\n    final Result result = new Result(component);\n    result.constraints.gridx = constraints.getColumn();\n    result.constraints.gridy = constraints.getRow();\n    result.constraints.gridwidth = constraints.getColSpan();\n    result.constraints.gridheight = constraints.getRowSpan();\n    result.constraints.weightx = getWeight(constraints, true);\n    result.constraints.weighty = getWeight(constraints, false);\n    result.constraints.insets = myInsets;\n    switch(constraints.getFill()) {\n      case GridConstraints.FILL_HORIZONTAL: result.constraints.fill = GridBagConstraints.HORIZONTAL; break;\n      case GridConstraints.FILL_VERTICAL: result.constraints.fill = GridBagConstraints.VERTICAL; break;\n      case GridConstraints.FILL_BOTH: result.constraints.fill = GridBagConstraints.BOTH; break;\n    }\n\n    Dimension minSize = constraints.myMinimumSize;\n    if (component != null && minSize.width <= 0 && minSize.height <= 0) {\n      minSize = component.getMinimumSize();\n    }\n\n    if ((constraints.getHSizePolicy() & GridConstraints.SIZEPOLICY_CAN_SHRINK) == 0) {\n      minSize.width = constraints.myPreferredSize.width > 0 || component == null\n                      ? constraints.myPreferredSize.width\n                      : component.getPreferredSize().width;\n    }\n    if ((constraints.getVSizePolicy() & GridConstraints.SIZEPOLICY_CAN_SHRINK) == 0) {\n      minSize.height = constraints.myPreferredSize.height > 0 || component == null\n                       ? constraints.myPreferredSize.height\n                       : component.getPreferredSize().height;\n    }\n\n    if (minSize.width != -1 || minSize.height != -1) {\n      result.minimumSize = minSize;\n    }\n\n    if (constraints.myPreferredSize.width > 0 && constraints.myPreferredSize.height > 0) {\n      result.preferredSize = constraints.myPreferredSize;\n    }\n    if (constraints.myMaximumSize.width > 0 && constraints.myMaximumSize.height > 0) {\n      result.maximumSize = constraints.myMaximumSize;\n    }\n\n    return result;\n  }","commit_id":"45b6f4fbf598d415d18c73ff5f90035fc97594a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void applyConversionResults(final JPanel panel, final GridBagConverter converter) {\n    GridBagConverter.Result[] results = converter.convert();\n    for(int i=0; i<results.length; i++)  {\n      GridBagConverter.Result result = results [i];\n      if (result.minimumSize != null) {\n        result.component.setMinimumSize(result.minimumSize);\n      }\n      panel.add(result.component, result.constraints);\n    }\n  }","id":98752,"modified_method":"private void applyConversionResults(final JPanel panel, final GridBagConverter converter) {\n    GridBagConverter.Result[] results = converter.convert();\n    for(int i=0; i<results.length; i++)  {\n      GridBagConverter.Result result = results [i];\n      if (result.minimumSize != null) {\n        result.component.setMinimumSize(result.minimumSize);\n      }\n      if (result.preferredSize != null) {\n        result.component.setPreferredSize(result.preferredSize);\n      }\n      panel.add(result.component, result.constraints);\n    }\n  }","commit_id":"45b6f4fbf598d415d18c73ff5f90035fc97594a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void generateComponentLayout(final LwComponent lwComponent,\n                                      final GeneratorAdapter generator,\n                                      final int componentLocal,\n                                      final int parentLocal) {\n    GridBagConverter.Result result = (GridBagConverter.Result) myIdToConstraintsMap.get(lwComponent.getId());\n    if (result != null) {\n      int gbcLocal = generator.newLocal(myGridBagConstraintsType);\n\n      generator.newInstance(myGridBagConstraintsType);\n      generator.dup();\n      generator.invokeConstructor(myGridBagConstraintsType, Method.getMethod(\"void <init> ()\"));\n      generator.storeLocal(gbcLocal);\n\n      GridBagConstraints defaults = new GridBagConstraints();\n      GridBagConstraints constraints = result.constraints;\n      if (defaults.gridx != constraints.gridx) {\n        setIntField(generator, gbcLocal, \"gridx\", constraints.gridx);\n      }\n      if (defaults.gridy != constraints.gridy) {\n        setIntField(generator, gbcLocal, \"gridy\", constraints.gridy);\n      }\n      if (defaults.gridwidth != constraints.gridwidth) {\n        setIntField(generator, gbcLocal, \"gridwidth\", constraints.gridwidth);\n      }\n      if (defaults.gridheight != constraints.gridheight) {\n        setIntField(generator, gbcLocal, \"gridheight\", constraints.gridheight);\n      }\n      if (defaults.weightx != constraints.weightx) {\n        setDoubleField(generator, gbcLocal, \"weightx\", constraints.weightx);\n      }\n      if (defaults.weighty != constraints.weighty) {\n        setDoubleField(generator, gbcLocal, \"weighty\", constraints.weighty);\n      }\n      if (defaults.anchor != constraints.anchor) {\n        setIntField(generator, gbcLocal, \"anchor\", constraints.anchor);\n      }\n      if (defaults.fill != constraints.fill) {\n        setIntField(generator, gbcLocal, \"fill\", constraints.fill);\n      }\n      if (defaults.ipadx != constraints.ipadx) {\n        setIntField(generator, gbcLocal, \"ipadx\", constraints.ipadx);\n      }\n      if (defaults.ipady != constraints.ipady) {\n        setIntField(generator, gbcLocal, \"ipady\", constraints.ipady);\n      }\n      if (!defaults.insets.equals(constraints.insets)) {\n        generator.loadLocal(gbcLocal);\n        AsmCodeGenerator.pushPropValue(generator, \"java.awt.Insets\", constraints.insets);\n        generator.putField(myGridBagConstraintsType, \"insets\", Type.getType(Insets.class));\n      }\n\n      generator.loadLocal(parentLocal);\n      generator.loadLocal(componentLocal);\n      generator.loadLocal(gbcLocal);\n\n      generator.invokeVirtual(Type.getType(Container.class), Method.getMethod(\"void add(java.awt.Component,java.lang.Object)\"));\n    }\n  }","id":98753,"modified_method":"public void generateComponentLayout(final LwComponent lwComponent,\n                                      final GeneratorAdapter generator,\n                                      final int componentLocal,\n                                      final int parentLocal) {\n    GridBagConverter.Result result = (GridBagConverter.Result) myIdToConstraintsMap.get(lwComponent.getId());\n    if (result != null) {\n      checkSetSize(generator, componentLocal, \"setMinimumSize\", result.minimumSize);\n      checkSetSize(generator, componentLocal, \"setPreferredSize\", result.preferredSize);\n      checkSetSize(generator, componentLocal, \"setMaximumSize\", result.maximumSize);\n\n      int gbcLocal = generator.newLocal(myGridBagConstraintsType);\n\n      generator.newInstance(myGridBagConstraintsType);\n      generator.dup();\n      generator.invokeConstructor(myGridBagConstraintsType, Method.getMethod(\"void <init> ()\"));\n      generator.storeLocal(gbcLocal);\n\n      GridBagConstraints defaults = new GridBagConstraints();\n      GridBagConstraints constraints = result.constraints;\n      if (defaults.gridx != constraints.gridx) {\n        setIntField(generator, gbcLocal, \"gridx\", constraints.gridx);\n      }\n      if (defaults.gridy != constraints.gridy) {\n        setIntField(generator, gbcLocal, \"gridy\", constraints.gridy);\n      }\n      if (defaults.gridwidth != constraints.gridwidth) {\n        setIntField(generator, gbcLocal, \"gridwidth\", constraints.gridwidth);\n      }\n      if (defaults.gridheight != constraints.gridheight) {\n        setIntField(generator, gbcLocal, \"gridheight\", constraints.gridheight);\n      }\n      if (defaults.weightx != constraints.weightx) {\n        setDoubleField(generator, gbcLocal, \"weightx\", constraints.weightx);\n      }\n      if (defaults.weighty != constraints.weighty) {\n        setDoubleField(generator, gbcLocal, \"weighty\", constraints.weighty);\n      }\n      if (defaults.anchor != constraints.anchor) {\n        setIntField(generator, gbcLocal, \"anchor\", constraints.anchor);\n      }\n      if (defaults.fill != constraints.fill) {\n        setIntField(generator, gbcLocal, \"fill\", constraints.fill);\n      }\n      if (defaults.ipadx != constraints.ipadx) {\n        setIntField(generator, gbcLocal, \"ipadx\", constraints.ipadx);\n      }\n      if (defaults.ipady != constraints.ipady) {\n        setIntField(generator, gbcLocal, \"ipady\", constraints.ipady);\n      }\n      if (!defaults.insets.equals(constraints.insets)) {\n        generator.loadLocal(gbcLocal);\n        AsmCodeGenerator.pushPropValue(generator, \"java.awt.Insets\", constraints.insets);\n        generator.putField(myGridBagConstraintsType, \"insets\", Type.getType(Insets.class));\n      }\n\n      generator.loadLocal(parentLocal);\n      generator.loadLocal(componentLocal);\n      generator.loadLocal(gbcLocal);\n\n      generator.invokeVirtual(Type.getType(Container.class), Method.getMethod(\"void add(java.awt.Component,java.lang.Object)\"));\n    }\n  }","commit_id":"45b6f4fbf598d415d18c73ff5f90035fc97594a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"PropertyInspectorTable(final GuiEditor editor,final ComponentTree componentTree){\n    LOG.assertTrue(editor != null);\n    LOG.assertTrue(componentTree != null);\n\n    myClassToBindProperty = new ClassToBindProperty(editor);\n    myBindingProperty = new BindingProperty(editor);\n    myBorderProperty = new BorderProperty();\n    myMarginProperty = new MarginProperty();\n    myHGapProperty = new HGapProperty();\n    myVGapProperty = new VGapProperty();\n    mySameSizeHorizontallyProperty = new SameSizeHorizontallyProperty();\n    mySameSizeVerticallyProperty = new SameSizeVerticallyProperty();\n    myHSizePolicyProperty = new HSizePolicyProperty();\n    myVSizePolicyProperty = new VSizePolicyProperty();\n    myFillProperty = new FillProperty();\n    myAnchorProperty = new AnchorProperty();\n    myRowSpanProperty = new RowSpanProperty();\n    myColumnSpanProperty = new ColumnSpanProperty();\n    myMinimumSizeProperty = new MinimumSizeProperty();\n    myPreferredSizeProperty = new PreferredSizeProperty();\n    myMaximumSizeProperty = new MaximumSizeProperty();\n\n    myEditor = editor;\n    myPropertyEditorListener = new MyPropertyEditorListener();\n    myLafManagerListener = new MyLafManagerListener();\n    myComponentTree=componentTree;\n    myProperties = new ArrayList<Property>();\n    myExpandedProperties = new HashSet<Property>();\n    myModel = new MyModel();\n    setModel(myModel);\n    setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    myCellRenderer = new MyCompositeTableCellRenderer();\n    myCellEditor = new MyCellEditor();\n\n    addMouseListener(new MyMouseListener());\n\n    final AnAction quickJavadocAction = ActionManager.getInstance().getAction(IdeActions.ACTION_QUICK_JAVADOC);\n    new ShowJavadocAction().registerCustomShortcutSet(\n      quickJavadocAction.getShortcutSet(), this\n    );\n\n    // Popup menu\n    PopupHandler.installPopupHandler(\n      this,\n      (ActionGroup)ActionManager.getInstance().getAction(IdeActions.GROUP_GUI_DESIGNER_PROPERTY_INSPECTOR_POPUP),\n      ActionPlaces.GUI_DESIGNER_PROPERTY_INSPECTOR_POPUP, ActionManager.getInstance());\n  }","id":98754,"modified_method":"PropertyInspectorTable(final GuiEditor editor,final ComponentTree componentTree){\n    LOG.assertTrue(editor != null);\n    LOG.assertTrue(componentTree != null);\n\n    myClassToBindProperty = new ClassToBindProperty(editor);\n    myBindingProperty = new BindingProperty(editor);\n    myBorderProperty = new BorderProperty();\n    myMarginProperty = new MarginProperty();\n    myHGapProperty = new HGapProperty();\n    myVGapProperty = new VGapProperty();\n    mySameSizeHorizontallyProperty = new SameSizeHorizontallyProperty();\n    mySameSizeVerticallyProperty = new SameSizeVerticallyProperty();\n    myHSizePolicyProperty = new HSizePolicyProperty();\n    myVSizePolicyProperty = new VSizePolicyProperty();\n    myFillProperty = new FillProperty();\n    myAnchorProperty = new AnchorProperty();\n    myRowSpanProperty = new RowSpanProperty();\n    myColumnSpanProperty = new ColumnSpanProperty();\n    myMinimumSizeProperty = new MinimumSizeProperty();\n    myPreferredSizeProperty = new PreferredSizeProperty();\n    myMaximumSizeProperty = new MaximumSizeProperty();\n    myLayoutManagerProperty = new LayoutManagerProperty();\n\n    myEditor = editor;\n    myPropertyEditorListener = new MyPropertyEditorListener();\n    myLafManagerListener = new MyLafManagerListener();\n    myComponentTree=componentTree;\n    myProperties = new ArrayList<Property>();\n    myExpandedProperties = new HashSet<Property>();\n    myModel = new MyModel();\n    setModel(myModel);\n    setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    myCellRenderer = new MyCompositeTableCellRenderer();\n    myCellEditor = new MyCellEditor();\n\n    addMouseListener(new MyMouseListener());\n\n    final AnAction quickJavadocAction = ActionManager.getInstance().getAction(IdeActions.ACTION_QUICK_JAVADOC);\n    new ShowJavadocAction().registerCustomShortcutSet(\n      quickJavadocAction.getShortcutSet(), this\n    );\n\n    // Popup menu\n    PopupHandler.installPopupHandler(\n      this,\n      (ActionGroup)ActionManager.getInstance().getAction(IdeActions.GROUP_GUI_DESIGNER_PROPERTY_INSPECTOR_POPUP),\n      ActionPlaces.GUI_DESIGNER_PROPERTY_INSPECTOR_POPUP, ActionManager.getInstance());\n  }","commit_id":"45b6f4fbf598d415d18c73ff5f90035fc97594a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Populates result list with the properties available for the specified\n   * component\n   */\n  private void collectProperties(final RadComponent component, final ArrayList<Property> result) {\n    if (component instanceof RadRootContainer){\n      result.add(myClassToBindProperty);\n    }\n    else {\n      final boolean isVSpacer = component instanceof RadVSpacer;\n      final boolean isHSpacer = component instanceof RadHSpacer;\n      final boolean isSpacer = isVSpacer || isHSpacer;\n\n      if (!isSpacer){\n        result.add(myBindingProperty);\n      }\n\n      final RadContainer parent = component.getParent();\n      final boolean inGrid = parent != null && parent.isGrid();\n\n      if(component instanceof RadContainer){\n        result.add(myBorderProperty);\n      }\n      if (component instanceof RadContainer && ((RadContainer)component).isGrid()) {\n        result.add(myMarginProperty);\n      }\n\n      if (component instanceof RadContainer && ((RadContainer)component).getLayout() instanceof AbstractLayout){\n        result.add(myHGapProperty);\n        result.add(myVGapProperty);\n      }\n\n      if (component instanceof RadContainer && ((RadContainer)component).isGrid()) {\n        result.add(mySameSizeHorizontallyProperty);\n        result.add(mySameSizeVerticallyProperty);\n      }\n\n      if (inGrid) {\n        if (!isVSpacer){\n          result.add(myHSizePolicyProperty);\n        }\n        if (!isHSpacer){\n          result.add(myVSizePolicyProperty);\n        }\n        if (!isSpacer){\n          result.add(myFillProperty);\n          result.add(myAnchorProperty);\n        }\n        if (myRowSpanProperty.appliesTo(component)){\n          result.add(myRowSpanProperty);\n        }\n        if (myColumnSpanProperty.appliesTo(component)){\n          result.add(myColumnSpanProperty);\n        }\n        result.add(myMinimumSizeProperty);\n        result.add(myPreferredSizeProperty);\n        result.add(myMaximumSizeProperty);\n      }\n\n      if (!isSpacer && !(component instanceof RadErrorComponent)){\n        final Class componentClass = component.getComponentClass();\n        final Property[] introspectedProperties =\n          Palette.getInstance(myEditor.getProject()).getIntrospectedProperties(componentClass);\n        final Properties properties = Properties.getInstance();\n        for (final Property property: introspectedProperties) {\n          if (!myShowExpertProperties && properties.isExpertProperty(componentClass, property.getName())) {\n            continue;\n          }\n          result.add(property);\n        }\n      }\n    }\n  }","id":98755,"modified_method":"/**\n   * Populates result list with the properties available for the specified\n   * component\n   */\n  private void collectProperties(final RadComponent component, final ArrayList<Property> result) {\n    if (component instanceof RadRootContainer){\n      result.add(myClassToBindProperty);\n      result.add(myLayoutManagerProperty);      \n    }\n    else {\n      final boolean isVSpacer = component instanceof RadVSpacer;\n      final boolean isHSpacer = component instanceof RadHSpacer;\n      final boolean isSpacer = isVSpacer || isHSpacer;\n\n      if (!isSpacer){\n        result.add(myBindingProperty);\n      }\n\n      final RadContainer parent = component.getParent();\n      final boolean inGrid = parent != null && parent.isGrid();\n\n      if(component instanceof RadContainer){\n        result.add(myBorderProperty);\n      }\n      if (component instanceof RadContainer && ((RadContainer)component).isGrid()) {\n        result.add(myMarginProperty);\n      }\n\n      if (component instanceof RadContainer && ((RadContainer)component).getLayout() instanceof AbstractLayout){\n        result.add(myHGapProperty);\n        result.add(myVGapProperty);\n      }\n\n      if (component instanceof RadContainer && ((RadContainer)component).isGrid()) {\n        result.add(mySameSizeHorizontallyProperty);\n        result.add(mySameSizeVerticallyProperty);\n      }\n\n      if (inGrid) {\n        if (!isVSpacer){\n          result.add(myHSizePolicyProperty);\n        }\n        if (!isHSpacer){\n          result.add(myVSizePolicyProperty);\n        }\n        if (!isSpacer){\n          result.add(myFillProperty);\n          result.add(myAnchorProperty);\n        }\n        if (myRowSpanProperty.appliesTo(component)){\n          result.add(myRowSpanProperty);\n        }\n        if (myColumnSpanProperty.appliesTo(component)){\n          result.add(myColumnSpanProperty);\n        }\n        result.add(myMinimumSizeProperty);\n        result.add(myPreferredSizeProperty);\n        result.add(myMaximumSizeProperty);\n      }\n\n      if (!isSpacer && !(component instanceof RadErrorComponent)){\n        final Class componentClass = component.getComponentClass();\n        final Property[] introspectedProperties =\n          Palette.getInstance(myEditor.getProject()).getIntrospectedProperties(componentClass);\n        final Properties properties = Properties.getInstance();\n        for (final Property property: introspectedProperties) {\n          if (!myShowExpertProperties && properties.isExpertProperty(componentClass, property.getName())) {\n            continue;\n          }\n          result.add(property);\n        }\n      }\n    }\n  }","commit_id":"45b6f4fbf598d415d18c73ff5f90035fc97594a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean prepareToInstall(ProgressIndicator pi) throws IOException {\n    File oldFile = null;\n    if (PluginManager.isPluginInstalled(PluginId.getId(myPluginId))) {\n      //store old plugins file\n      final IdeaPluginDescriptor ideaPluginDescriptor = PluginManager.getPlugin(PluginId.getId(myPluginId));\n      LOG.assertTrue(ideaPluginDescriptor != null);\n      if (myPluginVersion != null && IdeaPluginDescriptorImpl.compareVersion(ideaPluginDescriptor.getVersion(), myPluginVersion) >= 0) return false;\n      oldFile = ideaPluginDescriptor.getPath();\n    }\n    // download plugin\n    File file;\n    String errorMessage = IdeBundle.message(\"unknown.error\");\n    try {\n      file = downloadPlugin(pi);\n    }\n    catch (IOException ex) {\n      file = null;\n      errorMessage = ex.getMessage();\n    }\n    if (file == null) {\n      final String errorMessage1 = errorMessage;\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          Messages.showErrorDialog(IdeBundle.message(\"error.plugin.was.not.installed\", getPluginName(), errorMessage1),\n                                   IdeBundle.message(\"title.failed.to.download\"));\n        }\n      });\n      return false;\n    }\n\n    if (oldFile != null) {\n      // add command to delete the 'action script' file\n      StartupActionScriptManager.ActionCommand deleteOld = new StartupActionScriptManager.DeleteCommand(oldFile);\n      StartupActionScriptManager.addActionCommand(deleteOld);\n    }\n\n    //noinspection HardCodedStringLiteral\n    if (file.getName().endsWith(\".jar\")) {\n      // add command to copy file to the IDEA/plugins path\n      StartupActionScriptManager.ActionCommand copyPlugin =\n        new StartupActionScriptManager.CopyCommand(file, new File(PathManager.getPluginsPath() + File.separator + file.getName()));\n      StartupActionScriptManager.addActionCommand(copyPlugin);\n    }\n    else {\n      // add command to unzip file to the IDEA/plugins path\n      String unzipPath;\n      if (ZipUtil.isZipContainsFolder(file)) {\n        unzipPath = PathManager.getPluginsPath();\n      }\n      else {\n        unzipPath = PathManager.getPluginsPath() + File.separator + getPluginName();\n      }\n\n      StartupActionScriptManager.ActionCommand unzip = new StartupActionScriptManager.UnzipCommand(file, new File(unzipPath));\n      StartupActionScriptManager.addActionCommand(unzip);\n    }\n\n    // add command to remove temp plugin file\n    StartupActionScriptManager.ActionCommand deleteTemp = new StartupActionScriptManager.DeleteCommand(file);\n    StartupActionScriptManager.addActionCommand(deleteTemp);\n    return true;\n  }","id":98756,"modified_method":"public boolean prepareToInstall(ProgressIndicator pi) throws IOException {\n    File oldFile = null;\n    IdeaPluginDescriptor ideaPluginDescriptor = null;\n    if (PluginManager.isPluginInstalled(PluginId.getId(myPluginId))) {\n      //store old plugins file\n      ideaPluginDescriptor = PluginManager.getPlugin(PluginId.getId(myPluginId));\n      LOG.assertTrue(ideaPluginDescriptor != null);\n      if (myPluginVersion != null && IdeaPluginDescriptorImpl.compareVersion(ideaPluginDescriptor.getVersion(), myPluginVersion) >= 0) return false;\n      oldFile = ideaPluginDescriptor.getPath();\n    }\n    // download plugin\n    File file;\n    String errorMessage = IdeBundle.message(\"unknown.error\");\n    try {\n      file = downloadPlugin(pi);\n    }\n    catch (IOException ex) {\n      file = null;\n      errorMessage = ex.getMessage();\n    }\n    if (file == null) {\n      final String errorMessage1 = errorMessage;\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          Messages.showErrorDialog(IdeBundle.message(\"error.plugin.was.not.installed\", getPluginName(), errorMessage1),\n                                   IdeBundle.message(\"title.failed.to.download\"));\n        }\n      });\n      return false;\n    }\n\n    if (ideaPluginDescriptor != null) {\n      final IdeaPluginDescriptorImpl descriptor = PluginManager.loadDescriptorFromJar(file);\n      if (descriptor == null) return false;\n      if (IdeaPluginDescriptorImpl.compareVersion(ideaPluginDescriptor.getVersion(), descriptor.getVersion()) >= 0) return false; //was not updated\n      if (oldFile != null) {\n        // add command to delete the 'action script' file\n        StartupActionScriptManager.ActionCommand deleteOld = new StartupActionScriptManager.DeleteCommand(oldFile);\n        StartupActionScriptManager.addActionCommand(deleteOld);\n      }\n    }\n\n    //noinspection HardCodedStringLiteral\n    if (file.getName().endsWith(\".jar\")) {\n      // add command to copy file to the IDEA/plugins path\n      StartupActionScriptManager.ActionCommand copyPlugin =\n        new StartupActionScriptManager.CopyCommand(file, new File(PathManager.getPluginsPath() + File.separator + file.getName()));\n      StartupActionScriptManager.addActionCommand(copyPlugin);\n    }\n    else {\n      // add command to unzip file to the IDEA/plugins path\n      String unzipPath;\n      if (ZipUtil.isZipContainsFolder(file)) {\n        unzipPath = PathManager.getPluginsPath();\n      }\n      else {\n        unzipPath = PathManager.getPluginsPath() + File.separator + getPluginName();\n      }\n\n      StartupActionScriptManager.ActionCommand unzip = new StartupActionScriptManager.UnzipCommand(file, new File(unzipPath));\n      StartupActionScriptManager.addActionCommand(unzip);\n    }\n\n    // add command to remove temp plugin file\n    StartupActionScriptManager.ActionCommand deleteTemp = new StartupActionScriptManager.DeleteCommand(file);\n    StartupActionScriptManager.addActionCommand(deleteTemp);\n    return true;\n  }","commit_id":"3ed14370984c7a3fd027c1a2c27b1795acb1939a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Makes sure that all the dependencies exist, and then accept optional dependencies\n     * as real dependencies.\n     *\n     * @throws IOException\n     *             thrown if one or several mandatory dependencies doesn't exists.\n     */\n    /*package*/ void resolvePluginDependencies() throws IOException {\n        List<String> missingDependencies = new ArrayList<String>();\n        // make sure dependencies exist\n        for (Dependency d : dependencies) {\n            if (parent.getPlugin(d.shortName) == null)\n                missingDependencies.add(d.toString());\n        }\n        if (!missingDependencies.isEmpty())\n            throw new IOException(\"Dependency \"+Util.join(missingDependencies, \", \")+\" doesn't exist\");\n\n        // add the optional dependencies that exists\n        for (Dependency d : optionalDependencies) {\n            if (parent.getPlugin(d.shortName) != null)\n                dependencies.add(d);\n        }\n    }","id":98757,"modified_method":"/**\n     * Makes sure that all the dependencies exist, and then accept optional dependencies\n     * as real dependencies.\n     *\n     * @throws IOException\n     *             thrown if one or several mandatory dependencies doesn't exists.\n     */\n    /*package*/ void resolvePluginDependencies() throws IOException {\n        List<String> missingDependencies = new ArrayList<String>();\n        List<String> incompatibleDependencies = new ArrayList<String>();\n        // make sure dependencies exist\n        for (Dependency d : dependencies) {\n            PluginWrapper plugin = parent.getPlugin(d.shortName);\n            if (plugin == null || plugin.isActive()) {\n                missingDependencies.add(d.toString());\n            } else if (new VersionNumber(plugin.getVersion()).isOlderThan(new VersionNumber(d.version))) {\n                incompatibleDependencies.add(d.toString());\n            }\n        }\n\n        // add the optional dependencies that exists\n        for (Dependency d : optionalDependencies) {\n            PluginWrapper plugin = parent.getPlugin(d.shortName);\n            if (plugin != null) {\n                dependencies.add(d);\n            } else if (new VersionNumber(plugin.getVersion()).isOlderThan(new VersionNumber(d.version))) {\n                incompatibleDependencies.add(d.toString());\n            }\n        }\n\n        if (!missingDependencies.isEmpty())\n            throw new IOException(\"Dependency \"+Util.join(missingDependencies, \", \")+\" doesn't exist\");\n\n        if (!incompatibleDependencies.isEmpty())\n            throw new IOException(\"Dependency \"+Util.join(incompatibleDependencies, \", \")+\" doesn't match required version\");\n\n    }","commit_id":"2d40b7e7e9f5f6cd669cb0e3ba8625d05795dabe","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n  public String getRoleName() {\n    return getLinkDescriptor().getName();\n  }","id":98758,"modified_method":"@Override\n  public String getRoleName() {\n    LinkDescriptor d = getLinkDescriptor();\n    if (d == null) {\n      //invalid property, needed for propertyRead event in SNode until event is rewritten\n      return myName;\n    }\n    return d.getName();\n  }","commit_id":"ac571c61c2fadf7e055545d8eeef8d81eca42529","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String getRoleName() {\n    return getReferenceDescriptor().getName();\n  }","id":98759,"modified_method":"@Override\n  public String getRoleName() {\n    ReferenceDescriptor d = getReferenceDescriptor();\n    if (d == null) {\n      //invalid property, needed for propertyRead event in SNode until event is rewritten\n      return myName;\n    }\n    return d.getName();\n  }","commit_id":"ac571c61c2fadf7e055545d8eeef8d81eca42529","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean isMultiple() {\n    return getLinkDescriptor().isMultiple();\n  }","id":98760,"modified_method":"@Override\n  public boolean isMultiple() {\n    LinkDescriptor ld = getLinkDescriptor();\n    if (ld == null) return true;\n\n    return ld.isMultiple();\n  }","commit_id":"399d21bea0a7c1b105af6e901e2178e175bb17d7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SAbstractConcept getTargetConcept() {\n    SConceptId id = getLinkDescriptor().getTargetConcept();\n    ConceptDescriptor concept = ConceptRegistryUtil.getConceptDescriptor(id);\n    return concept.isInterfaceConcept() ? new SInterfaceConceptAdapterById(id, concept.getConceptFqName()) :\n        new SConceptAdapterById(id, concept.getConceptFqName());\n  }","id":98761,"modified_method":"@Override\n  public SAbstractConcept getTargetConcept() {\n    LinkDescriptor ld = getLinkDescriptor();\n    if (ld == null) return new SConceptAdapterById(SNodeUtil.conceptId_BaseConcept, SNodeUtil.concept_BaseConcept);\n\n    SConceptId id = ld.getTargetConcept();\n    ConceptDescriptor concept = ConceptRegistryUtil.getConceptDescriptor(id);\n    return concept.isInterfaceConcept() ? new SInterfaceConceptAdapterById(id, concept.getConceptFqName()) :\n        new SConceptAdapterById(id, concept.getConceptFqName());\n  }","commit_id":"399d21bea0a7c1b105af6e901e2178e175bb17d7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean isOptional() {\n    return getLinkDescriptor().isOptional();\n  }","id":98762,"modified_method":"@Override\n  public boolean isOptional() {\n    LinkDescriptor ld = getLinkDescriptor();\n    if (ld == null) return true;\n\n    return ld.isOptional();\n  }","commit_id":"399d21bea0a7c1b105af6e901e2178e175bb17d7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isUnordered() {\n    return getLinkDescriptor().isUnordered();\n  }","id":98763,"modified_method":"public boolean isUnordered() {\n    LinkDescriptor ld = getLinkDescriptor();\n    if (ld == null) return false;\n\n    return ld.isUnordered();\n  }","commit_id":"399d21bea0a7c1b105af6e901e2178e175bb17d7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SAbstractConcept getTargetConcept() {\n    SConceptId id = getReferenceDescriptor().getTargetConcept();\n    ConceptDescriptor concept = ConceptRegistryUtil.getConceptDescriptor(id);\n    return concept.isInterfaceConcept() ? new SInterfaceConceptAdapterById(id, concept.getConceptFqName()) :\n        new SConceptAdapterById(id, concept.getConceptFqName());\n  }","id":98764,"modified_method":"@Override\n  public SAbstractConcept getTargetConcept() {\n    ReferenceDescriptor rd = getReferenceDescriptor();\n    if (rd == null) return new SConceptAdapterById(SNodeUtil.conceptId_BaseConcept,SNodeUtil.concept_BaseConcept);\n\n    SConceptId id = rd.getTargetConcept();\n    ConceptDescriptor concept = ConceptRegistryUtil.getConceptDescriptor(id);\n    return concept.isInterfaceConcept() ? new SInterfaceConceptAdapterById(id, concept.getConceptFqName()) :\n        new SConceptAdapterById(id, concept.getConceptFqName());\n  }","commit_id":"399d21bea0a7c1b105af6e901e2178e175bb17d7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean isOptional() {\n    return getReferenceDescriptor().isOptional();\n  }","id":98765,"modified_method":"@Override\n  public boolean isOptional() {\n    ReferenceDescriptor rd = getReferenceDescriptor();\n    if (rd == null) return true;\n\n    return rd.isOptional();\n  }","commit_id":"399d21bea0a7c1b105af6e901e2178e175bb17d7","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * The EventsAlarmsWindow method constructs a sub-window instance which can be added to a\n\t * main window. The sub-window contains two embedded browsers which are directed at the Events\n\t * and Alarms page of the selected node\n\t * @param node Selected node\n\t * @param width Width of main window\n\t * @param height Height of main window\n\t * @throws MalformedURLException\n\t */\n\tpublic EventsAlarmsWindow(Node n, String eventsURL, String alarmsURL) throws MalformedURLException {\n\t\t\n\t\tNode node = n;\n\t\tif (node == null) {\n\t\t\tnode = new Node(-1, \"\", \"\");\n\t\t}\n\t\t/*Sets the URLs to the currently selected node that is passed in and initializes the browsers*/\n\t\tif (node.getNodeID() >= 0) {\n\t\t\teventsURL += node.getNodeID();\n\t\t\talarmsURL += node.getNodeID();\n\t\t}\n\t\tthis.eventsURL = new URL(eventsURL);\n\t\tthis.alarmsURL = new URL(alarmsURL);\n\t\teventsBrowser = new Embedded(\"\", new ExternalResource(this.eventsURL));\n\t\talarmsBrowser = new Embedded(\"\", new ExternalResource(this.alarmsURL));\n\t\t\n\t\tString label = node.getLabel();\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} else label = \" - \" + label;\n\t\t\n\t\tsetCaption(\"Events & Alarms\" + label);\n\t\tsetImmediate(true);\n\t\tsetResizable(false);\n\t\t\n\t\t/*Adds the two browsers to separate tabs in a tabsheet layout*/\n\t\tTabSheet tabsheet = new TabSheet();\n\t\ttabsheet.addTab(eventsBrowser, \"Events\");\n\t\ttabsheet.addTab(alarmsBrowser, \"Alarms\");\n\t\t\n\t\t/*Adds tabsheet component to the main layout of the sub-window*/\n\t\tVerticalLayout layout = new VerticalLayout();\n\t\tlayout.addComponent(tabsheet);\n\t\t\n\t\taddComponent(layout);\n\t}","id":98766,"modified_method":"/**\n\t * The EventsAlarmsWindow method constructs a sub-window instance which can be added to a\n\t * main window. The sub-window contains two embedded browsers which are directed at the Events\n\t * and Alarms page of the selected node\n\t * @param node Selected node\n\t * @param width Width of main window\n\t * @param height Height of main window\n\t * @throws MalformedURLException\n\t */\n\tpublic EventsAlarmsWindow(final Node node, final URL eventsURL, final URL alarmsURL) throws MalformedURLException {\n\t\teventsBrowser = new Embedded(\"\", new ExternalResource(eventsURL));\n\t\talarmsBrowser = new Embedded(\"\", new ExternalResource(alarmsURL));\n\t\t\n\t\tString label = node == null? \"\" : node.getLabel();\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} else {\n\t\t    label = \" - \" + label;\n\t\t}\n\t\t\n\t\tsetCaption(\"Events & Alarms\" + label);\n\t\tsetImmediate(true);\n\t\tsetResizable(false);\n\t\t\n\t\t/*Adds the two browsers to separate tabs in a tabsheet layout*/\n\t\tTabSheet tabsheet = new TabSheet();\n\t\ttabsheet.addTab(eventsBrowser, \"Events\");\n\t\ttabsheet.addTab(alarmsBrowser, \"Alarms\");\n\t\t\n\t\t/*Adds tabsheet component to the main layout of the sub-window*/\n\t\tVerticalLayout layout = new VerticalLayout();\n\t\tlayout.addComponent(tabsheet);\n\t\t\n\t\taddComponent(layout);\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tNode testNode1 = new Node(9,\"172.20.1.10\",\"Cartman\");\n\t\twindow = new EventsAlarmsWindow(null, \"http://localhost:8080/\", \"http://localhost:8080/\");\n\t\twindow2 = new EventsAlarmsWindow(testNode1, \"http://localhost:8080/\", \"http://localhost:8080/\");\n\t\tmainWindow = new Window();\n\t\tapp = new Application() { //Empty Application\n\t\t\t@Override\n\t\t\tpublic void init() {}\n\t\t};\n\t}","id":98767,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tNode testNode1 = new Node(9,\"172.20.1.10\",\"Cartman\");\n\t\tfinal URL url = new URL(\"http://localhost:8080/\");\n        window = new EventsAlarmsWindow(null, url, url);\n\t\twindow2 = new EventsAlarmsWindow(testNode1, url, url);\n\t\tmainWindow = new Window();\n\t\tapp = new Application() { //Empty Application\n\t\t\t@Override\n\t\t\tpublic void init() {}\n\t\t};\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The NodeInfoWindow method constructs a sub-window instance which can be added to a main window.\n     * The sub-window contains an embedded browser which displays the Node Info page of the currently selected\n     * node.\n     * @param node Selected node\n     * @param width Width of the main window\n     * @param height Height of the main window\n     * @throws MalformedURLException\n     */\n    public NodeInfoWindow(Node n, String baseURL) throws MalformedURLException{\n        \n\t\tNode node = n;\n\t\tif (node == null) {\n\t\t\tnode = new Node(-1, \"\", \"\");\n\t\t}\n\t\t/*Sets the URLs to the currently selected node that is passed in and initializes the browsers*/\n\t\tif (node.getNodeID() >= 0) {\n\t\t\tbaseURL += node.getNodeID();\n\t\t}\n    \t/*Sets the web address to the Resource Graphs page of the selected node and initializes the browser*/\n    \tnodeInfoURL = new URL(baseURL);\n        nodeInfoBrowser = new Embedded(\"\", new ExternalResource(nodeInfoURL));\n\n\t\tString label = node.getLabel();\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} else label = \" - \" + label;\n\t\tsetCaption(\"Node Info\" + label);\n        setImmediate(true);\n        setResizable(false);\n        \n        /*Adds the browser to the main layout*/\n        VerticalLayout layout = new VerticalLayout();\n        layout.addComponent(nodeInfoBrowser);\n\n        addComponent(layout);\n    }","id":98768,"modified_method":"/**\n     * The NodeInfoWindow method constructs a sub-window instance which can be added to a main window.\n     * The sub-window contains an embedded browser which displays the Node Info page of the currently selected\n     * node.\n     * @param node Selected node\n     * @param width Width of the main window\n     * @param height Height of the main window\n     * @throws MalformedURLException\n     */\n    public NodeInfoWindow(final Node node, final URL nodeURL) throws MalformedURLException{\n        \n        nodeInfoBrowser = new Embedded(\"\", new ExternalResource(nodeURL));\n\n        String label = node == null? \"\" : node.getLabel();\n        /*Sets up window settings*/\n        if (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n            label = \"\";\n        } else label = \" - \" + label;\n        setCaption(\"Node Info\" + label);\n        setImmediate(true);\n        setResizable(false);\n        \n        /*Adds the browser to the main layout*/\n        VerticalLayout layout = new VerticalLayout();\n        layout.addComponent(nodeInfoBrowser);\n\n        addComponent(layout);\n    }","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tNode testNode1 = new Node(9,\"172.20.1.10\",\"Cartman\");\n\t\twindow = new NodeInfoWindow(null, \"http://localhost:8080/\");\n\t\twindow2 = new NodeInfoWindow(testNode1, \"http://localhost:8080/\");\n\t\tmainWindow = new Window();\n\t\tapp = new Application() { //Empty Application\n\t\t\t@Override\n\t\t\tpublic void init() {}\n\t\t};\n\t}","id":98769,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tNode testNode1 = new Node(9,\"172.20.1.10\",\"Cartman\");\n\t\tfinal URL url = new URL(\"http://localhost:8080/\");\n        window = new NodeInfoWindow(null, url);\n\t\twindow2 = new NodeInfoWindow(testNode1, url);\n\t\tmainWindow = new Window();\n\t\tapp = new Application() { //Empty Application\n\t\t\t@Override\n\t\t\tpublic void init() {}\n\t\t};\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean enabled(List<Object> targets, OperationContext operationContext) {\n\t\treturn true;\n\t}","id":98770,"modified_method":"public boolean enabled(final List<Object> targets, final OperationContext operationContext) {\n\t    if (targets == null || targets.size() < 2) return true;\n\t    return false;\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Undoer execute(List<Object> targets, OperationContext operationContext) {\n\t\tString ipAddr = \"\";\n\t\tString label = \"\";\n\t\tint nodeID = -1;\n\n\t\tif (targets != null) {\n\t\t\tfor(Object target : targets) {\n\t\t\t\tProperty ipAddrProperty = operationContext.getGraphContainer().getVertexItem(target).getItemProperty(\"ipAddr\");\n\t\t\t\tipAddr = ipAddrProperty == null ? \"\" : (String) ipAddrProperty.getValue();\n\t\t\t\tProperty labelProperty = operationContext.getGraphContainer().getVertexItem(target).getItemProperty(\"label\");\n\t\t\t\tlabel = labelProperty == null ? \"\" : (String) labelProperty.getValue();\n\t\t\t\tProperty nodeIDProperty = operationContext.getGraphContainer().getVertexItem(target).getItemProperty(\"nodeID\");\n\t\t\t\tnodeID = nodeIDProperty == null ? -1 : (Integer) nodeIDProperty.getValue();\n\t\t\t}\n\t\t}\n\t\tNode node = new Node(nodeID, ipAddr, label);\n\t\toperationContext.getMainWindow().addWindow(new PingWindow(node, getPingURL()));\n\t\treturn null;\n\t}","id":98771,"modified_method":"public Undoer execute(final List<Object> targets, final OperationContext operationContext) {\n\t    String ipAddr = \"\";\n\t    String label = \"\";\n\t    int nodeID = -1;\n\n            if (targets != null) {\n                for (final Object target : targets) {\n                    final Item vertexItem = operationContext.getGraphContainer().getVertexItem(target);\n                    if (vertexItem != null) {\n                        final Property ipAddrProperty = vertexItem.getItemProperty(\"ipAddr\");\n                        ipAddr = ipAddrProperty == null ? \"\" : (String) ipAddrProperty.getValue();\n                        final Property labelProperty = vertexItem.getItemProperty(\"label\");\n                        label = labelProperty == null ? \"\" : (String) labelProperty.getValue();\n                        final Property nodeIDProperty = vertexItem.getItemProperty(\"nodeID\");\n                        nodeID = nodeIDProperty == null ? -1 : (Integer) nodeIDProperty.getValue();\n                    }\n                }\n            }\n            final Node node = new Node(nodeID, ipAddr, label);\n            operationContext.getMainWindow().addWindow(new PingWindow(node, getPingURL()));\n            return null;\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean display(List<Object> targets, OperationContext operationContext) {\n\t\tString ipAddr = \"\";\n\n\t\tif (targets != null) {\n\t\t\tfor(Object target : targets) {\n\t\t\t\tItem vertexItem = operationContext.getGraphContainer().getVertexItem(target);\n\t\t\t\tif (vertexItem != null) {\n\t\t\t\t\tProperty ipAddrProperty = vertexItem.getItemProperty(\"ipAddr\");\n\t\t\t\t\tipAddr = ipAddrProperty == null ? \"\" : (String) ipAddrProperty.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"\".equals(ipAddr)) return false;\n\t\treturn true;\n\t}","id":98772,"modified_method":"public boolean display(final List<Object> targets, final OperationContext operationContext) {\n\t    return true;\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The buildURL method takes the current values in the form and formats them into the\n\t * URL string that is used to redirect the results browser to the Ping page.\n\t * @return Web address for ping command with submitted parameters\n\t * @throws MalformedURLException\n\t */\n\tprotected URL buildURL() {\n\t\tboolean validInput = false;\n\t\ttry {\n\t\t\tvalidInput = validateInput();\n\t\t} catch (NumberFormatException e) {\n\t\t\tgetApplication().getMainWindow().showNotification(\"Inputs must be integers\", Notification.TYPE_WARNING_MESSAGE);\n\t\t\treturn null;\n\t\t}\n\t\tif (validInput){\n\t\t\tString options = baseAddress;\n\t\t\toptions += \"&address=\" + ipDropdown.getValue().toString();\n\t\t\toptions += \"&timeout=\" + timeoutField.getValue().toString();\n\t\t\toptions += \"&numberOfRequests=\" + requestsField.getValue().toString();\n\t\t\toptions += \"&packetSize=\" + (Integer.parseInt(packetSizeDropdown.getValue().toString()) - 8);\n\t\t\tif (numericalDataCheckBox.getValue().equals(true))\n\t\t\t\toptions += \"&numericOutput=true\";\n\t\t\ttry { return new URL(options); } catch (MalformedURLException e) {\n\t\t\t\tgetApplication().getMainWindow().showNotification(\"Could not build URL\", Notification.TYPE_WARNING_MESSAGE);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tgetApplication().getMainWindow().showNotification(\"Inputs must be between 0 and 9999\", Notification.TYPE_WARNING_MESSAGE);\n\t\t\treturn null;\n\t\t}\n\t}","id":98773,"modified_method":"/**\n\t * The buildURL method takes the current values in the form and formats them into the\n\t * URL string that is used to redirect the results browser to the Ping page.\n\t * @return Web address for ping command with submitted parameters\n\t * @throws MalformedURLException\n\t */\n    protected URL buildURL() {\n        boolean validInput = false;\n        try {\n            validInput = validateInput();\n        } catch (NumberFormatException e) {\n            getApplication().getMainWindow().showNotification(\"Inputs must be integers\", Notification.TYPE_WARNING_MESSAGE);\n            return null;\n        }\n        if (validInput) {\n            final URL baseUrl = getApplication().getURL();\n            \n            final StringBuilder options = new StringBuilder(baseAddress);\n\n            options.append(\"&address=\").append(ipDropdown.getValue())\n                .append(\"&timeout=\").append(timeoutField.getValue())\n                .append(\"&numberOfRequests=\").append(requestsField.getValue())\n                .append(\"&packetSize=\").append(Integer.parseInt(packetSizeDropdown.getValue().toString()) - 8);\n            if (numericalDataCheckBox.getValue().equals(true)) {\n                options.append(\"&numericOutput=true\");\n            }\n            try {\n                return new URL(baseUrl, options.toString());\n            } catch (final MalformedURLException e) {\n                getApplication().getMainWindow().showNotification(\"Could not build URL: \" + options.toString(), Notification.TYPE_WARNING_MESSAGE);\n                return null;\n            }\n        } else {\n            getApplication().getMainWindow().showNotification(\"Inputs must be between 0 and 9999\", Notification.TYPE_WARNING_MESSAGE);\n            return null;\n        }\n    }","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The ResourceGraphsWindow method constructs a sub-window instance which can be added to a\n\t * main window. The sub-window contains an embedded browser which displays the Resource Graphs\n\t * page of the currently selected node\n\t * @param node Selected node\n\t * @param width Width of the main window\n\t * @param height Height of the main window\n\t * @throws MalformedURLException\n\t */\n\tpublic ResourceGraphsWindow(Node n, String baseURL) throws MalformedURLException{\n\t\t\n\t\tNode node = n;\n\t\tif (node == null) {\n\t\t\tnode = new Node(-1, \"\", \"\");\n\t\t}\n\t\t/*Sets the URLs to the currently selected node that is passed in and initializes the browsers*/\n\t\tif (node.getNodeID() >= 0) {\n\t\t\tbaseURL += (\"[\" + node.getNodeID() + \"]\");\n\t\t}\n\t\t\n\t\t/*Sets the URLs to the currently selected node that is passed in and initializes the browsers*/\n\t\trgURL = new URL(baseURL);\n\t\trgBrowser = new Embedded(\"\", new ExternalResource(rgURL));\n\t\t\n\t\tString label = node.getLabel();\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} else label = \" - \" + label;\n\t\tsetCaption(\"Resource Graphs\" + label);\n\t\tsetImmediate(true);\n\t\tsetResizable(false);\n\t\t\n\t\t/*Adds the browser component to the main layout*/\n\t\tVerticalLayout layout = new VerticalLayout();\n\t\tlayout.addComponent(rgBrowser);\n\t\t\n\t\taddComponent(layout);\n\t}","id":98774,"modified_method":"/**\n\t * The ResourceGraphsWindow method constructs a sub-window instance which can be added to a\n\t * main window. The sub-window contains an embedded browser which displays the Resource Graphs\n\t * page of the currently selected node\n\t * @param node Selected node\n\t * @param width Width of the main window\n\t * @param height Height of the main window\n\t * @throws MalformedURLException\n\t */\n\tpublic ResourceGraphsWindow(final Node node, final URL nodeURL) throws MalformedURLException{\n\t\t\n\t\trgBrowser = new Embedded(\"\", new ExternalResource(nodeURL));\n\t\t\n\t\tString label = node.getLabel();\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} else {\n\t\t    label = \" - \" + label;\n\t\t}\n\t\tsetCaption(\"Resource Graphs\" + label);\n\t\tsetImmediate(true);\n\t\tsetResizable(false);\n\t\t\n\t\t/*Adds the browser component to the main layout*/\n\t\tVerticalLayout layout = new VerticalLayout();\n\t\tlayout.addComponent(rgBrowser);\n\t\t\n\t\taddComponent(layout);\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tNode testNode1 = new Node(9,\"172.20.1.10\",\"Cartman\");\n\t\twindow1 = new ResourceGraphsWindow(testNode1, \"http://localhost:8080/\");\n\t\twindow2 = new ResourceGraphsWindow(null, \"http://localhost:8080/\");\n\t\tmainWindow = new Window();\n\t\tapp = new Application() { //Empty Application\n\t\t\t@Override\n\t\t\tpublic void init() {}\n\t\t};\n\t}","id":98775,"modified_method":"@Before\n    public void setUp() throws Exception {\n        Node testNode1 = new Node(9, \"172.20.1.10\", \"Cartman\");\n        final URL url = new URL(\"http://localhost:8080/\");\n        window1 = new ResourceGraphsWindow(testNode1, url);\n        window2 = new ResourceGraphsWindow(null, url);\n        mainWindow = new Window();\n        app = new Application() { // Empty Application\n            @Override\n            public void init() {\n            }\n        };\n    }","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean display(List<Object> targets, OperationContext operationContext) {\n\t\tString ipAddr = \"\";\n\n\t\tif (targets != null) {\n\t\t\tList<Object> selectedVertices = operationContext.getGraphContainer().getSelectedVertices();\n\t\t\tif (selectedVertices.size() > 0) return false;\n\t\t\tfor(Object target : targets) {\n\t\t\t\tItem vertexItem = operationContext.getGraphContainer().getVertexItem(target);\n\t\t\t\tif (vertexItem != null) {\n\t\t\t\t\tProperty ipAddrProperty = vertexItem.getItemProperty(\"ipAddr\");\n\t\t\t\t\tipAddr = ipAddrProperty == null ? \"\" : (String) ipAddrProperty.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"\".equals(ipAddr)) return false;\n\t\treturn true;\n\t}","id":98776,"modified_method":"public boolean display(final List<Object> targets, final  OperationContext operationContext) {\n        String ipAddr = \"\";\n\n        if (targets != null) {\n            final List<Object> selectedVertices = operationContext.getGraphContainer().getSelectedVertices();\n            if (selectedVertices != null && selectedVertices.size() > 0) {\n                return false;\n            }\n            for (final Object target : targets) {\n                final Item vertexItem = operationContext.getGraphContainer().getVertexItem(target);\n                if (vertexItem != null) {\n                    final Property ipAddrProperty = vertexItem.getItemProperty(\"ipAddr\");\n                    ipAddr = ipAddrProperty == null ? \"\" : (String) ipAddrProperty.getValue();\n                }\n            }\n        }\n        if (\"\".equals(ipAddr)) {\n            return false;\n        }\n        return true;\n    }","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Undoer execute(List<Object> targets, OperationContext operationContext) {\n\t\tString ipAddr = \"\";\n\t\tString label = \"\";\n\t\tint nodeID = -1;\n\n\t\tif (targets != null) {\n\t\t\tfor(Object target : targets) {\n\t\t\t\tProperty ipAddrProperty = operationContext.getGraphContainer().getVertexItem(target).getItemProperty(\"ipAddr\");\n\t\t\t\tipAddr = ipAddrProperty == null ? \"\" : (String) ipAddrProperty.getValue();\n\t\t\t\tProperty labelProperty = operationContext.getGraphContainer().getVertexItem(target).getItemProperty(\"label\");\n\t\t\t\tlabel = labelProperty == null ? \"\" : (String) labelProperty.getValue();\n\t\t\t\tProperty nodeIDProperty = operationContext.getGraphContainer().getVertexItem(target).getItemProperty(\"nodeID\");\n\t\t\t\tnodeID = nodeIDProperty == null ? -1 : (Integer) nodeIDProperty.getValue();\n\t\t\t}\n\t\t}\n\t\tNode node = new Node(nodeID, ipAddr, label);\n\t\toperationContext.getMainWindow().addWindow(new TracerouteWindow(node, getTracerouteURL()));\n\t\treturn null;\n\t}","id":98777,"modified_method":"public Undoer execute(final List<Object> targets, final OperationContext operationContext) {\n        String ipAddr = \"\";\n        String label = \"\";\n        int nodeID = -1;\n\n        if (targets != null) {\n            for (final Object target : targets) {\n                final Item vertexItem = operationContext.getGraphContainer().getVertexItem(target);\n                if (vertexItem != null) {\n                    final Property ipAddrProperty = vertexItem.getItemProperty(\"ipAddr\");\n                    ipAddr = ipAddrProperty == null ? \"\" : (String) ipAddrProperty.getValue();\n                    final Property labelProperty = vertexItem.getItemProperty(\"label\");\n                    label = labelProperty == null ? \"\" : (String) labelProperty.getValue();\n                    final Property nodeIDProperty = vertexItem.getItemProperty(\"nodeID\");\n                    nodeID = nodeIDProperty == null ? -1 : (Integer) nodeIDProperty.getValue();\n                }\n            }\n        }\n        final Node node = new Node(nodeID, ipAddr, label);\n        operationContext.getMainWindow().addWindow(new TracerouteWindow(node, getTracerouteURL()));\n        return null;\n    }","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The buildURL method takes the current values in the form and formats them into the\n\t * URL string that is used to redirect the results browser to the Traceroute page.\n\t * @return Web address for traceroute command with submitted parameters\n\t * @throws MalformedURLException\n\t */\n\tprotected URL buildURL() {\n\t\tboolean validInput = false;\n\t\ttry { validInput = validateInput(); } catch (Exception e) {\n\t\t\tgetApplication().getMainWindow().showNotification(e.getMessage(), Notification.TYPE_WARNING_MESSAGE);\n\t\t\treturn null;\n\t\t}\n\t\tif (validInput) {\n\t\t\tString options = baseAddress;\n\t\t\toptions += \"&address=\" + ipDropdown.getValue().toString();\n\t\t\tif (!(\"\".equals(forcedHopField.getValue().toString()))) {\n\t\t\t\toptions += \"&hopAddress=\" + forcedHopField.getValue().toString();\n\t\t\t}\n\t\t\tif (numericalDataCheckBox.getValue().equals(true))\n\t\t\t\toptions += \"&numericOutput=true\";\n\t\t\ttry { return new URL(options); } catch (MalformedURLException e) {\n\t\t\t\tgetApplication().getMainWindow().showNotification(\"Could not build URL\", Notification.TYPE_WARNING_MESSAGE);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tgetApplication().getMainWindow().showNotification(\"Invalid IP addresss\", Notification.TYPE_WARNING_MESSAGE);\n\t\t\treturn null;\n\t\t}\n\t}","id":98778,"modified_method":"/**\n\t * The buildURL method takes the current values in the form and formats them into the\n\t * URL string that is used to redirect the results browser to the Traceroute page.\n\t * @return Web address for traceroute command with submitted parameters\n\t * @throws MalformedURLException\n\t */\n\tprotected URL buildURL() {\n\t    boolean validInput = false;\n\t    try {\n\t        validInput = validateInput();\n\t    } catch (Exception e) {\n\t        getApplication().getMainWindow().showNotification(e.getMessage(), Notification.TYPE_WARNING_MESSAGE);\n\t        return null;\n\t    }\n\t    if (validInput) {\n\t        final URL baseUrl = getApplication().getURL();\n\n\t        final StringBuilder options = new StringBuilder(tracerouteUrl);\n\t        options.append(\"&address=\").append(ipDropdown.getValue());\n\t        if (!(\"\".equals(forcedHopField.getValue().toString()))) {\n\t            options.append(\"&hopAddress=\").append(forcedHopField.getValue());\n\t        }\n\t        if (numericalDataCheckBox.getValue().equals(true)) {\n\t            options.append(\"&numericOutput=true\");\n\t        }\n\t        try {\n\t            return new URL(baseUrl, options.toString());\n\t        } catch (final MalformedURLException e) {\n\t            getApplication().getMainWindow().showNotification(\"Could not build URL: \" + options.toString(), Notification.TYPE_WARNING_MESSAGE);\n\t            return null;\n\t        }\n\t    } else {\n\t        getApplication().getMainWindow().showNotification(\"Invalid IP addresss\", Notification.TYPE_WARNING_MESSAGE);\n\t        return null;\n\t    }\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The TracerouteWindow method constructs a TracerouteWindow component with a size proportionate to the \n\t * width and height of the main window.\n\t * @param node \n\t * @param width Width of Main window\n\t * @param height Height of Main window\n\t */\n\tpublic TracerouteWindow(Node node, String baseAddress){\n\n\t\tthis.baseAddress = baseAddress;\n\t\t\n\t\tString label = \"\";\n\t\tString ipAddress = \"\";\n\t\tif (node != null) {\n\t\t\tlabel = node.getLabel();\n\t\t\tipAddress = node.getIPAddress();\n\t\t}\n\t\tString caption = \"\";\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} \n\t\tif (!label.equals(\"\")) caption = \" - \" + label;\n\t\tsetCaption(\"Traceroute\" + caption);\n\t\tsetImmediate(true);\n\t\tsetResizable(false);\n\n\t\t/*Initialize the header of the Sub-window with the name of the selected Node*/\n\t\tString nodeName = \"<div style=\\\"text-align: center; font-size: 18pt; font-weight:bold;\\\">\" + label + \"<\/div>\";\n\t\tnodeLabel = new Label(nodeName);\n\t\tnodeLabel.setContentMode(Label.CONTENT_XHTML);\n\n\t\t/*Creating various layouts to encapsulate all of the components*/\n\t\tVerticalLayout mainLayout = new VerticalLayout();\n\t\tmainLayout.setSizeFull();\n\t\tvSplit = new VerticalSplitPanel();\n\t\ttopLayout = new VerticalLayout();\n\t\tbottomLayout = new VerticalLayout();\n\t\tVerticalLayout form = new VerticalLayout();\n\t\tGridLayout grid = new GridLayout(2,2);\n\t\tgrid.setWidth(\"420\");\n\t\tgrid.setHeight(\"62\");\n\n\t\t/*Sets up IP Address dropdown with the Name as default*/\n\t\tipDropdown = new NativeSelect();\n\t\tipDropdown.addItem(ipAddress);\n\t\tipDropdown.select(ipAddress);\n\n\t\t/*Creates the Numerical Output Check box and sets up the listener*/\n\t\tnumericalDataCheckBox = new CheckBox(\"Use Numerical Node Names\");\n\t\tnumericalDataCheckBox.setImmediate(true);\n\t\tnumericalDataCheckBox.setValue(false);\n\n\t\t/*Creates the form labels and text fields*/\n\t\tLabel ipLabel = new Label(\"IP Address: \");\n\t\tLabel forcedHopLabel = new Label(\"Forced Hop IP: \");\n\t\tforcedHopField = new TextField();\n\t\tforcedHopField.setMaxLength(15);\n\n\t\t/*Add all of the components to the GridLayout*/\n\t\tgrid.addComponent(ipLabel);\n\t\tgrid.setComponentAlignment(ipLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(ipDropdown);\n\t\tgrid.setComponentAlignment(ipDropdown, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(forcedHopLabel);\n\t\tgrid.setComponentAlignment(forcedHopLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(forcedHopField);\n\t\tgrid.setComponentAlignment(forcedHopField, Alignment.MIDDLE_LEFT);\n\n\t\t/*Creates the Ping button and sets up the listener*/\n\t\ttracerouteButton = new Button(\"Traceroute\"); \n\t\ttracerouteButton.addListener(new Button.ClickListener() {\n\t\t\tpublic void buttonClick(ClickEvent event) {\n\t\t\t\tchangeBrowserURL(buildURL());\n\t\t\t}\n\t\t}); \n\n\t\t/*Adds components to the form and sets the width and spacing*/\n\t\tform.addComponent(grid);\n\t\tform.addComponent(numericalDataCheckBox);\n\t\tform.addComponent(tracerouteButton);\n\t\tform.setWidth(\"100%\");\n\t\tform.setSpacing(true);\n\n\t\t/*Adds components to the Top Layout and sets the width and margins*/\n\t\ttopLayout.addComponent(nodeLabel);\n\t\ttopLayout.setComponentAlignment(nodeLabel, Alignment.MIDDLE_CENTER);\n\t\ttopLayout.addComponent(form);\n\t\ttopLayout.setSizeFull();\n\t\ttopLayout.setMargin(true, true, false, true);\n\n\t\t/*Adds components to the Bottom Layout and sets the width and margins*/\n\t\tbottomLayout.setSizeFull();\n\t\tbottomLayout.setMargin(true);\n\t\tbottomLayout.setImmediate(true);\n\n\t\tbuildEmbeddedBrowser();\n\n\t\t/*Setting first and second components for the split panel and setting the panel divider position*/\n\t\tvSplit.setFirstComponent(topLayout);\n\t\tvSplit.setSecondComponent(bottomLayout);\n\t\tvSplit.setSplitPosition(splitHeight, UNITS_PIXELS);\n\t\tvSplit.setLocked(true);\n\n\t\t/*Adds split panel to the main layout and expands the split panel to 100% of the layout space*/\n\t\tmainLayout.addComponent(vSplit);\n\t\tmainLayout.setExpandRatio(vSplit, 1);\n\n\t\tsetContent(mainLayout);\n\t}","id":98779,"modified_method":"/**\n\t * The TracerouteWindow method constructs a TracerouteWindow component with a size proportionate to the \n\t * width and height of the main window.\n\t * @param node \n\t * @param width Width of Main window\n\t * @param height Height of Main window\n\t */\n\tpublic TracerouteWindow(Node node, String url) {\n\n\t\tthis.tracerouteUrl = url;\n\t\t\n\t\tString label = \"\";\n\t\tString ipAddress = \"\";\n\t\tif (node != null) {\n\t\t\tlabel = node.getLabel();\n\t\t\tipAddress = node.getIPAddress();\n\t\t}\n\t\tString caption = \"\";\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} \n\t\tif (!label.equals(\"\")) caption = \" - \" + label;\n\t\tsetCaption(\"Traceroute\" + caption);\n\t\tsetImmediate(true);\n\t\tsetResizable(false);\n\n\t\t/*Initialize the header of the Sub-window with the name of the selected Node*/\n\t\tString nodeName = \"<div style=\\\"text-align: center; font-size: 18pt; font-weight:bold;\\\">\" + label + \"<\/div>\";\n\t\tnodeLabel = new Label(nodeName);\n\t\tnodeLabel.setContentMode(Label.CONTENT_XHTML);\n\n\t\t/*Creating various layouts to encapsulate all of the components*/\n\t\tVerticalLayout mainLayout = new VerticalLayout();\n\t\tmainLayout.setSizeFull();\n\t\tvSplit = new VerticalSplitPanel();\n\t\ttopLayout = new VerticalLayout();\n\t\tbottomLayout = new VerticalLayout();\n\t\tVerticalLayout form = new VerticalLayout();\n\t\tGridLayout grid = new GridLayout(2,2);\n\t\tgrid.setWidth(\"420\");\n\t\tgrid.setHeight(\"62\");\n\n\t\t/*Sets up IP Address dropdown with the Name as default*/\n\t\tipDropdown = new NativeSelect();\n\t\tipDropdown.addItem(ipAddress);\n\t\tipDropdown.select(ipAddress);\n\n\t\t/*Creates the Numerical Output Check box and sets up the listener*/\n\t\tnumericalDataCheckBox = new CheckBox(\"Use Numerical Node Names\");\n\t\tnumericalDataCheckBox.setImmediate(true);\n\t\tnumericalDataCheckBox.setValue(false);\n\n\t\t/*Creates the form labels and text fields*/\n\t\tLabel ipLabel = new Label(\"IP Address: \");\n\t\tLabel forcedHopLabel = new Label(\"Forced Hop IP: \");\n\t\tforcedHopField = new TextField();\n\t\tforcedHopField.setMaxLength(15);\n\n\t\t/*Add all of the components to the GridLayout*/\n\t\tgrid.addComponent(ipLabel);\n\t\tgrid.setComponentAlignment(ipLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(ipDropdown);\n\t\tgrid.setComponentAlignment(ipDropdown, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(forcedHopLabel);\n\t\tgrid.setComponentAlignment(forcedHopLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(forcedHopField);\n\t\tgrid.setComponentAlignment(forcedHopField, Alignment.MIDDLE_LEFT);\n\n\t\t/*Creates the Ping button and sets up the listener*/\n\t\ttracerouteButton = new Button(\"Traceroute\"); \n\t\ttracerouteButton.addListener(new Button.ClickListener() {\n\t\t\tpublic void buttonClick(ClickEvent event) {\n\t\t\t\tchangeBrowserURL(buildURL());\n\t\t\t}\n\t\t}); \n\n\t\t/*Adds components to the form and sets the width and spacing*/\n\t\tform.addComponent(grid);\n\t\tform.addComponent(numericalDataCheckBox);\n\t\tform.addComponent(tracerouteButton);\n\t\tform.setWidth(\"100%\");\n\t\tform.setSpacing(true);\n\n\t\t/*Adds components to the Top Layout and sets the width and margins*/\n\t\ttopLayout.addComponent(nodeLabel);\n\t\ttopLayout.setComponentAlignment(nodeLabel, Alignment.MIDDLE_CENTER);\n\t\ttopLayout.addComponent(form);\n\t\ttopLayout.setSizeFull();\n\t\ttopLayout.setMargin(true, true, false, true);\n\n\t\t/*Adds components to the Bottom Layout and sets the width and margins*/\n\t\tbottomLayout.setSizeFull();\n\t\tbottomLayout.setMargin(true);\n\t\tbottomLayout.setImmediate(true);\n\n\t\tbuildEmbeddedBrowser();\n\n\t\t/*Setting first and second components for the split panel and setting the panel divider position*/\n\t\tvSplit.setFirstComponent(topLayout);\n\t\tvSplit.setSecondComponent(bottomLayout);\n\t\tvSplit.setSplitPosition(splitHeight, UNITS_PIXELS);\n\t\tvSplit.setLocked(true);\n\n\t\t/*Adds split panel to the main layout and expands the split panel to 100% of the layout space*/\n\t\tmainLayout.addComponent(vSplit);\n\t\tmainLayout.setExpandRatio(vSplit, 1);\n\n\t\tsetContent(mainLayout);\n\t}","commit_id":"e67c7c4b82590acc05cab1aee3f4ceb2cfe28885","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected String transform(\r\n            final BufferedReader reader,\r\n            final int length) throws IOException {\r\n        final StringBuilder out = new StringBuilder(length);\r\n        String line;\r\n        while ((line = reader.readLine()) != null) {\r\n            out.append(transformLine(line)).append(serverCore.CRLF_STRING);\r\n        }\r\n        return out.insert(0, directory()).toString();\r\n    }","id":98780,"modified_method":"/**\r\n     * Transforms a text which contains wiki code to HTML fragment.\r\n     * @param reader contains the text to be transformed.\r\n     * @param length expected length of text, used to create buffer with right size.\r\n     * @return HTML fragment.\r\n     * @throws IOException in case input from reader can not be read.\r\n     */\r\n    protected String transform(final BufferedReader reader, final int length)\r\n            throws IOException {\r\n        final StringBuilder out = new StringBuilder(length);\r\n        String line;\r\n        while ((line = reader.readLine()) != null) {\r\n            out.append(processLineOfWikiCode(line)).append(serverCore.CRLF_STRING);\r\n        }\r\n        return out.insert(0, createTableOfContents()).toString();\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** This method processes unordered lists.\r\n     */\r\n    //contributed by [AS] put into it's own method by [MN]\r\n    private String unorderedList(String result) {\r\n        if (!nolist) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n            int p0 = 0;\r\n            int p1 = 0;\r\n            //contributed by [AS]\r\n            if (result.startsWith(ListLevel + \"*\")) { //more stars\r\n                p0 = result.indexOf(ListLevel);\r\n                p1 = result.length();\r\n                result = \"<ul>\" + serverCore.CRLF_STRING +\r\n                        \"<li>\" +\r\n                        result.substring(ListLevel.length() + 1, p1) +\r\n                        \"<\/li>\";\r\n                ListLevel += \"*\";\r\n            } else if (ListLevel.length() > 0 && result.startsWith(ListLevel)) { //equal number of stars\r\n                p0 = result.indexOf(ListLevel);\r\n                p1 = result.length();\r\n                result = \"<li>\" +\r\n                        result.substring(ListLevel.length(), p1) +\r\n                        \"<\/li>\";\r\n            } else if (ListLevel.length() > 0) { //less stars\r\n                int i = ListLevel.length();\r\n                String tmp = \"\";\r\n\r\n                while (ListLevel.length() >= i && !result.startsWith(ListLevel.substring(0, i))) {\r\n                    tmp += \"<\/ul>\";\r\n                    i--;\r\n                }\r\n                p0 = ListLevel.length();\r\n                if (i < p0) {\r\n                    ListLevel = ListLevel.substring(0, i);\r\n                    p0 = ListLevel.length();\r\n                }\r\n                p1 = result.length();\r\n\r\n                if (ListLevel.length() > 0) {\r\n                    result = tmp +\r\n                            \"<li>\" +\r\n                            result.substring(p0, p1) +\r\n                            \"<\/li>\";\r\n                } else {\r\n                    result = tmp + result.substring(p0, p1);\r\n                }\r\n            }\r\n        //end contrib [AS]\r\n        }\r\n        return result;\r\n    }","id":98781,"modified_method":"/**\r\n     * Processes tags which are connected to unordered lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processUnorderedList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n            //contributed by [AS]\r\n            if (line.startsWith(unorderedListLevel + ASTERISK)) { //more stars\r\n                line = OPEN_UNORDERED_LIST + serverCore.CRLF_STRING\r\n                        + OPEN_LIST_ELEMENT\r\n                        + line.substring(unorderedListLevel.length() + 1, line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n                unorderedListLevel += ASTERISK;\r\n            } else if (unorderedListLevel.length() > 0 && line.startsWith(unorderedListLevel)) { //equal number of stars\r\n                line = OPEN_LIST_ELEMENT\r\n                        + line.substring(unorderedListLevel.length(), line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n            } else if (unorderedListLevel.length() > 0) { //less stars\r\n                int i = unorderedListLevel.length();\r\n                String tmp = EMPTY;\r\n\r\n                while (unorderedListLevel.length() >= i && !line.startsWith(unorderedListLevel.substring(0, i))) {\r\n                    tmp += CLOSE_UNORDERED_LIST;\r\n                    i--;\r\n                }\r\n                int positionOfOpeningTag = unorderedListLevel.length();\r\n                if (i < positionOfOpeningTag) {\r\n                    unorderedListLevel = unorderedListLevel.substring(0, i);\r\n                    positionOfOpeningTag = unorderedListLevel.length();\r\n                }\r\n                final int positionOfClosingTag = line.length();\r\n\r\n                if (unorderedListLevel.length() > 0) {\r\n                    line = tmp\r\n                            + OPEN_LIST_ELEMENT\r\n                            + line.substring(positionOfOpeningTag, positionOfClosingTag)\r\n                            + CLOSE_LIST_ELEMENT;\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n            //end contrib [AS]\r\n        }\r\n        return line;\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** This method processes ordered lists.\r\n     */\r\n    private String orderedList(String result) {\r\n        if (!nolist) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n            int p0 = 0;\r\n            int p1 = 0;\r\n            //# sorted Lists contributed by [AS]\r\n            //## Sublist\r\n            if (result.startsWith(numListLevel + \"#\")) { //more #\r\n                p0 = result.indexOf(numListLevel);\r\n                p1 = result.length();\r\n                result = \"<ol>\" + serverCore.CRLF_STRING +\r\n                        \"<li>\" +\r\n                        result.substring(numListLevel.length() + 1, p1) +\r\n                        \"<\/li>\";\r\n                numListLevel += \"#\";\r\n            } else if (numListLevel.length() > 0 && result.startsWith(numListLevel)) { //equal number of #\r\n                p0 = result.indexOf(numListLevel);\r\n                p1 = result.length();\r\n                result = \"<li>\" +\r\n                        result.substring(numListLevel.length(), p1) +\r\n                        \"<\/li>\";\r\n            } else if (numListLevel.length() > 0) { //less #\r\n                int i = numListLevel.length();\r\n                String tmp = \"\";\r\n\r\n                while (!result.startsWith(numListLevel.substring(0, i))) {\r\n                    tmp += \"<\/ol>\";\r\n                    i--;\r\n                }\r\n                numListLevel = numListLevel.substring(0, i);\r\n                p0 = numListLevel.length();\r\n                p1 = result.length();\r\n\r\n                if (numListLevel.length() > 0) {\r\n                    result = tmp +\r\n                            \"<li>\" +\r\n                            result.substring(p0, p1) +\r\n                            \"<\/li>\";\r\n                } else {\r\n                    result = tmp + result.substring(p0, p1);\r\n                }\r\n            }\r\n        // end contrib [AS]\r\n        }\r\n        return result;\r\n    }","id":98782,"modified_method":"/**\r\n     * Processes tags which are connected to ordered lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processOrderedList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n\r\n            //# sorted Lists contributed by [AS]\r\n            //## Sublist\r\n            if (line.startsWith(numberedListLevel + \"#\")) { //more #\r\n                line = OPEN_ORDERED_LIST + serverCore.CRLF_STRING\r\n                        + OPEN_LIST_ELEMENT\r\n                        + line.substring(numberedListLevel.length() + 1, line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n                numberedListLevel += \"#\";\r\n            } else if (numberedListLevel.length() > 0 && line.startsWith(numberedListLevel)) { //equal number of #\r\n                line = OPEN_LIST_ELEMENT\r\n                        + line.substring(numberedListLevel.length(), line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n            } else if (numberedListLevel.length() > 0) { //less #\r\n                int i = numberedListLevel.length();\r\n                String tmp = EMPTY;\r\n\r\n                while (!line.startsWith(numberedListLevel.substring(0, i))) {\r\n                    tmp += CLOSE_ORDERED_LIST;\r\n                    i--;\r\n                }\r\n                numberedListLevel = numberedListLevel.substring(0, i);\r\n                final int positionOfOpeningTag = numberedListLevel.length();\r\n                final int positionOfClosingTag = line.length();\r\n\r\n                if (numberedListLevel.length() > 0) {\r\n                    line = tmp\r\n                            + OPEN_LIST_ELEMENT\r\n                            + line.substring(positionOfOpeningTag, positionOfClosingTag)\r\n                            + CLOSE_LIST_ELEMENT;\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n            // end contrib [AS]\r\n        }\r\n        return line;\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** This method processes definition lists.\r\n     */\r\n    //contributed by [MN] based on unordered list code by [AS]\r\n    private String definitionList(String result) {\r\n        if (!nolist) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n            int p0 = 0;\r\n            int p1 = 0;\r\n            if (result.startsWith(defListLevel + \";\")) { //more semicolons\r\n                String dt = \"\";\r\n                String dd = \"\";\r\n                p0 = result.indexOf(defListLevel);\r\n                p1 = result.length();\r\n                final String resultCopy = result.substring(defListLevel.length() + 1, p1);\r\n                if ((p0 = resultCopy.indexOf(\":\")) > 0) {\r\n                    dt = resultCopy.substring(0, p0);\r\n                    dd = resultCopy.substring(p0 + 1);\r\n                    result = \"<dl>\" + \"<dt>\" + dt + \"<\/dt>\" + \"<dd>\" + dd;\r\n                    defList = true;\r\n                }\r\n                defListLevel += \";\";\r\n            } else if (defListLevel.length() > 0 && result.startsWith(defListLevel)) { //equal number of semicolons\r\n                String dt = \"\";\r\n                String dd = \"\";\r\n                p0 = result.indexOf(defListLevel);\r\n                p1 = result.length();\r\n                final String resultCopy = result.substring(defListLevel.length(), p1);\r\n                if ((p0 = resultCopy.indexOf(\":\")) > 0) {\r\n                    dt = resultCopy.substring(0, p0);\r\n                    dd = resultCopy.substring(p0 + 1);\r\n                    result = \"<dt>\" + dt + \"<\/dt>\" + \"<dd>\" + dd;\r\n                    defList = true;\r\n                }\r\n            } else if (defListLevel.length() > 0) { //less semicolons\r\n                String dt = \"\";\r\n                String dd = \"\";\r\n                int i = defListLevel.length();\r\n                String tmp = \"\";\r\n                while (!result.startsWith(defListLevel.substring(0, i))) {\r\n                    tmp += \"<\/dd><\/dl>\";\r\n                    i--;\r\n                }\r\n                defListLevel = defListLevel.substring(0, i);\r\n                p0 = defListLevel.length();\r\n                p1 = result.length();\r\n                if (defListLevel.length() > 0) {\r\n                    final String resultCopy = result.substring(p0, p1);\r\n                    if ((p0 = resultCopy.indexOf(\":\")) > 0) {\r\n                        dt = resultCopy.substring(0, p0);\r\n                        dd = resultCopy.substring(p0 + 1);\r\n                        result = tmp + \"<dt>\" + dt + \"<\/dt>\" + \"<dd>\" + dd;\r\n                        defList = true;\r\n                    }\r\n                } else {\r\n                    result = tmp + result.substring(p0, p1);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }","id":98783,"modified_method":"/**\r\n     * Processes tags which are connected to definition lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processDefinitionList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n\r\n            if (line.startsWith(defListLevel + \";\")) { //more semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                final int positionOfOpeningTag;\r\n                final int positionOfClosingTag = line.length();\r\n                final String copyOfLine = line.substring(defListLevel.length() + 1, positionOfClosingTag);\r\n                if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                    definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                    definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                    line = OPEN_DEFINITION_LIST +\r\n                            OPEN_DEFINITION_ITEM +\r\n                            definitionItem +\r\n                            CLOSE_DEFINITION_ITEM +\r\n                            OPEN_DEFINITION_DESCRIPTION +\r\n                            definitionDescription;\r\n                    processingDefList = true;\r\n                }\r\n                defListLevel += \";\";\r\n            } else if (defListLevel.length() > 0 && line.startsWith(defListLevel)) { //equal number of semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                final int positionOfOpeningTag;\r\n                final int positionOfClosingTag = line.length();\r\n                final String copyOfLine = line.substring(defListLevel.length(), positionOfClosingTag);\r\n                if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                    definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                    definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                    line = OPEN_DEFINITION_ITEM +\r\n                            definitionItem +\r\n                            CLOSE_DEFINITION_ITEM +\r\n                            OPEN_DEFINITION_DESCRIPTION +\r\n                            definitionDescription;\r\n                    processingDefList = true;\r\n                }\r\n            } else if (defListLevel.length() > 0) { //less semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                int i = defListLevel.length();\r\n                String tmp = EMPTY;\r\n                while (!line.startsWith(defListLevel.substring(0, i))) {\r\n                    tmp = CLOSE_DEFINITION_DESCRIPTION + CLOSE_DEFINITION_LIST;\r\n                    i--;\r\n                }\r\n                defListLevel = defListLevel.substring(0, i);\r\n                int positionOfOpeningTag = defListLevel.length();\r\n                final int positionOfClosingTag = line.length();\r\n                if (defListLevel.length() > 0) {\r\n                    final String copyOfLine = line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                    if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                        definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                        definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                        line = tmp + OPEN_DEFINITION_ITEM + definitionItem + CLOSE_DEFINITION_ITEM + OPEN_DEFINITION_DESCRIPTION + definitionDescription;\r\n                        processingDefList = true;\r\n                    }\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n        }\r\n        return line;\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private StringBuilder addPair(final String key, final String value, final StringBuilder sb) {\r\n        return sb.append(\" \").append(key).append(\"=\\\"\").append(value).append(\"\\\"\");\r\n    }","id":98784,"modified_method":"/**\r\n     * Appends a key/value pair in HTML syntax to a given StringBuilder.\r\n     * @param key key to be appended.\r\n     * @param value value of key.\r\n     * @param stringBuilder this is what key/value are appended to.\r\n     * @return\r\n     */\r\n    private StringBuilder appendKeyValuePair(final String key, final String value, final StringBuilder stringBuilder) {\r\n        return stringBuilder.append(\" \").append(key).append(\"=\\\"\").append(value).append(\"\\\"\");\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** This method processes links and images.\r\n     */\r\n    //contributed by [AS] except where stated otherwise\r\n    private String linksAndImages(String result) {\r\n\r\n        // create links\r\n        String kl, kv, alt, align;\r\n        int p;\r\n        int p0 = 0;\r\n        int p1 = 0;\r\n        // internal links and images\r\n        while ((p0 = result.indexOf(\"[[\")) >= 0) {\r\n            p1 = result.indexOf(\"]]\", p0 + 2);\r\n            if (p1 <= p0) {\r\n                break;\r\n            }\r\n            kl = result.substring(p0 + 2, p1);\r\n\r\n            // this is the part of the code that's responsible for images\r\n            // contributed by [MN]\r\n            if (kl.startsWith(\"Image:\")) {\r\n                alt = \"\";\r\n                align = \"\";\r\n                kv = \"\";\r\n                kl = kl.substring(6);\r\n\r\n                // are there any arguments for the image?\r\n                if ((p = kl.indexOf(\"&#124;\")) > 0) {\r\n                    kv = kl.substring(p + 6);\r\n                    kl = kl.substring(0, p);\r\n                    // if there are 2 arguments, write them into ALIGN and ALT\r\n                    if ((p = kv.indexOf(\"&#124;\")) > 0) {\r\n                        align = kv.substring(0, p);\r\n                        //checking validity of value for align. Only non browser specific\r\n                        //values get supported. Not supported: absmiddle, baseline, texttop\r\n                        if ((align.equals(\"bottom\")) ||\r\n                                (align.equals(\"center\")) ||\r\n                                (align.equals(\"left\")) ||\r\n                                (align.equals(\"middle\")) ||\r\n                                (align.equals(\"right\")) ||\r\n                                (align.equals(\"top\"))) {\r\n                            align = \" align=\\\"\" + align + \"\\\"\";\r\n                        } else {\r\n                            align = \"\";\r\n                        }\r\n                        alt = \" alt=\\\"\" + kv.substring(p + 6) + \"\\\"\";\r\n                    } // if there is just one, put it into ALT\r\n                    else {\r\n                        alt = \" alt=\\\"\" + kv + \"\\\"\";\r\n                    }\r\n                }\r\n\r\n                // replace incomplete URLs and make them point to http://peerip:port/...\r\n                // with this feature you can access an image in DATA/HTDOCS/share/yacy.gif\r\n                // using the wikicode [[Image:share/yacy.gif]]\r\n                // or an image DATA/HTDOCS/grafics/kaskelix.jpg with [[Image:grafics/kaskelix.jpg]]\r\n                // you are free to use other sub-paths of DATA/HTDOCS\r\n                if (kl.indexOf(\"://\") < 1) {\r\n                    kl = \"http://\" + super.address + \"/\" + kl;\r\n                }\r\n\r\n                result = result.substring(0, p0) + \"<img src=\\\"\" + kl + \"\\\"\" + align + alt + \">\" + result.substring(p1 + 2);\r\n            } // end contrib [MN]\r\n            // if it's no image, it might be an internal link\r\n            else {\r\n                if ((p = kl.indexOf(\"&#124;\")) > 0) {\r\n                    kv = kl.substring(p + 6);\r\n                    kl = kl.substring(0, p);\r\n                } else {\r\n                    kv = kl;\r\n                }\r\n                result = result.substring(0, p0) + \"<a class=\\\"known\\\" href=\\\"Wiki.html?page=\" + kl + \"\\\">\" + kv + \"<\/a>\" + result.substring(p1 + 2); // oob exception in append() !\r\n            }\r\n        }\r\n\r\n        // external links\r\n        while ((p0 = result.indexOf(\"[\")) >= 0) {\r\n            p1 = result.indexOf(\"]\", p0 + 1);\r\n            if (p1 <= p0) {\r\n                break;\r\n            }\r\n            kl = result.substring(p0 + 1, p1);\r\n            if ((p = kl.indexOf(\" \")) > 0) {\r\n                kv = kl.substring(p + 1);\r\n                kl = kl.substring(0, p);\r\n            } // No text for the link? -> <a href=\"http://www.url.com/\">http://www.url.com/<\/a>\r\n            else {\r\n                kv = kl;\r\n            }\r\n            // replace incomplete URLs and make them point to http://peerip:port/...\r\n            // with this feature you can access a file at DATA/HTDOCS/share/page.html\r\n            // using the wikicode [share/page.html]\r\n            // or a file DATA/HTDOCS/www/page.html with [www/page.html]\r\n            // you are free to use other sub-paths of DATA/HTDOCS\r\n            if (kl.indexOf(\"://\") < 1) {\r\n                kl = \"http://\" + super.address + \"/\" + kl;\r\n            }\r\n            result = result.substring(0, p0) + \"<a class=\\\"extern\\\" href=\\\"\" + kl + \"\\\">\" + kv + \"<\/a>\" + result.substring(p1 + 1);\r\n        }\r\n        return result;\r\n    }","id":98785,"modified_method":"/**\r\n     * Processes tags which are connected to links and images.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processLinksAndImages(String line) {\r\n\r\n        // create links\r\n        String kl, kv, alt, align;\r\n        int p;\r\n        int positionOfOpeningTag;\r\n        int positionOfClosingTag;\r\n        // internal links and images\r\n        while ((positionOfOpeningTag = line.indexOf(WIKI_OPEN_LINK)) >= 0) {\r\n            positionOfClosingTag = line.indexOf(WIKI_CLOSE_LINK, positionOfOpeningTag + WIKI_OPEN_LINK.length());\r\n            if (positionOfClosingTag <= positionOfOpeningTag) {\r\n                break;\r\n            }\r\n            kl = line.substring(positionOfOpeningTag + WIKI_OPEN_LINK.length(), positionOfClosingTag);\r\n\r\n            // this is the part of the code that's responsible for images\r\n            // contributed by [MN]\r\n            if (kl.startsWith(\"Image:\")) {\r\n                alt = EMPTY;\r\n                align = EMPTY;\r\n                kv = EMPTY;\r\n                kl = kl.substring(6);\r\n\r\n                // are there any arguments for the image?\r\n                if ((p = kl.indexOf(PIPE_ESCAPED)) > 0) {\r\n                    kv = kl.substring(p + 6);\r\n                    kl = kl.substring(0, p);\r\n                    // if there are 2 arguments, write them into ALIGN and ALT\r\n                    if ((p = kv.indexOf(PIPE_ESCAPED)) > 0) {\r\n                        align = kv.substring(0, p);\r\n                        //checking validity of value for align. Only non browser specific\r\n                        //values get supported. Not supported: absmiddle, baseline, texttop\r\n                        if ((align.equals(\"bottom\"))\r\n                                || (align.equals(\"center\"))\r\n                                || (align.equals(\"left\"))\r\n                                || (align.equals(\"middle\"))\r\n                                || (align.equals(\"right\"))\r\n                                || (align.equals(\"top\"))) {\r\n                            align = \" align=\\\"\" + align + \"\\\"\";\r\n                        } else {\r\n                            align = EMPTY;\r\n                        }\r\n                        alt = \" alt=\\\"\" + kv.substring(p + 6) + \"\\\"\";\r\n                    } // if there is just one, put it into ALT\r\n                    else {\r\n                        alt = \" alt=\\\"\" + kv + \"\\\"\";\r\n                    }\r\n                }\r\n\r\n                // replace incomplete URLs and make them point to http://peerip:port/...\r\n                // with this feature you can access an image in DATA/HTDOCS/share/yacy.gif\r\n                // using the wikicode [[Image:share/yacy.gif]]\r\n                // or an image DATA/HTDOCS/grafics/kaskelix.jpg with [[Image:grafics/kaskelix.jpg]]\r\n                // you are free to use other sub-paths of DATA/HTDOCS\r\n                if (kl.indexOf(\"://\") < 1) {\r\n                    kl = \"http://\" + super.address + \"/\" + kl;\r\n                }\r\n\r\n                line = line.substring(0, positionOfOpeningTag) + \"<img src=\\\"\" + kl + \"\\\"\" + align + alt + \">\" + line.substring(positionOfClosingTag + 2);\r\n            } // end contrib [MN]\r\n            // if it's no image, it might be an internal link\r\n            else {\r\n                if ((p = kl.indexOf(PIPE_ESCAPED)) > 0) {\r\n                    kv = kl.substring(p + 6);\r\n                    kl = kl.substring(0, p);\r\n                } else {\r\n                    kv = kl;\r\n                }\r\n                line = line.substring(0, positionOfOpeningTag) + \"<a class=\\\"known\\\" href=\\\"Wiki.html?page=\" + kl + \"\\\">\" + kv + \"<\/a>\" + line.substring(positionOfClosingTag + 2); // oob exception in append() !\r\n            }\r\n        }\r\n\r\n        // external links\r\n        while ((positionOfOpeningTag = line.indexOf(\"[\")) >= 0) {\r\n            positionOfClosingTag = line.indexOf(\"]\", positionOfOpeningTag + 1);\r\n            if (positionOfClosingTag <= positionOfOpeningTag) {\r\n                break;\r\n            }\r\n            kl = line.substring(positionOfOpeningTag + 1, positionOfClosingTag);\r\n            if ((p = kl.indexOf(\" \")) > 0) {\r\n                kv = kl.substring(p + 1);\r\n                kl = kl.substring(0, p);\r\n            } // No text for the link? -> <a href=\"http://www.url.com/\">http://www.url.com/<\/a>\r\n            else {\r\n                kv = kl;\r\n            }\r\n            // replace incomplete URLs and make them point to http://peerip:port/...\r\n            // with this feature you can access a file at DATA/HTDOCS/share/page.html\r\n            // using the wikicode [share/page.html]\r\n            // or a file DATA/HTDOCS/www/page.html with [www/page.html]\r\n            // you are free to use other sub-paths of DATA/HTDOCS\r\n            if (kl.indexOf(\"://\") < 1) {\r\n                kl = \"http://\" + super.address + \"/\" + kl;\r\n            }\r\n            line = line.substring(0, positionOfOpeningTag) + \"<a class=\\\"extern\\\" href=\\\"\" + kl + \"\\\">\" + kv + \"<\/a>\" + line.substring(positionOfClosingTag + 1);\r\n        }\r\n        return line;\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** This method takes possible table properties and tests if they are valid.\r\n     * Valid in this case means if they are a property for the table, tr or td\r\n     * tag as stated in the HTML Pocket Reference by Jennifer Niederst (1st edition)\r\n     * The method is important to avoid XSS attacks on the wiki via table properties.\r\n     * @param properties A string that may contain several table properties and/or junk.\r\n     * @return A string that only contains table properties.\r\n     */\r\n    private StringBuilder parseTableProperties(final String properties) {\r\n        final String[] values = properties.replaceAll(\"&quot;\", \"\").split(\"[= ]\");     //splitting the string at = and blanks\r\n        final StringBuilder sb = new StringBuilder(properties.length());\r\n        String key, value;\r\n        String[] posVals;\r\n        final int numberofvalues = values.length;\r\n        for (int i = 0; i < numberofvalues; i++) {\r\n            key = values[i].trim();\r\n            if (key.equals(\"nowrap\")) {\r\n                addPair(\"nowrap\", \"nowrap\", sb);\r\n            } else if (i + 1 < numberofvalues) {\r\n                value = values[++i].trim();\r\n                if ((key.equals(\"summary\")) ||\r\n                        (key.equals(\"bgcolor\") && value.matches(\"#{0,1}[0-9a-fA-F]{1,6}|[a-zA-Z]{3,}\")) ||\r\n                        ((key.equals(\"width\") || key.equals(\"height\")) && value.matches(\"\\\\d+%{0,1}\")) ||\r\n                        ((posVals = ps.get(key)) != null && Arrays.binarySearch(posVals, value) >= 0) ||\r\n                        (Arrays.binarySearch(tps, key) >= 0 && value.matches(\"\\\\d+\"))) {\r\n                    addPair(key, value, sb);\r\n                }\r\n            }\r\n        }\r\n        return sb;\r\n    }","id":98786,"modified_method":"/** This method takes possible table properties and tests if they are valid.\r\n     * Valid in this case means if they are a property for the table, tr or td\r\n     * tag as stated in the HTML Pocket Reference by Jennifer Niederst (1st edition)\r\n     * The method is important to avoid XSS attacks on the wiki via table properties.\r\n     * @param properties String which may contain several table properties and/or junk.\r\n     * @return String containing only table properties.\r\n     */\r\n    private StringBuilder filterTableProperties(final String properties) {\r\n        final String[] values = properties.replaceAll(\"&quot;\", EMPTY).split(\"[= ]\");     //splitting the string at = and blanks\r\n        final StringBuilder stringBuilder = new StringBuilder(properties.length());\r\n        String key, value;\r\n        String[] posVals;\r\n        final int numberOfValues = values.length;\r\n        for (int i = 0; i < numberOfValues; i++) {\r\n            key = values[i].trim();\r\n            if (key.equals(\"nowrap\")) {\r\n                appendKeyValuePair(\"nowrap\", \"nowrap\", stringBuilder);\r\n            } else if (i + 1 < numberOfValues) {\r\n                value = values[++i].trim();\r\n                if ((key.equals(\"summary\"))\r\n                        || (key.equals(\"bgcolor\") && value.matches(\"#{0,1}[0-9a-fA-F]{1,6}|[a-zA-Z]{3,}\"))\r\n                        || ((key.equals(\"width\") || key.equals(\"height\")) && value.matches(\"\\\\d+%{0,1}\"))\r\n                        || ((posVals = PROPERTY_VALUES.get(key)) != null && Arrays.binarySearch(posVals, value) >= 0)\r\n                        || (Arrays.binarySearch(TABLE_PROPERTIES, key) >= 0 && value.matches(\"\\\\d+\"))) {\r\n                    appendKeyValuePair(key, value, stringBuilder);\r\n                }\r\n            }\r\n        }\r\n        return stringBuilder;\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** This method handles the preformatted tags <pre> <\/pre> */\r\n    //contributed by [MN]\r\n    private String preformattedTag(String result) {\r\n        int p0 = 0;\r\n        int p1 = 0;\r\n        //both <pre> and <\/pre> in the same line\r\n        if (((p0 = result.indexOf(\"&lt;pre&gt;\")) >= 0) && ((p1 = result.indexOf(\"&lt;/pre&gt;\")) > 0) && (!(escaped))) {\r\n            if (p0 < p1) {\r\n                String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + result.substring(p0 + 11, p1) + \"<\/pre>\";\r\n                preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n                result = transformLine(result.substring(0, p0).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\" + result.substring(p1 + 12).replaceAll(\"!pre!\", \"!pre!!\"));\r\n                result = result.replaceAll(\"!pre!txt!\", preformattedText);\r\n                result = result.replaceAll(\"!pre!!\", \"!pre!\");\r\n            } //handles cases like <pre><pre> <\/pre><\/pre> <pre> <\/pre> that would cause an exception otherwise\r\n            else {\r\n                preformatted = true;\r\n                final String temp1 = transformLine(result.substring(0, p0 - 1).replaceAll(\"!tmp!\", \"!tmp!!\") + \"!tmp!txt!\");\r\n                nolist = true;\r\n                final String temp2 = transformLine(result.substring(p0));\r\n                nolist = false;\r\n                result = temp1.replaceAll(\"!tmp!txt!\", temp2);\r\n                result = result.replaceAll(\"!tmp!!\", \"!tmp!\");\r\n                preformatted = false;\r\n            }\r\n        } //start <pre>\r\n        else if (((p0 = result.indexOf(\"&lt;pre&gt;\")) >= 0) && (!preformattedSpan) && (!escaped)) {\r\n            preformatted = true;    //prevent surplus line breaks\r\n            String bq = \"\";  //gets filled with <blockquote>s as needed\r\n            String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + result.substring(p0 + 11);\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (result.substring(preindented, p0).startsWith(\":\")) {\r\n                preindented++;\r\n                bq = bq + \"<blockquote>\";\r\n            }\r\n            result = transformLine(result.substring(preindented, p0).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\");\r\n            result = bq + result.replaceAll(\"!pre!txt!\", preformattedText);\r\n            result = result.replaceAll(\"!pre!!\", \"!pre!\");\r\n            preformattedSpan = true;\r\n        } //end <\/pre>\r\n        else if (((p0 = result.indexOf(\"&lt;/pre&gt;\")) >= 0) && (preformattedSpan) && (!escaped)) {\r\n            preformattedSpan = false;\r\n            String bq = \"\"; //gets filled with <\/blockquote>s as needed\r\n            String preformattedText = result.substring(0, p0) + \"<\/pre>\";\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (preindented > 0) {\r\n                bq = bq + \"<\/blockquote>\";\r\n                preindented--;\r\n            }\r\n            result = transformLine(\"!pre!txt!\" + result.substring(p0 + 12).replaceAll(\"!pre!\", \"!pre!!\"));\r\n            result = result.replaceAll(\"!pre!txt!\", preformattedText) + bq;\r\n            result = result.replaceAll(\"!pre!!\", \"!pre!\");\r\n            preformatted = false;\r\n        } //Getting rid of surplus <\/pre>\r\n        else if (((p0 = result.indexOf(\"&lt;/pre&gt;\")) >= 0) && (!preformattedSpan) && (!escaped)) {\r\n            while ((p0 = result.indexOf(\"&lt;/pre&gt;\")) >= 0) {\r\n                result = result.substring(0, p0) + result.substring(p0 + 12);\r\n            }\r\n            result = transformLine(result);\r\n        }\r\n        return result;\r\n    }","id":98787,"modified_method":"/**\r\n     * Processes tags which are connected preformatted text (&lt;pre&gt; &lt;/pre&gt;).\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processPreformattedText(String line) {\r\n        int positionOfOpeningTag;\r\n        int positionOfClosingTag;\r\n        //both <pre> and <\/pre> in the same line\r\n        if (((positionOfOpeningTag = line.indexOf(\"&lt;pre&gt;\")) >= 0) && ((positionOfClosingTag = line.indexOf(\"&lt;/pre&gt;\")) > 0) && (!(escaped))) {\r\n            if (positionOfOpeningTag < positionOfClosingTag) {\r\n                String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + 11, positionOfClosingTag) + \"<\/pre>\";\r\n                preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n                line = processLineOfWikiCode(line.substring(0, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\" + line.substring(positionOfClosingTag + 12).replaceAll(\"!pre!\", \"!pre!!\"));\r\n                line = line.replaceAll(\"!pre!txt!\", preformattedText);\r\n                line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            } //handles cases like <pre><pre> <\/pre><\/pre> <pre> <\/pre> that would cause an exception otherwise\r\n            else {\r\n                processingPreformattedText = true;\r\n                final String temp1 = processLineOfWikiCode(line.substring(0, positionOfOpeningTag - 1).replaceAll(\"!tmp!\", \"!tmp!!\") + \"!tmp!txt!\");\r\n                noList = true;\r\n                final String temp2 = processLineOfWikiCode(line.substring(positionOfOpeningTag));\r\n                noList = false;\r\n                line = temp1.replaceAll(\"!tmp!txt!\", temp2);\r\n                line = line.replaceAll(\"!tmp!!\", \"!tmp!\");\r\n                processingPreformattedText = false;\r\n            }\r\n        } //start <pre>\r\n        else if (((positionOfOpeningTag = line.indexOf(\"&lt;pre&gt;\")) >= 0) && (!preformattedSpanning) && (!escaped)) {\r\n            processingPreformattedText = true;    //prevent surplus line breaks\r\n            final StringBuilder openBlockQuoteTags = new StringBuilder();  //gets filled with <blockquote>s as needed\r\n            String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + 11);\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (line.substring(preindented, positionOfOpeningTag).startsWith(\":\")) {\r\n                preindented++;\r\n                openBlockQuoteTags.append(OPEN_BLOCKQUOTE);\r\n            }\r\n            line = processLineOfWikiCode(line.substring(preindented, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\");\r\n            line = openBlockQuoteTags + line.replaceAll(\"!pre!txt!\", preformattedText);\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            preformattedSpanning = true;\r\n        } //end <\/pre>\r\n        else if (((positionOfOpeningTag = line.indexOf(\"&lt;/pre&gt;\")) >= 0) && (preformattedSpanning) && (!escaped)) {\r\n            preformattedSpanning = false;\r\n            final StringBuilder endBlockQuoteTags = new StringBuilder(); //gets filled with <\/blockquote>s as needed\r\n            String preformattedText = line.substring(0, positionOfOpeningTag) + \"<\/pre>\";\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (preindented > 0) {\r\n                endBlockQuoteTags.append(CLOSE_BLOCKQUOTE);\r\n                preindented--;\r\n            }\r\n            line = processLineOfWikiCode(\"!pre!txt!\" + line.substring(positionOfOpeningTag + 12).replaceAll(\"!pre!\", \"!pre!!\"));\r\n            line = line.replaceAll(\"!pre!txt!\", preformattedText) + endBlockQuoteTags;\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            processingPreformattedText = false;\r\n        } //Getting rid of surplus <\/pre>\r\n        else if (((positionOfOpeningTag = line.indexOf(\"&lt;/pre&gt;\")) >= 0) && (!preformattedSpanning) && (!escaped)) {\r\n            while ((positionOfOpeningTag = line.indexOf(\"&lt;/pre&gt;\")) >= 0) {\r\n                line = line.substring(0, positionOfOpeningTag) + line.substring(positionOfOpeningTag + 12);\r\n            }\r\n            line = processLineOfWikiCode(line);\r\n        }\r\n        return line;\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** Replaces two occurences of a substring in a string by a pair of strings if \r\n     * that substring occurs twice in the string. This method is not greedy! You'll\r\n     * have to run it in a loop if you want to replace all occurences of the substring.\r\n     * This method provides special treatment for headlines.\r\n     * @param input the string that something is to be replaced in\r\n     * @param pat substring to be replaced\r\n     * @param repl1 string substring gets replaced by on uneven occurences\r\n     * @param repl2 string substring gets replaced by on even occurences\r\n     */\r\n    //[MN]\r\n    private String pairReplace(String input, final String pat, final String repl1, final String repl2) {\r\n        String direlem = null;    //string to keep headlines until they get added to List dirElements\r\n        int p0 = 0;\r\n        int p1 = 0;\r\n        final int l = pat.length();\r\n        //replace pattern if a pair of the pattern can be found in the line\r\n        if (((p0 = input.indexOf(pat)) >= 0) && ((p1 = input.indexOf(pat, p0 + l)) >= 0)) {\r\n            //extra treatment for headlines\r\n            if (Arrays.binarySearch(headlineTags, pat) >= 0) {\r\n                //add anchor and create headline\r\n                direlem = input.substring(p0 + l, p1);\r\n                if (direlem != null) {\r\n                    //counting double headlines\r\n                    int doubles = 0;\r\n                    for (int i = 0; i < dirElements.size(); i++) {\r\n                        // no element with null value should ever be in directory\r\n                        assert (dirElements.get(i) != null);\r\n\r\n                        if (dirElements.size() > i && dirElements.get(i).substring(1).equals(direlem)) {\r\n                            doubles++;\r\n                        }\r\n                    }\r\n                    String anchor = direlem.replaceAll(\" \", \"_\").replaceAll(\"[^a-zA-Z0-9_]\", \"\"); //replace blanks with underscores and delete everything thats not a regular character, a number or _\r\n                    //if there are doubles, add underscore and number of doubles plus one\r\n                    if (doubles > 0) {\r\n                        anchor = anchor + \"_\" + (doubles + 1);\r\n                    }\r\n                    input = input.substring(0, p0) + \"<a name=\\\"\" + anchor + \"\\\"><\/a>\" + repl1 +\r\n                            direlem + repl2 + input.substring(p1 + l);\r\n                    //add headlines to list of headlines (so TOC can be created)\r\n                    if (Arrays.binarySearch(headlineTags, pat) >= 0) {\r\n                        dirElements.add((pat.length() - 1) + direlem);\r\n                    }\r\n                }\r\n            } else {\r\n                input = input.substring(0, p0) + repl1 +\r\n                        (input.substring(p0 + l, p1)) + repl2 +\r\n                        input.substring(p1 + l);\r\n            }\r\n        }\r\n        //recursion if a pair of the pattern can still be found in the line\r\n        if (((p0 = input.indexOf(pat)) >= 0) && (input.indexOf(pat, p0 + l) >= 0)) {\r\n            input = pairReplace(input, pat, repl1, repl2);\r\n        }\r\n        return input;\r\n    }","id":98788,"modified_method":"/** Replaces two occurences of a substring in a string by a pair of strings if \r\n     * that substring occurs twice in the string. This method is not greedy! You'll\r\n     * have to run it in a loop if you want to replace all occurences of the substring.\r\n     * This method provides special treatment for headlines.\r\n     * @param input the string that something is to be replaced in\r\n     * @param pat substring to be replaced\r\n     * @param repl1 string substring gets replaced by on uneven occurences\r\n     * @param repl2 string substring gets replaced by on even occurences\r\n     */\r\n    //[MN]\r\n    private String pairReplace(String input, final String pat, final String repl1, final String repl2) {\r\n        String direlem = null;    //string to keep headlines until they get added to List dirElements\r\n        int firstPosition;\r\n        final int secondPosition;\r\n        final int strLen = pat.length();\r\n        //replace pattern if a pair of the pattern can be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && ((secondPosition = input.indexOf(pat, firstPosition + strLen)) >= 0)) {\r\n            //extra treatment for headlines\r\n            if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                //add anchor and create headline\r\n                direlem = input.substring(firstPosition + strLen, secondPosition);\r\n                if (direlem != null) {\r\n                    //counting double headlines\r\n                    int doubles = 0;\r\n                    for (int i = 0; i < tableOfContentElements.size(); i++) {\r\n                        // no element with null value should ever be in directory\r\n                        assert (tableOfContentElements.get(i) != null);\r\n\r\n                        if (tableOfContentElements.size() > i && tableOfContentElements.get(i).substring(1).equals(direlem)) {\r\n                            doubles++;\r\n                        }\r\n                    }\r\n                    String anchor = direlem.replaceAll(\" \", \"_\").replaceAll(NOT_CHARACTER_NUMBER_OR_UNDERSCORE, EMPTY); //replace blanks with underscores and delete everything thats not a regular character, a number or _\r\n                    //if there are doubles, add underscore and number of doubles plus one\r\n                    if (doubles > 0) {\r\n                        anchor = anchor + \"_\" + (doubles + 1);\r\n                    }\r\n                    input = input.substring(0, firstPosition) + \"<a name=\\\"\" + anchor + \"\\\"><\/a>\" + repl1\r\n                            + direlem + repl2 + input.substring(secondPosition + strLen);\r\n                    //add headlines to list of headlines (so TOC can be created)\r\n                    if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                        tableOfContentElements.add((pat.length() - 1) + direlem);\r\n                    }\r\n                }\r\n            } else {\r\n                input = input.substring(0, firstPosition) + repl1\r\n                        + (input.substring(firstPosition + strLen, secondPosition)) + repl2\r\n                        + input.substring(secondPosition + strLen);\r\n            }\r\n        }\r\n        //recursion if another pair of the pattern can still be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && (input.indexOf(pat, firstPosition + strLen) >= 0)) {\r\n            input = pairReplace(input, pat, repl1, repl2);\r\n        }\r\n        return input;\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Processes tables in the wiki code.\r\n     * @param input String which might or might not contain parts of a table.\r\n     * @return String with wiki code of parts of table replaced by HTML code for table.\r\n     */\r\n    //[FB], changes by [MN]\r\n    private String processTable(final String input) {\r\n        //some variables that make it easier to change codes for the table\r\n        String line = \"\";\r\n        final String tableStart = \"&#123;&#124;\";                 // {|\r\n        final String newLine = \"&#124;-\";                         // |-\r\n        final String cellDivider = \"&#124;&#124;\";                // ||\r\n        final String tableEnd = \"&#124;&#125;\";                   // |}\r\n        final String attribDivider = \"&#124;\";                    // |\r\n        final int lenTableStart = tableStart.length();\r\n        final int lenCellDivider = cellDivider.length();\r\n        final int lenTableEnd = tableEnd.length();\r\n        final int lenAttribDivider = attribDivider.length();\r\n\r\n        if ((input.startsWith(tableStart)) && (!table)) {\r\n            table = true;\r\n            newrowstart = true;\r\n            line = \"<table\";\r\n            if (input.trim().length() > lenTableStart) {\r\n                line += parseTableProperties(input.substring(lenTableStart).trim()).toString();\r\n            }\r\n            line += \">\";\r\n        } else if (input.startsWith(newLine) && (table)) {          // new row\r\n            if (!newrowstart) {\r\n                line += \"\\t<\/tr>\\n\";\r\n            } else {\r\n                newrowstart = false;\r\n            }\r\n            line = line + \"\\t<tr>\";\r\n        } else if ((input.startsWith(cellDivider)) && (table)) {\r\n            line += \"\\t\\t<td\";\r\n            final int cellEnd = (input.indexOf(cellDivider, lenCellDivider) > 0) ? (input.indexOf(cellDivider, lenCellDivider)) : (input.length());\r\n            int propEnd = input.indexOf(attribDivider, lenCellDivider);\r\n            final int occImage = input.indexOf(\"[[Image:\", lenCellDivider);\r\n            final int occEscape = input.indexOf(\"[=\", lenCellDivider);\r\n            //If resultOf(\"[[Image:\") is less than propEnd, that means that there is no\r\n            //property for this cell, only an image. Without this, YaCy could get confused\r\n            //by a | in [[Image:picture.png|alt-text]] or [[Image:picture.png|alt-text]]\r\n            //Same for [= (part of [= =])\r\n            if ((propEnd > lenCellDivider) && ((occImage > propEnd) || (occImage < 0)) && ((occEscape > propEnd) || (occEscape < 0))) {\r\n                propEnd = input.indexOf(attribDivider, lenCellDivider) + lenAttribDivider;\r\n            } else {\r\n                propEnd = cellEnd;\r\n            }\r\n            // both point at same place => new line\r\n            if (propEnd == cellEnd) {\r\n                propEnd = lenCellDivider;\r\n            } else {\r\n                line += parseTableProperties(input.substring(lenCellDivider, propEnd - lenAttribDivider).trim()).toString();\r\n            }\r\n            // quick&dirty fix [MN]\r\n            if (propEnd > cellEnd) {\r\n                propEnd = lenCellDivider;\r\n            }\r\n            table = false;\r\n            cellprocessing = true;\r\n            line += \">\" + processTable(input.substring(propEnd, cellEnd).trim()) + \"<\/td>\";\r\n            table = true;\r\n            cellprocessing = false;\r\n            if (cellEnd < input.length()) {\r\n                line += \"\\n\" + processTable(input.substring(cellEnd));\r\n            }\r\n        } else if (input.startsWith(tableEnd) && (table)) {          // Table end\r\n            table = false;\r\n            line += \"\\t<\/tr>\\n<\/table>\" + input.substring(lenTableEnd);\r\n        } else {\r\n            line = input;\r\n        }\r\n        return line;\r\n    }","id":98789,"modified_method":"/**\r\n     * Processes tags which are connected to tables.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processTable(final String line) {\r\n        //some variables that make it easier to change codes for the table\r\n        final StringBuilder out = new StringBuilder();\r\n        final String tableStart = \"&#123;\" + PIPE_ESCAPED;        // {|\r\n        final String newLine = PIPE_ESCAPED + \"-\";                // |-\r\n        final String cellDivider = PIPE_ESCAPED + PIPE_ESCAPED;   // ||\r\n        final String tableEnd = PIPE_ESCAPED + \"&#125;\";          // |}\r\n        final String attribDivider = PIPE_ESCAPED;                // |\r\n        final int lenTableStart = tableStart.length();\r\n        final int lenCellDivider = cellDivider.length();\r\n        final int lenTableEnd = tableEnd.length();\r\n        final int lenAttribDivider = attribDivider.length();\r\n\r\n        if ((line.startsWith(tableStart)) && (!processingTable)) {\r\n            processingTable = true;\r\n            newRowStart = true;\r\n            out.append(\"<table\");\r\n            if (line.trim().length() > lenTableStart) {\r\n                out.append(filterTableProperties(line.substring(lenTableStart).trim()));\r\n            }\r\n            out.append(\">\");\r\n        } else if (line.startsWith(newLine) && (processingTable)) {          // new row\r\n            if (!newRowStart) {\r\n                out.append(\"\\t<\/tr>\\n\");\r\n            } else {\r\n                newRowStart = false;\r\n            }\r\n            out.append(\"\\t<tr>\");\r\n        } else if ((line.startsWith(cellDivider)) && (processingTable)) {\r\n            out.append(\"\\t\\t<td\");\r\n            final int cellEnd = (line.indexOf(cellDivider, lenCellDivider) > 0) ? (line.indexOf(cellDivider, lenCellDivider)) : (line.length());\r\n            int propEnd = line.indexOf(attribDivider, lenCellDivider);\r\n            final int occImage = line.indexOf(\"[[Image:\", lenCellDivider);\r\n            final int occEscape = line.indexOf(\"[=\", lenCellDivider);\r\n            //If resultOf(\"[[Image:\") is less than propEnd, that means that there is no\r\n            //property for this cell, only an image. Without this, YaCy could get confused\r\n            //by a | in [[Image:picture.png|alt-text]] or [[Image:picture.png|alt-text]]\r\n            //Same for [= (part of [= =])\r\n            if ((propEnd > lenCellDivider) && ((occImage > propEnd) || (occImage < 0)) && ((occEscape > propEnd) || (occEscape < 0))) {\r\n                propEnd = line.indexOf(attribDivider, lenCellDivider) + lenAttribDivider;\r\n            } else {\r\n                propEnd = cellEnd;\r\n            }\r\n            // both point at same place => new line\r\n            if (propEnd == cellEnd) {\r\n                propEnd = lenCellDivider;\r\n            } else {\r\n                out.append(filterTableProperties(line.substring(lenCellDivider, propEnd - lenAttribDivider).trim()));\r\n            }\r\n            // quick&dirty fix [MN]\r\n            if (propEnd > cellEnd) {\r\n                propEnd = lenCellDivider;\r\n            }\r\n            processingTable = false;\r\n            processingCell = true;\r\n            out.append(\">\");\r\n            out.append(processTable(line.substring(propEnd, cellEnd).trim()));\r\n            out.append(\"<\/td>\");\r\n            processingTable = true;\r\n            processingCell = false;\r\n            if (cellEnd < line.length()) {\r\n                out.append(\"\\n\");\r\n                out.append(processTable(line.substring(cellEnd)));\r\n            }\r\n        } else if (line.startsWith(tableEnd) && (processingTable)) {          // Table end\r\n            processingTable = false;\r\n            out.append(\"\\t<\/tr>\\n<\/table>\");\r\n            out.append(line.substring(lenTableEnd));\r\n        } else {\r\n            out.append(line);\r\n        }\r\n        return out.toString();\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** Constructor of the class wikiCode */\r\n    public wikiCode(String address) {\r\n        super(address);\r\n    }","id":98790,"modified_method":"/**\r\n     * Constructor\r\n     * @param address\r\n     */\r\n    public wikiCode(final String address) {\r\n        super(address);\r\n    }","commit_id":"5f391fcfa968f86be6af4622c37ca9ed1426dffa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected URI getBaseURI() throws XWikiRestException\n    {\n        try {\n            XWikiContext context = contextProvider.get();\n            XWiki xwiki = context.getWiki();\n\n            String url = context.getURLFactory().getServerURL(context).toString() +  \"/\"\n                + xwiki.getWebAppPath(context) + \"rest\";\n\n            return new URI(url);\n        } catch (URISyntaxException | MalformedURLException e) {\n            throw new XWikiRestException(\"Failed to generate a proper base URI.\", e);\n        }\n    }","id":98791,"modified_method":"protected URI getBaseURI() throws XWikiRestException\n    {\n        try {\n            XWikiContext context = contextProvider.get();\n            XWiki xwiki = context.getWiki();\n\n            StringBuilder url = new StringBuilder();\n\n            url.append(context.getURLFactory().getServerURL(context));\n\n            url.append('/');\n\n            String webAppPath = xwiki.getWebAppPath(context);\n            if (!webAppPath.equals(\"/\")) {\n                url.append(webAppPath);\n            }\n\n            url.append(\"rest\");\n\n            return new URI(url.toString());\n        } catch (URISyntaxException | MalformedURLException e) {\n            throw new XWikiRestException(\"Failed to generate a proper base URI.\", e);\n        }\n    }","commit_id":"bb28df0daa21d5b460e89432c378ff3527728e4a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void loadSchemasIfNeeded(PipelineContext pipelineContext) {\n        final Element modelElement = modelDocument.getRootElement();\n        // Create Schema validator only if we have schemas specified\n        if (modelElement.attributeValue(\"schema\") != null && schemaValidator == null) {\n            schemaValidator = new XFormsModelSchemaValidator();\n            schemaValidator.loadSchemas(pipelineContext, modelElement);\n        }\n    }","id":98792,"modified_method":"private void loadSchemasIfNeeded(PipelineContext pipelineContext) {\n        final Element modelElement = modelDocument.getRootElement();\n        // Create Schema validator only if we have schemas specified\n        if (modelElement.attributeValue(\"schema\") != null && schemaValidator == null) {\n            schemaValidator = new XFormsModelSchemaValidator();\n            schemaValidator.loadSchemas(pipelineContext, containingDocument, modelElement);\n        }\n    }","commit_id":"b4f4a3808f4e15f06cc7bd310a5187aba4cadf99","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Load XForms model schemas.\n     */\n    public void loadSchemas(final PipelineContext pipelineContext, Element modelElement) {\n        if (!isSkipInstanceSchemaValidation()) {\n            String schemaURI = modelElement.attributeValue(\"schema\");\n            if (schemaURI != null) {\n                // Resolve URI\n                String systemID = ((LocationData) modelElement.getData()).getSystemID();\n                try {\n                    schemaURI = URLFactory.createURL(systemID, schemaURI).toString();\n                } catch (MalformedURLException e) {\n                    throw new OXFException(e);\n                }\n                // Load associated grammar\n                schemaGrammar = loadGrammar(pipelineContext, schemaURI);\n            }\n        }\n    }","id":98793,"modified_method":"/**\n     * Load XForms model schemas.\n     */\n    public void loadSchemas(final PipelineContext pipelineContext, XFormsContainingDocument containingDocument, Element modelElement) {\n        if (!isSkipInstanceSchemaValidation()) {\n            final String schemaURIs = modelElement.attributeValue(\"schema\");\n            if (schemaURIs != null) {\n\n                final String schemaURI = schemaURIs;// TODO: check for multiple schemas\n\n                // External instance\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                // Resolve URL\n                // TODO: We do not support \"optimized\" access here, we always use an URL, because loadGrammar() wants a URL\n                final String resolvedURLString = XFormsUtils.resolveURL(containingDocument, pipelineContext, modelElement, false, schemaURI);\n                final URL resolvedURL = XFormsSubmissionUtils.createURL(resolvedURLString, null, externalContext);\n\n                // Load associated grammar\n                schemaGrammar = loadGrammar(pipelineContext, resolvedURL.toExternalForm());\n            }\n        }\n    }","commit_id":"b4f4a3808f4e15f06cc7bd310a5187aba4cadf99","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void handleItemCompact(ContentHandler contentHandler, String optionQName, XFormsControls.ControlInfo controlInfo,\n                                   boolean isMany, Item item) throws SAXException {\n\n        final AttributesImpl optionAttributes = getAttributes(item.getAttributes(), null, null);\n        optionAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, item.getValue());\n\n        // Figure out whether what items are selected\n        final String value = item.getValue();\n        if (!handlerContext.isGenerateTemplate() && controlInfo != null) {\n\n            boolean selected = false;\n            if (isMany) {\n                for (final StringTokenizer st = new StringTokenizer(controlInfo.getValue()); st.hasMoreTokens();) {\n                    final String token = st.nextToken();\n                    if (token.equals(value)) {\n                        selected = true;\n                        break;\n                    }\n                }\n            } else {\n                final String controlValue = controlInfo.getValue();\n                selected = controlValue != null && controlValue.equals(value);\n            }\n            if (selected)\n                optionAttributes.addAttribute(\"\", \"selected\", \"selected\", ContentHandlerHelper.CDATA, \"selected\");\n        }\n\n        // xhtml:option\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"option\", optionQName, optionAttributes);\n        final String label = item.getLabel();\n        contentHandler.characters(label.toCharArray(), 0, label.length());\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"option\", optionQName);\n    }","id":98794,"modified_method":"private void handleItemCompact(ContentHandler contentHandler, String optionQName, XFormsControls.ControlInfo controlInfo,\n                                   boolean isMany, Item item) throws SAXException {\n\n        final AttributesImpl optionAttributes = getAttributes(item.getAttributes(), null, null);\n        optionAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, item.getValue());\n\n        // Figure out whether what items are selected\n        final String value = item.getValue();\n        if (!handlerContext.isGenerateTemplate() && controlInfo != null) {\n\n            boolean selected = false;\n            if (isMany) {\n                for (final StringTokenizer st = new StringTokenizer(controlInfo.getValue()); st.hasMoreTokens();) {\n                    final String token = st.nextToken();\n                    if (token.equals(value)) {\n                        selected = true;\n                        break;\n                    }\n                }\n            } else {\n                final String controlValue = controlInfo.getValue();\n                selected = controlValue != null && controlValue.equals(value);\n            }\n            if (selected)\n                optionAttributes.addAttribute(\"\", \"selected\", \"selected\", ContentHandlerHelper.CDATA, \"selected\");\n        }\n\n        // xhtml:option\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"option\", optionQName, optionAttributes);\n        final String label = item.getLabel();\n        if (label != null)\n            contentHandler.characters(label.toCharArray(), 0, label.length());\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"option\", optionQName);\n    }","commit_id":"b4f4a3808f4e15f06cc7bd310a5187aba4cadf99","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * @param action absolute URL or absolute path (which must include the context path)\n     */\n    public static XFormsModelSubmission.ConnectionResult doRegular(PipelineContext pipelineContext, ExternalContext externalContext,\n                                                                   String method, final String action, String mediatype, boolean doReplace,\n                                                                   byte[] serializedInstance, String serializedInstanceString) {\n\n        // Compute submission URL\n        final URL submissionURL;\n        try {\n            final String actionString;\n            {\n                final StringBuffer updatedActionStringBuffer = new StringBuffer(action);\n                if (serializedInstanceString != null) {\n                    if (action.indexOf('?') == -1)\n                        updatedActionStringBuffer.append('?');\n                    else\n                        updatedActionStringBuffer.append('&');\n                    updatedActionStringBuffer.append(serializedInstanceString);\n                }\n                actionString = updatedActionStringBuffer.toString();\n            }\n\n            if (actionString.startsWith(\"/\")) {\n                // Case of path absolute\n                final String requestURL = externalContext.getRequest().getRequestURL();\n                submissionURL = URLFactory.createURL(requestURL, actionString);\n            } else if (NetUtils.urlHasProtocol(actionString)) {\n                // Case of absolute URL\n                submissionURL = URLFactory.createURL(actionString);\n            } else {\n                throw new OXFException(\"xforms:submission: invalid action: \" + actionString);\n            }\n        } catch (MalformedURLException e) {\n            throw new OXFException(\"xforms:submission: invalid action: \" + action, e);\n        }\n\n        // Perform submission\n        final String scheme = submissionURL.getProtocol();\n        if (scheme.equals(\"http\") || scheme.equals(\"https\") || (isGet(method) && (scheme.equals(\"file\") || scheme.equals(\"oxf\")))) {\n            // http MUST be supported\n            // https SHOULD be supported\n            // file SHOULD be supported\n            try {\n                final URLConnection urlConnection = submissionURL.openConnection();\n                final HttpURLConnection httpURLConnection = (urlConnection instanceof HttpURLConnection) ? (HttpURLConnection) urlConnection : null;\n                if (isPost(method) || isPut(method) || isGet(method)) {\n                    urlConnection.setDoInput(true);\n                    urlConnection.setDoOutput(!isGet(method)); // Only if POST / PUT\n\n                    if (httpURLConnection != null) {\n                        httpURLConnection.setRequestMethod(method.toUpperCase());\n                    }\n                    if (!isGet(method))\n                        urlConnection.setRequestProperty(\"content-type\", (mediatype != null) ? mediatype : \"application/xml\");\n\n                    // Forward cookies for session handling\n                    // TODO: The Servlet spec mandates JSESSIONID as cookie name; we should only forward this cookie\n                    final String[] cookies = (String[]) externalContext.getRequest().getHeaderValuesMap().get(\"cookie\");\n                    if (cookies != null) {\n                        for (int i = 0; i < cookies.length; i++) {\n                            final String cookie = cookies[i];\n                            urlConnection.setRequestProperty(\"cookie\", cookie);\n                        }\n                    }\n\n                    urlConnection.connect();\n\n                    // Write request body if needed\n                    if (!isGet(method)) {\n                        final OutputStream os = urlConnection.getOutputStream();\n                        try {\n                            os.write(serializedInstance);\n                        } finally {\n                            if (os != null) {\n                                try {\n                                    os.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing output stream for action: \" + action);\n                                }\n                            }\n                        }\n                    }\n\n                    // Create result\n                    final XFormsModelSubmission.ConnectionResult connectionResult = new XFormsModelSubmission.ConnectionResult(submissionURL.toExternalForm()) {\n                        public void close() {\n                            if (resultInputStream != null) {\n                                try {\n                                    resultInputStream.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing input stream for action: \" + action);\n                                }\n                            }\n\n                            if (httpURLConnection != null)\n                                httpURLConnection.disconnect();\n                        }\n                    };\n\n                    // Get response information that needs to be forwarded\n                    connectionResult.resultCode = (httpURLConnection != null) ? httpURLConnection.getResponseCode() : 200;\n                    final String contentType = urlConnection.getContentType();\n                    connectionResult.resultMediaType = NetUtils.getContentTypeMediaType(contentType);\n                    connectionResult.resultHeaders = urlConnection.getHeaderFields();\n                    connectionResult.resultInputStream = urlConnection.getInputStream();\n\n                    return connectionResult;\n\n                } else if (method.equals(\"multipart-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"form-data-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"urlencoded-post\")) {\n                    throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                } else {\n                    throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                }\n            } catch (IOException e) {\n                throw new OXFException(e);\n            }\n        } else if (!isGet(method) && (scheme.equals(\"file\") || scheme.equals(\"oxf\"))) {\n            // TODO\n            // SHOULD be supported (should probably support oxf: as well)\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else if (scheme.equals(\"mailto\")) {\n            // TODO\n            // MAY be supported\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else {\n            throw new OXFException(\"xforms:submission: submission URL scheme not supported: \" + scheme);\n        }\n    }","id":98795,"modified_method":"/**\n     * @param action absolute URL or absolute path (which must include the context path)\n     */\n    public static XFormsModelSubmission.ConnectionResult doRegular(PipelineContext pipelineContext, ExternalContext externalContext,\n                                                                   String method, final String action, String mediatype, boolean doReplace,\n                                                                   byte[] serializedInstance, String serializedInstanceString) {\n\n        // Compute submission URL\n        final URL submissionURL;\n        submissionURL = createURL(action, serializedInstanceString, externalContext);\n\n        // Perform submission\n        final String scheme = submissionURL.getProtocol();\n        if (scheme.equals(\"http\") || scheme.equals(\"https\") || (isGet(method) && (scheme.equals(\"file\") || scheme.equals(\"oxf\")))) {\n            // http MUST be supported\n            // https SHOULD be supported\n            // file SHOULD be supported\n            try {\n                final URLConnection urlConnection = submissionURL.openConnection();\n                final HttpURLConnection httpURLConnection = (urlConnection instanceof HttpURLConnection) ? (HttpURLConnection) urlConnection : null;\n                if (isPost(method) || isPut(method) || isGet(method)) {\n                    urlConnection.setDoInput(true);\n                    urlConnection.setDoOutput(!isGet(method)); // Only if POST / PUT\n\n                    if (httpURLConnection != null) {\n                        httpURLConnection.setRequestMethod(method.toUpperCase());\n                    }\n                    if (!isGet(method))\n                        urlConnection.setRequestProperty(\"content-type\", (mediatype != null) ? mediatype : \"application/xml\");\n\n                    // Forward cookies for session handling\n                    // TODO: The Servlet spec mandates JSESSIONID as cookie name; we should only forward this cookie\n                    final String[] cookies = (String[]) externalContext.getRequest().getHeaderValuesMap().get(\"cookie\");\n                    if (cookies != null) {\n                        for (int i = 0; i < cookies.length; i++) {\n                            final String cookie = cookies[i];\n                            urlConnection.setRequestProperty(\"cookie\", cookie);\n                        }\n                    }\n\n                    urlConnection.connect();\n\n                    // Write request body if needed\n                    if (!isGet(method)) {\n                        final OutputStream os = urlConnection.getOutputStream();\n                        try {\n                            os.write(serializedInstance);\n                        } finally {\n                            if (os != null) {\n                                try {\n                                    os.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing output stream for action: \" + action);\n                                }\n                            }\n                        }\n                    }\n\n                    // Create result\n                    final XFormsModelSubmission.ConnectionResult connectionResult = new XFormsModelSubmission.ConnectionResult(submissionURL.toExternalForm()) {\n                        public void close() {\n                            if (resultInputStream != null) {\n                                try {\n                                    resultInputStream.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing input stream for action: \" + action);\n                                }\n                            }\n\n                            if (httpURLConnection != null)\n                                httpURLConnection.disconnect();\n                        }\n                    };\n\n                    // Get response information that needs to be forwarded\n                    connectionResult.resultCode = (httpURLConnection != null) ? httpURLConnection.getResponseCode() : 200;\n                    final String contentType = urlConnection.getContentType();\n                    connectionResult.resultMediaType = NetUtils.getContentTypeMediaType(contentType);\n                    connectionResult.resultHeaders = urlConnection.getHeaderFields();\n                    connectionResult.resultInputStream = urlConnection.getInputStream();\n\n                    return connectionResult;\n\n                } else if (method.equals(\"multipart-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"form-data-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"urlencoded-post\")) {\n                    throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                } else {\n                    throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                }\n            } catch (IOException e) {\n                throw new OXFException(e);\n            }\n        } else if (!isGet(method) && (scheme.equals(\"file\") || scheme.equals(\"oxf\"))) {\n            // TODO\n            // SHOULD be supported (should probably support oxf: as well)\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else if (scheme.equals(\"mailto\")) {\n            // TODO\n            // MAY be supported\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else {\n            throw new OXFException(\"xforms:submission: submission URL scheme not supported: \" + scheme);\n        }\n    }","commit_id":"b4f4a3808f4e15f06cc7bd310a5187aba4cadf99","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n    * Performs a HTTP Request\n    * \n    * @param context   The context of the calling XQuery\n    * @param method    The HTTP methor for the request\n    * @param persistCookies    If true existing cookies are re-used and any issued cookies are persisted for future HTTP Requests \n    */\n    protected Sequence doRequest( XQueryContext context, HttpMethod method, boolean persistCookies ) throws IOException, XPathException\n    {\n        int statusCode = 0;\n        Sequence encodedResponse = null;\n        \n        //use existing cookies?\n        if( persistCookies ) {\n            //set existing cookies\n            Cookie[] cookies = (Cookie[])context.getXQueryContextVar( HTTP_MODULE_PERSISTENT_COOKIES) ;\n            if( cookies != null ) {\n                for( int c = 0; c < cookies.length; c++ ) {\n                    method.setRequestHeader( \"Cookie\", cookies[c].toExternalForm() );\n                }\n            }\n        }\n        \n        //execute the request\n        HttpClient http = new HttpClient();\n        \n        try {   \n            //set the proxy server (if any)\n            String proxyHost = System.getProperty( \"http.proxyHost\") ; \n            if( proxyHost != null) {\n                //TODO: support for http.nonProxyHosts e.g. -Dhttp.nonProxyHosts=\"*.devonline.gov.uk|*.devon.gov.uk\"\n                \n                ProxyHost proxy = new ProxyHost( proxyHost, Integer.parseInt( System.getProperty( \"http.proxyPort\" ) ) );\n                http.getHostConfiguration().setProxyHost( proxy );\n            }\n            \n            //perform the request\n            statusCode = http.executeMethod( method );\n            \n            encodedResponse = encodeResponseAsXML( context, method, statusCode );\n            \n            //persist cookies?\n            if( persistCookies ) {\n                //store/update cookies\n                HttpState state             = http.getState();\n                Cookie[] incomingCookies    = state.getCookies();\n                Cookie[] currentCookies     = (Cookie[])context.getXQueryContextVar( HTTP_MODULE_PERSISTENT_COOKIES );\n                \n                context.setXQueryContextVar( HTTP_MODULE_PERSISTENT_COOKIES, mergeCookies( currentCookies, incomingCookies ) );\n            }\n        }\n        catch( Exception e ) {\n            encodedResponse = encodeErrorResponse( context, e.getMessage() );\n        }\n        \n        return( encodedResponse );\n    }","id":98796,"modified_method":"/**\n    * Performs a HTTP Request\n    * \n    * @param context   The context of the calling XQuery\n    * @param method    The HTTP methor for the request\n    * @param persistCookies    If true existing cookies are re-used and any issued cookies are persisted for future HTTP Requests \n    */\n    protected Sequence doRequest( XQueryContext context, HttpMethod method, boolean persistCookies ) throws IOException, XPathException\n    {\n        int statusCode = 0;\n        Sequence encodedResponse = null;\n        \n        //use existing cookies?\n        if( persistCookies ) {\n            //set existing cookies\n            Cookie[] cookies = (Cookie[])context.getXQueryContextVar( HTTP_MODULE_PERSISTENT_COOKIES) ;\n            if( cookies != null ) {\n                for( int c = 0; c < cookies.length; c++ ) {\n                    method.setRequestHeader( \"Cookie\", cookies[c].toExternalForm() );\n                }\n            }\n        }\n        \n        //execute the request\n        HttpClient http = new HttpClient();\n        \n        try {   \n            //set the proxy server (if any)\n            String proxyHost = System.getProperty( \"http.proxyHost\") ; \n            if( proxyHost != null) {\n                //TODO: support for http.nonProxyHosts e.g. -Dhttp.nonProxyHosts=\"*.devonline.gov.uk|*.devon.gov.uk\"\n                \n                ProxyHost proxy = new ProxyHost( proxyHost, Integer.parseInt( System.getProperty( \"http.proxyPort\" ) ) );\n                http.getHostConfiguration().setProxyHost( proxy );\n            }\n            \n            //perform the request\n            statusCode = http.executeMethod( method );\n            \n            encodedResponse = encodeResponseAsXML( context, method, statusCode );\n            \n            //persist cookies?\n            if( persistCookies ) {\n                //store/update cookies\n                HttpState state             = http.getState();\n                Cookie[] incomingCookies    = state.getCookies();\n                Cookie[] currentCookies     = (Cookie[])context.getXQueryContextVar( HTTP_MODULE_PERSISTENT_COOKIES );\n                \n                context.setXQueryContextVar( HTTP_MODULE_PERSISTENT_COOKIES, mergeCookies( currentCookies, incomingCookies ) );\n            }\n        }\n        catch( Exception e ) {\n            e.printStackTrace();\n            encodedResponse = encodeErrorResponse( context, e.getMessage() );\n        }\n        \n        return( encodedResponse );\n    }","commit_id":"ba18cde3bddb64fa4587224893b5316bd6e352d2","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n    * Takes the HTTP Response Body from the HTTP Method and attempts to insert it into the response tree we are building.\n    * \n    * Conversion Preference -\n    * 1) Try and parse as XML, if successful returns a Node\n    * 2) Try and parse as HTML returning as XML compatible HTML, if successful returns a Node\n    * 3) Return as base64Binary encoded data\n    * \n    * @param context   The context of the calling XQuery\n    * @param method    The HTTP Request Method\n    * @param builder   The MemTreeBuilder that is being used\n    * \n    * @return The data in an suitable XQuery datatype value\n    */\n    private void insertResponseBody( XQueryContext context, HttpMethod method, MemTreeBuilder builder ) throws IOException, XPathException\n    {\n        boolean     parsed       = false;\n        NodeImpl    responseNode = null;\n        \n        // determine the type of the response document\n        MimeType responseMimeType = getResponseMimeType( method.getResponseHeader( \"Content-Type\" ) );\n        builder.addAttribute( new QName( \"mimetype\", null, null ), method.getResponseHeader( \"Content-Type\" ).getValue() );\n        \n        //try and parse the response as XML\n        try {\n            //TODO: replace getResponseBodyAsString() with getResponseBodyAsStream()\n            responseNode = (NodeImpl)ModuleUtils.stringToXML( context, method.getResponseBodyAsString() );\n            builder.addAttribute( new QName( \"type\", null, null ), \"xml\" );\n            responseNode.copyTo( null, new DocumentBuilderReceiver( builder ) );         \n        }\n        catch( SAXException se ) {\n            //could not parse to xml\n        }\n        \n        if( responseNode == null ) {\n            //response is NOT parseable as XML\n            \n            //is it a html document?\n            if( responseMimeType.getName().equals( MimeType.HTML_TYPE.getName() ) ) {\n                //html document\n                try {\n                    //parse html to xml(html)\n                    responseNode = (NodeImpl)ModuleUtils.htmlToXHtml(context, method.getURI().toString(), new InputSource(method.getResponseBodyAsStream() ) ).getDocumentElement();\n                    builder.addAttribute( new QName( \"type\", null, null ), \"xhtml\" );\n                    responseNode.copyTo( null, new DocumentBuilderReceiver( builder ) );                  \n                }\n                catch( URIException ue ) {\n                    throw( new XPathException (ue ) );\n                }\n                catch( SAXException se ) {\n                    //could not parse to xml(html)\n                }\n            }\n        }\n        \n        if( responseNode == null ) {\n            if( responseMimeType.getName().startsWith( \"text/\" ) ) {\n                // Assume it's a text body and URL encode it\n                builder.addAttribute( new QName( \"type\", null, null ), \"text\" );\n                builder.addAttribute( new QName( \"encoding\", null, null ), \"URLEncoded\" );\n                builder.characters( URLEncoder.encode( method.getResponseBodyAsString(), \"UTF-8\" ) );\n            } else {\n                // Assume it's a binary body and Base64 encode it\n                byte[] body = method.getResponseBody();\n                \n                builder.addAttribute( new QName( \"type\", null, null ), \"binary\" );\n                builder.addAttribute( new QName( \"encoding\", null, null ), \"Base64Encoded\" );\n                \n                if( body != null ) {\n                    Base64Binary binary = new Base64Binary( body );\n                    builder.characters( binary.getStringValue() );\n                }\n            }\n        }\n    }","id":98797,"modified_method":"/**\n    * Takes the HTTP Response Body from the HTTP Method and attempts to insert it into the response tree we are building.\n    * \n    * Conversion Preference -\n    * 1) Try and parse as XML, if successful returns a Node\n    * 2) Try and parse as HTML returning as XML compatible HTML, if successful returns a Node\n    * 3) Return as base64Binary encoded data\n    * \n    * @param context   The context of the calling XQuery\n    * @param method    The HTTP Request Method\n    * @param builder   The MemTreeBuilder that is being used\n    * \n    * @return The data in an suitable XQuery datatype value\n    */\n    private void insertResponseBody( XQueryContext context, HttpMethod method, MemTreeBuilder builder ) throws IOException, XPathException\n    {\n        boolean     parsed       = false;\n        NodeImpl    responseNode = null;\n        String        bodyAsString = method.getResponseBodyAsString();\n\n        // check if there is a response body\n        if (bodyAsString == null)\n                return;\n\n        // determine the type of the response document\n        MimeType responseMimeType = getResponseMimeType( method.getResponseHeader( \"Content-Type\" ) );\n        builder.addAttribute( new QName( \"mimetype\", null, null ), method.getResponseHeader( \"Content-Type\" ).getValue() );\n        \n        //try and parse the response as XML\n        try {\n            //TODO: replace getResponseBodyAsString() with getResponseBodyAsStream()\n            responseNode = (NodeImpl)ModuleUtils.stringToXML( context, bodyAsString );\n            builder.addAttribute( new QName( \"type\", null, null ), \"xml\" );\n            responseNode.copyTo( null, new DocumentBuilderReceiver( builder ) );         \n        }\n        catch( SAXException se ) {\n            //could not parse to xml\n        }\n        \n        if( responseNode == null ) {\n            //response is NOT parseable as XML\n            \n            //is it a html document?\n            if( responseMimeType.getName().equals( MimeType.HTML_TYPE.getName() ) ) {\n                //html document\n                try {\n                    //parse html to xml(html)\n                    responseNode = (NodeImpl)ModuleUtils.htmlToXHtml(context, method.getURI().toString(), new InputSource(method.getResponseBodyAsStream() ) ).getDocumentElement();\n                    builder.addAttribute( new QName( \"type\", null, null ), \"xhtml\" );\n                    responseNode.copyTo( null, new DocumentBuilderReceiver( builder ) );                  \n                }\n                catch( URIException ue ) {\n                    throw( new XPathException (ue ) );\n                }\n                catch( SAXException se ) {\n                    //could not parse to xml(html)\n                }\n            }\n        }\n        \n        if( responseNode == null ) {\n            if( responseMimeType.getName().startsWith( \"text/\" ) ) {\n                // Assume it's a text body and URL encode it\n                builder.addAttribute( new QName( \"type\", null, null ), \"text\" );\n                builder.addAttribute( new QName( \"encoding\", null, null ), \"URLEncoded\" );\n                builder.characters( URLEncoder.encode( method.getResponseBodyAsString(), \"UTF-8\" ) );\n            } else {\n                // Assume it's a binary body and Base64 encode it\n                byte[] body = method.getResponseBody();\n                \n                builder.addAttribute( new QName( \"type\", null, null ), \"binary\" );\n                builder.addAttribute( new QName( \"encoding\", null, null ), \"Base64Encoded\" );\n                \n                if( body != null ) {\n                    Base64Binary binary = new Base64Binary( body );\n                    builder.characters( binary.getStringValue() );\n                }\n            }\n        }\n    }","commit_id":"ba18cde3bddb64fa4587224893b5316bd6e352d2","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n    * Takes an exception message and encodes it as an XML response structure.\n    * \n    * @param context       The context of the calling XQuery\n    * @param message       The exception error message\n    * \n    * @return The response in XML format\n    */\n    private Sequence encodeErrorResponse( XQueryContext context, String message ) throws IOException, XPathException\n    {\n        Sequence    xmlResponse     = null;\n        \n        MemTreeBuilder builder = context.getDocumentBuilder();\n        \n        builder.startDocument();\n        builder.startElement( new QName( \"response\", NAMESPACE_URI, PREFIX ), null );\n        builder.addAttribute( new QName( \"statusCode\", null, null ), HTTP_EXCEPTION_STATUS_CODE );\n        \n        builder.startElement( new QName( \"body\", NAMESPACE_URI, PREFIX ), null );\n        \n        builder.addAttribute( new QName( \"type\", null, null ), \"text\" );\n        builder.addAttribute( new QName( \"encoding\", null, null ), \"URLEncoded\" );\n        builder.characters( URLEncoder.encode( message, \"UTF-8\" ) );\n        \n        builder.endElement();\n        \n        builder.endElement();\n        \n        xmlResponse = (NodeValue)builder.getDocument().getDocumentElement();\n        \n        return( xmlResponse );\n    }","id":98798,"modified_method":"/**\n    * Takes an exception message and encodes it as an XML response structure.\n    * \n    * @param context       The context of the calling XQuery\n    * @param message       The exception error message\n    * \n    * @return The response in XML format\n    */\n    private Sequence encodeErrorResponse( XQueryContext context, String message ) throws IOException, XPathException\n    {\n        Sequence    xmlResponse     = null;\n        \n        MemTreeBuilder builder = context.getDocumentBuilder();\n        \n        builder.startDocument();\n        builder.startElement( new QName( \"response\", NAMESPACE_URI, PREFIX ), null );\n        builder.addAttribute( new QName( \"statusCode\", null, null ), HTTP_EXCEPTION_STATUS_CODE );\n        \n        builder.startElement( new QName( \"body\", NAMESPACE_URI, PREFIX ), null );\n        \n        builder.addAttribute( new QName( \"type\", null, null ), \"text\" );\n        builder.addAttribute( new QName( \"encoding\", null, null ), \"URLEncoded\" );\n        if (message != null)\n            builder.characters( URLEncoder.encode( message, \"UTF-8\" ) );\n        \n        builder.endElement();\n        \n        builder.endElement();\n        \n        xmlResponse = (NodeValue)builder.getDocument().getDocumentElement();\n        \n        return( xmlResponse );\n    }","commit_id":"ba18cde3bddb64fa4587224893b5316bd6e352d2","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void evaluateDisplayValue(PipelineContext pipelineContext, String format) {\n        final String result;\n        if (format == null) {\n            // Try default format for known types\n\n            final Map prefixToURIMap = new HashMap();\n            prefixToURIMap.put(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n\n            final OXFProperties.PropertySet propertySet = OXFProperties.instance().getPropertySet();\n\n            if (\"{http://www.w3.org/2001/XMLSchema}date\".equals(type)) {\n                // Format a date\n                final String DEFAULT_FORMAT = \"if (. castable as xs:date) then format-date(xs:date(.), '[MNn] [D], [Y]', 'en', (), ()) else .\";\n                format = propertySet.getString(XFormsConstants.XFORMS_DEFAULT_DATE_FORMAT_PROPERTY, DEFAULT_FORMAT);\n            } else if (\"{http://www.w3.org/2001/XMLSchema}dateTime\".equals(type)) {\n                // Format a dateTime\n                final String DEFAULT_FORMAT = \"if (. castable as xs:dateTime) then format-dateTime(xs:dateTime(.), '[MNn] [D], [Y] [H01]:[m01]:[s01] UTC', 'en', (), ()) else .\";\n                format = propertySet.getString(XFormsConstants.XFORMS_DEFAULT_DATETIME_FORMAT_PROPERTY, DEFAULT_FORMAT);\n            } else if (\"{http://www.w3.org/2001/XMLSchema}time\".equals(type)) {\n                // Format a time\n                final String DEFAULT_FORMAT = \"if (. castable as xs:time) then format-time(xs:time(.), '[H01]:[m01]:[s01] UTC', 'en', (), ()) else .\";\n                format = propertySet.getString(XFormsConstants.XFORMS_DEFAULT_TIME_FORMAT_PROPERTY, DEFAULT_FORMAT);\n            }\n\n            if (format != null) {\n                final NodeInfo currentSingleNode = currentBindingContext.getSingleNode();\n                final XFormsInstance currentInstance = containingDocument.getXFormsControls().getInstanceForNode(currentSingleNode);\n                result = currentInstance.getEvaluator().evaluateAsString(pipelineContext, currentSingleNode,\n                            format, prefixToURIMap, null, containingDocument.getXFormsControls().getFunctionLibrary(), null);\n            } else {\n                result = null;\n            }\n\n        } else {\n            // Format value according to format attribute\n            final Map prefixToURIMap = Dom4jUtils.getNamespaceContextNoDefault(getElement());\n\n            final NodeInfo currentSingleNode = currentBindingContext.getSingleNode();\n            final XFormsInstance currentInstance = containingDocument.getXFormsControls().getInstanceForNode(currentSingleNode);\n\n            result = currentInstance.getEvaluator().evaluateAsString(pipelineContext, currentSingleNode,\n                        format, prefixToURIMap, null, containingDocument.getXFormsControls().getFunctionLibrary(), null);\n        }\n        setDisplayValue(result);\n    }","id":98799,"modified_method":"protected void evaluateDisplayValueUseFormat(PipelineContext pipelineContext, String format) {\n        final String result;\n        if (format == null) {\n            // Try default format for known types\n\n            final Map prefixToURIMap = new HashMap();\n            prefixToURIMap.put(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n\n            final OXFProperties.PropertySet propertySet = OXFProperties.instance().getPropertySet();\n\n            if (\"{http://www.w3.org/2001/XMLSchema}date\".equals(type)) {\n                // Format a date\n                final String DEFAULT_FORMAT = \"if (. castable as xs:date) then format-date(xs:date(.), '[MNn] [D], [Y]', 'en', (), ()) else .\";\n                format = propertySet.getString(XFormsConstants.XFORMS_DEFAULT_DATE_FORMAT_PROPERTY, DEFAULT_FORMAT);\n            } else if (\"{http://www.w3.org/2001/XMLSchema}dateTime\".equals(type)) {\n                // Format a dateTime\n                final String DEFAULT_FORMAT = \"if (. castable as xs:dateTime) then format-dateTime(xs:dateTime(.), '[MNn] [D], [Y] [H01]:[m01]:[s01] UTC', 'en', (), ()) else .\";\n                format = propertySet.getString(XFormsConstants.XFORMS_DEFAULT_DATETIME_FORMAT_PROPERTY, DEFAULT_FORMAT);\n            } else if (\"{http://www.w3.org/2001/XMLSchema}time\".equals(type)) {\n                // Format a time\n                final String DEFAULT_FORMAT = \"if (. castable as xs:time) then format-time(xs:time(.), '[H01]:[m01]:[s01] UTC', 'en', (), ()) else .\";\n                format = propertySet.getString(XFormsConstants.XFORMS_DEFAULT_TIME_FORMAT_PROPERTY, DEFAULT_FORMAT);\n            }\n\n            if (format != null) {\n                final NodeInfo currentSingleNode = currentBindingContext.getSingleNode();\n                final XFormsInstance currentInstance = containingDocument.getXFormsControls().getInstanceForNode(currentSingleNode);\n                result = currentInstance.getEvaluator().evaluateAsString(pipelineContext, currentSingleNode,\n                            format, prefixToURIMap, null, containingDocument.getXFormsControls().getFunctionLibrary(), null);\n            } else {\n                result = null;\n            }\n\n        } else {\n            // Format value according to format attribute\n            final Map prefixToURIMap = Dom4jUtils.getNamespaceContextNoDefault(getElement());\n\n            final NodeInfo currentSingleNode = currentBindingContext.getSingleNode();\n            final XFormsInstance currentInstance = containingDocument.getXFormsControls().getInstanceForNode(currentSingleNode);\n\n            result = currentInstance.getEvaluator().evaluateAsString(pipelineContext, currentSingleNode,\n                        format, prefixToURIMap, null, containingDocument.getXFormsControls().getFunctionLibrary(), null);\n        }\n        setDisplayValue(result);\n    }","commit_id":"ce75146601664e42fc011f199da995523e28dec0","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void setDisplayValue(String displayValue) {\n        this.displayValue = displayValue;\n    }","id":98800,"modified_method":"protected void setDisplayValue(String displayValue) {\n        this.displayValue = displayValue;\n    }","commit_id":"ce75146601664e42fc011f199da995523e28dec0","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void evaluateDisplayValue(PipelineContext pipelineContext) {\n        evaluateDisplayValue(pipelineContext, format);\n    }","id":98801,"modified_method":"public void evaluateDisplayValue(PipelineContext pipelineContext) {\n        evaluateDisplayValueUseFormat(pipelineContext, format);\n    }","commit_id":"ce75146601664e42fc011f199da995523e28dec0","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final ControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (ControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDate;\n        final String typeClass;\n        {\n            final StringBuffer classes = new StringBuffer(\"xforms-control xforms-input\");\n            if (!handlerContext.isGenerateTemplate()) {\n                isDate = isDate(controlInfo.getType());\n                typeClass = isDate ? \"xforms-type-date\" : \"xforms-type-string\";\n\n                handleMIPClasses(classes, controlInfo);\n\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            } else {\n                isDate = false;\n                typeClass = null;\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            }\n        }\n\n        // Create xhtml:span\n        final boolean isReadOnly = !handlerContext.isGenerateTemplate() && controlInfo.isReadonly();\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n        final String inputQName = XMLUtils.buildQName(xhtmlPrefix, \"input\");\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, newAttributes);\n        {\n            // Create xhtml:span\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-date-display\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-readonly\");\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());// TODO: check whether like in the XSTL version we need to copy other classes as well\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                if (!handlerContext.isGenerateTemplate() && isDate) {\n                    final String value = controlInfo.getDisplayValue();\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n\n            // Create xhtml:input\n            {\n                final StringBuffer inputClasses = new StringBuffer(\"xforms-input-input\");\n                if (typeClass != null) {\n                    inputClasses.append(' ');\n                    inputClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"type\", \"type\", ContentHandlerHelper.CDATA, \"text\");\n                reusableAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n                reusableAttributes.addAttribute(\"\", \"id\", \"id\", ContentHandlerHelper.CDATA, \"input-\" + effectiveId);\n\n                if (!handlerContext.isGenerateTemplate()) {\n                    final String value = controlInfo.getValue();\n                    reusableAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, (value == null) ? \"\" : value);\n                } else {\n                    reusableAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, \"\");\n                }\n\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA,\n                        (inputClasses.length() > 0) ? inputClasses.toString() : \"\");// TODO: check whether like in the XSTL version we need to copy other classes as well\n                if (isReadOnly) {\n                    reusableAttributes.addAttribute(\"\", \"disabled\", \"disabled\", ContentHandlerHelper.CDATA, \"disabled\");\n                }\n\n                // Copy special attributes in xxforms namespace\n                copyAttributes(elementAttributes, XFormsConstants.XXFORMS_NAMESPACE_URI, XXFORMS_ATTRIBUTES_TO_COPY, reusableAttributes);\n\n                // Handle accessibility attributes\n                handleAccessibilityAttributes(elementAttributes, reusableAttributes);\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName);\n            }\n\n            // Create xhtml:span for date picker\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-showcalendar\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-showcalendar-readonly\");\n                if (typeClass != null) {\n                    spanClasses.append(' ');\n                    spanClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());\n                reusableAttributes.addAttribute(\"\", \"id\", \"id\", ContentHandlerHelper.CDATA, \"showcalendar-\" + effectiveId);\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","id":98802,"modified_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final ControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (ControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDate;\n        final String typeClass;\n        {\n            final StringBuffer classes = new StringBuffer(\"xforms-control xforms-input\");\n            if (!handlerContext.isGenerateTemplate()) {\n                isDate = isDate(controlInfo.getType());\n                typeClass = isDate ? \"xforms-type-date\" : \"xforms-type-string\";\n\n                handleMIPClasses(classes, controlInfo);\n\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            } else {\n                isDate = false;\n                typeClass = null;\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            }\n        }\n\n        // Create xhtml:span\n        final boolean isReadOnly = !handlerContext.isGenerateTemplate() && controlInfo.isReadonly();\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n        final String inputQName = XMLUtils.buildQName(xhtmlPrefix, \"input\");\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, newAttributes);\n        {\n            // Create xhtml:span\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-date-display\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-readonly\");\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());// TODO: check whether like in the XSTL version we need to copy other classes as well\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                if (!handlerContext.isGenerateTemplate() && isDate) {\n                    final String displayValue = controlInfo.getDisplayValueOrValue();\n                    if (displayValue != null)\n                        contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n\n            // Create xhtml:input\n            {\n                final StringBuffer inputClasses = new StringBuffer(\"xforms-input-input\");\n                if (typeClass != null) {\n                    inputClasses.append(' ');\n                    inputClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"type\", \"type\", ContentHandlerHelper.CDATA, \"text\");\n                reusableAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n                reusableAttributes.addAttribute(\"\", \"id\", \"id\", ContentHandlerHelper.CDATA, \"input-\" + effectiveId);\n\n                if (!handlerContext.isGenerateTemplate()) {\n                    final String value = controlInfo.getValue();\n                    reusableAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, (value == null) ? \"\" : value);\n                } else {\n                    reusableAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, \"\");\n                }\n\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA,\n                        (inputClasses.length() > 0) ? inputClasses.toString() : \"\");// TODO: check whether like in the XSTL version we need to copy other classes as well\n                if (isReadOnly) {\n                    reusableAttributes.addAttribute(\"\", \"disabled\", \"disabled\", ContentHandlerHelper.CDATA, \"disabled\");\n                }\n\n                // Copy special attributes in xxforms namespace\n                copyAttributes(elementAttributes, XFormsConstants.XXFORMS_NAMESPACE_URI, XXFORMS_ATTRIBUTES_TO_COPY, reusableAttributes);\n\n                // Handle accessibility attributes\n                handleAccessibilityAttributes(elementAttributes, reusableAttributes);\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName);\n            }\n\n            // Create xhtml:span for date picker\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-showcalendar\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-showcalendar-readonly\");\n                if (typeClass != null) {\n                    spanClasses.append(' ');\n                    spanClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());\n                reusableAttributes.addAttribute(\"\", \"id\", \"id\", ContentHandlerHelper.CDATA, \"showcalendar-\" + effectiveId);\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","commit_id":"ce75146601664e42fc011f199da995523e28dec0","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final OutputControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (OutputControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDateOrTime;\n        final StringBuffer classes = new StringBuffer(\"xforms-control xforms-output\");\n\n        final String appearanceValue = elementAttributes.getValue(\"appearance\");\n        final String appearanceLocalname = (appearanceValue == null) ? null : XMLUtils.localNameFromQName(appearanceValue);\n        final String appearanceURI = (appearanceValue == null) ? null : uriFromQName(appearanceValue);\n\n        final String mediatypeValue = elementAttributes.getValue(\"mediatype\");\n        final boolean isImage = mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n        final boolean isHTML = (mediatypeValue != null && mediatypeValue.equals(\"text/html\"))\n                || (appearanceValue != null && XFormsConstants.XXFORMS_NAMESPACE_URI.equals(appearanceURI) && \"html\".equals(appearanceLocalname));\n\n        if (isHTML) {\n            classes.append(\" xforms-initially-hidden\");\n            classes.append(\" xforms-mediatype-text-html\");\n        } else if (isImage) {\n            classes.append(\" xforms-mediatype-image\");\n        }\n\n        if (!handlerContext.isGenerateTemplate()) {\n\n            // Find classes to add\n            isDateOrTime = isDateOrTime(controlInfo.getType());\n            handleMIPClasses(classes, controlInfo);\n\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        } else {\n            isDateOrTime = false;\n\n            // Find classes to add\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        }\n\n        // Create xhtml:span or xhtml:div\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        // For IE we need to generate a div here for IE, which doesn't support working with innterHTML on spans.\n        final String enclosingElementLocalname = isHTML ? \"div\" : \"span\";\n        final String enclosingElementQName = XMLUtils.buildQName(xhtmlPrefix, enclosingElementLocalname);\n\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, enclosingElementLocalname, enclosingElementQName, newAttributes);\n        if (!handlerContext.isGenerateTemplate()) {\n            if (isImage) {\n                // Case of image media type with URI\n                final String imgQName = XMLUtils.buildQName(xhtmlPrefix, \"img\");\n                final AttributesImpl imgAttributes = new AttributesImpl();\n                // @src=\"...\"\n                imgAttributes.addAttribute(\"\", \"src\", \"src\", ContentHandlerHelper.CDATA, controlInfo.getValue());\n                // @f:url-norewrite=\"true\"\n                final String formattingPrefix;\n                final boolean isNewPrefix;\n                {\n                    final String existingFormattingPrefix = handlerContext.findFormattingPrefix();\n                    if (existingFormattingPrefix == null || \"\".equals(existingFormattingPrefix)) {\n                        // No prefix is currently mapped\n                        formattingPrefix = handlerContext.findNewPrefix();\n                        isNewPrefix = true;\n                    } else {\n                        formattingPrefix = existingFormattingPrefix;\n                        isNewPrefix = false;\n                    }\n                    imgAttributes.addAttribute(XMLConstants.OPS_FORMATTING_URI, \"url-norewrite\", XMLUtils.buildQName(formattingPrefix, \"url-norewrite\"), ContentHandlerHelper.CDATA, \"true\");\n                }\n                if (isNewPrefix)\n                    contentHandler.startPrefixMapping(formattingPrefix, XMLConstants.OPS_FORMATTING_URI);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName, imgAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName);\n                if (isNewPrefix)\n                    contentHandler.endPrefixMapping(formattingPrefix);\n            } else if (isDateOrTime) {\n                // Display formatted value for dates\n                final String displayValue = controlInfo.getDisplayValue();\n                contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n            } else {\n                // Regular text case\n                final String value = controlInfo.getValue();\n                if (value != null)\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, enclosingElementLocalname, enclosingElementQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        if (elementAttributes.getValue(\"value\") == null)\n            handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","id":98803,"modified_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final OutputControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (OutputControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDateOrTime;\n        final StringBuffer classes = new StringBuffer(\"xforms-control xforms-output\");\n\n        final String appearanceValue = elementAttributes.getValue(\"appearance\");\n        final String appearanceLocalname = (appearanceValue == null) ? null : XMLUtils.localNameFromQName(appearanceValue);\n        final String appearanceURI = (appearanceValue == null) ? null : uriFromQName(appearanceValue);\n\n        final String mediatypeValue = elementAttributes.getValue(\"mediatype\");\n        final boolean isImage = mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n        final boolean isHTML = (mediatypeValue != null && mediatypeValue.equals(\"text/html\"))\n                || (appearanceValue != null && XFormsConstants.XXFORMS_NAMESPACE_URI.equals(appearanceURI) && \"html\".equals(appearanceLocalname));\n\n        if (isHTML) {\n            classes.append(\" xforms-initially-hidden\");\n            classes.append(\" xforms-mediatype-text-html\");\n        } else if (isImage) {\n            classes.append(\" xforms-mediatype-image\");\n        }\n\n        if (!handlerContext.isGenerateTemplate()) {\n\n            // Find classes to add\n            isDateOrTime = isDateOrTime(controlInfo.getType());\n            handleMIPClasses(classes, controlInfo);\n\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        } else {\n            isDateOrTime = false;\n\n            // Find classes to add\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        }\n\n        // Create xhtml:span or xhtml:div\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        // For IE we need to generate a div here for IE, which doesn't support working with innterHTML on spans.\n        final String enclosingElementLocalname = isHTML ? \"div\" : \"span\";\n        final String enclosingElementQName = XMLUtils.buildQName(xhtmlPrefix, enclosingElementLocalname);\n\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, enclosingElementLocalname, enclosingElementQName, newAttributes);\n        if (!handlerContext.isGenerateTemplate()) {\n            if (isImage) {\n                // Case of image media type with URI\n                final String imgQName = XMLUtils.buildQName(xhtmlPrefix, \"img\");\n                final AttributesImpl imgAttributes = new AttributesImpl();\n                // @src=\"...\"\n                imgAttributes.addAttribute(\"\", \"src\", \"src\", ContentHandlerHelper.CDATA, controlInfo.getValue());\n                // @f:url-norewrite=\"true\"\n                final String formattingPrefix;\n                final boolean isNewPrefix;\n                {\n                    final String existingFormattingPrefix = handlerContext.findFormattingPrefix();\n                    if (existingFormattingPrefix == null || \"\".equals(existingFormattingPrefix)) {\n                        // No prefix is currently mapped\n                        formattingPrefix = handlerContext.findNewPrefix();\n                        isNewPrefix = true;\n                    } else {\n                        formattingPrefix = existingFormattingPrefix;\n                        isNewPrefix = false;\n                    }\n                    imgAttributes.addAttribute(XMLConstants.OPS_FORMATTING_URI, \"url-norewrite\", XMLUtils.buildQName(formattingPrefix, \"url-norewrite\"), ContentHandlerHelper.CDATA, \"true\");\n                }\n                if (isNewPrefix)\n                    contentHandler.startPrefixMapping(formattingPrefix, XMLConstants.OPS_FORMATTING_URI);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName, imgAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName);\n                if (isNewPrefix)\n                    contentHandler.endPrefixMapping(formattingPrefix);\n            } else if (isDateOrTime) {\n                // Display formatted value for dates\n                final String displayValue = controlInfo.getDisplayValueOrValue();\n                if (displayValue != null)\n                    contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n            } else {\n                // Regular text case\n                final String displayValue = controlInfo.getDisplayValueOrValue();\n                if (displayValue != null)\n                    contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, enclosingElementLocalname, enclosingElementQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        if (elementAttributes.getValue(\"value\") == null)\n            handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","commit_id":"ce75146601664e42fc011f199da995523e28dec0","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        namespaceSupport.pushContext();\n\n        final String explodedQName = XMLUtils.buildExplodedQName(uri, localname);\n        final String handlerClassName = (String) handlerKeysToNames.get(explodedQName);\n        if (handlerClassName != null) {\n            // Found new handler\n            final ElementHandlerNew elementHandler = getHandlerByClassName(handlerClassName);\n            elementHandler.setContext(elementHandlerContext);\n            elementHandler.setForward(elementHandler.isForwarding());\n            elementHandler.setContentHandler(output);\n\n            if (currentHandlerInfo != null)\n                handlerInfos.push(currentHandlerInfo);\n            currentHandlerInfo = new HandlerInfo(level, elementHandler);\n            super.setContentHandler(elementHandler);\n\n            elementHandler.start(uri, localname, qName, attributes);\n        } else {\n            super.startElement(uri, localname, qName, attributes);\n        }\n\n        level++;\n    }","id":98804,"modified_method":"public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n        try {\n            if (mustPushContext)\n                namespaceSupport.pushContext();\n            else\n                mustPushContext = true;\n\n            if (!isFillingUpSAXStore) {\n//                namespaceSupport.pushContext();\n\n                final String explodedQName = XMLUtils.buildExplodedQName(uri, localname);\n                final String handlerClassName = (String) handlerKeysToNames.get(explodedQName);\n                if (handlerClassName != null) {\n                    // Found new handler\n                    final ElementHandlerNew elementHandler = getHandlerByClassName(handlerClassName);\n                    elementHandler.setContext(elementHandlerContext);\n                    elementHandler.setForward(elementHandler.isForwarding());\n                    elementHandler.setContentHandler(output);\n\n                    if (currentHandlerInfo != null)\n                        handlerInfos.push(currentHandlerInfo);\n\n                    if (elementHandler.isRepeating()) {\n                        currentHandlerInfo = new HandlerInfo(level, elementHandler, attributes);\n                        super.setContentHandler(currentHandlerInfo.saxStore);\n                        isFillingUpSAXStore = true;\n                    } else {\n                        currentHandlerInfo = new HandlerInfo(level, elementHandler);\n                        super.setContentHandler(elementHandler);\n                        elementHandler.start(uri, localname, qName, attributes);\n                    }\n                } else {\n                    super.startElement(uri, localname, qName, attributes);\n                }\n            } else {\n                super.startElement(uri, localname, qName, attributes);\n            }\n\n            level++;\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void endElement(String uri, String localname, String qName) throws SAXException {\n        level--;\n\n        if (currentHandlerInfo != null && currentHandlerInfo.level == level) {\n            // End of handler\n\n            currentHandlerInfo.elementHandler.end(uri, localname, qName);\n\n            currentHandlerInfo = (HandlerInfo) ((handlerInfos.size() > 0) ? handlerInfos.pop() : null);\n            super.setContentHandler((currentHandlerInfo != null) ? (ContentHandler) currentHandlerInfo.elementHandler : output);\n\n        } else {\n            super.endElement(uri, localname, qName);\n        }\n\n        namespaceSupport.popContext();\n    }","id":98805,"modified_method":"public void endElement(String uri, String localname, String qName) throws SAXException {\n        try {\n            level--;\n\n            if (currentHandlerInfo != null && currentHandlerInfo.level == level) {\n                // End of handler\n\n                if (currentHandlerInfo.elementHandler.isRepeating()) {\n                    isFillingUpSAXStore = false;\n                    super.setContentHandler(currentHandlerInfo.elementHandler);\n                    level++;\n                    currentHandlerInfo.elementHandler.start(uri, localname, qName, currentHandlerInfo.attributes);\n                    currentHandlerInfo.elementHandler.end(uri, localname, qName);\n                    level--;\n                } else {\n                    currentHandlerInfo.elementHandler.end(uri, localname, qName);\n                }\n\n                currentHandlerInfo = (HandlerInfo) ((handlerInfos.size() > 0) ? handlerInfos.pop() : null);\n                super.setContentHandler((currentHandlerInfo != null) ? (ContentHandler) currentHandlerInfo.elementHandler : output);\n\n//                namespaceSupport.popContext();\n\n            } else {\n                super.endElement(uri, localname, qName);\n//                if (!isFillingUpSAXStore)\n//                    namespaceSupport.popContext();\n            }\n\n            namespaceSupport.popContext();\n            mustPushContext = true;\n\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        // Update global NamespaceSupport\n        namespaceSupport.declarePrefix(prefix, uri);\n        super.startPrefixMapping(prefix, uri);\n    }","id":98806,"modified_method":"public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        try {\n            if (mustPushContext) {\n                namespaceSupport.pushContext();\n                mustPushContext = false;\n            }\n\n            // Update global NamespaceSupport\n            namespaceSupport.declarePrefix(prefix, uri);\n            super.startPrefixMapping(prefix, uri);\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void endDocument() throws SAXException {\n        super.endDocument();\n    }","id":98807,"modified_method":"public void endDocument() throws SAXException {\n        try {\n            super.endDocument();\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void endPrefixMapping(String s) throws SAXException {\n        super.endPrefixMapping(s);\n    }","id":98808,"modified_method":"public void endPrefixMapping(String s) throws SAXException {\n        try {\n            super.endPrefixMapping(s);\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void characters(char[] chars, int start, int length) throws SAXException {\n        super.characters(chars, start, length);\n    }","id":98809,"modified_method":"public void characters(char[] chars, int start, int length) throws SAXException {\n        try {\n            super.characters(chars, start, length);\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void startDocument() throws SAXException {\n        setContentHandler(output);\n        setForward(true);\n        super.startDocument();\n    }","id":98810,"modified_method":"public void startDocument() throws SAXException {\n        try {\n            setContentHandler(output);\n            setForward(true);\n            super.startDocument();\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private ElementHandlerNew getHandlerByClassName(String handlerClassName) {\n        try {\n            final Class handlerClass = Class.forName(handlerClassName);\n            return (ElementHandlerNew) handlerClass.newInstance();\n        } catch (InstantiationException e) {// TODO: location data\n            throw new OXFException(e);\n        } catch (IllegalAccessException e) {\n            throw new OXFException(e);\n        } catch (ClassNotFoundException e) {\n            throw new OXFException(e);\n        }\n    }","id":98811,"modified_method":"private ElementHandlerNew getHandlerByClassName(String handlerClassName) {\n        try {\n            final Class handlerClass = Class.forName(handlerClassName);\n            return (ElementHandlerNew) handlerClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new ValidationException(e, new LocationData(locator));\n        } catch (IllegalAccessException e) {\n            throw new ValidationException(e, new LocationData(locator));\n        } catch (ClassNotFoundException e) {\n            throw new ValidationException(e, new LocationData(locator));\n        }\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"protected AttributesImpl getAttributes(Attributes elementAttributes, String classes, String id) {\n        reusableAttributes.clear();\n\n        // Copy \"id\"\n        if (id != null) {\n            reusableAttributes.addAttribute(\"\", \"id\", \"id\", ContentHandlerHelper.CDATA, id);\n        }\n        // Copy common attributes\n        for (int i = 0; i < ATTRIBUTES_TO_COPY.length; i++) {\n            final String name = ATTRIBUTES_TO_COPY[i];\n            final String value = elementAttributes.getValue(name);\n            if (value != null)\n                reusableAttributes.addAttribute(\"\", name, name, ContentHandlerHelper.CDATA, value);\n        }\n        // Copy \"navindex\" into \"tabindex\"\n        {\n            final String value = elementAttributes.getValue(\"navindex\");\n            if (value != null)\n                reusableAttributes.addAttribute(\"\", \"tabindex\", \"tabindex\", ContentHandlerHelper.CDATA, value);\n        }\n        // Create \"class\" attribute if necessary\n        {\n            final StringBuffer sb = new StringBuffer((classes != null) ? classes : \"\");\n            {\n                final String value = elementAttributes.getValue(\"class\");\n                if (value != null) {\n                    if (sb.length() > 0)\n                        sb.append(' ');\n                    sb.append(value);\n                }\n            }\n            {\n                final String value = elementAttributes.getValue(XMLConstants.XHTML_NAMESPACE_URI, \"class\");\n                if (value != null) {\n                    if (sb.length() > 0)\n                        sb.append(' ');\n                    sb.append(value);\n                }\n            }\n            {\n                final String value = elementAttributes.getValue(\"incremental\");\n                if (\"true\".equals(value)) {\n                    if (sb.length() > 0)\n                        sb.append(' ');\n                    sb.append(\"xforms-incremental\");\n                }\n            }\n            if (sb.length() > 0) {\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, sb.toString());\n            }\n        }\n        // Copy attributes in the xhtml namespace to no namespace\n        for (int i = 0; i < elementAttributes.getLength(); i++) {\n            if (XMLConstants.XHTML_NAMESPACE_URI.equals(elementAttributes.getURI(i))) {\n                final String name = elementAttributes.getLocalName(i);\n                if (!\"class\".equals(name)) {\n                    reusableAttributes.addAttribute(\"\", name, name, ContentHandlerHelper.CDATA, elementAttributes.getValue(i));\n                }\n            }\n        }\n\n        return reusableAttributes;\n    }","id":98812,"modified_method":"protected AttributesImpl getAttributes(Attributes elementAttributes, String classes, String id) {\n        reusableAttributes.clear();\n\n        // Copy \"id\"\n        if (id != null) {\n            reusableAttributes.addAttribute(\"\", \"id\", \"id\", ContentHandlerHelper.CDATA, id);\n        }\n        // Copy common attributes\n        for (int i = 0; i < ATTRIBUTES_TO_COPY.length; i++) {\n            final String name = ATTRIBUTES_TO_COPY[i];\n            final String value = elementAttributes.getValue(name);\n            if (value != null)\n                reusableAttributes.addAttribute(\"\", name, name, ContentHandlerHelper.CDATA, value);\n        }\n        // Copy \"navindex\" into \"tabindex\"\n        {\n            final String value = elementAttributes.getValue(\"navindex\");\n            if (value != null)\n                reusableAttributes.addAttribute(\"\", \"tabindex\", \"tabindex\", ContentHandlerHelper.CDATA, value);\n        }\n        // Create \"class\" attribute if necessary\n        {\n            final StringBuffer sb = new StringBuffer();\n            // User-defined classes go first\n            {\n                final String value = elementAttributes.getValue(\"class\");\n                if (value != null) {\n                    if (sb.length() > 0)\n                        sb.append(' ');\n                    sb.append(value);\n                }\n            }\n            {\n                final String value = elementAttributes.getValue(XMLConstants.XHTML_NAMESPACE_URI, \"class\");\n                if (value != null) {\n                    if (sb.length() > 0)\n                        sb.append(' ');\n                    sb.append(value);\n                }\n            }\n            // XForms engine classes go next\n            {\n                if (classes != null) {\n                    if (sb.length() > 0)\n                        sb.append(' ');\n                    sb.append(classes);\n                }\n            }\n            {\n                final String value = elementAttributes.getValue(\"incremental\");\n                if (\"true\".equals(value)) {\n                    if (sb.length() > 0)\n                        sb.append(' ');\n                    sb.append(\"xforms-incremental\");\n                }\n            }\n            if (sb.length() > 0) {\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, sb.toString());\n            }\n        }\n        // Copy attributes in the xhtml namespace to no namespace\n        for (int i = 0; i < elementAttributes.getLength(); i++) {\n            if (XMLConstants.XHTML_NAMESPACE_URI.equals(elementAttributes.getURI(i))) {\n                final String name = elementAttributes.getLocalName(i);\n                if (!\"class\".equals(name)) {\n                    reusableAttributes.addAttribute(\"\", name, name, ContentHandlerHelper.CDATA, elementAttributes.getValue(i));\n                }\n            }\n        }\n\n        return reusableAttributes;\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.ControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.ControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDateOrTime;\n        final String typeClass;\n        {\n            final StringBuffer classes = new StringBuffer(\"xforms-control xforms-input\");\n            if (!handlerContext.isGenerateTemplate()) {\n                isDateOrTime = isDateOrTime(controlInfo.getType());\n                typeClass = isDateOrTime ? \"xforms-type-date\" : \"xforms-type-string\";\n\n                handleReadOnlyClass(classes, controlInfo);\n                handleRelevantClass(classes, controlInfo);\n\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n                handleReadOnlyAttribute(newAttributes, controlInfo);\n            } else {\n                isDateOrTime = false;\n                typeClass = null;\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            }\n        }\n\n        // Create xhtml:span\n        final boolean isReadOnly = !handlerContext.isGenerateTemplate() && controlInfo.isReadonly();\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n        final String inputQName = XMLUtils.buildQName(xhtmlPrefix, \"input\");\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, newAttributes);\n        {\n            // Create xhtml:span\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-date-display\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-readonly\");\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());// TODO: check whether like in the XSTL version we need to copy other classes as well\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                if (!handlerContext.isGenerateTemplate() && isDateOrTime) {\n                    final String value = controlInfo.getDisplayValue();\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n\n            // Create xhtml:input\n            {\n                final StringBuffer inputClasses = new StringBuffer();\n                if (typeClass != null) {\n                    inputClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"type\", \"type\", ContentHandlerHelper.CDATA, \"text\");\n                reusableAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n                reusableAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA,\n                        handlerContext.isGenerateTemplate() ? \"\" : controlInfo.getValue());\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA,\n                        (inputClasses.length() > 0) ? inputClasses.toString() : \"\");// TODO: check whether like in the XSTL version we need to copy other classes as well\n                if (isReadOnly) {\n                    reusableAttributes.addAttribute(\"\", \"disabled\", \"disabled\", ContentHandlerHelper.CDATA, \"disabled\");\n                }\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName);\n            }\n\n            // Create xhtml:span for date picker\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-showcalendar\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-showcalendar-readonly\");\n                if (typeClass != null) {\n                    spanClasses.append(' ');\n                    spanClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","id":98813,"modified_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.ControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.ControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isDateOrTime;\n        final String typeClass;\n        {\n            final StringBuffer classes = new StringBuffer(\"xforms-control xforms-input\");\n            if (!handlerContext.isGenerateTemplate()) {\n                isDateOrTime = isDateOrTime(controlInfo.getType());\n                typeClass = isDateOrTime ? \"xforms-type-date\" : \"xforms-type-string\";\n\n                handleReadOnlyClass(classes, controlInfo);\n                handleRelevantClass(classes, controlInfo);\n\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n                handleReadOnlyAttribute(newAttributes, controlInfo);\n            } else {\n                isDateOrTime = false;\n                typeClass = null;\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            }\n        }\n\n        // Create xhtml:span\n        final boolean isReadOnly = !handlerContext.isGenerateTemplate() && controlInfo.isReadonly();\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n        final String inputQName = XMLUtils.buildQName(xhtmlPrefix, \"input\");\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, newAttributes);\n        {\n            // Create xhtml:span\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-date-display\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-readonly\");\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());// TODO: check whether like in the XSTL version we need to copy other classes as well\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                if (!handlerContext.isGenerateTemplate() && isDateOrTime) {\n                    final String value = controlInfo.getDisplayValue();\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n                }\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n\n            // Create xhtml:input\n            {\n                final StringBuffer inputClasses = new StringBuffer();\n                if (typeClass != null) {\n                    inputClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"type\", \"type\", ContentHandlerHelper.CDATA, \"text\");\n                reusableAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n\n                if (!handlerContext.isGenerateTemplate()) {\n                    final String value = controlInfo.getValue();\n                    reusableAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, (value == null) ? \"\" : value);\n                } else {\n                    reusableAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, \"\");\n                }\n\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA,\n                        (inputClasses.length() > 0) ? inputClasses.toString() : \"\");// TODO: check whether like in the XSTL version we need to copy other classes as well\n                if (isReadOnly) {\n                    reusableAttributes.addAttribute(\"\", \"disabled\", \"disabled\", ContentHandlerHelper.CDATA, \"disabled\");\n                }\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"input\", inputQName);\n            }\n\n            // Create xhtml:span for date picker\n            {\n                final StringBuffer spanClasses = new StringBuffer(\"xforms-showcalendar\");\n                if (isReadOnly)\n                    spanClasses.append(\" xforms-showcalendar-readonly\");\n                if (typeClass != null) {\n                    spanClasses.append(' ');\n                    spanClasses.append(typeClass);\n                }\n\n                reusableAttributes.clear();\n                reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, spanClasses.toString());\n\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, reusableAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.OutputControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.OutputControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isImage;\n        final boolean isDateOrTime;\n        final StringBuffer classes = new StringBuffer(\"xforms-control xforms-output\");\n        if (!handlerContext.isGenerateTemplate()) {\n\n            final String appearanceValue = elementAttributes.getValue(\"appearance\");\n            final String appearanceLocalname = (appearanceValue == null) ? null : XMLUtils.localNameFromQName(appearanceValue);\n            final String appearanceURI = (appearanceValue == null) ? null : uriFromQName(appearanceValue);\n\n            final String mediaType = controlInfo.getMediaTypeAttribute();\n\n            final boolean isHTML = appearanceValue != null && XFormsConstants.XXFORMS_NAMESPACE_URI.equals(appearanceURI) && \"html\".equals(appearanceLocalname);\n            isImage = mediaType != null && mediaType.startsWith(\"image/\");\n\n            // Find classes to add\n\n            if (isHTML) {\n                classes.append(\" xforms-output-html\");\n            } else if (isImage) {\n                classes.append(\" xforms-output-image\");\n            }\n            isDateOrTime = isDateOrTime(controlInfo.getType());\n            if (isDateOrTime) {\n                classes.append(\" xforms-date\");\n            }\n            handleReadOnlyClass(classes, controlInfo);\n            handleRelevantClass(classes, controlInfo);\n\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            handleReadOnlyAttribute(newAttributes, controlInfo);\n        } else {\n            isImage = false;\n            isDateOrTime = false;\n\n            // Find classes to add\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        }\n\n        // Create xhtml:span\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, newAttributes);\n        if (!handlerContext.isGenerateTemplate()) {\n            if (isImage) {\n                // Case of image media type with URI\n                final String imgQName = XMLUtils.buildQName(xhtmlPrefix, \"img\");\n                final AttributesImpl imgAttributes = new AttributesImpl();\n                // @src=\"...\"\n                imgAttributes.addAttribute(\"\", \"src\", \"src\", ContentHandlerHelper.CDATA, controlInfo.getValue());\n                // @f:url-norewrite=\"true\"\n                final String formattingPrefix;\n                final boolean isNewPrefix;\n                {\n                    final String existingFormattingPrefix = handlerContext.findFormattingPrefix();\n                    if (existingFormattingPrefix == null || \"\".equals(existingFormattingPrefix)) {\n                        // No prefix is currently mapped\n                        formattingPrefix = handlerContext.findNewPrefix();\n                        isNewPrefix = true;\n                    } else {\n                        formattingPrefix = existingFormattingPrefix;\n                        isNewPrefix = false;\n                    }\n                    imgAttributes.addAttribute(XMLConstants.OPS_FORMATTING_URI, \"url-norewrite\", XMLUtils.buildQName(formattingPrefix, \"url-norewrite\"), ContentHandlerHelper.CDATA, \"true\");\n                }\n                if (isNewPrefix)\n                    contentHandler.startPrefixMapping(formattingPrefix, XMLConstants.OPS_FORMATTING_URI);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName, imgAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName);\n                if (isNewPrefix)\n                    contentHandler.endPrefixMapping(formattingPrefix);\n            } else if (isDateOrTime) {\n                // Display formatted value for dates\n                final String displayValue = controlInfo.getDisplayValue();\n                contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n            } else {\n                // Regular text case\n                final String value = controlInfo.getValue();\n                contentHandler.characters(value.toCharArray(), 0, value.length());\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","id":98814,"modified_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.OutputControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.OutputControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        final boolean isImage;\n        final boolean isDateOrTime;\n        final StringBuffer classes = new StringBuffer(\"xforms-control xforms-output\");\n        if (!handlerContext.isGenerateTemplate()) {\n\n            final String appearanceValue = elementAttributes.getValue(\"appearance\");\n            final String appearanceLocalname = (appearanceValue == null) ? null : XMLUtils.localNameFromQName(appearanceValue);\n            final String appearanceURI = (appearanceValue == null) ? null : uriFromQName(appearanceValue);\n\n            final String mediaType = controlInfo.getMediaTypeAttribute();\n\n            final boolean isHTML = appearanceValue != null && XFormsConstants.XXFORMS_NAMESPACE_URI.equals(appearanceURI) && \"html\".equals(appearanceLocalname);\n            isImage = mediaType != null && mediaType.startsWith(\"image/\");\n\n            // Find classes to add\n\n            if (isHTML) {\n                classes.append(\" xforms-output-html\");\n            } else if (isImage) {\n                classes.append(\" xforms-output-image\");\n            }\n            isDateOrTime = isDateOrTime(controlInfo.getType());\n            if (isDateOrTime) {\n                classes.append(\" xforms-date\");\n            }\n            handleReadOnlyClass(classes, controlInfo);\n            handleRelevantClass(classes, controlInfo);\n\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            handleReadOnlyAttribute(newAttributes, controlInfo);\n        } else {\n            isImage = false;\n            isDateOrTime = false;\n\n            // Find classes to add\n            newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n        }\n\n        // Create xhtml:span\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, newAttributes);\n        if (!handlerContext.isGenerateTemplate()) {\n            if (isImage) {\n                // Case of image media type with URI\n                final String imgQName = XMLUtils.buildQName(xhtmlPrefix, \"img\");\n                final AttributesImpl imgAttributes = new AttributesImpl();\n                // @src=\"...\"\n                imgAttributes.addAttribute(\"\", \"src\", \"src\", ContentHandlerHelper.CDATA, controlInfo.getValue());\n                // @f:url-norewrite=\"true\"\n                final String formattingPrefix;\n                final boolean isNewPrefix;\n                {\n                    final String existingFormattingPrefix = handlerContext.findFormattingPrefix();\n                    if (existingFormattingPrefix == null || \"\".equals(existingFormattingPrefix)) {\n                        // No prefix is currently mapped\n                        formattingPrefix = handlerContext.findNewPrefix();\n                        isNewPrefix = true;\n                    } else {\n                        formattingPrefix = existingFormattingPrefix;\n                        isNewPrefix = false;\n                    }\n                    imgAttributes.addAttribute(XMLConstants.OPS_FORMATTING_URI, \"url-norewrite\", XMLUtils.buildQName(formattingPrefix, \"url-norewrite\"), ContentHandlerHelper.CDATA, \"true\");\n                }\n                if (isNewPrefix)\n                    contentHandler.startPrefixMapping(formattingPrefix, XMLConstants.OPS_FORMATTING_URI);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName, imgAttributes);\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"img\", imgQName);\n                if (isNewPrefix)\n                    contentHandler.endPrefixMapping(formattingPrefix);\n            } else if (isDateOrTime) {\n                // Display formatted value for dates\n                final String displayValue = controlInfo.getDisplayValue();\n                contentHandler.characters(displayValue.toCharArray(), 0, displayValue.length());\n            } else {\n                // Regular text case\n                final String value = controlInfo.getValue();\n                if (value != null)\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n            }\n        }\n        contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private Attributes getAttributesWithClass(Attributes originalAttributes) {\n            String newClassAttribute = originalAttributes.getValue(\"class\");\n\n            if (addedClasses.length() > 0) {\n                if (newClassAttribute == null) {\n                    newClassAttribute = addedClasses.toString();\n                } else {\n                    newClassAttribute += \" \" + addedClasses;\n                }\n            }\n\n            if (newClassAttribute != null)\n                return XMLUtils.addOrReplaceAttribute(originalAttributes, \"\", \"\", \"class\", newClassAttribute);\n            else\n                return originalAttributes;\n        }","id":98815,"modified_method":"private Attributes getAttributesWithClass(Attributes originalAttributes) {\n            String newClassAttribute = originalAttributes.getValue(\"class\");\n\n            if (addedClasses != null && addedClasses.length() > 0) {\n                if (newClassAttribute == null) {\n                    newClassAttribute = addedClasses.toString();\n                } else {\n                    newClassAttribute += \" \" + addedClasses;\n                }\n            }\n\n            if (newClassAttribute != null)\n                return XMLUtils.addOrReplaceAttribute(originalAttributes, \"\", \"\", \"class\", newClassAttribute);\n            else\n                return originalAttributes;\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final String repeatId = attributes.getValue(\"id\");\n        final String effectiveId = handlerContext.getEffectiveId(attributes);\n\n        final boolean isTopLevelRepeat = handlerContext.countParentRepeats() == 0;\n        final boolean isRepeatSelected = handlerContext.isRepeatSelected() || isTopLevelRepeat;\n        final boolean isGenerateTemplate = handlerContext.isGenerateTemplate() || isTopLevelRepeat;\n        final int currentIteration = handlerContext.getCurrentIteration();\n\n        final XFormsControls.ControlsState currentControlState = containingDocument.getXFormsControls().getCurrentControlsState();\n        final Map effectiveRepeatIdToIterations = currentControlState.getEffectiveRepeatIdToIterations();\n        final Map repeatIdToIndex = currentControlState.getRepeatIdToIndex();\n\n        final int currentRepeatIndex = (currentIteration == 0 && !isTopLevelRepeat) ? 0 : ((Integer) repeatIdToIndex.get(repeatId)).intValue();\n//        System.out.println(\"Effective id: \" + effectiveId + \"; effectiveRepeatIdToIterations null: \" + (effectiveRepeatIdToIterations == null));\n        final int currentRepeatIterations = (currentIteration == 0 && !isTopLevelRepeat) ? 0 : ((Integer) effectiveRepeatIdToIterations.get(effectiveId)).intValue();\n\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n\n        // Place interceptor on output\n        final DeferredContentHandler savedOutput = handlerContext.getController().getOutput();\n        final OutputInterceptor outputInterceptor = new OutputInterceptor(savedOutput, effectiveId, spanQName);\n        handlerContext.getController().setOutput(new DeferredContentHandlerImpl(outputInterceptor));\n\n        setContentHandler(handlerContext.getController().getOutput());\n\n        if (isTopLevelRepeat || !isGenerateTemplate) {\n            // Unroll repeat\n\n            final XFormsControls.RepeatControlInfo repeatControlInfo = (XFormsControls.RepeatControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n            for (int i = 1; i <= currentRepeatIterations; i++) {\n                if (i > 1) {\n                    // Delimiter: between repeat entries\n                    outputRepeatDelimiter(savedOutput, outputInterceptor.getDelimiterNamespaceURI(), outputInterceptor.getDelimiterPrefix(), outputInterceptor.getDelimiterLocalName(), null);\n                }\n\n                // Is the current iteration selected?\n                final boolean isCurrentRepeatSelected = isRepeatSelected && i == currentRepeatIndex;\n                final boolean isCurrentRepeatRelevant = ((XFormsControls.RepeatIterationInfo) repeatControlInfo.getChildren().get(i - 1)).isRelevant();\n                final int numberParentRepeat = handlerContext.countParentRepeats();\n\n                // Determine classes to add on root elements and around root characters\n                final StringBuffer addedClasses;\n                {\n                    addedClasses = new StringBuffer();\n                    if (isCurrentRepeatSelected) {\n                        addedClasses.append(\"xforms-repeat-selected-item-\");\n                        addedClasses.append((numberParentRepeat % 2 == 0) ? '1' : '2');\n                    }\n                    if (!isCurrentRepeatRelevant)\n                        addedClasses.append(\" xforms-disabled\");\n                }\n                outputInterceptor.setAddedClasses(addedClasses);\n\n                // Apply the content of the body for this iteration\n                handlerContext.pushRepeatContext(false, i, false, isCurrentRepeatSelected);\n                repeatBody();\n                outputInterceptor.flushCharacters(true);\n                handlerContext.popRepeatContext();\n            }\n        }\n\n        if (isGenerateTemplate) {\n            // Generate template\n\n//            if (currentRepeatIterations > 0)\n//                mustGenerateFirstDelimiters[0] = true;\n\n            if (!outputInterceptor.isMustGenerateFirstDelimiters()) {\n                // Delimiter: between repeat entries\n                outputRepeatDelimiter(savedOutput, outputInterceptor.getDelimiterNamespaceURI(), outputInterceptor.getDelimiterPrefix(), outputInterceptor.getDelimiterLocalName(), null);\n            }\n\n            // Determine classes to add on root elements and around root characters\n            outputInterceptor.setAddedClasses(new StringBuffer(isTopLevelRepeat ? \"xforms-repeat-template\" : \"\"));\n\n            // Apply the content of the body for this iteration\n            handlerContext.pushRepeatContext(true, 0, false, false);\n            repeatBody();\n            outputInterceptor.flushCharacters(true);\n            handlerContext.popRepeatContext();\n        }\n\n        // Restore output\n        handlerContext.getController().setOutput(savedOutput);\n        setContentHandler(savedOutput);\n\n        // Delimiter: end repeat\n        outputRepeatDelimiter(savedOutput, outputInterceptor.getDelimiterNamespaceURI(), outputInterceptor.getDelimiterPrefix(), outputInterceptor.getDelimiterLocalName(), \"repeat-end-\" + effectiveId);\n    }","id":98816,"modified_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final String repeatId = attributes.getValue(\"id\");\n        final String effectiveId = handlerContext.getEffectiveId(attributes);\n\n        final boolean isTopLevelRepeat = handlerContext.countParentRepeats() == 0;\n        final boolean isRepeatSelected = handlerContext.isRepeatSelected() || isTopLevelRepeat;\n        final boolean isGenerateTemplate = handlerContext.isGenerateTemplate() || isTopLevelRepeat;\n        final int currentIteration = handlerContext.getCurrentIteration();\n\n        final XFormsControls.ControlsState currentControlState = containingDocument.getXFormsControls().getCurrentControlsState();\n        final Map effectiveRepeatIdToIterations = currentControlState.getEffectiveRepeatIdToIterations();\n        final Map repeatIdToIndex = currentControlState.getRepeatIdToIndex();\n\n        final int currentRepeatIndex = (currentIteration == 0 && !isTopLevelRepeat) ? 0 : ((Integer) repeatIdToIndex.get(repeatId)).intValue();\n//        System.out.println(\"Effective id: \" + effectiveId + \"; effectiveRepeatIdToIterations null: \" + (effectiveRepeatIdToIterations == null));\n        final int currentRepeatIterations = (currentIteration == 0 && !isTopLevelRepeat) ? 0 : ((Integer) effectiveRepeatIdToIterations.get(effectiveId)).intValue();\n\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n\n        // Place interceptor on output\n        final DeferredContentHandler savedOutput = handlerContext.getController().getOutput();\n        final OutputInterceptor outputInterceptor = new OutputInterceptor(savedOutput, effectiveId, spanQName);\n        handlerContext.getController().setOutput(new DeferredContentHandlerImpl(outputInterceptor));\n\n        setContentHandler(handlerContext.getController().getOutput());\n\n        if (isTopLevelRepeat || !isGenerateTemplate) {\n            // Unroll repeat\n\n            final XFormsControls.RepeatControlInfo repeatControlInfo = (XFormsControls.RepeatControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n            for (int i = 1; i <= currentRepeatIterations; i++) {\n                if (i > 1) {\n                    // Delimiter: between repeat entries\n                    outputRepeatDelimiter(savedOutput, outputInterceptor.getDelimiterNamespaceURI(), outputInterceptor.getDelimiterPrefix(), outputInterceptor.getDelimiterLocalName(), null);\n                }\n\n                // Is the current iteration selected?\n                final boolean isCurrentRepeatSelected = isRepeatSelected && i == currentRepeatIndex;\n                final boolean isCurrentRepeatRelevant = ((XFormsControls.RepeatIterationInfo) repeatControlInfo.getChildren().get(i - 1)).isRelevant();\n                final int numberParentRepeat = handlerContext.countParentRepeats();\n\n                // Determine classes to add on root elements and around root characters\n                final StringBuffer addedClasses;\n                {\n                    addedClasses = new StringBuffer();\n                    if (isCurrentRepeatSelected) {\n                        addedClasses.append(\"xforms-repeat-selected-item-\");\n                        addedClasses.append((numberParentRepeat % 2 == 0) ? '1' : '2');\n                    }\n                    if (!isCurrentRepeatRelevant)\n                        addedClasses.append(\" xforms-disabled\");\n                }\n                outputInterceptor.setAddedClasses(addedClasses);\n\n                // Apply the content of the body for this iteration\n                handlerContext.pushRepeatContext(false, i, false, isCurrentRepeatSelected);\n                handlerContext.getController().repeatBody();\n                outputInterceptor.flushCharacters(true);\n                handlerContext.popRepeatContext();\n            }\n        }\n\n        if (isGenerateTemplate) {\n            // Generate template\n\n//            if (currentRepeatIterations > 0)\n//                mustGenerateFirstDelimiters[0] = true;\n\n            if (!outputInterceptor.isMustGenerateFirstDelimiters()) {\n                // Delimiter: between repeat entries\n                outputRepeatDelimiter(savedOutput, outputInterceptor.getDelimiterNamespaceURI(), outputInterceptor.getDelimiterPrefix(), outputInterceptor.getDelimiterLocalName(), null);\n            }\n\n            // Determine classes to add on root elements and around root characters\n            outputInterceptor.setAddedClasses(new StringBuffer(isTopLevelRepeat ? \"xforms-repeat-template\" : \"\"));\n\n            // Apply the content of the body for this iteration\n            handlerContext.pushRepeatContext(true, 0, false, false);\n            handlerContext.getController().repeatBody();\n            outputInterceptor.flushCharacters(true);\n            handlerContext.popRepeatContext();\n        }\n\n        if (outputInterceptor.getDelimiterNamespaceURI() == null) {\n            // No delimiter has been generated, try to find one!\n\n            outputInterceptor.setForward(false); // prevent interceptor to output anything\n\n            handlerContext.pushRepeatContext(true, 0, false, false);\n            handlerContext.getController().repeatBody();\n            outputInterceptor.flushCharacters(true);\n            handlerContext.popRepeatContext();\n        }\n\n        // Restore output\n        handlerContext.getController().setOutput(savedOutput);\n        setContentHandler(savedOutput);\n\n        // Delimiter: end repeat\n        outputRepeatDelimiter(savedOutput, outputInterceptor.getDelimiterNamespaceURI(), outputInterceptor.getDelimiterPrefix(), outputInterceptor.getDelimiterLocalName(), \"repeat-end-\" + effectiveId);\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.ControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.ControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        {\n            final StringBuffer classes = new StringBuffer(\"xforms-control xforms-textarea\");\n            if (!handlerContext.isGenerateTemplate()) {\n\n                handleReadOnlyClass(classes, controlInfo);\n                handleRelevantClass(classes, controlInfo);\n\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n                handleReadOnlyAttribute(newAttributes, controlInfo);\n            } else {\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            }\n        }\n\n        // Create xhtml:textarea\n        {\n            final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n            final String textareaQName = XMLUtils.buildQName(xhtmlPrefix, \"textarea\");\n            newAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n\n            contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName, newAttributes);\n            if (!handlerContext.isGenerateTemplate()) {\n                final String value = controlInfo.getValue();\n                contentHandler.characters(value.toCharArray(), 0, value.length());\n            }\n            contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName);\n        }\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","id":98817,"modified_method":"public void end(String uri, String localname, String qName) throws SAXException {\n\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        final String effectiveId = handlerContext.getEffectiveId(elementAttributes);\n        final XFormsControls.ControlInfo controlInfo = handlerContext.isGenerateTemplate()\n                ? null : (XFormsControls.ControlInfo) containingDocument.getObjectById(pipelineContext, effectiveId);\n\n        // xforms:label\n        handleLabelHintHelpAlert(effectiveId, \"label\", controlInfo);\n\n        final AttributesImpl newAttributes;\n        {\n            final StringBuffer classes = new StringBuffer(\"xforms-control xforms-textarea\");\n            if (!handlerContext.isGenerateTemplate()) {\n\n                handleReadOnlyClass(classes, controlInfo);\n                handleRelevantClass(classes, controlInfo);\n\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n                handleReadOnlyAttribute(newAttributes, controlInfo);\n            } else {\n                newAttributes = getAttributes(elementAttributes, classes.toString(), effectiveId);\n            }\n        }\n\n        // Create xhtml:textarea\n        {\n            final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n            final String textareaQName = XMLUtils.buildQName(xhtmlPrefix, \"textarea\");\n            newAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, effectiveId);\n\n            contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName, newAttributes);\n            if (!handlerContext.isGenerateTemplate()) {\n                final String value = controlInfo.getValue();\n                if (value != null)\n                    contentHandler.characters(value.toCharArray(), 0, value.length());\n            }\n            contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"textarea\", textareaQName);\n        }\n\n        // xforms:help\n        handleLabelHintHelpAlert(effectiveId, \"help\", controlInfo);\n\n        // xforms:alert\n        handleLabelHintHelpAlert(effectiveId, \"alert\", controlInfo);\n\n        // xforms:hint\n        handleLabelHintHelpAlert(effectiveId, \"hint\", controlInfo);\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n        if (XFormsConstants.XFORMS_NAMESPACE_URI.equals(uri)) {\n            if (\"label\".equals(localname)) {\n                labelAttributes = new AttributesImpl(attributes);\n            } else if (\"hint\".equals(localname)) {\n                hintAttributes = new AttributesImpl(attributes);\n            } else if (\"help\".equals(localname)) {\n                helpAttributes = new AttributesImpl(attributes);\n            } else if (\"alert\".equals(localname)) {\n                alertAttributes = new AttributesImpl(attributes);\n            }\n        }\n        super.startElement(uri, localname, qName, attributes);\n    }","id":98818,"modified_method":"public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n        level++;\n        if (level == 1 && XFormsConstants.XFORMS_NAMESPACE_URI.equals(uri)) {\n            // Handle direct children only\n            if (\"label\".equals(localname)) {\n                labelAttributes = new AttributesImpl(attributes);\n            } else if (\"hint\".equals(localname)) {\n                hintAttributes = new AttributesImpl(attributes);\n            } else if (\"help\".equals(localname)) {\n                helpAttributes = new AttributesImpl(attributes);\n            } else if (\"alert\".equals(localname)) {\n                alertAttributes = new AttributesImpl(attributes);\n            }\n        }\n        super.startElement(uri, localname, qName, attributes);\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n        // Reset state, as this handler is reused\n        labelAttributes = null;\n        helpAttributes = null;\n        hintAttributes = null;\n        alertAttributes = null;\n    }","id":98819,"modified_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n        // Reset state, as this handler may be reused\n        level = 0;\n        labelAttributes = null;\n        helpAttributes = null;\n        hintAttributes = null;\n        alertAttributes = null;\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void endDocument() throws SAXException {\n            if (topLevelContentHandler)\n                super.endDocument();\n        }","id":98820,"modified_method":"public void endDocument() throws SAXException {\n            if (topLevelContentHandler) {\n                super.endDocument();\n            } else {\n                // Clean-up namespace mappings\n                sendClearEndPrefixMappings();\n            }\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void sendEndPrefixMappings() throws SAXException {\n            for (Enumeration e = paremtNamespaceSupport.getPrefixes(); e.hasMoreElements();) {\n                final String namespacePrefix = (String) e.nextElement();\n                if (!namespacePrefix.startsWith(\"xml\"))\n                    super.endPrefixMapping(namespacePrefix);\n            }\n\n            final String defaultNS = paremtNamespaceSupport.getURI(\"\");\n            if (defaultNS != null && defaultNS.length() > 0)\n                super.endPrefixMapping(\"\");\n        }","id":98821,"modified_method":"private void sendClearEndPrefixMappings() throws SAXException {\n            for (Enumeration e = paremtNamespaceSupport.getPrefixes(); e.hasMoreElements();) {\n                final String namespacePrefix = (String) e.nextElement();\n                if (!namespacePrefix.startsWith(\"xml\") && !namespacePrefix.equals(\"\"))\n                    super.endPrefixMapping(namespacePrefix);\n            }\n\n            final String defaultNS = paremtNamespaceSupport.getURI(\"\");\n            if (defaultNS != null && defaultNS.length() > 0)\n                super.endPrefixMapping(\"\");\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void startDocument() throws SAXException {\n            if (topLevelContentHandler)\n                super.startDocument();\n        }","id":98822,"modified_method":"public void startDocument() throws SAXException {\n            if (topLevelContentHandler) {\n                super.startDocument();\n            } else {\n                // Clean-up namespace mappings\n                sendClearStartPrefixMappings();\n            }\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void sendStartPrefixMappings() throws SAXException {\n            for (Enumeration e = paremtNamespaceSupport.getPrefixes(); e.hasMoreElements();) {\n                final String namespacePrefix = (String) e.nextElement();\n                if (!namespacePrefix.startsWith(\"xml\"))\n                    super.startPrefixMapping(namespacePrefix, \"\");\n            }\n\n            final String defaultNS = paremtNamespaceSupport.getURI(\"\");\n            if (defaultNS != null && defaultNS.length() > 0)\n                super.startPrefixMapping(\"\", \"\");\n        }","id":98823,"modified_method":"private void sendClearStartPrefixMappings() throws SAXException {\n            for (Enumeration e = paremtNamespaceSupport.getPrefixes(); e.hasMoreElements();) {\n                final String namespacePrefix = (String) e.nextElement();\n                if (!namespacePrefix.startsWith(\"xml\") && !namespacePrefix.equals(\"\"))\n                    super.startPrefixMapping(namespacePrefix, \"\");\n            }\n\n            final String defaultNS = paremtNamespaceSupport.getURI(\"\");\n            if (defaultNS != null && defaultNS.length() > 0)\n                super.startPrefixMapping(\"\", \"\");\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(final String name) {\n        final ProcessorOutput output = new URIProcessorOutputImpl(getClass(), name, INPUT_CONFIG) {\n            public void readImpl(final PipelineContext pipelineContext, final ContentHandler contentHandler) {\n//                final ContentHandler debugContentHandler = new SAXDebuggerProcessor.DebugContentHandler(contentHandler);\n                final TransformerURIResolver uriResolver = new TransformerURIResolver(XIncludeProcessor.this, pipelineContext, INPUT_CONFIG, false);\n\n                // Try to cache URI references\n                final boolean[] wasRead = { false };\n                readCacheInputAsObject(pipelineContext, getInputByName(INPUT_CONFIG), new CacheableInputReader() {\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        final URIReferences uriReferences = new URIReferences();\n                        readInputAsSAX(pipelineContext, INPUT_CONFIG, new XIncludeContentHandler(pipelineContext, contentHandler, uriReferences, uriResolver));\n                        wasRead[0] = true;\n                        return uriReferences;\n                    }\n                });\n\n                // Read if not already read\n                if (!wasRead[0]) {\n                    readInputAsSAX(pipelineContext, INPUT_CONFIG, new XIncludeContentHandler(pipelineContext, contentHandler, null, uriResolver));\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","id":98824,"modified_method":"public ProcessorOutput createOutput(final String name) {\n        final ProcessorOutput output = new URIProcessorOutputImpl(getClass(), name, INPUT_CONFIG) {\n            public void readImpl(final PipelineContext pipelineContext, final ContentHandler contentHandler) {\n//                final ContentHandler debugContentHandler = new SAXDebuggerProcessor.DebugContentHandler(contentHandler);\n                final ContentHandler debugContentHandler = contentHandler;\n                final TransformerURIResolver uriResolver = new TransformerURIResolver(XIncludeProcessor.this, pipelineContext, INPUT_CONFIG, false);\n\n                // Try to cache URI references\n                final boolean[] wasRead = { false };\n                readCacheInputAsObject(pipelineContext, getInputByName(INPUT_CONFIG), new CacheableInputReader() {\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        final URIReferences uriReferences = new URIReferences();\n                        readInputAsSAX(pipelineContext, INPUT_CONFIG, new XIncludeContentHandler(pipelineContext, debugContentHandler, uriReferences, uriResolver));\n                        wasRead[0] = true;\n                        return uriReferences;\n                    }\n                });\n\n                // Read if not already read\n                if (!wasRead[0]) {\n                    readInputAsSAX(pipelineContext, INPUT_CONFIG, new XIncludeContentHandler(pipelineContext, debugContentHandler, null, uriResolver));\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n            namespaceSupport.pushContext();\n\n            if (!topLevelContentHandler && level == 0) {\n                // Clean-up namespace mappings\n                sendStartPrefixMappings();\n                // Add or replace xml:base attribute\n                attributes = XMLUtils.addOrReplaceAttribute(attributes, XMLConstants.XML_URI, \"xml\", \"base\", xmlBase);\n            }\n\n            if (XMLConstants.XINCLUDE_URI.equals(uri) || XMLConstants.OLD_XINCLUDE_URI.equals(uri)) {\n                // Found XInclude namespace\n\n                // Warn upon obsolete namespace URI\n                if (XMLConstants.OLD_XINCLUDE_URI.equals(uri))\n                    logger.warn(\"Using incorrect XInclude namespace URI: '\" + uri + \"'; should use '\" + XMLConstants.XINCLUDE_URI + \"' at \" + new LocationData(locator).toString());\n\n                if (\"include\".equals(localname)) {\n                    // Start inclusion\n\n                    inInclude = true;\n                    includeLevel = level;\n\n                    final String href = attributes.getValue(\"href\");\n                    final String parse = attributes.getValue(\"parse\");\n\n                    if (parse != null && !parse.equals(\"xml\"))\n                        throw new ValidationException(\"Invalid 'parse' attribute value: \" + parse, new LocationData(locator));\n\n                    try {\n                        // Get SAXSource\n                        final String base = locator.getSystemId();\n                        final SAXSource source = (SAXSource) uriResolver.resolve(href, base);\n                        final XMLReader xmlReader = source.getXMLReader();\n                        xmlReader.setContentHandler(new XIncludeContentHandler(pipelineContext, getContentHandler(), uriReferences, uriResolver, source.getSystemId(), namespaceSupport));\n\n                        // Keep URI reference\n                        if (uriReferences != null)\n                            uriReferences.addReference(base, href);\n\n                        // Read document\n                        xmlReader.parse(new InputSource()); // Yeah, the SAX API doesn't make much sense\n\n                    } catch (Exception e) {\n                        // Resource error, must go to fallback if possible\n                        throw new OXFException(e);\n                    }\n\n                } else if (\"fallback\".equals(localname)) {\n                    // TODO\n                } else {\n                    throw new ValidationException(\"Invalid XInclude element: \" + localname, new LocationData(locator));\n                }\n\n            } else {\n                super.startElement(uri, localname, qName, attributes);\n            }\n\n            level++;\n        }","id":98825,"modified_method":"public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n            if (mustPushContext)\n                namespaceSupport.pushContext();\n            else\n                mustPushContext = true;\n\n            if (!topLevelContentHandler && level == 0) {\n                // Add or replace xml:base attribute\n                attributes = XMLUtils.addOrReplaceAttribute(attributes, XMLConstants.XML_URI, \"xml\", \"base\", xmlBase);\n            }\n\n            if (XMLConstants.XINCLUDE_URI.equals(uri) || XMLConstants.OLD_XINCLUDE_URI.equals(uri)) {\n                // Found XInclude namespace\n\n                // Warn upon obsolete namespace URI\n                if (XMLConstants.OLD_XINCLUDE_URI.equals(uri))\n                    logger.warn(\"Using incorrect XInclude namespace URI: '\" + uri + \"'; should use '\" + XMLConstants.XINCLUDE_URI + \"' at \" + new LocationData(locator).toString());\n\n                if (\"include\".equals(localname)) {\n                    // Start inclusion\n\n                    inInclude = true;\n\n                    final String href = attributes.getValue(\"href\");\n                    final String parse = attributes.getValue(\"parse\");\n\n                    if (parse != null && !parse.equals(\"xml\"))\n                        throw new ValidationException(\"Invalid 'parse' attribute value: \" + parse, new LocationData(locator));\n\n                    try {\n                        // Get SAXSource\n                        final String base = locator.getSystemId();\n                        final SAXSource source = (SAXSource) uriResolver.resolve(href, base);\n                        final XMLReader xmlReader = source.getXMLReader();\n                        xmlReader.setContentHandler(new XIncludeContentHandler(pipelineContext, getContentHandler(), uriReferences, uriResolver, source.getSystemId(), namespaceSupport));\n\n                        // Keep URI reference\n                        if (uriReferences != null)\n                            uriReferences.addReference(base, href);\n\n                        // Read document\n                        xmlReader.parse(new InputSource()); // Yeah, the SAX API doesn't make much sense\n\n                    } catch (Exception e) {\n                        // Resource error, must go to fallback if possible\n                        throw new OXFException(e);\n                    }\n\n                } else if (\"fallback\".equals(localname)) {\n                    // TODO\n                } else {\n                    throw new ValidationException(\"Invalid XInclude element: \" + localname, new LocationData(locator));\n                }\n\n            } else if (includeLevel != -1 && level == includeLevel) {\n                // We are starting a sibling of an included element\n\n                // Send adjusted prefix mappings\n                sendRestoreStartPrefixMappings();\n\n                super.startElement(uri, localname, qName, attributes);\n            } else {\n                super.startElement(uri, localname, qName, attributes);\n            }\n\n            level++;\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void startPrefixMapping(String prefix, String uri) throws SAXException {\n            namespaceSupport.declarePrefix(prefix, uri);\n            super.startPrefixMapping(prefix, uri);\n        }","id":98826,"modified_method":"public void startPrefixMapping(String prefix, String uri) throws SAXException {\n\n            if (mustPushContext) {\n                namespaceSupport.pushContext();\n                mustPushContext = false;\n            }\n\n            namespaceSupport.declarePrefix(prefix, uri);\n            super.startPrefixMapping(prefix, uri);\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void endElement(String uri, String localname, String qName) throws SAXException {\n\n            level--;\n\n            namespaceSupport.popContext();\n\n            if (XMLConstants.XINCLUDE_URI.equals(uri) || XMLConstants.OLD_XINCLUDE_URI.equals(uri)) {\n\n            } else {\n                super.endElement(uri, localname, qName);\n            }\n\n            if (!topLevelContentHandler && level == 0) {\n                sendEndPrefixMappings();\n            }\n        }","id":98827,"modified_method":"public void endElement(String uri, String localname, String qName) throws SAXException {\n\n            level--;\n\n            final boolean isEndingInclude;\n            if (XMLConstants.XINCLUDE_URI.equals(uri) || XMLConstants.OLD_XINCLUDE_URI.equals(uri)) {\n                if (\"include\".equals(localname)) {\n                    isEndingInclude = true;\n                } else {\n                    isEndingInclude = false;\n                }\n            } else {\n                isEndingInclude = false;\n                super.endElement(uri, localname, qName);\n            }\n\n            if (isEndingInclude) {\n                // Remember that we included at this level\n                includeLevel = level;\n            } else if (includeLevel != -1) {\n                if (level == includeLevel) {\n                    // Clear adjusted namespace mappings\n                    sendRestoreEndPrefixMappings();\n                } else if (level < includeLevel) {\n                    // Clear include level indicator\n                    includeLevel = -1;\n                }\n            }\n\n            namespaceSupport.popContext();\n            mustPushContext = true;\n        }","commit_id":"967e0250deb0a048a5e360c810ce72c3a3e888fd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, false);\r\n\r\n            if (target.canChoose(controller.getId(), game)) {\r\n                controller.choose(Outcome.ReturnToHand, target, source.getSourceId(), game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n\r\n                if ( permanent != null ) {\r\n                    targetChosen = true;\r\n                    controller.moveCardToHandWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD);\r\n                }\r\n            }\r\n\r\n            if ( !targetChosen ) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98828,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, false);\r\n\r\n            if (target.canChoose(controller.getId(), game) && controller.chooseUse(outcome, \"Return another creature you control to its owner's hand?\", game)) {\r\n                controller.chooseTarget(Outcome.ReturnToHand, target, source, game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n                if ( permanent != null ) {\r\n                    targetChosen = true;\r\n                    controller.moveCardToHandWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD);\r\n                }\r\n            }\r\n\r\n            if ( !targetChosen ) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"e63eef16aa9d8070e29525c4ffb5286fc6291b50","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, false);\r\n\r\n            if (target.canChoose(controller.getId(), game)) {\r\n                controller.choose(Outcome.ReturnToHand, target, source.getSourceId(), game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n\r\n                if (permanent != null) {\r\n                    targetChosen = true;\r\n                    controller.moveCards(permanent, null, Zone.HAND, source, game);\r\n                }\r\n            }\r\n\r\n            if (!targetChosen) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98829,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, true);\r\n            if (target.canChoose(controller.getId(), game) && controller.chooseUse(outcome, \"Return another creature you control to its owner's hand?\", source, game)) {\r\n                controller.chooseTarget(Outcome.ReturnToHand, target, source, game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n                if (permanent != null) {\r\n                    targetChosen = true;\r\n                    permanent.moveToZone(Zone.HAND, this.getId(), game, false);\r\n                }\r\n            }\r\n\r\n            if (!targetChosen) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"8f1af6b9403e741c310a17ece55571571b7ef6c0","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean targetChosen = false;\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        TargetPermanent target = new TargetPermanent(1, 1, filter, false);\r\n\r\n        if (target.canChoose(player.getId(), game)) {\r\n            player.choose(Outcome.Sacrifice, target, source.getSourceId(), game);\r\n            Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n\r\n            if ( permanent != null ) {\r\n                targetChosen = true;\r\n                permanent.moveToZone(Zone.HAND, this.getId(), game, false);\r\n            }\r\n        }\r\n\r\n        if ( !targetChosen ) {\r\n            new SacrificeSourceEffect().apply(game, source);\r\n        }\r\n\r\n        return false;\r\n    }","id":98830,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, true);\r\n            if (target.canChoose(controller.getId(), game) && controller.chooseUse(outcome, \"Return an artifact you control to its owner's hand?\", source, game)) {\r\n                controller.chooseTarget(Outcome.Sacrifice, target, source, game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n                if (permanent != null) {\r\n                    targetChosen = true;\r\n                    permanent.moveToZone(Zone.HAND, this.getId(), game, false);\r\n                }\r\n            }\r\n\r\n            if (!targetChosen) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"8f1af6b9403e741c310a17ece55571571b7ef6c0","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, true);\r\n            if (target.canChoose(controller.getId(), game) && controller.chooseUse(outcome, \"Return another creature you control to its owner's hand?\", source, game)) {\r\n                controller.chooseTarget(Outcome.ReturnToHand, target, source, game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n                if (permanent != null) {\r\n                    targetChosen = true;\r\n                    controller.moveCards(permanent, null, Zone.HAND, source, game);\r\n                }\r\n            }\r\n\r\n            if (!targetChosen) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98831,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, true);\r\n            if (target.canChoose(controller.getId(), game) && controller.chooseUse(outcome, \"Return another creature you control to its owner's hand?\", source, game)) {\r\n                controller.chooseTarget(Outcome.ReturnToHand, target, source, game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n                if (permanent != null) {\r\n                    targetChosen = true;\r\n                    permanent.moveToZone(Zone.HAND, this.getId(), game, false);\r\n                }\r\n            }\r\n\r\n            if (!targetChosen) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"8f1af6b9403e741c310a17ece55571571b7ef6c0","url":"https://github.com/magefree/mage"},{"original_method":"/**\n\t * Main function for the ccndcontrol tool.  Initializes the tool, reads the argument list\n\t * and constructs face to be added.\n\t * \n\t * @param args Command line arguments: \n\t * \n\t * @return void\n\t */\n\tpublic static void main(String[] args) {\n\t\tboolean dynamic = false;\n\t\tString configFile = null;\t\n\t\tint startArg = 0;\n\t\tLevel logLevel = Level.SEVERE;\n\t\t\n\t\tfor (int i = 0; i < args.length - 1; i++) {\n\t\t\tif (args[i].equals((\"-v\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tlogLevel = Level.INFO;\n\t\t\t} else if (args[i].equals((\"-vv\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tlogLevel = Level.ALL;\n\t\t\t} else if (args[i].equals((\"-d\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tdynamic = true;\n\t\t\t} else if (args[i].equals(\"-f\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t\tSystem.exit(1);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tconfigFile = args[++i];\n\t\t\t\tif (startArg <= i) {\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLog.setDefaultLevel(logLevel);\n\t\t\n\t\tif (null == configFile && args.length < startArg + 2) {\n\t\t\tusage();\n\t\t\tSystem.exit(1);\t\t\t\t\t\n\t\t}\n\t\t\n\t\tif (null != configFile) {\n\t\t\tprocessConfigFile(configFile);\n\t\t} else {\n\t\t\tparseFromTokens(args, startArg, args.length);\n\t\t}\n\t\t\n\t\tint nReg = regList.size();\n\t\tfor (int i = 0; i < nReg; i++) {\n\t\t\tRegEntry entry = regList.get(i);\n\t\t\tCCNHandle ccnHandle = null;\n\t\t\tFaceManager fHandle = null;\n\t\t\tInteger faceID = null;\t\t\n\t\t\ttry {\n\t\t\t\tccnHandle = CCNHandle.open();\n\t\t\t\tfHandle = new FaceManager(ccnHandle);\n\t\t\t\tif (entry.command == Command.Add) {\n\t\t\t\t\tfaceID = fHandle.createFace(entry.protocol, entry.host, entry.port);\n\t\t\t\t\tLog.info(\"Created face \" + faceID.toString());\n\t\t\t\t\tPrefixRegistrationManager pre = new PrefixRegistrationManager(ccnHandle);\n\t\t\t\t\tpre.registerPrefix(entry.uri, faceID, entry.flags);\n\t\t\t\t\tLog.info(\"Added registration for \" + entry.uri);\n\t\t\t\t\n\t\t\t\t} else if (entry.command == Command.Delete) {\n\t\t\t\t\tfHandle.deleteFace(entry.faceID);\n\t\t\t\t} else {\n\t\t\t\t\t\t/* This really can't happen unless the check above was wrong. */\n\t\t\t\t\t\tLog.severe(\"Internal error.  command (\" + entry.command + \") not add or del\");\n\t\t\t\t\t\tLog.abort();\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} catch (ConfigurationException e) {\n\t\t\t\tSystem.err.println(\"Configuration Error\");\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.err.println(e.toString());\n\t\t\t\te.printStackTrace();\n\t\t\t}catch (CCNDaemonException e) {\n\t\t\t\tSystem.err.println(e.toString());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tSystem.exit(0);\n\t}","id":98832,"modified_method":"/**\n\t * Main function for the ccndcontrol tool.  Initializes the tool, reads the argument list\n\t * and constructs face to be added.\n\t * \n\t * @param args Command line arguments: \n\t * \n\t * @return void\n\t */\n\tpublic static void main(String[] args) {\n\t\tboolean dynamic = false;\n\t\tString configFile = null;\t\n\t\tint startArg = 0;\n\t\tLevel logLevel = Level.SEVERE;\n\t\tverbose = false;\n\t\t\n\t\tfor (int i = 0; i < args.length - 1; i++) {\n\t\t\tif (args[i].equals((\"-v\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tverbose = true;\n\t\t\t\tlogLevel = Level.INFO;\n\t\t\t} else if (args[i].equals((\"-vv\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tlogLevel = Level.ALL;\n\t\t\t} else if (args[i].equals((\"-d\"))) {\n\t\t\t\tif (startArg <= i)\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\tdynamic = true;\n\t\t\t} else if (args[i].equals(\"-f\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tusage();\n\t\t\t\t\tSystem.exit(1);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tconfigFile = args[++i];\n\t\t\t\tif (startArg <= i) {\n\t\t\t\t\tstartArg = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLog.setDefaultLevel(logLevel);\n\t\t\n\t\tif (null == configFile && args.length < startArg + 2) {\n\t\t\tusage();\n\t\t\tSystem.exit(1);\t\t\t\t\t\n\t\t}\n\t\t\n\t\tif (null != configFile) {\n\t\t\tprocessConfigFile(configFile);\n\t\t} else {\n\t\t\tparseFromTokens(args, startArg, args.length);\n\t\t}\n\t\t\n\t\tint nReg = regList.size();\n\t\tfor (int i = 0; i < nReg; i++) {\n\t\t\tRegEntry entry = regList.get(i);\n\t\t\tCCNHandle ccnHandle = null;\n\t\t\tFaceManager fHandle = null;\n\t\t\tInteger faceID = null;\t\t\n\t\t\ttry {\n\t\t\t\tccnHandle = CCNHandle.open();\n\t\t\t\tfHandle = new FaceManager(ccnHandle);\n\t\t\t\tif (entry.command == Command.Add) {\n\t\t\t\t\tfaceID = fHandle.createFace(entry.protocol, entry.host, entry.port);\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tSystem.out.println(\"Created face \" + faceID.toString());\n\t\t\t\t\t}\n\t\t\t\t\tPrefixRegistrationManager pre = new PrefixRegistrationManager(ccnHandle);\n\t\t\t\t\tpre.registerPrefix(entry.uri, faceID, entry.flags);\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tSystem.out.println(\"Added registration for \" + entry.uri);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (entry.command == Command.Delete) {\n\t\t\t\t\tfHandle.deleteFace(entry.faceID);\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tSystem.out.println(\"Deleted face \" + entry.faceID.toString() + \" in local ccnd\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* This really can't happen unless the check above was wrong. */\n\t\t\t\t\tSystem.err.println(\"Internal error.  command (\" + entry.command + \") not add or del\");\n\t\t\t\t\tSystem.exit(1);\t\t\t\n\t\t\t\t}\n\n\t\t\t} catch (ConfigurationException e) {\n\t\t\t\tString m = e.getMessage();\n\t\t\t\tSystem.err.println(m);\n\t\t\t\tSystem.exit(1);\t\t\t\n\t\t\t} catch (IOException e) {\n\t\t\t\tString m = e.getMessage();\n\t\t\t\tSystem.err.println(m);\n\t\t\t\tSystem.exit(1);\t\t\t\n\t\t\t}catch (CCNDaemonException e) {\n\t\t\t\tString m = e.getMessage();\n\t\t\t\tSystem.err.println(m);\n\t\t\t\tSystem.exit(1);\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tSystem.exit(0);\n\t}","commit_id":"a64ad62923c3ab9c637b414344ddee50c94f405d","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n   * Retrieves the port number of the flume collector from the gateway\n   * configuration. If no name is passed in, tries to figures out the name\n   * by scanning through the configuration.\n   *\n   * @param config    The gateway configuration\n   * @param flumeName The name of the flume collector, optional\n   * @return The port number if found, or -1 otherwise.\n   */\n  static int findFlumePort(CConfiguration config, String flumeName) {\n\n    if (flumeName == null) {\n      // find the name of the flume collector\n      flumeName = Util.findConnector(config, FlumeCollector.class);\n      if (flumeName == null) {\n        return -1;\n      } else {\n        LOG.info(\"Reading configuration for connector '\" + flumeName + \"'.\");\n      }\n    }\n    // get the collector's port number from the config\n    return config.getInt(Constants.buildConnectorPropertyName(\n        flumeName, Constants.CONFIG_PORT), -1);\n  }","id":98833,"modified_method":"/**\n   * Retrieves the port number of the flume collector from the gateway\n   * configuration. If no name is passed in, tries to figures out the name\n   * by scanning through the configuration.\n   *\n   * @param config    The gateway configuration\n   * @param flumeName The name of the flume collector, optional\n   * @return The port number if found, or -1 otherwise.\n   */\n  int findFlumePort(CConfiguration config, String flumeName) {\n\n    if (flumeName == null) {\n      // find the name of the flume collector\n      flumeName = Util.findConnector(config, FlumeCollector.class);\n      if (flumeName == null) {\n        return -1;\n      } else {\n        if (verbose)\n          System.out.println(\"Reading configuration for connector '\" + flumeName + \"'.\");\n      }\n    }\n    // get the collector's port number from the config\n    return config.getInt(Constants.buildConnectorPropertyName(\n        flumeName, Constants.CONFIG_PORT), -1);\n  }","commit_id":"207627c1da9e1c52c840b68a8804a40d5973a0a1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Parse the command line arguments\n   */\n  void parseArguments(String[] args) {\n    if (args.length == 0) usage(true);\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      help = true;\n      return;\n    }\n    // go through all the arguments\n    for (int pos = 0; pos < args.length; pos++) {\n      String arg = args[pos];\n      if (\"--port\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        try {\n          port = Integer.valueOf(args[pos]);\n          continue;\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      } else if (\"--host\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        hostname = args[pos];\n      } else if (\"--connector\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        connector = args[pos];\n      } else if (\"--stream\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        destination = args[pos];\n      } else if (\"--header\".equals(arg)) {\n        if (pos + 2 >= args.length) usage(true);\n        headers.put(args[++pos], args[++pos]);\n      } else if (\"--body\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        body = args[pos];\n      } else if (\"--body-file\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        bodyFile = args[pos];\n      } else if (\"--help\".equals(arg)) {\n        usage(false);\n        help = true;\n        return;\n      } else {  // unkown argument\n        usage(true);\n      }\n    }\n  }","id":98834,"modified_method":"/**\n   * Parse the command line arguments\n   */\n  void parseArguments(String[] args) {\n    if (args.length == 0) usage(true);\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      help = true;\n      return;\n    }\n    // go through all the arguments\n    for (int pos = 0; pos < args.length; pos++) {\n      String arg = args[pos];\n      if (\"--port\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        try {\n          port = Integer.valueOf(args[pos]);\n          continue;\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      } else if (\"--host\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        hostname = args[pos];\n      } else if (\"--connector\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        connector = args[pos];\n      } else if (\"--stream\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        destination = args[pos];\n      } else if (\"--header\".equals(arg)) {\n        if (pos + 2 >= args.length) usage(true);\n        headers.put(args[++pos], args[++pos]);\n      } else if (\"--body\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        body = args[pos];\n      } else if (\"--body-file\".equals(arg)) {\n        if (++pos >= args.length) usage(true);\n        bodyFile = args[pos];\n      } else if (\"--help\".equals(arg)) {\n        usage(false);\n        help = true;\n        return;\n      } else if (\"--verbose\".equals(arg)) {\n        verbose = true;\n      } else {  // unkown argument\n        usage(true);\n      }\n    }\n  }","commit_id":"207627c1da9e1c52c840b68a8804a40d5973a0a1","url":"https://github.com/caskdata/cdap"},{"original_method":"public byte[] findClassBytes(String name) {\n    return getClassPathItem().getClass(name);\n  }","id":98835,"modified_method":"public byte[] findClassBytes(String name) {\n    IClassPathItem cpi = getClassPathItem();\n    if (cpi==null) return null;\n    return cpi.getClass(name);\n  }","commit_id":"ae0e498e796cca0627645e03a4a73465cb738711","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean hasClass(String name) {\n    return getClassPathItem().hasClass(name);\n  }","id":98836,"modified_method":"public boolean hasClass(String name) {\n    IClassPathItem cpi = getClassPathItem();\n    if (cpi==null) return false;\n    return cpi.hasClass(name);\n  }","commit_id":"ae0e498e796cca0627645e03a4a73465cb738711","url":"https://github.com/JetBrains/MPS"},{"original_method":"public URL findResource(String name) {\n    return getClassPathItem().getResource(name);\n  }","id":98837,"modified_method":"public URL findResource(String name) {\n    IClassPathItem cpi = getClassPathItem();\n    if (cpi==null) return null;\n    return cpi.getResource(name);\n  }","commit_id":"ae0e498e796cca0627645e03a4a73465cb738711","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void moduleAdded(IModule module) {\n    excludeClassesGen(module);\n    excludeClassPath(module, module.getClassPathItem());\n  }","id":98838,"modified_method":"private void moduleAdded(IModule module) {\n    excludeClassesGen(module);\n    IClassPathItem pathItem = module.getClassPathItem();\n    if (pathItem == null) return;\n    excludeClassPath(module, pathItem);\n  }","commit_id":"2f37916e3caff71230873b02a1c3fa0be0f3a160","url":"https://github.com/JetBrains/MPS"},{"original_method":"public KeyShortcut(int modifiers, int keyCode, ShortcutContext context, String description, KeyShortcutEventHandler handler, String keyEvent, boolean displayInView, boolean stopPropagation, boolean preventDefault)\n   {\n      this(modifiers, keyCode, context, description, handler, keyEvent, displayInView, false, false, false);\n   }","id":98839,"modified_method":"/**\n    * Construct a KeyShortcut.\n    * @param modifiers keys such as Shift and Alt that must be depressed for the\n    *           shortcut to fire.\n    *           <p>\n    *           Use {@link #ALT_KEY}, {@link #SHIFT_KEY},\n    *           {@link #SHIFT_ALT_KEYS}, {@link #META_KEY} and {@link #CTRL_KEY}\n    *           to generate this. ( e.g. {@code CTRL_KEY | ALT_KEY} )\n    *           <\/p>\n    * @param keyCode the integer code for the key.\n    *           <p>\n    *           This may be an uppercase character, but results may vary so test\n    *           thoroughly in the targeted browsers.\n    *           <\/p>\n    *           <p>\n    *           Note that for keypress events, the key code depends on Shift and\n    *           CapsLock and will give the lowercase or uppercase ASCII code as\n    *           expected. keydown and keyup events appear always to give the\n    *           uppercase key code (keydown is currently used for all shortcuts.\n    *           <\/p>\n    * @param context see\n    *           {@link KeyShortcutPresenter#setContextActive(ShortcutContext, boolean)}\n    * @param description shown to the user in the key shortcut summary pane.\n    *        Use {@link #DO_NOT_DISPLAY_DESCRIPTION} to prevent shortcut being displayed in the summary.\n    * @param stopPropagation\n    * @param preventDefault\n    * @param isNot\n    * @param keyAction defined if shortcut action to be triggered by KeyUp, or\n    *           KeyDown. Default KeyDown.\n    */\n   public KeyShortcut(int modifiers, int keyCode, ShortcutContext context, String description, KeyShortcutEventHandler handler, String keyEvent, boolean stopPropagation, boolean preventDefault, boolean isNot)\n   {\n      this.modifiers = modifiers;\n      this.keyCode = keyCode;\n      this.context = context;\n      this.description = description;\n      this.handler = handler;\n      this.keyEvent = keyEvent;\n      this.stopPropagation = stopPropagation;\n      this.preventDefault = preventDefault;\n      this.isNot = isNot;\n   }","commit_id":"4aa34395f122392df66ce826cb55065b78ecdb20","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Construct a KeyShortcut.\n    * \n    * @param modifiers keys such as Shift and Alt that must be depressed for the\n    *           shortcut to fire.\n    *           <p>\n    *           Use {@link #ALT_KEY}, {@link #SHIFT_KEY},\n    *           {@link #SHIFT_ALT_KEYS}, {@link #META_KEY} and {@link #CTRL_KEY}\n    *           to generate this. ( e.g. {@code} CTRL_KEY | ALT_KEY )\n    *           <\/p>\n    * @param keyCode the integer code for the key.\n    *           <p>\n    *           This may be an uppercase character, but results may vary so test\n    *           thoroughly in the targeted browsers.\n    *           <\/p>\n    *           <p>\n    *           Note that for keypress events, the key code depends on Shift and\n    *           CapsLock and will give the lowercase or uppercase ASCII code as\n    *           expected. keydown and keyup events appear always to give the\n    *           uppercase key code (keydown is currently used for all shortcuts.\n    *           <\/p>\n    * @param context see\n    *           {@link KeyShortcutPresenter#setContextActive(ShortcutContext, boolean)}\n    * @param description shown to the user in the key shortcut summary pane\n    * \n    * @param keyAction defined if shortcut action to be triggered by KeyUp, or\n    *           KeyDown. Default KeyDown.\n    * \n    * @param displayInView\n    * \n    * @param stopPropagation\n    * \n    * @param preventDefault\n    * \n    * @param isNot\n    */\n   public KeyShortcut(int modifiers, int keyCode, ShortcutContext context, String description, KeyShortcutEventHandler handler, String keyEvent, boolean displayInView, boolean stopPropagation, boolean preventDefault, boolean isNot)\n   {\n      this.modifiers = modifiers;\n      this.keyCode = keyCode;\n      this.context = context;\n      this.description = description;\n      this.handler = handler;\n      this.keyEvent = keyEvent;\n      this.displayInView = displayInView;\n      this.stopPropagation = stopPropagation;\n      this.preventDefault = preventDefault;\n      this.isNot = isNot;\n   }","id":98840,"modified_method":"/**\n    * Construct a KeyShortcut.\n    * \n    * @param modifiers keys such as Shift and Alt that must be depressed for the\n    *           shortcut to fire.\n    *           <p>\n    *           Use {@link #ALT_KEY}, {@link #SHIFT_KEY},\n    *           {@link #SHIFT_ALT_KEYS}, {@link #META_KEY} and {@link #CTRL_KEY}\n    *           to generate this. ( e.g. {@code CTRL_KEY | ALT_KEY} )\n    *           <\/p>\n    * @param keyCode the integer code for the key.\n    *           <p>\n    *           This may be an uppercase character, but results may vary so test\n    *           thoroughly in the targeted browsers.\n    *           <\/p>\n    *           <p>\n    *           Note that for keypress events, the key code depends on Shift and\n    *           CapsLock and will give the lowercase or uppercase ASCII code as\n    *           expected. keydown and keyup events appear always to give the\n    *           uppercase key code.\n    *           <\/p>\n    * @param context see\n    *           {@link KeyShortcutPresenter#setContextActive(ShortcutContext, boolean)}\n    * @param description shown to the user in the key shortcut summary pane.\n    *        Use {@link #DO_NOT_DISPLAY_DESCRIPTION} to prevent shortcut being\n    *        displayed in the summary pane.\n    * @param keyAction determines which type of key event this shortcut will \n    *        respond to.\n    * @param stopPropagation\n    * @param preventDefault\n    */\n   public KeyShortcut(int modifiers, int keyCode, ShortcutContext context, String description, KeyShortcutEventHandler handler, String keyEvent, boolean stopPropagation, boolean preventDefault)\n   {\n      this(modifiers, keyCode, context, description, handler, keyEvent, stopPropagation, preventDefault, false);\n   }","commit_id":"4aa34395f122392df66ce826cb55065b78ecdb20","url":"https://github.com/zanata/zanata-server"},{"original_method":"public KeyShortcut(int modifiers, int keyCode, ShortcutContext context, String description, KeyShortcutEventHandler handler)\n   {\n      this(modifiers, keyCode, context, description, handler, KEY_DOWN_EVENT, true, false, false);\n   }","id":98841,"modified_method":"/**\n    * Create a key-down key shortcut that does not stop propagation or prevent default actions.\n    * \n    * @see #KeyShortcut(int, int, ShortcutContext, String, KeyShortcutEventHandler, String, boolean, boolean, boolean)\n    */\n   public KeyShortcut(int modifiers, int keyCode, ShortcutContext context, String description, KeyShortcutEventHandler handler)\n   {\n      this(modifiers, keyCode, context, description, handler, KEY_DOWN_EVENT, false, false);\n   }","commit_id":"4aa34395f122392df66ce826cb55065b78ecdb20","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean isDisplayInView()\n   {\n      return displayInView;\n   }","id":98842,"modified_method":"public boolean isDisplayInView()\n   {\n      return !DO_NOT_DISPLAY_DESCRIPTION.equals(description);\n   }","commit_id":"4aa34395f122392df66ce826cb55065b78ecdb20","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      ensureActiveContexts().add(ShortcutContext.Application);\n\n      Event.addNativePreviewHandler(new NativePreviewHandler()\n      {\n\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            NativeEvent evt = event.getNativeEvent();\n\n            if ((event.getTypeInt() & (Event.ONKEYDOWN | Event.ONKEYUP)) != 0)\n            {\n               processKeyEvent(evt);\n            }\n         }\n      });\n\n      registerKeyShortcut(new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ESCAPE, ShortcutContext.Application, messages.closeShortcutView(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (display.isShowing())\n            {\n               display.hide(true);\n            }\n         }\n      }, KeyShortcut.KEY_UP_EVENT, true, true, true));\n\n      // could try to use ?, although this is not as simple as passing character\n      // '?'\n      registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, 'Y', ShortcutContext.Application, messages.showAvailableKeyShortcuts(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            display.clearPanel();\n            for (ShortcutContext context : ensureActiveContexts())\n            {\n               display.addContext(context, ensureShortcutMap().values());\n            }\n            display.showPanel();\n         }\n      }));\n   }","id":98843,"modified_method":"@Override\n   protected void onBind()\n   {\n      ensureActiveContexts().add(ShortcutContext.Application);\n\n      Event.addNativePreviewHandler(new NativePreviewHandler()\n      {\n\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            NativeEvent evt = event.getNativeEvent();\n\n            if ((event.getTypeInt() & (Event.ONKEYDOWN | Event.ONKEYUP)) != 0)\n            {\n               processKeyEvent(evt);\n            }\n         }\n      });\n\n      registerKeyShortcut(new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ESCAPE, ShortcutContext.Application, messages.closeShortcutView(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (display.isShowing())\n            {\n               display.hide(true);\n            }\n         }\n      }, KeyShortcut.KEY_UP_EVENT, true, true));\n\n      // could try to use ?, although this is not as simple as passing character\n      // '?'\n      registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, 'Y', ShortcutContext.Application, messages.showAvailableKeyShortcuts(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            display.clearPanel();\n            for (ShortcutContext context : ensureActiveContexts())\n            {\n               display.addContext(context, ensureShortcutMap().values());\n            }\n            display.showPanel();\n         }\n      }));\n   }","commit_id":"4aa34395f122392df66ce826cb55065b78ecdb20","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public TargetContentsPresenter(Provider<TargetContentsDisplay> displayProvider, final CachingDispatchAsync dispatcher, final Identity identity, final EventBus eventBus, final TableEditorMessages messages, final SourceContentsPresenter sourceContentsPresenter, final UserSessionService sessionService, final UserConfigHolder configHolder, WorkspaceContext workspaceContext, Scheduler scheduler, ValidationMessagePanelDisplay validationMessagePanel, final KeyShortcutPresenter keyShortcutPresenter)\n   {\n      this.displayProvider = displayProvider;\n      this.eventBus = eventBus;\n      this.messages = messages;\n      this.sourceContentsPresenter = sourceContentsPresenter;\n      this.configHolder = configHolder;\n      this.workspaceContext = workspaceContext;\n      this.scheduler = scheduler;\n      this.validationMessagePanel = validationMessagePanel;\n      this.sessionService = sessionService;\n      this.identity = identity;\n      this.dispatcher = dispatcher;\n      this.keyShortcutPresenter = keyShortcutPresenter;\n\n      eventBus.addHandler(UserConfigChangeEvent.getType(), this);\n      eventBus.addHandler(RequestValidationEvent.getType(), this);\n      eventBus.addHandler(InsertStringInEditorEvent.getType(), this);\n      eventBus.addHandler(CopyDataToEditorEvent.getType(), this);\n      eventBus.addHandler(TransUnitEditEvent.getType(), this);\n      eventBus.addHandler(EnableModalNavigationEvent.getType(), this);\n\n      KeyShortcutEventHandler copyTM1Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(0));\n         }\n      };\n\n      KeyShortcutEventHandler copyTM2Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(1));\n         }\n      };\n\n      KeyShortcutEventHandler copyTM3Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(2));\n         }\n      };\n\n      KeyShortcutEventHandler copyTM4Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(3));\n         }\n      };\n\n      // Register shortcut CTRL+ALT+1 to copy result from TM result 1\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_1, ShortcutContext.Edit, messages.copyFromTM(\"1\"), copyTM1Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_1_NUM, ShortcutContext.Edit, messages.copyFromTM(\"1\"), copyTM1Handler, false));\n\n      // Register shortcut CTRL+ALT+2 to copy result from TM result 2\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_2, ShortcutContext.Edit, messages.copyFromTM(\"2\"), copyTM2Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_2_NUM, ShortcutContext.Edit, messages.copyFromTM(\"2\"), copyTM2Handler, false));\n\n      // Register shortcut CTRL+ALT+3 to copy result from TM result 3\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_3, ShortcutContext.Edit, messages.copyFromTM(\"3\"), copyTM3Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_3_NUM, ShortcutContext.Edit, messages.copyFromTM(\"3\"), copyTM3Handler, false));\n\n      // Register shortcut CTRL+ALT+4 to copy result from TM result 4\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_4, ShortcutContext.Edit, messages.copyFromTM(\"4\"), copyTM4Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_4_NUM, ShortcutContext.Edit, messages.copyFromTM(\"4\"), copyTM4Handler, false));\n\n      KeyShortcutEventHandler moveNextKeyHandler = new KeyShortcutEventHandler()\n      {\n\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            moveNext(false);\n         }\n      };\n\n      KeyShortcutEventHandler movePreviousKeyHandler = new KeyShortcutEventHandler()\n      {\n\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            movePrevious(false);\n         }\n      };\n\n      // Register shortcut ALT+(Down/K) to move next row and open editor\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_DOWN, ShortcutContext.Edit, messages.moveToNextRow(), moveNextKeyHandler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_K, ShortcutContext.Edit, messages.moveToNextRow(), moveNextKeyHandler));\n\n      // Register shortcut ALT+(Up/J) to move previous row and open editor\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_UP, ShortcutContext.Edit, messages.moveToPreviousRow(), movePreviousKeyHandler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_J, ShortcutContext.Edit, messages.moveToPreviousRow(), movePreviousKeyHandler));\n\n      // Register shortcut ALT+(PageDown) to move next state entry - if modal\n      // navigation is enabled\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_PAGEDOWN, ShortcutContext.Edit, messages.moveToNextStateRow(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (isModalNavEnabled)\n            {\n               moveToNextState(NavTransUnitEvent.NavigationType.NextEntry);\n            }\n         }\n      }));\n\n      // Register shortcut ALT+(PageUp) to move previous state entry - if modal\n      // navigation is enabled\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_PAGEUP, ShortcutContext.Edit, messages.moveToPreviousStateRow(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (isModalNavEnabled)\n            {\n               moveToNextState(NavTransUnitEvent.NavigationType.PrevEntry);\n            }\n         }\n      }));\n\n      // Register shortcut CTRL+S to save as fuzzy\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_KEY, KeyShortcut.KEY_S, ShortcutContext.Edit, messages.saveAsFuzzy(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            saveAsFuzzy();\n         }\n      }, KeyShortcut.KEY_DOWN_EVENT, true, true, true));\n\n      KeyShortcutEventHandler saveAsApprovedKeyShortcutHandler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            saveAsApprovedAndMoveNext();\n         }\n      };\n\n      ctrlEnterSavesApprovedShortcut = new KeyShortcut(KeyShortcut.CTRL_KEY, KeyCodes.KEY_ENTER,\n            ShortcutContext.Edit, messages.saveAsApproved(), saveAsApprovedKeyShortcutHandler,\n            KeyShortcut.KEY_DOWN_EVENT, true, true, true);\n\n      enterSavesApprovedShortcut = new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ENTER,\n            ShortcutContext.Edit, messages.saveAsApproved(), saveAsApprovedKeyShortcutHandler,\n            KeyShortcut.KEY_DOWN_EVENT, true, true, true);\n\n      enterTriggersAutoSizeShortcut = new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ENTER,\n            ShortcutContext.Edit, \"\", new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            getCurrentEditor().autoSizePlusOne();\n         }\n      },\n            KeyShortcut.KEY_DOWN_EVENT, false, false, false);\n\n      if (configHolder.isEnterSavesApproved())\n      {\n         enterSavesApprovedRegistered = true;\n         enterSavesApprovedHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(enterSavesApprovedShortcut);\n      }\n      else\n      {\n         enterSavesApprovedRegistered = false;\n         ctrlEnterSavesApprovedHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(ctrlEnterSavesApprovedShortcut);\n         enterTriggersAutoSizeHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(enterTriggersAutoSizeShortcut);\n      }\n\n      // Register user typing keys to (anything not CTRL or ALT or ESC or ENTER) resize textarea\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.ESC_ENTER_KEYS, ShortcutContext.Edit, messages.userTyping(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            getCurrentEditor().autoSize();\n         }\n      }, KeyShortcut.KEY_DOWN_EVENT, false, false, false, true));\n\n      escClosesEditorShortcut = new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ESCAPE,\n            ShortcutContext.Edit, messages.closeEditor(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (configHolder.isEscClosesEditor() && !keyShortcutPresenter.getDisplay().isShowing())\n            {\n               onCancel();\n            }\n         }\n      });\n\n      if (configHolder.isEscClosesEditor()) {\n         escClosesEditorRegistered = true;\n         escClosesEditorHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(escClosesEditorShortcut);\n      }\n      else\n      {\n         escClosesEditorRegistered = false;\n      }\n\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_G, ShortcutContext.Edit, \"Copy from source\", new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (getCurrentEditor().isFocused())\n            {\n               copySource(getCurrentEditor());\n            }\n         }\n      }));\n\n   }","id":98844,"modified_method":"@Inject\n   public TargetContentsPresenter(Provider<TargetContentsDisplay> displayProvider, final CachingDispatchAsync dispatcher, final Identity identity, final EventBus eventBus, final TableEditorMessages messages, final SourceContentsPresenter sourceContentsPresenter, final UserSessionService sessionService, final UserConfigHolder configHolder, WorkspaceContext workspaceContext, Scheduler scheduler, ValidationMessagePanelDisplay validationMessagePanel, final KeyShortcutPresenter keyShortcutPresenter)\n   {\n      this.displayProvider = displayProvider;\n      this.eventBus = eventBus;\n      this.messages = messages;\n      this.sourceContentsPresenter = sourceContentsPresenter;\n      this.configHolder = configHolder;\n      this.workspaceContext = workspaceContext;\n      this.scheduler = scheduler;\n      this.validationMessagePanel = validationMessagePanel;\n      this.sessionService = sessionService;\n      this.identity = identity;\n      this.dispatcher = dispatcher;\n      this.keyShortcutPresenter = keyShortcutPresenter;\n\n      eventBus.addHandler(UserConfigChangeEvent.getType(), this);\n      eventBus.addHandler(RequestValidationEvent.getType(), this);\n      eventBus.addHandler(InsertStringInEditorEvent.getType(), this);\n      eventBus.addHandler(CopyDataToEditorEvent.getType(), this);\n      eventBus.addHandler(TransUnitEditEvent.getType(), this);\n      eventBus.addHandler(EnableModalNavigationEvent.getType(), this);\n\n      KeyShortcutEventHandler copyTM1Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(0));\n         }\n      };\n\n      KeyShortcutEventHandler copyTM2Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(1));\n         }\n      };\n\n      KeyShortcutEventHandler copyTM3Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(2));\n         }\n      };\n\n      KeyShortcutEventHandler copyTM4Handler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            eventBus.fireEvent(new TransMemoryShortcutCopyEvent(3));\n         }\n      };\n\n      // Register shortcut CTRL+ALT+1 to copy result from TM result 1\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_1, ShortcutContext.Edit, messages.copyFromTM(1), copyTM1Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_1_NUM, ShortcutContext.Edit, KeyShortcut.DO_NOT_DISPLAY_DESCRIPTION, copyTM1Handler));\n\n      // Register shortcut CTRL+ALT+2 to copy result from TM result 2\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_2, ShortcutContext.Edit, messages.copyFromTM(2), copyTM2Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_2_NUM, ShortcutContext.Edit, KeyShortcut.DO_NOT_DISPLAY_DESCRIPTION, copyTM2Handler));\n\n      // Register shortcut CTRL+ALT+3 to copy result from TM result 3\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_3, ShortcutContext.Edit, messages.copyFromTM(3), copyTM3Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_3_NUM, ShortcutContext.Edit, KeyShortcut.DO_NOT_DISPLAY_DESCRIPTION, copyTM3Handler));\n\n      // Register shortcut CTRL+ALT+4 to copy result from TM result 4\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_4, ShortcutContext.Edit, messages.copyFromTM(4), copyTM4Handler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.KEY_4_NUM, ShortcutContext.Edit, KeyShortcut.DO_NOT_DISPLAY_DESCRIPTION, copyTM4Handler));\n\n      KeyShortcutEventHandler moveNextKeyHandler = new KeyShortcutEventHandler()\n      {\n\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            moveNext(false);\n         }\n      };\n\n      KeyShortcutEventHandler movePreviousKeyHandler = new KeyShortcutEventHandler()\n      {\n\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            movePrevious(false);\n         }\n      };\n\n      // Register shortcut ALT+(Down/K) to move next row and open editor\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_DOWN, ShortcutContext.Edit, messages.moveToNextRow(), moveNextKeyHandler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_K, ShortcutContext.Edit, messages.moveToNextRow(), moveNextKeyHandler));\n\n      // Register shortcut ALT+(Up/J) to move previous row and open editor\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_UP, ShortcutContext.Edit, messages.moveToPreviousRow(), movePreviousKeyHandler));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_J, ShortcutContext.Edit, messages.moveToPreviousRow(), movePreviousKeyHandler));\n\n      // Register shortcut ALT+(PageDown) to move next state entry - if modal\n      // navigation is enabled\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_PAGEDOWN, ShortcutContext.Edit, messages.moveToNextStateRow(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (isModalNavEnabled)\n            {\n               moveToNextState(NavTransUnitEvent.NavigationType.NextEntry);\n            }\n         }\n      }));\n\n      // Register shortcut ALT+(PageUp) to move previous state entry - if modal\n      // navigation is enabled\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_PAGEUP, ShortcutContext.Edit, messages.moveToPreviousStateRow(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (isModalNavEnabled)\n            {\n               moveToNextState(NavTransUnitEvent.NavigationType.PrevEntry);\n            }\n         }\n      }));\n\n      // Register shortcut CTRL+S to save as fuzzy\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_KEY, KeyShortcut.KEY_S, ShortcutContext.Edit, messages.saveAsFuzzy(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            saveAsFuzzy();\n         }\n      }, KeyShortcut.KEY_DOWN_EVENT, true, true));\n\n      KeyShortcutEventHandler saveAsApprovedKeyShortcutHandler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            saveAsApprovedAndMoveNext();\n         }\n      };\n\n      ctrlEnterSavesApprovedShortcut = new KeyShortcut(KeyShortcut.CTRL_KEY, KeyCodes.KEY_ENTER,\n            ShortcutContext.Edit, messages.saveAsApproved(), saveAsApprovedKeyShortcutHandler,\n            KeyShortcut.KEY_DOWN_EVENT, true, true);\n\n      enterSavesApprovedShortcut = new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ENTER,\n            ShortcutContext.Edit, messages.saveAsApproved(), saveAsApprovedKeyShortcutHandler,\n            KeyShortcut.KEY_DOWN_EVENT, true, true);\n\n      enterTriggersAutoSizeShortcut = new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ENTER,\n            ShortcutContext.Edit, KeyShortcut.DO_NOT_DISPLAY_DESCRIPTION, new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            getCurrentEditor().autoSizePlusOne();\n         }\n      }, KeyShortcut.KEY_DOWN_EVENT, false, false);\n\n      if (configHolder.isEnterSavesApproved())\n      {\n         enterSavesApprovedRegistered = true;\n         enterSavesApprovedHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(enterSavesApprovedShortcut);\n      }\n      else\n      {\n         enterSavesApprovedRegistered = false;\n         ctrlEnterSavesApprovedHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(ctrlEnterSavesApprovedShortcut);\n         enterTriggersAutoSizeHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(enterTriggersAutoSizeShortcut);\n      }\n\n      // Register user typing keys to (anything not CTRL or ALT or ESC or ENTER) resize textarea\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.CTRL_ALT_KEYS, KeyShortcut.ESC_ENTER_KEYS, ShortcutContext.Edit, KeyShortcut.DO_NOT_DISPLAY_DESCRIPTION, new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            getCurrentEditor().autoSize();\n         }\n      }, KeyShortcut.KEY_DOWN_EVENT, false, false, true));\n\n      escClosesEditorShortcut = new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ESCAPE,\n            ShortcutContext.Edit, messages.closeEditor(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (configHolder.isEscClosesEditor() && !keyShortcutPresenter.getDisplay().isShowing())\n            {\n               onCancel();\n            }\n         }\n      });\n\n      if (configHolder.isEscClosesEditor()) {\n         escClosesEditorRegistered = true;\n         escClosesEditorHandlerRegistration = keyShortcutPresenter.registerKeyShortcut(escClosesEditorShortcut);\n      }\n      else\n      {\n         escClosesEditorRegistered = false;\n      }\n\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_G, ShortcutContext.Edit, \"Copy from source\", new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (getCurrentEditor().isFocused())\n            {\n               copySource(getCurrentEditor());\n            }\n         }\n      }));\n\n   }","commit_id":"4aa34395f122392df66ce826cb55065b78ecdb20","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      bindSouthPanelPresenters();\n      translationEditorPresenter.bind();\n      optionsPanelPresenter.bind();\n\n      registerHandler(eventBus.addHandler(ExitWorkspaceEvent.getType(), new ExitWorkspaceEventHandler()\n      {\n         @Override\n         public void onExitWorkspace(ExitWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.removeTranslator(event.getEditorClientId(), event.getPerson());\n            targetContentsPresenter.updateTranslators();\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(EnterWorkspaceEvent.getType(), new EnterWorkspaceEventHandler()\n      {\n         @Override\n         public void onEnterWorkspace(EnterWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.addTranslator(event.getEditorClientId(), event.getPerson(), null);\n            workspaceUsersPresenter.dispatchChatAction(null, messages.hasJoinedWorkspace(event.getPerson().getId().toString()), MESSAGE_TYPE.SYSTEM_MSG);\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      // We won't receive the EnterWorkspaceEvent generated by our own login,\n      // because this presenter is not bound until we get the callback from\n      // EventProcessor.\n      // Thus we load the translator list here.\n      loadTranslatorList();\n\n      registerHandler(eventBus.addHandler(PublishWorkspaceChatEvent.getType(), new PublishWorkspaceChatEventHandler()\n      {\n         @Override\n         public void onPublishWorkspaceChat(PublishWorkspaceChatEvent event)\n         {\n            if (!display.isUserPanelOpen())\n            {\n               display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()) + \" *\");\n               display.startAlert(800);\n            }\n         }\n      }));\n\n      registerHandler(display.getSouthTabPanel().addSelectionHandler(new SelectionHandler<Integer>()\n      {\n\n         @Override\n         public void onSelection(SelectionEvent<Integer> event)\n         {\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n            display.cancelAlert();\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            setSouthPanelReadOnly(event.isReadOnly());\n         }\n      }));\n\n      if (workspaceContext.isReadOnly())\n      {\n         setSouthPanelReadOnly(true);\n      }\n\n      registerHandler(display.getOptionsToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowOptions = event.getValue();\n            if (shouldShowOptions)\n            {\n               display.setSidePanelVisible(true);\n               display.setOptionsToggleTooltip(messages.hideEditorOptions());\n            }\n            else\n            {\n               display.setSidePanelVisible(false);\n               display.setOptionsToggleTooltip(messages.showEditorOptions());\n            }\n         }\n      }));\n\n      registerHandler(display.getSouthPanelToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowSouthPanel = event.getValue();\n            setSouthPanelExpanded(shouldShowSouthPanel);\n         }\n      }));\n\n      KeyShortcutEventHandler gotoPreRowHandler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            translationEditorPresenter.gotoPrevRow(false);\n         }\n      };\n\n      KeyShortcutEventHandler gotoNextRowHandler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            translationEditorPresenter.gotoNextRow(false);\n         }\n      };\n\n      // Register shortcut ALT+(UP/J) for previous row navigation\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_UP, ShortcutContext.Navigation, messages.navigateToNextRow(), gotoPreRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true, true));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_J, ShortcutContext.Navigation, messages.navigateToNextRow(), gotoPreRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true, true));\n\n      // Register shortcut ALT+(Down/K) for next row navigation\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_DOWN, ShortcutContext.Navigation, messages.navigateToPreviousRow(), gotoNextRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true, true));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_K, ShortcutContext.Navigation, messages.navigateToPreviousRow(), gotoNextRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true, true));\n\n      // Register shortcut Enter to open editor in selected row - if no other input field is in focus\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ENTER, ShortcutContext.Navigation, messages.openEditorInSelectedRow(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (!isOtherInputFieldFocused())\n            {\n               translationEditorPresenter.openEditorOnSelectedRow();\n            }\n         }\n      }, KeyShortcut.KEY_UP_EVENT, true, true, true));\n   }","id":98845,"modified_method":"@Override\n   protected void onBind()\n   {\n      bindSouthPanelPresenters();\n      translationEditorPresenter.bind();\n      optionsPanelPresenter.bind();\n\n      registerHandler(eventBus.addHandler(ExitWorkspaceEvent.getType(), new ExitWorkspaceEventHandler()\n      {\n         @Override\n         public void onExitWorkspace(ExitWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.removeTranslator(event.getEditorClientId(), event.getPerson());\n            targetContentsPresenter.updateTranslators();\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(EnterWorkspaceEvent.getType(), new EnterWorkspaceEventHandler()\n      {\n         @Override\n         public void onEnterWorkspace(EnterWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.addTranslator(event.getEditorClientId(), event.getPerson(), null);\n            workspaceUsersPresenter.dispatchChatAction(null, messages.hasJoinedWorkspace(event.getPerson().getId().toString()), MESSAGE_TYPE.SYSTEM_MSG);\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      // We won't receive the EnterWorkspaceEvent generated by our own login,\n      // because this presenter is not bound until we get the callback from\n      // EventProcessor.\n      // Thus we load the translator list here.\n      loadTranslatorList();\n\n      registerHandler(eventBus.addHandler(PublishWorkspaceChatEvent.getType(), new PublishWorkspaceChatEventHandler()\n      {\n         @Override\n         public void onPublishWorkspaceChat(PublishWorkspaceChatEvent event)\n         {\n            if (!display.isUserPanelOpen())\n            {\n               display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()) + \" *\");\n               display.startAlert(800);\n            }\n         }\n      }));\n\n      registerHandler(display.getSouthTabPanel().addSelectionHandler(new SelectionHandler<Integer>()\n      {\n\n         @Override\n         public void onSelection(SelectionEvent<Integer> event)\n         {\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n            display.cancelAlert();\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            setSouthPanelReadOnly(event.isReadOnly());\n         }\n      }));\n\n      if (workspaceContext.isReadOnly())\n      {\n         setSouthPanelReadOnly(true);\n      }\n\n      registerHandler(display.getOptionsToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowOptions = event.getValue();\n            if (shouldShowOptions)\n            {\n               display.setSidePanelVisible(true);\n               display.setOptionsToggleTooltip(messages.hideEditorOptions());\n            }\n            else\n            {\n               display.setSidePanelVisible(false);\n               display.setOptionsToggleTooltip(messages.showEditorOptions());\n            }\n         }\n      }));\n\n      registerHandler(display.getSouthPanelToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowSouthPanel = event.getValue();\n            setSouthPanelExpanded(shouldShowSouthPanel);\n         }\n      }));\n\n      KeyShortcutEventHandler gotoPreRowHandler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            translationEditorPresenter.gotoPrevRow(false);\n         }\n      };\n\n      KeyShortcutEventHandler gotoNextRowHandler = new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            translationEditorPresenter.gotoNextRow(false);\n         }\n      };\n\n      // Register shortcut ALT+(UP/J) for previous row navigation\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_UP, ShortcutContext.Navigation, messages.navigateToNextRow(), gotoPreRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_J, ShortcutContext.Navigation, messages.navigateToNextRow(), gotoPreRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true));\n\n      // Register shortcut ALT+(Down/K) for next row navigation\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyCodes.KEY_DOWN, ShortcutContext.Navigation, messages.navigateToPreviousRow(), gotoNextRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true));\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.ALT_KEY, KeyShortcut.KEY_K, ShortcutContext.Navigation, messages.navigateToPreviousRow(), gotoNextRowHandler, KeyShortcut.KEY_DOWN_EVENT, true, true));\n\n      // Register shortcut Enter to open editor in selected row - if no other input field is in focus\n      keyShortcutPresenter.registerKeyShortcut(new KeyShortcut(KeyShortcut.NO_MODIFIER, KeyCodes.KEY_ENTER, ShortcutContext.Navigation, messages.openEditorInSelectedRow(), new KeyShortcutEventHandler()\n      {\n         @Override\n         public void onKeyShortcut(KeyShortcutEvent event)\n         {\n            if (!isOtherInputFieldFocused())\n            {\n               translationEditorPresenter.openEditorOnSelectedRow();\n            }\n         }\n      }, KeyShortcut.KEY_UP_EVENT, true, true));\n   }","commit_id":"4aa34395f122392df66ce826cb55065b78ecdb20","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static StatefulKnowledgeSessionImpl readSession(MarshallerReaderContext context,\n                                                    int id,\n                                                    Environment environment,\n                                                    SessionConfiguration config) throws IOException,\n                                                                                ClassNotFoundException {\n\n        ProtobufMessages.KnowledgeSession _session = loadAndParseSession( context );\n\n        StatefulKnowledgeSessionImpl session = createAndInitializeSession( context,\n                                                                    id,\n                                                                    environment,\n                                                                    config,\n                                                                    _session );\n\n        return readSession( _session,\n                            session,\n                            (InternalAgenda) session.getAgenda(),\n                            context );\n    }","id":98846,"modified_method":"public static StatefulKnowledgeSessionImpl readSession(MarshallerReaderContext context,\n                                                           int id,\n                                                           Environment environment,\n                                                           SessionConfiguration config) throws IOException, ClassNotFoundException {\n        return readSession( context, id, environment, config, null );\n    }","commit_id":"4f5589824adf02ba41af4164cc85fd20e51ebccc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Create a new session into which to read the stream data\n     */\n    public static StatefulKnowledgeSessionImpl readSession(MarshallerReaderContext context,\n                                                    int id) throws IOException,\n                                                           ClassNotFoundException {\n        StatefulKnowledgeSessionImpl session = readSession( context,\n                                                     id,\n                                                     EnvironmentFactory.newEnvironment(),\n                                                     SessionConfiguration.getDefaultInstance() );\n        return session;\n    }","id":98847,"modified_method":"/**\n     * Create a new session into which to read the stream data\n     */\n    public static StatefulKnowledgeSessionImpl readSession(MarshallerReaderContext context,\n                                                           int id) throws IOException, ClassNotFoundException {\n        return readSession( context,\n                            id,\n                            EnvironmentFactory.newEnvironment(),\n                            SessionConfiguration.getDefaultInstance() );\n    }","commit_id":"4f5589824adf02ba41af4164cc85fd20e51ebccc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public StatefulKnowledgeSession unmarshall(final InputStream stream,\n                                               KieSessionConfiguration config,\n                                               Environment environment) throws IOException,\n                                                                       ClassNotFoundException {\n        if ( config == null ) {\n            config = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();\n        }\n\n        if ( environment == null ) {\n            environment = KnowledgeBaseFactory.newEnvironment();\n        }\n\n        MarshallerReaderContext context = new MarshallerReaderContext( stream,\n                                                                       (KnowledgeBaseImpl) kbase,\n                                                                       RuleBaseNodes.getNodeMap( (KnowledgeBaseImpl) kbase ),\n                                                                       this.strategyStore,\n                                                                       TIMER_READERS,\n                                                                       this.marshallingConfig.isMarshallProcessInstances(),\n                                                                       this.marshallingConfig.isMarshallWorkItems(),\n                                                                       environment );\n\n        int id = ((KnowledgeBaseImpl) this.kbase).nextWorkingMemoryCounter();\n        RuleBaseConfiguration conf = ((KnowledgeBaseImpl) this.kbase).getConfiguration();\n\n        StatefulKnowledgeSessionImpl session = ProtobufInputMarshaller.readSession( context,\n                                                                             id,\n                                                                             environment,\n                                                                             (SessionConfiguration) config );\n        context.close();\n        if ( ((SessionConfiguration) config).isKeepReference() ) {\n            ((KnowledgeBaseImpl) this.kbase).addStatefulSession(session);\n        }\n        return session;\n\n    }","id":98848,"modified_method":"public StatefulKnowledgeSession unmarshall(final InputStream stream,\n                                               KieSessionConfiguration config,\n                                               Environment environment) throws IOException,\n                                                                       ClassNotFoundException {\n        if ( config == null ) {\n            config = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();\n        }\n\n        if ( environment == null ) {\n            environment = KnowledgeBaseFactory.newEnvironment();\n        }\n\n        MarshallerReaderContext context = new MarshallerReaderContext( stream,\n                                                                       (KnowledgeBaseImpl) kbase,\n                                                                       RuleBaseNodes.getNodeMap( (KnowledgeBaseImpl) kbase ),\n                                                                       this.strategyStore,\n                                                                       TIMER_READERS,\n                                                                       this.marshallingConfig.isMarshallProcessInstances(),\n                                                                       this.marshallingConfig.isMarshallWorkItems(),\n                                                                       environment );\n\n        int id = ((KnowledgeBaseImpl) this.kbase).nextWorkingMemoryCounter();\n        RuleBaseConfiguration conf = ((KnowledgeBaseImpl) this.kbase).getConfiguration();\n\n        StatefulKnowledgeSessionImpl session = ProtobufInputMarshaller.readSession( context,\n                                                                                    id,\n                                                                                    environment,\n                                                                                    (SessionConfiguration) config,\n                                                                                    initializer );\n        context.close();\n        if ( ((SessionConfiguration) config).isKeepReference() ) {\n            ((KnowledgeBaseImpl) this.kbase).addStatefulSession(session);\n        }\n        return session;\n\n    }","commit_id":"4f5589824adf02ba41af4164cc85fd20e51ebccc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Exist Info, so load session from here\n     */\n    public SessionMarshallingHelper( KieBase kbase,\n                                     KieSessionConfiguration conf,\n                                     Environment env) {\n        this.kbase = kbase;\n        this.conf = conf;\n        this.env = env;\n        ObjectMarshallingStrategy[] strategies = (ObjectMarshallingStrategy[]) env.get( EnvironmentName.OBJECT_MARSHALLING_STRATEGIES );\n        if (strategies  != null ) {\n            // use strategies if provided in the environment\n            this.marshaller = MarshallerFactory.newMarshaller( kbase, strategies );\n        } else {\n            this.marshaller = MarshallerFactory.newMarshaller( kbase ) ;\n        }\n    }","id":98849,"modified_method":"/**\n     * Exist Info, so load session from here\n     */\n    public SessionMarshallingHelper( KieBase kbase,\n                                     KieSessionConfiguration conf,\n                                     Environment env) {\n        this.kbase = kbase;\n        this.conf = conf;\n        this.env = env;\n        ObjectMarshallingStrategy[] strategies = (ObjectMarshallingStrategy[]) env.get( EnvironmentName.OBJECT_MARSHALLING_STRATEGIES );\n\n        // use strategies if provided in the environment\n        this.marshaller = strategies != null ?\n                          (InternalMarshaller) MarshallerFactory.newMarshaller( kbase, strategies ) :\n                          (InternalMarshaller) MarshallerFactory.newMarshaller( kbase ) ;\n    }","commit_id":"4f5589824adf02ba41af4164cc85fd20e51ebccc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/** \n     * new session, don't write now as info will request it on update callback\n     */\n    public SessionMarshallingHelper( KieSession ksession,\n                                     KieSessionConfiguration conf) {\n        this.ksession = ksession;\n        this.kbase = ksession.getKieBase();\n        this.conf = conf;\n        this.env = ksession.getEnvironment();\n        ObjectMarshallingStrategy[] strategies = (ObjectMarshallingStrategy[]) this.env.get( EnvironmentName.OBJECT_MARSHALLING_STRATEGIES );\n        if (strategies  != null ) {\n            // use strategies if provided in the environment\n            this.marshaller = MarshallerFactory.newMarshaller( kbase, strategies );\n        } else {\n            this.marshaller = MarshallerFactory.newMarshaller( kbase ) ;\n        }\n        \n    }","id":98850,"modified_method":"/** \n     * new session, don't write now as info will request it on update callback\n     */\n    public SessionMarshallingHelper( KieSession ksession,\n                                     KieSessionConfiguration conf) {\n        this.ksession = ksession;\n        this.kbase = ksession.getKieBase();\n        this.conf = conf;\n        this.env = ksession.getEnvironment();\n        ObjectMarshallingStrategy[] strategies = (ObjectMarshallingStrategy[]) this.env.get( EnvironmentName.OBJECT_MARSHALLING_STRATEGIES );\n\n        // use strategies if provided in the environment\n        this.marshaller = strategies != null ?\n                          (InternalMarshaller) MarshallerFactory.newMarshaller( kbase, strategies ) :\n                          (InternalMarshaller) MarshallerFactory.newMarshaller( kbase ) ;\n    }","commit_id":"4f5589824adf02ba41af4164cc85fd20e51ebccc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public KieSession loadSnapshot(byte[] bytes,\n                                   KieSession ksession) {\n        this.ksession = ksession;\n        ByteArrayInputStream bais = new ByteArrayInputStream( bytes );\n        try {\n            if ( this.ksession != null ) {\n                this.marshaller.unmarshall( bais,\n                                            this.ksession );\n            } else {\n                this.ksession = this.marshaller.unmarshall( bais,\n                                                            this.conf,\n                                                            this.env );\n            }\n        } catch ( Exception e ) {\n            throw new RuntimeException( \"Unable to load session snapshot\",\n                                        e );\n        }\n        return this.ksession;\n    }","id":98851,"modified_method":"public KieSession loadSnapshot( byte[] bytes,\n                                    KieSession ksession,\n                                    KieSessionInitializer initializer ) {\n        this.ksession = ksession;\n        ByteArrayInputStream bais = new ByteArrayInputStream( bytes );\n        try {\n            this.marshaller.setInitializer( initializer );\n            if ( this.ksession != null ) {\n                this.marshaller.unmarshall( bais,\n                                            this.ksession );\n            } else {\n                this.ksession = this.marshaller.unmarshall( bais,\n                                                            this.conf,\n                                                            this.env );\n            }\n        } catch ( Exception e ) {\n            throw new RuntimeException( \"Unable to load session snapshot\",\n                                        e );\n        } finally {\n            this.marshaller.setInitializer( null );\n        }\n        return this.ksession;\n    }","commit_id":"4f5589824adf02ba41af4164cc85fd20e51ebccc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void initExistingKnowledgeSession(Long sessionId,\n                                KieBase kbase,\n                                KieSessionConfiguration conf,\n                                PersistenceContext persistenceContext) {\n\n        if ( !doRollback && this.ksession != null ) {\n            return;\n            // nothing to initialise\n        }\n\n        this.doRollback = false;\n        try {\n            // if locking is active, this will also lock the (found) SessionInfo instance\n            this.sessionInfo = persistenceContext.findSessionInfo( sessionId );\n        } catch ( Exception e ) {\n            throw new SessionNotFoundException( \"Could not find session data for id \" + sessionId,\n                                        e );\n        }\n        if ( sessionInfo == null ) {\n            throw new SessionNotFoundException( \"Could not find session data for id \" + sessionId );\n        }\n\n        if ( this.marshallingHelper == null ) {\n            // this should only happen when this class is first constructed\n            this.marshallingHelper = new SessionMarshallingHelper( kbase,\n                                                                   conf,\n                                                                   env );\n            MarshallingConfigurationImpl config = (MarshallingConfigurationImpl)\n                    this.marshallingHelper.getMarshaller().getMarshallingConfiguration();\n            config.setMarshallProcessInstances( false );\n            config.setMarshallWorkItems( false );\n        }\n\n        this.sessionInfo.setJPASessionMashallingHelper(this.marshallingHelper);\n\n        // if this.ksession is null, it'll create a new one, else it'll use the existing one\n        this.ksession = this.marshallingHelper.loadSnapshot( this.sessionInfo.getData(), this.ksession );\n\n        InternalKnowledgeRuntime kruntime = ((InternalKnowledgeRuntime) ksession);\n\n        // The CommandService for the TimerJobFactoryManager must be set before any timer jobs are scheduled.\n        // Otherwise, if overdue jobs are scheduled (and then run before the .commandService field can be set),\n        //  they will retrieve a null commandService (instead of a reference to this) and fail.\n        TimerJobFactoryManager timerJobFactoryManager = ((InternalKnowledgeRuntime) ksession ).getTimerService().getTimerJobFactoryManager();\n        if (timerJobFactoryManager instanceof CommandServiceTimerJobFactoryManager) {\n            ( (CommandServiceTimerJobFactoryManager) timerJobFactoryManager ).setCommandService( this );\n        }\n\n        // update the session id to be the same as the session info id\n        kruntime.setId( this.sessionInfo.getId() );\n\n        kruntime.setEndOperationListener( new EndOperationListenerImpl( this.txm, this.sessionInfo ) );\n\n        if ( this.kContext == null ) {\n            // this should only happen when this class is first constructed\n            this.kContext = new FixedKnowledgeCommandContext( new ContextImpl( \"ksession\", null),\n                                                              null,\n                                                              null,\n                                                              this.ksession,\n                                                              null );\n        }\n\n        this.commandService = new TransactionInterceptor(kContext);\n        // apply interceptors\n        Iterator<Interceptor> iterator = this.interceptors.descendingIterator();\n        while (iterator.hasNext()) {\n            addInterceptor(iterator.next(), false);\n        }\n\n    }","id":98852,"modified_method":"protected void initExistingKnowledgeSession(Long sessionId,\n                                KieBase kbase,\n                                KieSessionConfiguration conf,\n                                PersistenceContext persistenceContext) {\n\n        if ( !doRollback && this.ksession != null ) {\n            return;\n            // nothing to initialise\n        }\n\n        this.doRollback = false;\n        try {\n            // if locking is active, this will also lock the (found) SessionInfo instance\n            this.sessionInfo = persistenceContext.findSessionInfo( sessionId );\n        } catch ( Exception e ) {\n            throw new SessionNotFoundException( \"Could not find session data for id \" + sessionId,\n                                        e );\n        }\n        if ( sessionInfo == null ) {\n            throw new SessionNotFoundException( \"Could not find session data for id \" + sessionId );\n        }\n\n        if ( this.marshallingHelper == null ) {\n            // this should only happen when this class is first constructed\n            this.marshallingHelper = new SessionMarshallingHelper( kbase,\n                                                                   conf,\n                                                                   env );\n            MarshallingConfigurationImpl config = (MarshallingConfigurationImpl)\n                    this.marshallingHelper.getMarshaller().getMarshallingConfiguration();\n            config.setMarshallProcessInstances( false );\n            config.setMarshallWorkItems( false );\n        }\n\n        this.sessionInfo.setJPASessionMashallingHelper(this.marshallingHelper);\n\n        // if this.ksession is null, it'll create a new one, else it'll use the existing one\n        this.ksession = this.marshallingHelper.loadSnapshot( this.sessionInfo.getData(), this.ksession, new JpaSessionInitializer(this) );\n\n        // update the session id to be the same as the session info id\n        InternalKnowledgeRuntime kruntime = ((InternalKnowledgeRuntime) ksession);\n        kruntime.setId( this.sessionInfo.getId() );\n        kruntime.setEndOperationListener( new EndOperationListenerImpl( this.txm, this.sessionInfo ) );\n\n        if ( this.kContext == null ) {\n            // this should only happen when this class is first constructed\n            this.kContext = new FixedKnowledgeCommandContext( new ContextImpl( \"ksession\", null),\n                                                              null,\n                                                              null,\n                                                              this.ksession,\n                                                              null );\n        }\n\n        this.commandService = new TransactionInterceptor(kContext);\n        // apply interceptors\n        Iterator<Interceptor> iterator = this.interceptors.descendingIterator();\n        while (iterator.hasNext()) {\n            addInterceptor(iterator.next(), false);\n        }\n\n    }","commit_id":"4f5589824adf02ba41af4164cc85fd20e51ebccc","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void createSQLiteDatabase(File dirWithTiles, String regionName, String tileSource) throws SQLException, IOException {\r\n\t\tlong now = System.currentTimeMillis();\r\n\t\ttry {\r\n\t\t\tClass.forName(\"org.sqlite.JDBC\"); //$NON-NLS-1$\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\tlog.error(\"Illegal configuration\", e); //$NON-NLS-1$\r\n\t\t\tthrow new IllegalStateException(e);\r\n\t\t}\r\n\t\tFile fileToWrite = new File(dirWithTiles, regionName + \".\" + tileSource + \".sqlitedb\");\r\n\t\tfileToWrite.delete();\r\n\t\tConnection conn = DriverManager.getConnection(\"jdbc:sqlite:\" + fileToWrite.getAbsolutePath()); //$NON-NLS-1$\r\n\t\tStatement statement = conn.createStatement();\r\n\t\tstatement.execute(\"CREATE TABLE tiles (x int, y int, z int, s int, image blob, PRIMARY KEY (x,y,z,s))\");\r\n\t\tstatement.execute(\"CREATE INDEX IND on tiles (x,y,z,s)\");\r\n\t\tstatement.execute(\"CREATE TABLE info(minzoom,maxzoom)\");\r\n\t\tstatement.execute(\"CREATE TABLE android_metadata (locale TEXT)\");\r\n\t\tstatement.close();\r\n\r\n\t\tconn.setAutoCommit(false);\r\n\t\t\r\n\t\tPreparedStatement pStatement = conn.prepareStatement(\"INSERT INTO tiles VALUES (?, ?, ?, ?, ?)\");\r\n\t\tint ch = 0;\r\n\t\tint bufSize = 32 * 1024;\r\n\t\tbyte[] buf = new byte[bufSize];\r\n\t\tint maxZoom = 17;\r\n\t\tint minZoom = 1;\r\n\t\t\r\n\t\tFile rootDir = new File(dirWithTiles, tileSource);\r\n\t\tfor(File z : rootDir.listFiles()){\r\n\t\t\ttry {\r\n\t\t\t\tint zoom = Integer.parseInt(z.getName());\r\n\t\t\t\tfor(File xDir : z.listFiles()){\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tint x = Integer.parseInt(xDir.getName());\r\n\t\t\t\t\t\tfor(File f : xDir.listFiles()){\r\n\t\t\t\t\t\t\tif(!f.isFile()){\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tint i = f.getName().indexOf('.');\r\n\t\t\t\t\t\t\t\tint y = Integer.parseInt(f.getName().substring(0, i));\r\n\t\t\t\t\t\t\t\tbuf = new byte[(int) f.length()]; \r\n\t\t\t\t\t\t\t\tif(zoom > maxZoom){\r\n\t\t\t\t\t\t\t\t\tmaxZoom = zoom;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(zoom < minZoom){\r\n\t\t\t\t\t\t\t\t\tminZoom = zoom;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tFileInputStream is = new FileInputStream(f);\r\n\t\t\t\t\t\t\t\tint l = is.read(buf);\r\n\t\t\t\t\t\t\t\tif (l > 0) {\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(1, x);\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(2, y);\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(3, zoom);\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(4, 0);\r\n\t\t\t\t\t\t\t\t\tpStatement.setBytes(5, buf);\r\n\t\t\t\t\t\t\t\t\tpStatement.addBatch();\r\n\t\t\t\t\t\t\t\t\tch++;\r\n\t\t\t\t\t\t\t\t\tif (ch >= BATCH_SIZE) {\r\n\t\t\t\t\t\t\t\t\t\tpStatement.executeBatch();\r\n\t\t\t\t\t\t\t\t\t\tch = 0;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif (ch > 0) {\r\n\t\t\tpStatement.executeBatch();\r\n\t\t\tch = 0;\r\n\t\t}\r\n\t\t\r\n\t\tpStatement.close();\r\n\t\tconn.commit();\r\n\t\tconn.close();\r\n\t\tlog.info(\"Index created \" + fileToWrite.getName() + \" \" + (System.currentTimeMillis() - now) + \" ms\");\r\n\t}","id":98853,"modified_method":"public static void createSQLiteDatabase(File dirWithTiles, String regionName, String tileSource) throws SQLException, IOException {\r\n\t\tlong now = System.currentTimeMillis();\r\n\t\ttry {\r\n\t\t\tClass.forName(\"org.sqlite.JDBC\"); //$NON-NLS-1$\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\tlog.error(\"Illegal configuration\", e); //$NON-NLS-1$\r\n\t\t\tthrow new IllegalStateException(e);\r\n\t\t}\r\n\t\tFile fileToWrite = new File(dirWithTiles, regionName + \".\" + tileSource + \".sqlitedb\");\r\n\t\tfileToWrite.delete();\r\n\t\tConnection conn = DriverManager.getConnection(\"jdbc:sqlite:\" + fileToWrite.getAbsolutePath()); //$NON-NLS-1$\r\n\t\tStatement statement = conn.createStatement();\r\n\t\tstatement.execute(\"CREATE TABLE tiles (x int, y int, z int, s int, image blob, PRIMARY KEY (x,y,z,s))\");\r\n\t\tstatement.execute(\"CREATE INDEX IND on tiles (x,y,z,s)\");\r\n\t\tstatement.execute(\"CREATE TABLE info(minzoom,maxzoom)\");\r\n\t\tstatement.execute(\"CREATE TABLE android_metadata (locale TEXT)\");\r\n\t\tstatement.close();\r\n\r\n\t\tconn.setAutoCommit(false);\r\n\t\t\r\n\t\tPreparedStatement pStatement = conn.prepareStatement(\"INSERT INTO tiles VALUES (?, ?, ?, ?, ?)\");\r\n\t\tint ch = 0;\r\n\t\tint bufSize = 32 * 1024;\r\n\t\tbyte[] buf = new byte[bufSize];\r\n\t\tint maxZoom = 17;\r\n\t\tint minZoom = 1;\r\n\t\t\r\n\t\tFile rootDir = new File(dirWithTiles, tileSource);\r\n\t\tfor(File z : rootDir.listFiles()){\r\n\t\t\ttry {\r\n\t\t\t\tint zoom = Integer.parseInt(z.getName());\r\n\t\t\t\tfor(File xDir : z.listFiles()){\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tint x = Integer.parseInt(xDir.getName());\r\n\t\t\t\t\t\tfor(File f : xDir.listFiles()){\r\n\t\t\t\t\t\t\tif(!f.isFile()){\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tint i = f.getName().indexOf('.');\r\n\t\t\t\t\t\t\t\tint y = Integer.parseInt(f.getName().substring(0, i));\r\n\t\t\t\t\t\t\t\tbuf = new byte[(int) f.length()]; \r\n\t\t\t\t\t\t\t\tif(zoom > maxZoom){\r\n\t\t\t\t\t\t\t\t\tmaxZoom = zoom;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(zoom < minZoom){\r\n\t\t\t\t\t\t\t\t\tminZoom = zoom;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tFileInputStream is = new FileInputStream(f);\r\n\t\t\t\t\t\t\t\tint l = is.read(buf);\r\n\t\t\t\t\t\t\t\tif (l > 0) {\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(1, x);\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(2, y);\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(3, 17 - zoom);\r\n\t\t\t\t\t\t\t\t\tpStatement.setInt(4, 0);\r\n\t\t\t\t\t\t\t\t\tpStatement.setBytes(5, buf);\r\n\t\t\t\t\t\t\t\t\tpStatement.addBatch();\r\n\t\t\t\t\t\t\t\t\tch++;\r\n\t\t\t\t\t\t\t\t\tif (ch >= BATCH_SIZE) {\r\n\t\t\t\t\t\t\t\t\t\tpStatement.executeBatch();\r\n\t\t\t\t\t\t\t\t\t\tch = 0;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif (ch > 0) {\r\n\t\t\tpStatement.executeBatch();\r\n\t\t\tch = 0;\r\n\t\t}\r\n\t\t\r\n\t\tpStatement.close();\r\n\t\tconn.commit();\r\n\t\tconn.close();\r\n\t\tlog.info(\"Index created \" + fileToWrite.getName() + \" \" + (System.currentTimeMillis() - now) + \" ms\");\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void insertImage(int x, int y, int zoom, File fileToSave) throws IOException {\r\n\t\tif(exists(x, y, zoom)){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tByteBuffer buf = ByteBuffer.allocate((int) fileToSave.length());\r\n\t\tFileInputStream is = new FileInputStream(fileToSave);\r\n\t\tint i = 0;\r\n\t\tbyte[] b = new byte[BUF_SIZE];\r\n\t\twhile((i=is.read(b, 0, BUF_SIZE)) > - 1){\r\n\t\t\tbuf.put(b, 0, i);\r\n\t\t}\r\n\t\t\r\n\t\tSQLiteStatement statement = getDatabase().compileStatement(\"INSERT INTO tiles VALUES(?, ?, ?, ?, ?)\"); //$NON-NLS-1$\r\n\t\tstatement.bindLong(1, x);\r\n\t\tstatement.bindLong(2, y);\r\n\t\tstatement.bindLong(3, 17 - zoom);\r\n\t\tstatement.bindLong(4, 0);\r\n\t\tstatement.bindBlob(5, buf.array());\r\n\t\tstatement.execute();\r\n\t\tstatement.close();\r\n\t\t\r\n\t}","id":98854,"modified_method":"public void insertImage(int x, int y, int zoom, File fileToSave) throws IOException {\r\n\t\tSQLiteDatabase db = getDatabase();\r\n\t\tif(db == null || db.isReadOnly()){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(exists(x, y, zoom)){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tByteBuffer buf = ByteBuffer.allocate((int) fileToSave.length());\r\n\t\tFileInputStream is = new FileInputStream(fileToSave);\r\n\t\tint i = 0;\r\n\t\tbyte[] b = new byte[BUF_SIZE];\r\n\t\twhile((i=is.read(b, 0, BUF_SIZE)) > - 1){\r\n\t\t\tbuf.put(b, 0, i);\r\n\t\t}\r\n\t\t\r\n\t\tSQLiteStatement statement = db.compileStatement(\"INSERT INTO tiles VALUES(?, ?, ?, ?, ?)\"); //$NON-NLS-1$\r\n\t\tstatement.bindLong(1, x);\r\n\t\tstatement.bindLong(2, y);\r\n\t\tstatement.bindLong(3, 17 - zoom);\r\n\t\tstatement.bindLong(4, 0);\r\n\t\tstatement.bindBlob(5, buf.array());\r\n\t\tstatement.execute();\r\n\t\tstatement.close();\r\n\t\t\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public Bitmap getImage(int x, int y, int zoom) {\r\n\t\tCursor cursor = getDatabase().rawQuery(\"SELECT image FROM tiles WHERE x = ? AND y = ? AND z = ?\", new String[] {x+\"\", y+\"\",(17 - zoom)+\"\"});    //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$\r\n\t\tbyte[] blob = null;\r\n\t\tif(cursor.moveToFirst()) {\r\n\t\t\tblob = cursor.getBlob(0);\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\tif(blob != null){\r\n\t\t\treturn BitmapFactory.decodeByteArray(blob, 0, blob.length);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":98855,"modified_method":"public Bitmap getImage(int x, int y, int zoom) {\r\n\t\tSQLiteDatabase db = getDatabase();\r\n\t\tif(db == null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tCursor cursor = db.rawQuery(\"SELECT image FROM tiles WHERE x = ? AND y = ? AND z = ?\", new String[] {x+\"\", y+\"\",(17 - zoom)+\"\"});    //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$\r\n\t\tbyte[] blob = null;\r\n\t\tif(cursor.moveToFirst()) {\r\n\t\t\tblob = cursor.getBlob(0);\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\tif(blob != null){\r\n\t\t\treturn BitmapFactory.decodeByteArray(blob, 0, blob.length);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic boolean couldBeDownloadedFromInternet() {\r\n\t\tif(getDatabase().isReadOnly() || base == null){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn base.couldBeDownloadedFromInternet();\r\n\t}","id":98856,"modified_method":"@Override\r\n\tpublic boolean couldBeDownloadedFromInternet() {\r\n\t\tif(getDatabase() == null || getDatabase().isReadOnly() || base == null){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn base.couldBeDownloadedFromInternet();\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private SQLiteDatabase getDatabase(){\r\n\t\tif(db == null){\r\n\t\t\tdb = SQLiteDatabase.openDatabase(file.getAbsolutePath(), null, 0);\r\n\t\t}\r\n\t\treturn db;\r\n\t}","id":98857,"modified_method":"private SQLiteDatabase getDatabase(){\r\n\t\tif(db == null && file.exists()){\r\n\t\t\tdb = SQLiteDatabase.openDatabase(file.getAbsolutePath(), null, 0);\r\n\t\t}\r\n\t\treturn db;\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic String getUrlToLoad(int x, int y, int zoom) {\r\n\t\tif(getDatabase().isReadOnly()){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn base != null ? base.getUrlToLoad(x, y, zoom) : null;\r\n\t}","id":98858,"modified_method":"@Override\r\n\tpublic String getUrlToLoad(int x, int y, int zoom) {\r\n\t\tSQLiteDatabase db = getDatabase();\r\n\t\tif(db == null || db.isReadOnly()){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn base != null ? base.getUrlToLoad(x, y, zoom) : null;\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public boolean exists(int x, int y, int zoom) {\r\n\t\tCursor cursor = getDatabase().rawQuery(\"SELECT 1 FROM tiles WHERE x = ? AND y = ? AND z = ?\", new String[] {x+\"\", y+\"\",(17 - zoom)+\"\"});    //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$\r\n\t\tboolean e =  cursor.moveToFirst();\r\n\t\tcursor.close();\r\n\t\treturn e;\r\n\t}","id":98859,"modified_method":"public boolean exists(int x, int y, int zoom) {\r\n\t\tSQLiteDatabase db = getDatabase();\r\n\t\tif(db == null){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tCursor cursor = db.rawQuery(\"SELECT 1 FROM tiles WHERE x = ? AND y = ? AND z = ?\", new String[] {x+\"\", y+\"\",(17 - zoom)+\"\"});    //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$\r\n\t\tboolean e =  cursor.moveToFirst();\r\n\t\tcursor.close();\r\n\t\treturn e;\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void deleteImage(int x, int y, int zoom) {\r\n\t\tif(getDatabase().isReadOnly()){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tgetDatabase().execSQL(\"DELETE FROM tiles WHERE x = ? AND y = ? AND z = ?\", new String[] {x+\"\", y+\"\",(17 - zoom)+\"\"});    //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$\r\n\t}","id":98860,"modified_method":"public void deleteImage(int x, int y, int zoom) {\r\n\t\tSQLiteDatabase db = getDatabase();\r\n\t\tif(db == null || db.isReadOnly()){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tdb.execSQL(\"DELETE FROM tiles WHERE x = ? AND y = ? AND z = ?\", new String[] {x+\"\", y+\"\",(17 - zoom)+\"\"});    //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$\r\n\t}","commit_id":"1add62376269a74479f92f2bb4fec7e65addd593","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static String waitForPasswordOnAws(ComputeService computeService, final NodeMetadata node, long timeout, TimeUnit timeUnit) throws TimeoutException {\n        ComputeServiceContext computeServiceContext = computeService.getContext();\n        AWSEC2Client ec2Client = computeServiceContext.unwrap(AWSEC2ApiMetadata.CONTEXT_TOKEN).getApi();\n        final WindowsClient client = ec2Client.getWindowsServices();\n        final String region = node.getLocation().getParent().getId();\n      \n        // The Administrator password will take some time before it is ready - Amazon says sometimes 15 minutes.\n        // So we create a predicate that tests if the password is ready, and wrap it in a retryable predicate.\n        Predicate<String> passwordReady = new Predicate<String>() {\n            @Override public boolean apply(String s) {\n                if (Strings.isNullOrEmpty(s)) return false;\n                PasswordData data = client.getPasswordDataInRegion(region, s);\n                if (data == null) return false;\n                return !Strings.isNullOrEmpty(data.getPasswordData());\n            }\n        };\n        \n        LOG.info(\"Waiting for password, for \"+node.getProviderId()+\":\"+node.getId());\n        RetryablePredicate<String> passwordReadyRetryable = new RetryablePredicate<String>(passwordReady, timeUnit.toMillis(timeout), 10*1000, TimeUnit.MILLISECONDS);\n        boolean ready = passwordReadyRetryable.apply(node.getProviderId());\n        if (!ready) throw new TimeoutException(\"Password not available for \"+node+\" in region \"+region+\" after \"+timeout+\" \"+timeUnit.name());\n\n        // Now pull together Amazon's encrypted password blob, and the private key that jclouds generated\n        PasswordDataAndPrivateKey dataAndKey = new PasswordDataAndPrivateKey(\n                client.getPasswordDataInRegion(region, node.getProviderId()),\n                node.getCredentials().getPrivateKey());\n\n        // And apply it to the decryption function\n        WindowsLoginCredentialsFromEncryptedData f = computeServiceContext.getUtils().getInjector().getInstance(WindowsLoginCredentialsFromEncryptedData.class);\n        LoginCredentials credentials = f.apply(dataAndKey);\n\n        return credentials.getPassword();\n    }","id":98861,"modified_method":"public static String waitForPasswordOnAws(ComputeService computeService, final NodeMetadata node, long timeout, TimeUnit timeUnit) throws TimeoutException {\n        ComputeServiceContext computeServiceContext = computeService.getContext();\n        AWSEC2Client ec2Client = computeServiceContext.unwrap(AWSEC2ApiMetadata.CONTEXT_TOKEN).getApi();\n        final WindowsClient client = ec2Client.getWindowsServices();\n        final String region = node.getLocation().getParent().getId();\n      \n        // The Administrator password will take some time before it is ready - Amazon says sometimes 15 minutes.\n        // So we create a predicate that tests if the password is ready, and wrap it in a retryable predicate.\n        Predicate<String> passwordReady = new Predicate<String>() {\n            @Override public boolean apply(String s) {\n                if (Strings.isNullOrEmpty(s)) return false;\n                PasswordData data = client.getPasswordDataInRegion(region, s);\n                if (data == null) return false;\n                return !Strings.isNullOrEmpty(data.getPasswordData());\n            }\n        };\n        \n        LOG.info(\"Waiting for password, for \"+node.getProviderId()+\":\"+node.getId());\n        Predicate passwordReadyRetryable = Predicates2.retry(passwordReady, timeUnit.toMillis(timeout), 10*1000, TimeUnit.MILLISECONDS);\n        boolean ready = passwordReadyRetryable.apply(node.getProviderId());\n        if (!ready) throw new TimeoutException(\"Password not available for \"+node+\" in region \"+region+\" after \"+timeout+\" \"+timeUnit.name());\n\n        // Now pull together Amazon's encrypted password blob, and the private key that jclouds generated\n        PasswordDataAndPrivateKey dataAndKey = new PasswordDataAndPrivateKey(\n                client.getPasswordDataInRegion(region, node.getProviderId()),\n                node.getCredentials().getPrivateKey());\n\n        // And apply it to the decryption function\n        WindowsLoginCredentialsFromEncryptedData f = computeServiceContext.getUtils().getInjector().getInstance(WindowsLoginCredentialsFromEncryptedData.class);\n        LoginCredentials credentials = f.apply(dataAndKey);\n\n        return credentials.getPassword();\n    }","commit_id":"f8ccae8ad7c5437dc018b7947a0d8f8160ebd848","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void removeDefaultClusters() {\r\n    listener.onMessage(\"\\nWARN: Exported database does not support manual index separation.\"\r\n        + \" Manual index cluster will be dropped.\");\r\n\r\n    // In v4 new cluster for manual indexes has been implemented. To keep database consistent we should shift back\r\n    // all clusters and recreate cluster for manual indexes in the end.\r\n    database.dropCluster(OMetadata.CLUSTER_MANUAL_INDEX_NAME);\r\n\r\n    final OSchema schema = database.getMetadata().getSchema();\r\n    schema.dropClass(OUser.CLASS_NAME);\r\n    schema.dropClass(ORole.CLASS_NAME);\r\n    schema.dropClass(OSecurityShared.RESTRICTED_CLASSNAME);\r\n    schema.dropClass(OFunction.CLASS_NAME);\r\n    schema.dropClass(OMVRBTreeRIDProvider.PERSISTENT_CLASS_NAME);\r\n    schema.save();\r\n\r\n    database.dropCluster(OStorage.CLUSTER_DEFAULT_NAME);\r\n\r\n    database.getStorage().setDefaultClusterId(\r\n        database.addCluster(OStorage.CLUSTER_TYPE.PHYSICAL.toString(), OStorage.CLUSTER_DEFAULT_NAME, null, null));\r\n\r\n    // Starting from v4 schema has been moved to internal cluster.\r\n    // Create a stub at #2:0 to prevent cluster position shifting.\r\n    new ODocument().save(OStorage.CLUSTER_DEFAULT_NAME);\r\n\r\n    database.getMetadata().getSecurity().create();\r\n  }","id":98862,"modified_method":"protected void removeDefaultClusters() {\r\n    listener.onMessage(\"\\nWARN: Exported database does not support manual index separation.\"\r\n        + \" Manual index cluster will be dropped.\");\r\n\r\n    // In v4 new cluster for manual indexes has been implemented. To keep database consistent we should shift back\r\n    // all clusters and recreate cluster for manual indexes in the end.\r\n    database.dropCluster(OMetadata.CLUSTER_MANUAL_INDEX_NAME);\r\n\r\n    final OSchema schema = database.getMetadata().getSchema();\r\n    if (schema.existsClass(OUser.CLASS_NAME))\r\n      schema.dropClass(OUser.CLASS_NAME);\r\n    if (schema.existsClass(ORole.CLASS_NAME))\r\n      schema.dropClass(ORole.CLASS_NAME);\r\n    if (schema.existsClass(OSecurityShared.RESTRICTED_CLASSNAME))\r\n      schema.dropClass(OSecurityShared.RESTRICTED_CLASSNAME);\r\n    if (schema.existsClass(OFunction.CLASS_NAME))\r\n      schema.dropClass(OFunction.CLASS_NAME);\r\n    if (schema.existsClass(OMVRBTreeRIDProvider.PERSISTENT_CLASS_NAME))\r\n      schema.dropClass(OMVRBTreeRIDProvider.PERSISTENT_CLASS_NAME);\r\n    schema.save();\r\n\r\n    database.dropCluster(OStorage.CLUSTER_DEFAULT_NAME);\r\n\r\n    database.getStorage().setDefaultClusterId(\r\n        database.addCluster(OStorage.CLUSTER_TYPE.PHYSICAL.toString(), OStorage.CLUSTER_DEFAULT_NAME, null, null));\r\n\r\n    // Starting from v4 schema has been moved to internal cluster.\r\n    // Create a stub at #2:0 to prevent cluster position shifting.\r\n    new ODocument().save(OStorage.CLUSTER_DEFAULT_NAME);\r\n\r\n    database.getMetadata().getSecurity().create();\r\n  }","commit_id":"6b0dd10c5f230cc45c0202746ea7bf73a68b8d32","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * @return a list of {@link WorkerInfo} objects representing the workers in Alluxio\n   */\n  public List<WorkerInfo> getWorkerInfoList() {\n    List<WorkerInfo> workerInfoList = new ArrayList<>(mWorkers.size());\n    for (MasterWorkerInfo masterWorkerInfo : mWorkers) {\n      synchronized (masterWorkerInfo) {\n        workerInfoList.add(masterWorkerInfo.generateClientWorkerInfo());\n      }\n    }\n    return workerInfoList;\n  }","id":98863,"modified_method":"/**\n   * @return a list of {@link WorkerInfo} objects representing the workers in Alluxio\n   */\n  public List<WorkerInfo> getWorkerInfoList() {\n    List<WorkerInfo> workerInfoList = new ArrayList<>(mWorkers.size());\n    for (MasterWorkerInfo worker : mWorkers) {\n      synchronized (worker) {\n        workerInfoList.add(worker.generateClientWorkerInfo());\n      }\n    }\n    return workerInfoList;\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @param blockId the block id to get information for\n   * @return the {@link BlockInfo} for the given block id\n   * @throws BlockInfoException if the block info is not found\n   */\n  public BlockInfo getBlockInfo(long blockId) throws BlockInfoException {\n    MasterBlockInfo masterBlockInfo = mBlocks.get(blockId);\n    if (masterBlockInfo == null) {\n      throw new BlockInfoException(ExceptionMessage.BLOCK_META_NOT_FOUND, blockId);\n    }\n    synchronized (masterBlockInfo) {\n      return generateBlockInfo(masterBlockInfo);\n    }\n  }","id":98864,"modified_method":"/**\n   * @param blockId the block id to get information for\n   * @return the {@link BlockInfo} for the given block id\n   * @throws BlockInfoException if the block info is not found\n   */\n  public BlockInfo getBlockInfo(long blockId) throws BlockInfoException {\n    MasterBlockInfo block = mBlocks.get(blockId);\n    if (block == null) {\n      throw new BlockInfoException(ExceptionMessage.BLOCK_META_NOT_FOUND, blockId);\n    }\n    synchronized (block) {\n      return generateBlockInfo(block);\n    }\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Marks a block as committed, but without a worker location. This means the block is only in ufs.\n   *\n   * @param blockId the id of the block to commit\n   * @param length the length of the block\n   */\n  public void commitBlockInUFS(long blockId, long length) {\n    LOG.debug(\"Commit block in ufs. blockId: {}, length: {}\", blockId, length);\n    if (mBlocks.get(blockId) != null) {\n      // Block metadata already exists, so do not need to create a new one.\n      return;\n    }\n\n    // The block has not been committed previously, so add the metadata to commit the block.\n    MasterBlockInfo masterBlockInfo = new MasterBlockInfo(blockId, length);\n    long counter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    synchronized (masterBlockInfo) {\n      if (mBlocks.putIfAbsent(blockId, masterBlockInfo) == null) {\n        // Successfully added the new block metadata. Append a journal entry for the new metadata.\n        BlockInfoEntry blockInfo =\n            BlockInfoEntry.newBuilder().setBlockId(blockId).setLength(length).build();\n        counter = appendJournalEntry(JournalEntry.newBuilder().setBlockInfo(blockInfo).build());\n      }\n    }\n    if (counter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n      waitForJournalFlush(counter);\n    }\n  }","id":98865,"modified_method":"/**\n   * Marks a block as committed, but without a worker location. This means the block is only in ufs.\n   *\n   * @param blockId the id of the block to commit\n   * @param length the length of the block\n   */\n  public void commitBlockInUFS(long blockId, long length) {\n    LOG.debug(\"Commit block in ufs. blockId: {}, length: {}\", blockId, length);\n    if (mBlocks.get(blockId) != null) {\n      // Block metadata already exists, so do not need to create a new one.\n      return;\n    }\n\n    // The block has not been committed previously, so add the metadata to commit the block.\n    MasterBlockInfo block = new MasterBlockInfo(blockId, length);\n    long counter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    synchronized (block) {\n      if (mBlocks.putIfAbsent(blockId, block) == null) {\n        // Successfully added the new block metadata. Append a journal entry for the new metadata.\n        BlockInfoEntry blockInfo =\n            BlockInfoEntry.newBuilder().setBlockId(blockId).setLength(length).build();\n        counter = appendJournalEntry(JournalEntry.newBuilder().setBlockInfo(blockInfo).build());\n      }\n    }\n    waitForJournalFlush(counter);\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Updates metadata when a worker periodically heartbeats with the master.\n   *\n   * @param workerId the worker id\n   * @param usedBytesOnTiers a mapping from tier alias to the used bytes\n   * @param removedBlockIds a list of block ids removed from this worker\n   * @param addedBlocksOnTiers a mapping from tier alias to the added blocks\n   * @return an optional command for the worker to execute\n   */\n  public Command workerHeartbeat(long workerId, Map<String, Long> usedBytesOnTiers,\n      List<Long> removedBlockIds, Map<String, List<Long>> addedBlocksOnTiers) {\n    MasterWorkerInfo workerInfo = mWorkers.getFirstByField(mIdIndex, workerId);\n    if (workerInfo == null) {\n      LOG.warn(\"Could not find worker id: {} for heartbeat.\", workerId);\n      return new Command(CommandType.Register, new ArrayList<Long>());\n    }\n\n    synchronized (workerInfo) {\n      // Technically, workerInfo should be confirmed to still be in the data structure. Lost worker\n      // detection can remove it. However, we are intentionally ignoring this race, since the worker\n      // will just re-register regardless.\n      processWorkerRemovedBlocks(workerInfo, removedBlockIds);\n      processWorkerAddedBlocks(workerInfo, addedBlocksOnTiers);\n\n      workerInfo.updateUsedBytes(usedBytesOnTiers);\n      workerInfo.updateLastUpdatedTimeMs();\n\n      List<Long> toRemoveBlocks = workerInfo.getToRemoveBlocks();\n      if (toRemoveBlocks.isEmpty()) {\n        return new Command(CommandType.Nothing, new ArrayList<Long>());\n      }\n      return new Command(CommandType.Free, toRemoveBlocks);\n    }\n  }","id":98866,"modified_method":"/**\n   * Updates metadata when a worker periodically heartbeats with the master.\n   *\n   * @param workerId the worker id\n   * @param usedBytesOnTiers a mapping from tier alias to the used bytes\n   * @param removedBlockIds a list of block ids removed from this worker\n   * @param addedBlocksOnTiers a mapping from tier alias to the added blocks\n   * @return an optional command for the worker to execute\n   */\n  public Command workerHeartbeat(long workerId, Map<String, Long> usedBytesOnTiers,\n      List<Long> removedBlockIds, Map<String, List<Long>> addedBlocksOnTiers) {\n    MasterWorkerInfo worker = mWorkers.getFirstByField(mIdIndex, workerId);\n    if (worker == null) {\n      LOG.warn(\"Could not find worker id: {} for heartbeat.\", workerId);\n      return new Command(CommandType.Register, new ArrayList<Long>());\n    }\n\n    synchronized (worker) {\n      // Technically, 'worker' should be confirmed to still be in the data structure. Lost worker\n      // detection can remove it. However, we are intentionally ignoring this race, since the worker\n      // will just re-register regardless.\n      processWorkerRemovedBlocks(worker, removedBlockIds);\n      processWorkerAddedBlocks(worker, addedBlocksOnTiers);\n\n      worker.updateUsedBytes(usedBytesOnTiers);\n      worker.updateLastUpdatedTimeMs();\n\n      List<Long> toRemoveBlocks = worker.getToRemoveBlocks();\n      if (toRemoveBlocks.isEmpty()) {\n        return new Command(CommandType.Nothing, new ArrayList<Long>());\n      }\n      return new Command(CommandType.Free, toRemoveBlocks);\n    }\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return a new block container id\n   */\n  @Override\n  public long getNewContainerId() {\n    long counter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    long containerId;\n    synchronized (mBlockContainerIdGenerator) {\n      containerId = mBlockContainerIdGenerator.getNewContainerId();\n      counter = appendJournalEntry(mBlockContainerIdGenerator.toJournalEntry());\n    }\n    if (counter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n      waitForJournalFlush(counter);\n    }\n    return containerId;\n  }","id":98867,"modified_method":"/**\n   * @return a new block container id\n   */\n  @Override\n  public long getNewContainerId() {\n    long counter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    long containerId;\n    synchronized (mBlockContainerIdGenerator) {\n      containerId = mBlockContainerIdGenerator.getNewContainerId();\n      counter = appendJournalEntry(mBlockContainerIdGenerator.toJournalEntry());\n    }\n    waitForJournalFlush(counter);\n    return containerId;\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Updates the worker and block metadata for blocks added to a worker.\n   *\n   * @param workerInfo The worker metadata object\n   * @param addedBlockIds A mapping from storage tier alias to a list of block ids added\n   */\n  @GuardedBy(\"workerInfo\")\n  private void processWorkerAddedBlocks(MasterWorkerInfo workerInfo,\n      Map<String, List<Long>> addedBlockIds) {\n    for (Map.Entry<String, List<Long>> entry : addedBlockIds.entrySet()) {\n      for (long blockId : entry.getValue()) {\n        MasterBlockInfo masterBlockInfo = mBlocks.get(blockId);\n        if (masterBlockInfo != null) {\n          synchronized (masterBlockInfo) {\n            workerInfo.addBlock(blockId);\n            masterBlockInfo.addWorker(workerInfo.getId(), entry.getKey());\n            mLostBlocks.remove(blockId);\n          }\n        } else {\n          LOG.warn(\"Failed to register workerId: {} to blockId: {}\", workerInfo.getId(), blockId);\n        }\n      }\n    }\n  }","id":98868,"modified_method":"/**\n   * Updates the worker and block metadata for blocks added to a worker.\n   *\n   * @param workerInfo The worker metadata object\n   * @param addedBlockIds A mapping from storage tier alias to a list of block ids added\n   */\n  @GuardedBy(\"workerInfo\")\n  private void processWorkerAddedBlocks(MasterWorkerInfo workerInfo,\n      Map<String, List<Long>> addedBlockIds) {\n    for (Map.Entry<String, List<Long>> entry : addedBlockIds.entrySet()) {\n      for (long blockId : entry.getValue()) {\n        MasterBlockInfo block = mBlocks.get(blockId);\n        if (block != null) {\n          synchronized (block) {\n            workerInfo.addBlock(blockId);\n            block.addWorker(workerInfo.getId(), entry.getKey());\n            mLostBlocks.remove(blockId);\n          }\n        } else {\n          LOG.warn(\"Failed to register workerId: {} to blockId: {}\", workerInfo.getId(), blockId);\n        }\n      }\n    }\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Marks a block as committed on a specific worker.\n   *\n   * @param workerId the worker id committing the block\n   * @param usedBytesOnTier the updated used bytes on the tier of the worker\n   * @param tierAlias the alias of the storage tier where the worker is committing the block to\n   * @param blockId the committing block id\n   * @param length the length of the block\n   */\n  public void commitBlock(long workerId, long usedBytesOnTier, String tierAlias, long blockId,\n      long length) {\n    LOG.debug(\"Commit block from workerId: {}, usedBytesOnTier: {}, blockId: {}, length: {}\",\n        workerId, usedBytesOnTier, blockId, length);\n\n    long counter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n\n    MasterWorkerInfo workerInfo = mWorkers.getFirstByField(mIdIndex, workerId);\n    // Lock the worker metadata first.\n    synchronized (workerInfo) {\n      // Loop until block metadata is successfully locked.\n      for (;;) {\n        boolean mustInsert = false;\n        MasterBlockInfo masterBlockInfo = mBlocks.get(blockId);\n        if (masterBlockInfo == null) {\n          // The block metadata doesn't exist yet.\n          masterBlockInfo = new MasterBlockInfo(blockId, length);\n          mustInsert = true;\n        }\n\n        // Lock the block metadata.\n        synchronized (masterBlockInfo) {\n          boolean writeJournal = false;\n          if (mustInsert) {\n            if (mBlocks.putIfAbsent(blockId, masterBlockInfo) != null) {\n              // Another thread already inserted the metadata for this block, so start loop over.\n              continue;\n            }\n            // Successfully added the new block metadata. Append a journal entry for the new\n            // metadata.\n            writeJournal = true;\n          } else if (masterBlockInfo.getLength() != length\n              && masterBlockInfo.getLength() == Constants.UNKNOWN_SIZE) {\n            // The block size was previously unknown. Update the block size with the committed\n            // size, and append a journal entry.\n            masterBlockInfo.updateLength(length);\n            writeJournal = true;\n          }\n          if (writeJournal) {\n            BlockInfoEntry blockInfo =\n                BlockInfoEntry.newBuilder().setBlockId(blockId).setLength(length).build();\n            counter = appendJournalEntry(JournalEntry.newBuilder().setBlockInfo(blockInfo).build());\n          }\n          // At this point, both the worker and the block metadata are locked.\n\n          // Update the block metadata with the new worker location.\n          masterBlockInfo.addWorker(workerId, tierAlias);\n          // This worker has this block, so it is no longer lost.\n          mLostBlocks.remove(blockId);\n\n          // Update the worker information for this new block.\n          workerInfo.addBlock(blockId);\n          workerInfo.updateUsedBytes(tierAlias, usedBytesOnTier);\n          workerInfo.updateLastUpdatedTimeMs();\n        }\n        break;\n      }\n    }\n\n    if (counter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n      waitForJournalFlush(counter);\n    }\n  }","id":98869,"modified_method":"/**\n   * Marks a block as committed on a specific worker.\n   *\n   * @param workerId the worker id committing the block\n   * @param usedBytesOnTier the updated used bytes on the tier of the worker\n   * @param tierAlias the alias of the storage tier where the worker is committing the block to\n   * @param blockId the committing block id\n   * @param length the length of the block\n   */\n  public void commitBlock(long workerId, long usedBytesOnTier, String tierAlias, long blockId,\n      long length) {\n    LOG.debug(\"Commit block from workerId: {}, usedBytesOnTier: {}, blockId: {}, length: {}\",\n        workerId, usedBytesOnTier, blockId, length);\n\n    long counter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n\n    MasterWorkerInfo worker = mWorkers.getFirstByField(mIdIndex, workerId);\n    // Lock the worker metadata first.\n    synchronized (worker) {\n      // Loop until block metadata is successfully locked.\n      for (;;) {\n        boolean newBlock = false;\n        MasterBlockInfo block = mBlocks.get(blockId);\n        if (block == null) {\n          // The block metadata doesn't exist yet.\n          block = new MasterBlockInfo(blockId, length);\n          newBlock = true;\n        }\n\n        // Lock the block metadata.\n        synchronized (block) {\n          boolean writeJournal = false;\n          if (newBlock) {\n            if (mBlocks.putIfAbsent(blockId, block) != null) {\n              // Another thread already inserted the metadata for this block, so start loop over.\n              continue;\n            }\n            // Successfully added the new block metadata. Append a journal entry for the new\n            // metadata.\n            writeJournal = true;\n          } else if (block.getLength() != length\n              && block.getLength() == Constants.UNKNOWN_SIZE) {\n            // The block size was previously unknown. Update the block size with the committed\n            // size, and append a journal entry.\n            block.updateLength(length);\n            writeJournal = true;\n          }\n          if (writeJournal) {\n            BlockInfoEntry blockInfo =\n                BlockInfoEntry.newBuilder().setBlockId(blockId).setLength(length).build();\n            counter = appendJournalEntry(JournalEntry.newBuilder().setBlockInfo(blockInfo).build());\n          }\n          // At this point, both the worker and the block metadata are locked.\n\n          // Update the block metadata with the new worker location.\n          block.addWorker(workerId, tierAlias);\n          // This worker has this block, so it is no longer lost.\n          mLostBlocks.remove(blockId);\n\n          // Update the worker information for this new block.\n          worker.addBlock(blockId);\n          worker.updateUsedBytes(tierAlias, usedBytesOnTier);\n          worker.updateLastUpdatedTimeMs();\n        }\n        break;\n      }\n    }\n\n    waitForJournalFlush(counter);\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Removes blocks from workers.\n   *\n   * @param blockIds a list of block ids to remove from Alluxio space\n   * @param delete whether to delete blocks metadata in Master\n   */\n  public void removeBlocks(List<Long> blockIds, boolean delete) {\n    HashSet<Long> workerIds = new HashSet<>();\n    for (long blockId : blockIds) {\n      MasterBlockInfo masterBlockInfo = mBlocks.get(blockId);\n      if (masterBlockInfo == null) {\n        continue;\n      }\n      workerIds.clear();\n      synchronized (masterBlockInfo) {\n        // Technically, masterBlockInfo should be confirmed to still be in the data structure. A\n        // concurrent removeBlock call can remove it. However, we are intentionally ignoring this\n        // race, since deleting the same block again is a noop.\n        workerIds.addAll(masterBlockInfo.getWorkers());\n        // Two cases here:\n        // 1) For delete: delete the block metadata.\n        // 2) For free: keep the block metadata. mLostBlocks will be changed in\n        // processWorkerRemovedBlocks\n        if (delete) {\n          // Make sure blockId is removed from mLostBlocks when the block metadata is deleted.\n          // Otherwise blockId in mLostBlock can be dangling index if the metadata is gone.\n          mLostBlocks.remove(blockId);\n          mBlocks.remove(blockId);\n        }\n      }\n\n      // Outside of locking the block. This does not have to be synchronized with the block\n      // metadata, since it is essentially an asynchronous signal to the worker to remove the block.\n      for (long workerId : workerIds) {\n        MasterWorkerInfo workerInfo = mWorkers.getFirstByField(mIdIndex, workerId);\n        if (workerInfo != null) {\n          synchronized (workerInfo) {\n            workerInfo.updateToRemovedBlock(true, blockId);\n          }\n        }\n      }\n    }\n  }","id":98870,"modified_method":"/**\n   * Removes blocks from workers.\n   *\n   * @param blockIds a list of block ids to remove from Alluxio space\n   * @param delete whether to delete blocks metadata in Master\n   */\n  public void removeBlocks(List<Long> blockIds, boolean delete) {\n    HashSet<Long> workerIds = new HashSet<>();\n    for (long blockId : blockIds) {\n      MasterBlockInfo block = mBlocks.get(blockId);\n      if (block == null) {\n        continue;\n      }\n      workerIds.clear();\n      synchronized (block) {\n        // Technically, 'block' should be confirmed to still be in the data structure. A\n        // concurrent removeBlock call can remove it. However, we are intentionally ignoring this\n        // race, since deleting the same block again is a noop.\n        workerIds.addAll(block.getWorkers());\n        // Two cases here:\n        // 1) For delete: delete the block metadata.\n        // 2) For free: keep the block metadata. mLostBlocks will be changed in\n        // processWorkerRemovedBlocks\n        if (delete) {\n          // Make sure blockId is removed from mLostBlocks when the block metadata is deleted.\n          // Otherwise blockId in mLostBlock can be dangling index if the metadata is gone.\n          mLostBlocks.remove(blockId);\n          mBlocks.remove(blockId);\n        }\n      }\n\n      // Outside of locking the block. This does not have to be synchronized with the block\n      // metadata, since it is essentially an asynchronous signal to the worker to remove the block.\n      for (long workerId : workerIds) {\n        MasterWorkerInfo worker = mWorkers.getFirstByField(mIdIndex, workerId);\n        if (worker != null) {\n          synchronized (worker) {\n            worker.updateToRemovedBlock(true, blockId);\n          }\n        }\n      }\n    }\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Returns a worker id for the given worker.\n   *\n   * @param workerNetAddress the worker {@link WorkerNetAddress}\n   * @return the worker id for this worker\n   */\n  public long getWorkerId(WorkerNetAddress workerNetAddress) {\n    // TODO(gpang): This NetAddress cloned in case thrift re-uses the object. Does thrift re-use it?\n    MasterWorkerInfo existingWorker = mWorkers.getFirstByField(mAddressIndex, workerNetAddress);\n    if (existingWorker != null) {\n      // This worker address is already mapped to a worker id.\n      long oldWorkerId = existingWorker.getId();\n      LOG.warn(\"The worker {} already exists as id {}.\", workerNetAddress, oldWorkerId);\n      return oldWorkerId;\n    }\n\n    MasterWorkerInfo lostWorkerInfo = mLostWorkers.getFirstByField(mAddressIndex, workerNetAddress);\n    if (lostWorkerInfo != null) {\n      // this is one of the lost workers\n      synchronized (lostWorkerInfo) {\n        final long lostWorkerId = lostWorkerInfo.getId();\n        LOG.warn(\"A lost worker {} has requested its old id {}.\", workerNetAddress, lostWorkerId);\n\n        // Update the timestamp of the worker before it is considered an active worker.\n        lostWorkerInfo.updateLastUpdatedTimeMs();\n        mWorkers.add(lostWorkerInfo);\n        mLostWorkers.remove(lostWorkerInfo);\n        return lostWorkerId;\n      }\n    }\n\n    // Generate a new worker id.\n    long workerId = mNextWorkerId.getAndIncrement();\n    mWorkers.add(new MasterWorkerInfo(workerId, workerNetAddress));\n\n    LOG.info(\"getWorkerId(): WorkerNetAddress: {} id: {}\", workerNetAddress, workerId);\n    return workerId;\n  }","id":98871,"modified_method":"/**\n   * Returns a worker id for the given worker.\n   *\n   * @param workerNetAddress the worker {@link WorkerNetAddress}\n   * @return the worker id for this worker\n   */\n  public long getWorkerId(WorkerNetAddress workerNetAddress) {\n    // TODO(gpang): This NetAddress cloned in case thrift re-uses the object. Does thrift re-use it?\n    MasterWorkerInfo existingWorker = mWorkers.getFirstByField(mAddressIndex, workerNetAddress);\n    if (existingWorker != null) {\n      // This worker address is already mapped to a worker id.\n      long oldWorkerId = existingWorker.getId();\n      LOG.warn(\"The worker {} already exists as id {}.\", workerNetAddress, oldWorkerId);\n      return oldWorkerId;\n    }\n\n    MasterWorkerInfo lostWorker = mLostWorkers.getFirstByField(mAddressIndex, workerNetAddress);\n    if (lostWorker != null) {\n      // this is one of the lost workers\n      synchronized (lostWorker) {\n        final long lostWorkerId = lostWorker.getId();\n        LOG.warn(\"A lost worker {} has requested its old id {}.\", workerNetAddress, lostWorkerId);\n\n        // Update the timestamp of the worker before it is considered an active worker.\n        lostWorker.updateLastUpdatedTimeMs();\n        mWorkers.add(lostWorker);\n        mLostWorkers.remove(lostWorker);\n        return lostWorkerId;\n      }\n    }\n\n    // Generate a new worker id.\n    long workerId = mNextWorkerId.getAndIncrement();\n    mWorkers.add(new MasterWorkerInfo(workerId, workerNetAddress));\n\n    LOG.info(\"getWorkerId(): WorkerNetAddress: {} id: {}\", workerNetAddress, workerId);\n    return workerId;\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Updates the worker and block metadata for blocks removed from a worker.\n   *\n   * @param workerInfo The worker metadata object\n   * @param removedBlockIds A list of block ids removed from the worker\n   */\n  @GuardedBy(\"workerInfo\")\n  private void processWorkerRemovedBlocks(MasterWorkerInfo workerInfo,\n      Collection<Long> removedBlockIds) {\n    for (long removedBlockId : removedBlockIds) {\n      MasterBlockInfo masterBlockInfo = mBlocks.get(removedBlockId);\n      if (masterBlockInfo == null) {\n        LOG.warn(\"Worker {} informs the removed block {}, but block metadata does not exist\"\n            + \" on Master!\", workerInfo.getId(), removedBlockId);\n        // TODO(pfxuan): [ALLUXIO-1804] should find a better way to handle the removed blocks.\n        // Ideally, the delete/free I/O flow should never reach this point. Because Master may\n        // update the block metadata only after receiving the acknowledgement from Workers.\n        workerInfo.removeBlock(removedBlockId);\n        // Continue to remove the remaining blocks.\n        continue;\n      }\n      synchronized (masterBlockInfo) {\n        LOG.info(\"Block {} is removed on worker {}.\", removedBlockId, workerInfo.getId());\n        workerInfo.removeBlock(masterBlockInfo.getBlockId());\n        masterBlockInfo.removeWorker(workerInfo.getId());\n        if (masterBlockInfo.getNumLocations() == 0) {\n          mLostBlocks.add(removedBlockId);\n        }\n      }\n    }\n  }","id":98872,"modified_method":"/**\n   * Updates the worker and block metadata for blocks removed from a worker.\n   *\n   * @param workerInfo The worker metadata object\n   * @param removedBlockIds A list of block ids removed from the worker\n   */\n  @GuardedBy(\"workerInfo\")\n  private void processWorkerRemovedBlocks(MasterWorkerInfo workerInfo,\n      Collection<Long> removedBlockIds) {\n    for (long removedBlockId : removedBlockIds) {\n      MasterBlockInfo block = mBlocks.get(removedBlockId);\n      if (block == null) {\n        LOG.warn(\"Worker {} informs the removed block {}, but block metadata does not exist\"\n            + \" on Master!\", workerInfo.getId(), removedBlockId);\n        // TODO(pfxuan): [ALLUXIO-1804] should find a better way to handle the removed blocks.\n        // Ideally, the delete/free I/O flow should never reach this point. Because Master may\n        // update the block metadata only after receiving the acknowledgement from Workers.\n        workerInfo.removeBlock(removedBlockId);\n        // Continue to remove the remaining blocks.\n        continue;\n      }\n      synchronized (block) {\n        LOG.info(\"Block {} is removed on worker {}.\", removedBlockId, workerInfo.getId());\n        workerInfo.removeBlock(block.getBlockId());\n        block.removeWorker(workerInfo.getId());\n        if (block.getNumLocations() == 0) {\n          mLostBlocks.add(removedBlockId);\n        }\n      }\n    }\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Updates metadata when a worker registers with the master.\n   *\n   * @param workerId the worker id of the worker registering\n   * @param storageTiers a list of storage tier aliases in order of their position in the worker's\n   *        hierarchy\n   * @param totalBytesOnTiers a mapping from storage tier alias to total bytes\n   * @param usedBytesOnTiers a mapping from storage tier alias to the used byes\n   * @param currentBlocksOnTiers a mapping from storage tier alias to a list of blocks\n   * @throws NoWorkerException if workerId cannot be found\n   */\n  public void workerRegister(long workerId, List<String> storageTiers,\n      Map<String, Long> totalBytesOnTiers, Map<String, Long> usedBytesOnTiers,\n      Map<String, List<Long>> currentBlocksOnTiers) throws NoWorkerException {\n    MasterWorkerInfo workerInfo = mWorkers.getFirstByField(mIdIndex, workerId);\n    if (workerInfo == null) {\n      throw new NoWorkerException(\"Could not find worker id: \" + workerId + \" to register.\");\n    }\n\n    // Gather all blocks on this worker.\n    HashSet<Long> blocks = new HashSet<>();\n    for (List<Long> blockIds : currentBlocksOnTiers.values()) {\n      blocks.addAll(blockIds);\n    }\n\n    synchronized (workerInfo) {\n      workerInfo.updateLastUpdatedTimeMs();\n      // Detect any lost blocks on this worker.\n      Set<Long> removedBlocks = workerInfo.register(mGlobalStorageTierAssoc, storageTiers,\n          totalBytesOnTiers, usedBytesOnTiers, blocks);\n      processWorkerRemovedBlocks(workerInfo, removedBlocks);\n      processWorkerAddedBlocks(workerInfo, currentBlocksOnTiers);\n    }\n\n    LOG.info(\"registerWorker(): {}\", workerInfo);\n  }","id":98873,"modified_method":"/**\n   * Updates metadata when a worker registers with the master.\n   *\n   * @param workerId the worker id of the worker registering\n   * @param storageTiers a list of storage tier aliases in order of their position in the worker's\n   *        hierarchy\n   * @param totalBytesOnTiers a mapping from storage tier alias to total bytes\n   * @param usedBytesOnTiers a mapping from storage tier alias to the used byes\n   * @param currentBlocksOnTiers a mapping from storage tier alias to a list of blocks\n   * @throws NoWorkerException if workerId cannot be found\n   */\n  public void workerRegister(long workerId, List<String> storageTiers,\n      Map<String, Long> totalBytesOnTiers, Map<String, Long> usedBytesOnTiers,\n      Map<String, List<Long>> currentBlocksOnTiers) throws NoWorkerException {\n    MasterWorkerInfo worker = mWorkers.getFirstByField(mIdIndex, workerId);\n    if (worker == null) {\n      throw new NoWorkerException(\"Could not find worker id: \" + workerId + \" to register.\");\n    }\n\n    // Gather all blocks on this worker.\n    HashSet<Long> blocks = new HashSet<>();\n    for (List<Long> blockIds : currentBlocksOnTiers.values()) {\n      blocks.addAll(blockIds);\n    }\n\n    synchronized (worker) {\n      worker.updateLastUpdatedTimeMs();\n      // Detect any lost blocks on this worker.\n      Set<Long> removedBlocks = worker.register(mGlobalStorageTierAssoc, storageTiers,\n          totalBytesOnTiers, usedBytesOnTiers, blocks);\n      processWorkerRemovedBlocks(worker, removedBlocks);\n      processWorkerAddedBlocks(worker, currentBlocksOnTiers);\n    }\n\n    LOG.info(\"registerWorker(): {}\", worker);\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Retrieves information for the given list of block ids.\n   *\n   * @param blockIds A list of block ids to retrieve the information for\n   * @return A list of {@link BlockInfo} objects corresponding to the input list of block ids. The\n   *         list is in the same order as the input list\n   */\n  public List<BlockInfo> getBlockInfoList(List<Long> blockIds) {\n    List<BlockInfo> ret = new ArrayList<>(blockIds.size());\n    for (long blockId : blockIds) {\n      MasterBlockInfo masterBlockInfo = mBlocks.get(blockId);\n      if (masterBlockInfo == null) {\n        continue;\n      }\n      synchronized (masterBlockInfo) {\n        ret.add(generateBlockInfo(masterBlockInfo));\n      }\n    }\n    return ret;\n  }","id":98874,"modified_method":"/**\n   * Retrieves information for the given list of block ids.\n   *\n   * @param blockIds A list of block ids to retrieve the information for\n   * @return A list of {@link BlockInfo} objects corresponding to the input list of block ids. The\n   *         list is in the same order as the input list\n   */\n  public List<BlockInfo> getBlockInfoList(List<Long> blockIds) {\n    List<BlockInfo> ret = new ArrayList<>(blockIds.size());\n    for (long blockId : blockIds) {\n      MasterBlockInfo block = mBlocks.get(blockId);\n      if (block == null) {\n        continue;\n      }\n      synchronized (block) {\n        ret.add(generateBlockInfo(block));\n      }\n    }\n    return ret;\n  }","commit_id":"d335402390a3bb7d83bdb0160cd6d9e725a4841f","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n        public void focusLost(FocusEvent e) {\n            if (ignoreListener) return;\n            String ostr = tOffset.getText();\n            int semicolon = ostr.indexOf(';');\n            if( semicolon >= 0 && semicolon + 1 < ostr.length() ) {\n                try {\n                    // here we assume that Double.parseDouble() needs '.' as a decimal separator\n                    String easting = ostr.substring(0, semicolon).trim().replace(',', '.');\n                    String northing = ostr.substring(semicolon + 1).trim().replace(',', '.');\n                    double dx = Double.parseDouble(easting);\n                    double dy = Double.parseDouble(northing);\n                    layer.setOffset(dx, dy);\n                } catch (NumberFormatException nfe) {\n                    // we repaint offset numbers in any case\n                }\n            }\n            updateOffsetIntl();\n            Main.map.repaint();\n        }","id":98875,"modified_method":"@Override\n        public void focusLost(FocusEvent e) {\n            if (ignoreListener) return;\n            String ostr = tOffset.getText();\n            int semicolon = ostr.indexOf(';');\n            if( semicolon >= 0 && semicolon + 1 < ostr.length() ) {\n                try {\n                    // here we assume that Double.parseDouble() needs '.' as a decimal separator\n                    String easting = ostr.substring(0, semicolon).trim().replace(',', '.');\n                    String northing = ostr.substring(semicolon + 1).trim().replace(',', '.');\n                    double dx = Double.parseDouble(easting);\n                    double dy = Double.parseDouble(northing);\n                    layer.setOffset(dx, dy);\n                } catch (NumberFormatException nfe) {\n                    // we repaint offset numbers in any case\n                }\n            }\n            updateOffsetIntl();\n            if (Main.map != null) {\n                Main.map.repaint();\n            }\n        }","commit_id":"3451b16c8175a2ea281a11cfdc9cd63ba870d0b5","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Player player = game.getPlayer(targetPointer.getFirst(game, source));\r\n        if (player != null && controller != null) {\r\n            controller.lookAtCards(\"Gitaxian Probe\", player.getHand(), game);\r\n        }\r\n        return true;\r\n    }","id":98876,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Player player = game.getPlayer(targetPointer.getFirst(game, source));\r\n        MageObject sourceObject = source.getSourceObject(game);\r\n        if (player != null && controller != null && sourceObject != null) {\r\n            controller.lookAtCards(sourceObject.getIdName() + \" (\" + player.getName() + \")\", player.getHand(), game);\r\n        }\r\n        return true;\r\n    }","commit_id":"7a90db7995de71905003751786858b7681a88f3e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public void paintComponent(Graphics g) {\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        if (isEnabled()) {\r\n            if (isHovered || textAlwaysVisible) {\r\n                g.drawImage(hoverImage, 0, 0, imageSize.width, imageSize.height, this);\r\n                if (text != null) {\r\n                    if (textColor != null) {\r\n                        g2d.setColor(textColor);\r\n                    }\r\n                    if (useMiniFont) {\r\n                        g2d.setFont(textFontMini);\r\n                    } else {\r\n                        g2d.setFont(textFont);\r\n                    }\r\n                    textOffsetX = calculateOffset(g2d);\r\n                    g2d.drawString(text, textOffsetX, textOffsetY);\r\n                }\r\n            } else {\r\n                g.drawImage(image, 0, 0, imageSize.width, imageSize.height, this);\r\n            }\r\n            if (isSelected) {\r\n                if (selectedImage != null) {\r\n                    g.drawImage(selectedImage, 0, 0, imageSize.width, imageSize.height, this);\r\n                } else {\r\n                    System.err.println(\"No selectedImage for button.\");\r\n                }\r\n            }\r\n        } else {\r\n            g.drawImage(disabledImage, 0, 0, imageSize.width, imageSize.height, this);\r\n        }\r\n        if (topText != null) {\r\n            if (useMiniFont) {\r\n                g2d.setFont(textFontMini);\r\n            } else {\r\n                g2d.setFont(textFont);\r\n            }\r\n            topTextOffsetX = calculateOffsetForTop(g2d, topText);\r\n            g2d.setColor(textBGColor);\r\n            g2d.drawString(topText, topTextOffsetX + 1, 13);\r\n            g2d.setColor(textColor);\r\n            g2d.drawString(topText, topTextOffsetX, 12);\r\n        }\r\n        if (overlayImage != null) {\r\n            g.drawImage(overlayImage, (imageSize.width - overlayImageSize.width) / 2, 10, this);\r\n        } else if (set != null) {\r\n            // draw only if it is not current tab\r\n            if (!drawSet) {\r\n                g2d.setFont(textSetFontBoldMini);\r\n                g2d.drawString(set, 5, 25);\r\n            }\r\n        }\r\n\r\n        if (drawSet && set != null) {\r\n            g2d.setFont(textSetFontBold);\r\n            int w = (int) (getWidth() / 2.0);\r\n            int h = (int) (getHeight() / 2.0);\r\n            int dy = overlayImage == null ? 15 : 25;\r\n            g2d.translate(w + 5, h + dy);\r\n            g2d.rotate(-Math.PI / 2.0);\r\n            g2d.drawString(set, 0, 0);\r\n        }\r\n    }","id":98877,"modified_method":"@Override\r\n    public void paintComponent(Graphics g) {\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        if (isEnabled()) {\r\n            if (isHovered || textAlwaysVisible) {\r\n                g.drawImage(hoverImage, 0, 0, imageSize.width, imageSize.height, this);\r\n                if (text != null) {\r\n                    if (textColor != null) {\r\n                        g2d.setColor(textColor);\r\n                    }\r\n                    if (useMiniFont) {\r\n                        g2d.setFont(textFontMini);\r\n                    } else {\r\n                        g2d.setFont(textFont);\r\n                    }\r\n                    textOffsetX = calculateOffset(g2d);\r\n                    g2d.drawString(text, textOffsetX, textOffsetY);\r\n                }\r\n            } else {\r\n                g.drawImage(image, 0, 0, imageSize.width, imageSize.height, this);\r\n            }\r\n            if (isSelected) {\r\n                if (selectedImage != null) {\r\n                    g.drawImage(selectedImage, 0, 0, imageSize.width, imageSize.height, this);\r\n                } else {\r\n                    System.err.println(\"No selectedImage for button.\");\r\n                }\r\n            }\r\n        } else {\r\n            g.drawImage(disabledImage, 0, 0, imageSize.width, imageSize.height, this);\r\n        }\r\n        if (topText != null) {\r\n            if (useMiniFont) {\r\n                g2d.setFont(textFontMini);\r\n            } else {\r\n                g2d.setFont(textFont);\r\n            }\r\n            topTextOffsetX = calculateOffsetForTop(g2d, topText);\r\n            g2d.setColor(textBGColor);\r\n            g2d.drawString(topText, topTextOffsetX + 1, 14);\r\n            g2d.setColor(textColor);\r\n            g2d.drawString(topText, topTextOffsetX, 13);\r\n        }\r\n        if (topTextImage != null) {\r\n            g.drawImage(topTextImage, 4, 3, this);\r\n        }\r\n        if (overlayImage != null) {\r\n            g.drawImage(overlayImage, (imageSize.width - overlayImageSize.width) / 2, 10, this);\r\n        } else if (set != null) {\r\n            // draw only if it is not current tab\r\n            if (!drawSet) {\r\n                g2d.setFont(textSetFontBoldMini);\r\n                g2d.drawString(set, 5, 25);\r\n            }\r\n        }\r\n\r\n        if (drawSet && set != null) {\r\n            g2d.setFont(textSetFontBold);\r\n            int w = (int) (getWidth() / 2.0);\r\n            int h = (int) (getHeight() / 2.0);\r\n            int dy = overlayImage == null ? 15 : 25;\r\n            g2d.translate(w + 5, h + dy);\r\n            g2d.rotate(-Math.PI / 2.0);\r\n            g2d.drawString(set, 0, 0);\r\n        }\r\n    }","commit_id":"7a90db7995de71905003751786858b7681a88f3e","url":"https://github.com/magefree/mage"},{"original_method":"private int calculateOffsetForTop(Graphics2D g2d, String text) {\r\n        if (topTextOffsetX == -1) { // calculate once\r\n            FontRenderContext frc = g2d.getFontRenderContext();\r\n            int textWidth = (int) textFont.getStringBounds(text, frc).getWidth();\r\n            topTextOffsetX = (imageSize.width - textWidth) / 2;\r\n        }\r\n        return topTextOffsetX;\r\n    }","id":98878,"modified_method":"private int calculateOffsetForTop(Graphics2D g2d, String text) {\r\n        if (topTextOffsetX == -1) { // calculate once\r\n            FontRenderContext frc = g2d.getFontRenderContext();\r\n            int textWidth = (int) textFont.getStringBounds(text, frc).getWidth();\r\n            int neededImageWidth = (topTextImage == null ? 0 : topTextImage.getWidth(this));\r\n            int availableXWidth = imageSize.width - neededImageWidth;\r\n            topTextOffsetX = (availableXWidth - textWidth) / 2 + neededImageWidth;\r\n        }\r\n        return topTextOffsetX;\r\n    }","commit_id":"7a90db7995de71905003751786858b7681a88f3e","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void initComponents() {\n\n        panelBackground = new MageRoundPane();\n        panelBackground.setPreferredSize(new Dimension(PANEL_WIDTH - 2, PANEL_HEIGHT));\n        Rectangle r = new Rectangle(80, 80);\n        avatarFlag = new JLabel();\n        timerLabel = new JLabel();\n        lifeLabel = new JLabel();\n        handLabel = new JLabel();\n        poisonLabel = new JLabel();\n        graveLabel = new JLabel();\n        libraryLabel = new JLabel();\n        setOpaque(false);\n\n        panelBackground.setXOffset(3);\n        panelBackground.setYOffset(3);\n        panelBackground.setVisible(true);\n\n        // Avatar\n        Image image = ImageHelper.getImageFromResources(DEFAULT_AVATAR_PATH);\n\n        BufferedImage resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        avatar = new HoverButton(\"player\", resized, resized, resized, r);\n        avatar.setLayout(new GridLayout(4, 1, 0, 0));\n        avatar.add(new JLabel());\n        avatar.add(new JLabel());\n        avatar.add(avatarFlag);\n        avatar.setAlignTextLeft(true);\n        avatarFlag.setHorizontalAlignment(JLabel.LEFT);\n        avatarFlag.setVerticalAlignment(JLabel.BOTTOM);\n        avatar.add(new JLabel());\n        String showPlayerNamePermanently = MageFrame.getPreferences().get(PreferencesDialog.KEY_SHOW_PLAYER_NAMES_PERMANENTLY, \"true\");\n        if (showPlayerNamePermanently.equals(\"true\")) {\n            avatar.setTextAlwaysVisible(true);\n        }\n        avatar.setTextOffsetButtonY(10);\n        avatar.setObserver(new Command() {\n            @Override\n            public void execute() {\n                session.sendPlayerUUID(gameId, playerId);\n            }\n        });\n\n        // timer area /small layout)\n        timerLabel.setToolTipText(\"Time left\");\n        timerLabel.setSize(80, 12);\n        timerLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\n        // life area\n        r = new Rectangle(18, 18);\n        lifeLabel.setToolTipText(\"Life\");\n        Image imageLife = ImageHelper.getImageFromResources(\"/info/life.png\");\n        BufferedImage resizedLife = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageLife, BufferedImage.TYPE_INT_ARGB), r);\n        life = new ImagePanel(resizedLife, ImagePanel.ACTUAL);\n        life.setToolTipText(\"Life\");\n        life.setOpaque(false);\n        // hand area\n        r = new Rectangle(18, 18);\n        handLabel.setToolTipText(\"Hand\");\n        Image imageHand = ImageHelper.getImageFromResources(\"/info/hand.png\");\n        BufferedImage resizedHand = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageHand, BufferedImage.TYPE_INT_ARGB), r);\n        hand = new ImagePanel(resizedHand, ImagePanel.ACTUAL);\n        hand.setToolTipText(\"Hand\");\n        hand.setOpaque(false);\n\n        // Poison count\n        poisonLabel.setText(\"0\");\n        r = new Rectangle(14, 14);\n        poisonLabel.setToolTipText(\"Poison\");\n        Image imagePoison = ImageHelper.getImageFromResources(\"/info/poison.png\");\n        BufferedImage resizedPoison = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imagePoison, BufferedImage.TYPE_INT_ARGB), r);\n        poison = new ImagePanel(resizedPoison, ImagePanel.ACTUAL);\n        poison.setToolTipText(\"Poison\");\n        poison.setOpaque(false);\n\n        // Library\n        r = new Rectangle(19, 19);\n        libraryLabel.setToolTipText(\"Library\");\n        Image imageLibrary = ImageHelper.getImageFromResources(\"/info/library.png\");\n        BufferedImage resizedLibrary = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageLibrary, BufferedImage.TYPE_INT_ARGB), r);\n\n        library = new HoverButton(null, resizedLibrary, resizedLibrary, resizedLibrary, r);\n        library.setToolTipText(\"Library\");\n        library.setOpaque(false);\n        library.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnLibraryActionPerformed(null);\n            }\n        });\n\n        // Grave count and open graveyard button\n        r = new Rectangle(21, 21);\n        graveLabel.setToolTipText(\"Graveyard\");\n        Image imageGrave = ImageHelper.getImageFromResources(\"/info/grave.png\");\n        BufferedImage resizedGrave = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageGrave, BufferedImage.TYPE_INT_ARGB), r);\n\n        grave = new HoverButton(null, resizedGrave, resizedGrave, resizedGrave, r);\n        grave.setToolTipText(\"Graveyard\");\n        grave.setOpaque(false);\n        grave.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnGraveActionPerformed(null);\n            }\n        });\n\n        exileLabel = new JLabel();\n        exileLabel.setToolTipText(\"Exile\");\n        image = ImageHelper.getImageFromResources(\"/info/exile.png\");\n        r = new Rectangle(21, 21);\n        resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        exileZone = new HoverButton(null, resized, resized, resized, r);\n        exileZone.setToolTipText(\"Exile\");\n        exileZone.setOpaque(false);\n        exileZone.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnExileZoneActionPerformed(null);\n            }\n        });\n        exileZone.setBounds(25, 0, 21, 21);\n\n        // Cheat button\n        r = new Rectangle(25, 21);\n        image = ImageHelper.getImageFromResources(\"/info/cheat.png\");\n        resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        cheat = new JButton();\n        cheat.setIcon(new ImageIcon(resized));\n        cheat.setToolTipText(\"Cheat button\");\n        cheat.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                btnCheatActionPerformed(e);\n            }\n        });\n\n        zonesPanel = new JPanel();\n        zonesPanel.setPreferredSize(new Dimension(100, 20));\n        zonesPanel.setSize(100, 20);\n        zonesPanel.setLayout(null);\n\n        image = ImageHelper.getImageFromResources(\"/info/command_zone.png\");\n        r = new Rectangle(21, 21);\n        resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        commandZone = new HoverButton(null, resized, resized, resized, r);\n        commandZone.setToolTipText(\"Command Zone (Commander and Emblems)\");\n        commandZone.setOpaque(false);\n        commandZone.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnCommandZoneActionPerformed(null);\n            }\n        });\n        commandZone.setBounds(5, 0, 21, 21);\n        zonesPanel.add(commandZone);\n\n        cheat.setBounds(28, 0, 25, 21);\n        zonesPanel.add(cheat);\n\n        btnPlayer = new JButton();\n        btnPlayer.setText(\"Player\");\n        btnPlayer.setVisible(false);\n        btnPlayer.setToolTipText(\"Player\");\n        btnPlayer.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                session.sendPlayerUUID(gameId, playerId);\n            }\n        });\n\n        // Add mana symbols\n        JLabel manaCountLabelW = new JLabel();\n        manaCountLabelW.setToolTipText(\"White mana\");\n        manaCountLabelW.setText(\"0\");\n        manaLabels.put(\"W\", manaCountLabelW);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaW = ManaSymbols.getManaSymbolImageSmall(\"W\");\n        HoverButton btnWhiteMana = new HoverButton(null, imageManaW, imageManaW, imageManaW, r);\n        btnWhiteMana.setToolTipText(\"White mana\");\n        btnWhiteMana.setOpaque(false);\n        btnWhiteMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.WHITE);\n            }\n        });\n\n        JLabel manaCountLabelU = new JLabel();\n        manaCountLabelU.setToolTipText(\"Blue mana\");\n        manaCountLabelU.setText(\"0\");\n        manaLabels.put(\"U\", manaCountLabelU);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaU = ManaSymbols.getManaSymbolImageSmall(\"U\");\n        HoverButton btnBlueMana = new HoverButton(null, imageManaU, imageManaU, imageManaU, r);\n        btnBlueMana.setToolTipText(\"Blue mana\");\n        btnBlueMana.setOpaque(false);\n        btnBlueMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.BLUE);\n            }\n        });\n\n        JLabel manaCountLabelB = new JLabel();\n        manaCountLabelB.setToolTipText(\"Black mana\");\n        manaCountLabelB.setText(\"0\");\n        manaLabels.put(\"B\", manaCountLabelB);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaB = ManaSymbols.getManaSymbolImageSmall(\"B\");\n        HoverButton btnBlackMana = new HoverButton(null, imageManaB, imageManaB, imageManaB, r);\n        btnBlackMana.setToolTipText(\"Black mana\");\n        btnBlackMana.setOpaque(false);\n        btnBlackMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.BLACK);\n            }\n        });\n\n        JLabel manaCountLabelR = new JLabel();\n        manaCountLabelR.setToolTipText(\"Red mana\");\n        manaCountLabelR.setText(\"0\");\n        manaLabels.put(\"R\", manaCountLabelR);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaR = ManaSymbols.getManaSymbolImageSmall(\"R\");\n        HoverButton btnRedMana = new HoverButton(null, imageManaR, imageManaR, imageManaR, r);\n        btnRedMana.setToolTipText(\"Red mana\");\n        btnRedMana.setOpaque(false);\n        btnRedMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.RED);\n            }\n        });\n\n        JLabel manaCountLabelG = new JLabel();\n        manaCountLabelG.setToolTipText(\"Green mana\");\n        manaCountLabelG.setText(\"0\");\n        manaLabels.put(\"G\", manaCountLabelG);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaG = ManaSymbols.getManaSymbolImageSmall(\"G\");\n        HoverButton btnGreenMana = new HoverButton(null, imageManaG, imageManaG, imageManaG, r);\n        btnGreenMana.setToolTipText(\"Green mana\");\n        btnGreenMana.setOpaque(false);\n        btnGreenMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.GREEN);\n            }\n        });\n\n        JLabel manaCountLabelX = new JLabel();\n        manaCountLabelX.setToolTipText(\"Colorless mana\");\n        manaCountLabelX.setText(\"0\");\n        manaLabels.put(\"X\", manaCountLabelX);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaX = ManaSymbols.getManaSymbolImageSmall(\"X\");\n        HoverButton btnColorlessMana = new HoverButton(null, imageManaX, imageManaX, imageManaX, r);\n        btnColorlessMana.setToolTipText(\"Colorless mana\");\n        btnColorlessMana.setOpaque(false);\n        btnColorlessMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.COLORLESS);\n            }\n        });\n\n        GroupLayout gl_panelBackground = new GroupLayout(panelBackground);\n        gl_panelBackground.setHorizontalGroup(\n                gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(9)\n                        .addComponent(life, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE)\n                        .addGap(3)\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(18)\n                                        .addComponent(hand, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(lifeLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                        .addGap(4)\n                        .addComponent(handLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE))\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(9)\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(3)\n                                        .addComponent(poison, GroupLayout.PREFERRED_SIZE, 14, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(2)\n                                        .addComponent(btnWhiteMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(2)\n                                        .addComponent(btnBlueMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(2)\n                                        .addComponent(btnBlackMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(grave, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE)\n                        )\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(18)\n                                                        .addComponent(library, GroupLayout.PREFERRED_SIZE, 19, GroupLayout.PREFERRED_SIZE))\n                                                .addComponent(poisonLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(20)\n                                                        .addComponent(btnRedMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(1)\n                                                        .addComponent(manaCountLabelW, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE)))\n                                        .addGap(3)\n                                        .addComponent(manaCountLabelR, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addComponent(manaCountLabelB, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(19)\n                                                        .addComponent(btnColorlessMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)))\n                                        .addGap(5)\n                                        .addComponent(manaCountLabelX, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(20)\n                                        .addComponent(btnGreenMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(40)\n                                        .addComponent(manaCountLabelG, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(40)\n                                        .addComponent(libraryLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                                /*.addGroup(gl_panelBackground.createSequentialGroup()\n                                 .addGap(18)\n                                 .addComponent(cheat, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))*/\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(18)\n                                        .addComponent(exileZone, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE)\n                                )\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(5)\n                                        .addComponent(graveLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(40)\n                                        .addComponent(exileLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addComponent(manaCountLabelU, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))))\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(6)\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addComponent(btnPlayer, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(timerLabel, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(avatar, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE))\n                        //                        .addGroup(gl_panelBackground.createSequentialGroup()\n                        //                                .addComponent(avatarFlag, GroupLayout.PREFERRED_SIZE, 16, GroupLayout.PREFERRED_SIZE))\n                        .addGap(14))\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(6)\n                        .addComponent(zonesPanel, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE)\n                        .addGap(14))\n        );\n        gl_panelBackground.setVerticalGroup(\n                gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(6)\n                        .addComponent(avatar, GroupLayout.PREFERRED_SIZE, 80, GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(ComponentPlacement.RELATED)\n                        .addComponent(btnPlayer)\n                        .addComponent(timerLabel)\n                        .addGap(1)\n                        // Life & Hand\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addComponent(life, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addComponent(hand, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(lifeLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE)\n                                .addComponent(handLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE))\n                        .addGap(1)\n                        // Poison\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(4)\n                                        .addComponent(poison, GroupLayout.PREFERRED_SIZE, 14, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(4)\n                                        .addComponent(btnWhiteMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(2)\n                                        .addComponent(btnBlueMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(2)\n                                        .addComponent(btnBlackMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(5)\n                                        .addComponent(grave, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE)\n                                )\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                                        .addGap(1)\n                                                                        .addComponent(library, GroupLayout.PREFERRED_SIZE, 19, GroupLayout.PREFERRED_SIZE))\n                                                                .addComponent(poisonLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE))\n                                                        .addGap(2)\n                                                        .addComponent(btnRedMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(14)\n                                                        .addComponent(manaCountLabelW, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(14)\n                                                        .addComponent(manaCountLabelR, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)))\n                                        .addGap(4)\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addComponent(manaCountLabelB, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(8)\n                                                        .addComponent(btnColorlessMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                                .addComponent(manaCountLabelX, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(39)\n                                        .addComponent(btnGreenMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(31)\n                                        .addComponent(manaCountLabelG, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(libraryLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE)\n                                /*.addGroup(gl_panelBackground.createSequentialGroup()\n                                 .addGap(76)\n                                 .addComponent(cheat, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE))*/\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(76)\n                                        .addComponent(exileZone, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE)\n                                )\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(76)\n                                        .addComponent(graveLabel, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(76)\n                                        .addComponent(exileLabel, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(31)\n                                        .addComponent(manaCountLabelU, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)\n                                )\n                        )\n                        .addPreferredGap(ComponentPlacement.RELATED)\n                        .addComponent(zonesPanel, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE)\n                )\n        );\n        panelBackground.setLayout(gl_panelBackground);\n        GroupLayout groupLayout = new GroupLayout(this);\n        groupLayout.setHorizontalGroup(\n                groupLayout.createParallelGroup(Alignment.LEADING)\n                .addGroup(groupLayout.createSequentialGroup()\n                        .addComponent(panelBackground, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE))\n        );\n        groupLayout.setVerticalGroup(\n                groupLayout.createParallelGroup(Alignment.LEADING)\n                .addGroup(groupLayout.createSequentialGroup()\n                        .addComponent(panelBackground, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE))\n        );\n        setLayout(groupLayout);\n\n    }","id":98879,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void initComponents() {\n\n        panelBackground = new MageRoundPane();\n        panelBackground.setPreferredSize(new Dimension(PANEL_WIDTH - 2, PANEL_HEIGHT));\n        Rectangle r = new Rectangle(80, 80);\n        avatarFlag = new JLabel();\n        timerLabel = new JLabel();\n        lifeLabel = new JLabel();\n        handLabel = new JLabel();\n        poisonLabel = new JLabel();\n        graveLabel = new JLabel();\n        libraryLabel = new JLabel();\n        setOpaque(false);\n\n        panelBackground.setXOffset(3);\n        panelBackground.setYOffset(3);\n        panelBackground.setVisible(true);\n\n        // Avatar\n        Image image = ImageHelper.getImageFromResources(DEFAULT_AVATAR_PATH);\n\n        BufferedImage resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        avatar = new HoverButton(\"\", resized, resized, resized, r);\n\n        String showPlayerNamePermanently = MageFrame.getPreferences().get(PreferencesDialog.KEY_SHOW_PLAYER_NAMES_PERMANENTLY, \"true\");\n        if (showPlayerNamePermanently.equals(\"true\")) {\n            avatar.setTextAlwaysVisible(true);\n        }\n        avatar.setTextOffsetButtonY(10);\n        avatar.setObserver(new Command() {\n            @Override\n            public void execute() {\n                session.sendPlayerUUID(gameId, playerId);\n            }\n        });\n\n        // timer area /small layout)\n        timerLabel.setToolTipText(\"Time left\");\n        timerLabel.setSize(80, 12);\n        timerLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\n        // life area\n        r = new Rectangle(18, 18);\n        lifeLabel.setToolTipText(\"Life\");\n        Image imageLife = ImageHelper.getImageFromResources(\"/info/life.png\");\n        BufferedImage resizedLife = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageLife, BufferedImage.TYPE_INT_ARGB), r);\n        life = new ImagePanel(resizedLife, ImagePanel.ACTUAL);\n        life.setToolTipText(\"Life\");\n        life.setOpaque(false);\n        // hand area\n        r = new Rectangle(18, 18);\n        handLabel.setToolTipText(\"Hand\");\n        Image imageHand = ImageHelper.getImageFromResources(\"/info/hand.png\");\n        BufferedImage resizedHand = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageHand, BufferedImage.TYPE_INT_ARGB), r);\n        hand = new ImagePanel(resizedHand, ImagePanel.ACTUAL);\n        hand.setToolTipText(\"Hand\");\n        hand.setOpaque(false);\n\n        // Poison count\n        poisonLabel.setText(\"0\");\n        r = new Rectangle(14, 14);\n        poisonLabel.setToolTipText(\"Poison\");\n        Image imagePoison = ImageHelper.getImageFromResources(\"/info/poison.png\");\n        BufferedImage resizedPoison = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imagePoison, BufferedImage.TYPE_INT_ARGB), r);\n        poison = new ImagePanel(resizedPoison, ImagePanel.ACTUAL);\n        poison.setToolTipText(\"Poison\");\n        poison.setOpaque(false);\n\n        // Library\n        r = new Rectangle(19, 19);\n        libraryLabel.setToolTipText(\"Library\");\n        Image imageLibrary = ImageHelper.getImageFromResources(\"/info/library.png\");\n        BufferedImage resizedLibrary = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageLibrary, BufferedImage.TYPE_INT_ARGB), r);\n\n        library = new HoverButton(null, resizedLibrary, resizedLibrary, resizedLibrary, r);\n        library.setToolTipText(\"Library\");\n        library.setOpaque(false);\n        library.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnLibraryActionPerformed(null);\n            }\n        });\n\n        // Grave count and open graveyard button\n        r = new Rectangle(21, 21);\n        graveLabel.setToolTipText(\"Graveyard\");\n        Image imageGrave = ImageHelper.getImageFromResources(\"/info/grave.png\");\n        BufferedImage resizedGrave = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(imageGrave, BufferedImage.TYPE_INT_ARGB), r);\n\n        grave = new HoverButton(null, resizedGrave, resizedGrave, resizedGrave, r);\n        grave.setToolTipText(\"Graveyard\");\n        grave.setOpaque(false);\n        grave.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnGraveActionPerformed(null);\n            }\n        });\n\n        exileLabel = new JLabel();\n        exileLabel.setToolTipText(\"Exile\");\n        image = ImageHelper.getImageFromResources(\"/info/exile.png\");\n        r = new Rectangle(21, 21);\n        resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        exileZone = new HoverButton(null, resized, resized, resized, r);\n        exileZone.setToolTipText(\"Exile\");\n        exileZone.setOpaque(false);\n        exileZone.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnExileZoneActionPerformed(null);\n            }\n        });\n        exileZone.setBounds(25, 0, 21, 21);\n\n        // Cheat button\n        r = new Rectangle(25, 21);\n        image = ImageHelper.getImageFromResources(\"/info/cheat.png\");\n        resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        cheat = new JButton();\n        cheat.setIcon(new ImageIcon(resized));\n        cheat.setToolTipText(\"Cheat button\");\n        cheat.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                btnCheatActionPerformed(e);\n            }\n        });\n\n        zonesPanel = new JPanel();\n        zonesPanel.setPreferredSize(new Dimension(100, 20));\n        zonesPanel.setSize(100, 20);\n        zonesPanel.setLayout(null);\n\n        image = ImageHelper.getImageFromResources(\"/info/command_zone.png\");\n        r = new Rectangle(21, 21);\n        resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n        commandZone = new HoverButton(null, resized, resized, resized, r);\n        commandZone.setToolTipText(\"Command Zone (Commander and Emblems)\");\n        commandZone.setOpaque(false);\n        commandZone.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnCommandZoneActionPerformed(null);\n            }\n        });\n        commandZone.setBounds(5, 0, 21, 21);\n        zonesPanel.add(commandZone);\n\n        cheat.setBounds(28, 0, 25, 21);\n        zonesPanel.add(cheat);\n\n        btnPlayer = new JButton();\n        btnPlayer.setText(\"Player\");\n        btnPlayer.setVisible(false);\n        btnPlayer.setToolTipText(\"Player\");\n        btnPlayer.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                session.sendPlayerUUID(gameId, playerId);\n            }\n        });\n\n        // Add mana symbols\n        JLabel manaCountLabelW = new JLabel();\n        manaCountLabelW.setToolTipText(\"White mana\");\n        manaCountLabelW.setText(\"0\");\n        manaLabels.put(\"W\", manaCountLabelW);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaW = ManaSymbols.getManaSymbolImageSmall(\"W\");\n        HoverButton btnWhiteMana = new HoverButton(null, imageManaW, imageManaW, imageManaW, r);\n        btnWhiteMana.setToolTipText(\"White mana\");\n        btnWhiteMana.setOpaque(false);\n        btnWhiteMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.WHITE);\n            }\n        });\n\n        JLabel manaCountLabelU = new JLabel();\n        manaCountLabelU.setToolTipText(\"Blue mana\");\n        manaCountLabelU.setText(\"0\");\n        manaLabels.put(\"U\", manaCountLabelU);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaU = ManaSymbols.getManaSymbolImageSmall(\"U\");\n        HoverButton btnBlueMana = new HoverButton(null, imageManaU, imageManaU, imageManaU, r);\n        btnBlueMana.setToolTipText(\"Blue mana\");\n        btnBlueMana.setOpaque(false);\n        btnBlueMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.BLUE);\n            }\n        });\n\n        JLabel manaCountLabelB = new JLabel();\n        manaCountLabelB.setToolTipText(\"Black mana\");\n        manaCountLabelB.setText(\"0\");\n        manaLabels.put(\"B\", manaCountLabelB);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaB = ManaSymbols.getManaSymbolImageSmall(\"B\");\n        HoverButton btnBlackMana = new HoverButton(null, imageManaB, imageManaB, imageManaB, r);\n        btnBlackMana.setToolTipText(\"Black mana\");\n        btnBlackMana.setOpaque(false);\n        btnBlackMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.BLACK);\n            }\n        });\n\n        JLabel manaCountLabelR = new JLabel();\n        manaCountLabelR.setToolTipText(\"Red mana\");\n        manaCountLabelR.setText(\"0\");\n        manaLabels.put(\"R\", manaCountLabelR);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaR = ManaSymbols.getManaSymbolImageSmall(\"R\");\n        HoverButton btnRedMana = new HoverButton(null, imageManaR, imageManaR, imageManaR, r);\n        btnRedMana.setToolTipText(\"Red mana\");\n        btnRedMana.setOpaque(false);\n        btnRedMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.RED);\n            }\n        });\n\n        JLabel manaCountLabelG = new JLabel();\n        manaCountLabelG.setToolTipText(\"Green mana\");\n        manaCountLabelG.setText(\"0\");\n        manaLabels.put(\"G\", manaCountLabelG);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaG = ManaSymbols.getManaSymbolImageSmall(\"G\");\n        HoverButton btnGreenMana = new HoverButton(null, imageManaG, imageManaG, imageManaG, r);\n        btnGreenMana.setToolTipText(\"Green mana\");\n        btnGreenMana.setOpaque(false);\n        btnGreenMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.GREEN);\n            }\n        });\n\n        JLabel manaCountLabelX = new JLabel();\n        manaCountLabelX.setToolTipText(\"Colorless mana\");\n        manaCountLabelX.setText(\"0\");\n        manaLabels.put(\"X\", manaCountLabelX);\n        r = new Rectangle(12, 12);\n        BufferedImage imageManaX = ManaSymbols.getManaSymbolImageSmall(\"X\");\n        HoverButton btnColorlessMana = new HoverButton(null, imageManaX, imageManaX, imageManaX, r);\n        btnColorlessMana.setToolTipText(\"Colorless mana\");\n        btnColorlessMana.setOpaque(false);\n        btnColorlessMana.setObserver(new Command() {\n            @Override\n            public void execute() {\n                btnManaActionPerformed(ManaType.COLORLESS);\n            }\n        });\n\n        GroupLayout gl_panelBackground = new GroupLayout(panelBackground);\n        gl_panelBackground.setHorizontalGroup(\n                gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(9)\n                        .addComponent(life, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE)\n                        .addGap(3)\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(18)\n                                        .addComponent(hand, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(lifeLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                        .addGap(4)\n                        .addComponent(handLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE))\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(9)\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(3)\n                                        .addComponent(poison, GroupLayout.PREFERRED_SIZE, 14, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(2)\n                                        .addComponent(btnWhiteMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(2)\n                                        .addComponent(btnBlueMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(2)\n                                        .addComponent(btnBlackMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(grave, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE)\n                        )\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(18)\n                                                        .addComponent(library, GroupLayout.PREFERRED_SIZE, 19, GroupLayout.PREFERRED_SIZE))\n                                                .addComponent(poisonLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(20)\n                                                        .addComponent(btnRedMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(1)\n                                                        .addComponent(manaCountLabelW, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE)))\n                                        .addGap(3)\n                                        .addComponent(manaCountLabelR, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addComponent(manaCountLabelB, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(19)\n                                                        .addComponent(btnColorlessMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)))\n                                        .addGap(5)\n                                        .addComponent(manaCountLabelX, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(20)\n                                        .addComponent(btnGreenMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(40)\n                                        .addComponent(manaCountLabelG, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(40)\n                                        .addComponent(libraryLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                                /*.addGroup(gl_panelBackground.createSequentialGroup()\n                                 .addGap(18)\n                                 .addComponent(cheat, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))*/\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(18)\n                                        .addComponent(exileZone, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE)\n                                )\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(5)\n                                        .addComponent(graveLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(40)\n                                        .addComponent(exileLabel, GroupLayout.PREFERRED_SIZE, 25, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addComponent(manaCountLabelU, GroupLayout.PREFERRED_SIZE, MANA_LABEL_SIZE_HORIZONTAL, GroupLayout.PREFERRED_SIZE))))\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(6)\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addComponent(btnPlayer, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(timerLabel, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(avatar, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE))\n                        //                        .addGroup(gl_panelBackground.createSequentialGroup()\n                        //                                .addComponent(avatarFlag, GroupLayout.PREFERRED_SIZE, 16, GroupLayout.PREFERRED_SIZE))\n                        .addGap(14))\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(6)\n                        .addComponent(zonesPanel, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE)\n                        .addGap(14))\n        );\n        gl_panelBackground.setVerticalGroup(\n                gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                .addGroup(gl_panelBackground.createSequentialGroup()\n                        .addGap(6)\n                        .addComponent(avatar, GroupLayout.PREFERRED_SIZE, 80, GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(ComponentPlacement.RELATED)\n                        .addComponent(btnPlayer)\n                        .addComponent(timerLabel)\n                        .addGap(1)\n                        // Life & Hand\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addComponent(life, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(1)\n                                        .addComponent(hand, GroupLayout.PREFERRED_SIZE, 18, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(lifeLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE)\n                                .addComponent(handLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE))\n                        .addGap(1)\n                        // Poison\n                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(4)\n                                        .addComponent(poison, GroupLayout.PREFERRED_SIZE, 14, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(4)\n                                        .addComponent(btnWhiteMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(2)\n                                        .addComponent(btnBlueMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(2)\n                                        .addComponent(btnBlackMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE)\n                                        .addGap(5)\n                                        .addComponent(grave, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE)\n                                )\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                                        .addGap(1)\n                                                                        .addComponent(library, GroupLayout.PREFERRED_SIZE, 19, GroupLayout.PREFERRED_SIZE))\n                                                                .addComponent(poisonLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE))\n                                                        .addGap(2)\n                                                        .addComponent(btnRedMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(14)\n                                                        .addComponent(manaCountLabelW, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(14)\n                                                        .addComponent(manaCountLabelR, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)))\n                                        .addGap(4)\n                                        .addGroup(gl_panelBackground.createParallelGroup(Alignment.LEADING)\n                                                .addComponent(manaCountLabelB, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)\n                                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                                        .addGap(8)\n                                                        .addComponent(btnColorlessMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                                .addComponent(manaCountLabelX, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(39)\n                                        .addComponent(btnGreenMana, GroupLayout.PREFERRED_SIZE, 15, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(31)\n                                        .addComponent(manaCountLabelG, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE))\n                                .addComponent(libraryLabel, GroupLayout.PREFERRED_SIZE, 20, GroupLayout.PREFERRED_SIZE)\n                                /*.addGroup(gl_panelBackground.createSequentialGroup()\n                                 .addGap(76)\n                                 .addComponent(cheat, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE))*/\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(76)\n                                        .addComponent(exileZone, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE)\n                                )\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(76)\n                                        .addComponent(graveLabel, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(76)\n                                        .addComponent(exileLabel, GroupLayout.PREFERRED_SIZE, 21, GroupLayout.PREFERRED_SIZE))\n                                .addGroup(gl_panelBackground.createSequentialGroup()\n                                        .addGap(31)\n                                        .addComponent(manaCountLabelU, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)\n                                )\n                        )\n                        .addPreferredGap(ComponentPlacement.RELATED)\n                        .addComponent(zonesPanel, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE)\n                )\n        );\n        panelBackground.setLayout(gl_panelBackground);\n        GroupLayout groupLayout = new GroupLayout(this);\n        groupLayout.setHorizontalGroup(\n                groupLayout.createParallelGroup(Alignment.LEADING)\n                .addGroup(groupLayout.createSequentialGroup()\n                        .addComponent(panelBackground, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE))\n        );\n        groupLayout.setVerticalGroup(\n                groupLayout.createParallelGroup(Alignment.LEADING)\n                .addGroup(groupLayout.createSequentialGroup()\n                        .addComponent(panelBackground, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE))\n        );\n        setLayout(groupLayout);\n\n    }","commit_id":"7a90db7995de71905003751786858b7681a88f3e","url":"https://github.com/magefree/mage"},{"original_method":"public void update(PlayerView player) {\n        this.player = player;\n        int playerLife = player.getLife();\n        if (playerLife > 99) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(9f);\n            lifeLabel.setFont(font);\n            changedFontLife = true;\n        } else if (changedFontLife) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(12f);\n            lifeLabel.setFont(font);\n            changedFontLife = false;\n        }\n        lifeLabel.setText(Integer.toString(playerLife));\n        poisonLabel.setText(Integer.toString(player.getPoison()));\n        handLabel.setText(Integer.toString(player.getHandCount()));\n        int libraryCards = player.getLibraryCount();\n        if (libraryCards > 99) {\n            Font font = libraryLabel.getFont();\n            font = font.deriveFont(9f);\n            libraryLabel.setFont(font);\n            changedFontLibrary = true;\n        } else if (changedFontLibrary) {\n            Font font = libraryLabel.getFont();\n            font = font.deriveFont(12f);\n            libraryLabel.setFont(font);\n            changedFontLibrary = false;\n        }\n        libraryLabel.setText(Integer.toString(libraryCards));\n\n        int graveCards = player.getGraveyard().size();\n        if (graveCards > 99) {\n            if (!changedFontGrave) {\n                Font font = graveLabel.getFont();\n                font = font.deriveFont(9f);\n                graveLabel.setFont(font);\n                changedFontGrave = true;\n            }\n        } else if (changedFontGrave) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(12f);\n            graveLabel.setFont(font);\n            changedFontGrave = false;\n        }\n        graveLabel.setText(Integer.toString(graveCards));\n\n        int exileCards = player.getExile().size();\n        if (exileCards > 99) {\n            if (!changedFontExile) {\n                Font font = exileLabel.getFont();\n                font = font.deriveFont(9f);\n                exileLabel.setFont(font);\n                changedFontExile = true;\n            }\n        } else if (changedFontExile) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(12f);\n            exileLabel.setFont(font);\n            changedFontExile = false;\n        }\n        exileLabel.setText(Integer.toString(exileCards));\n\n        if (!MageFrame.isLite()) {\n            int id = player.getUserData().getAvatarId();\n            if (id <= 0) {\n                id = PreferencesDialog.DEFAULT_AVATAR_ID;\n            }\n            if (id != avatarId) {\n                avatarId = id;\n                String path = \"/avatars/\" + String.valueOf(avatarId) + \".jpg\";\n                if (avatarId == 64) {\n                    path = \"/avatars/i64.jpg\";\n                } else if (avatarId >= 1000) {\n                    avatarId = avatarId - 1000;\n                    path = \"/avatars/special/\" + String.valueOf(avatarId) + \".gif\";\n                }\n                Image image = ImageHelper.getImageFromResources(path);\n                Rectangle r = new Rectangle(80, 80);\n                BufferedImage resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n                this.avatar.update(\"player\", resized, resized, resized, resized, r);\n            }\n            if (!player.getUserData().getFlagName().equals(flagName)) {\n                flagName = player.getUserData().getFlagName();\n                this.avatarFlag.setIcon(CountryUtil.getCountryFlagIcon(flagName));\n                this.avatarFlag.setToolTipText(CountryUtil.getCountryName(flagName));\n                avatar.repaint();\n            }\n        }\n        this.avatar.setText(player.getName());\n        if (this.timer != null) {\n            if (player.getPriorityTimeLeft() != Integer.MAX_VALUE) {\n                String priorityTimeValue = getPriorityTimeLeftString(player);\n                this.timer.setCount(player.getPriorityTimeLeft());\n                this.avatar.setTopText(priorityTimeValue);\n                this.timerLabel.setText(priorityTimeValue);\n            }\n            if (player.isTimerActive()) {\n                this.timer.resume();\n            } else {\n                this.timer.pause();\n            }\n        }\n\n        this.btnPlayer.setText(player.getName());\n        this.btnPlayer.setToolTipText(\"Life: \" + player.getLife());\n        if (player.isActive()) {\n            this.avatar.setBorder(greenBorder);\n            this.btnPlayer.setBorder(greenBorder);\n        } else if (player.hasLeft()) {\n            this.avatar.setBorder(redBorder);\n            this.btnPlayer.setBorder(redBorder);\n        } else {\n            this.avatar.setBorder(emptyBorder);\n            this.btnPlayer.setBorder(emptyBorder);\n        }\n\n        update(player.getManaPool());\n    }","id":98880,"modified_method":"public void update(PlayerView player) {\n        this.player = player;\n        if (flagName == null) { // do only once\n            avatar.setText(this.player.getName());\n            if (!player.getUserData().getFlagName().equals(flagName)) {\n                flagName = player.getUserData().getFlagName();\n                this.avatar.setTopTextImage(CountryUtil.getCountryFlagIcon(flagName).getImage());\n            }\n            // TODO: Add the wins to the tooltiptext of the avatar\n            String countryname = CountryUtil.getCountryName(flagName);\n            if (countryname == null) {\n                countryname = \"Unknown\";\n            }\n            String tooltip = \"<HTML>Name: \" + player.getName() + \"<br/>Country: \" + countryname;\n            avatar.setToolTipText(tooltip);\n            avatar.repaint();\n\n            // used if avatar image can't be used\n            this.btnPlayer.setText(player.getName());\n            this.btnPlayer.setToolTipText(tooltip);\n        }\n        int playerLife = player.getLife();\n        if (playerLife > 99) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(9f);\n            lifeLabel.setFont(font);\n            changedFontLife = true;\n        } else if (changedFontLife) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(12f);\n            lifeLabel.setFont(font);\n            changedFontLife = false;\n        }\n        lifeLabel.setText(Integer.toString(playerLife));\n        poisonLabel.setText(Integer.toString(player.getPoison()));\n        handLabel.setText(Integer.toString(player.getHandCount()));\n        int libraryCards = player.getLibraryCount();\n        if (libraryCards > 99) {\n            Font font = libraryLabel.getFont();\n            font = font.deriveFont(9f);\n            libraryLabel.setFont(font);\n            changedFontLibrary = true;\n        } else if (changedFontLibrary) {\n            Font font = libraryLabel.getFont();\n            font = font.deriveFont(12f);\n            libraryLabel.setFont(font);\n            changedFontLibrary = false;\n        }\n        libraryLabel.setText(Integer.toString(libraryCards));\n\n        int graveCards = player.getGraveyard().size();\n        if (graveCards > 99) {\n            if (!changedFontGrave) {\n                Font font = graveLabel.getFont();\n                font = font.deriveFont(9f);\n                graveLabel.setFont(font);\n                changedFontGrave = true;\n            }\n        } else if (changedFontGrave) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(12f);\n            graveLabel.setFont(font);\n            changedFontGrave = false;\n        }\n        graveLabel.setText(Integer.toString(graveCards));\n\n        int exileCards = player.getExile().size();\n        if (exileCards > 99) {\n            if (!changedFontExile) {\n                Font font = exileLabel.getFont();\n                font = font.deriveFont(9f);\n                exileLabel.setFont(font);\n                changedFontExile = true;\n            }\n        } else if (changedFontExile) {\n            Font font = lifeLabel.getFont();\n            font = font.deriveFont(12f);\n            exileLabel.setFont(font);\n            changedFontExile = false;\n        }\n        exileLabel.setText(Integer.toString(exileCards));\n\n        if (!MageFrame.isLite()) {\n            int id = player.getUserData().getAvatarId();\n            if (id <= 0) {\n                id = PreferencesDialog.DEFAULT_AVATAR_ID;\n            }\n            if (id != avatarId) {\n                avatarId = id;\n                String path = \"/avatars/\" + String.valueOf(avatarId) + \".jpg\";\n                if (avatarId == 64) {\n                    path = \"/avatars/i64.jpg\";\n                } else if (avatarId >= 1000) {\n                    avatarId = avatarId - 1000;\n                    path = \"/avatars/special/\" + String.valueOf(avatarId) + \".gif\";\n                }\n                Image image = ImageHelper.getImageFromResources(path);\n                Rectangle r = new Rectangle(80, 80);\n                BufferedImage resized = ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image, BufferedImage.TYPE_INT_ARGB), r);\n                this.avatar.update(this.player.getName(), resized, resized, resized, resized, r);\n            }\n        }\n        if (this.timer != null) {\n            if (player.getPriorityTimeLeft() != Integer.MAX_VALUE) {\n                String priorityTimeValue = getPriorityTimeLeftString(player);\n                this.timer.setCount(player.getPriorityTimeLeft());\n                this.avatar.setTopText(priorityTimeValue);\n                this.timerLabel.setText(priorityTimeValue);\n            }\n            if (player.isTimerActive()) {\n                this.timer.resume();\n            } else {\n                this.timer.pause();\n            }\n        }\n\n        if (player.isActive()) {\n            this.avatar.setBorder(greenBorder);\n            this.btnPlayer.setBorder(greenBorder);\n        } else if (player.hasLeft()) {\n            this.avatar.setBorder(redBorder);\n            this.btnPlayer.setBorder(redBorder);\n        } else {\n            this.avatar.setBorder(emptyBorder);\n            this.btnPlayer.setBorder(emptyBorder);\n        }\n\n        update(player.getManaPool());\n    }","commit_id":"7a90db7995de71905003751786858b7681a88f3e","url":"https://github.com/magefree/mage"},{"original_method":"public void init(UUID gameId, UUID playerId, BigCard bigCard, int priorityTime) {\n        this.gameId = gameId;\n        this.playerId = playerId;\n        this.bigCard = bigCard;\n        session = MageFrame.getSession();\n        cheat.setVisible(session.isTestMode());\n        cheat.setFocusable(false);\n\n        if (priorityTime > 0) {\n            long delay = 1000L;\n\n            timer = new PriorityTimer(priorityTime, delay, new mage.interfaces.Action() {\n                @Override\n                public void execute() throws MageException {\n                    // do nothing\n                }\n            });\n            final PriorityTimer pt = timer;\n            timer.setTaskOnTick(new mage.interfaces.Action() {\n                @Override\n                public void execute() throws MageException {\n                    int priorityTimeValue = pt.getCount();\n                    String text = getPriorityTimeLeftString(priorityTimeValue);\n                    PlayerPanelExt.this.avatar.setTopText(text);\n                    PlayerPanelExt.this.timerLabel.setText(text);\n                    PlayerPanelExt.this.avatar.repaint();\n                }\n            });\n            timer.init(gameId);\n        }\n    }","id":98881,"modified_method":"public void init(UUID gameId, UUID playerId, BigCard bigCard, int priorityTime) {\n        this.gameId = gameId;\n        this.playerId = playerId;\n        this.bigCard = bigCard;\n        session = MageFrame.getSession();\n        cheat.setVisible(session.isTestMode());\n        cheat.setFocusable(false);\n        flagName = null;\n        if (priorityTime > 0) {\n            long delay = 1000L;\n\n            timer = new PriorityTimer(priorityTime, delay, new mage.interfaces.Action() {\n                @Override\n                public void execute() throws MageException {\n                    // do nothing\n                }\n            });\n            final PriorityTimer pt = timer;\n            timer.setTaskOnTick(new mage.interfaces.Action() {\n                @Override\n                public void execute() throws MageException {\n                    int priorityTimeValue = pt.getCount();\n                    String text = getPriorityTimeLeftString(priorityTimeValue);\n                    PlayerPanelExt.this.avatar.setTopText(text);\n                    PlayerPanelExt.this.timerLabel.setText(text);\n                    PlayerPanelExt.this.avatar.repaint();\n                }\n            });\n            timer.init(gameId);\n        }\n    }","commit_id":"7a90db7995de71905003751786858b7681a88f3e","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * merges the primitives in dataset <code>from<\/code> into the dataset of\n     * this layer\n     *\n     * @param from  the source data set\n     */\n    public void mergeFrom(final DataSet from, ProgressMonitor progressMonitor) {\n        final DataSetMerger visitor = new DataSetMerger(data,from);\n        try {\n            visitor.merge(progressMonitor);\n        } catch (DataIntegrityProblemException e) {\n            JOptionPane.showMessageDialog(\n                    Main.parent,\n                    e.getHtmlMessage() != null ? e.getHtmlMessage() : e.getMessage(),\n                    tr(\"Error\"),\n                    JOptionPane.ERROR_MESSAGE\n            );\n            return;\n\n        }\n\n        Area a = data.getDataSourceArea();\n\n        // copy the merged layer's data source info;\n        // only add source rectangles if they are not contained in the\n        // layer already.\n        for (DataSource src : from.dataSources) {\n            if (a == null || !a.contains(src.bounds.asRect())) {\n                data.dataSources.add(src);\n            }\n        }\n\n        // copy the merged layer's API version, downgrade if required\n        if (data.getVersion() == null) {\n            data.setVersion(from.getVersion());\n        } else if (\"0.5\".equals(data.getVersion()) ^ \"0.5\".equals(from.getVersion())) {\n            System.err.println(tr(\"Warning: mixing 0.6 and 0.5 data results in version 0.5\"));\n            data.setVersion(\"0.5\");\n        }\n\n        int numNewConflicts = 0;\n        for (Conflict<?> c : visitor.getConflicts()) {\n            if (!conflicts.hasConflict(c)) {\n                numNewConflicts++;\n                conflicts.add(c);\n            }\n        }\n        // repaint to make sure new data is displayed properly.\n        Main.map.mapView.repaint();\n        warnNumNewConflicts(numNewConflicts);\n    }","id":98882,"modified_method":"/**\n     * merges the primitives in dataset <code>from<\/code> into the dataset of\n     * this layer\n     *\n     * @param from  the source data set\n     */\n    public void mergeFrom(final DataSet from, ProgressMonitor progressMonitor) {\n        final DataSetMerger visitor = new DataSetMerger(data,from);\n        try {\n            visitor.merge(progressMonitor);\n        } catch (DataIntegrityProblemException e) {\n            JOptionPane.showMessageDialog(\n                    Main.parent,\n                    e.getHtmlMessage() != null ? e.getHtmlMessage() : e.getMessage(),\n                    tr(\"Error\"),\n                    JOptionPane.ERROR_MESSAGE\n            );\n            return;\n\n        }\n\n        Area a = data.getDataSourceArea();\n\n        // copy the merged layer's data source info;\n        // only add source rectangles if they are not contained in the\n        // layer already.\n        for (DataSource src : from.dataSources) {\n            if (a == null || !a.contains(src.bounds.asRect())) {\n                data.dataSources.add(src);\n            }\n        }\n\n        // copy the merged layer's API version, downgrade if required\n        if (data.getVersion() == null) {\n            data.setVersion(from.getVersion());\n        } else if (\"0.5\".equals(data.getVersion()) ^ \"0.5\".equals(from.getVersion())) {\n            System.err.println(tr(\"Warning: mixing 0.6 and 0.5 data results in version 0.5\"));\n            data.setVersion(\"0.5\");\n        }\n\n        int numNewConflicts = 0;\n        for (Conflict<?> c : visitor.getConflicts()) {\n            if (!conflicts.hasConflict(c)) {\n                numNewConflicts++;\n                conflicts.add(c);\n            }\n        }\n        // repaint to make sure new data is displayed properly.\n        if (Main.map != null && Main.map.mapView != null) {\n            Main.map.mapView.repaint();\n        }\n        warnNumNewConflicts(numNewConflicts);\n    }","commit_id":"a4fd666213be3f7da432da5b3c720ce3c38842e6","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        Main.pref.put(\"draw.rawgps.lines\", !Main.pref.getBoolean(\"draw.rawgps.lines\"));\n        Main.map.mapView.repaint();\n    }","id":98883,"modified_method":"public void actionPerformed(ActionEvent e) {\n        Main.pref.put(\"draw.rawgps.lines\", !Main.pref.getBoolean(\"draw.rawgps.lines\"));\n        if(Main.map != null)\n            Main.map.mapView.repaint();\n    }","commit_id":"459e168908e9d18ba7633031708ced5250768b5e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void valueChanged(TreeSelectionEvent e) {\n            fixButton.setEnabled(false);\n            if (ignoreButton != null) {\n                ignoreButton.setEnabled(false);\n            }\n            selectButton.setEnabled(false);\n\n            boolean hasFixes = setSelection(null, false);\n            fixButton.setEnabled(hasFixes);\n            Main.map.repaint();\n        }","id":98884,"modified_method":"@Override\n        public void valueChanged(TreeSelectionEvent e) {\n            fixButton.setEnabled(false);\n            if (ignoreButton != null) {\n                ignoreButton.setEnabled(false);\n            }\n            selectButton.setEnabled(false);\n\n            boolean hasFixes = setSelection(null, false);\n            fixButton.setEnabled(hasFixes);\n            if (Main.map != null) {\n                Main.map.repaint();\n            }\n        }","commit_id":"fd3bc0de331606dff4e5aa383f19e1392e762fbe","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public synchronized void tileLoadingFinished(Tile tile, boolean success) {\n        if (tile.hasError()) {\n            success = false;\n            tile.setImage(null);\n        }\n        if (sharpenLevel != 0 && success) {\n            tile.setImage(sharpenImage(tile.getImage()));\n        }\n        tile.setLoaded(true);\n        needRedraw = true;\n        Main.map.repaint(100);\n        tileRequestsOutstanding.remove(tile);\n        if (Main.isDebugEnabled()) {\n            Main.debug(\"tileLoadingFinished() tile: \" + tile + \" success: \" + success);\n        }\n    }","id":98885,"modified_method":"@Override\n    public synchronized void tileLoadingFinished(Tile tile, boolean success) {\n        if (tile.hasError()) {\n            success = false;\n            tile.setImage(null);\n        }\n        if (sharpenLevel != 0 && success) {\n            tile.setImage(sharpenImage(tile.getImage()));\n        }\n        tile.setLoaded(true);\n        needRedraw = true;\n        if (Main.map != null) {\n            Main.map.repaint(100);\n        }\n        tileRequestsOutstanding.remove(tile);\n        if (Main.isDebugEnabled()) {\n            Main.debug(\"tileLoadingFinished() tile: \" + tile + \" success: \" + success);\n        }\n    }","commit_id":"3532da8f50ab029cc1492658b324cc92149fadb2","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void actionPerformed(ActionEvent arg0) {\n        final JPanel msg = new JPanel(new GridBagLayout());\n\n        dateFilter = new DateFilterPanel(layer, \"gpx.traces\", false);\n        dateFilter.setFilterAppliedListener(new ActionListener() {\n            @Override public void actionPerformed(ActionEvent e) {\n                noUpdates = true;\n                selectVisibleTracksInTable();\n                noUpdates = false;\n                Main.map.mapView.preferenceChanged(null);\n                Main.map.repaint(100);\n            }\n        });\n        dateFilter.loadFromPrefs();\n\n        final JToggleButton b = new JToggleButton(new AbstractAction(tr(\"Select by date\")) {\n            @Override public void actionPerformed(ActionEvent e) {\n                if (((JToggleButton) e.getSource()).isSelected()) {\n                    dateFilter.setEnabled(true);\n                    dateFilter.applyFilter();\n                } else {\n                    dateFilter.setEnabled(false);\n                }\n            }\n        });\n        dateFilter.setEnabled(false);\n        msg.add(b, GBC.std().insets(0, 0, 5, 0));\n        msg.add(dateFilter, GBC.eol().insets(0, 0, 10, 0).fill(GBC.HORIZONTAL));\n\n        msg.add(new JLabel(tr(\"<html>Select all tracks that you want to be displayed. \" +\n                \"You can drag select a range of tracks or use CTRL+Click to select specific ones. \" +\n                \"The map is updated live in the background. Open the URLs by double clicking them.<\/html>\")),\n                GBC.eop().fill(GBC.HORIZONTAL));\n        // build table\n        final boolean[] trackVisibilityBackup = layer.trackVisibility.clone();\n        table = buildTable(buildTableContents());\n        selectVisibleTracksInTable();\n        listenToSelectionChanges();\n        // make the table scrollable\n        JScrollPane scrollPane = new JScrollPane(table);\n        msg.add(scrollPane, GBC.eol().fill(GBC.BOTH));\n\n        // build dialog\n        ExtendedDialog ed = new ExtendedDialog(Main.parent, tr(\"Set track visibility for {0}\", layer.getName()),\n                new String[]{tr(\"Show all\"), tr(\"Show selected only\"), tr(\"Cancel\")});\n        ed.setButtonIcons(new String[]{\"eye\", \"dialogs/filter\", \"cancel\"});\n        ed.setContent(msg, false);\n        ed.setDefaultButton(2);\n        ed.setCancelButton(3);\n        ed.configureContextsensitiveHelp(\"/Action/ChooseTrackVisibility\", true);\n        ed.setRememberWindowGeometry(getClass().getName() + \".geometry\", WindowGeometry.centerInWindow(Main.parent, new Dimension(1000, 500)));\n        ed.showDialog();\n        dateFilter.saveInPrefs();\n        int v = ed.getValue();\n        // cancel for unknown buttons and copy back original settings\n        if (v != 1 && v != 2) {\n            layer.trackVisibility = Arrays.copyOf(trackVisibilityBackup, layer.trackVisibility.length);\n            Main.map.repaint();\n            return;\n        }\n        // set visibility (1 = show all, 2 = filter). If no tracks are selected\n        // set all of them visible and...\n        ListSelectionModel s = table.getSelectionModel();\n        final boolean all = v == 1 || s.isSelectionEmpty();\n        for (int i = 0; i < layer.trackVisibility.length; i++) {\n            layer.trackVisibility[table.convertRowIndexToModel(i)] = all || s.isSelectedIndex(i);\n        }\n        // ...sync with layer visibility instead to avoid having two ways to hide everything\n        layer.setVisible(v == 1 || !s.isSelectionEmpty());\n\n        Main.map.mapView.preferenceChanged(null);\n        Main.map.repaint();\n    }","id":98886,"modified_method":"@Override\n    public void actionPerformed(ActionEvent arg0) {\n        final JPanel msg = new JPanel(new GridBagLayout());\n\n        dateFilter = new DateFilterPanel(layer, \"gpx.traces\", false);\n        dateFilter.setFilterAppliedListener(new ActionListener() {\n            @Override public void actionPerformed(ActionEvent e) {\n                noUpdates = true;\n                selectVisibleTracksInTable();\n                noUpdates = false;\n                Main.map.mapView.preferenceChanged(null);\n                Main.map.repaint(100);\n            }\n        });\n        dateFilter.loadFromPrefs();\n\n        final JToggleButton b = new JToggleButton(new AbstractAction(tr(\"Select by date\")) {\n            @Override public void actionPerformed(ActionEvent e) {\n                if (((JToggleButton) e.getSource()).isSelected()) {\n                    dateFilter.setEnabled(true);\n                    dateFilter.applyFilter();\n                } else {\n                    dateFilter.setEnabled(false);\n                }\n            }\n        });\n        dateFilter.setEnabled(false);\n        msg.add(b, GBC.std().insets(0, 0, 5, 0));\n        msg.add(dateFilter, GBC.eol().insets(0, 0, 10, 0).fill(GBC.HORIZONTAL));\n\n        msg.add(new JLabel(tr(\"<html>Select all tracks that you want to be displayed. \" +\n                \"You can drag select a range of tracks or use CTRL+Click to select specific ones. \" +\n                \"The map is updated live in the background. Open the URLs by double clicking them.<\/html>\")),\n                GBC.eop().fill(GBC.HORIZONTAL));\n        // build table\n        final boolean[] trackVisibilityBackup = layer.trackVisibility.clone();\n        table = buildTable(buildTableContents());\n        selectVisibleTracksInTable();\n        listenToSelectionChanges();\n        // make the table scrollable\n        JScrollPane scrollPane = new JScrollPane(table);\n        msg.add(scrollPane, GBC.eol().fill(GBC.BOTH));\n\n        int v = 1;\n        if (!GraphicsEnvironment.isHeadless()) {\n            // build dialog\n            ExtendedDialog ed = new ExtendedDialog(Main.parent, tr(\"Set track visibility for {0}\", layer.getName()),\n                    new String[]{tr(\"Show all\"), tr(\"Show selected only\"), tr(\"Cancel\")});\n            ed.setButtonIcons(new String[]{\"eye\", \"dialogs/filter\", \"cancel\"});\n            ed.setContent(msg, false);\n            ed.setDefaultButton(2);\n            ed.setCancelButton(3);\n            ed.configureContextsensitiveHelp(\"/Action/ChooseTrackVisibility\", true);\n            ed.setRememberWindowGeometry(getClass().getName() + \".geometry\",\n                    WindowGeometry.centerInWindow(Main.parent, new Dimension(1000, 500)));\n            ed.showDialog();\n            dateFilter.saveInPrefs();\n            v = ed.getValue();\n            // cancel for unknown buttons and copy back original settings\n            if (v != 1 && v != 2) {\n                layer.trackVisibility = Arrays.copyOf(trackVisibilityBackup, layer.trackVisibility.length);\n                Main.map.repaint();\n                return;\n            }\n        }\n        // set visibility (1 = show all, 2 = filter). If no tracks are selected\n        // set all of them visible and...\n        ListSelectionModel s = table.getSelectionModel();\n        final boolean all = v == 1 || s.isSelectionEmpty();\n        for (int i = 0; i < layer.trackVisibility.length; i++) {\n            layer.trackVisibility[table.convertRowIndexToModel(i)] = all || s.isSelectedIndex(i);\n        }\n        // ...sync with layer visibility instead to avoid having two ways to hide everything\n        layer.setVisible(v == 1 || !s.isSelectionEmpty());\n\n        if (Main.isDisplayingMapView()) {\n            Main.map.mapView.preferenceChanged(null);\n        }\n        if (Main.map != null) {\n            Main.map.repaint();\n        }\n    }","commit_id":"89db4760f7b3f36a3f33f2435f039a0c3b30d0dc","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Area \"a\" contains the hull that we would like to download data for. however we\n     * can only download rectangles, so the following is an attempt at finding a number of\n     * rectangles to download.\n     *\n     * The idea is simply: Start out with the full bounding box. If it is too large, then\n     * split it in half and repeat recursively for each half until you arrive at something\n     * small enough to download. The algorithm is improved by always using the intersection\n     * between the rectangle and the actual desired area. For example, if you have a track\n     * that goes like this: +----+ | /| | / | | / | |/ | +----+ then we would first look at\n     * downloading the whole rectangle (assume it's too big), after that we split it in half\n     * (upper and lower half), but we donot request the full upper and lower rectangle, only\n     * the part of the upper/lower rectangle that actually has something in it.\n     *\n     * This functions calculates the rectangles, asks the user to continue and downloads\n     * the areas if applicable.\n     *\n     * @param a download area hull\n     * @param maxArea maximum area size for a single download\n     * @param osmDownload Set to true if OSM data should be downloaded\n     * @param gpxDownload Set to true if GPX data should be downloaded\n     * @param title the title string for the confirmation dialog\n     * @param progressMonitor the progress monitor\n     */\n    protected static void confirmAndDownloadAreas(Area a, double maxArea, boolean osmDownload, boolean gpxDownload, String title,\n            ProgressMonitor progressMonitor) {\n        List<Rectangle2D> toDownload = new ArrayList<>();\n        addToDownload(a, a.getBounds(), toDownload, maxArea);\n        if (toDownload.isEmpty()) {\n            return;\n        }\n        JPanel msg = new JPanel(new GridBagLayout());\n        msg.add(new JLabel(\n                tr(\"<html>This action will require {0} individual<br>\" + \"download requests. Do you wish<br>to continue?<\/html>\",\n                        toDownload.size())), GBC.eol());\n        if (JOptionPane.OK_OPTION != JOptionPane.showConfirmDialog(Main.parent, msg, title,\n                JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE)) {\n            return;\n        }\n        final PleaseWaitProgressMonitor monitor = new PleaseWaitProgressMonitor(tr(\"Download data\"));\n        final Future<?> future = new DownloadTaskList().download(false, toDownload, osmDownload, gpxDownload, monitor);\n        Main.worker.submit(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    future.get();\n                } catch (Exception e) {\n                    Main.error(e);\n                    return;\n                }\n                monitor.close();\n            }\n        });\n    }","id":98887,"modified_method":"/**\n     * Area \"a\" contains the hull that we would like to download data for. however we\n     * can only download rectangles, so the following is an attempt at finding a number of\n     * rectangles to download.\n     *\n     * The idea is simply: Start out with the full bounding box. If it is too large, then\n     * split it in half and repeat recursively for each half until you arrive at something\n     * small enough to download. The algorithm is improved by always using the intersection\n     * between the rectangle and the actual desired area. For example, if you have a track\n     * that goes like this: +----+ | /| | / | | / | |/ | +----+ then we would first look at\n     * downloading the whole rectangle (assume it's too big), after that we split it in half\n     * (upper and lower half), but we donot request the full upper and lower rectangle, only\n     * the part of the upper/lower rectangle that actually has something in it.\n     *\n     * This functions calculates the rectangles, asks the user to continue and downloads\n     * the areas if applicable.\n     *\n     * @param a download area hull\n     * @param maxArea maximum area size for a single download\n     * @param osmDownload Set to true if OSM data should be downloaded\n     * @param gpxDownload Set to true if GPX data should be downloaded\n     * @param title the title string for the confirmation dialog\n     * @param progressMonitor the progress monitor\n     */\n    protected static void confirmAndDownloadAreas(Area a, double maxArea, boolean osmDownload, boolean gpxDownload, String title,\n            ProgressMonitor progressMonitor) {\n        List<Rectangle2D> toDownload = new ArrayList<>();\n        addToDownload(a, a.getBounds(), toDownload, maxArea);\n        if (toDownload.isEmpty()) {\n            return;\n        }\n        JPanel msg = new JPanel(new GridBagLayout());\n        msg.add(new JLabel(\n                tr(\"<html>This action will require {0} individual<br>\" + \"download requests. Do you wish<br>to continue?<\/html>\",\n                        toDownload.size())), GBC.eol());\n        if (!GraphicsEnvironment.isHeadless() && JOptionPane.OK_OPTION != JOptionPane.showConfirmDialog(\n                Main.parent, msg, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE)) {\n            return;\n        }\n        final PleaseWaitProgressMonitor monitor = new PleaseWaitProgressMonitor(tr(\"Download data\"));\n        final Future<?> future = new DownloadTaskList().download(false, toDownload, osmDownload, gpxDownload, monitor);\n        Main.worker.submit(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    future.get();\n                } catch (Exception e) {\n                    Main.error(e);\n                    return;\n                }\n                monitor.close();\n            }\n        });\n    }","commit_id":"89db4760f7b3f36a3f33f2435f039a0c3b30d0dc","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Show this panel in a new \"Download along\" help-aware dialog\n     * @param title The dialog title\n     * @param helpTopic The dialog help topic\n     * @return The selected button index (0 for download, 1 for cancel, 2 for dialog closure)\n     */\n    public int showInDownloadDialog(String title, String helpTopic) {\n        final ButtonSpec[] options = new ButtonSpec[] {\n                new ButtonSpec(\n                        tr(\"Download\"),\n                        ImageProvider.get(\"download\"),\n                        tr(\"Click to download\"),\n                        null // no specific help text\n                ),\n                new ButtonSpec(\n                        tr(\"Cancel\"),\n                        ImageProvider.get(\"cancel\"),\n                        tr(\"Click to cancel\"),\n                        null // no specific help text\n                )\n        };\n\n        addChangeListener(new ChangeListener() {\n            @Override public void stateChanged(ChangeEvent e) {\n                options[0].setEnabled(isDownloadOsmData() || isDownloadGpxData());\n            }\n        });\n\n        int ret = HelpAwareOptionPane.showOptionDialog(Main.parent, this, title,\n                JOptionPane.QUESTION_MESSAGE, null, options, options[0], helpTopic);\n        if (0 == ret) {\n            rememberSettings();\n        }\n\n        return ret;\n    }","id":98888,"modified_method":"/**\n     * Show this panel in a new \"Download along\" help-aware dialog\n     * @param title The dialog title\n     * @param helpTopic The dialog help topic\n     * @return The selected button index (0 for download, 1 for cancel, 2 for dialog closure)\n     */\n    public int showInDownloadDialog(String title, String helpTopic) {\n        final ButtonSpec[] options = new ButtonSpec[] {\n                new ButtonSpec(\n                        tr(\"Download\"),\n                        ImageProvider.get(\"download\"),\n                        tr(\"Click to download\"),\n                        null // no specific help text\n                ),\n                new ButtonSpec(\n                        tr(\"Cancel\"),\n                        ImageProvider.get(\"cancel\"),\n                        tr(\"Click to cancel\"),\n                        null // no specific help text\n                )\n        };\n\n        addChangeListener(new ChangeListener() {\n            @Override public void stateChanged(ChangeEvent e) {\n                options[0].setEnabled(isDownloadOsmData() || isDownloadGpxData());\n            }\n        });\n\n        int ret = 0;\n        if (!GraphicsEnvironment.isHeadless()) {\n            ret = HelpAwareOptionPane.showOptionDialog(Main.parent, this, title,\n                    JOptionPane.QUESTION_MESSAGE, null, options, options[0], helpTopic);\n        }\n        if (0 == ret) {\n            rememberSettings();\n        }\n\n        return ret;\n    }","commit_id":"89db4760f7b3f36a3f33f2435f039a0c3b30d0dc","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n\n        final DownloadAlongPanel panel = new DownloadAlongPanel(\n                PREF_DOWNLOAD_ALONG_TRACK_OSM, PREF_DOWNLOAD_ALONG_TRACK_GPS,\n                PREF_DOWNLOAD_ALONG_TRACK_DISTANCE, PREF_DOWNLOAD_ALONG_TRACK_AREA, PREF_DOWNLOAD_ALONG_TRACK_NEAR);\n\n        if (0 != panel.showInDownloadDialog(tr(\"Download from OSM along this track\"), HelpUtil.ht(\"/Action/DownloadAlongTrack\"))) {\n            return;\n        }\n\n        final int near = panel.getNear();\n\n        /*\n         * Find the average latitude for the data we're contemplating, so we can know how many\n         * metres per degree of longitude we have.\n         */\n        double latsum = 0;\n        int latcnt = 0;\n        if (near == NEAR_TRACK || near == NEAR_BOTH) {\n            for (GpxTrack trk : data.tracks) {\n                for (GpxTrackSegment segment : trk.getSegments()) {\n                    for (WayPoint p : segment.getWayPoints()) {\n                        latsum += p.getCoor().lat();\n                        latcnt++;\n                    }\n                }\n            }\n        }\n        if (near == NEAR_WAYPOINTS || near == NEAR_BOTH) {\n            for (WayPoint p : data.waypoints) {\n                latsum += p.getCoor().lat();\n                latcnt++;\n            }\n        }\n        double avglat = latsum / latcnt;\n        double scale = Math.cos(Math.toRadians(avglat));\n        /*\n         * Compute buffer zone extents and maximum bounding box size. Note that the maximum we\n         * ever offer is a bbox area of 0.002, while the API theoretically supports 0.25, but as\n         * soon as you touch any built-up area, that kind of bounding box will download forever\n         * and then stop because it has more than 50k nodes.\n         */\n        final double buffer_dist = panel.getDistance();\n        final double max_area = panel.getArea() / 10000.0 / scale;\n        final double buffer_y = buffer_dist / 100000.0;\n        final double buffer_x = buffer_y / scale;\n        final int totalTicks = latcnt;\n        // guess if a progress bar might be useful.\n        final boolean displayProgress = totalTicks > 2000 && buffer_y < 0.01;\n\n        class CalculateDownloadArea extends PleaseWaitRunnable {\n\n            private final Area a = new Area();\n            private boolean cancel;\n            private int ticks;\n            private final Rectangle2D r = new Rectangle2D.Double();\n\n            CalculateDownloadArea() {\n                super(tr(\"Calculating Download Area\"), displayProgress ? null : NullProgressMonitor.INSTANCE, false);\n            }\n\n            @Override\n            protected void cancel() {\n                cancel = true;\n            }\n\n            @Override\n            protected void finish() {\n            }\n\n            @Override\n            protected void afterFinish() {\n                if (cancel) {\n                    return;\n                }\n                confirmAndDownloadAreas(a, max_area, panel.isDownloadOsmData(), panel.isDownloadGpxData(),\n                        tr(\"Download from OSM along this track\"), progressMonitor);\n            }\n\n            /**\n             * increase tick count by one, report progress every 100 ticks\n             */\n            private void tick() {\n                ticks++;\n                if (ticks % 100 == 0) {\n                    progressMonitor.worked(100);\n                }\n            }\n\n            /**\n             * calculate area for single, given way point and return new LatLon if the\n             * way point has been used to modify the area.\n             */\n            private LatLon calcAreaForWayPoint(WayPoint p, LatLon previous) {\n                tick();\n                LatLon c = p.getCoor();\n                if (previous == null || c.greatCircleDistance(previous) > buffer_dist) {\n                    // we add a buffer around the point.\n                    r.setRect(c.lon() - buffer_x, c.lat() - buffer_y, 2 * buffer_x, 2 * buffer_y);\n                    a.add(new Area(r));\n                    return c;\n                }\n                return previous;\n            }\n\n            @Override\n            protected void realRun() {\n                progressMonitor.setTicksCount(totalTicks);\n                /*\n                 * Collect the combined area of all gpx points plus buffer zones around them. We ignore\n                 * points that lie closer to the previous point than the given buffer size because\n                 * otherwise this operation takes ages.\n                 */\n                LatLon previous = null;\n                if (near == NEAR_TRACK || near == NEAR_BOTH) {\n                    for (GpxTrack trk : data.tracks) {\n                        for (GpxTrackSegment segment : trk.getSegments()) {\n                            for (WayPoint p : segment.getWayPoints()) {\n                                if (cancel) {\n                                    return;\n                                }\n                                previous = calcAreaForWayPoint(p, previous);\n                            }\n                        }\n                    }\n                }\n                if (near == NEAR_WAYPOINTS || near == NEAR_BOTH) {\n                    for (WayPoint p : data.waypoints) {\n                        if (cancel) {\n                            return;\n                        }\n                        previous = calcAreaForWayPoint(p, previous);\n                    }\n                }\n            }\n        }\n\n        Main.worker.submit(new CalculateDownloadArea());\n    }","id":98889,"modified_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n        Main.worker.submit(createTask());\n    }","commit_id":"89db4760f7b3f36a3f33f2435f039a0c3b30d0dc","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void finishRequest(WMSRequest request) {\n        requestQueueLock.lock();\n        try {\n            PrecacheTask task = request.getPrecacheTask();\n            if (task != null) {\n                task.processedCount++;\n                if (!task.progressMonitor.isCanceled()) {\n                    task.progressMonitor.worked(1);\n                    task.progressMonitor.setCustomText(tr(\"Downloaded {0}/{1} tiles\", task.processedCount, task.totalCount));\n                }\n            }\n            processingRequests.remove(request);\n            if (request.getState() != null && !request.isPrecacheOnly()) {\n                finishedRequests.add(request);\n                Main.map.mapView.repaint();\n            }\n        } finally {\n            requestQueueLock.unlock();\n        }\n    }","id":98890,"modified_method":"public void finishRequest(WMSRequest request) {\n        requestQueueLock.lock();\n        try {\n            PrecacheTask task = request.getPrecacheTask();\n            if (task != null) {\n                task.processedCount++;\n                if (!task.progressMonitor.isCanceled()) {\n                    task.progressMonitor.worked(1);\n                    task.progressMonitor.setCustomText(tr(\"Downloaded {0}/{1} tiles\", task.processedCount, task.totalCount));\n                }\n            }\n            processingRequests.remove(request);\n            if (request.getState() != null && !request.isPrecacheOnly()) {\n                finishedRequests.add(request);\n                if (Main.map != null && Main.map.mapView != null) {\n                    Main.map.mapView.repaint();\n                }\n            }\n        } finally {\n            requestQueueLock.unlock();\n        }\n    }","commit_id":"7e53fa9f133fc4c16a1a813051986f055bc73b21","url":"https://github.com/openstreetmap/josm"},{"original_method":"public <T> void addAll(@NotNull Key<List<T>> key, @NotNull Collection<T> value) {\n        List<T> list = holder.putUserDataIfAbsent(key, new CopyOnWriteArrayList<T>());\n        list.addAll(value);\n    }","id":98891,"modified_method":"public <T> void addAll(@NotNull Key<List<T>> key, @NotNull Collection<T> value) {\n        checkReadOnly();\n        List<T> list = holder.putUserDataIfAbsent(key, new CopyOnWriteArrayList<T>());\n        list.addAll(value);\n    }","commit_id":"17e37380841fcc1b5f8e61095e47895a16a100b0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public <T> void add(@NotNull Key<List<T>> key, @NotNull T value) {\n        List<T> list = holder.putUserDataIfAbsent(key, new CopyOnWriteArrayList<T>());\n        list.add(value);\n    }","id":98892,"modified_method":"public <T> void add(@NotNull Key<List<T>> key, @NotNull T value) {\n        checkReadOnly();\n        List<T> list = holder.putUserDataIfAbsent(key, new CopyOnWriteArrayList<T>());\n        list.add(value);\n    }","commit_id":"17e37380841fcc1b5f8e61095e47895a16a100b0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public <T> T get(@NotNull Key<T> key, @NotNull T defaultValue) {\n        T data = holder.getUserData(key);\n        return data == null ? defaultValue : data;\n    }","id":98893,"modified_method":"@NotNull\n    public <T> T get(@NotNull Key<T> key, @NotNull T defaultValue) {\n        T data = holder.getUserData(key);\n        return data == null ? defaultValue : unmodifiable(data);\n    }","commit_id":"17e37380841fcc1b5f8e61095e47895a16a100b0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public <T> T get(@NotNull Key<T> key) {\n        return holder.getUserData(key);\n    }","id":98894,"modified_method":"@Nullable\n    public <T> T get(@NotNull Key<T> key) {\n        T data = holder.getUserData(key);\n        return data == null ? null : unmodifiable(data);\n    }","commit_id":"17e37380841fcc1b5f8e61095e47895a16a100b0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public <T> void put(@NotNull Key<T> key, @Nullable T value) {\n        holder.putUserData(key, value);\n    }","id":98895,"modified_method":"public <T> void put(@NotNull Key<T> key, @Nullable T value) {\n        checkReadOnly();\n        holder.putUserData(key, value);\n    }","commit_id":"17e37380841fcc1b5f8e61095e47895a16a100b0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetCoreEnvironment(Disposable parentDisposable, @NotNull CompilerConfiguration configuration) {\n        this.configuration = configuration;\n\n        this.applicationEnvironment = new JavaCoreApplicationEnvironment(parentDisposable);\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"kt\");\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"kts\");\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"ktm\");\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, JetParserDefinition.KTSCRIPT_FILE_SUFFIX); // should be renamed to kts\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"jet\");\n        applicationEnvironment.registerParserDefinition(new JavaParserDefinition());\n        applicationEnvironment.registerParserDefinition(new JetParserDefinition());\n\n        projectEnvironment = new JavaCoreProjectEnvironment(parentDisposable, applicationEnvironment);\n\n        MockProject project = projectEnvironment.getProject();\n        project.registerService(JetScriptDefinitionProvider.class, new JetScriptDefinitionProvider());\n        project.registerService(JetFilesProvider.class, new CliJetFilesProvider(this));\n        project.registerService(CoreJavaFileManager.class, (CoreJavaFileManager) ServiceManager.getService(project, JavaFileManager.class));\n        Extensions.getArea(project)\n                .getExtensionPoint(PsiElementFinder.EP_NAME)\n                .registerExtension(new JavaElementFinder(project));\n\n        annotationsProvider = new CoreAnnotationsProvider();\n        project.registerService(ExternalAnnotationsProvider.class, annotationsProvider);\n\n        for (File path : configuration.getList(JVMConfigurationKeys.CLASSPATH_KEY)) {\n            addToClasspath(path);\n        }\n        for (File path : configuration.getList(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY)) {\n            addExternalAnnotationsRoot(PathUtil.jarFileOrDirectoryToVirtualFile(path));\n        }\n        for (String path : configuration.getList(CommonConfigurationKeys.SOURCE_ROOTS_KEY)) {\n            addSources(path);\n        }\n\n        JetScriptDefinitionProvider.getInstance(project).addScriptDefinitions(configuration.getList(CommonConfigurationKeys.SCRIPT_DEFINITIONS_KEY));\n\n        JetStandardLibrary.initialize(project);\n        initialized = true;\n    }","id":98896,"modified_method":"public JetCoreEnvironment(Disposable parentDisposable, @NotNull CompilerConfiguration configuration) {\n        this.configuration = configuration.copy();\n        this.configuration.setReadOnly(true);\n\n        this.applicationEnvironment = new JavaCoreApplicationEnvironment(parentDisposable);\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"kt\");\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"kts\");\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"ktm\");\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, JetParserDefinition.KTSCRIPT_FILE_SUFFIX); // should be renamed to kts\n        applicationEnvironment.registerFileType(JetFileType.INSTANCE, \"jet\");\n        applicationEnvironment.registerParserDefinition(new JavaParserDefinition());\n        applicationEnvironment.registerParserDefinition(new JetParserDefinition());\n\n        projectEnvironment = new JavaCoreProjectEnvironment(parentDisposable, applicationEnvironment);\n\n        MockProject project = projectEnvironment.getProject();\n        project.registerService(JetScriptDefinitionProvider.class, new JetScriptDefinitionProvider());\n        project.registerService(JetFilesProvider.class, new CliJetFilesProvider(this));\n        project.registerService(CoreJavaFileManager.class, (CoreJavaFileManager) ServiceManager.getService(project, JavaFileManager.class));\n        Extensions.getArea(project)\n                .getExtensionPoint(PsiElementFinder.EP_NAME)\n                .registerExtension(new JavaElementFinder(project));\n\n        annotationsProvider = new CoreAnnotationsProvider();\n        project.registerService(ExternalAnnotationsProvider.class, annotationsProvider);\n\n        for (File path : configuration.getList(JVMConfigurationKeys.CLASSPATH_KEY)) {\n            addToClasspath(path);\n        }\n        for (File path : configuration.getList(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY)) {\n            addExternalAnnotationsRoot(PathUtil.jarFileOrDirectoryToVirtualFile(path));\n        }\n        for (String path : configuration.getList(CommonConfigurationKeys.SOURCE_ROOTS_KEY)) {\n            addSources(path);\n        }\n\n        JetScriptDefinitionProvider.getInstance(project).addScriptDefinitions(configuration.getList(CommonConfigurationKeys.SCRIPT_DEFINITIONS_KEY));\n\n        JetStandardLibrary.initialize(project);\n        initialized = true;\n    }","commit_id":"17e37380841fcc1b5f8e61095e47895a16a100b0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n  static <T extends DomElement> DomFileElementImpl<T> getCachedFileElement(XmlFile file) {\n    return file.getUserData(CACHED_FILE_ELEMENT);\n  }","id":98897,"modified_method":"@Nullable\n  static <T extends DomElement> DomFileElementImpl<T> getCachedFileElement(XmlFile file) {\n    WeakReference<DomFileElementImpl> ref = file.getUserData(CACHED_FILE_ELEMENT);\n    return ref == null ? null : ref.get();\n  }","commit_id":"927f651a9854428cf2520a5684e3e21f83a14d6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public final <T extends DomElement> DomFileElementImpl<T> getFileElement(final XmlFile file, final Class<T> aClass, String rootTagName) {\n    //noinspection unchecked\n    if (file.getUserData(MOCK_DESCIPRTION) == null) {\n      file.putUserData(MOCK_DESCIPRTION, new MockDomFileDescription<T>(aClass, rootTagName, file));\n      mySemService.clearCache();\n    }\n    final DomFileElementImpl<T> fileElement = getFileElement(file);\n    assert fileElement != null;\n    return fileElement;\n  }","id":98898,"modified_method":"@NotNull\n  public final <T extends DomElement> DomFileElementImpl<T> getFileElement(final XmlFile file, final Class<T> aClass, String rootTagName) {\n    //noinspection unchecked\n    if (file.getUserData(MOCK_DESCRIPTION) == null) {\n      file.putUserData(MOCK_DESCRIPTION, new MockDomFileDescription<T>(aClass, rootTagName, file));\n      mySemService.clearCache();\n    }\n    final DomFileElementImpl<T> fileElement = getFileElement(file);\n    assert fileElement != null;\n    return fileElement;\n  }","commit_id":"927f651a9854428cf2520a5684e3e21f83a14d6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void _computeFileElement(final boolean fireEvents, final XmlFileHeader rootTagName, @Nullable StringBuilder sb) {\n    if (sb != null) {\n      sb.append(rootTagName).append(\"\\n\");\n    }\n\n    if (!myXmlFile.isValid()) {\n      myLastResult = null;\n      return;\n    }\n    if (sb != null) {\n      sb.append(\"File is valid\\n\");\n    }\n\n    final DomFileDescription<T> description = findFileDescription(rootTagName, sb);\n\n    final DomFileElementImpl oldValue = getLastValue();\n    if (sb != null) {\n      sb.append(\"last \" + oldValue + \"\\n\");\n    }\n    final List<DomEvent> events = fireEvents ? new SmartList<DomEvent>() : Collections.<DomEvent>emptyList();\n    if (oldValue != null) {\n      if (fireEvents) {\n        events.add(new DomEvent(oldValue, false));\n      }\n    }\n\n    if (description == null) {\n      myLastResult = null;\n      return;\n    }\n\n    final Class<T> rootElementClass = description.getRootElementClass();\n    final XmlName xmlName = DomImplUtil.createXmlName(description.getRootTagName(), rootElementClass, null);\n    assert xmlName != null;\n    final EvaluatedXmlNameImpl rootTagName1 = EvaluatedXmlNameImpl.createEvaluatedXmlName(xmlName, xmlName.getNamespaceKey(), false);\n    myLastResult = new DomFileElementImpl<T>(myXmlFile, rootElementClass, rootTagName1, myDomManager, description);\n    if (sb != null) {\n      sb.append(\"success \" + myLastResult + \"\\n\");\n    }\n\n    if (fireEvents) {\n      final DomElement element = myLastResult;\n      events.add(new DomEvent(element, true));\n    }\n  }","id":98899,"modified_method":"@Nullable\n  private DomFileElementImpl<T> _computeFileElement(final boolean fireEvents, final XmlFileHeader rootTagName, @Nullable StringBuilder sb) {\n    if (sb != null) {\n      sb.append(rootTagName).append(\"\\n\");\n    }\n\n    if (!myXmlFile.isValid()) {\n      return null;\n    }\n    if (sb != null) {\n      sb.append(\"File is valid\\n\");\n    }\n\n    final DomFileDescription<T> description = findFileDescription(rootTagName, sb);\n\n    final DomFileElementImpl oldValue = getLastValue();\n    if (sb != null) {\n      sb.append(\"last \" + oldValue + \"\\n\");\n    }\n    final List<DomEvent> events = fireEvents ? new SmartList<DomEvent>() : Collections.<DomEvent>emptyList();\n    if (oldValue != null) {\n      if (fireEvents) {\n        events.add(new DomEvent(oldValue, false));\n      }\n    }\n\n    if (description == null) {\n      return null;\n    }\n\n    final Class<T> rootElementClass = description.getRootElementClass();\n    final XmlName xmlName = DomImplUtil.createXmlName(description.getRootTagName(), rootElementClass, null);\n    assert xmlName != null;\n    final EvaluatedXmlNameImpl rootTagName1 = EvaluatedXmlNameImpl.createEvaluatedXmlName(xmlName, xmlName.getNamespaceKey(), false);\n    DomFileElementImpl<T> result = new DomFileElementImpl<T>(myXmlFile, rootElementClass, rootTagName1, myDomManager, description);\n    if (sb != null) {\n      sb.append(\"success \" + result + \"\\n\");\n    }\n\n    if (fireEvents) {\n      events.add(new DomEvent(result, true));\n    }\n    return result;\n  }","commit_id":"927f651a9854428cf2520a5684e3e21f83a14d6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getFileElementWithLogging() {\n    final XmlFileHeader rootTagName = getRootTag();\n    final StringBuilder log = new StringBuilder();\n    _computeFileElement(false, rootTagName, log);\n    return log.toString();\n  }","id":98900,"modified_method":"public String getFileElementWithLogging() {\n    final XmlFileHeader rootTagName = getRootTag();\n    final StringBuilder log = new StringBuilder();\n    myLastResult = _computeFileElement(false, rootTagName, log);\n    return log.toString();\n  }","commit_id":"927f651a9854428cf2520a5684e3e21f83a14d6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private DomFileDescription<T> findFileDescription(final XmlFileHeader rootTagName, @Nullable StringBuilder sb) {\n    final DomFileDescription<T> mockDescription = myXmlFile.getUserData(DomManagerImpl.MOCK_DESCIPRTION);\n    if (mockDescription != null) return mockDescription;\n\n    if (sb != null) {\n      sb.append(\"no mock\\n\");\n    }\n\n    final XmlFile originalFile = (XmlFile)myXmlFile.getOriginalFile();\n    if (sb != null) {\n      sb.append(\"original: \" + originalFile + \"\\n\");\n    }\n    if (originalFile != myXmlFile) {\n      final FileDescriptionCachedValueProvider<T> provider = myDomManager.getOrCreateCachedValueProvider(originalFile);\n      final DomFileElementImpl<T> element = provider.getFileElement();\n      if (sb != null) {\n        sb.append(\"originalDom \" + element + \"\\n\");\n      }\n      return element == null ? null : element.getFileDescription();\n    }\n\n    //noinspection unchecked\n    final Set<DomFileDescription> namedDescriptions = myDomManager.getFileDescriptions(rootTagName.getRootTagLocalName());\n    if (sb != null) {\n      sb.append(\"named \" + new HashSet<DomFileDescription>(namedDescriptions) + \"\\n\");\n    }\n    DomFileDescription<T> description = ContainerUtil.find(namedDescriptions, myCondition);\n    if (description == null) {\n      final Set<DomFileDescription> unnamed = myDomManager.getAcceptingOtherRootTagNameDescriptions();\n      description = ContainerUtil.find(unnamed, myCondition);\n    }\n    if (sb != null) {\n      sb.append(\"found \" + description + \"\\n\");\n    }\n    return description;\n  }","id":98901,"modified_method":"@Nullable\n  private DomFileDescription<T> findFileDescription(final XmlFileHeader rootTagName, @Nullable StringBuilder sb) {\n    final DomFileDescription<T> mockDescription = myXmlFile.getUserData(DomManagerImpl.MOCK_DESCRIPTION);\n    if (mockDescription != null) return mockDescription;\n\n    if (sb != null) {\n      sb.append(\"no mock\\n\");\n    }\n\n    final XmlFile originalFile = (XmlFile)myXmlFile.getOriginalFile();\n    if (sb != null) {\n      sb.append(\"original: \" + originalFile + \"\\n\");\n    }\n    if (originalFile != myXmlFile) {\n      final FileDescriptionCachedValueProvider<T> provider = myDomManager.getOrCreateCachedValueProvider(originalFile);\n      final DomFileElementImpl<T> element = provider.getFileElement();\n      if (sb != null) {\n        sb.append(\"originalDom \" + element + \"\\n\");\n      }\n      return element == null ? null : element.getFileDescription();\n    }\n\n    //noinspection unchecked\n    final Set<DomFileDescription> namedDescriptions = myDomManager.getFileDescriptions(rootTagName.getRootTagLocalName());\n    if (sb != null) {\n      sb.append(\"named \" + new HashSet<DomFileDescription>(namedDescriptions) + \"\\n\");\n    }\n    DomFileDescription<T> description = ContainerUtil.find(namedDescriptions, myCondition);\n    if (description == null) {\n      final Set<DomFileDescription> unnamed = myDomManager.getAcceptingOtherRootTagNameDescriptions();\n      description = ContainerUtil.find(unnamed, myCondition);\n    }\n    if (sb != null) {\n      sb.append(\"found \" + description + \"\\n\");\n    }\n    return description;\n  }","commit_id":"927f651a9854428cf2520a5684e3e21f83a14d6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public final DomFileElementImpl<T> getFileElement() {\n    if (myComputed) return myLastResult;\n\n    _computeFileElement(false, getRootTag(), null);\n    myXmlFile.putUserData(DomManagerImpl.CACHED_FILE_ELEMENT, myLastResult);\n    myComputed = true;\n    return myLastResult;\n  }","id":98902,"modified_method":"@Nullable\n  public final DomFileElementImpl<T> getFileElement() {\n    if (myComputed) return myLastResult;\n\n    DomFileElementImpl<T> result = _computeFileElement(false, getRootTag(), null);\n\n    synchronized (myCondition) {\n      if (myComputed) return myLastResult;\n\n      myLastResult = result;\n      WeakReference<DomFileElementImpl> ref = result != null ? new WeakReference<DomFileElementImpl>(result) : null;\n      myXmlFile.putUserData(DomManagerImpl.CACHED_FILE_ELEMENT, ref);\n      myComputed = true;\n      return result;\n    }\n  }","commit_id":"927f651a9854428cf2520a5684e3e21f83a14d6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean showGenericValues() {\n    return myDomElement.getRoot().getUserData(SHOW_PROPERTIES_KEY);\n  }","id":98903,"modified_method":"protected boolean showGenericValues() {\n    final Boolean showProperties = myDomElement.getRoot().getUserData(SHOW_PROPERTIES_KEY);\n    return showProperties == null ? false: showProperties;\n  }","commit_id":"7de3c1cde3628c36b9c151026c736868054e4a3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent getToolbarPane() {\n    DefaultActionGroup actions = new DefaultActionGroup();\n\n    actions.add(new ToggleAction(\"ShowProperties\") {\n      public void update(final AnActionEvent e) {\n        super.update(e);\n        e.getPresentation().setIcon(IconLoader.getIcon(\"/nodes/pointcut.png\"));\n      }\n\n      public boolean isSelected(AnActionEvent e) {\n        return myRootElement.getRoot().getUserData(BaseDomElementNode.SHOW_PROPERTIES_KEY);\n      }\n\n      public void setSelected(AnActionEvent e, boolean state) {\n        myRootElement.getRoot().putUserData(BaseDomElementNode.SHOW_PROPERTIES_KEY, state);\n        myBuilder.updateFromRoot(true);\n      }\n    });\n\n    actions.add(new ExpandAllAction(myTree));\n    actions.add(new CollapseAllAction(myTree));\n\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(\n      ActionPlaces.UNKNOWN, actions, true);\n\n    return actionToolbar.getComponent();\n  }","id":98904,"modified_method":"protected JComponent getToolbarPane() {\n    DefaultActionGroup actions = new DefaultActionGroup();\n\n    actions.add(new ToggleAction(\"ShowProperties\") {\n      public void update(final AnActionEvent e) {\n        super.update(e);\n        e.getPresentation().setIcon(IconLoader.getIcon(\"/nodes/pointcut.png\"));\n      }\n\n      public boolean isSelected(AnActionEvent e) {\n        final Boolean showGenericValues = myRootElement.getRoot().getUserData(BaseDomElementNode.SHOW_PROPERTIES_KEY);\n\n        return showGenericValues == null ? false: showGenericValues;\n      }\n\n      public void setSelected(AnActionEvent e, boolean state) {\n        myRootElement.getRoot().putUserData(BaseDomElementNode.SHOW_PROPERTIES_KEY, state);\n        myBuilder.updateFromRoot(true);\n      }\n    });\n\n    actions.add(new ExpandAllAction(myTree));\n    actions.add(new CollapseAllAction(myTree));\n\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(\n      ActionPlaces.UNKNOWN, actions, true);\n\n    return actionToolbar.getComponent();\n  }","commit_id":"7de3c1cde3628c36b9c151026c736868054e4a3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    if (project == null) {\n      return;\n    }\n\n    PsiElement element = (PsiElement)dataContext.getData(DataConstants.PSI_ELEMENT);\n    if (element == null) {\n      Messages.showMessageDialog(\n        project,\n        IdeBundle.message(\"message.please.select.element.for.javadoc\"),\n        IdeBundle.message(\"title.no.element.selected\"),\n        Messages.getErrorIcon()\n      );\n      return;\n    }\n\n\n    PsiFile context = (PsiFile)dataContext.getData(DataConstants.PSI_FILE);\n    Editor editor = (Editor)dataContext.getData(DataConstants.EDITOR);\n    PsiElement originalElement = (context!=null && editor!=null)? context.findElementAt(editor.getCaretModel().getOffset()):null;\n    try {\n      element.putUserData(JavaDocManager.ORIGINAL_ELEMENT_KEY,originalElement);\n    } catch(RuntimeException ex) {\n      // some UserDataHolder does not support putUserData, e.g. PsiPackage\n      // tolerate it\n    }\n\n    JavaDocManager.getInstance(project).openJavaDoc(element);\n  }","id":98905,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    if (project == null) {\n      return;\n    }\n\n    PsiElement element = (PsiElement)dataContext.getData(DataConstants.PSI_ELEMENT);\n    if (element == null) {\n      Messages.showMessageDialog(\n        project,\n        IdeBundle.message(\"message.please.select.element.for.javadoc\"),\n        IdeBundle.message(\"title.no.element.selected\"),\n        Messages.getErrorIcon()\n      );\n      return;\n    }\n\n\n    PsiFile context = (PsiFile)dataContext.getData(DataConstants.PSI_FILE);\n    Editor editor = (Editor)dataContext.getData(DataConstants.EDITOR);\n    PsiElement originalElement = (context!=null && editor!=null)? context.findElementAt(editor.getCaretModel().getOffset()):null;\n    try {\n      element.putUserData(\n        JavaDocManager.ORIGINAL_ELEMENT_KEY,\n        SmartPointerManager.getInstance(originalElement.getProject()).createSmartPsiElementPointer(originalElement)\n      );\n    } catch(RuntimeException ex) {\n      // some UserDataHolder does not support putUserData, e.g. PsiPackage\n      // tolerate it\n    }\n\n    JavaDocManager.getInstance(project).openJavaDoc(element);\n  }","commit_id":"59933039e52a90574db2662e12c6babe872daad6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String generateDocInfo() {\n    StringBuffer buffer = new StringBuffer();\n    if (myElement instanceof PsiClass) {\n      generateClassJavaDoc(buffer, (PsiClass)myElement);\n    }\n    else if (myElement instanceof PsiMethod) {\n      generateMethodJavaDoc(buffer, (PsiMethod)myElement);\n    } else if (myElement instanceof PsiParameter) {\n      generateMethodParameterJavaDoc(buffer, (PsiParameter)myElement);\n    }\n    else if (myElement instanceof PsiField) {\n      generateFieldJavaDoc(buffer, (PsiField)myElement);\n    }\n    else if (myElement instanceof PsiVariable) {\n      generateVariableJavaDoc(buffer, (PsiVariable)myElement);\n    }\n    else if (myElement instanceof PsiFile) {\n      generateFileJavaDoc(buffer, (PsiFile)myElement); //used for Ctrl-Click\n    }\n    else if (myElement instanceof PsiPackage) {\n      generatePackageJavaDoc(buffer, (PsiPackage) myElement);\n    }\n    else {\n      if (myProvider!=null) {\n        return myProvider.generateDoc(myElement,myElement.getUserData(JavaDocManager.ORIGINAL_ELEMENT_KEY));\n      }\n      return null;\n    }\n    String text = buffer.toString();\n    if (text.length() == 0) {\n      return null;\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Generated JavaDoc:\");\n      LOG.debug(text);\n    }\n\n    text = StringUtil.replace(text, \"/>\", \">\");\n\n    return text;\n  }","id":98906,"modified_method":"public String generateDocInfo() {\n    StringBuffer buffer = new StringBuffer();\n    if (myElement instanceof PsiClass) {\n      generateClassJavaDoc(buffer, (PsiClass)myElement);\n    }\n    else if (myElement instanceof PsiMethod) {\n      generateMethodJavaDoc(buffer, (PsiMethod)myElement);\n    } else if (myElement instanceof PsiParameter) {\n      generateMethodParameterJavaDoc(buffer, (PsiParameter)myElement);\n    }\n    else if (myElement instanceof PsiField) {\n      generateFieldJavaDoc(buffer, (PsiField)myElement);\n    }\n    else if (myElement instanceof PsiVariable) {\n      generateVariableJavaDoc(buffer, (PsiVariable)myElement);\n    }\n    else if (myElement instanceof PsiFile) {\n      generateFileJavaDoc(buffer, (PsiFile)myElement); //used for Ctrl-Click\n    }\n    else if (myElement instanceof PsiPackage) {\n      generatePackageJavaDoc(buffer, (PsiPackage) myElement);\n    }\n    else {\n      if (myProvider!=null) {\n        final SmartPsiElementPointer elementPointer = myElement.getUserData(JavaDocManager.ORIGINAL_ELEMENT_KEY);\n        return myProvider.generateDoc(\n          myElement,\n          elementPointer != null ? elementPointer.getElement() : null\n        );\n      }\n      return null;\n    }\n    String text = buffer.toString();\n    if (text.length() == 0) {\n      return null;\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Generated JavaDoc:\");\n      LOG.debug(text);\n    }\n\n    text = StringUtil.replace(text, \"/>\", \">\");\n\n    return text;\n  }","commit_id":"59933039e52a90574db2662e12c6babe872daad6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DocumentationProvider getProviderFromElement(final PsiElement element) {\n    PsiElement originalElement = element!=null ? element.getUserData(ORIGINAL_ELEMENT_KEY):null;\n    PsiFile containingFile = (originalElement!=null)?originalElement.getContainingFile() : (element!=null)?element.getContainingFile():null;\n    VirtualFile vfile = (containingFile!=null)?containingFile.getVirtualFile() : null;\n\n    return (vfile!=null)?getProvider(vfile.getFileType()):null;\n  }","id":98907,"modified_method":"public DocumentationProvider getProviderFromElement(final PsiElement element) {\n    SmartPsiElementPointer originalElementPointer = element!=null ? element.getUserData(ORIGINAL_ELEMENT_KEY):null;\n    PsiElement originalElement = originalElementPointer != null ? originalElementPointer.getElement() : null;\n    PsiFile containingFile = (originalElement!=null)?originalElement.getContainingFile() : (element!=null)?element.getContainingFile():null;\n    VirtualFile vfile = (containingFile!=null)?containingFile.getVirtualFile() : null;\n\n    return (vfile!=null)?getProvider(vfile.getFileType()):null;\n  }","commit_id":"59933039e52a90574db2662e12c6babe872daad6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JBPopup showJavaDocInfo(final Editor editor, PsiFile file, boolean requestFocus) {\n    myEditor = editor;\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    final PsiExpressionList list =\n      ParameterInfoController.findArgumentList(file, editor.getCaretModel().getOffset(), -1);\n    if (list != null) {\n      myParameterInfoController = ParameterInfoController.getControllerAtOffset(editor, list.getTextRange().getStartOffset());\n    }\n\n\n    PsiElement element = TargetElementUtil.findTargetElement(editor,\n                                                             TargetElementUtil.ELEMENT_NAME_ACCEPTED\n                                                             | TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED\n                                                             | TargetElementUtil.LOOKUP_ITEM_ACCEPTED\n                                                             | TargetElementUtil.NEW_AS_CONSTRUCTOR\n                                                             | TargetElementUtil.THIS_ACCEPTED\n                                                             | TargetElementUtil.SUPER_ACCEPTED);\n    PsiElement originalElement = (file != null)?file.findElementAt(editor.getCaretModel().getOffset()): null;\n\n    if (element == null && editor != null) {\n      final PsiReference ref = TargetElementUtil.findReference(editor, editor.getCaretModel().getOffset());\n\n      if (ref != null) {\n        final PsiElement parent = ref.getElement().getParent();\n\n        if (parent instanceof PsiMethodCallExpression) {\n          element = parent;\n        }\n      }\n\n      Lookup activeLookup = LookupManager.getInstance(myProject).getActiveLookup();\n\n      if (activeLookup != null) {\n        LookupItem item = activeLookup.getCurrentItem();\n        if (item == null) return null;\n\n        if (file!=null) {\n          DocumentationProvider documentationProvider = documentationProviders.get(file.getFileType());\n          if (documentationProvider!=null) {\n\n            if (ref!=null) originalElement = ref.getElement();\n            element = documentationProvider.getDocumentationElementForLookupItem(item.getObject(), originalElement);\n          }\n        }\n      }\n    }\n\n    if (element instanceof PsiAnonymousClass) {\n      element = ((PsiAnonymousClass)element).getBaseClassType().resolve();\n    }\n\n    if (element == null && myParameterInfoController != null) {\n      final Object[] objects = myParameterInfoController.getSelectedElements();\n\n      if (objects != null && objects.length > 0) {\n        element = getPsiElementFromParameterInfoObject(objects[0], element);\n      }\n    }\n\n    if (element == null && file != null) { // look if we are within a javadoc comment\n      element = originalElement;\n      if (element == null) return null;\n      PsiDocComment comment = PsiTreeUtil.getParentOfType(element, PsiDocComment.class);\n      if (comment == null) return null;\n      element = comment.getParent();\n      if (!(element instanceof PsiDocCommentOwner)) return null;\n    }\n\n    JBPopupImpl oldHint = (JBPopupImpl)getDocInfoHint();\n    if (oldHint != null) {\n      JavaDocInfoComponent component = (JavaDocInfoComponent)oldHint.getComponent();\n      PsiElement element1 = component.getElement();\n      if (element != null && Comparing.equal(element, element1)) {\n        if (requestFocus) {\n          component.getComponent().requestFocus();\n        }\n        return oldHint;\n      }\n      oldHint.cancel();\n    }\n\n    JavaDocInfoComponent component = new JavaDocInfoComponent(this);\n    try {\n      element.putUserData(ORIGINAL_ELEMENT_KEY,originalElement);\n    } catch (RuntimeException ex) {\n      // PsiPackage does not allow putUserData\n    }\n\n    final String title = SymbolPresentationUtil.getSymbolPresentableText(element);\n    final JBPopup hint = JBPopupFactory.getInstance().createComponentPopupBuilder(component, component)\n      .setRequestFocusIfNotLookupOrSearch(myProject)\n      .setLookupAndSearchUpdater(new Condition<PsiElement>() {\n        public boolean value(final PsiElement element) {\n          if (myEditor != null){\n            final PsiFile file = element.getContainingFile();\n            if (file != null) {\n              Editor editor = myEditor;\n              showJavaDocInfo(myEditor, file, false);\n              myEditor = editor;\n            }\n          } else {\n            showJavaDocInfo(element);\n          }\n          return false;\n        }\n      }, myProject)\n      .setForceHeavyweight(false)\n      .setDimensionServiceKey(JAVADOC_LOCATION_AND_SIZE)\n      .setResizable(true)\n      .setMovable(true)\n      .setTitle(CodeInsightBundle.message(\"javadoc.info.title\", title != null ? title : element.getText()))\n      .setCancelCallback(new Computable<Boolean>(){\n        public Boolean compute() {\n          if (fromQuickSearch()) {\n            ((ChooseByNameBase.JPanelProvider)myPreviouslyFocused.getParent()).unregisterHint();\n          }\n\n          myEditor = null;\n          myPreviouslyFocused = null;\n          myParameterInfoController = null;\n          return Boolean.TRUE;\n        }\n      })\n      .createPopup();\n\n\n    component.setHint(hint);\n\n    fetchDocInfo(getDefaultProvider(element), component);\n\n    myDocInfoHintRef = new WeakReference<JBPopup>(hint);\n\n    return hint;\n  }","id":98908,"modified_method":"public JBPopup showJavaDocInfo(final Editor editor, PsiFile file, boolean requestFocus) {\n    myEditor = editor;\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    final PsiExpressionList list =\n      ParameterInfoController.findArgumentList(file, editor.getCaretModel().getOffset(), -1);\n    if (list != null) {\n      myParameterInfoController = ParameterInfoController.getControllerAtOffset(editor, list.getTextRange().getStartOffset());\n    }\n\n\n    PsiElement element = TargetElementUtil.findTargetElement(editor,\n                                                             TargetElementUtil.ELEMENT_NAME_ACCEPTED\n                                                             | TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED\n                                                             | TargetElementUtil.LOOKUP_ITEM_ACCEPTED\n                                                             | TargetElementUtil.NEW_AS_CONSTRUCTOR\n                                                             | TargetElementUtil.THIS_ACCEPTED\n                                                             | TargetElementUtil.SUPER_ACCEPTED);\n    PsiElement originalElement = (file != null)?file.findElementAt(editor.getCaretModel().getOffset()): null;\n\n    if (element == null && editor != null) {\n      final PsiReference ref = TargetElementUtil.findReference(editor, editor.getCaretModel().getOffset());\n\n      if (ref != null) {\n        final PsiElement parent = ref.getElement().getParent();\n\n        if (parent instanceof PsiMethodCallExpression) {\n          element = parent;\n        }\n      }\n\n      Lookup activeLookup = LookupManager.getInstance(myProject).getActiveLookup();\n\n      if (activeLookup != null) {\n        LookupItem item = activeLookup.getCurrentItem();\n        if (item == null) return null;\n\n        if (file!=null) {\n          DocumentationProvider documentationProvider = documentationProviders.get(file.getFileType());\n          if (documentationProvider!=null) {\n\n            if (ref!=null) originalElement = ref.getElement();\n            element = documentationProvider.getDocumentationElementForLookupItem(item.getObject(), originalElement);\n          }\n        }\n      }\n    }\n\n    if (element instanceof PsiAnonymousClass) {\n      element = ((PsiAnonymousClass)element).getBaseClassType().resolve();\n    }\n\n    if (element == null && myParameterInfoController != null) {\n      final Object[] objects = myParameterInfoController.getSelectedElements();\n\n      if (objects != null && objects.length > 0) {\n        element = getPsiElementFromParameterInfoObject(objects[0], element);\n      }\n    }\n\n    if (element == null && file != null) { // look if we are within a javadoc comment\n      element = originalElement;\n      if (element == null) return null;\n      PsiDocComment comment = PsiTreeUtil.getParentOfType(element, PsiDocComment.class);\n      if (comment == null) return null;\n      element = comment.getParent();\n      if (!(element instanceof PsiDocCommentOwner)) return null;\n    }\n\n    JBPopupImpl oldHint = (JBPopupImpl)getDocInfoHint();\n    if (oldHint != null) {\n      JavaDocInfoComponent component = (JavaDocInfoComponent)oldHint.getComponent();\n      PsiElement element1 = component.getElement();\n      if (element != null && Comparing.equal(element, element1)) {\n        if (requestFocus) {\n          component.getComponent().requestFocus();\n        }\n        return oldHint;\n      }\n      oldHint.cancel();\n    }\n\n    JavaDocInfoComponent component = new JavaDocInfoComponent(this);\n    try {\n      element.putUserData(\n        ORIGINAL_ELEMENT_KEY,\n        SmartPointerManager.getInstance(originalElement.getProject()).createSmartPsiElementPointer(originalElement)\n      );\n    } catch (RuntimeException ex) {\n      // PsiPackage does not allow putUserData\n    }\n\n    final String title = SymbolPresentationUtil.getSymbolPresentableText(element);\n    final JBPopup hint = JBPopupFactory.getInstance().createComponentPopupBuilder(component, component)\n      .setRequestFocusIfNotLookupOrSearch(myProject)\n      .setLookupAndSearchUpdater(new Condition<PsiElement>() {\n        public boolean value(final PsiElement element) {\n          if (myEditor != null){\n            final PsiFile file = element.getContainingFile();\n            if (file != null) {\n              Editor editor = myEditor;\n              showJavaDocInfo(myEditor, file, false);\n              myEditor = editor;\n            }\n          } else {\n            showJavaDocInfo(element);\n          }\n          return false;\n        }\n      }, myProject)\n      .setForceHeavyweight(false)\n      .setDimensionServiceKey(JAVADOC_LOCATION_AND_SIZE)\n      .setResizable(true)\n      .setMovable(true)\n      .setTitle(CodeInsightBundle.message(\"javadoc.info.title\", title != null ? title : element.getText()))\n      .setCancelCallback(new Computable<Boolean>(){\n        public Boolean compute() {\n          if (fromQuickSearch()) {\n            ((ChooseByNameBase.JPanelProvider)myPreviouslyFocused.getParent()).unregisterHint();\n          }\n\n          myEditor = null;\n          myPreviouslyFocused = null;\n          myParameterInfoController = null;\n          return Boolean.TRUE;\n        }\n      })\n      .createPopup();\n\n\n    component.setHint(hint);\n\n    fetchDocInfo(getDefaultProvider(element), component);\n\n    myDocInfoHintRef = new WeakReference<JBPopup>(hint);\n\n    return hint;\n  }","commit_id":"59933039e52a90574db2662e12c6babe872daad6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getExternalJavaDocUrl(final PsiElement element) {\n    String url = null;\n\n    if (element instanceof PsiClass) {\n      url = findUrlForClass((PsiClass)element);\n    }\n    else if (element instanceof PsiField) {\n      PsiField field = (PsiField)element;\n      PsiClass aClass = field.getContainingClass();\n      if (aClass != null) {\n        url = findUrlForClass(aClass);\n        if (url != null) {\n          url += \"#\" + field.getName();\n        }\n      }\n    }\n    else if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      PsiClass aClass = method.getContainingClass();\n      if (aClass != null) {\n        url = findUrlForClass(aClass);\n        if (url != null) {\n          String signature = PsiFormatUtil.formatMethod(method,\n                                                        PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME |\n                                                                              PsiFormatUtil.SHOW_PARAMETERS,\n                                                        PsiFormatUtil.SHOW_TYPE | PsiFormatUtil.SHOW_FQ_CLASS_NAMES, 999);\n          url += \"#\" + signature;\n        }\n      }\n    }\n    else if (element instanceof PsiPackage) {\n      url = findUrlForPackage((PsiPackage)element);\n    }\n    else if (element instanceof PsiDirectory) {\n      PsiPackage aPackage = ((PsiDirectory)element).getPackage();\n      if (aPackage != null) {\n        url = findUrlForPackage(aPackage);\n      }\n    } else {\n      DocumentationProvider provider = getProviderFromElement(element);\n      if (provider!=null) url = provider.getUrlFor(element,element.getUserData(ORIGINAL_ELEMENT_KEY));\n    }\n\n    return url == null ? null : url.replace('\\\\', '/');\n  }","id":98909,"modified_method":"private String getExternalJavaDocUrl(final PsiElement element) {\n    String url = null;\n\n    if (element instanceof PsiClass) {\n      url = findUrlForClass((PsiClass)element);\n    }\n    else if (element instanceof PsiField) {\n      PsiField field = (PsiField)element;\n      PsiClass aClass = field.getContainingClass();\n      if (aClass != null) {\n        url = findUrlForClass(aClass);\n        if (url != null) {\n          url += \"#\" + field.getName();\n        }\n      }\n    }\n    else if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      PsiClass aClass = method.getContainingClass();\n      if (aClass != null) {\n        url = findUrlForClass(aClass);\n        if (url != null) {\n          String signature = PsiFormatUtil.formatMethod(method,\n                                                        PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME |\n                                                                              PsiFormatUtil.SHOW_PARAMETERS,\n                                                        PsiFormatUtil.SHOW_TYPE | PsiFormatUtil.SHOW_FQ_CLASS_NAMES, 999);\n          url += \"#\" + signature;\n        }\n      }\n    }\n    else if (element instanceof PsiPackage) {\n      url = findUrlForPackage((PsiPackage)element);\n    }\n    else if (element instanceof PsiDirectory) {\n      PsiPackage aPackage = ((PsiDirectory)element).getPackage();\n      if (aPackage != null) {\n        url = findUrlForPackage(aPackage);\n      }\n    } else {\n      DocumentationProvider provider = getProviderFromElement(element);\n      if (provider!=null) {\n        final SmartPsiElementPointer originalElementPointer = element.getUserData(ORIGINAL_ELEMENT_KEY);\n        url = provider.getUrlFor(element, originalElementPointer != null ? originalElementPointer.getElement() : null);\n      }\n    }\n\n    return url == null ? null : url.replace('\\\\', '/');\n  }","commit_id":"59933039e52a90574db2662e12c6babe872daad6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void runExecuteActionInner(final boolean erase) {\n    // Process input and add to history\n    final Document document = getLanguageConsole().getCurrentEditor().getDocument();\n    final String documentText = document.getText();\n    final TextRange range = new TextRange(0, document.getTextLength());\n    getLanguageConsole().getCurrentEditor().getSelectionModel().setSelection(range.getStartOffset(), range.getEndOffset());\n    getLanguageConsole().addCurrentToHistory(range, false);\n    if (erase) {\n      getLanguageConsole().setInputText(\"\");\n    }\n    final String line = documentText;\n    if (!StringUtil.isEmptyOrSpaces(line)){\n      myHistory.addToHistory(line);          \n    }\n    // Send to interpreter / server\n    final String text2send = line.length() == 0 ? \"\\n\\n\" : line + \"\\n\";\n    sendInput(text2send);\n    myConsoleView.inputSent(text2send);\n  }","id":98910,"modified_method":"private void runExecuteActionInner(final boolean erase) {\n    // Process input and add to history\n    final Document document = getLanguageConsole().getCurrentEditor().getDocument();\n    final String documentText = document.getText();\n    final TextRange range = new TextRange(0, document.getTextLength());\n    getLanguageConsole().getCurrentEditor().getSelectionModel().setSelection(range.getStartOffset(), range.getEndOffset());\n    getLanguageConsole().addCurrentToHistory(range, false);\n    if (erase) {\n      getLanguageConsole().setInputText(\"\");\n    }\n    final String line = documentText;\n    if (!StringUtil.isEmptyOrSpaces(line)){\n      myHistory.addToHistory(line);          \n    }\n    // Send to interpreter / server\n    final String text2send = line.length() == 0 ? \"\\n\\n\" : line + \"\\n\";\n    sendInput(text2send);\n\n    if (myConsoleView instanceof ConsoleNotification){\n      ((ConsoleNotification)myConsoleView).inputSent(text2send);\n    }\n  }","commit_id":"3fb2eb1c6afe1268e14c60bf1f4b16e7c0a35b0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void initAndRun() throws ExecutionException {\n    // Create Server process\n    final Process process = createProcess();\n\n    // Init console view\n    myConsoleView = new PyLanguageConsoleView(myProject, myConsoleTitle);\n\n    myProcessHandler = createProcessHandler(process);\n\n    ProcessTerminatedListener.attach(myProcessHandler);\n\n    // Set language level\n    for (Module module : ModuleManager.getInstance(myProject).getModules()) {\n      final Sdk pythonSdk = PythonSdkType.findPythonSdk(module);\n      if (pythonSdk != null){\n        final LanguageLevel languageLevel = PythonSdkType.getLanguageLevelForSdk(pythonSdk);\n        final PsiFile psiFile = getLanguageConsole().getFile();\n        // Set module explicitly\n        psiFile.putUserData(ModuleUtil.KEY_MODULE, module);\n        final VirtualFile vFile = psiFile.getVirtualFile();\n        if (vFile != null) {\n          // Set language level\n          vFile.putUserData(LanguageLevel.KEY, languageLevel);\n        }\n        break;\n      }\n    }\n\n    myProcessHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void processTerminated(ProcessEvent event) {\n        myRunAction.getTemplatePresentation().setEnabled(false);\n        myConsoleView.getConsole().setPrompt(\"\");\n        myConsoleView.getConsole().getConsoleEditor().setRendererMode(true);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            myConsoleView.getConsole().getConsoleEditor().getComponent().updateUI();\n          }\n        });\n      }\n    });\n\n// Setup default prompt\n    myConsoleView.getConsole().setPrompt(PyConsoleHighlightingUtil.ORDINARY_PROMPT.trim());\n\n// Attach to process\n    myConsoleView.attachToProcess(myProcessHandler);\n\n// Add filter TODO[oleg]: Add stacktrace filters\n//    myConsoleView.addMessageFilter(new OutputConsoleFilter());\n\n// Runner creating\n    final Executor defaultExecutor = ExecutorRegistry.getInstance().getExecutorById(DefaultRunExecutor.EXECUTOR_ID);\n    final DefaultActionGroup toolbarActions = new DefaultActionGroup();\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, toolbarActions, false);\n\n// Runner creating\n    final JPanel panel = new JPanel(new BorderLayout());\n    panel.add(actionToolbar.getComponent(), BorderLayout.WEST);\n    panel.add(myConsoleView.getComponent(), BorderLayout.CENTER);\n\n    final RunContentDescriptor myDescriptor =\n      new RunContentDescriptor(myConsoleView, myProcessHandler, panel, myConsoleTitle);\n\n// tool bar actions\n    final AnAction[] actions = fillToolBarActions(toolbarActions, defaultExecutor, myDescriptor);\n    registerActionShortcuts(actions, getLanguageConsole().getConsoleEditor().getComponent());\n    registerActionShortcuts(actions, panel);\n    panel.updateUI();\n\n// Show in run toolwindow\n    ExecutionManager.getInstance(myProject).getContentManager().showRunContent(defaultExecutor, myDescriptor);\n\n// Request focus\n    final ToolWindow window = ToolWindowManager.getInstance(myProject).getToolWindow(defaultExecutor.getId());\n    window.activate(new Runnable() {\n      public void run() {\n        IdeFocusManager.getInstance(myProject).requestFocus(getLanguageConsole().getCurrentEditor().getContentComponent(), true);\n      }\n    });\n// Run\n    myProcessHandler.startNotify();\n  }","id":98911,"modified_method":"public void initAndRun() throws ExecutionException {\n    // Create Server process\n    final Process process = createProcess();\n\n    // Init console view\n    myConsoleView = createConsoleView();\n\n    myProcessHandler = createProcessHandler(process);\n\n    ProcessTerminatedListener.attach(myProcessHandler);\n\n    // Set language level\n    for (Module module : ModuleManager.getInstance(myProject).getModules()) {\n      final Sdk pythonSdk = PythonSdkType.findPythonSdk(module);\n      if (pythonSdk != null){\n        final LanguageLevel languageLevel = PythonSdkType.getLanguageLevelForSdk(pythonSdk);\n        final PsiFile psiFile = getLanguageConsole().getFile();\n        // Set module explicitly\n        psiFile.putUserData(ModuleUtil.KEY_MODULE, module);\n        final VirtualFile vFile = psiFile.getVirtualFile();\n        if (vFile != null) {\n          // Set language level\n          vFile.putUserData(LanguageLevel.KEY, languageLevel);\n        }\n        break;\n      }\n    }\n\n    myProcessHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void processTerminated(ProcessEvent event) {\n        myRunAction.getTemplatePresentation().setEnabled(false);\n        myConsoleView.getConsole().setPrompt(\"\");\n        myConsoleView.getConsole().getConsoleEditor().setRendererMode(true);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            myConsoleView.getConsole().getConsoleEditor().getComponent().updateUI();\n          }\n        });\n      }\n    });\n\n// Setup default prompt\n    myConsoleView.getConsole().setPrompt(PyConsoleHighlightingUtil.ORDINARY_PROMPT.trim());\n\n// Attach to process\n    myConsoleView.attachToProcess(myProcessHandler);\n\n// Add filter TODO[oleg]: Add stacktrace filters\n//    myConsoleView.addMessageFilter(new OutputConsoleFilter());\n\n// Runner creating\n    final Executor defaultExecutor = ExecutorRegistry.getInstance().getExecutorById(DefaultRunExecutor.EXECUTOR_ID);\n    final DefaultActionGroup toolbarActions = new DefaultActionGroup();\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, toolbarActions, false);\n\n// Runner creating\n    final JPanel panel = new JPanel(new BorderLayout());\n    panel.add(actionToolbar.getComponent(), BorderLayout.WEST);\n    panel.add(myConsoleView.getComponent(), BorderLayout.CENTER);\n\n    final RunContentDescriptor myDescriptor =\n      new RunContentDescriptor(myConsoleView, myProcessHandler, panel, myConsoleTitle);\n\n// tool bar actions\n    final AnAction[] actions = fillToolBarActions(toolbarActions, defaultExecutor, myDescriptor);\n    registerActionShortcuts(actions, getLanguageConsole().getConsoleEditor().getComponent());\n    registerActionShortcuts(actions, panel);\n    panel.updateUI();\n\n// Show in run toolwindow\n    ExecutionManager.getInstance(myProject).getContentManager().showRunContent(defaultExecutor, myDescriptor);\n\n// Request focus\n    final ToolWindow window = ToolWindowManager.getInstance(myProject).getToolWindow(defaultExecutor.getId());\n    window.activate(new Runnable() {\n      public void run() {\n        IdeFocusManager.getInstance(myProject).requestFocus(getLanguageConsole().getCurrentEditor().getContentComponent(), true);\n      }\n    });\n// Run\n    myProcessHandler.startNotify();\n  }","commit_id":"3fb2eb1c6afe1268e14c60bf1f4b16e7c0a35b0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiPolyVariantReference getReference() {\n    // Handle import reference\n    if (PsiTreeUtil.getParentOfType(this, PyImportElement.class, PyFromImportStatement.class) != null) {\n      return new PyImportReferenceImpl(this);\n    }\n\n    if (getQualifier() != null) {\n      return new PyQualifiedReferenceImpl(this);\n    }\n\n    return new PyReferenceImpl(this);\n  }","id":98912,"modified_method":"@NotNull\n  public PsiPolyVariantReference getReference() {\n    final PsiFile file = getContainingFile();\n    final PyExpression qualifier = getQualifier();\n    if (file != null) {\n      // Return special reference\n      final PydevConsoleCommunication communication = file.getCopyableUserData(PydevConsoleRunner.CONSOLE_KEY);\n      if (communication != null){\n        if (qualifier != null) {\n          return new PydevConsoleReference(this, communication, qualifier.getText() + \".\");\n        }\n        return new PydevConsoleReference(this, communication, \"\");\n      }\n    }\n\n    // Handle import reference\n    if (PsiTreeUtil.getParentOfType(this, PyImportElement.class, PyFromImportStatement.class) != null) {\n      return new PyImportReferenceImpl(this);\n    }\n\n    if (qualifier != null) {\n      return new PyQualifiedReferenceImpl(this);\n    }\n\n    return new PyReferenceImpl(this);\n  }","commit_id":"3fb2eb1c6afe1268e14c60bf1f4b16e7c0a35b0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  ASTNode getNameElement() {\n    return getNode().findChildByType(PyTokenTypes.IDENTIFIER);\n  }","id":98913,"modified_method":"@Nullable\n  public ASTNode getNameElement() {\n    return getNode().findChildByType(PyTokenTypes.IDENTIFIER);\n  }","commit_id":"3fb2eb1c6afe1268e14c60bf1f4b16e7c0a35b0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void initAndRun() throws ExecutionException {\n    super.initAndRun();\n    try {\n      Thread.sleep(100);\n    }\n    catch (InterruptedException e) {\n      // Ignore\n    }\n    sendInput(\"import sys; print('Python %s on %s' % (sys.version, sys.platform))\\n\");\n  }","id":98914,"modified_method":"@Override\n  public void initAndRun() throws ExecutionException {\n    super.initAndRun();\n\n    // Propagate console communication to language console\n    ((PydevLanguageConsoleView)myConsoleView).setPydevConsoleCommunication(myPydevConsoleCommunication);\n\n    try {\n      Thread.sleep(100);\n    }\n    catch (InterruptedException e) {\n      // Ignore\n    }\n    sendInput(\"import sys; print('Python %s on %s' % (sys.version, sys.platform))\\n\");\n  }","commit_id":"3fb2eb1c6afe1268e14c60bf1f4b16e7c0a35b0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processDeclarations(@NotNull PsiScopeProcessor processor,\n                                     @NotNull ResolveState substitutor,\n                                     PsiElement lastParent,\n                                     @NotNull PsiElement place) {\n    final PyStatementList statementList = getStatementList();\n    for (PsiElement element : statementList.getChildren()) {\n      if (element instanceof PyFunction) {\n        if (!processor.execute(element, substitutor)) return false;\n      }\n    }\n    for (PsiElement psiElement : statementList.getChildren()) {\n      if (psiElement instanceof PyAssignmentStatement) {\n        final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)psiElement;\n        final PyExpression[] targets = assignmentStatement.getTargets();\n        for (PyExpression target : targets) {\n          if (target instanceof PyTargetExpression) {\n            if (!processor.execute(target, substitutor)) return false;\n          }\n        }\n      }\n    }\n    return processor.execute(this, substitutor);\n  }","id":98915,"modified_method":"@Override\n  public boolean processDeclarations(@NotNull PsiScopeProcessor processor,\n                                     @NotNull ResolveState substitutor,\n                                     PsiElement lastParent,\n                                     @NotNull PsiElement place) {\n    final PyStatementList statementList = getStatementList();\n    for (PsiElement element : statementList.getChildren()) {\n      if (element instanceof PyFunction) {\n        final PyFunction function = (PyFunction)element;\n        final String name = function.getName();\n        if (processor instanceof PyResolveUtil.VariantsProcessor && name != null && name.startsWith(\"__\") && name.endsWith(\"__\")) {\n          continue;\n        }\n        if (!processor.execute(element, substitutor)) return false;\n      }\n    }\n    for (PsiElement psiElement : statementList.getChildren()) {\n      if (psiElement instanceof PyAssignmentStatement) {\n        final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)psiElement;\n        final PyExpression[] targets = assignmentStatement.getTargets();\n        for (PyExpression target : targets) {\n          if (target instanceof PyTargetExpression) {\n            if (!processor.execute(target, substitutor)) return false;\n          }\n        }\n      }\n    }\n    if (processor instanceof PyResolveUtil.VariantsProcessor) {\n      return true;\n    }\n    return processor.execute(this, substitutor);\n  }","commit_id":"26022c1807883d045c273c0cbb0df15bcfe06af1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    if (getQualifier() != null) {\n      return new Object[0]; // TODO?\n    }\n\n    final PyResolveUtil.VariantsProcessor processor = new PyResolveUtil.VariantsProcessor();\n    PyResolveUtil.treeWalkUp(processor, this, this, null);\n    return processor.getResult();\n  }","id":98916,"modified_method":"public Object[] getVariants() {\n    final PyExpression qualifier = getQualifier();\n    if (qualifier != null) {\n      PyType qualifierType = qualifier.getType();\n      PsiElement variantsOwner = null;\n      if (qualifierType instanceof PyClassType) {\n        variantsOwner = ((PyClassType) qualifierType).getPyClass();\n      }\n      else if (qualifierType instanceof PyModuleType) {\n        variantsOwner = ((PyModuleType) qualifierType).getModule();\n      }\n      if (variantsOwner != null) {\n        final PyResolveUtil.VariantsProcessor processor = new PyResolveUtil.VariantsProcessor();\n        variantsOwner.processDeclarations(processor, ResolveState.initial(), null, this);\n        return processor.getResult();\n      }\n      return new Object[0];\n    }\n\n    final PyResolveUtil.VariantsProcessor processor = new PyResolveUtil.VariantsProcessor();\n    PyResolveUtil.treeWalkUp(processor, this, this, null);\n    return processor.getResult();\n  }","commit_id":"26022c1807883d045c273c0cbb0df15bcfe06af1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Object[] getVariants() {\n    PyExpression qualifier = CompletionUtil.getOriginalOrSelf(myElement.getQualifier());\n    assert qualifier != null;\n    final PyQualifiedExpression element = CompletionUtil.getOriginalOrSelf(myElement);\n\n    PyType qualifierType = TypeEvalContext.slow().getType(qualifier);\n    ProcessingContext ctx = new ProcessingContext();\n    final Set<String> namesAlready = new HashSet<String>();\n    ctx.put(PyType.CTX_NAMES, namesAlready);\n    if (qualifierType != null) {\n      Collection<Object> variants = new ArrayList<Object>();\n      Collections.addAll(variants, getVariantFromHasAttr(qualifier));\n      if (qualifier instanceof PyQualifiedExpression) {\n        Collection<PyExpression> attrs = collectAssignedAttributes((PyQualifiedExpression)qualifier);\n        for (PyExpression ex : attrs) {\n          final String name = ex.getName();\n          if (name != null && name.endsWith(CompletionUtil.DUMMY_IDENTIFIER_TRIMMED)) {\n            continue;\n          }\n          if (ex instanceof PsiNamedElement && qualifierType instanceof PyClassType) {\n            variants.add(LookupElementBuilder.create((PsiNamedElement)ex)\n                           .withTypeText(qualifierType.getName())\n                           .withIcon(PlatformIcons.FIELD_ICON));\n          }\n          if (ex instanceof PyReferenceExpression) {\n            PyReferenceExpression refExpr = (PyReferenceExpression)ex;\n            namesAlready.add(refExpr.getReferencedName());\n          }\n          else if (ex instanceof PyTargetExpression) {\n            PyTargetExpression targetExpr = (PyTargetExpression)ex;\n            namesAlready.add(targetExpr.getName());\n          }\n        }\n        Collections.addAll(variants, qualifierType.getCompletionVariants(element.getName(), element, ctx));\n        return variants.toArray();\n      }\n      else {\n        return qualifierType.getCompletionVariants(element.getName(), element, ctx);\n      }\n    }\n    return getUntypedVariants();\n  }","id":98917,"modified_method":"@NotNull\n  @Override\n  public Object[] getVariants() {\n    PyExpression qualifier = myElement.getQualifier();\n    if (qualifier != null) {\n      qualifier = CompletionUtil.getOriginalOrSelf(qualifier);\n    }\n    if (qualifier == null) {\n      return EMPTY_ARRAY;\n    }\n    final PyQualifiedExpression element = CompletionUtil.getOriginalOrSelf(myElement);\n\n    PyType qualifierType = TypeEvalContext.slow().getType(qualifier);\n    ProcessingContext ctx = new ProcessingContext();\n    final Set<String> namesAlready = new HashSet<String>();\n    ctx.put(PyType.CTX_NAMES, namesAlready);\n    if (qualifierType != null) {\n      Collection<Object> variants = new ArrayList<Object>();\n      Collections.addAll(variants, getVariantFromHasAttr(qualifier));\n      if (qualifier instanceof PyQualifiedExpression) {\n        Collection<PyExpression> attrs = collectAssignedAttributes((PyQualifiedExpression)qualifier);\n        for (PyExpression ex : attrs) {\n          final String name = ex.getName();\n          if (name != null && name.endsWith(CompletionUtil.DUMMY_IDENTIFIER_TRIMMED)) {\n            continue;\n          }\n          if (ex instanceof PsiNamedElement && qualifierType instanceof PyClassType) {\n            variants.add(LookupElementBuilder.create((PsiNamedElement)ex)\n                           .withTypeText(qualifierType.getName())\n                           .withIcon(PlatformIcons.FIELD_ICON));\n          }\n          if (ex instanceof PyReferenceExpression) {\n            PyReferenceExpression refExpr = (PyReferenceExpression)ex;\n            namesAlready.add(refExpr.getReferencedName());\n          }\n          else if (ex instanceof PyTargetExpression) {\n            PyTargetExpression targetExpr = (PyTargetExpression)ex;\n            namesAlready.add(targetExpr.getName());\n          }\n        }\n        Collections.addAll(variants, qualifierType.getCompletionVariants(element.getName(), element, ctx));\n        return variants.toArray();\n      }\n      else {\n        return qualifierType.getCompletionVariants(element.getName(), element, ctx);\n      }\n    }\n    return getUntypedVariants();\n  }","commit_id":"e9fccfb338f982c1aff3ad45f028767fd97cb2a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void rememberReference(PyReferenceExpression node, PsiElement element) {\n    // we will remember reference in deepest node\n    if (node.getQualifier() instanceof PyReferenceExpression) return;\n\n    final PsiPolyVariantReference ref = node.getReference();\n    final PsiElement target = ref.resolve();\n    if (target instanceof PsiNamedElement && !PsiTreeUtil.isAncestor(element, target, false)) {\n      node.putCopyableUserData(ENCODED_IMPORT, (PsiNamedElement)target);\n    }\n  }","id":98918,"modified_method":"private static void rememberReference(PyReferenceExpression node, PsiElement element) {\n    // We will remember reference in deepest node (except for references to PyImportedModules, as we need references to modules, not to\n    // their packages)\n    final PyExpression qualifier = node.getQualifier();\n    if (qualifier != null && !(resolveExpression(qualifier) instanceof PyImportedModule)) {\n      return;\n    }\n    final PsiElement target = resolveExpression(node);\n    if (target instanceof PsiNamedElement && !PsiTreeUtil.isAncestor(element, target, false)) {\n      node.putCopyableUserData(ENCODED_IMPORT, (PsiNamedElement)target);\n    }\n  }","commit_id":"221f0d89e3020f3d5118d863d1799ec41c8b6833","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiJavaCodeReferenceElement getQualifier(PsiElement qualifier) {\n    if (qualifier instanceof PsiThisExpression) {\n      return ((PsiThisExpression)qualifier).getQualifier();\n    } else if (qualifier != null) {\n      return  ((PsiSuperExpression)qualifier).getQualifier();\n    }\n    return null;\n  }","id":98919,"modified_method":"private static PsiJavaCodeReferenceElement getQualifier(PsiElement qualifier) {\n    if (qualifier instanceof PsiThisExpression) {\n      final PsiJavaCodeReferenceElement thisQualifier = ((PsiThisExpression)qualifier).getQualifier();\n      if (thisQualifier != null) {\n        final PsiClass innerMostClass = PsiTreeUtil.getParentOfType(thisQualifier, PsiClass.class);\n        if (innerMostClass == thisQualifier.resolve()) {\n          return null;\n        }\n      }\n      return thisQualifier;\n    } else if (qualifier != null) {\n      return  ((PsiSuperExpression)qualifier).getQualifier();\n    }\n    return null;\n  }","commit_id":"97a5b00bf7734cca213227bbe6f4c17284b122ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Icon findIcon(@NotNull String path, @NotNull ClassLoader classLoader) {\n    String originalPath = path;\n    path = patchPath(path);\n    if (isReflectivePath(path)) return getReflectiveIcon(path, classLoader);\n    if (!StringUtil.startsWithChar(path, '/')) return null;\n\n    final URL url = classLoader.getResource(path.substring(1));\n    final Icon icon = findIcon(url);\n    if (icon instanceof CachedImageIcon) {\n      ((CachedImageIcon)icon).myOriginalPath = originalPath;\n      ((CachedImageIcon)icon).myClassLoader = classLoader;\n    }\n    return icon;\n  }","id":98920,"modified_method":"@Nullable\n  public static Icon findIcon(@NotNull String path, @NotNull ClassLoader classLoader) {\n    String originalPath = path;\n    Pair<String, Class> patchedPath = patchPath(path);\n    path = patchedPath.first;\n    if (patchedPath.second != null) {\n      classLoader = patchedPath.second.getClassLoader();\n    }\n    if (isReflectivePath(path)) return getReflectiveIcon(path, classLoader);\n    if (!StringUtil.startsWithChar(path, '/')) return null;\n\n    final URL url = classLoader.getResource(path.substring(1));\n    final Icon icon = findIcon(url);\n    if (icon instanceof CachedImageIcon) {\n      ((CachedImageIcon)icon).myOriginalPath = originalPath;\n      ((CachedImageIcon)icon).myClassLoader = classLoader;\n    }\n    return icon;\n  }","commit_id":"65c7695c14d2ae1a5d41e72c060f65f43dffbd3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Icon findIcon(@NotNull String path, @NotNull final Class aClass, boolean computeNow, boolean strict) {\n    String originalPath = path;\n    path = patchPath(path);\n    if (isReflectivePath(path)) return getReflectiveIcon(path, aClass.getClassLoader());\n\n    URL myURL = aClass.getResource(path);\n    if (myURL == null) {\n      if (strict) throw new RuntimeException(\"Can't find icon in '\" + path + \"' near \" + aClass);\n      return null;\n    }\n    final Icon icon = findIcon(myURL);\n    if (icon instanceof CachedImageIcon) {\n      ((CachedImageIcon)icon).myOriginalPath = originalPath;\n      ((CachedImageIcon)icon).myClassLoader = aClass.getClassLoader();\n    }\n    return icon;\n  }","id":98921,"modified_method":"@Nullable\n  public static Icon findIcon(@NotNull String path, @NotNull Class aClass, boolean computeNow, boolean strict) {\n    String originalPath = path;\n    Pair<String, Class> patchedPath = patchPath(path);\n    path = patchedPath.first;\n    if (patchedPath.second != null) {\n      aClass = patchedPath.second;\n    }\n    if (isReflectivePath(path)) return getReflectiveIcon(path, aClass.getClassLoader());\n\n    URL myURL = aClass.getResource(path);\n    if (myURL == null) {\n      if (strict) throw new RuntimeException(\"Can't find icon in '\" + path + \"' near \" + aClass);\n      return null;\n    }\n    final Icon icon = findIcon(myURL);\n    if (icon instanceof CachedImageIcon) {\n      ((CachedImageIcon)icon).myOriginalPath = originalPath;\n      ((CachedImageIcon)icon).myClassLoader = aClass.getClassLoader();\n    }\n    return icon;\n  }","commit_id":"65c7695c14d2ae1a5d41e72c060f65f43dffbd3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String patchPath(@NotNull String path) {\n    for (IconPathPatcher patcher : ourPatchers) {\n      String newPath = patcher.patchPath(path);\n      if (newPath != null) {\n        path = newPath;\n      }\n    }\n    return path;\n  }","id":98922,"modified_method":"@NotNull\n  private static Pair<String, Class> patchPath(@NotNull String path) {\n    for (IconPathPatcher patcher : ourPatchers) {\n      String newPath = patcher.patchPath(path);\n      if (newPath != null) {\n        return Pair.create(newPath, patcher.getContextClass(path));\n      }\n    }\n    return Pair.create(path, null);\n  }","commit_id":"65c7695c14d2ae1a5d41e72c060f65f43dffbd3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    private synchronized ImageIcon getRealIcon() {\n      if (isLoaderDisabled() && (myRealIcon == null || dark != USE_DARK_ICONS || scale != SCALE || filter != IMAGE_FILTER || numberOfPatchers != ourPatchers.size())) return EMPTY_ICON;\n\n      if (!isValid()) {\n        myRealIcon = null;\n        dark = USE_DARK_ICONS;\n        scale = SCALE;\n        filter = IMAGE_FILTER;\n        myScaledIconsCache.clear();\n        if (numberOfPatchers != ourPatchers.size()) {\n          numberOfPatchers = ourPatchers.size();\n          String path = myOriginalPath == null ? null : patchPath(myOriginalPath);\n          if (myClassLoader != null&& path != null && path.startsWith(\"/\")) {\n            path = path.substring(1);\n            final URL url = myClassLoader.getResource(path);\n            if (url != null) {\n              myUrl = url;\n            }\n          }\n        }\n      }\n      Object realIcon = myRealIcon;\n      if (realIcon instanceof Icon) return (ImageIcon)realIcon;\n\n      ImageIcon icon;\n      if (realIcon instanceof Reference) {\n        icon = ((Reference<ImageIcon>)realIcon).get();\n        if (icon != null) return (ImageIcon)icon;\n      }\n\n      Image image = ImageLoader.loadFromUrl(myUrl, true, filter);\n      icon = checkIcon(image, myUrl);\n\n      if (icon != null) {\n        if (icon.getIconWidth() < 50 && icon.getIconHeight() < 50) {\n          realIcon = icon;\n        }\n        else {\n          realIcon = new SoftReference<ImageIcon>(icon);\n        }\n        myRealIcon = realIcon;\n      }\n\n      return icon == null ? EMPTY_ICON : icon;\n    }","id":98923,"modified_method":"@NotNull\n    private synchronized ImageIcon getRealIcon() {\n      if (isLoaderDisabled() && (myRealIcon == null || dark != USE_DARK_ICONS || scale != SCALE || filter != IMAGE_FILTER || numberOfPatchers != ourPatchers.size())) return EMPTY_ICON;\n\n      if (!isValid()) {\n        myRealIcon = null;\n        dark = USE_DARK_ICONS;\n        scale = SCALE;\n        filter = IMAGE_FILTER;\n        myScaledIconsCache.clear();\n        if (numberOfPatchers != ourPatchers.size()) {\n          numberOfPatchers = ourPatchers.size();\n          Pair<String, Class> patchedPath = patchPath(myOriginalPath);\n          String path = myOriginalPath == null ? null : patchedPath.first;\n          if (patchedPath.second != null) {\n            myClassLoader = patchedPath.second.getClassLoader();\n          }\n          if (myClassLoader != null && path != null && path.startsWith(\"/\")) {\n            path = path.substring(1);\n            final URL url = myClassLoader.getResource(path);\n            if (url != null) {\n              myUrl = url;\n            }\n          }\n        }\n      }\n      Object realIcon = myRealIcon;\n      if (realIcon instanceof Icon) return (ImageIcon)realIcon;\n\n      ImageIcon icon;\n      if (realIcon instanceof Reference) {\n        icon = ((Reference<ImageIcon>)realIcon).get();\n        if (icon != null) return (ImageIcon)icon;\n      }\n\n      Image image = ImageLoader.loadFromUrl(myUrl, true, filter);\n      icon = checkIcon(image, myUrl);\n\n      if (icon != null) {\n        if (icon.getIconWidth() < 50 && icon.getIconHeight() < 50) {\n          realIcon = icon;\n        }\n        else {\n          realIcon = new SoftReference<ImageIcon>(icon);\n        }\n        myRealIcon = realIcon;\n      }\n\n      return icon == null ? EMPTY_ICON : icon;\n    }","commit_id":"65c7695c14d2ae1a5d41e72c060f65f43dffbd3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\t\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\t\tblogsEntryAttachmentFileEntryReferences = null;\n\n\t\t\tUploadException uploadException =\n\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\tif (uploadException != null) {\n\t\t\t\tif (uploadException.isExceededLiferayFileItemSizeLimit()) {\n\t\t\t\t\tthrow new LiferayFileItemException();\n\t\t\t\t}\n\t\t\t\telse if (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\tthrow new FileSizeException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD) ||\n\t\t\t\t\t cmd.equals(Constants.UPDATE)) {\n\n\t\t\t\tCallable<Object[]> updateEntryCallable =\n\t\t\t\t\tnew UpdateEntryCallable(actionRequest);\n\n\t\t\t\tObject[] returnValue = TransactionHandlerUtil.invoke(\n\t\t\t\t\t_transactionAttribute, updateEntryCallable);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\t((List<BlogsEntryAttachmentFileEntryReference>)\n\t\t\t\t\t\treturnValue[2]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntries(actionRequest, false);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE_TO_TRASH)) {\n\t\t\t\tdeleteEntries(actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.RESTORE)) {\n\t\t\t\trestoreTrashEntries(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribe(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribe(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tString portletId = HttpUtil.getParameter(redirect, \"p_p_id\", false);\n\n\t\t\tif (Validator.isNotNull(oldUrlTitle)) {\n\t\t\t\tString oldRedirectParam =\n\t\t\t\t\tPortalUtil.getPortletNamespace(portletId) + \"redirect\";\n\n\t\t\t\tString oldRedirect = HttpUtil.getParameter(\n\t\t\t\t\tredirect, oldRedirectParam, false);\n\n\t\t\t\tif (Validator.isNotNull(oldRedirect)) {\n\t\t\t\t\tString newRedirect = HttpUtil.decodeURL(oldRedirect);\n\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldRedirectParam, \"redirect\");\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldRedirect, newRedirect);\n\t\t\t\t}\n\t\t\t\telse if (redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t\t\t redirect.contains(\"/blogs/\" + oldUrlTitle + \"?\") ||\n\t\t\t\t\t\t redirect.contains(\"/blog/\" + oldUrlTitle + \"?\")) {\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t}\n\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tboolean ajax = ParamUtil.getBoolean(actionRequest, \"ajax\");\n\n\t\t\tif (ajax) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\t\t\tfor (BlogsEntryAttachmentFileEntryReference\n\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference :\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReferences) {\n\n\t\t\t\t\tJSONObject blogsEntryFileEntryReferencesJSONObject =\n\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"attributeDataImageId\",\n\t\t\t\t\t\tEditorConstants.ATTRIBUTE_DATA_IMAGE_ID);\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryId\",\n\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntryId()));\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryUrl\",\n\t\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntryURL(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetBlogsEntryAttachmentFileEntry(),\n\t\t\t\t\t\t\tStringPool.BLANK));\n\n\t\t\t\t\tjsonArray.put(blogsEntryFileEntryReferencesJSONObject);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\"blogsEntryAttachmentReferences\", jsonArray);\n\n\t\t\t\tjsonObject.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\tJSONPortletResponseUtil.writeJSON(\n\t\t\t\t\tactionRequest, actionResponse, jsonObject);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((entry != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tactionRequest, entry, redirect);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\t\tif (!windowState.equals(LiferayWindowState.POP_UP)) {\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tif (cmd.equals(Constants.ADD) && (entry != null)) {\n\t\t\t\t\t\t\tString namespace = PortalUtil.getPortletNamespace(\n\t\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"className\",\n\t\t\t\t\t\t\t\tBlogsEntry.class.getName());\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"classPK\",\n\t\t\t\t\t\t\t\tentry.getEntryId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\"mvcPath\", \"/html/portlet/blogs/error.jsp\");\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryDescriptionException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntrySmallImageNameException ||\n\t\t\t\t\t e instanceof EntrySmallImageSizeException ||\n\t\t\t\t\t e instanceof EntryTitleException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof LiferayFileItemException ||\n\t\t\t\t\t e instanceof SanitizerException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\tif (cause instanceof SanitizerException) {\n\t\t\t\t\tSessionErrors.add(actionRequest, SanitizerException.class);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\n\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\"mvcPath\", \"/html/portlet/blogs/error.jsp\");\n\t\t}\n\t}","id":98924,"modified_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\t\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\t\tblogsEntryAttachmentFileEntryReferences = null;\n\n\t\t\tUploadException uploadException =\n\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\tif (uploadException != null) {\n\t\t\t\tif (uploadException.isExceededLiferayFileItemSizeLimit()) {\n\t\t\t\t\tthrow new LiferayFileItemException();\n\t\t\t\t}\n\t\t\t\telse if (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\tthrow new FileSizeException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD) ||\n\t\t\t\t\t cmd.equals(Constants.UPDATE)) {\n\n\t\t\t\tCallable<Object[]> updateEntryCallable =\n\t\t\t\t\tnew UpdateEntryCallable(actionRequest);\n\n\t\t\t\tObject[] returnValue = TransactionHandlerUtil.invoke(\n\t\t\t\t\t_transactionAttribute, updateEntryCallable);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\t((List<BlogsEntryAttachmentFileEntryReference>)\n\t\t\t\t\t\treturnValue[2]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntries(actionRequest, false);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE_TO_TRASH)) {\n\t\t\t\tdeleteEntries(actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.RESTORE)) {\n\t\t\t\trestoreTrashEntries(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribe(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribe(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tString portletId = HttpUtil.getParameter(redirect, \"p_p_id\", false);\n\n\t\t\tif (Validator.isNotNull(oldUrlTitle)) {\n\t\t\t\tString oldRedirectParam =\n\t\t\t\t\tPortalUtil.getPortletNamespace(portletId) + \"redirect\";\n\n\t\t\t\tString oldRedirect = HttpUtil.getParameter(\n\t\t\t\t\tredirect, oldRedirectParam, false);\n\n\t\t\t\tif (Validator.isNotNull(oldRedirect)) {\n\t\t\t\t\tString newRedirect = HttpUtil.decodeURL(oldRedirect);\n\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldRedirectParam, \"redirect\");\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldRedirect, newRedirect);\n\t\t\t\t}\n\t\t\t\telse if (redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t\t\t redirect.contains(\"/blogs/\" + oldUrlTitle + \"?\") ||\n\t\t\t\t\t\t redirect.contains(\"/blog/\" + oldUrlTitle + \"?\")) {\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t}\n\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tboolean ajax = ParamUtil.getBoolean(actionRequest, \"ajax\");\n\n\t\t\tif (ajax) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\t\t\tfor (BlogsEntryAttachmentFileEntryReference\n\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference :\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReferences) {\n\n\t\t\t\t\tJSONObject blogsEntryFileEntryReferencesJSONObject =\n\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"attributeDataImageId\",\n\t\t\t\t\t\tEditorConstants.ATTRIBUTE_DATA_IMAGE_ID);\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryId\",\n\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntryId()));\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryUrl\",\n\t\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntryURL(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetBlogsEntryAttachmentFileEntry(),\n\t\t\t\t\t\t\tStringPool.BLANK));\n\n\t\t\t\t\tjsonArray.put(blogsEntryFileEntryReferencesJSONObject);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\"blogsEntryAttachmentReferences\", jsonArray);\n\n\t\t\t\tjsonObject.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\tJSONPortletResponseUtil.writeJSON(\n\t\t\t\t\tactionRequest, actionResponse, jsonObject);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((entry != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tactionRequest, entry, redirect);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\t\tif (!windowState.equals(LiferayWindowState.POP_UP)) {\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tif (cmd.equals(Constants.ADD) && (entry != null)) {\n\t\t\t\t\t\t\tString namespace = PortalUtil.getPortletNamespace(\n\t\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"className\",\n\t\t\t\t\t\t\t\tBlogsEntry.class.getName());\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"classPK\",\n\t\t\t\t\t\t\t\tentry.getEntryId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString mvcPath = \"/html/portlet/blogs/edit_entry.jsp\";\n\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tmvcPath = \"/html/portlet/blogs/error.jsp\";\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryDescriptionException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntrySmallImageNameException ||\n\t\t\t\t\t e instanceof EntrySmallImageSizeException ||\n\t\t\t\t\t e instanceof EntryTitleException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof LiferayFileItemException ||\n\t\t\t\t\t e instanceof SanitizerException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\tif (cause instanceof SanitizerException) {\n\t\t\t\t\tSessionErrors.add(actionRequest, SanitizerException.class);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", mvcPath);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\n\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\"mvcPath\", \"/html/portlet/blogs/error.jsp\");\n\t\t}\n\t}","commit_id":"b8cc1847fdf898f952951ad639bddc30176e3714","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteInstance(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tupdateInstance(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchCompanyException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\"mvcPath\", \"/html/portlet/portal_instances/error.jsp\");\n\t\t\t}\n\t\t\telse if (e instanceof CompanyMxException ||\n\t\t\t\t\t e instanceof CompanyVirtualHostException ||\n\t\t\t\t\t e instanceof CompanyWebIdException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof RequiredCompanyException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98925,"modified_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteInstance(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tupdateInstance(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString mvcPath =\n\t\t\t\t\"/html/portlet/portal_instances/error.jsp\";\n\n\t\t\tif (e instanceof NoSuchCompanyException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof CompanyMxException ||\n\t\t\t\t\t e instanceof CompanyVirtualHostException ||\n\t\t\t\t\t e instanceof CompanyWebIdException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tmvcPath = \"/html/portlet/portal_instances/edit_instance.jsp\";\n\t\t\t}\n\t\t\telse if (e instanceof RequiredCompanyException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", mvcPath);\n\t\t}\n\t}","commit_id":"c3170842fae851c34633473a72762035a5ee16b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tOrganization organization = null;\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\torganization = updateOrganization(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteOrganizations(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (organization != null) {\n\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\tredirect, actionResponse.getNamespace() + \"organizationId\",\n\t\t\t\t\torganization.getOrganizationId());\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchOrganizationException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tactionResponse.setRenderParameter(\"mvcPath\", \"/error.jsp\");\n\t\t\t}\n\t\t\telse if (e instanceof AddressCityException ||\n\t\t\t\t\t e instanceof AddressStreetException ||\n\t\t\t\t\t e instanceof AddressZipException ||\n\t\t\t\t\t e instanceof DuplicateOrganizationException ||\n\t\t\t\t\t e instanceof EmailAddressException ||\n\t\t\t\t\t e instanceof NoSuchCountryException ||\n\t\t\t\t\t e instanceof NoSuchListTypeException ||\n\t\t\t\t\t e instanceof NoSuchRegionException ||\n\t\t\t\t\t e instanceof OrganizationNameException ||\n\t\t\t\t\t e instanceof OrganizationParentException ||\n\t\t\t\t\t e instanceof PhoneNumberException ||\n\t\t\t\t\t e instanceof RequiredOrganizationException ||\n\t\t\t\t\t e instanceof WebsiteURLException) {\n\n\t\t\t\tif (e instanceof NoSuchListTypeException) {\n\t\t\t\t\tNoSuchListTypeException nslte = (NoSuchListTypeException)e;\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest,\n\t\t\t\t\t\te.getClass().getName() + nslte.getType());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof RequiredOrganizationException) {\n\t\t\t\t\tString redirect = PortalUtil.escapeRedirect(\n\t\t\t\t\t\tParamUtil.getString(actionRequest, \"redirect\"));\n\n\t\t\t\t\tlong organizationId = ParamUtil.getLong(\n\t\t\t\t\t\tactionRequest, \"organizationId\");\n\n\t\t\t\t\tif (organizationId > 0) {\n\t\t\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\t\t\tredirect,\n\t\t\t\t\t\t\tactionResponse.getNamespace() + \"organizationId\",\n\t\t\t\t\t\t\torganizationId);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98926,"modified_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tOrganization organization = null;\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\torganization = updateOrganization(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteOrganizations(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (organization != null) {\n\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\tredirect, actionResponse.getNamespace() + \"organizationId\",\n\t\t\t\t\torganization.getOrganizationId());\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString mvcPath = \"/edit_organization.jsp\";\n\n\t\t\tif (e instanceof NoSuchOrganizationException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tmvcPath = \"/error.jsp\";\n\t\t\t}\n\t\t\telse if (e instanceof AddressCityException ||\n\t\t\t\t\t e instanceof AddressStreetException ||\n\t\t\t\t\t e instanceof AddressZipException ||\n\t\t\t\t\t e instanceof DuplicateOrganizationException ||\n\t\t\t\t\t e instanceof EmailAddressException ||\n\t\t\t\t\t e instanceof NoSuchCountryException ||\n\t\t\t\t\t e instanceof NoSuchListTypeException ||\n\t\t\t\t\t e instanceof NoSuchRegionException ||\n\t\t\t\t\t e instanceof OrganizationNameException ||\n\t\t\t\t\t e instanceof OrganizationParentException ||\n\t\t\t\t\t e instanceof PhoneNumberException ||\n\t\t\t\t\t e instanceof RequiredOrganizationException ||\n\t\t\t\t\t e instanceof WebsiteURLException) {\n\n\t\t\t\tif (e instanceof NoSuchListTypeException) {\n\t\t\t\t\tNoSuchListTypeException nslte = (NoSuchListTypeException)e;\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest,\n\t\t\t\t\t\te.getClass().getName() + nslte.getType());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof RequiredOrganizationException) {\n\t\t\t\t\tString redirect = PortalUtil.escapeRedirect(\n\t\t\t\t\t\tParamUtil.getString(actionRequest, \"redirect\"));\n\n\t\t\t\t\tlong organizationId = ParamUtil.getLong(\n\t\t\t\t\t\tactionRequest, \"organizationId\");\n\n\t\t\t\t\tif (organizationId > 0) {\n\t\t\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\t\t\tredirect,\n\t\t\t\t\t\t\tactionResponse.getNamespace() + \"organizationId\",\n\t\t\t\t\t\t\torganizationId);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", mvcPath);\n\t\t}\n\t}","commit_id":"887c54c3698ae882cf0482cf311477b72b4c2961","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tDynamicActionRequest dynamicActionRequest = new DynamicActionRequest(\n\t\t\tactionRequest);\n\n\t\tlong prefixId = getListTypeId(\n\t\t\tactionRequest, \"prefixValue\", ListTypeConstants.CONTACT_PREFIX);\n\n\t\tdynamicActionRequest.setParameter(\"prefixId\", String.valueOf(prefixId));\n\n\t\tlong suffixId = getListTypeId(\n\t\t\tactionRequest, \"suffixValue\", ListTypeConstants.CONTACT_SUFFIX);\n\n\t\tdynamicActionRequest.setParameter(\"suffixId\", String.valueOf(suffixId));\n\n\t\tactionRequest = dynamicActionRequest;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tUser user = null;\n\t\t\tString oldScreenName = StringPool.BLANK;\n\t\t\tboolean updateLanguageId = false;\n\n\t\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\t\tuser = addUser(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DEACTIVATE) ||\n\t\t\t\t\t cmd.equals(Constants.DELETE) ||\n\t\t\t\t\t cmd.equals(Constants.RESTORE)) {\n\n\t\t\t\tdeleteUsers(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"deleteRole\")) {\n\t\t\t\tdeleteRole(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UPDATE)) {\n\t\t\t\tObject[] returnValue = updateUser(\n\t\t\t\t\tactionRequest, actionResponse);\n\n\t\t\t\tuser = (User)returnValue[0];\n\t\t\t\toldScreenName = ((String)returnValue[1]);\n\t\t\t\tupdateLanguageId = ((Boolean)returnValue[2]);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"unlock\")) {\n\t\t\t\tuser = updateLockout(actionRequest);\n\t\t\t}\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (user != null) {\n\t\t\t\tif (Validator.isNotNull(oldScreenName)) {\n\n\t\t\t\t\t// This will fix the redirect if the user is on his personal\n\t\t\t\t\t// my account page and changes his screen name. A redirect\n\t\t\t\t\t// that references the old screen name no longer points to a\n\t\t\t\t\t// valid screen name and therefore needs to be updated.\n\n\t\t\t\t\tGroup group = user.getGroup();\n\n\t\t\t\t\tif (group.getGroupId() == themeDisplay.getScopeGroupId()) {\n\t\t\t\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\t\t\t\tString friendlyURLPath = group.getPathFriendlyURL(\n\t\t\t\t\t\t\tlayout.isPrivateLayout(), themeDisplay);\n\n\t\t\t\t\t\tString oldPath =\n\t\t\t\t\t\t\tfriendlyURLPath + StringPool.SLASH + oldScreenName;\n\t\t\t\t\t\tString newPath =\n\t\t\t\t\t\t\tfriendlyURLPath + StringPool.SLASH +\n\t\t\t\t\t\t\t\tuser.getScreenName();\n\n\t\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\t\tredirect, oldPath, newPath);\n\n\t\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\t\tredirect, HttpUtil.encodeURL(oldPath),\n\t\t\t\t\t\t\tHttpUtil.encodeURL(newPath));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (updateLanguageId && themeDisplay.isI18n()) {\n\t\t\t\t\tString i18nLanguageId = user.getLanguageId();\n\t\t\t\t\tint pos = i18nLanguageId.indexOf(CharPool.UNDERLINE);\n\n\t\t\t\t\tif (pos != -1) {\n\t\t\t\t\t\ti18nLanguageId = i18nLanguageId.substring(0, pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tString i18nPath = StringPool.SLASH + i18nLanguageId;\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, themeDisplay.getI18nPath(), i18nPath);\n\t\t\t\t}\n\n\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\tredirect, actionResponse.getNamespace() + \"p_u_i_d\",\n\t\t\t\t\tuser.getUserId());\n\t\t\t}\n\n\t\t\tGroup scopeGroup = themeDisplay.getScopeGroup();\n\n\t\t\tif (scopeGroup.isUser() &&\n\t\t\t\t(_userLocalService.fetchUserById(\n\t\t\t\t\tscopeGroup.getClassPK()) == null)) {\n\n\t\t\t\tredirect = HttpUtil.setParameter(redirect, \"doAsGroupId\", 0);\n\t\t\t\tredirect = HttpUtil.setParameter(redirect, \"refererPlid\", 0);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchUserException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tactionResponse.setRenderParameter(\"mvcPath\", \"/error.jsp\");\n\t\t\t}\n\t\t\telse if (e instanceof AddressCityException ||\n\t\t\t\t\t e instanceof AddressStreetException ||\n\t\t\t\t\t e instanceof AddressZipException ||\n\t\t\t\t\t e instanceof CompanyMaxUsersException ||\n\t\t\t\t\t e instanceof ContactBirthdayException ||\n\t\t\t\t\t e instanceof ContactNameException ||\n\t\t\t\t\t e instanceof EmailAddressException ||\n\t\t\t\t\t e instanceof GroupFriendlyURLException ||\n\t\t\t\t\t e instanceof MembershipPolicyException ||\n\t\t\t\t\t e instanceof NoSuchCountryException ||\n\t\t\t\t\t e instanceof NoSuchListTypeException ||\n\t\t\t\t\t e instanceof NoSuchRegionException ||\n\t\t\t\t\t e instanceof PhoneNumberException ||\n\t\t\t\t\t e instanceof RequiredUserException ||\n\t\t\t\t\t e instanceof UserEmailAddressException ||\n\t\t\t\t\t e instanceof UserFieldException ||\n\t\t\t\t\t e instanceof UserIdException ||\n\t\t\t\t\t e instanceof UserPasswordException ||\n\t\t\t\t\t e instanceof UserReminderQueryException ||\n\t\t\t\t\t e instanceof UserScreenNameException ||\n\t\t\t\t\t e instanceof UserSmsException ||\n\t\t\t\t\t e instanceof WebsiteURLException) {\n\n\t\t\t\tif (e instanceof NoSuchListTypeException) {\n\t\t\t\t\tNoSuchListTypeException nslte = (NoSuchListTypeException)e;\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest,\n\t\t\t\t\t\te.getClass().getName() + nslte.getType());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t\t}\n\n\t\t\t\tString password1 = actionRequest.getParameter(\"password1\");\n\t\t\t\tString password2 = actionRequest.getParameter(\"password2\");\n\n\t\t\t\tboolean submittedPassword = false;\n\n\t\t\t\tif (!Validator.isBlank(password1) ||\n\t\t\t\t\t!Validator.isBlank(password2)) {\n\n\t\t\t\t\tsubmittedPassword = true;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof CompanyMaxUsersException ||\n\t\t\t\t\te instanceof RequiredUserException || submittedPassword) {\n\n\t\t\t\t\tString redirect = PortalUtil.escapeRedirect(\n\t\t\t\t\t\tParamUtil.getString(actionRequest, \"redirect\"));\n\n\t\t\t\t\tif (submittedPassword) {\n\t\t\t\t\t\tUser user = PortalUtil.getSelectedUser(actionRequest);\n\n\t\t\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\t\t\tredirect, actionResponse.getNamespace() + \"p_u_i_d\",\n\t\t\t\t\t\t\tuser.getUserId());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":98927,"modified_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tDynamicActionRequest dynamicActionRequest = new DynamicActionRequest(\n\t\t\tactionRequest);\n\n\t\tlong prefixId = getListTypeId(\n\t\t\tactionRequest, \"prefixValue\", ListTypeConstants.CONTACT_PREFIX);\n\n\t\tdynamicActionRequest.setParameter(\"prefixId\", String.valueOf(prefixId));\n\n\t\tlong suffixId = getListTypeId(\n\t\t\tactionRequest, \"suffixValue\", ListTypeConstants.CONTACT_SUFFIX);\n\n\t\tdynamicActionRequest.setParameter(\"suffixId\", String.valueOf(suffixId));\n\n\t\tactionRequest = dynamicActionRequest;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tUser user = null;\n\t\t\tString oldScreenName = StringPool.BLANK;\n\t\t\tboolean updateLanguageId = false;\n\n\t\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\t\tuser = addUser(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DEACTIVATE) ||\n\t\t\t\t\t cmd.equals(Constants.DELETE) ||\n\t\t\t\t\t cmd.equals(Constants.RESTORE)) {\n\n\t\t\t\tdeleteUsers(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"deleteRole\")) {\n\t\t\t\tdeleteRole(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UPDATE)) {\n\t\t\t\tObject[] returnValue = updateUser(\n\t\t\t\t\tactionRequest, actionResponse);\n\n\t\t\t\tuser = (User)returnValue[0];\n\t\t\t\toldScreenName = ((String)returnValue[1]);\n\t\t\t\tupdateLanguageId = ((Boolean)returnValue[2]);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"unlock\")) {\n\t\t\t\tuser = updateLockout(actionRequest);\n\t\t\t}\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (user != null) {\n\t\t\t\tif (Validator.isNotNull(oldScreenName)) {\n\n\t\t\t\t\t// This will fix the redirect if the user is on his personal\n\t\t\t\t\t// my account page and changes his screen name. A redirect\n\t\t\t\t\t// that references the old screen name no longer points to a\n\t\t\t\t\t// valid screen name and therefore needs to be updated.\n\n\t\t\t\t\tGroup group = user.getGroup();\n\n\t\t\t\t\tif (group.getGroupId() == themeDisplay.getScopeGroupId()) {\n\t\t\t\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\t\t\t\tString friendlyURLPath = group.getPathFriendlyURL(\n\t\t\t\t\t\t\tlayout.isPrivateLayout(), themeDisplay);\n\n\t\t\t\t\t\tString oldPath =\n\t\t\t\t\t\t\tfriendlyURLPath + StringPool.SLASH + oldScreenName;\n\t\t\t\t\t\tString newPath =\n\t\t\t\t\t\t\tfriendlyURLPath + StringPool.SLASH +\n\t\t\t\t\t\t\t\tuser.getScreenName();\n\n\t\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\t\tredirect, oldPath, newPath);\n\n\t\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\t\tredirect, HttpUtil.encodeURL(oldPath),\n\t\t\t\t\t\t\tHttpUtil.encodeURL(newPath));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (updateLanguageId && themeDisplay.isI18n()) {\n\t\t\t\t\tString i18nLanguageId = user.getLanguageId();\n\t\t\t\t\tint pos = i18nLanguageId.indexOf(CharPool.UNDERLINE);\n\n\t\t\t\t\tif (pos != -1) {\n\t\t\t\t\t\ti18nLanguageId = i18nLanguageId.substring(0, pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tString i18nPath = StringPool.SLASH + i18nLanguageId;\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, themeDisplay.getI18nPath(), i18nPath);\n\t\t\t\t}\n\n\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\tredirect, actionResponse.getNamespace() + \"p_u_i_d\",\n\t\t\t\t\tuser.getUserId());\n\t\t\t}\n\n\t\t\tGroup scopeGroup = themeDisplay.getScopeGroup();\n\n\t\t\tif (scopeGroup.isUser() &&\n\t\t\t\t(_userLocalService.fetchUserById(\n\t\t\t\t\tscopeGroup.getClassPK()) == null)) {\n\n\t\t\t\tredirect = HttpUtil.setParameter(redirect, \"doAsGroupId\", 0);\n\t\t\t\tredirect = HttpUtil.setParameter(redirect, \"refererPlid\", 0);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString mvcPath = \"/edit_user.jsp\";\n\n\t\t\tif (e instanceof NoSuchUserException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tmvcPath = \"/error.jsp\";\n\t\t\t}\n\t\t\telse if (e instanceof AddressCityException ||\n\t\t\t\t\t e instanceof AddressStreetException ||\n\t\t\t\t\t e instanceof AddressZipException ||\n\t\t\t\t\t e instanceof CompanyMaxUsersException ||\n\t\t\t\t\t e instanceof ContactBirthdayException ||\n\t\t\t\t\t e instanceof ContactNameException ||\n\t\t\t\t\t e instanceof EmailAddressException ||\n\t\t\t\t\t e instanceof GroupFriendlyURLException ||\n\t\t\t\t\t e instanceof MembershipPolicyException ||\n\t\t\t\t\t e instanceof NoSuchCountryException ||\n\t\t\t\t\t e instanceof NoSuchListTypeException ||\n\t\t\t\t\t e instanceof NoSuchRegionException ||\n\t\t\t\t\t e instanceof PhoneNumberException ||\n\t\t\t\t\t e instanceof RequiredUserException ||\n\t\t\t\t\t e instanceof UserEmailAddressException ||\n\t\t\t\t\t e instanceof UserFieldException ||\n\t\t\t\t\t e instanceof UserIdException ||\n\t\t\t\t\t e instanceof UserPasswordException ||\n\t\t\t\t\t e instanceof UserReminderQueryException ||\n\t\t\t\t\t e instanceof UserScreenNameException ||\n\t\t\t\t\t e instanceof UserSmsException ||\n\t\t\t\t\t e instanceof WebsiteURLException) {\n\n\t\t\t\tif (e instanceof NoSuchListTypeException) {\n\t\t\t\t\tNoSuchListTypeException nslte = (NoSuchListTypeException)e;\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest,\n\t\t\t\t\t\te.getClass().getName() + nslte.getType());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t\t}\n\n\t\t\t\tString password1 = actionRequest.getParameter(\"password1\");\n\t\t\t\tString password2 = actionRequest.getParameter(\"password2\");\n\n\t\t\t\tboolean submittedPassword = false;\n\n\t\t\t\tif (!Validator.isBlank(password1) ||\n\t\t\t\t\t!Validator.isBlank(password2)) {\n\n\t\t\t\t\tsubmittedPassword = true;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof CompanyMaxUsersException ||\n\t\t\t\t\te instanceof RequiredUserException || submittedPassword) {\n\n\t\t\t\t\tString redirect = PortalUtil.escapeRedirect(\n\t\t\t\t\t\tParamUtil.getString(actionRequest, \"redirect\"));\n\n\t\t\t\t\tif (submittedPassword) {\n\t\t\t\t\t\tUser user = PortalUtil.getSelectedUser(actionRequest);\n\n\t\t\t\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\t\t\t\tredirect, actionResponse.getNamespace() + \"p_u_i_d\",\n\t\t\t\t\t\t\tuser.getUserId());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", mvcPath);\n\t\t}\n\t}","commit_id":"887c54c3698ae882cf0482cf311477b72b4c2961","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player != null) {\n            player.drawCards(3, game);\n            \n            boolean putOnTop = player.chooseUse(Outcome.Neutral, \"Put cards on top?\", source, game);\n            putInLibrary(player, source, game, putOnTop);\n            putInLibrary(player, source, game, putOnTop);\n            \n            return true;\n        }\n        return false;\n    }","id":98928,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            controller.drawCards(3, game);\n            boolean putOnTop = controller.chooseUse(Outcome.Neutral, \"Put cards on top?\", source, game);\n            TargetCardInHand target = new TargetCardInHand(2, 2, new FilterCard());\n            controller.chooseTarget(Outcome.Detriment, target, source, game);\n            Cards cardsToLibrary = new CardsImpl(target.getTargets());\n            if (!cardsToLibrary.isEmpty()) {\n                if (putOnTop) {\n                    controller.putCardsOnTopOfLibrary(cardsToLibrary, game, source, false);\n                } else {\n                    controller.putCardsOnBottomOfLibrary(cardsToLibrary, game, source, false);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"d26b8aeae06f9d52083cb583ad24ebd30d6ab500","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player != null) {\r\n            TargetCardInHand target = new TargetCardInHand();\r\n            player.chooseTarget(Outcome.ReturnToHand, target, source, game);\r\n            Card card = player.getHand().get(target.getFirstTarget(), game);\r\n            if (card != null) {\r\n                player.getHand().remove(card);\r\n                card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98929,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            TargetCardInHand target = new TargetCardInHand();\r\n            controller.chooseTarget(Outcome.ReturnToHand, target, source, game);\r\n            Card card = controller.getHand().get(target.getFirstTarget(), game);\r\n            if (card != null) {\r\n                controller.putCardsOnTopOfLibrary(new CardsImpl(card), game, source, false);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"d26b8aeae06f9d52083cb583ad24ebd30d6ab500","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player != null) {\n            player.drawCards(3, game);\n            putOnLibrary(player, source, game);\n            putOnLibrary(player, source, game);\n            return true;\n        }\n        return false;\n    }","id":98930,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            controller.drawCards(3, game);\n            TargetCardInHand target = new TargetCardInHand(2, 2, new FilterCard());\n            controller.chooseTarget(Outcome.Detriment, target, source, game);\n            Cards cardsToLibrary = new CardsImpl(target.getTargets());\n            if (!cardsToLibrary.isEmpty()) {\n                controller.putCardsOnTopOfLibrary(cardsToLibrary, game, source, true);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"d26b8aeae06f9d52083cb583ad24ebd30d6ab500","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            controller.drawCards(2, game);\n            putOnLibrary(controller, source, game);\n            putOnLibrary(controller, source, game);\n            return true;\n        }\n        return false;\n    }","id":98931,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            controller.drawCards(2, game);\n            TargetCardInHand target = new TargetCardInHand(2, 2, new FilterCard());\n            controller.chooseTarget(Outcome.Detriment, target, source, game);\n            Cards cardsToLibrary = new CardsImpl(target.getTargets());\n            if (!cardsToLibrary.isEmpty()) {\n                controller.putCardsOnBottomOfLibrary(cardsToLibrary, game, source, false);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"d26b8aeae06f9d52083cb583ad24ebd30d6ab500","url":"https://github.com/magefree/mage"},{"original_method":"/**\r\n     *\r\n     * @param game\r\n     * @param source\r\n     * @param cardName name of the card to exile\r\n     * @param targetPlayerId id of the target player to exile card name from his\r\n     * or her zones\r\n     * @return\r\n     */\r\n    public boolean applySearchAndExile(Game game, Ability source, String cardName, UUID targetPlayerId) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (cardName != null && controller != null) {\r\n            Player targetPlayer = game.getPlayer(targetPlayerId);\r\n            if (targetPlayer != null) {\r\n                FilterCard filter = new FilterCard(\"card named \" + cardName);\r\n                filter.add(new NamePredicate(cardName));\r\n\r\n                // cards in Graveyard\r\n                int cardsCount = (cardName.isEmpty() ? 0 : targetPlayer.getGraveyard().count(filter, game));\r\n                if (cardsCount > 0) {\r\n                    filter.setMessage(\"card named \" + cardName + \" in the graveyard of \" + targetPlayer.getLogName());\r\n                    TargetCard target = new TargetCard((graveyardExileOptional ? 0 : cardsCount), cardsCount, Zone.GRAVEYARD, filter);\r\n                    if (controller.choose(Outcome.Exile, targetPlayer.getGraveyard(), target, game)) {\r\n                        List<UUID> targets = target.getTargets();\r\n                        for (UUID targetId : targets) {\r\n                            Card targetCard = targetPlayer.getGraveyard().get(targetId, game);\r\n                            if (targetCard != null) {\r\n                                targetPlayer.getGraveyard().remove(targetCard);\r\n                                controller.moveCardToExileWithInfo(targetCard, null, null, source.getSourceId(), game, Zone.GRAVEYARD, true);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // cards in Hand\r\n                cardsCount = (cardName.isEmpty() ? 0 : targetPlayer.getHand().count(filter, game));\r\n                filter.setMessage(\"card named \" + cardName + \" in the hand of \" + targetPlayer.getLogName());\r\n                TargetCard target = new TargetCard(0, cardsCount, Zone.HAND, filter);\r\n                if (controller.choose(Outcome.Exile, targetPlayer.getHand(), target, game)) {\r\n                    List<UUID> targets = target.getTargets();\r\n                    for (UUID targetId : targets) {\r\n                        Card targetCard = targetPlayer.getHand().get(targetId, game);\r\n                        if (targetCard != null) {\r\n                            targetPlayer.getHand().remove(targetCard);\r\n                            controller.moveCardToExileWithInfo(targetCard, null, null, source.getSourceId(), game, Zone.HAND, true);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // cards in Library\r\n                Cards cardsInLibrary = new CardsImpl(Zone.LIBRARY);\r\n                cardsInLibrary.addAll(targetPlayer.getLibrary().getCards(game));\r\n                cardsCount = (cardName.isEmpty() ? 0 : cardsInLibrary.count(filter, game));\r\n                filter.setMessage(\"card named \" + cardName + \" in the library of \" + targetPlayer.getLogName());\r\n                TargetCardInLibrary targetLib = new TargetCardInLibrary(0, cardsCount, filter);\r\n                if (controller.choose(Outcome.Exile, cardsInLibrary, targetLib, game)) {\r\n                    List<UUID> targets = targetLib.getTargets();\r\n                    for (UUID targetId : targets) {\r\n                        Card targetCard = targetPlayer.getLibrary().remove(targetId, game);\r\n                        if (targetCard != null) {\r\n                            controller.moveCardToExileWithInfo(targetCard, null, null, source.getSourceId(), game, Zone.LIBRARY, true);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                targetPlayer.shuffleLibrary(game);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }","id":98932,"modified_method":"/**\r\n     *\r\n     * @param game\r\n     * @param source\r\n     * @param cardName name of the card to exile\r\n     * @param targetPlayerId id of the target player to exile card name from his\r\n     * or her zones\r\n     * @return\r\n     */\r\n    public boolean applySearchAndExile(Game game, Ability source, String cardName, UUID targetPlayerId) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (cardName != null && controller != null) {\r\n            Player targetPlayer = game.getPlayer(targetPlayerId);\r\n            if (targetPlayer != null) {\r\n                FilterCard filter = new FilterCard(\"card named \" + cardName);\r\n                filter.add(new NamePredicate(cardName));\r\n\r\n                // cards in Graveyard\r\n                int cardsCount = (cardName.isEmpty() ? 0 : targetPlayer.getGraveyard().count(filter, game));\r\n                if (cardsCount > 0) {\r\n                    filter.setMessage(\"card named \" + cardName + \" in the graveyard of \" + targetPlayer.getLogName());\r\n                    TargetCard target = new TargetCard((graveyardExileOptional ? 0 : cardsCount), cardsCount, Zone.GRAVEYARD, filter);\r\n                    if (controller.choose(Outcome.Exile, targetPlayer.getGraveyard(), target, game)) {\r\n                        controller.moveCards(new CardsImpl(target.getTargets()), Zone.EXILED, source, game);\r\n                    }\r\n                }\r\n\r\n                // cards in Hand\r\n                cardsCount = (cardName.isEmpty() ? 0 : targetPlayer.getHand().count(filter, game));\r\n                filter.setMessage(\"card named \" + cardName + \" in the hand of \" + targetPlayer.getLogName());\r\n                TargetCard target = new TargetCard(0, cardsCount, Zone.HAND, filter);\r\n                if (controller.choose(Outcome.Exile, targetPlayer.getHand(), target, game)) {\r\n                    controller.moveCards(new CardsImpl(target.getTargets()), Zone.EXILED, source, game);\r\n                }\r\n\r\n                // cards in Library\r\n                Cards cardsInLibrary = new CardsImpl(Zone.LIBRARY);\r\n                cardsInLibrary.addAll(targetPlayer.getLibrary().getCards(game));\r\n                cardsCount = (cardName.isEmpty() ? 0 : cardsInLibrary.count(filter, game));\r\n                filter.setMessage(\"card named \" + cardName + \" in the library of \" + targetPlayer.getLogName());\r\n                TargetCardInLibrary targetLib = new TargetCardInLibrary(0, cardsCount, filter);\r\n                if (controller.choose(Outcome.Exile, cardsInLibrary, targetLib, game)) {\r\n                    controller.moveCards(new CardsImpl(target.getTargets()), Zone.EXILED, source, game);\r\n                }\r\n                targetPlayer.shuffleLibrary(game);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }","commit_id":"d26b8aeae06f9d52083cb583ad24ebd30d6ab500","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n\r\n            Map<UUID, List<Permanent>> permanentsOwned = new HashMap<>();\r\n            Collection<Permanent> permanents = game.getBattlefield().getActivePermanents(source.getControllerId(), game);\r\n            for (Permanent permanent : permanents) {\r\n                List<Permanent> list = permanentsOwned.get(permanent.getOwnerId());\r\n                if (list == null) {\r\n                    list = new ArrayList<>();\r\n                    permanentsOwned.put(permanent.getOwnerId(), list);\r\n                }\r\n                list.add(permanent);\r\n            }\r\n\r\n            // shuffle permanents and hand cards into owner's library\r\n            Map<UUID, Integer> permanentsCount = new HashMap<>();\r\n\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    int handCards = player.getHand().size();\r\n                    player.moveCards(player.getHand(), Zone.HAND, Zone.LIBRARY, source, game);\r\n                    List<Permanent> list = permanentsOwned.remove(player.getId());\r\n                    permanentsCount.put(playerId, handCards + (list != null ? list.size() : 0));\r\n                    for (Permanent permanent : list) {\r\n                        player.moveCardToLibraryWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD, true, true);\r\n                    }\r\n                    player.shuffleLibrary(game);\r\n                }\r\n            }\r\n\r\n            game.applyEffects(); // so effects from creatures that were on the battlefield won't trigger from draw or put into play\r\n\r\n            // Draw cards\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    int count = permanentsCount.get(playerId);\r\n                    if (count > 0) {\r\n                        player.drawCards(count, game);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // put lands onto the battlefield\r\n            Cards toBattlefield = new CardsImpl();\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    TargetCard target = new TargetCardInHand(0, Integer.MAX_VALUE, new FilterLandCard(\"put any number of land cards from your hand onto the battlefield\"));\r\n                    player.chooseTarget(Outcome.PutLandInPlay, player.getHand(), target, source, game);\r\n                    toBattlefield.addAll(target.getTargets());\r\n                }\r\n            }\r\n            return controller.moveCards(toBattlefield.getCards(game), Zone.BATTLEFIELD, source, game, true, false, true, null);\r\n        }\r\n        return false;\r\n    }","id":98933,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n\r\n            Map<UUID, List<Permanent>> permanentsOwned = new HashMap<>();\r\n            Collection<Permanent> permanents = game.getBattlefield().getActivePermanents(source.getControllerId(), game);\r\n            for (Permanent permanent : permanents) {\r\n                List<Permanent> list = permanentsOwned.get(permanent.getOwnerId());\r\n                if (list == null) {\r\n                    list = new ArrayList<>();\r\n                    permanentsOwned.put(permanent.getOwnerId(), list);\r\n                }\r\n                list.add(permanent);\r\n            }\r\n\r\n            // shuffle permanents and hand cards into owner's library\r\n            Map<UUID, Integer> permanentsCount = new HashMap<>();\r\n\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    int handCards = player.getHand().size();\r\n                    player.moveCards(player.getHand(), Zone.HAND, Zone.LIBRARY, source, game);\r\n                    List<Permanent> list = permanentsOwned.remove(player.getId());\r\n                    permanentsCount.put(playerId, handCards + (list != null ? list.size() : 0));\r\n                    for (Permanent permanent : list) {\r\n                        player.moveCardToLibraryWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD, true, true);\r\n                    }\r\n                    player.shuffleLibrary(game);\r\n                }\r\n            }\r\n\r\n            game.applyEffects(); // so effects from creatures that were on the battlefield won't trigger from draw or put into play\r\n\r\n            // Draw cards\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    int count = permanentsCount.get(playerId);\r\n                    if (count > 0) {\r\n                        player.drawCards(count, game);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // put lands onto the battlefield\r\n            Cards toBattlefield = new CardsImpl();\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    TargetCard target = new TargetCardInHand(0, Integer.MAX_VALUE, new FilterLandCard(\"put any number of land cards from your hand onto the battlefield\"));\r\n                    player.chooseTarget(Outcome.PutLandInPlay, player.getHand(), target, source, game);\r\n                    toBattlefield.addAll(target.getTargets());\r\n                }\r\n            }\r\n            return controller.moveCards(toBattlefield.getCards(game), Zone.BATTLEFIELD, source, game, false, false, true, null);\r\n        }\r\n        return false;\r\n    }","commit_id":"d26b8aeae06f9d52083cb583ad24ebd30d6ab500","url":"https://github.com/magefree/mage"},{"original_method":"public WhirlpoolDrake(UUID ownerId) {\r\n        super(ownerId, 34, \"Whirlpool Drake\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{3}{U}\");\r\n        this.expansionSetCode = \"APC\";\r\n        this.subtype.add(\"Drake\");\r\n\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n        // When Whirlpool Drake enters the battlefield, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new WhirlpoolSDrakeTriggeredEffect(), false));\r\n        \r\n        // When Whirlpool Drake dies, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new DiesTriggeredAbility(new WhirlpoolSDrakeTriggeredEffect(), false));\r\n    }","id":98934,"modified_method":"public WhirlpoolDrake(UUID ownerId) {\r\n        super(ownerId, 34, \"Whirlpool Drake\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{3}{U}\");\r\n        this.expansionSetCode = \"APC\";\r\n        this.subtype.add(\"Drake\");\r\n\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n        // When Whirlpool Drake enters the battlefield, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect(), false));\r\n\r\n        // When Whirlpool Drake dies, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new DiesTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect(), false));\r\n    }","commit_id":"eb1c738b370b20300c6c1ba00da302e0ef2f561f","url":"https://github.com/magefree/mage"},{"original_method":"public WhirlpoolRider(UUID ownerId) {\r\n        super(ownerId, 35, \"Whirlpool Rider\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{U}\");\r\n        this.expansionSetCode = \"APC\";\r\n        this.subtype.add(\"Merfolk\");\r\n\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // When Whirlpool Rider enters the battlefield, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new WhirlpoolRiderTriggeredEffect()));\r\n\r\n    }","id":98935,"modified_method":"public WhirlpoolRider(UUID ownerId) {\r\n        super(ownerId, 35, \"Whirlpool Rider\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{U}\");\r\n        this.expansionSetCode = \"APC\";\r\n        this.subtype.add(\"Merfolk\");\r\n\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // When Whirlpool Rider enters the battlefield, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect()));\r\n\r\n    }","commit_id":"eb1c738b370b20300c6c1ba00da302e0ef2f561f","url":"https://github.com/magefree/mage"},{"original_method":"public WhirlpoolWarrior(UUID ownerId) {\r\n        super(ownerId, 29, \"Whirlpool Warrior\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{U}\");\r\n        this.expansionSetCode = \"PC2\";\r\n        this.subtype.add(\"Merfolk\");\r\n        this.subtype.add(\"Warrior\");\r\n\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // When Whirlpool Warrior enters the battlefield, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new WhirlpoolWarriorTriggeredEffect()));\r\n\r\n        // {R}, Sacrifice Whirlpool Warrior: Each player shuffles the cards from his or her hand into his or her library, then draws that many cards.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new WhirlpoolWarriorActivatedEffect(), new ManaCostsImpl(\"{R}\"));\r\n        ability.addCost(new SacrificeSourceCost());\r\n        this.addAbility(ability);\r\n    }","id":98936,"modified_method":"public WhirlpoolWarrior(UUID ownerId) {\r\n        super(ownerId, 29, \"Whirlpool Warrior\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{U}\");\r\n        this.expansionSetCode = \"PC2\";\r\n        this.subtype.add(\"Merfolk\");\r\n        this.subtype.add(\"Warrior\");\r\n\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // When Whirlpool Warrior enters the battlefield, shuffle the cards from your hand into your library, then draw that many cards.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect()));\r\n\r\n        // {R}, Sacrifice Whirlpool Warrior: Each player shuffles the cards from his or her hand into his or her library, then draws that many cards.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new WhirlpoolWarriorActivatedEffect(), new ManaCostsImpl(\"{R}\"));\r\n        ability.addCost(new SacrificeSourceCost());\r\n        this.addAbility(ability);\r\n    }","commit_id":"eb1c738b370b20300c6c1ba00da302e0ef2f561f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            for (UUID playerId : controller.getInRange()) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    int cardsHand = player.getHand().size();\r\n                    if (cardsHand > 0) {\r\n                        for (Card card : player.getHand().getCards(game)) {\r\n                            if (card != null) {\r\n                                player.removeFromHand(card, game);\r\n                                card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                            }\r\n                        }\r\n                        game.informPlayers(player.getLogName() + \" shuffles the cards from his or her hand into his or her library\");\r\n                        player.shuffleLibrary(game);\r\n                        player.drawCards(cardsHand, game);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":98937,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Map<UUID, Integer> playerCards = new LinkedHashMap<>();\r\n            for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    int cardsHand = player.getHand().size();\r\n                    if (cardsHand > 0) {\r\n                        playerCards.put(playerId, cardsHand);\r\n                        player.moveCards(player.getHand(), Zone.LIBRARY, source, game);\r\n                        player.shuffleLibrary(game);\r\n                    }\r\n                }\r\n            }\r\n            for (Entry<UUID, Integer> entry : playerCards.entrySet()) {\r\n                Player player = game.getPlayer(entry.getKey());\r\n                if (player != null) {\r\n                    player.drawCards(entry.getValue(), game);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"eb1c738b370b20300c6c1ba00da302e0ef2f561f","url":"https://github.com/magefree/mage"},{"original_method":"public CachedModuleDescriptor getCachedModuleDescriptor(ModuleVersionRepository repository, ModuleRevisionId moduleRevisionId) {\n        ModuleDescriptorCacheEntry moduleDescriptorCacheEntry = getCache().get(createKey(repository, moduleRevisionId));\n        if (moduleDescriptorCacheEntry == null) {\n            return null;\n        }\n        ModuleDescriptor descriptor = null;\n        if (!moduleDescriptorCacheEntry.isMissing) {\n            descriptor = moduleDescriptorStore.getModuleDescriptor(repository, moduleRevisionId);\n        }\n        return new DefaultCachedModuleDescriptor(moduleDescriptorCacheEntry, descriptor, timeProvider);\n    }","id":98938,"modified_method":"public CachedModuleDescriptor getCachedModuleDescriptor(ModuleVersionRepository repository, ModuleRevisionId moduleRevisionId) {\n        ModuleDescriptorCacheEntry moduleDescriptorCacheEntry = getCache().get(createKey(repository, moduleRevisionId));\n        if (moduleDescriptorCacheEntry == null) {\n            return null;\n        }\n        if (moduleDescriptorCacheEntry.isMissing) {\n            return new DefaultCachedModuleDescriptor(moduleDescriptorCacheEntry, null, timeProvider);\n        }\n        ModuleDescriptor descriptor = moduleDescriptorStore.getModuleDescriptor(repository, moduleRevisionId);\n        if (descriptor == null) {\n            // Descriptor file has been manually deleted - ignore the entry\n            return null;\n        }\n        return new DefaultCachedModuleDescriptor(moduleDescriptorCacheEntry, descriptor, timeProvider);\n    }","commit_id":"87c2a5b07b9356082814aa4f13a6d82e203eefbd","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleDescriptor getModuleDescriptor(ModuleVersionRepository repository, ModuleRevisionId moduleRevisionId) {\n        File moduleDescriptorFile = moduleDescriptorFileStore.getModuleDescriptorFile(repository, moduleRevisionId);\n        return parseModuleDescriptorFile(moduleDescriptorFile);\n    }","id":98939,"modified_method":"public ModuleDescriptor getModuleDescriptor(ModuleVersionRepository repository, ModuleRevisionId moduleRevisionId) {\n        File moduleDescriptorFile = moduleDescriptorFileStore.getModuleDescriptorFile(repository, moduleRevisionId);\n        if (moduleDescriptorFile.exists()) {\n            return parseModuleDescriptorFile(moduleDescriptorFile);\n        }\n        return null;\n    }","commit_id":"87c2a5b07b9356082814aa4f13a6d82e203eefbd","url":"https://github.com/gradle/gradle"},{"original_method":"public List<ModelRoot> getNonDefaultModelRoots() {\n    return CollectionUtil.iteratorAsList(getModuleDescriptor().modelRoots());\n  }","id":98940,"modified_method":"public List<ModelRoot> getNonDefaultModelRoots() {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      return descriptor.getModelRoots();\n    }\n    return new ArrayList<ModelRoot>();\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<String> getClassPath() {\n    ArrayList<String> result = new ArrayList<String>();\n\n    if (getModuleDescriptor() != null) {\n      for (ClassPathEntry entry : CollectionUtil.iteratorAsIterable(getModuleDescriptor().classPathEntrys())) {\n        result.add(entry.getPath());\n      }\n    }\n\n    return result;\n  }","id":98941,"modified_method":"public List<String> getClassPath() {\n    ArrayList<String> result = new ArrayList<String>();\n\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      for (ClassPathEntry entry : CollectionUtil.iteratorAsIterable(descriptor.classPathEntrys())) {\n        result.add(entry.getPath());\n      }\n    }\n\n    return result;\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Dependency> getDependencies() {\n    List<Dependency> result = new ArrayList<Dependency>();\n    if (getModuleDescriptor() != null) {\n      for (ModuleReference ref : getModuleDescriptor().getDependencys()) {\n        result.add(new Dependency(ref.getName(), ref.getReexport()));\n      }\n    }\n    return result;\n  }","id":98942,"modified_method":"public List<Dependency> getDependencies() {\n    List<Dependency> result = new ArrayList<Dependency>();\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      for (ModuleReference ref : descriptor.getDependencys()) {\n        result.add(new Dependency(ref.getName(), ref.getReexport()));\n      }\n    }\n    return result;\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isCompileInMPS() {\n    return getModuleDescriptor().getCompileInMPS();\n  }","id":98943,"modified_method":"public boolean isCompileInMPS() {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    return descriptor != null && descriptor.getCompileInMPS();\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addModuleImport(final String moduleUID) {\n    CommandProcessor.instance().executeCommand(new Runnable() {\n      public void run() {\n        ModuleDescriptor md = getModuleDescriptor();\n\n        for (ModuleReference r : md.getDependencys()) {\n          if (moduleUID.equals(r.getName())) {\n            return;\n          }\n        }\n\n        ModuleReference ref = ModuleReference.newInstance(md.getModel());\n        ref.setName(moduleUID);\n        md.addDependency(ref);\n\n        setModuleDescriptor(md);\n\n        save();\n      }\n    });\n  }","id":98944,"modified_method":"public void addModuleImport(final String moduleUID) {\n    CommandProcessor.instance().executeCommand(new Runnable() {\n      public void run() {\n        ModuleDescriptor md = getModuleDescriptor();\n        if (md == null) return;\n\n        for (ModuleReference r : md.getDependencys()) {\n          if (moduleUID.equals(r.getName())) {\n            return;\n          }\n        }\n\n        ModuleReference ref = ModuleReference.newInstance(md.getModel());\n        ref.setName(moduleUID);\n        md.addDependency(ref);\n\n        setModuleDescriptor(md);\n        save();\n      }\n    });\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected List<String> getExportedPackages() {\n    List<String> result = new ArrayList<String>();\n    OSGiOptions osgiOptions = getModuleDescriptor().getOsgiOptions();\n    if (osgiOptions != null) {\n      for (PackageReference pr : osgiOptions.getExportedPackages()) {\n        result.add(pr.getName());\n      }\n    }\n    return result;\n  }","id":98945,"modified_method":"protected List<String> getExportedPackages() {\n    List<String> result = new ArrayList<String>();\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      OSGiOptions osgiOptions = descriptor.getOsgiOptions();\n      if (osgiOptions != null) {\n        for (PackageReference pr : osgiOptions.getExportedPackages()) {\n          result.add(pr.getName());\n        }\n      }\n    }\n    return result;\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<String> getSourcePaths() {\n    List<String> result = new ArrayList<String>();\n    for (SourcePath p : getModuleDescriptor().getSourcePaths()) {\n      result.add(p.getPath());\n    }\n    result.add(getGeneratorOutputPath());\n    return result;\n  }","id":98946,"modified_method":"public List<String> getSourcePaths() {\n    List<String> result = new ArrayList<String>();\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      for (SourcePath p : descriptor.getSourcePaths()) {\n        result.add(p.getPath());\n      }\n    }\n    result.add(getGeneratorOutputPath());\n    return result;\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<String> getRuntimeClassPathItems() {\n    ArrayList<String> result = new ArrayList<String>();\n\n    if (getClassesGen() != null) {\n      result.add(getClassesGen().getPath());\n    }\n\n    if (getModuleDescriptor() != null) {\n      for (ClassPathEntry entry : CollectionUtil.iteratorAsIterable(getModuleDescriptor().runtimeClassPathEntrys())) {\n        result.add(entry.getPath());\n      }\n    }\n\n    if (BootstrapLanguagesManager.getInstance().getLanguagesUIDsUsedInCore().contains(getModuleUID())) {\n      result.add(ClassLoaderManager.getInstance().getBaseMPSPath());\n    }\n\n    return result;\n  }","id":98947,"modified_method":"public List<String> getRuntimeClassPathItems() {\n    ArrayList<String> result = new ArrayList<String>();\n\n    if (getClassesGen() != null) {\n      result.add(getClassesGen().getPath());\n    }\n\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      for (ClassPathEntry entry : CollectionUtil.iteratorAsIterable(descriptor.runtimeClassPathEntrys())) {\n        result.add(entry.getPath());\n      }\n    }\n\n    if (BootstrapLanguagesManager.getInstance().getLanguagesUIDsUsedInCore().contains(getModuleUID())) {\n      result.add(ClassLoaderManager.getInstance().getBaseMPSPath());\n    }\n\n    return result;\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<String> getUsedLanguagesNamespaces() {\n    List<String> result = new ArrayList<String>();\n    if (getModuleDescriptor() != null) {\n      for (LanguageReference lr : getModuleDescriptor().getUsedLanguages()) {\n        result.add(lr.getName());\n      }\n    }\n    return result;\n  }","id":98948,"modified_method":"public List<String> getUsedLanguagesNamespaces() {\n    List<String> result = new ArrayList<String>();\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      for (LanguageReference lr : descriptor.getUsedLanguages()) {\n        result.add(lr.getName());\n      }\n    }\n    return result;\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addUsedLanguage(final String languageNamespace) {\n    CommandProcessor.instance().executeCommand(new Runnable() {\n      public void run() {\n        ModuleDescriptor md = getModuleDescriptor();\n\n        for (LanguageReference r : md.getUsedLanguages()) {\n          if (languageNamespace.equals(r.getName())) {\n            return;\n          }\n        }\n\n        LanguageReference ref = LanguageReference.newInstance(md.getModel());\n        ref.setName(languageNamespace);\n        md.addUsedLanguage(ref);\n\n        setModuleDescriptor(md);\n\n        save();\n      }\n    });\n  }","id":98949,"modified_method":"public void addUsedLanguage(final String languageNamespace) {\n    CommandProcessor.instance().executeCommand(new Runnable() {\n      public void run() {\n        ModuleDescriptor md = getModuleDescriptor();\n        if (md == null) return;\n\n        for (LanguageReference r : md.getUsedLanguages()) {\n          if (languageNamespace.equals(r.getName())) {\n            return;\n          }\n        }\n\n        LanguageReference ref = LanguageReference.newInstance(md.getModel());\n        ref.setName(languageNamespace);\n        md.addUsedLanguage(ref);\n\n        setModuleDescriptor(md);\n        save();\n      }\n    });\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<Dependency> getRequiredBundles() {\n    List<Dependency> result = new ArrayList<Dependency>();\n    result.add(new Dependency(\"jetbrains.mps\", false));\n\n    for (String s : BootstrapLanguagesManager.getInstance().getLanguagesUIDsUsedInCore()) {\n      result.add(new Dependency(s, false));\n    }\n\n    result.addAll(getDependencies());\n\n    OSGiOptions osgiOptions = getModuleDescriptor().getOsgiOptions();\n    if (osgiOptions != null) {\n      for (BundleReference br : osgiOptions.getRequiredBundles()) {\n        result.add(new Dependency(br.getName(), false));\n      }\n    }\n\n    return result;\n  }","id":98950,"modified_method":"private List<Dependency> getRequiredBundles() {\n    List<Dependency> result = new ArrayList<Dependency>();\n    result.add(new Dependency(\"jetbrains.mps\", false));\n\n    for (String s : BootstrapLanguagesManager.getInstance().getLanguagesUIDsUsedInCore()) {\n      result.add(new Dependency(s, false));\n    }\n\n    result.addAll(getDependencies());\n\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor != null) {\n      OSGiOptions osgiOptions = descriptor.getOsgiOptions();\n      if (osgiOptions != null) {\n        for (BundleReference br : osgiOptions.getRequiredBundles()) {\n          result.add(new Dependency(br.getName(), false));\n        }\n      }\n    }\n\n    return result;\n  }","commit_id":"c7617d2800e1991f09fb12cab566fe9a3db98ca8","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Collection<ModelRoot> getStubModelEntriesToIncludeOrExclude() {\n    return getModuleDescriptor().getStubModelEntries();\n  }","id":98951,"modified_method":"protected Collection<ModelRoot> getStubModelEntriesToIncludeOrExclude() {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor == null) return Collections.emptySet();\n    return descriptor.getStubModelEntries();\n  }","commit_id":"616f56547b9ff0729b93e272522a6acffdf3e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void onModuleLoad() {\n    updateSModelReferences();\n    updateModuleReferences();\n\n    if (!isPackaged()) {\n      Set<ModelRoot> visited = new HashSet<ModelRoot>();\n      List<ModelRoot> remove = new ArrayList<ModelRoot>();\n      for (ModelRoot e : getModuleDescriptor().getStubModelEntries()) {\n        if (visited.contains(e)) {\n          remove.add(e);\n        }\n\n        visited.add(e);\n      }\n\n      getModuleDescriptor().getStubModelEntries().removeAll(remove);\n    }\n  }","id":98952,"modified_method":"public void onModuleLoad() {\n    updateSModelReferences();\n    updateModuleReferences();\n\n    if (!isPackaged()) {\n      Set<ModelRoot> visited = new HashSet<ModelRoot>();\n      List<ModelRoot> remove = new ArrayList<ModelRoot>();\n      ModuleDescriptor descriptor = getModuleDescriptor();\n      if (descriptor == null) return;\n      for (ModelRoot e : descriptor.getStubModelEntries()) {\n        if (visited.contains(e)) {\n          remove.add(e);\n        }\n\n        visited.add(e);\n      }\n\n      descriptor.getStubModelEntries().removeAll(remove);\n    }\n  }","commit_id":"616f56547b9ff0729b93e272522a6acffdf3e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean needReloading() {\n    if ((myDescriptorFile == null) || !myDescriptorFile.exists()) {\n      return false;\n    }\n    String timestampString;\n    if (ModelAccess.instance().canRead()) {\n      timestampString = getModuleDescriptor().getTimestamp();\n    } else {\n      timestampString = ModelAccess.instance().runReadAction(new Computable<String>() {\n        public String compute() {\n          return getModuleDescriptor().getTimestamp();\n        }\n      });\n    }\n    if (timestampString == null) return true;\n    long timestamp = Long.decode(timestampString);\n    return timestamp != myDescriptorFile.lastModified();\n  }","id":98953,"modified_method":"public boolean needReloading() {\n    if ((myDescriptorFile == null) || !myDescriptorFile.exists()) {\n      return false;\n    }\n\n    final ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor == null) return false;\n\n    String timestampString;\n    if (ModelAccess.instance().canRead()) {\n      timestampString = descriptor.getTimestamp();\n    } else {\n      timestampString = ModelAccess.instance().runReadAction(new Computable<String>() {\n        public String compute() {\n          return descriptor.getTimestamp();\n        }\n      });\n    }\n    if (timestampString == null) return true;\n    long timestamp = Long.decode(timestampString);\n    return timestamp != myDescriptorFile.lastModified();\n  }","commit_id":"616f56547b9ff0729b93e272522a6acffdf3e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addUsedDevkit(ModuleReference devkitRef) {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor.getUsedDevkits().contains(devkitRef)) return;\n\n    descriptor.getUsedDevkits().add(devkitRef);\n    invalidateCaches();\n//    setModuleDescriptor(descriptor, true);\n    save();\n  }","id":98954,"modified_method":"public void addUsedDevkit(ModuleReference devkitRef) {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor == null) return;\n    if (descriptor.getUsedDevkits().contains(devkitRef)) return;\n\n    descriptor.getUsedDevkits().add(devkitRef);\n    invalidateCaches();\n//    setModuleDescriptor(descriptor, true);\n    save();\n  }","commit_id":"616f56547b9ff0729b93e272522a6acffdf3e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addDependency(@NotNull ModuleReference moduleRef, boolean reexport) {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    for (Dependency dep : descriptor.getDependencies()) {\n      if (!ObjectUtils.equals(dep.getModuleRef(), moduleRef)) continue;\n\n      if (reexport && !dep.isReexport()) {\n        dep.setReexport(true);\n        invalidateCaches();\n        save();\n      }\n      return;\n    }\n\n    Dependency dep = new Dependency();\n    dep.setModuleRef(moduleRef);\n    dep.setReexport(reexport);\n    descriptor.getDependencies().add(dep);\n    //setModuleDescriptor(descriptor, true);\n    invalidateCaches();\n    save();\n  }","id":98955,"modified_method":"public void addDependency(@NotNull ModuleReference moduleRef, boolean reexport) {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor == null) return;\n    for (Dependency dep : descriptor.getDependencies()) {\n      if (!ObjectUtils.equals(dep.getModuleRef(), moduleRef)) continue;\n\n      if (reexport && !dep.isReexport()) {\n        dep.setReexport(true);\n        invalidateCaches();\n        save();\n      }\n      return;\n    }\n\n    Dependency dep = new Dependency();\n    dep.setModuleRef(moduleRef);\n    dep.setReexport(reexport);\n    descriptor.getDependencies().add(dep);\n    //setModuleDescriptor(descriptor, true);\n    invalidateCaches();\n    save();\n  }","commit_id":"616f56547b9ff0729b93e272522a6acffdf3e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addUsedLanguage(ModuleReference langRef) {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor.getUsedLanguages().contains(langRef)) return;\n\n    descriptor.getUsedLanguages().add(langRef);\n    invalidateCaches();\n//    setModuleDescriptor(descriptor, true);// removed as it follows to models disposing even after addChild()\n    //save();\n  }","id":98956,"modified_method":"public void addUsedLanguage(ModuleReference langRef) {\n    ModuleDescriptor descriptor = getModuleDescriptor();\n    if (descriptor == null) return;\n    if (descriptor.getUsedLanguages().contains(langRef)) return;\n\n    descriptor.getUsedLanguages().add(langRef);\n    invalidateCaches();\n//    setModuleDescriptor(descriptor, true);// removed as it follows to models disposing even after addChild()\n    //save();\n  }","commit_id":"616f56547b9ff0729b93e272522a6acffdf3e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public IScope getScope() {\n    if (myScope == null) {\n      myScope = new EvaluationAuxScope(this);\n    }\n    return myScope;\n  }","id":98957,"modified_method":"@NotNull\n  public IScope getScope() {\n    return GlobalScope.getInstance();\n  }","commit_id":"616f56547b9ff0729b93e272522a6acffdf3e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    super.readExternal(element);\n    myInterpreterOptions = JDOMExternalizerUtil.readField(element, \"INTERPRETER_OPTIONS\");\n    readEnvs(element);\n    mySdkHome = JDOMExternalizerUtil.readField(element, \"SDK_HOME\");\n    myWorkingDirectory = JDOMExternalizerUtil.readField(element, \"WORKING_DIRECTORY\");\n    myUseModuleSdk = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"IS_MODULE_SDK\"));\n    myAddContentRoots = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"ADD_CONTENT_ROOTS\"));\n    myAddSourceRoots = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"ADD_SOURCE_ROOTS\"));\n    getConfigurationModule().readExternal(element);\n\n    setMappingSettings(PathMappingSettings.readExternal(element));\n    // extension settings:\n    PythonRunConfigurationExtensionsManager.getInstance().readExternal(this, element);\n  }","id":98958,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    super.readExternal(element);\n    myInterpreterOptions = JDOMExternalizerUtil.readField(element, \"INTERPRETER_OPTIONS\");\n    readEnvs(element);\n    mySdkHome = JDOMExternalizerUtil.readField(element, \"SDK_HOME\");\n    myWorkingDirectory = JDOMExternalizerUtil.readField(element, \"WORKING_DIRECTORY\");\n    myUseModuleSdk = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"IS_MODULE_SDK\"));\n    final String addContentRoots = JDOMExternalizerUtil.readField(element, \"ADD_CONTENT_ROOTS\");\n    myAddContentRoots = addContentRoots == null || Boolean.parseBoolean(addContentRoots);\n    final String addSourceRoots = JDOMExternalizerUtil.readField(element, \"ADD_SOURCE_ROOTS\");\n    myAddSourceRoots = addSourceRoots == null|| Boolean.parseBoolean(addSourceRoots);\n    getConfigurationModule().readExternal(element);\n\n    setMappingSettings(PathMappingSettings.readExternal(element));\n    // extension settings:\n    PythonRunConfigurationExtensionsManager.getInstance().readExternal(this, element);\n  }","commit_id":"201007bd16d9d2ffe48b90d41217c19fa22e9abe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void writeExternal(Element element) throws WriteExternalException {\n    super.writeExternal(element);\n\n    JDOMExternalizerUtil.writeField(element, \"SCRIPT_NAME\", myScriptName);\n    JDOMExternalizerUtil.writeField(element, \"CLASS_NAME\", myClassName);\n    JDOMExternalizerUtil.writeField(element, \"METHOD_NAME\", myMethodName);\n    JDOMExternalizerUtil.writeField(element, \"FOLDER_NAME\", myFolderName);\n    JDOMExternalizerUtil.writeField(element, \"TEST_TYPE\", myTestType.toString());\n    JDOMExternalizerUtil.writeField(element, \"PATTERN\", myPattern);\n    JDOMExternalizerUtil.writeField(element, \"USE_PATTERN\", String.valueOf(usePattern));\n    JDOMExternalizerUtil.writeField(element, \"ADD_CONTENT_ROOTS\", String.valueOf(myAddContentRoots));\n    JDOMExternalizerUtil.writeField(element, \"ADD_SOURCE_ROOTS\", String.valueOf(myAddSourceRoots));\n  }","id":98959,"modified_method":"@Override\n  public void writeExternal(Element element) throws WriteExternalException {\n    super.writeExternal(element);\n\n    JDOMExternalizerUtil.writeField(element, \"SCRIPT_NAME\", myScriptName);\n    JDOMExternalizerUtil.writeField(element, \"CLASS_NAME\", myClassName);\n    JDOMExternalizerUtil.writeField(element, \"METHOD_NAME\", myMethodName);\n    JDOMExternalizerUtil.writeField(element, \"FOLDER_NAME\", myFolderName);\n    JDOMExternalizerUtil.writeField(element, \"TEST_TYPE\", myTestType.toString());\n    JDOMExternalizerUtil.writeField(element, \"PATTERN\", myPattern);\n    JDOMExternalizerUtil.writeField(element, \"USE_PATTERN\", String.valueOf(usePattern));\n  }","commit_id":"201007bd16d9d2ffe48b90d41217c19fa22e9abe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    super.readExternal(element);\n    myScriptName = JDOMExternalizerUtil.readField(element, \"SCRIPT_NAME\");\n    myClassName = JDOMExternalizerUtil.readField(element, \"CLASS_NAME\");\n    myMethodName = JDOMExternalizerUtil.readField(element, \"METHOD_NAME\");\n    myFolderName = JDOMExternalizerUtil.readField(element, \"FOLDER_NAME\");\n\n    myPattern = JDOMExternalizerUtil.readField(element, \"PATTERN\");\n    usePattern = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"USE_PATTERN\"));\n    myAddContentRoots = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"ADD_CONTENT_ROOTS\"));\n    myAddSourceRoots = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"ADD_SOURCE_ROOTS\"));\n\n    try {\n      final String testType = JDOMExternalizerUtil.readField(element, \"TEST_TYPE\");\n      myTestType = testType != null ? TestType.valueOf(testType) : TestType.TEST_SCRIPT;\n    }\n    catch (IllegalArgumentException e) {\n      myTestType = TestType.TEST_SCRIPT; // safe default\n    }\n  }","id":98960,"modified_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    super.readExternal(element);\n    myScriptName = JDOMExternalizerUtil.readField(element, \"SCRIPT_NAME\");\n    myClassName = JDOMExternalizerUtil.readField(element, \"CLASS_NAME\");\n    myMethodName = JDOMExternalizerUtil.readField(element, \"METHOD_NAME\");\n    myFolderName = JDOMExternalizerUtil.readField(element, \"FOLDER_NAME\");\n\n    myPattern = JDOMExternalizerUtil.readField(element, \"PATTERN\");\n    usePattern = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"USE_PATTERN\"));\n\n    try {\n      final String testType = JDOMExternalizerUtil.readField(element, \"TEST_TYPE\");\n      myTestType = testType != null ? TestType.valueOf(testType) : TestType.TEST_SCRIPT;\n    }\n    catch (IllegalArgumentException e) {\n      myTestType = TestType.TEST_SCRIPT; // safe default\n    }\n  }","commit_id":"201007bd16d9d2ffe48b90d41217c19fa22e9abe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    super.readExternal(element);\n    myInterpreterOptions = JDOMExternalizerUtil.readField(element, \"INTERPRETER_OPTIONS\");\n    myPassParentEnvs = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"PARENT_ENVS\"));\n    mySdkHome = JDOMExternalizerUtil.readField(element, \"SDK_HOME\");\n    myWorkingDirectory = JDOMExternalizerUtil.readField(element, \"WORKING_DIRECTORY\");\n    myUseModuleSdk = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"IS_MODULE_SDK\"));\n    getConfigurationModule().readExternal(element);\n    EnvironmentVariablesComponent.readExternal(element, getEnvs());\n  }","id":98961,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    super.readExternal(element);\n    myInterpreterOptions = JDOMExternalizerUtil.readField(element, \"INTERPRETER_OPTIONS\");\n    final String parentEnvs = JDOMExternalizerUtil.readField(element, \"PARENT_ENVS\");\n    if (parentEnvs != null) {\n      myPassParentEnvs = Boolean.parseBoolean(parentEnvs);\n    }\n    mySdkHome = JDOMExternalizerUtil.readField(element, \"SDK_HOME\");\n    myWorkingDirectory = JDOMExternalizerUtil.readField(element, \"WORKING_DIRECTORY\");\n    myUseModuleSdk = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, \"IS_MODULE_SDK\"));\n    getConfigurationModule().readExternal(element);\n    EnvironmentVariablesComponent.readExternal(element, getEnvs());\n  }","commit_id":"01174817db435e2f9127b29c3ddef448293114a9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"final void handleSocketException(Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n            node.onOutOfMemory((OutOfMemoryError) e);\n        }\n        if (sk != null) {\n            sk.cancel();\n        }\n        connection.close();\n        StringBuilder sb = new StringBuilder();\n        sb.append(Thread.currentThread().getName());\n        sb.append(\" Closing socket to endpoint \");\n        sb.append(connection.getEndPoint());\n        sb.append(\", Cause:\").append(e);\n        if (e instanceof IOException) {\n            logger.log(Level.WARNING, sb.toString());\n        } else {\n            logger.log(Level.WARNING, sb.toString(), e);\n        }\n    }","id":98962,"modified_method":"final void handleSocketException(Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n            node.onOutOfMemory((OutOfMemoryError) e);\n        }\n        if (sk != null) {\n            sk.cancel();\n        }\n        connection.close();\n        if (connection.getType().isClient() && !connection.getType().isBinary()) {\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(Thread.currentThread().getName());\n        sb.append(\" Closing socket to endpoint \");\n        sb.append(connection.getEndPoint());\n        sb.append(\", Cause:\").append(e);\n        if (e instanceof IOException) {\n            logger.log(Level.WARNING, sb.toString());\n        } else {\n            logger.log(Level.WARNING, sb.toString(), e);\n        }\n    }","commit_id":"ce0008d4bdc61981264ddccf8afda3df8b355f32","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * See the general contract of the <code>readUTF<\/code> method of\n     * <code>DataInput<\/code>.\n     * <p/>\n     * Bytes for this operation are read from the contained input stream.\n     *\n     * @return a Unicode string.\n     * @throws EOFException           if this input stream reaches the end before reading all\n     *                                the bytes.\n     * @throws IOException            if an I/O error occurs.\n     * @throws UTFDataFormatException if the bytes do not represent a valid modified UTF-8\n     *                                encoding of a string.\n     * @see java.io.DataInputStream#readUTF(java.io.DataInput)\n     */\n    public final String readUTF() throws IOException {\n        StringBuilder result = new StringBuilder();\n        int chunkSize = readInt();\n        while (chunkSize > 0) {\n            result.append(readShortUTF());\n            chunkSize--;\n        }\n        return result.toString();\n    }","id":98963,"modified_method":"/**\n     * See the general contract of the <code>readUTF<\/code> method of\n     * <code>DataInput<\/code>.\n     * <p/>\n     * Bytes for this operation are read from the contained input stream.\n     *\n     * @return a Unicode string.\n     * @throws EOFException           if this input stream reaches the end before reading all\n     *                                the bytes.\n     * @throws IOException            if an I/O error occurs.\n     * @throws UTFDataFormatException if the bytes do not represent a valid modified UTF-8\n     *                                encoding of a string.\n     * @see java.io.DataInputStream#readUTF(java.io.DataInput)\n     */\n    public final String readUTF() throws IOException {\n        boolean isNull = readBoolean();\n        if (isNull) return null;\n        int length = readInt();\n        StringBuilder result = new StringBuilder(length);\n        int chunkSize = length / FastByteArrayOutputStream.STRING_CHUNK_SIZE + 1;\n        while (chunkSize > 0) {\n            result.append(readShortUTF());\n            chunkSize--;\n        }\n        return result.toString();\n    }","commit_id":"ce0008d4bdc61981264ddccf8afda3df8b355f32","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final void writeUTF(final String str) throws IOException {\n        int length = str.length();\n        int chunkSize = length / STRING_CHUNK_SIZE + 1;\n        writeInt(chunkSize);\n        for (int i = 0; i < chunkSize; i++) {\n            int beginIndex = Math.max(0, i * STRING_CHUNK_SIZE - 1);\n            int endIndex = Math.min((i + 1) * STRING_CHUNK_SIZE - 1, length);\n            writeShortUTF(str.substring(beginIndex, endIndex));\n        }\n    }","id":98964,"modified_method":"public final void writeUTF(final String str) throws IOException {\n        boolean isNull = (str == null);\n        writeBoolean(isNull);\n        if (isNull) return;\n        int length = str.length();\n        writeInt(length);\n        int chunkSize = length / STRING_CHUNK_SIZE + 1;\n        for (int i = 0; i < chunkSize; i++) {\n            int beginIndex = Math.max(0, i * STRING_CHUNK_SIZE - 1);\n            int endIndex = Math.min((i + 1) * STRING_CHUNK_SIZE - 1, length);\n            writeShortUTF(str.substring(beginIndex, endIndex));\n        }\n    }","commit_id":"ce0008d4bdc61981264ddccf8afda3df8b355f32","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void finishBlock() throws IOException {\n      if (baosDos == null) return;\n\n      // Flush Data Output Stream\n      baosDos.flush();\n\n      // Compress Data and write to output stream\n      DataOutputStream compressStream = getCompressingStream();\n      baos.writeTo(compressStream);\n      int size = releaseCompressingStream(compressStream);\n\n      long now = System.currentTimeMillis();\n\n      blockKeys.add(firstKey);\n      blockOffsets.add(Long.valueOf(blockBegin));\n      blockDataSizes.add(Integer.valueOf(size));\n      this.totalBytes += size;\n\n      writeTime += System.currentTimeMillis() - now;\n      writeOps++;\n\n      if (blockCache != null) {\n        byte [] bytes = baos.toByteArray();\n        ByteBuffer blockToCache = ByteBuffer.wrap(bytes, DATABLOCKMAGIC.length,\n            bytes.length - DATABLOCKMAGIC.length);\n        String blockName = path.toString() + blockNumber;\n        blockCache.cacheBlock(blockName, blockToCache);\n      }\n\n      baosDos.close();\n      baosDos = null;\n      baos = null;\n\n      blockNumber++;\n    }","id":98965,"modified_method":"private void finishBlock() throws IOException {\n      if (this.out == null) return;\n      long now = System.currentTimeMillis();\n\n      int size = releaseCompressingStream(this.out);\n      this.out = null;\n      blockKeys.add(firstKey);\n      blockOffsets.add(Long.valueOf(blockBegin));\n      blockDataSizes.add(Integer.valueOf(size));\n      this.totalBytes += size;\n\n      writeTime += System.currentTimeMillis() - now;\n      writeOps++;\n\n      if (blockCache != null) {\n        baosDos.flush();\n        byte [] bytes = baos.toByteArray();\n        ByteBuffer blockToCache = ByteBuffer.wrap(bytes, DATABLOCKMAGIC.length,\n            bytes.length - DATABLOCKMAGIC.length);\n        String blockName = path.toString() + blockNumber;\n        blockCache.cacheBlock(blockName, blockToCache);\n        baosDos.close();\n      }\n      blockNumber++;\n    }","commit_id":"94ca0f49fe1080c1e6de2d77440f1007d64e2a2f","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Add key/value to file.\n     * Keys must be added in an order that agrees with the Comparator passed\n     * on construction.\n     * @param key\n     * @param koffset\n     * @param klength\n     * @param value\n     * @param voffset\n     * @param vlength\n     * @throws IOException\n     */\n    private void append(final byte [] key, final int koffset, final int klength,\n        final byte [] value, final int voffset, final int vlength)\n    throws IOException {\n      boolean dupKey = checkKey(key, koffset, klength);\n      checkValue(value, voffset, vlength);\n      if (!dupKey) {\n        checkBlockBoundary();\n      }\n      // Write length of key and value and then actual key and value bytes.\n      this.baosDos.writeInt(klength);\n      this.keylength += klength;\n      this.baosDos.writeInt(vlength);\n      this.valuelength += vlength;\n      this.baosDos.write(key, koffset, klength);\n      this.baosDos.write(value, voffset, vlength);\n      // Are we the first key in this block?\n      if (this.firstKey == null) {\n        // Copy the key.\n        this.firstKey = new byte [klength];\n        System.arraycopy(key, koffset, this.firstKey, 0, klength);\n      }\n      this.lastKeyBuffer = key;\n      this.lastKeyOffset = koffset;\n      this.lastKeyLength = klength;\n      this.entryCount ++;\n    }","id":98966,"modified_method":"/**\n     * Add key/value to file.\n     * Keys must be added in an order that agrees with the Comparator passed\n     * on construction.\n     * @param key\n     * @param koffset\n     * @param klength\n     * @param value\n     * @param voffset\n     * @param vlength\n     * @throws IOException\n     */\n    private void append(final byte [] key, final int koffset, final int klength,\n        final byte [] value, final int voffset, final int vlength)\n    throws IOException {\n      boolean dupKey = checkKey(key, koffset, klength);\n      checkValue(value, voffset, vlength);\n      if (!dupKey) {\n        checkBlockBoundary();\n      }\n      // Write length of key and value and then actual key and value bytes.\n      this.out.writeInt(klength);\n      this.keylength += klength;\n      this.out.writeInt(vlength);\n      this.valuelength += vlength;\n      this.out.write(key, koffset, klength);\n      this.out.write(value, voffset, vlength);\n      // Are we the first key in this block?\n      if (this.firstKey == null) {\n        // Copy the key.\n        this.firstKey = new byte [klength];\n        System.arraycopy(key, koffset, this.firstKey, 0, klength);\n      }\n      this.lastKeyBuffer = key;\n      this.lastKeyOffset = koffset;\n      this.lastKeyLength = klength;\n      this.entryCount ++;\n      // If we are pre-caching blocks on write, fill byte array stream\n      if (blockCache != null) {\n        this.baosDos.writeInt(klength);\n        this.baosDos.writeInt(vlength);\n        this.baosDos.write(key, koffset, klength);\n        this.baosDos.write(value, voffset, vlength);\n      }\n    }","commit_id":"94ca0f49fe1080c1e6de2d77440f1007d64e2a2f","url":"https://github.com/apache/hbase"},{"original_method":"private void newBlock() throws IOException {\n      // This is where the next block begins.\n      blockBegin = outputStream.getPos();\n\n      firstKey = null;\n\n      // to avoid too many calls to realloc(),\n      // pre-allocates the byte stream to the block size + 25%\n      baos = new ByteArrayOutputStream(blocksize + (int)(blocksize * 0.25));\n      baosDos = new DataOutputStream(baos);\n      baosDos.write(DATABLOCKMAGIC);\n    }","id":98967,"modified_method":"private void newBlock() throws IOException {\n      // This is where the next block begins.\n      blockBegin = outputStream.getPos();\n      this.out = getCompressingStream();\n      this.out.write(DATABLOCKMAGIC);\n      firstKey = null;\n      if (blockCache != null) {\n        this.baos = new ByteArrayOutputStream();\n        this.baosDos = new DataOutputStream(baos);\n        this.baosDos.write(DATABLOCKMAGIC);\n      }\n    }","commit_id":"94ca0f49fe1080c1e6de2d77440f1007d64e2a2f","url":"https://github.com/apache/hbase"},{"original_method":"private void checkBlockBoundary() throws IOException {\n      if (baosDos != null && baosDos.size() < blocksize) return;\n      finishBlock();\n      newBlock();\n    }","id":98968,"modified_method":"private void checkBlockBoundary() throws IOException {\n      if (this.out != null && this.out.size() < blocksize) return;\n      finishBlock();\n      newBlock();\n    }","commit_id":"94ca0f49fe1080c1e6de2d77440f1007d64e2a2f","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void deleteXWikiAttachment(XWikiAttachment attachment, boolean parentUpdate, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n\n            Session session = getSession(context);\n\n            String db = context.getDatabase();\n            String attachdb = (attachment.getDoc() == null) ? null : attachment.getDoc().getDatabase();\n            try {\n                if (attachdb != null) {\n                    context.setDatabase(attachdb);\n                }\n\n                // Delete the three attachment entries\n                try {\n                    session.delete(new XWikiAttachmentContent(attachment));\n                } catch (Exception e) {\n                    if (LOGGER.isWarnEnabled()) {\n                        LOGGER.warn(\"Error deleting attachment content \" + attachment.getFilename() + \" of doc \"\n                            + attachment.getDoc().getFullName());\n                    }\n                }\n\n                context.getWiki().getAttachmentVersioningStore().deleteArchive(attachment, context, false);\n\n                try {\n                    session.delete(attachment);\n                } catch (Exception e) {\n                    if (LOGGER.isWarnEnabled()) {\n                        LOGGER.warn(\"Error deleting attachment meta data \" + attachment.getFilename() + \" of doc \"\n                            + attachment.getDoc().getFullName());\n                    }\n                }\n\n            } finally {\n                context.setDatabase(db);\n            }\n\n            try {\n                if (parentUpdate) {\n                    List<XWikiAttachment> list = attachment.getDoc().getAttachmentList();\n                    for (int i = 0; i < list.size(); i++) {\n                        XWikiAttachment attach = list.get(i);\n                        if (attachment.getFilename().equals(attach.getFilename())) {\n                            list.remove(i);\n                            break;\n                        }\n                    }\n                    context.getWiki().getStore().saveXWikiDoc(attachment.getDoc(), context, false);\n                }\n            } catch (Exception e) {\n                if (LOGGER.isWarnEnabled()) {\n                    LOGGER.warn(\"Error updating document when deleting attachment \" + attachment.getFilename()\n                        + \" of doc \" + attachment.getDoc().getFullName());\n                }\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {attachment.getFilename(), attachment.getDoc().getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_ATTACHMENT,\n                \"Exception while deleting attachment {0} of document {1}\", e, args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }","id":98969,"modified_method":"@Override\n    public void deleteXWikiAttachment(XWikiAttachment attachment, boolean parentUpdate, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n\n            Session session = getSession(context);\n\n            String db = context.getDatabase();\n            String attachdb = (attachment.getDoc() == null) ? null : attachment.getDoc().getDatabase();\n            try {\n                if (attachdb != null) {\n                    context.setDatabase(attachdb);\n                }\n\n                // Delete the three attachment entries\n                try {\n                    session.delete(new XWikiAttachmentContent(attachment));\n                } catch (Exception e) {\n                    LOGGER.warn(\"Error deleting attachment content [{}] of document [{}]\", attachment.getFilename(),\n                        attachment.getDoc().getDocumentReference());\n                }\n\n                context.getWiki().getAttachmentVersioningStore().deleteArchive(attachment, context, false);\n\n                try {\n                    session.delete(attachment);\n                } catch (Exception e) {\n                    LOGGER.warn(\"Error deleting attachment meta data [{}] of document [{}]\", attachment.getFilename(),\n                        attachment.getDoc().getDocumentReference());\n                }\n\n            } finally {\n                context.setDatabase(db);\n            }\n\n            try {\n                if (parentUpdate) {\n                    List<XWikiAttachment> list = attachment.getDoc().getAttachmentList();\n                    for (int i = 0; i < list.size(); i++) {\n                        XWikiAttachment attach = list.get(i);\n                        if (attachment.getFilename().equals(attach.getFilename())) {\n                            list.remove(i);\n                            break;\n                        }\n                    }\n                    context.getWiki().getStore().saveXWikiDoc(attachment.getDoc(), context, false);\n                }\n            } catch (Exception e) {\n                LOGGER.warn(\"Error updating document when deleting attachment [{}] of document [{}]\",\n                    attachment.getFilename(), attachment.getDoc().getDocumentReference());\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {attachment.getFilename(), attachment.getDoc().getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_ATTACHMENT,\n                \"Exception while deleting attachment {0} of document {1}\", e, args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }","commit_id":"ea541b6f854009ed9e83e742075da840835a0e03","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String getLsResultStr(TachyonURI tUri, int size, String testUser, String testGroup)\n      throws IOException, TachyonException {\n    String format = \"%-10s%-25s%-15s%-15s%-15s%-5s\\n\";\n    return String.format(format, FormatUtils.getSizeFromBytes(size),\n        CommandUtils.convertMsToDate(mTfs.getInfo(mTfs.open(tUri)).getCreationTimeMs()),\n        \"In Memory\", testUser, testGroup, tUri.getPath());\n  }","id":98970,"modified_method":"private String getLsResultStr(TachyonURI tUri, int size, String testUser, String testGroup)\n      throws IOException, TachyonException {\n    return getLsResultStr(tUri.getPath(), mTfs.getInfo(mTfs.open(tUri)).getCreationTimeMs(), size,\n        \"In Memory\", testUser, testGroup);\n  }","commit_id":"8a072d16fdb6cfea8545678afb8bb01e7e5710e8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void lsTest() throws IOException, TachyonException {\n    // clear the loginUser\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    MasterContext.getConf().set(Constants.SECURITY_GROUP_MAPPING,\n        IdentityUserGroupsMapping.class.getName());\n\n    FileInfo[] files = new FileInfo[4];\n    String testUser = \"test_user_ls\";\n    System.setProperty(Constants.SECURITY_LOGIN_USERNAME, testUser);\n\n    TachyonFile fileA = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileA\",\n        TachyonStorageType.STORE, UnderStorageType.NO_PERSIST, 10);\n    files[0] = mTfs.getInfo(fileA);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testDir/testFileB\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 20);\n    files[1] = mTfs.getInfo(mTfs.open(new TachyonURI(\"/testRoot/testDir\")));\n    TachyonFile fileC = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileC\",\n        TachyonStorageType.NO_STORE, UnderStorageType.SYNC_PERSIST, 30);\n    files[2] = mTfs.getInfo(fileC);\n    mFsShell.run(\"ls\", \"/testRoot\");\n    String expected = \"\";\n    String format = \"%-10s%-25s%-15s%-15s%-15s%-5s\\n\";\n    expected += String.format(format, FormatUtils.getSizeFromBytes(10),\n        CommandUtils.convertMsToDate(files[0].getCreationTimeMs()), \"In Memory\", testUser,\n        testUser, \"/testRoot/testFileA\");\n    expected += String.format(format, FormatUtils.getSizeFromBytes(0),\n        CommandUtils.convertMsToDate(files[1].getCreationTimeMs()), \"\", testUser,\n        testUser, \"/testRoot/testDir\");\n    expected += String.format(format, FormatUtils.getSizeFromBytes(30),\n        CommandUtils.convertMsToDate(files[2].getCreationTimeMs()), \"Not In Memory\", testUser,\n        testUser, \"/testRoot/testFileC\");\n    Assert.assertEquals(expected, mOutput.toString());\n    // clear testing username\n    System.clearProperty(Constants.SECURITY_LOGIN_USERNAME);\n  }","id":98971,"modified_method":"@Test\n  public void lsTest() throws IOException, TachyonException {\n    // clear the loginUser\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    MasterContext.getConf().set(Constants.SECURITY_GROUP_MAPPING,\n        IdentityUserGroupsMapping.class.getName());\n\n    FileInfo[] files = new FileInfo[4];\n    String testUser = \"test_user_ls\";\n    System.setProperty(Constants.SECURITY_LOGIN_USERNAME, testUser);\n\n    TachyonFile fileA = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileA\",\n        TachyonStorageType.STORE, UnderStorageType.NO_PERSIST, 10);\n    files[0] = mTfs.getInfo(fileA);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testDir/testFileB\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 20);\n    files[1] = mTfs.getInfo(mTfs.open(new TachyonURI(\"/testRoot/testDir\")));\n    TachyonFile fileC = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileC\",\n        TachyonStorageType.NO_STORE, UnderStorageType.SYNC_PERSIST, 30);\n    files[2] = mTfs.getInfo(fileC);\n    mFsShell.run(\"ls\", \"/testRoot\");\n    String expected = \"\";\n    expected +=\n        getLsResultStr(\"/testRoot/testFileA\", files[0].getCreationTimeMs(), 10, \"In Memory\",\n            testUser, testUser);\n    expected +=\n        getLsResultStr(\"/testRoot/testDir\", files[1].getCreationTimeMs(), 0, \"\", testUser,\n            testUser);\n    expected +=\n        getLsResultStr(\"/testRoot/testFileC\", files[2].getCreationTimeMs(), 30, \"Not In Memory\",\n            testUser, testUser);\n    Assert.assertEquals(expected, mOutput.toString());\n    // clear testing username\n    System.clearProperty(Constants.SECURITY_LOGIN_USERNAME);\n  }","commit_id":"8a072d16fdb6cfea8545678afb8bb01e7e5710e8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void lsrTest() throws IOException, TachyonException {\n    // clear the loginUser\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    MasterContext.getConf().set(Constants.SECURITY_GROUP_MAPPING,\n        IdentityUserGroupsMapping.class.getName());\n\n    FileInfo[] files = new FileInfo[4];\n    String testUser = \"test_user_lsr\";\n    System.setProperty(Constants.SECURITY_LOGIN_USERNAME, testUser);\n\n    TachyonFile fileA = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileA\",\n        TachyonStorageType.STORE, UnderStorageType.NO_PERSIST, 10);\n    files[0] = mTfs.getInfo(fileA);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testDir/testFileB\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 20);\n    files[1] = mTfs.getInfo(mTfs.open(new TachyonURI(\"/testRoot/testDir\")));\n    files[2] = mTfs.getInfo(mTfs.open(new TachyonURI(\"/testRoot/testDir/testFileB\")));\n    TachyonFile fileC = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileC\",\n        TachyonStorageType.NO_STORE, UnderStorageType.SYNC_PERSIST, 30);\n    files[3] = mTfs.getInfo(fileC);\n    mFsShell.run(\"lsr\", \"/testRoot\");\n    String expected = \"\";\n    String format = \"%-10s%-25s%-15s%-15s%-15s%-5s\\n\";\n    expected +=\n        String.format(format, FormatUtils.getSizeFromBytes(10),\n            CommandUtils.convertMsToDate(files[0].getCreationTimeMs()), \"In Memory\", testUser,\n            testUser, \"/testRoot/testFileA\");\n    expected +=\n        String.format(format, FormatUtils.getSizeFromBytes(0),\n            CommandUtils.convertMsToDate(files[1].getCreationTimeMs()), \"\", testUser, testUser,\n            \"/testRoot/testDir\");\n    expected +=\n        String.format(format, FormatUtils.getSizeFromBytes(20),\n            CommandUtils.convertMsToDate(files[2].getCreationTimeMs()), \"In Memory\", testUser,\n            testUser, \"/testRoot/testDir/testFileB\");\n    expected +=\n        String.format(format, FormatUtils.getSizeFromBytes(30),\n            CommandUtils.convertMsToDate(files[3].getCreationTimeMs()), \"Not In Memory\", testUser,\n            testUser, \"/testRoot/testFileC\");\n    Assert.assertEquals(expected, mOutput.toString());\n    // clear testing username\n    System.clearProperty(Constants.SECURITY_LOGIN_USERNAME);\n  }","id":98972,"modified_method":"@Test\n  public void lsrTest() throws IOException, TachyonException {\n    // clear the loginUser\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    MasterContext.getConf().set(Constants.SECURITY_GROUP_MAPPING,\n        IdentityUserGroupsMapping.class.getName());\n\n    FileInfo[] files = new FileInfo[4];\n    String testUser = \"test_user_lsr\";\n    System.setProperty(Constants.SECURITY_LOGIN_USERNAME, testUser);\n\n    TachyonFile fileA = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileA\",\n        TachyonStorageType.STORE, UnderStorageType.NO_PERSIST, 10);\n    files[0] = mTfs.getInfo(fileA);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testDir/testFileB\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 20);\n    files[1] = mTfs.getInfo(mTfs.open(new TachyonURI(\"/testRoot/testDir\")));\n    files[2] = mTfs.getInfo(mTfs.open(new TachyonURI(\"/testRoot/testDir/testFileB\")));\n    TachyonFile fileC = TachyonFSTestUtils.createByteFile(mTfs, \"/testRoot/testFileC\",\n        TachyonStorageType.NO_STORE, UnderStorageType.SYNC_PERSIST, 30);\n    files[3] = mTfs.getInfo(fileC);\n    mFsShell.run(\"lsr\", \"/testRoot\");\n    String expected = \"\";\n    expected +=\n        getLsResultStr(\"/testRoot/testFileA\", files[0].getCreationTimeMs(), 10, \"In Memory\",\n            testUser, testUser);\n    expected +=\n        getLsResultStr(\"/testRoot/testDir\", files[1].getCreationTimeMs(), 0, \"\", testUser,\n            testUser);\n    expected +=\n        getLsResultStr(\"/testRoot/testDir/testFileB\", files[2].getCreationTimeMs(), 20,\n            \"In Memory\", testUser, testUser);\n    expected +=\n        getLsResultStr(\"/testRoot/testFileC\", files[3].getCreationTimeMs(), 30, \"Not In Memory\",\n            testUser, testUser);\n    Assert.assertEquals(expected, mOutput.toString());\n    // clear testing username\n    System.clearProperty(Constants.SECURITY_LOGIN_USERNAME);\n  }","commit_id":"8a072d16fdb6cfea8545678afb8bb01e7e5710e8","url":"https://github.com/amplab/tachyon"},{"original_method":"ConfigToadlet(HighLevelSimpleClient client, Node n, Config conf, String CSSName) {\n\t\tsuper(client, CSSName);\n\t\tconfig=conf;\n\t\tnode=n;\n\t}","id":98973,"modified_method":"ConfigToadlet(HighLevelSimpleClient client, Config conf, String CSSName) {\n\t\tsuper(client, CSSName);\n\t\tconfig=conf;\n\t}","commit_id":"3060440a5aebb9b6dc3e2ec638d657abb7908d3c","url":"https://github.com/freenet/fred"},{"original_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tSubConfig[] sc = config.getConfigs();\n\t\t\n\t\tctx.getPageMaker().makeHead(buf, \"Freenet Node Configuration\", CSSName);\n\t\tHTTPRequest request = new HTTPRequest(uri);\n\t\tif (request.hasParameters() == false) {\n\t\t\tbuf.append(\"<h1 class=\\\"title\\\">Node Configuration<\/h1>\\n\");\n\t\t\tbuf.append(\"<div class=\\\"config\\\">\\n\");\n\t\t\tbuf.append(\"\t<ul class=\\\"config\\\">\\n\");\n\t\t\t// FIXME: Use POST insteed !\n\t\t\tbuf.append(\"<form method=\\\"get\\\">\");\n\t\t\tString last = null;\n\t\t\t\n\t\t\tfor(int i=0; i<sc.length;i++){\n\t\t\t\tOption[] o = sc[i].getOptions();\n\t\t\t\tString prefix = new String(sc[i].getPrefix());\n\t\t\t\t\n\t\t\t\tif(last == null || ! last.equalsIgnoreCase(prefix)){\n\t\t\t\t\tbuf.append(\"<\/p>\\n\");\n\t\t\t\t\tbuf.append(\"<\/span>\\n\");\n\t\t\t\t\tbuf.append(\"<span id=\\\"\"+prefix+\"\\\">\\n\");\n\t\t\t\t\tbuf.append(\"<p>\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<o.length; j++){\n\t\t\t\t\tString configName = new String(o[j].getName());\n\t\t\t\t\t/*\n\t\t\t\t\tif(prefix.equals(\"node\") && configName.equals(\"name\")){\n\t\t\t\t\t\tbuf.append(\"<form method=\\\"post\\\"><input alt=\\\"node name\\\" class=\\\"config\\\"\" +\n\t\t\t\t\t\t\t\t\" type=\\\"text\\\" name=\\\"__node_name\\\" value=\\\"\"+o[j].getValueString()+\"\\\"/><\/form>\\n\");\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\t\n\t\t\t\t\tbuf.append(o[j].getShortDesc()+\":\\n\");\n\t\t\t\t\tbuf.append(\"\t\t<li>\"+prefix+\".\"+configName+\"=><input alt=\\\"\"+o[j].getShortDesc()+\"\\\" class=\\\"config\\\"\" +\n\t\t\t\t\t\t\t\" type=\\\"text\\\" name=\\\"\"+prefix+\".\"+configName+\"\\\" value=\\\"\"+o[j].getValueString()+\"\\\"><\/li>\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbuf.append(\"<hr><br>\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" value=\\\"Apply\\\">\");\n\t\t\tbuf.append(\"<input type=\\\"reset\\\" value=\\\"Cancel\\\">\");\n\t\t\tbuf.append(\"<\/form>\");\n\t\t\tbuf.append(\"\t<\/ul>\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\n\t\t} else {\n\t\t\tbuf.append(\"Applying configuration\");\n\t\t\t\n\t\t\tfor(int i=0; i<sc.length ; i++){\n\t\t\t\tOption[] o = sc[i].getOptions();\n\t\t\t\tString prefix = new String(sc[i].getPrefix());\n\t\t\t\tString configName;\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<o.length; j++){\n\t\t\t\t\tconfigName=o[j].getName();\n\t\t\t\t\t\n\t\t\t\t\t// we ignore unreconized parameters \n\t\t\t\t\tif(request.getParam(prefix+\".\"+configName) != \"\"){\n\t\t\t\t\t\tif(o[j].getValueString() != request.getParam(prefix+\".\"+configName))\n\t\t\t\t\t\t\tbuf.append(o[j].getShortDesc()+\":\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tctx.getPageMaker().makeTail(buf);\n\t\t\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t}","id":98974,"modified_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tSubConfig[] sc = config.getConfigs();\n\t\t\n\t\tHTTPRequest request = new HTTPRequest(uri);\n\t\tif (request.hasParameters() == false) {\n\t\t\tctx.getPageMaker().makeHead(buf, \"Freenet Node Configuration\", CSSName);\n\t\t\tbuf.append(\"<h1 class=\\\"title\\\">Node Configuration<\/h1>\\n\");\n\t\t\tbuf.append(\"<div class=\\\"config\\\">\\n\");\n\t\t\tbuf.append(\"\t<ul class=\\\"config\\\">\\n\");\n\t\t\t// FIXME: Use POST insteed !\n\t\t\tbuf.append(\"<form method=\\\"get\\\">\");\n\t\t\tString last = null;\n\t\t\t\n\t\t\tfor(int i=0; i<sc.length;i++){\n\t\t\t\tOption[] o = sc[i].getOptions();\n\t\t\t\tString prefix = new String(sc[i].getPrefix());\n\t\t\t\t\n\t\t\t\tif(last == null || ! last.equalsIgnoreCase(prefix)){\n\t\t\t\t\tbuf.append(\"<\/p>\\n\");\n\t\t\t\t\tbuf.append(\"<\/span>\\n\");\n\t\t\t\t\tbuf.append(\"<span id=\\\"\"+prefix+\"\\\">\\n\");\n\t\t\t\t\tbuf.append(\"<p>\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<o.length; j++){\n\t\t\t\t\tString configName = new String(o[j].getName());\n\t\t\t\t\t/*\n\t\t\t\t\tif(prefix.equals(\"node\") && configName.equals(\"name\")){\n\t\t\t\t\t\tbuf.append(\"<form method=\\\"post\\\"><input alt=\\\"node name\\\" class=\\\"config\\\"\" +\n\t\t\t\t\t\t\t\t\" type=\\\"text\\\" name=\\\"__node_name\\\" value=\\\"\"+o[j].getValueString()+\"\\\"/><\/form>\\n\");\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\t\n\t\t\t\t\tbuf.append(o[j].getShortDesc()+\":\\n\");\n\t\t\t\t\tbuf.append(\"\t\t<li>\"+prefix+\".\"+configName+\"=><input alt=\\\"\"+o[j].getShortDesc()+\"\\\" class=\\\"config\\\"\" +\n\t\t\t\t\t\t\t\" type=\\\"text\\\" name=\\\"\"+prefix+\".\"+configName+\"\\\" value=\\\"\"+o[j].getValueString()+\"\\\"><\/li>\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbuf.append(\"<br><hr>\");\n\t\t\t}\n\t\t\t\n\t\t\tbuf.append(\"<br>\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" value=\\\"Apply\\\">\");\n\t\t\tbuf.append(\"<input type=\\\"reset\\\" value=\\\"Cancel\\\">\");\n\t\t\tbuf.append(\"<\/form>\");\n\t\t\tbuf.append(\"\t<\/ul>\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\t\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\t\n\t\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t\n\t\t} else {\n\t\t\tfor(int i=0; i<sc.length ; i++){\n\t\t\t\tOption[] o = sc[i].getOptions();\n\t\t\t\tString prefix = new String(sc[i].getPrefix());\n\t\t\t\tString configName;\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<o.length; j++){\n\t\t\t\t\tconfigName=o[j].getName();\n\t\t\t\t\t\n\t\t\t\t\t// we ignore unreconized parameters \n\t\t\t\t\tif(request.getParam(prefix+\".\"+configName) != \"\"){\n\t\t\t\t\t\tif(o[j].getValueString() != request.getParam(prefix+\".\"+configName)){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\to[j].setValue(request.getParam(prefix+\".\"+configName));\n\t\t\t\t\t\t\t}catch(Exception e){\n\t\t\t\t\t\t\t\tbuf.append(e+\"\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconfig.store();\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", mkForwardPage(ctx, \"Applying configuration\", buf.toString(), \"/config/\", 10));\n\t\t}\n\t}","commit_id":"3060440a5aebb9b6dc3e2ec638d657abb7908d3c","url":"https://github.com/freenet/fred"},{"original_method":"public static void maybeCreateFproxyEtc(Node node, Config config) throws IOException {\n\t\t\n\t\tSubConfig fproxyConfig = new SubConfig(\"fproxy\", config);\n\t\t\n\t\tfproxyConfig.register(\"enabled\", true, 1, true, \"Enable fproxy?\", \"Whether to enable fproxy and related HTTP services\",\n\t\t\t\tnew FproxyEnabledCallback(node));\n\t\t\n\t\tboolean fproxyEnabled = fproxyConfig.getBoolean(\"enabled\");\n\t\t\n\t\tif(!fproxyEnabled) {\n\t\t\tfproxyConfig.finishedInitialization();\n\t\t\tLogger.normal(node, \"Not starting Fproxy as it's disabled\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfproxyConfig.register(\"port\", DEFAULT_FPROXY_PORT, 2, true, \"Fproxy port number\", \"Fproxy port number\",\n\t\t\t\tnew FproxyPortCallback(node));\n\t\tfproxyConfig.register(\"bindto\", \"127.0.0.1\", 2, true, \"IP address to bind to\", \"IP address to bind to\",\n\t\t\t\tnew FproxyBindtoCallback(node));\n\t\tfproxyConfig.register(\"css\", \"clean\", 1, true, \"CSS Name\", \"Name of the CSS Fproxy should use\",\n\t\t\t\tnew FproxyCSSNameCallback(node));\n\t\t\n\t\tint port = fproxyConfig.getInt(\"port\");\n\t\tString bind_ip = fproxyConfig.getString(\"bindto\");\n\t\tString CSSName = fproxyConfig.getString(\"css\");\n\t\t\n\t\tSystem.out.println(\"Starting fproxy on port \"+(port));\n\t\tLogger.normal(node,\"Starting fproxy on \"+bind_ip+\":\"+port);\n\t\t\n\t\ttry {\n\t\t\tSimpleToadletServer server = new SimpleToadletServer(port, bind_ip);\n\t\t\tnode.setToadletContainer(server);\n\t\t\tFproxyToadlet fproxy = new FproxyToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), CSSName);\n\t\t\tnode.setFproxy(fproxy);\n\t\t\tserver.register(fproxy, \"/\", false);\n\t\t\t\n\t\t\tPproxyToadlet pproxy = new PproxyToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), node.pluginManager, CSSName);\n\t\t\tserver.register(pproxy, \"/plugins/\", true);\n\t\t\t\n\t\t\tWelcomeToadlet welcometoadlet = new WelcomeToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), node, CSSName);\n\t\t\tserver.register(welcometoadlet, \"/welcome/\", true);\n\t\t\t\n\t\t\tConfigToadlet configtoadlet = new ConfigToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), node, config, CSSName);\n\t\t\tserver.register(configtoadlet, \"/config/\", true);\n\t\t\t\n\t\t\tStaticToadlet statictoadlet = new StaticToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), CSSName);\n\t\t\tserver.register(statictoadlet, \"/static/\", true);\n\t\t} catch (IOException ioe) {\n\t\t\tLogger.error(node,\"Failed to start fproxy on \"+bind_ip+\":\"+port);\n\t\t}\n\t\t\n\t\tfproxyConfig.finishedInitialization();\n\t}","id":98975,"modified_method":"public static void maybeCreateFproxyEtc(Node node, Config config) throws IOException {\n\t\t\n\t\tSubConfig fproxyConfig = new SubConfig(\"fproxy\", config);\n\t\t\n\t\tfproxyConfig.register(\"enabled\", true, 1, true, \"Enable fproxy?\", \"Whether to enable fproxy and related HTTP services\",\n\t\t\t\tnew FproxyEnabledCallback(node));\n\t\t\n\t\tboolean fproxyEnabled = fproxyConfig.getBoolean(\"enabled\");\n\t\t\n\t\tif(!fproxyEnabled) {\n\t\t\tfproxyConfig.finishedInitialization();\n\t\t\tLogger.normal(node, \"Not starting Fproxy as it's disabled\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfproxyConfig.register(\"port\", DEFAULT_FPROXY_PORT, 2, true, \"Fproxy port number\", \"Fproxy port number\",\n\t\t\t\tnew FproxyPortCallback(node));\n\t\tfproxyConfig.register(\"bindto\", \"127.0.0.1\", 2, true, \"IP address to bind to\", \"IP address to bind to\",\n\t\t\t\tnew FproxyBindtoCallback(node));\n\t\tfproxyConfig.register(\"css\", \"clean\", 1, true, \"CSS Name\", \"Name of the CSS Fproxy should use\",\n\t\t\t\tnew FproxyCSSNameCallback(node));\n\t\t\n\t\tint port = fproxyConfig.getInt(\"port\");\n\t\tString bind_ip = fproxyConfig.getString(\"bindto\");\n\t\tString CSSName = fproxyConfig.getString(\"css\");\n\t\t\n\t\tSystem.out.println(\"Starting fproxy on port \"+(port));\n\t\tLogger.normal(node,\"Starting fproxy on \"+bind_ip+\":\"+port);\n\t\t\n\t\ttry {\n\t\t\tSimpleToadletServer server = new SimpleToadletServer(port, bind_ip);\n\t\t\tnode.setToadletContainer(server);\n\t\t\tFproxyToadlet fproxy = new FproxyToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), CSSName);\n\t\t\tnode.setFproxy(fproxy);\n\t\t\tserver.register(fproxy, \"/\", false);\n\t\t\t\n\t\t\tPproxyToadlet pproxy = new PproxyToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), node.pluginManager, CSSName);\n\t\t\tserver.register(pproxy, \"/plugins/\", true);\n\t\t\t\n\t\t\tWelcomeToadlet welcometoadlet = new WelcomeToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), node, CSSName);\n\t\t\tserver.register(welcometoadlet, \"/welcome/\", true);\n\t\t\t\n\t\t\tConfigToadlet configtoadlet = new ConfigToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), config, CSSName);\n\t\t\tserver.register(configtoadlet, \"/config/\", true);\n\t\t\t\n\t\t\tStaticToadlet statictoadlet = new StaticToadlet(node.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS), CSSName);\n\t\t\tserver.register(statictoadlet, \"/static/\", true);\n\t\t} catch (IOException ioe) {\n\t\t\tLogger.error(node,\"Failed to start fproxy on \"+bind_ip+\":\"+port);\n\t\t}\n\t\t\n\t\tfproxyConfig.finishedInitialization();\n\t}","commit_id":"3060440a5aebb9b6dc3e2ec638d657abb7908d3c","url":"https://github.com/freenet/fred"},{"original_method":"public String mkForwardPage(String title, String content, String nextpage, int interval) {\n\t\tif (content == null) content = \"null\";\n\t\treturn \"<html><head><title>\" + title + \"<\/title>\"+\n\t\t\"<META HTTP-EQUIV=Refresh CONTENT=\\\"\" + interval +\n\t\t\"; URL=\"+nextpage+\"\\\"><\/head><body><h1>\" + title +\n\t\t\"<\/h1>\" + content.replaceAll(\"\\n\", \"<br/>\\n\") + \"<\/body>\";\n\t}","id":98976,"modified_method":"public String mkForwardPage(ToadletContext ctx, String title, String content, String nextpage, int interval) {\n\t\tif (content == null) content = \"null\";\n\t\t\n\t\treturn  \t\"<HTML><HEAD><link rel=\\\"stylesheet\\\" href=\\\"/static/themes/\"+ctx.getPageMaker().theme+\"/theme.css\\\" type=\\\"text/css\\\" /><head><title>\" + title + \"<\/title>\"+\n\t\t\"<META HTTP-EQUIV=Refresh CONTENT=\\\"\" + interval +\n\t\t\"; URL=\"+nextpage+\"\\\"><\/head><body><h1>\" + title +\n\t\t\"<\/h1>\" + content.replaceAll(\"\\n\", \"<br/>\\n\") + \"<\/body>\";\n\t}","commit_id":"3060440a5aebb9b6dc3e2ec638d657abb7908d3c","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n\t\t\tint seconds = 120; // give up after 2 min\n\t\t\twhile (plugin == null) {\n\t\t\t\t// 1s polling\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t}\n\t\t\t\tif (seconds-- <= 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (plugin instanceof FredPlugin) {\n\t\t\t\tFredPlugin plug = ((FredPlugin)plugin);\n\t\t\t\t// handles fproxy? If so, register\n\t\t\t\tif (plug.handles(FredPlugin.handleFproxy))\n\t\t\t\t\tpm.registerToadlet(plug);\n\t\t\t\t((FredPlugin)plugin).runPlugin(pr);\n\t\t\t}\n\t\t\t// If not FredPlugin, then the whole thing is aborted,\n\t\t\t// and then this method will return, killing the thread\n\t\t\t\n\t\t\tpm.removePlugin(this);\n\t\t}","id":98977,"modified_method":"public void run() {\n\t\t\tint seconds = 120; // give up after 2 min\n\t\t\twhile (plugin == null) {\n\t\t\t\t// 1s polling\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t}\n\t\t\t\tif (seconds-- <= 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (plugin instanceof FredPlugin) {\n\t\t\t\tFredPlugin plug = ((FredPlugin)plugin);\n\t\t\t\t// handles fproxy? If so, register\n\t\t\t\t//if (plug.handles(FredPlugin.handleFproxy))\n\t\t\t\tif (plug instanceof FredPluginHTTP)\n\t\t\t\t\tpm.registerToadlet(plug);\n\t\t\t\t((FredPlugin)plugin).runPlugin(pr);\n\t\t\t}\n\t\t\t// If not FredPlugin, then the whole thing is aborted,\n\t\t\t// and then this method will return, killing the thread\n\t\t\t\n\t\t\tpm.removePlugin(this);\n\t\t}","commit_id":"22eae17b200a3c872b59194d0b85206ff93f25f1","url":"https://github.com/freenet/fred"},{"original_method":"public PluginManager(PluginRespirator pluginRespirator) {\n\t\tpluginInfo = new HashMap();\n\t\ttoadletList = new HashMap();\n\t\t\n\t\tthis.pluginRespirator = pluginRespirator;\n\t\tpluginRespirator.setPluginManager(this);\n\t\t//StartPlugin(\"misc@file:plugin.jar\");\n\t\t\n\t\t// Needed to include plugin in jar-files\n\t\tif (new Date().equals(null)){\n\t\t\tSystem.err.println(new TestPlugin());\n\t\t}\n\t}","id":98978,"modified_method":"public PluginManager(PluginRespirator pluginRespirator) {\n\t\tpluginInfo = new HashMap();\n\t\ttoadletList = new HashMap();\n\t\t\n\t\tthis.pluginRespirator = pluginRespirator;\n\t\tpluginRespirator.setPluginManager(this);\n\t\t//StartPlugin(\"misc@file:plugin.jar\");\n\t\t\n\t\t// Needed to include plugin in jar-files\n\t\t/*\n\t\t if (new Date().equals(null)){\n\t\t\tSystem.err.println(new TestPlugin());\n\t\t}\n\t\t*/\n\t}","commit_id":"22eae17b200a3c872b59194d0b85206ff93f25f1","url":"https://github.com/freenet/fred"},{"original_method":"public String handleHTTPGet(String plugin, String path) {\n\t\tFredPlugin handler = null;\n\t\tsynchronized (toadletList) {\n\t\t\thandler = (FredPlugin)toadletList.get(plugin);\n\t\t}\n\t\tif (handler == null)\n\t\t\treturn null;\n\t\t\n\t\treturn handler.handleHTTPGet(path);\n\t}","id":98979,"modified_method":"public String handleHTTPGet(String plugin, String path) throws PluginHTTPException {\n\t\tFredPlugin handler = null;\n\t\tsynchronized (toadletList) {\n\t\t\thandler = (FredPlugin)toadletList.get(plugin);\n\t\t}\n\t\t/*if (handler == null)\n\t\t\treturn null;\n\t\t\t*/\n\t\t\n\t\tif (handler instanceof FredPluginHTTP)\n\t\t\treturn ((FredPluginHTTP)handler).handleHTTPGet(path);\n\t\t\n\t\t// no plugin found\n\t\tthrow new PluginHTTPException();\n\t}","commit_id":"22eae17b200a3c872b59194d0b85206ff93f25f1","url":"https://github.com/freenet/fred"},{"original_method":"public void handleGet(URI uri, ToadletContext ctx)\n\t\t\tthrows ToadletContextClosedException, IOException {\n\t\tString ks = uri.toString();\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\tks = ks.substring(\"plugins/\".length());\n\t\tLogger.minor(this, \"Pproxy fetching \"+ks);\n\t\ttry {\n\t\t\tif (ks.equals(\"\")) {\n\t\t\t\tString ret = pm.dumpPlugins().replaceAll(\",\", \"\\n&nbsp; &nbsp; \");\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"Plugin list\", ret));\n\t\t\t} else {\n\t\t\t\tint to = ks.indexOf(\"/\");\n\t\t\t\tString plugin, data;\n\t\t\t\tif (to == -1) {\n\t\t\t\t\tplugin = ks;\n\t\t\t\t\tdata = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tplugin = ks.substring(0, to);\n\t\t\t\t\tdata = ks.substring(to + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//pm.handleHTTPGet(plugin, data);\n\t\t\t\t\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"plugin\", pm.handleHTTPGet(plugin, data)));\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pm.handleHTTPGet(plugin, data));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//FetchResult result = fetch(key);\n\t\t\t//writeReply(ctx, 200, result.getMimeType(), \"OK\", result.asBucket());\n\t\t\t\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tString msg = \"<html><head><title>Internal Error<\/title><\/head><body><h1>Internal Error: please report<\/h1><pre>\";\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\tt.printStackTrace(pw);\n\t\t\tpw.flush();\n\t\t\tmsg = msg + sw.toString() + \"<\/pre><\/body><\/html>\";\n\t\t\tthis.writeReply(ctx, 500, \"text/html\", \"Internal Error\", msg);\n\t\t}\n\t}","id":98980,"modified_method":"public void handleGet(URI uri, ToadletContext ctx)\n\t\t\tthrows ToadletContextClosedException, IOException {\n\t\t//String basepath = \"/plugins/\";\n\t\tString ks = uri.toString();\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\tks = ks.substring(\"plugins/\".length());\n\t\tLogger.minor(this, \"Pproxy fetching \"+ks);\n\t\ttry {\n\t\t\tif (ks.equals(\"\")) {\n\t\t\t\tString ret = \"<hr/>\";\n\t\t\t\tret = pm.dumpPlugins().replaceAll(\",\", \"\\n&nbsp; &nbsp; \").replaceAll(\"\\\"\", \" \\\" \");\n\t\t\t\tif (ret.length() < 6)\n\t\t\t\t\tret += \"<i>No plugins loaded<\/i>\\n\";\n\t\t\t\tret += \"<hr/>\";\n\t\t\t\tret += \"<form method=\\\"GET\\\">Remove plugin: <input type=text name=\\\"remove\\\"/><input type=submit /><\/form>\\n\";\n\t\t\t\tret += \"<form method=\\\"GET\\\">Load plugin: <input type=text name=\\\"load\\\"/><input type=submit /><\/form>\\n\";\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"Plugin list\", ret));\n\t\t\t} else if (ks.startsWith(\"?remove=\")) {\n\t\t\t\tpm.killPlugin(ks.substring(\"?remove=\".length()));\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", mkForwardPage(\"Removing plugin\", \"Removing plugin...\", \".\", 5));\n\t\t\t} else if (ks.startsWith(\"?load=\")) {\n\t\t\t\tpm.startPlugin(ks.substring(\"?load=\".length()));\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", mkForwardPage(\"Loading plugin\", \"Loading plugin...\", \".\", 5));\n\t\t\t} else {\n\t\t\t\tint to = ks.indexOf(\"/\");\n\t\t\t\tString plugin, data;\n\t\t\t\tif (to == -1) {\n\t\t\t\t\tplugin = ks;\n\t\t\t\t\tdata = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tplugin = ks.substring(0, to);\n\t\t\t\t\tdata = ks.substring(to + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//pm.handleHTTPGet(plugin, data);\n\t\t\t\t\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"plugin\", pm.handleHTTPGet(plugin, data)));\n\t\t\t\ttry {\n\t\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pm.handleHTTPGet(plugin, data));\n\t\t\t\t} catch (PluginHTTPException ex) {\n\t\t\t\t\twriteReply(ctx, ex.getCode(), ex.getMimeType(), ex.getDesc(), ex.getMessage());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//FetchResult result = fetch(key);\n\t\t\t//writeReply(ctx, 200, result.getMimeType(), \"OK\", result.asBucket());\n\t\t\t\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tString msg = \"<html><head><title>Internal Error<\/title><\/head><body><h1>Internal Error: please report<\/h1><pre>\";\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\tt.printStackTrace(pw);\n\t\t\tpw.flush();\n\t\t\tmsg = msg + sw.toString() + \"<\/pre><\/body><\/html>\";\n\t\t\tthis.writeReply(ctx, 500, \"text/html\", \"Internal Error\", msg);\n\t\t}\n\t}","commit_id":"22eae17b200a3c872b59194d0b85206ff93f25f1","url":"https://github.com/freenet/fred"},{"original_method":"public ChunkHtmlPage(String url, NotebookHtmlMetadata metadata,\n         int ordinal, final Command onRenderComplete)\n   {\n      super(ordinal);\n\n      // extract classes from metadata if present\n      JsArrayString classes = JsArrayString.createArray().cast();\n      if (metadata != null) \n         classes = metadata.getClasses();\n\n      String clazz = classes.length() > 0 ? classes.get(0) : \"html\";\n      thumbnail_ = new ChunkOutputThumbnail(clazz, \n            classes.length() > 1 ? classes.get(1) : \"\",\n            new ChunkHtmlPreview(), ChunkOutputWidget.getEditorColors());\n\n      // amend the URL to cause any contained widget to use the RStudio viewer\n      // sizing policy\n      if (url.indexOf('?') > 0)\n         url += \"&\";\n      else\n         url += \"?\";\n      url += \"viewer_pane=1\";\n\n      frame_ = new ChunkOutputFrame();\n      content_= new FixedRatioWidget(frame_, \n                  ChunkOutputUi.OUTPUT_ASPECT, \n                  ChunkOutputUi.MAX_HTMLWIDGET_WIDTH);\n\n      frame_.loadUrl(url, new Command()\n      {\n         @Override\n         public void execute()\n         {\n            Element body = frame_.getDocument().getBody();\n            Style bodyStyle = body.getStyle();\n            \n            bodyStyle.setPadding(0, Unit.PX);\n            bodyStyle.setMargin(0, Unit.PX);\n            onEditorThemeChanged(ChunkOutputWidget.getEditorColors());\n            \n            onRenderComplete.execute();\n         };\n      });\n   }","id":98981,"modified_method":"public ChunkHtmlPage(String url, NotebookHtmlMetadata metadata,\n         int ordinal, final Command onRenderComplete, ChunkOutputSize chunkOutputSize)\n   {\n      super(ordinal);\n\n      // extract classes from metadata if present\n      JsArrayString classes = JsArrayString.createArray().cast();\n      if (metadata != null) \n         classes = metadata.getClasses();\n\n      String clazz = classes.length() > 0 ? classes.get(0) : \"html\";\n      thumbnail_ = new ChunkOutputThumbnail(clazz, \n            classes.length() > 1 ? classes.get(1) : \"\",\n            new ChunkHtmlPreview(), ChunkOutputWidget.getEditorColors());\n\n      // amend the URL to cause any contained widget to use the RStudio viewer\n      // sizing policy\n      if (url.indexOf('?') > 0)\n         url += \"&\";\n      else\n         url += \"?\";\n      url += \"viewer_pane=1\";\n\n      frame_ = new ChunkOutputFrame();\n      \n      if (chunkOutputSize != ChunkOutputSize.Full) {\n         content_ = new FixedRatioWidget(frame_, \n               ChunkOutputUi.OUTPUT_ASPECT, \n               ChunkOutputUi.MAX_HTMLWIDGET_WIDTH);\n      }\n      else {\n         frame_.getElement().getStyle().setWidth(100, Unit.PCT);\n         content_ = frame_;\n      }\n\n      frame_.loadUrl(url, new Command()\n      {\n         @Override\n         public void execute()\n         {\n            Element body = frame_.getDocument().getBody();\n            Style bodyStyle = body.getStyle();\n            \n            bodyStyle.setPadding(0, Unit.PX);\n            bodyStyle.setMargin(0, Unit.PX);\n            onEditorThemeChanged(ChunkOutputWidget.getEditorColors());\n            \n            onRenderComplete.execute();\n         };\n      });\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showHtmlOutput(String url, NotebookHtmlMetadata metadata, \n         int ordinal, Command onRenderComplete)\n   {\n      addPage(new ChunkHtmlPage(url, metadata, ordinal, onRenderComplete));\n   }","id":98982,"modified_method":"@Override\n   public void showHtmlOutput(String url, NotebookHtmlMetadata metadata, \n         int ordinal, Command onRenderComplete)\n   {\n      addPage(new ChunkHtmlPage(url, metadata, ordinal, onRenderComplete, chunkOutputSize_));\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkOutputGallery(\n      ChunkOutputPresenter.Host host,\n      ChunkOutputSize chunkOutputSize)\n   {\n      pages_ = new ArrayList<ChunkOutputPage>();\n      host_ = host;\n      chunkOutputSize_ = chunkOutputSize;\n      initWidget(uiBinder.createAndBindUi(this));\n      content_ = new SimplePanel();\n      viewer_.add(content_);\n   }","id":98983,"modified_method":"public ChunkOutputGallery(\n      ChunkOutputPresenter.Host host,\n      ChunkOutputSize chunkOutputSize)\n   {\n      pages_ = new ArrayList<ChunkOutputPage>();\n      host_ = host;\n      chunkOutputSize_ = chunkOutputSize;\n      initWidget(uiBinder.createAndBindUi(this));\n      content_ = new SimplePanel();\n      viewer_.add(content_);\n\n      if (chunkOutputSize_ == ChunkOutputSize.Full)\n      {\n         addStyleName(style.expand());\n         content_.addStyleName(style.content());\n      }\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showPlotOutput(String url, NotebookPlotMetadata metadata,\n         int ordinal, Command onRenderComplete)\n   {\n      addPage(new ChunkPlotPage(url, metadata, ordinal, onRenderComplete));\n   }","id":98984,"modified_method":"@Override\n   public void showPlotOutput(String url, NotebookPlotMetadata metadata,\n         int ordinal, Command onRenderComplete)\n   {\n      addPage(new ChunkPlotPage(url, metadata, ordinal, onRenderComplete, chunkOutputSize_));\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void setActivePage(int idx)\n   {\n      // ignore if out of bounds or no-op\n      if (idx >= pages_.size())\n         return;\n      if (idx == activePage_)\n         return;\n\n      content_.clear();\n      content_.add(pages_.get(idx).contentWidget());\n      \n      // remove the selection styling from the previously active page (if any)\n      // and add it to this page\n      if (activePage_ >= 0)\n         pages_.get(activePage_).thumbnailWidget().removeStyleName(\n               style.selected());\n      pages_.get(idx).thumbnailWidget().addStyleName(style.selected());\n      pages_.get(idx).onSelected();\n      activePage_ = idx;\n      \n      // this page may have a different height than its predecessor\n      host_.notifyHeightChanged();\n   }","id":98985,"modified_method":"private void setActivePage(int idx)\n   {\n      // ignore if out of bounds or no-op\n      if (idx >= pages_.size())\n         return;\n      if (idx == activePage_)\n         return;\n\n      content_.clear();\n      content_.add(pages_.get(idx).contentWidget());\n      \n      // remove the selection styling from the previously active page (if any)\n      // and add it to this page\n      if (activePage_ >= 0)\n         pages_.get(activePage_).thumbnailWidget().removeStyleName(\n               style.selected());\n      pages_.get(idx).thumbnailWidget().addStyleName(style.selected());\n      pages_.get(idx).onSelected();\n      activePage_ = idx;\n      \n      // this page may have a different height than its predecessor\n      host_.notifyHeightChanged();\n      \n      if (pages_.get(idx) instanceof ChunkDataPage)\n      {\n         ((ChunkDataPage)pages_.get(idx)).onResize();\n      }\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"public List<ChunkOutputPage> extractPages()\n   {\n      // flush any errors so they are properly accounted for\n      flushQueuedErrors();\n      \n      List<ChunkOutputPage> pages = new ArrayList<ChunkOutputPage>();\n      for (Widget w: this)\n      {\n         // extract ordinal and metadata\n         JavaScriptObject metadata = null;\n         String ord = w.getElement().getAttribute(ORDINAL_ATTRIBUTE);\n         int ordinal = 0;\n         if (!StringUtil.isNullOrEmpty(ord))\n            ordinal = StringUtil.parseInt(ord, 0);\n         if (metadata_.containsKey(ordinal))\n            metadata = metadata_.get(ordinal);\n\n         if (w instanceof ChunkDataWidget)\n         {\n            ChunkDataWidget widget = (ChunkDataWidget)w;\n            ChunkDataPage data = new ChunkDataPage(widget, \n                  (NotebookFrameMetadata)metadata.cast(), ordinal);\n            pages.add(data);\n            remove(w);\n            continue;\n         }\n\n         // extract the inner element if this is a fixed-ratio widget (or just\n         // use raw if it's not)\n         Widget inner = w;\n         if (w instanceof FixedRatioWidget)\n            inner = ((FixedRatioWidget)w).getWidget();\n         \n         if (inner instanceof ChunkPlotWidget)\n         {\n            ChunkPlotWidget plot = (ChunkPlotWidget)inner;\n            ChunkPlotPage page = new ChunkPlotPage(plot.plotUrl(),\n                  plot.getMetadata(), ordinal, null);\n            pages.add(page);\n            remove(w);\n         }\n         else if (inner instanceof ChunkOutputFrame)\n         {\n            ChunkOutputFrame frame = (ChunkOutputFrame)inner;\n            ChunkHtmlPage html = new ChunkHtmlPage(frame.getUrl(), \n                  (NotebookHtmlMetadata)metadata.cast(), ordinal, null);\n            pages.add(html);\n            remove(w);\n         }\n      }\n      return pages;\n   }","id":98986,"modified_method":"public List<ChunkOutputPage> extractPages()\n   {\n      // flush any errors so they are properly accounted for\n      flushQueuedErrors();\n      \n      List<ChunkOutputPage> pages = new ArrayList<ChunkOutputPage>();\n      for (Widget w: this)\n      {\n         // extract ordinal and metadata\n         JavaScriptObject metadata = null;\n         String ord = w.getElement().getAttribute(ORDINAL_ATTRIBUTE);\n         int ordinal = 0;\n         if (!StringUtil.isNullOrEmpty(ord))\n            ordinal = StringUtil.parseInt(ord, 0);\n         if (metadata_.containsKey(ordinal))\n            metadata = metadata_.get(ordinal);\n\n         if (w instanceof ChunkDataWidget)\n         {\n            ChunkDataWidget widget = (ChunkDataWidget)w;\n            ChunkDataPage data = new ChunkDataPage(widget, \n                  (NotebookFrameMetadata)metadata.cast(), ordinal);\n            pages.add(data);\n            remove(w);\n            continue;\n         }\n\n         // extract the inner element if this is a fixed-ratio widget (or just\n         // use raw if it's not)\n         Widget inner = w;\n         if (w instanceof FixedRatioWidget)\n            inner = ((FixedRatioWidget)w).getWidget();\n         \n         if (inner instanceof ChunkPlotWidget)\n         {\n            ChunkPlotWidget plot = (ChunkPlotWidget)inner;\n            ChunkPlotPage page = new ChunkPlotPage(plot.plotUrl(),\n                  plot.getMetadata(), ordinal, null, chunkOutputSize_);\n            pages.add(page);\n            remove(w);\n         }\n         else if (inner instanceof ChunkOutputFrame)\n         {\n            ChunkOutputFrame frame = (ChunkOutputFrame)inner;\n            ChunkHtmlPage html = new ChunkHtmlPage(frame.getUrl(), \n                  (NotebookHtmlMetadata)metadata.cast(), ordinal, null, chunkOutputSize_);\n            pages.add(html);\n            remove(w);\n         }\n      }\n      return pages;\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkPlotPage(final String url, NotebookPlotMetadata metadata, \n         int ordinal, final Command onRenderComplete)\n   {\n      super(ordinal);\n      \n      thumbnail_ = new HTMLPanel(\"\");\n      \n      if (ChunkPlotWidget.isFixedSizePlotUrl(url))\n      {\n         final Image thumbnail = new Image();\n         thumbnail_.add(thumbnail);\n         thumbnail_.getElement().getStyle().setTextAlign(TextAlign.CENTER);\n\n         plot_ = new ChunkPlotWidget(url, metadata, new Command() \n         {\n            @Override\n            public void execute()\n            {\n               ImageElementEx plot = plot_.getElement().cast();\n               ImageElementEx img = thumbnail.getElement().cast();\n               if (plot.naturalHeight() < plot.naturalWidth())\n               {\n                  img.getStyle().setProperty(\"width\", \"100%\");\n                  img.getStyle().setProperty(\"height\", \"auto\");\n               }\n               else\n               {\n                  img.getStyle().setProperty(\"height\", \"100%\");\n                  img.getStyle().setProperty(\"width\", \"auto\");\n               }\n               thumbnail.setUrl(url);\n               onRenderComplete.execute();\n            }\n         });\n      }\n      else\n      {\n         // automatically expand non-fixed plots\n         thumbnail_.add(new FixedRatioWidget(new Image(url), \n                     ChunkOutputUi.OUTPUT_ASPECT, 100));\n         plot_ = new ChunkPlotWidget(url, metadata, onRenderComplete);\n      }\n      \n      // look for messages or warnings in metadata\n      boolean hasMessages = false;\n      boolean hasWarnings = false;\n      if (metadata != null)\n      {\n         for (int i = 0; i < metadata.getConditions().length(); i++)\n         {\n            int condition = metadata.getConditions().get(i).getInt(0);\n            if (condition == ChunkConditionBar.CONDITION_MESSAGE)\n               hasMessages = true;\n            else if (condition == ChunkConditionBar.CONDITION_WARNING)\n               hasWarnings = true;\n         }\n      }\n      \n      if (hasMessages || hasWarnings)\n      {\n         Image condImage = new Image();\n         if (hasWarnings)\n            condImage.setResource(ThemeResources.INSTANCE.warningSmall());\n         else if (hasMessages)\n            condImage.setResource(ThemeResources.INSTANCE.infoSmall());\n         condImage.setWidth(\"8px\");\n         condImage.setHeight(\"7px\");\n         Style style = condImage.getElement().getStyle();\n         style.setPosition(Position.ABSOLUTE);\n         style.setBottom(5, Unit.PX);\n         style.setRight(5, Unit.PX);\n         thumbnail_.add(condImage);\n      }\n   }","id":98987,"modified_method":"public ChunkPlotPage(final String url, NotebookPlotMetadata metadata, \n         int ordinal, final Command onRenderComplete, ChunkOutputSize chunkOutputSize)\n   {\n      super(ordinal);\n      \n      thumbnail_ = new HTMLPanel(\"\");\n      \n      if (ChunkPlotWidget.isFixedSizePlotUrl(url))\n      {\n         final Image thumbnail = new Image();\n         thumbnail_.add(thumbnail);\n         thumbnail_.getElement().getStyle().setTextAlign(TextAlign.CENTER);\n\n         plot_ = new ChunkPlotWidget(url, metadata, new Command() \n         {\n            @Override\n            public void execute()\n            {\n               ImageElementEx plot = plot_.getElement().cast();\n               ImageElementEx img = thumbnail.getElement().cast();\n               if (plot.naturalHeight() < plot.naturalWidth())\n               {\n                  img.getStyle().setProperty(\"width\", \"100%\");\n                  img.getStyle().setProperty(\"height\", \"auto\");\n               }\n               else\n               {\n                  img.getStyle().setProperty(\"height\", \"100%\");\n                  img.getStyle().setProperty(\"width\", \"auto\");\n               }\n               thumbnail.setUrl(url);\n               onRenderComplete.execute();\n            }\n         });\n      }\n      else\n      {\n         // automatically expand non-fixed plots\n         thumbnail_.add(new FixedRatioWidget(new Image(url), \n                     ChunkOutputUi.OUTPUT_ASPECT, 100));\n         plot_ = new ChunkPlotWidget(url, metadata, onRenderComplete, chunkOutputSize);\n      }\n      \n      // look for messages or warnings in metadata\n      boolean hasMessages = false;\n      boolean hasWarnings = false;\n      if (metadata != null)\n      {\n         for (int i = 0; i < metadata.getConditions().length(); i++)\n         {\n            int condition = metadata.getConditions().get(i).getInt(0);\n            if (condition == ChunkConditionBar.CONDITION_MESSAGE)\n               hasMessages = true;\n            else if (condition == ChunkConditionBar.CONDITION_WARNING)\n               hasWarnings = true;\n         }\n      }\n      \n      if (hasMessages || hasWarnings)\n      {\n         Image condImage = new Image();\n         if (hasWarnings)\n            condImage.setResource(ThemeResources.INSTANCE.warningSmall());\n         else if (hasMessages)\n            condImage.setResource(ThemeResources.INSTANCE.infoSmall());\n         condImage.setWidth(\"8px\");\n         condImage.setHeight(\"7px\");\n         Style style = condImage.getElement().getStyle();\n         style.setPosition(Position.ABSOLUTE);\n         style.setBottom(5, Unit.PX);\n         style.setRight(5, Unit.PX);\n         thumbnail_.add(condImage);\n      }\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkPlotWidget(String url, NotebookPlotMetadata metadata, \n         final Command onRenderComplete, ChunkOutputSize chunkOutputSize)\n   {\n      plot_ = new Image();\n      url_ = url;\n      metadata_ = metadata;\n      chunkOutputSize_ = chunkOutputSize;\n\n      DOM.sinkEvents(plot_.getElement(), Event.ONLOAD);\n      DOM.setEventListener(plot_.getElement(), \n         new EventListener()\n         {\n            @Override\n            public void onBrowserEvent(Event event)\n            {\n               if (DOM.eventGetType(event) != Event.ONLOAD)\n                  return;\n               \n               // if the image is of fixed size, just clamp its width to the\n               // editor surface while preserving its aspect ratio\n               if (isFixedSizePlotUrl(plot_.getUrl()))\n               {\n                  ImageElementEx img = plot_.getElement().cast();\n                  img.getStyle().setProperty(\"height\", \"auto\");\n                  img.getStyle().setProperty(\"maxWidth\", \"100%\");\n               }\n                  \n               plot_.setVisible(true);\n               if (onRenderComplete != null)\n                  onRenderComplete.execute();\n            }\n         });\n      \n      // start loading\n      plot_.setUrl(url);\n      Widget root = plot_;\n      \n      if (isFixedSizePlotUrl(url))\n      {\n         // if the plot is of fixed size, emit it directly, but make it\n         // initially invisible until we get sizing information (as we may \n         // have to downsample)\n         plot_.setVisible(false);\n      }\n      else if (chunkOutputSize_ == ChunkOutputSize.Full)\n      {\n         HTMLPanel panel = new HTMLPanel(\"\");\n         \n         panel.getElement().getStyle().setWidth(100, Unit.PCT);\n         panel.getElement().getStyle().setHeight(100, Unit.PCT);\n\n         plot_.getElement().getStyle().setWidth(100, Unit.PCT);\n         plot_.getElement().getStyle().setHeight(100, Unit.PCT);\n         \n         panel.add(plot_);\n         host_ = panel;\n         root = panel;\n      }\n      else\n      {\n         // if we can scale the plot, scale it\n         FixedRatioWidget fixedFrame = new FixedRatioWidget(plot_, \n                     ChunkOutputUi.OUTPUT_ASPECT, \n                     ChunkOutputUi.MAX_PLOT_WIDTH);\n         host_ = fixedFrame;\n         root = fixedFrame;\n      }\n      \n      // if there's metadata to display, further wrap the widget with it\n      if (metadata != null && metadata.getConditions().length() > 0)\n      {\n         // otherwise, group with metadata\n         VerticalPanel outer = new VerticalPanel();\n         conditions_ = new ChunkConditionBar(metadata.getConditions());\n         conditions_.onEditorThemeChanged(ChunkOutputWidget.getEditorColors());\n         outer.add(conditions_);\n         outer.add(root);\n         outer.setHeight(\"100%\");\n         outer.setWidth(\"100%\");\n         root = outer;\n      }\n      \n      initWidget(root);\n   }","id":98988,"modified_method":"public ChunkPlotWidget(String url, NotebookPlotMetadata metadata, \n         final Command onRenderComplete, ChunkOutputSize chunkOutputSize)\n   {\n      plot_ = new Image();\n      url_ = url;\n      metadata_ = metadata;\n      chunkOutputSize_ = chunkOutputSize;\n\n      DOM.sinkEvents(plot_.getElement(), Event.ONLOAD);\n      DOM.setEventListener(plot_.getElement(), \n         new EventListener()\n         {\n            @Override\n            public void onBrowserEvent(Event event)\n            {\n               if (DOM.eventGetType(event) != Event.ONLOAD)\n                  return;\n               \n               // if the image is of fixed size, just clamp its width to the\n               // editor surface while preserving its aspect ratio\n               if (isFixedSizePlotUrl(plot_.getUrl()))\n               {\n                  ImageElementEx img = plot_.getElement().cast();\n                  img.getStyle().setProperty(\"height\", \"auto\");\n                  img.getStyle().setProperty(\"maxWidth\", \"100%\");\n               }\n                  \n               plot_.setVisible(true);\n               if (onRenderComplete != null)\n                  onRenderComplete.execute();\n            }\n         });\n      \n      // start loading\n      plot_.setUrl(url);\n      Widget root = plot_;\n      \n      if (isFixedSizePlotUrl(url))\n      {\n         // if the plot is of fixed size, emit it directly, but make it\n         // initially invisible until we get sizing information (as we may \n         // have to downsample)\n         plot_.setVisible(false);\n      }\n      else if (chunkOutputSize_ == ChunkOutputSize.Full)\n      {\n         HTMLPanel panel = new HTMLPanel(\"\");\n         \n         panel.getElement().getStyle().setWidth(100, Unit.PCT);\n         panel.getElement().getStyle().setHeight(100, Unit.PCT);\n         panel.getElement().getStyle().setProperty(\"display\", \"flex\");\n\n         plot_.getElement().getStyle().setWidth(100, Unit.PCT);\n         \n         panel.add(plot_);\n         host_ = panel;\n         root = panel;\n      }\n      else\n      {\n         // if we can scale the plot, scale it\n         FixedRatioWidget fixedFrame = new FixedRatioWidget(plot_, \n                     ChunkOutputUi.OUTPUT_ASPECT, \n                     ChunkOutputUi.MAX_PLOT_WIDTH);\n         host_ = fixedFrame;\n         root = fixedFrame;\n      }\n      \n      // if there's metadata to display, further wrap the widget with it\n      if (metadata != null && metadata.getConditions().length() > 0)\n      {\n         // otherwise, group with metadata\n         VerticalPanel outer = new VerticalPanel();\n         conditions_ = new ChunkConditionBar(metadata.getConditions());\n         conditions_.onEditorThemeChanged(ChunkOutputWidget.getEditorColors());\n         outer.add(conditions_);\n         outer.add(root);\n         outer.setHeight(\"100%\");\n         outer.setWidth(\"100%\");\n         root = outer;\n      }\n      \n      initWidget(root);\n   }","commit_id":"f87ed6b809dfa793a3160e3b5761d919a7bf51d7","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkDataWidget(JavaScriptObject data, ChunkOutputSize chunkOutputSize)\n   {\n      data_ = data;\n      chunkOutputSize_ = chunkOutputSize;\n\n      if (chunkOutputSize_ == ChunkOutputSize.Full) {\n         getElement().getStyle().setWidth(100, Unit.PCT);\n         getElement().getStyle().setHeight(100, Unit.PCT);\n      }\n\n      initPagedTableOrDelay();\n   }","id":98989,"modified_method":"public ChunkDataWidget(JavaScriptObject data, ChunkOutputSize chunkOutputSize)\n   {\n      data_ = data;\n      chunkOutputSize_ = chunkOutputSize;\n\n      if (chunkOutputSize_ == ChunkOutputSize.Full) {\n         getElement().getStyle().setWidth(100, Unit.PCT);\n\n         getElement().getStyle().setProperty(\"display\", \"-ms-flexbox\");\n         getElement().getStyle().setProperty(\"display\", \"-webkit-flex\");\n         getElement().getStyle().setProperty(\"display\", \"flex\");\n      }\n\n      initPagedTableOrDelay();\n   }","commit_id":"a144ba0a435705963ef6721ad086e775d13741c2","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkOutputStream(ChunkOutputPresenter.Host host, ChunkOutputSize chunkOutputSize)\n   {\n      host_ = host;\n      chunkOutputSize_ = chunkOutputSize;\n      metadata_ = new HashMap<Integer, JavaScriptObject>();\n\n      if (chunkOutputSize_ == ChunkOutputSize.Full) {\n         getElement().getStyle().setWidth(100, Unit.PCT);\n         getElement().getStyle().setHeight(100, Unit.PCT);\n      }\n   }","id":98990,"modified_method":"public ChunkOutputStream(ChunkOutputPresenter.Host host, ChunkOutputSize chunkOutputSize)\n   {\n      host_ = host;\n      chunkOutputSize_ = chunkOutputSize;\n      metadata_ = new HashMap<Integer, JavaScriptObject>();\n\n      if (chunkOutputSize_ == ChunkOutputSize.Full) {\n         getElement().getStyle().setWidth(100, Unit.PCT);\n\n         getElement().getStyle().setProperty(\"display\", \"-ms-flexbox\");\n         getElement().getStyle().setProperty(\"display\", \"-webkit-flex\");\n         getElement().getStyle().setProperty(\"display\", \"flex\");\n      }\n   }","commit_id":"a144ba0a435705963ef6721ad086e775d13741c2","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkPlotWidget(String url, NotebookPlotMetadata metadata, \n         final Command onRenderComplete, ChunkOutputSize chunkOutputSize)\n   {\n      plot_ = new Image();\n      url_ = url;\n      metadata_ = metadata;\n      chunkOutputSize_ = chunkOutputSize;\n\n      DOM.sinkEvents(plot_.getElement(), Event.ONLOAD);\n      DOM.setEventListener(plot_.getElement(), \n         new EventListener()\n         {\n            @Override\n            public void onBrowserEvent(Event event)\n            {\n               if (DOM.eventGetType(event) != Event.ONLOAD)\n                  return;\n               \n               // if the image is of fixed size, just clamp its width to the\n               // editor surface while preserving its aspect ratio\n               if (isFixedSizePlotUrl(plot_.getUrl()))\n               {\n                  ImageElementEx img = plot_.getElement().cast();\n                  img.getStyle().setProperty(\"height\", \"auto\");\n                  img.getStyle().setProperty(\"maxWidth\", \"100%\");\n               }\n                  \n               plot_.setVisible(true);\n               if (onRenderComplete != null)\n                  onRenderComplete.execute();\n            }\n         });\n      \n      // start loading\n      plot_.setUrl(url);\n      Widget root = plot_;\n      \n      if (isFixedSizePlotUrl(url))\n      {\n         // if the plot is of fixed size, emit it directly, but make it\n         // initially invisible until we get sizing information (as we may \n         // have to downsample)\n         plot_.setVisible(false);\n      }\n      else if (chunkOutputSize_ == ChunkOutputSize.Full)\n      {\n         HTMLPanel panel = new HTMLPanel(\"\");\n         \n         panel.getElement().getStyle().setWidth(100, Unit.PCT);\n         panel.getElement().getStyle().setHeight(100, Unit.PCT);\n         panel.getElement().getStyle().setProperty(\"display\", \"flex\");\n\n         plot_.getElement().getStyle().setWidth(100, Unit.PCT);\n         \n         panel.add(plot_);\n         host_ = panel;\n         root = panel;\n      }\n      else\n      {\n         // if we can scale the plot, scale it\n         FixedRatioWidget fixedFrame = new FixedRatioWidget(plot_, \n                     ChunkOutputUi.OUTPUT_ASPECT, \n                     ChunkOutputUi.MAX_PLOT_WIDTH);\n         host_ = fixedFrame;\n         root = fixedFrame;\n      }\n      \n      // if there's metadata to display, further wrap the widget with it\n      if (metadata != null && metadata.getConditions().length() > 0)\n      {\n         // otherwise, group with metadata\n         VerticalPanel outer = new VerticalPanel();\n         conditions_ = new ChunkConditionBar(metadata.getConditions());\n         conditions_.onEditorThemeChanged(ChunkOutputWidget.getEditorColors());\n         outer.add(conditions_);\n         outer.add(root);\n         outer.setHeight(\"100%\");\n         outer.setWidth(\"100%\");\n         root = outer;\n      }\n      \n      initWidget(root);\n   }","id":98991,"modified_method":"public ChunkPlotWidget(String url, NotebookPlotMetadata metadata, \n         final Command onRenderComplete, ChunkOutputSize chunkOutputSize)\n   {\n      plot_ = new Image();\n      url_ = url;\n      metadata_ = metadata;\n      chunkOutputSize_ = chunkOutputSize;\n\n      DOM.sinkEvents(plot_.getElement(), Event.ONLOAD);\n      DOM.setEventListener(plot_.getElement(), \n         new EventListener()\n         {\n            @Override\n            public void onBrowserEvent(Event event)\n            {\n               if (DOM.eventGetType(event) != Event.ONLOAD)\n                  return;\n               \n               // if the image is of fixed size, just clamp its width to the\n               // editor surface while preserving its aspect ratio\n               if (isFixedSizePlotUrl(plot_.getUrl()))\n               {\n                  ImageElementEx img = plot_.getElement().cast();\n                  img.getStyle().setProperty(\"height\", \"auto\");\n                  img.getStyle().setProperty(\"maxWidth\", \"100%\");\n               }\n                  \n               plot_.setVisible(true);\n               if (onRenderComplete != null)\n                  onRenderComplete.execute();\n            }\n         });\n      \n      // start loading\n      plot_.setUrl(url);\n      Widget root = plot_;\n      \n      if (isFixedSizePlotUrl(url))\n      {\n         // if the plot is of fixed size, emit it directly, but make it\n         // initially invisible until we get sizing information (as we may \n         // have to downsample)\n         plot_.setVisible(false);\n      }\n      else if (chunkOutputSize_ == ChunkOutputSize.Full)\n      {\n         HTMLPanel panel = new HTMLPanel(\"\");\n         \n         panel.getElement().getStyle().setWidth(100, Unit.PCT);\n         \n         panel.getElement().getStyle().setProperty(\"display\", \"-ms-flexbox\");\n         panel.getElement().getStyle().setProperty(\"display\", \"-webkit-flex\");\n         panel.getElement().getStyle().setProperty(\"display\", \"flex\");\n\n         plot_.getElement().getStyle().setProperty(\"display\", \"-ms-flexbox\");\n         plot_.getElement().getStyle().setProperty(\"display\", \"-webkit-flex\");\n         plot_.getElement().getStyle().setProperty(\"display\", \"flex\");\n\n         plot_.getElement().getStyle().setWidth(100, Unit.PCT);\n         \n         panel.add(plot_);\n         host_ = panel;\n         root = panel;\n      }\n      else\n      {\n         // if we can scale the plot, scale it\n         FixedRatioWidget fixedFrame = new FixedRatioWidget(plot_, \n                     ChunkOutputUi.OUTPUT_ASPECT, \n                     ChunkOutputUi.MAX_PLOT_WIDTH);\n         host_ = fixedFrame;\n         root = fixedFrame;\n      }\n      \n      // if there's metadata to display, further wrap the widget with it\n      if (metadata != null && metadata.getConditions().length() > 0)\n      {\n         // otherwise, group with metadata\n         VerticalPanel outer = new VerticalPanel();\n         conditions_ = new ChunkConditionBar(metadata.getConditions());\n         conditions_.onEditorThemeChanged(ChunkOutputWidget.getEditorColors());\n         outer.add(conditions_);\n         outer.add(root);\n         outer.setHeight(\"100%\");\n         outer.setWidth(\"100%\");\n         root = outer;\n      }\n      \n      initWidget(root);\n   }","commit_id":"a144ba0a435705963ef6721ad086e775d13741c2","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Nullable\n  public StructureViewBuilder getStructureViewBuilder(@NotNull final FileType fileType, @NotNull final VirtualFile file, @NotNull final Project project) {\n    if (fileType instanceof LanguageFileType) {\n      final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n      return psiFile == null ?  null : LanguageStructureViewBuilder.INSTANCE.forLanguage(((LanguageFileType)fileType).getLanguage())\n        .getStructureViewBuilder(psiFile);\n    }\n\n    return null;\n  }","id":98992,"modified_method":"@Nullable\n  public StructureViewBuilder getStructureViewBuilder(@NotNull final FileType fileType, @NotNull final VirtualFile file, @NotNull final Project project) {\n    if (fileType instanceof LanguageFileType) {\n      final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n      if (psiFile == null) return null;\n      final PsiStructureViewFactory factory = LanguageStructureViewBuilder.INSTANCE.forLanguage(((LanguageFileType)fileType).getLanguage());\n      return factory == null ?  null : factory.getStructureViewBuilder(psiFile);\n    }\n\n    return null;\n  }","commit_id":"e7a4b6b09b4360dd251eaf7548bf7f7b3122d554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public SuppressQuickFix[] getBatchSuppressActions(@Nullable PsiElement element) {\n    if (element != null) {\n      THashSet<SuppressQuickFix> fixes = new THashSet<SuppressQuickFix>(new TObjectHashingStrategy<SuppressQuickFix>() {\n        @Override\n        public int computeHashCode(SuppressQuickFix object) {\n          return object.getName().hashCode();\n        }\n\n        @Override\n        public boolean equals(SuppressQuickFix o1, SuppressQuickFix o2) {\n          return o1.getName().equals(o2.getName());\n        }\n      });\n      Set<InspectionSuppressor> suppressors = getSuppressors(element);\n      for (InspectionSuppressor suppressor : suppressors) {\n        if (suppressor != null) {\n          SuppressQuickFix[] actions = suppressor.getSuppressActions(element, getShortName());\n          fixes.addAll(Arrays.asList(actions));\n        }\n      }\n      return fixes.toArray(new SuppressQuickFix[fixes.size()]);\n    }\n    return SuppressQuickFix.EMPTY_ARRAY;\n  }","id":98993,"modified_method":"@NotNull\n  @Override\n  public SuppressQuickFix[] getBatchSuppressActions(@Nullable PsiElement element) {\n    if (element != null) {\n      THashSet<SuppressQuickFix> fixes = new THashSet<SuppressQuickFix>(new TObjectHashingStrategy<SuppressQuickFix>() {\n        @Override\n        public int computeHashCode(SuppressQuickFix object) {\n          return object.getName().hashCode();\n        }\n\n        @Override\n        public boolean equals(SuppressQuickFix o1, SuppressQuickFix o2) {\n          return o1.getName().equals(o2.getName());\n        }\n      });\n      Set<InspectionSuppressor> suppressors = getSuppressors(element);\n      for (InspectionSuppressor suppressor : suppressors) {\n        SuppressQuickFix[] actions = suppressor.getSuppressActions(element, getShortName());\n        fixes.addAll(Arrays.asList(actions));\n      }\n      return fixes.toArray(new SuppressQuickFix[fixes.size()]);\n    }\n    return SuppressQuickFix.EMPTY_ARRAY;\n  }","commit_id":"b76c069fce2f8880a30a1e0ae8528fd9c6db2ab3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Set<InspectionSuppressor> getSuppressors(@NotNull PsiElement element) {\n    FileViewProvider viewProvider = element.getContainingFile().getViewProvider();\n    if (viewProvider instanceof TemplateLanguageFileViewProvider) {\n      LinkedHashSet<InspectionSuppressor> suppressors = new LinkedHashSet<InspectionSuppressor>();\n      ContainerUtil.addIfNotNull(suppressors, LanguageInspectionSuppressors.INSTANCE.forLanguage(viewProvider.getBaseLanguage()));\n      for (Language language : viewProvider.getLanguages()) {\n        ContainerUtil.addIfNotNull(suppressors, LanguageInspectionSuppressors.INSTANCE.forLanguage(language));\n      }\n      ContainerUtil.addIfNotNull(suppressors, LanguageInspectionSuppressors.INSTANCE.forLanguage(element.getLanguage()));\n      return suppressors;\n    }\n    return Collections.singleton(LanguageInspectionSuppressors.INSTANCE.forLanguage(element.getLanguage()));\n  }","id":98994,"modified_method":"public static Set<InspectionSuppressor> getSuppressors(@NotNull PsiElement element) {\n    FileViewProvider viewProvider = element.getContainingFile().getViewProvider();\n    final InspectionSuppressor elementLanguageSuppressor = LanguageInspectionSuppressors.INSTANCE.forLanguage(element.getLanguage());\n    if (viewProvider instanceof TemplateLanguageFileViewProvider) {\n      LinkedHashSet<InspectionSuppressor> suppressors = new LinkedHashSet<InspectionSuppressor>();\n      ContainerUtil.addIfNotNull(suppressors, LanguageInspectionSuppressors.INSTANCE.forLanguage(viewProvider.getBaseLanguage()));\n      for (Language language : viewProvider.getLanguages()) {\n        ContainerUtil.addIfNotNull(suppressors, LanguageInspectionSuppressors.INSTANCE.forLanguage(language));\n      }\n      ContainerUtil.addIfNotNull(suppressors, elementLanguageSuppressor);\n      return suppressors;\n    }\n    return elementLanguageSuppressor != null ? Collections.singleton(elementLanguageSuppressor) : Collections.<InspectionSuppressor>emptySet();\n  }","commit_id":"b76c069fce2f8880a30a1e0ae8528fd9c6db2ab3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isSuppressedFor(@NotNull PsiElement element) {\n    Set<InspectionSuppressor> suppressors = getSuppressors(element);\n    for (InspectionSuppressor suppressor : suppressors) {\n      if (suppressor != null && isSuppressed(suppressor, element)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":98995,"modified_method":"@Override\n  public boolean isSuppressedFor(@NotNull PsiElement element) {\n    Set<InspectionSuppressor> suppressors = getSuppressors(element);\n    for (InspectionSuppressor suppressor : suppressors) {\n      if (isSuppressed(suppressor, element)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"b76c069fce2f8880a30a1e0ae8528fd9c6db2ab3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RefactoringActionHandler getHandler(DataContext dataContext) {\n    PsiFile file = LangDataKeys.PSI_FILE.getData(dataContext);\n    if (file == null) return null;\n    return LanguageExtractInclude.INSTANCE.forLanguage(file.getViewProvider().getBaseLanguage());\n  }","id":98996,"modified_method":"public RefactoringActionHandler getHandler(DataContext dataContext) {\n    PsiFile file = LangDataKeys.PSI_FILE.getData(dataContext);\n    if (file == null) return null;\n    final RefactoringSupportProvider supportProvider = LanguageRefactoringSupport.INSTANCE.forLanguage(file.getViewProvider().getBaseLanguage());\n    return supportProvider != null ? supportProvider.getPullUpHandler() : null;\n  }","commit_id":"7484f6b2cf91f0ae5f7d685832285624753460f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RefactoringActionHandler getHandler(DataContext dataContext) {\n    PsiFile file = LangDataKeys.PSI_FILE.getData(dataContext);\n    if (file == null) return null;\n    return LanguageExtractInclude.INSTANCE.forLanguage(file.getViewProvider().getBaseLanguage());\n  }","id":98997,"modified_method":"public RefactoringActionHandler getHandler(DataContext dataContext) {\n    PsiFile file = LangDataKeys.PSI_FILE.getData(dataContext);\n    if (file == null) return null;\n    final RefactoringSupportProvider supportProvider = LanguageRefactoringSupport.INSTANCE.forLanguage(file.getViewProvider().getBaseLanguage());\n    return supportProvider != null ? supportProvider.getPullUpHandler() : null;\n  }","commit_id":"7484f6b2cf91f0ae5f7d685832285624753460f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isValidForFile(Project project, Editor editor, final PsiFile file) {\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter() != null;\n    }\n\n    final Language lang = file.getLanguage();\n    if (lang == null) return false;\n    final Commenter commenter = LanguageCommenters.INSTANCE.forLanguage(lang);\n    if (commenter == null) return false;\n    return commenter.getBlockCommentPrefix() != null && commenter.getBlockCommentSuffix() != null;\n  }","id":98998,"modified_method":"protected boolean isValidForFile(Project project, Editor editor, final PsiFile file) {\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter() != null;\n    }\n\n    Commenter commenter = LanguageCommenters.INSTANCE.forLanguage(file.getLanguage());\n    if (commenter == null) commenter = LanguageCommenters.INSTANCE.forLanguage(file.getViewProvider().getBaseLanguage());\n    if (commenter == null) return false;\n    return commenter.getBlockCommentPrefix() != null && commenter.getBlockCommentSuffix() != null;\n  }","commit_id":"9eae0ab2283fbbf295ad89852ab1087c064dcd4c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Commenter findCommenter(PsiFile file, Editor editor) {\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter();\n    }\n\n    Language lang = PsiUtilBase.getLanguageInEditor(editor, file.getProject());\n\n    if (lang == null || LanguageCommenters.INSTANCE.forLanguage(lang) == null) {\n      lang = file.getLanguage();\n    }\n    return LanguageCommenters.INSTANCE.forLanguage(lang);\n  }","id":98999,"modified_method":"private static Commenter findCommenter(PsiFile file, Editor editor) {\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter();\n    }\n\n    Language lang = PsiUtilBase.getLanguageInEditor(editor, file.getProject());\n\n    if (lang == null || LanguageCommenters.INSTANCE.forLanguage(lang) == null) {\n      lang = file.getLanguage();\n    }\n    if (lang == null || LanguageCommenters.INSTANCE.forLanguage(lang) == null) {\n      lang = file.getViewProvider().getBaseLanguage();\n    }\n    return LanguageCommenters.INSTANCE.forLanguage(lang);\n  }","commit_id":"9eae0ab2283fbbf295ad89852ab1087c064dcd4c","url":"https://github.com/JetBrains/intellij-community"}]